(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module boxed.
  (* StructTuple
    {
      name := "Box";
      ty_params := [ "T"; "A" ];
      fields := [ Ty.apply (Ty.path "core::ptr::unique::Unique") [ T ]; A ];
    } *)
  
  Module Impl_alloc_boxed_Box_T_alloc_alloc_Global.
    Definition Self (T : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "alloc::boxed::Box") [ T; Ty.path "alloc::alloc::Global" ].
    
    (*
        pub fn new(x: T) -> Self {
            #[rustc_box]
            Box::new(x)
        }
    *)
    Definition new (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match τ, α with
      | [], [ x ] =>
        ltac:(M.monadic
          (let x := M.alloc (| x |) in
          M.read (|
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply (Ty.path "alloc::boxed::Box") [ T; Ty.path "alloc::alloc::Global" ],
                "new",
                []
              |),
              [ x ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_new : forall (T : Ty.t), M.IsAssociatedFunction (Self T) "new" (new T).
    
    (*
        pub fn new_uninit() -> Box<mem::MaybeUninit<T>> {
            Self::new_uninit_in(Global)
        }
    *)
    Definition new_uninit (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match τ, α with
      | [], [] =>
        ltac:(M.monadic
          (M.call_closure (|
            M.get_associated_function (|
              Ty.apply (Ty.path "alloc::boxed::Box") [ T; Ty.path "alloc::alloc::Global" ],
              "new_uninit_in",
              []
            |),
            [ Value.StructTuple "alloc::alloc::Global" [] ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_new_uninit :
      forall (T : Ty.t),
      M.IsAssociatedFunction (Self T) "new_uninit" (new_uninit T).
    
    (*
        pub fn new_zeroed() -> Box<mem::MaybeUninit<T>> {
            Self::new_zeroed_in(Global)
        }
    *)
    Definition new_zeroed (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match τ, α with
      | [], [] =>
        ltac:(M.monadic
          (M.call_closure (|
            M.get_associated_function (|
              Ty.apply (Ty.path "alloc::boxed::Box") [ T; Ty.path "alloc::alloc::Global" ],
              "new_zeroed_in",
              []
            |),
            [ Value.StructTuple "alloc::alloc::Global" [] ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_new_zeroed :
      forall (T : Ty.t),
      M.IsAssociatedFunction (Self T) "new_zeroed" (new_zeroed T).
    
    (*
        pub fn pin(x: T) -> Pin<Box<T>> {
            Box::new(x).into()
        }
    *)
    Definition pin (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match τ, α with
      | [], [ x ] =>
        ltac:(M.monadic
          (let x := M.alloc (| x |) in
          M.call_closure (|
            M.get_trait_method (|
              "core::convert::Into",
              Ty.apply (Ty.path "alloc::boxed::Box") [ T; Ty.path "alloc::alloc::Global" ],
              [
                Ty.apply
                  (Ty.path "core::pin::Pin")
                  [ Ty.apply (Ty.path "alloc::boxed::Box") [ T; Ty.path "alloc::alloc::Global" ] ]
              ],
              "into",
              []
            |),
            [
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply (Ty.path "alloc::boxed::Box") [ T; Ty.path "alloc::alloc::Global" ],
                  "new",
                  []
                |),
                [ M.read (| x |) ]
              |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_pin : forall (T : Ty.t), M.IsAssociatedFunction (Self T) "pin" (pin T).
    
    (*
        pub fn try_new(x: T) -> Result<Self, AllocError> {
            Self::try_new_in(x, Global)
        }
    *)
    Definition try_new (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match τ, α with
      | [], [ x ] =>
        ltac:(M.monadic
          (let x := M.alloc (| x |) in
          M.call_closure (|
            M.get_associated_function (|
              Ty.apply (Ty.path "alloc::boxed::Box") [ T; Ty.path "alloc::alloc::Global" ],
              "try_new_in",
              []
            |),
            [ M.read (| x |); Value.StructTuple "alloc::alloc::Global" [] ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_try_new :
      forall (T : Ty.t),
      M.IsAssociatedFunction (Self T) "try_new" (try_new T).
    
    (*
        pub fn try_new_uninit() -> Result<Box<mem::MaybeUninit<T>>, AllocError> {
            Box::try_new_uninit_in(Global)
        }
    *)
    Definition try_new_uninit (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match τ, α with
      | [], [] =>
        ltac:(M.monadic
          (M.call_closure (|
            M.get_associated_function (|
              Ty.apply (Ty.path "alloc::boxed::Box") [ T; Ty.path "alloc::alloc::Global" ],
              "try_new_uninit_in",
              []
            |),
            [ Value.StructTuple "alloc::alloc::Global" [] ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_try_new_uninit :
      forall (T : Ty.t),
      M.IsAssociatedFunction (Self T) "try_new_uninit" (try_new_uninit T).
    
    (*
        pub fn try_new_zeroed() -> Result<Box<mem::MaybeUninit<T>>, AllocError> {
            Box::try_new_zeroed_in(Global)
        }
    *)
    Definition try_new_zeroed (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match τ, α with
      | [], [] =>
        ltac:(M.monadic
          (M.call_closure (|
            M.get_associated_function (|
              Ty.apply (Ty.path "alloc::boxed::Box") [ T; Ty.path "alloc::alloc::Global" ],
              "try_new_zeroed_in",
              []
            |),
            [ Value.StructTuple "alloc::alloc::Global" [] ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_try_new_zeroed :
      forall (T : Ty.t),
      M.IsAssociatedFunction (Self T) "try_new_zeroed" (try_new_zeroed T).
    (*
        pub unsafe fn from_raw(raw: *mut T) -> Self {
            unsafe { Self::from_raw_in(raw, Global) }
        }
    *)
    Definition from_raw (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match τ, α with
      | [], [ raw ] =>
        ltac:(M.monadic
          (let raw := M.alloc (| raw |) in
          M.call_closure (|
            M.get_associated_function (|
              Ty.apply (Ty.path "alloc::boxed::Box") [ T; Ty.path "alloc::alloc::Global" ],
              "from_raw_in",
              []
            |),
            [ M.read (| raw |); Value.StructTuple "alloc::alloc::Global" [] ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_from_raw :
      forall (T : Ty.t),
      M.IsAssociatedFunction (Self T) "from_raw" (from_raw T).
  End Impl_alloc_boxed_Box_T_alloc_alloc_Global.
  
  Module Impl_alloc_boxed_Box_T_A.
    Definition Self (T A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::boxed::Box") [ T; A ].
    
    (*
        pub fn new_in(x: T, alloc: A) -> Self
        where
            A: Allocator,
        {
            let mut boxed = Self::new_uninit_in(alloc);
            unsafe {
                boxed.as_mut_ptr().write(x);
                boxed.assume_init()
            }
        }
    *)
    Definition new_in (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match τ, α with
      | [], [ x; alloc ] =>
        ltac:(M.monadic
          (let x := M.alloc (| x |) in
          let alloc := M.alloc (| alloc |) in
          M.read (|
            let boxed :=
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "alloc::boxed::Box") [ T; A ],
                    "new_uninit_in",
                    []
                  |),
                  [ M.read (| alloc |) ]
                |)
              |) in
            let _ :=
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.apply (Ty.path "*mut") [ T ], "write", [] |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ T ],
                        "as_mut_ptr",
                        []
                      |),
                      [ M.read (| boxed |) ]
                    |);
                    M.read (| x |)
                  ]
                |)
              |) in
            M.alloc (|
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "alloc::boxed::Box")
                    [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ T ]; A ],
                  "assume_init",
                  []
                |),
                [ M.read (| boxed |) ]
              |)
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_new_in :
      forall (T A : Ty.t),
      M.IsAssociatedFunction (Self T A) "new_in" (new_in T A).
    
    (*
        pub fn try_new_in(x: T, alloc: A) -> Result<Self, AllocError>
        where
            A: Allocator,
        {
            let mut boxed = Self::try_new_uninit_in(alloc)?;
            unsafe {
                boxed.as_mut_ptr().write(x);
                Ok(boxed.assume_init())
            }
        }
    *)
    Definition try_new_in (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match τ, α with
      | [], [ x; alloc ] =>
        ltac:(M.monadic
          (let x := M.alloc (| x |) in
          let alloc := M.alloc (| alloc |) in
          M.catch_return (|
            ltac:(M.monadic
              (M.read (|
                let boxed :=
                  M.copy (|
                    M.match_operator (|
                      M.alloc (|
                        M.call_closure (|
                          M.get_trait_method (|
                            "core::ops::try_trait::Try",
                            Ty.apply
                              (Ty.path "core::result::Result")
                              [
                                Ty.apply
                                  (Ty.path "alloc::boxed::Box")
                                  [
                                    Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ T ];
                                    A
                                  ];
                                Ty.path "core::alloc::AllocError"
                              ],
                            [],
                            "branch",
                            []
                          |),
                          [
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply (Ty.path "alloc::boxed::Box") [ T; A ],
                                "try_new_uninit_in",
                                []
                              |),
                              [ M.read (| alloc |) ]
                            |)
                          ]
                        |)
                      |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "core::ops::control_flow::ControlFlow::Break",
                                0
                              |) in
                            let residual := M.copy (| γ0_0 |) in
                            M.alloc (|
                              M.never_to_any (|
                                M.read (|
                                  M.return_ (|
                                    M.call_closure (|
                                      M.get_trait_method (|
                                        "core::ops::try_trait::FromResidual",
                                        Ty.apply
                                          (Ty.path "core::result::Result")
                                          [
                                            Ty.apply (Ty.path "alloc::boxed::Box") [ T; A ];
                                            Ty.path "core::alloc::AllocError"
                                          ],
                                        [
                                          Ty.apply
                                            (Ty.path "core::result::Result")
                                            [
                                              Ty.path "core::convert::Infallible";
                                              Ty.path "core::alloc::AllocError"
                                            ]
                                        ],
                                        "from_residual",
                                        []
                                      |),
                                      [ M.read (| residual |) ]
                                    |)
                                  |)
                                |)
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "core::ops::control_flow::ControlFlow::Continue",
                                0
                              |) in
                            let val := M.copy (| γ0_0 |) in
                            val))
                      ]
                    |)
                  |) in
                let _ :=
                  M.alloc (|
                    M.call_closure (|
                      M.get_associated_function (| Ty.apply (Ty.path "*mut") [ T ], "write", [] |),
                      [
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ T ],
                            "as_mut_ptr",
                            []
                          |),
                          [ M.read (| boxed |) ]
                        |);
                        M.read (| x |)
                      ]
                    |)
                  |) in
                M.alloc (|
                  Value.StructTuple
                    "core::result::Result::Ok"
                    [
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply
                            (Ty.path "alloc::boxed::Box")
                            [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ T ]; A ],
                          "assume_init",
                          []
                        |),
                        [ M.read (| boxed |) ]
                      |)
                    ]
                |)
              |)))
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_try_new_in :
      forall (T A : Ty.t),
      M.IsAssociatedFunction (Self T A) "try_new_in" (try_new_in T A).
    
    (*
        pub fn new_uninit_in(alloc: A) -> Box<mem::MaybeUninit<T>, A>
        where
            A: Allocator,
        {
            let layout = Layout::new::<mem::MaybeUninit<T>>();
            // NOTE: Prefer match over unwrap_or_else since closure sometimes not inlineable.
            // That would make code size bigger.
            match Box::try_new_uninit_in(alloc) {
                Ok(m) => m,
                Err(_) => handle_alloc_error(layout),
            }
        }
    *)
    Definition new_uninit_in (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match τ, α with
      | [], [ alloc ] =>
        ltac:(M.monadic
          (let alloc := M.alloc (| alloc |) in
          M.read (|
            let layout :=
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.path "core::alloc::layout::Layout",
                    "new",
                    [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ T ] ]
                  |),
                  []
                |)
              |) in
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "alloc::boxed::Box") [ T; A ],
                    "try_new_uninit_in",
                    []
                  |),
                  [ M.read (| alloc |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 :=
                      M.SubPointer.get_struct_tuple_field (| γ, "core::result::Result::Ok", 0 |) in
                    let m := M.copy (| γ0_0 |) in
                    m));
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 :=
                      M.SubPointer.get_struct_tuple_field (| γ, "core::result::Result::Err", 0 |) in
                    M.alloc (|
                      M.never_to_any (|
                        M.call_closure (|
                          M.get_function (| "alloc::alloc::handle_alloc_error", [] |),
                          [ M.read (| layout |) ]
                        |)
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_new_uninit_in :
      forall (T A : Ty.t),
      M.IsAssociatedFunction (Self T A) "new_uninit_in" (new_uninit_in T A).
    
    (*
        pub fn try_new_uninit_in(alloc: A) -> Result<Box<mem::MaybeUninit<T>, A>, AllocError>
        where
            A: Allocator,
        {
            let ptr = if T::IS_ZST {
                NonNull::dangling()
            } else {
                let layout = Layout::new::<mem::MaybeUninit<T>>();
                alloc.allocate(layout)?.cast()
            };
            unsafe { Ok(Box::from_raw_in(ptr.as_ptr(), alloc)) }
        }
    *)
    Definition try_new_uninit_in (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match τ, α with
      | [], [ alloc ] =>
        ltac:(M.monadic
          (let alloc := M.alloc (| alloc |) in
          M.catch_return (|
            ltac:(M.monadic
              (M.read (|
                let ptr :=
                  M.copy (|
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.get_constant (| "core::mem::SizedTypeProperties::IS_ZST" |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (|
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "core::ptr::non_null::NonNull")
                                    [
                                      Ty.apply
                                        (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                        [ T ]
                                    ],
                                  "dangling",
                                  []
                                |),
                                []
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let layout :=
                              M.alloc (|
                                M.call_closure (|
                                  M.get_associated_function (|
                                    Ty.path "core::alloc::layout::Layout",
                                    "new",
                                    [
                                      Ty.apply
                                        (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                        [ T ]
                                    ]
                                  |),
                                  []
                                |)
                              |) in
                            M.alloc (|
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "core::ptr::non_null::NonNull")
                                    [ Ty.apply (Ty.path "slice") [ Ty.path "u8" ] ],
                                  "cast",
                                  [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ T ]
                                  ]
                                |),
                                [
                                  M.read (|
                                    M.match_operator (|
                                      M.alloc (|
                                        M.call_closure (|
                                          M.get_trait_method (|
                                            "core::ops::try_trait::Try",
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              [
                                                Ty.apply
                                                  (Ty.path "core::ptr::non_null::NonNull")
                                                  [ Ty.apply (Ty.path "slice") [ Ty.path "u8" ] ];
                                                Ty.path "core::alloc::AllocError"
                                              ],
                                            [],
                                            "branch",
                                            []
                                          |),
                                          [
                                            M.call_closure (|
                                              M.get_trait_method (|
                                                "core::alloc::Allocator",
                                                A,
                                                [],
                                                "allocate",
                                                []
                                              |),
                                              [ alloc; M.read (| layout |) ]
                                            |)
                                          ]
                                        |)
                                      |),
                                      [
                                        fun γ =>
                                          ltac:(M.monadic
                                            (let γ0_0 :=
                                              M.SubPointer.get_struct_tuple_field (|
                                                γ,
                                                "core::ops::control_flow::ControlFlow::Break",
                                                0
                                              |) in
                                            let residual := M.copy (| γ0_0 |) in
                                            M.alloc (|
                                              M.never_to_any (|
                                                M.read (|
                                                  M.return_ (|
                                                    M.call_closure (|
                                                      M.get_trait_method (|
                                                        "core::ops::try_trait::FromResidual",
                                                        Ty.apply
                                                          (Ty.path "core::result::Result")
                                                          [
                                                            Ty.apply
                                                              (Ty.path "alloc::boxed::Box")
                                                              [
                                                                Ty.apply
                                                                  (Ty.path
                                                                    "core::mem::maybe_uninit::MaybeUninit")
                                                                  [ T ];
                                                                A
                                                              ];
                                                            Ty.path "core::alloc::AllocError"
                                                          ],
                                                        [
                                                          Ty.apply
                                                            (Ty.path "core::result::Result")
                                                            [
                                                              Ty.path "core::convert::Infallible";
                                                              Ty.path "core::alloc::AllocError"
                                                            ]
                                                        ],
                                                        "from_residual",
                                                        []
                                                      |),
                                                      [ M.read (| residual |) ]
                                                    |)
                                                  |)
                                                |)
                                              |)
                                            |)));
                                        fun γ =>
                                          ltac:(M.monadic
                                            (let γ0_0 :=
                                              M.SubPointer.get_struct_tuple_field (|
                                                γ,
                                                "core::ops::control_flow::ControlFlow::Continue",
                                                0
                                              |) in
                                            let val := M.copy (| γ0_0 |) in
                                            val))
                                      ]
                                    |)
                                  |)
                                ]
                              |)
                            |)))
                      ]
                    |)
                  |) in
                M.alloc (|
                  Value.StructTuple
                    "core::result::Result::Ok"
                    [
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply
                            (Ty.path "alloc::boxed::Box")
                            [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ T ]; A ],
                          "from_raw_in",
                          []
                        |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply
                                (Ty.path "core::ptr::non_null::NonNull")
                                [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ T ] ],
                              "as_ptr",
                              []
                            |),
                            [ M.read (| ptr |) ]
                          |);
                          M.read (| alloc |)
                        ]
                      |)
                    ]
                |)
              |)))
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_try_new_uninit_in :
      forall (T A : Ty.t),
      M.IsAssociatedFunction (Self T A) "try_new_uninit_in" (try_new_uninit_in T A).
    
    (*
        pub fn new_zeroed_in(alloc: A) -> Box<mem::MaybeUninit<T>, A>
        where
            A: Allocator,
        {
            let layout = Layout::new::<mem::MaybeUninit<T>>();
            // NOTE: Prefer match over unwrap_or_else since closure sometimes not inlineable.
            // That would make code size bigger.
            match Box::try_new_zeroed_in(alloc) {
                Ok(m) => m,
                Err(_) => handle_alloc_error(layout),
            }
        }
    *)
    Definition new_zeroed_in (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match τ, α with
      | [], [ alloc ] =>
        ltac:(M.monadic
          (let alloc := M.alloc (| alloc |) in
          M.read (|
            let layout :=
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.path "core::alloc::layout::Layout",
                    "new",
                    [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ T ] ]
                  |),
                  []
                |)
              |) in
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "alloc::boxed::Box") [ T; A ],
                    "try_new_zeroed_in",
                    []
                  |),
                  [ M.read (| alloc |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 :=
                      M.SubPointer.get_struct_tuple_field (| γ, "core::result::Result::Ok", 0 |) in
                    let m := M.copy (| γ0_0 |) in
                    m));
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 :=
                      M.SubPointer.get_struct_tuple_field (| γ, "core::result::Result::Err", 0 |) in
                    M.alloc (|
                      M.never_to_any (|
                        M.call_closure (|
                          M.get_function (| "alloc::alloc::handle_alloc_error", [] |),
                          [ M.read (| layout |) ]
                        |)
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_new_zeroed_in :
      forall (T A : Ty.t),
      M.IsAssociatedFunction (Self T A) "new_zeroed_in" (new_zeroed_in T A).
    
    (*
        pub fn try_new_zeroed_in(alloc: A) -> Result<Box<mem::MaybeUninit<T>, A>, AllocError>
        where
            A: Allocator,
        {
            let ptr = if T::IS_ZST {
                NonNull::dangling()
            } else {
                let layout = Layout::new::<mem::MaybeUninit<T>>();
                alloc.allocate_zeroed(layout)?.cast()
            };
            unsafe { Ok(Box::from_raw_in(ptr.as_ptr(), alloc)) }
        }
    *)
    Definition try_new_zeroed_in (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match τ, α with
      | [], [ alloc ] =>
        ltac:(M.monadic
          (let alloc := M.alloc (| alloc |) in
          M.catch_return (|
            ltac:(M.monadic
              (M.read (|
                let ptr :=
                  M.copy (|
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.get_constant (| "core::mem::SizedTypeProperties::IS_ZST" |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (|
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "core::ptr::non_null::NonNull")
                                    [
                                      Ty.apply
                                        (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                        [ T ]
                                    ],
                                  "dangling",
                                  []
                                |),
                                []
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let layout :=
                              M.alloc (|
                                M.call_closure (|
                                  M.get_associated_function (|
                                    Ty.path "core::alloc::layout::Layout",
                                    "new",
                                    [
                                      Ty.apply
                                        (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                        [ T ]
                                    ]
                                  |),
                                  []
                                |)
                              |) in
                            M.alloc (|
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "core::ptr::non_null::NonNull")
                                    [ Ty.apply (Ty.path "slice") [ Ty.path "u8" ] ],
                                  "cast",
                                  [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ T ]
                                  ]
                                |),
                                [
                                  M.read (|
                                    M.match_operator (|
                                      M.alloc (|
                                        M.call_closure (|
                                          M.get_trait_method (|
                                            "core::ops::try_trait::Try",
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              [
                                                Ty.apply
                                                  (Ty.path "core::ptr::non_null::NonNull")
                                                  [ Ty.apply (Ty.path "slice") [ Ty.path "u8" ] ];
                                                Ty.path "core::alloc::AllocError"
                                              ],
                                            [],
                                            "branch",
                                            []
                                          |),
                                          [
                                            M.call_closure (|
                                              M.get_trait_method (|
                                                "core::alloc::Allocator",
                                                A,
                                                [],
                                                "allocate_zeroed",
                                                []
                                              |),
                                              [ alloc; M.read (| layout |) ]
                                            |)
                                          ]
                                        |)
                                      |),
                                      [
                                        fun γ =>
                                          ltac:(M.monadic
                                            (let γ0_0 :=
                                              M.SubPointer.get_struct_tuple_field (|
                                                γ,
                                                "core::ops::control_flow::ControlFlow::Break",
                                                0
                                              |) in
                                            let residual := M.copy (| γ0_0 |) in
                                            M.alloc (|
                                              M.never_to_any (|
                                                M.read (|
                                                  M.return_ (|
                                                    M.call_closure (|
                                                      M.get_trait_method (|
                                                        "core::ops::try_trait::FromResidual",
                                                        Ty.apply
                                                          (Ty.path "core::result::Result")
                                                          [
                                                            Ty.apply
                                                              (Ty.path "alloc::boxed::Box")
                                                              [
                                                                Ty.apply
                                                                  (Ty.path
                                                                    "core::mem::maybe_uninit::MaybeUninit")
                                                                  [ T ];
                                                                A
                                                              ];
                                                            Ty.path "core::alloc::AllocError"
                                                          ],
                                                        [
                                                          Ty.apply
                                                            (Ty.path "core::result::Result")
                                                            [
                                                              Ty.path "core::convert::Infallible";
                                                              Ty.path "core::alloc::AllocError"
                                                            ]
                                                        ],
                                                        "from_residual",
                                                        []
                                                      |),
                                                      [ M.read (| residual |) ]
                                                    |)
                                                  |)
                                                |)
                                              |)
                                            |)));
                                        fun γ =>
                                          ltac:(M.monadic
                                            (let γ0_0 :=
                                              M.SubPointer.get_struct_tuple_field (|
                                                γ,
                                                "core::ops::control_flow::ControlFlow::Continue",
                                                0
                                              |) in
                                            let val := M.copy (| γ0_0 |) in
                                            val))
                                      ]
                                    |)
                                  |)
                                ]
                              |)
                            |)))
                      ]
                    |)
                  |) in
                M.alloc (|
                  Value.StructTuple
                    "core::result::Result::Ok"
                    [
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply
                            (Ty.path "alloc::boxed::Box")
                            [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ T ]; A ],
                          "from_raw_in",
                          []
                        |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply
                                (Ty.path "core::ptr::non_null::NonNull")
                                [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ T ] ],
                              "as_ptr",
                              []
                            |),
                            [ M.read (| ptr |) ]
                          |);
                          M.read (| alloc |)
                        ]
                      |)
                    ]
                |)
              |)))
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_try_new_zeroed_in :
      forall (T A : Ty.t),
      M.IsAssociatedFunction (Self T A) "try_new_zeroed_in" (try_new_zeroed_in T A).
    
    (*
        pub fn pin_in(x: T, alloc: A) -> Pin<Self>
        where
            A: 'static + Allocator,
        {
            Self::into_pin(Self::new_in(x, alloc))
        }
    *)
    Definition pin_in (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match τ, α with
      | [], [ x; alloc ] =>
        ltac:(M.monadic
          (let x := M.alloc (| x |) in
          let alloc := M.alloc (| alloc |) in
          M.call_closure (|
            M.get_associated_function (|
              Ty.apply (Ty.path "alloc::boxed::Box") [ T; A ],
              "into_pin",
              []
            |),
            [
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply (Ty.path "alloc::boxed::Box") [ T; A ],
                  "new_in",
                  []
                |),
                [ M.read (| x |); M.read (| alloc |) ]
              |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_pin_in :
      forall (T A : Ty.t),
      M.IsAssociatedFunction (Self T A) "pin_in" (pin_in T A).
    
    (*
        pub fn into_boxed_slice(boxed: Self) -> Box<[T], A> {
            let (raw, alloc) = Box::into_raw_with_allocator(boxed);
            unsafe { Box::from_raw_in(raw as *mut [T; 1], alloc) }
        }
    *)
    Definition into_boxed_slice (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match τ, α with
      | [], [ boxed ] =>
        ltac:(M.monadic
          (let boxed := M.alloc (| boxed |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "alloc::boxed::Box") [ T; A ],
                    "into_raw_with_allocator",
                    []
                  |),
                  [ M.read (| boxed |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let raw := M.copy (| γ0_0 |) in
                    let alloc := M.copy (| γ0_1 |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply
                            (Ty.path "alloc::boxed::Box")
                            [ Ty.apply (Ty.path "slice") [ T ]; A ],
                          "from_raw_in",
                          []
                        |),
                        [
                          (* Unsize *) M.pointer_coercion (M.rust_cast (M.read (| raw |)));
                          M.read (| alloc |)
                        ]
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_into_boxed_slice :
      forall (T A : Ty.t),
      M.IsAssociatedFunction (Self T A) "into_boxed_slice" (into_boxed_slice T A).
    
    (*
        pub fn into_inner(boxed: Self) -> T {
            *boxed
        }
    *)
    Definition into_inner (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match τ, α with
      | [], [ boxed ] =>
        ltac:(M.monadic
          (let boxed := M.alloc (| boxed |) in
          M.read (| M.read (| boxed |) |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_into_inner :
      forall (T A : Ty.t),
      M.IsAssociatedFunction (Self T A) "into_inner" (into_inner T A).
    (*
        pub const unsafe fn from_raw_in(raw: *mut T, alloc: A) -> Self {
            Box(unsafe { Unique::new_unchecked(raw) }, alloc)
        }
    *)
    Definition from_raw_in (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match τ, α with
      | [], [ raw; alloc ] =>
        ltac:(M.monadic
          (let raw := M.alloc (| raw |) in
          let alloc := M.alloc (| alloc |) in
          Value.StructTuple
            "alloc::boxed::Box"
            [
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply (Ty.path "core::ptr::unique::Unique") [ T ],
                  "new_unchecked",
                  []
                |),
                [ M.read (| raw |) ]
              |);
              M.read (| alloc |)
            ]))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_from_raw_in :
      forall (T A : Ty.t),
      M.IsAssociatedFunction (Self T A) "from_raw_in" (from_raw_in T A).
    
    (*
        pub fn into_raw(b: Self) -> *mut T {
            Self::into_raw_with_allocator(b).0
        }
    *)
    Definition into_raw (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match τ, α with
      | [], [ b ] =>
        ltac:(M.monadic
          (let b := M.alloc (| b |) in
          M.read (|
            M.SubPointer.get_tuple_field (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "alloc::boxed::Box") [ T; A ],
                    "into_raw_with_allocator",
                    []
                  |),
                  [ M.read (| b |) ]
                |)
              |),
              0
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_into_raw :
      forall (T A : Ty.t),
      M.IsAssociatedFunction (Self T A) "into_raw" (into_raw T A).
    
    (*
        pub fn into_raw_with_allocator(b: Self) -> ( *mut T, A) {
            let (leaked, alloc) = Box::into_unique(b);
            (leaked.as_ptr(), alloc)
        }
    *)
    Definition into_raw_with_allocator (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match τ, α with
      | [], [ b ] =>
        ltac:(M.monadic
          (let b := M.alloc (| b |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "alloc::boxed::Box") [ T; A ],
                    "into_unique",
                    []
                  |),
                  [ M.read (| b |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let leaked := M.copy (| γ0_0 |) in
                    let alloc := M.copy (| γ0_1 |) in
                    M.alloc (|
                      Value.Tuple
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply (Ty.path "core::ptr::unique::Unique") [ T ],
                              "as_ptr",
                              []
                            |),
                            [ M.read (| leaked |) ]
                          |);
                          M.read (| alloc |)
                        ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_into_raw_with_allocator :
      forall (T A : Ty.t),
      M.IsAssociatedFunction (Self T A) "into_raw_with_allocator" (into_raw_with_allocator T A).
    
    (*
        pub fn into_unique(b: Self) -> (Unique<T>, A) {
            // Box is recognized as a "unique pointer" by Stacked Borrows, but internally it is a
            // raw pointer for the type system. Turning it directly into a raw pointer would not be
            // recognized as "releasing" the unique pointer to permit aliased raw accesses,
            // so all raw pointer methods have to go through `Box::leak`. Turning *that* to a raw pointer
            // behaves correctly.
            let alloc = unsafe { ptr::read(&b.1) };
            (Unique::from(Box::leak(b)), alloc)
        }
    *)
    Definition into_unique (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match τ, α with
      | [], [ b ] =>
        ltac:(M.monadic
          (let b := M.alloc (| b |) in
          M.read (|
            let alloc :=
              M.alloc (|
                M.call_closure (|
                  M.get_function (| "core::ptr::read", [ A ] |),
                  [ M.SubPointer.get_struct_tuple_field (| b, "alloc::boxed::Box", 1 |) ]
                |)
              |) in
            M.alloc (|
              Value.Tuple
                [
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::convert::From",
                      Ty.apply (Ty.path "core::ptr::unique::Unique") [ T ],
                      [ Ty.apply (Ty.path "&mut") [ T ] ],
                      "from",
                      []
                    |),
                    [
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "alloc::boxed::Box") [ T; A ],
                          "leak",
                          []
                        |),
                        [ M.read (| b |) ]
                      |)
                    ]
                  |);
                  M.read (| alloc |)
                ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_into_unique :
      forall (T A : Ty.t),
      M.IsAssociatedFunction (Self T A) "into_unique" (into_unique T A).
    
    (*
        pub const fn allocator(b: &Self) -> &A {
            &b.1
        }
    *)
    Definition allocator (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match τ, α with
      | [], [ b ] =>
        ltac:(M.monadic
          (let b := M.alloc (| b |) in
          M.SubPointer.get_struct_tuple_field (| M.read (| b |), "alloc::boxed::Box", 1 |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_allocator :
      forall (T A : Ty.t),
      M.IsAssociatedFunction (Self T A) "allocator" (allocator T A).
    
    (*
        pub fn leak<'a>(b: Self) -> &'a mut T
        where
            A: 'a,
        {
            unsafe { &mut *mem::ManuallyDrop::new(b).0.as_ptr() }
        }
    *)
    Definition leak (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match τ, α with
      | [], [ b ] =>
        ltac:(M.monadic
          (let b := M.alloc (| b |) in
          M.call_closure (|
            M.get_associated_function (|
              Ty.apply (Ty.path "core::ptr::unique::Unique") [ T ],
              "as_ptr",
              []
            |),
            [
              M.read (|
                M.SubPointer.get_struct_tuple_field (|
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::deref::Deref",
                      Ty.apply
                        (Ty.path "core::mem::manually_drop::ManuallyDrop")
                        [ Ty.apply (Ty.path "alloc::boxed::Box") [ T; A ] ],
                      [],
                      "deref",
                      []
                    |),
                    [
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.apply
                              (Ty.path "core::mem::manually_drop::ManuallyDrop")
                              [ Ty.apply (Ty.path "alloc::boxed::Box") [ T; A ] ],
                            "new",
                            []
                          |),
                          [ M.read (| b |) ]
                        |)
                      |)
                    ]
                  |),
                  "alloc::boxed::Box",
                  0
                |)
              |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_leak :
      forall (T A : Ty.t),
      M.IsAssociatedFunction (Self T A) "leak" (leak T A).
    
    (*
        pub const fn into_pin(boxed: Self) -> Pin<Self>
        where
            A: 'static,
        {
            // It's not possible to move or replace the insides of a `Pin<Box<T>>`
            // when `T: !Unpin`, so it's safe to pin it directly without any
            // additional requirements.
            unsafe { Pin::new_unchecked(boxed) }
        }
    *)
    Definition into_pin (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match τ, α with
      | [], [ boxed ] =>
        ltac:(M.monadic
          (let boxed := M.alloc (| boxed |) in
          M.call_closure (|
            M.get_associated_function (|
              Ty.apply
                (Ty.path "core::pin::Pin")
                [ Ty.apply (Ty.path "alloc::boxed::Box") [ T; A ] ],
              "new_unchecked",
              []
            |),
            [ M.read (| boxed |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_into_pin :
      forall (T A : Ty.t),
      M.IsAssociatedFunction (Self T A) "into_pin" (into_pin T A).
  End Impl_alloc_boxed_Box_T_A.
  
  Module Impl_alloc_boxed_Box_slice_T_alloc_alloc_Global.
    Definition Self (T : Ty.t) : Ty.t :=
      Ty.apply
        (Ty.path "alloc::boxed::Box")
        [ Ty.apply (Ty.path "slice") [ T ]; Ty.path "alloc::alloc::Global" ].
    
    (*
        pub fn new_uninit_slice(len: usize) -> Box<[mem::MaybeUninit<T>]> {
            unsafe { RawVec::with_capacity(len).into_box(len) }
        }
    *)
    Definition new_uninit_slice (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match τ, α with
      | [], [ len ] =>
        ltac:(M.monadic
          (let len := M.alloc (| len |) in
          M.call_closure (|
            M.get_associated_function (|
              Ty.apply (Ty.path "alloc::raw_vec::RawVec") [ T; Ty.path "alloc::alloc::Global" ],
              "into_box",
              []
            |),
            [
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply (Ty.path "alloc::raw_vec::RawVec") [ T; Ty.path "alloc::alloc::Global" ],
                  "with_capacity",
                  []
                |),
                [ M.read (| len |) ]
              |);
              M.read (| len |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_new_uninit_slice :
      forall (T : Ty.t),
      M.IsAssociatedFunction (Self T) "new_uninit_slice" (new_uninit_slice T).
    
    (*
        pub fn new_zeroed_slice(len: usize) -> Box<[mem::MaybeUninit<T>]> {
            unsafe { RawVec::with_capacity_zeroed(len).into_box(len) }
        }
    *)
    Definition new_zeroed_slice (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match τ, α with
      | [], [ len ] =>
        ltac:(M.monadic
          (let len := M.alloc (| len |) in
          M.call_closure (|
            M.get_associated_function (|
              Ty.apply (Ty.path "alloc::raw_vec::RawVec") [ T; Ty.path "alloc::alloc::Global" ],
              "into_box",
              []
            |),
            [
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply (Ty.path "alloc::raw_vec::RawVec") [ T; Ty.path "alloc::alloc::Global" ],
                  "with_capacity_zeroed",
                  []
                |),
                [ M.read (| len |) ]
              |);
              M.read (| len |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_new_zeroed_slice :
      forall (T : Ty.t),
      M.IsAssociatedFunction (Self T) "new_zeroed_slice" (new_zeroed_slice T).
    
    (*
        pub fn try_new_uninit_slice(len: usize) -> Result<Box<[mem::MaybeUninit<T>]>, AllocError> {
            let ptr = if T::IS_ZST || len == 0 {
                NonNull::dangling()
            } else {
                let layout = match Layout::array::<mem::MaybeUninit<T>>(len) {
                    Ok(l) => l,
                    Err(_) => return Err(AllocError),
                };
                Global.allocate(layout)?.cast()
            };
            unsafe { Ok(RawVec::from_raw_parts_in(ptr.as_ptr(), len, Global).into_box(len)) }
        }
    *)
    Definition try_new_uninit_slice (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match τ, α with
      | [], [ len ] =>
        ltac:(M.monadic
          (let len := M.alloc (| len |) in
          M.catch_return (|
            ltac:(M.monadic
              (M.read (|
                let ptr :=
                  M.copy (|
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  LogicalOp.or (|
                                    M.read (|
                                      M.get_constant (| "core::mem::SizedTypeProperties::IS_ZST" |)
                                    |),
                                    ltac:(M.monadic
                                      (BinOp.Pure.eq (M.read (| len |)) (Value.Integer 0)))
                                  |)
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (|
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "core::ptr::non_null::NonNull") [ T ],
                                  "dangling",
                                  []
                                |),
                                []
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let layout :=
                              M.copy (|
                                M.match_operator (|
                                  M.alloc (|
                                    M.call_closure (|
                                      M.get_associated_function (|
                                        Ty.path "core::alloc::layout::Layout",
                                        "array",
                                        [
                                          Ty.apply
                                            (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                            [ T ]
                                        ]
                                      |),
                                      [ M.read (| len |) ]
                                    |)
                                  |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ0_0 :=
                                          M.SubPointer.get_struct_tuple_field (|
                                            γ,
                                            "core::result::Result::Ok",
                                            0
                                          |) in
                                        let l := M.copy (| γ0_0 |) in
                                        l));
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ0_0 :=
                                          M.SubPointer.get_struct_tuple_field (|
                                            γ,
                                            "core::result::Result::Err",
                                            0
                                          |) in
                                        M.alloc (|
                                          M.never_to_any (|
                                            M.read (|
                                              M.return_ (|
                                                Value.StructTuple
                                                  "core::result::Result::Err"
                                                  [ Value.StructTuple "core::alloc::AllocError" [] ]
                                              |)
                                            |)
                                          |)
                                        |)))
                                  ]
                                |)
                              |) in
                            M.alloc (|
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "core::ptr::non_null::NonNull")
                                    [ Ty.apply (Ty.path "slice") [ Ty.path "u8" ] ],
                                  "cast",
                                  [ T ]
                                |),
                                [
                                  M.read (|
                                    M.match_operator (|
                                      M.alloc (|
                                        M.call_closure (|
                                          M.get_trait_method (|
                                            "core::ops::try_trait::Try",
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              [
                                                Ty.apply
                                                  (Ty.path "core::ptr::non_null::NonNull")
                                                  [ Ty.apply (Ty.path "slice") [ Ty.path "u8" ] ];
                                                Ty.path "core::alloc::AllocError"
                                              ],
                                            [],
                                            "branch",
                                            []
                                          |),
                                          [
                                            M.call_closure (|
                                              M.get_trait_method (|
                                                "core::alloc::Allocator",
                                                Ty.path "alloc::alloc::Global",
                                                [],
                                                "allocate",
                                                []
                                              |),
                                              [
                                                M.alloc (|
                                                  Value.StructTuple "alloc::alloc::Global" []
                                                |);
                                                M.read (| layout |)
                                              ]
                                            |)
                                          ]
                                        |)
                                      |),
                                      [
                                        fun γ =>
                                          ltac:(M.monadic
                                            (let γ0_0 :=
                                              M.SubPointer.get_struct_tuple_field (|
                                                γ,
                                                "core::ops::control_flow::ControlFlow::Break",
                                                0
                                              |) in
                                            let residual := M.copy (| γ0_0 |) in
                                            M.alloc (|
                                              M.never_to_any (|
                                                M.read (|
                                                  M.return_ (|
                                                    M.call_closure (|
                                                      M.get_trait_method (|
                                                        "core::ops::try_trait::FromResidual",
                                                        Ty.apply
                                                          (Ty.path "core::result::Result")
                                                          [
                                                            Ty.apply
                                                              (Ty.path "alloc::boxed::Box")
                                                              [
                                                                Ty.apply
                                                                  (Ty.path "slice")
                                                                  [
                                                                    Ty.apply
                                                                      (Ty.path
                                                                        "core::mem::maybe_uninit::MaybeUninit")
                                                                      [ T ]
                                                                  ];
                                                                Ty.path "alloc::alloc::Global"
                                                              ];
                                                            Ty.path "core::alloc::AllocError"
                                                          ],
                                                        [
                                                          Ty.apply
                                                            (Ty.path "core::result::Result")
                                                            [
                                                              Ty.path "core::convert::Infallible";
                                                              Ty.path "core::alloc::AllocError"
                                                            ]
                                                        ],
                                                        "from_residual",
                                                        []
                                                      |),
                                                      [ M.read (| residual |) ]
                                                    |)
                                                  |)
                                                |)
                                              |)
                                            |)));
                                        fun γ =>
                                          ltac:(M.monadic
                                            (let γ0_0 :=
                                              M.SubPointer.get_struct_tuple_field (|
                                                γ,
                                                "core::ops::control_flow::ControlFlow::Continue",
                                                0
                                              |) in
                                            let val := M.copy (| γ0_0 |) in
                                            val))
                                      ]
                                    |)
                                  |)
                                ]
                              |)
                            |)))
                      ]
                    |)
                  |) in
                M.alloc (|
                  Value.StructTuple
                    "core::result::Result::Ok"
                    [
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply
                            (Ty.path "alloc::raw_vec::RawVec")
                            [ T; Ty.path "alloc::alloc::Global" ],
                          "into_box",
                          []
                        |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply
                                (Ty.path "alloc::raw_vec::RawVec")
                                [ T; Ty.path "alloc::alloc::Global" ],
                              "from_raw_parts_in",
                              []
                            |),
                            [
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "core::ptr::non_null::NonNull") [ T ],
                                  "as_ptr",
                                  []
                                |),
                                [ M.read (| ptr |) ]
                              |);
                              M.read (| len |);
                              Value.StructTuple "alloc::alloc::Global" []
                            ]
                          |);
                          M.read (| len |)
                        ]
                      |)
                    ]
                |)
              |)))
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_try_new_uninit_slice :
      forall (T : Ty.t),
      M.IsAssociatedFunction (Self T) "try_new_uninit_slice" (try_new_uninit_slice T).
    
    (*
        pub fn try_new_zeroed_slice(len: usize) -> Result<Box<[mem::MaybeUninit<T>]>, AllocError> {
            let ptr = if T::IS_ZST || len == 0 {
                NonNull::dangling()
            } else {
                let layout = match Layout::array::<mem::MaybeUninit<T>>(len) {
                    Ok(l) => l,
                    Err(_) => return Err(AllocError),
                };
                Global.allocate_zeroed(layout)?.cast()
            };
            unsafe { Ok(RawVec::from_raw_parts_in(ptr.as_ptr(), len, Global).into_box(len)) }
        }
    *)
    Definition try_new_zeroed_slice (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match τ, α with
      | [], [ len ] =>
        ltac:(M.monadic
          (let len := M.alloc (| len |) in
          M.catch_return (|
            ltac:(M.monadic
              (M.read (|
                let ptr :=
                  M.copy (|
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  LogicalOp.or (|
                                    M.read (|
                                      M.get_constant (| "core::mem::SizedTypeProperties::IS_ZST" |)
                                    |),
                                    ltac:(M.monadic
                                      (BinOp.Pure.eq (M.read (| len |)) (Value.Integer 0)))
                                  |)
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (|
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "core::ptr::non_null::NonNull") [ T ],
                                  "dangling",
                                  []
                                |),
                                []
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let layout :=
                              M.copy (|
                                M.match_operator (|
                                  M.alloc (|
                                    M.call_closure (|
                                      M.get_associated_function (|
                                        Ty.path "core::alloc::layout::Layout",
                                        "array",
                                        [
                                          Ty.apply
                                            (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                            [ T ]
                                        ]
                                      |),
                                      [ M.read (| len |) ]
                                    |)
                                  |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ0_0 :=
                                          M.SubPointer.get_struct_tuple_field (|
                                            γ,
                                            "core::result::Result::Ok",
                                            0
                                          |) in
                                        let l := M.copy (| γ0_0 |) in
                                        l));
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ0_0 :=
                                          M.SubPointer.get_struct_tuple_field (|
                                            γ,
                                            "core::result::Result::Err",
                                            0
                                          |) in
                                        M.alloc (|
                                          M.never_to_any (|
                                            M.read (|
                                              M.return_ (|
                                                Value.StructTuple
                                                  "core::result::Result::Err"
                                                  [ Value.StructTuple "core::alloc::AllocError" [] ]
                                              |)
                                            |)
                                          |)
                                        |)))
                                  ]
                                |)
                              |) in
                            M.alloc (|
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "core::ptr::non_null::NonNull")
                                    [ Ty.apply (Ty.path "slice") [ Ty.path "u8" ] ],
                                  "cast",
                                  [ T ]
                                |),
                                [
                                  M.read (|
                                    M.match_operator (|
                                      M.alloc (|
                                        M.call_closure (|
                                          M.get_trait_method (|
                                            "core::ops::try_trait::Try",
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              [
                                                Ty.apply
                                                  (Ty.path "core::ptr::non_null::NonNull")
                                                  [ Ty.apply (Ty.path "slice") [ Ty.path "u8" ] ];
                                                Ty.path "core::alloc::AllocError"
                                              ],
                                            [],
                                            "branch",
                                            []
                                          |),
                                          [
                                            M.call_closure (|
                                              M.get_trait_method (|
                                                "core::alloc::Allocator",
                                                Ty.path "alloc::alloc::Global",
                                                [],
                                                "allocate_zeroed",
                                                []
                                              |),
                                              [
                                                M.alloc (|
                                                  Value.StructTuple "alloc::alloc::Global" []
                                                |);
                                                M.read (| layout |)
                                              ]
                                            |)
                                          ]
                                        |)
                                      |),
                                      [
                                        fun γ =>
                                          ltac:(M.monadic
                                            (let γ0_0 :=
                                              M.SubPointer.get_struct_tuple_field (|
                                                γ,
                                                "core::ops::control_flow::ControlFlow::Break",
                                                0
                                              |) in
                                            let residual := M.copy (| γ0_0 |) in
                                            M.alloc (|
                                              M.never_to_any (|
                                                M.read (|
                                                  M.return_ (|
                                                    M.call_closure (|
                                                      M.get_trait_method (|
                                                        "core::ops::try_trait::FromResidual",
                                                        Ty.apply
                                                          (Ty.path "core::result::Result")
                                                          [
                                                            Ty.apply
                                                              (Ty.path "alloc::boxed::Box")
                                                              [
                                                                Ty.apply
                                                                  (Ty.path "slice")
                                                                  [
                                                                    Ty.apply
                                                                      (Ty.path
                                                                        "core::mem::maybe_uninit::MaybeUninit")
                                                                      [ T ]
                                                                  ];
                                                                Ty.path "alloc::alloc::Global"
                                                              ];
                                                            Ty.path "core::alloc::AllocError"
                                                          ],
                                                        [
                                                          Ty.apply
                                                            (Ty.path "core::result::Result")
                                                            [
                                                              Ty.path "core::convert::Infallible";
                                                              Ty.path "core::alloc::AllocError"
                                                            ]
                                                        ],
                                                        "from_residual",
                                                        []
                                                      |),
                                                      [ M.read (| residual |) ]
                                                    |)
                                                  |)
                                                |)
                                              |)
                                            |)));
                                        fun γ =>
                                          ltac:(M.monadic
                                            (let γ0_0 :=
                                              M.SubPointer.get_struct_tuple_field (|
                                                γ,
                                                "core::ops::control_flow::ControlFlow::Continue",
                                                0
                                              |) in
                                            let val := M.copy (| γ0_0 |) in
                                            val))
                                      ]
                                    |)
                                  |)
                                ]
                              |)
                            |)))
                      ]
                    |)
                  |) in
                M.alloc (|
                  Value.StructTuple
                    "core::result::Result::Ok"
                    [
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply
                            (Ty.path "alloc::raw_vec::RawVec")
                            [ T; Ty.path "alloc::alloc::Global" ],
                          "into_box",
                          []
                        |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply
                                (Ty.path "alloc::raw_vec::RawVec")
                                [ T; Ty.path "alloc::alloc::Global" ],
                              "from_raw_parts_in",
                              []
                            |),
                            [
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "core::ptr::non_null::NonNull") [ T ],
                                  "as_ptr",
                                  []
                                |),
                                [ M.read (| ptr |) ]
                              |);
                              M.read (| len |);
                              Value.StructTuple "alloc::alloc::Global" []
                            ]
                          |);
                          M.read (| len |)
                        ]
                      |)
                    ]
                |)
              |)))
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_try_new_zeroed_slice :
      forall (T : Ty.t),
      M.IsAssociatedFunction (Self T) "try_new_zeroed_slice" (try_new_zeroed_slice T).
  End Impl_alloc_boxed_Box_slice_T_alloc_alloc_Global.
  
  Module Impl_alloc_boxed_Box_slice_T_A.
    Definition Self (T A : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "alloc::boxed::Box") [ Ty.apply (Ty.path "slice") [ T ]; A ].
    
    (*
        pub fn new_uninit_slice_in(len: usize, alloc: A) -> Box<[mem::MaybeUninit<T>], A> {
            unsafe { RawVec::with_capacity_in(len, alloc).into_box(len) }
        }
    *)
    Definition new_uninit_slice_in (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match τ, α with
      | [], [ len; alloc ] =>
        ltac:(M.monadic
          (let len := M.alloc (| len |) in
          let alloc := M.alloc (| alloc |) in
          M.call_closure (|
            M.get_associated_function (|
              Ty.apply (Ty.path "alloc::raw_vec::RawVec") [ T; A ],
              "into_box",
              []
            |),
            [
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply (Ty.path "alloc::raw_vec::RawVec") [ T; A ],
                  "with_capacity_in",
                  []
                |),
                [ M.read (| len |); M.read (| alloc |) ]
              |);
              M.read (| len |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_new_uninit_slice_in :
      forall (T A : Ty.t),
      M.IsAssociatedFunction (Self T A) "new_uninit_slice_in" (new_uninit_slice_in T A).
    
    (*
        pub fn new_zeroed_slice_in(len: usize, alloc: A) -> Box<[mem::MaybeUninit<T>], A> {
            unsafe { RawVec::with_capacity_zeroed_in(len, alloc).into_box(len) }
        }
    *)
    Definition new_zeroed_slice_in (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match τ, α with
      | [], [ len; alloc ] =>
        ltac:(M.monadic
          (let len := M.alloc (| len |) in
          let alloc := M.alloc (| alloc |) in
          M.call_closure (|
            M.get_associated_function (|
              Ty.apply (Ty.path "alloc::raw_vec::RawVec") [ T; A ],
              "into_box",
              []
            |),
            [
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply (Ty.path "alloc::raw_vec::RawVec") [ T; A ],
                  "with_capacity_zeroed_in",
                  []
                |),
                [ M.read (| len |); M.read (| alloc |) ]
              |);
              M.read (| len |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_new_zeroed_slice_in :
      forall (T A : Ty.t),
      M.IsAssociatedFunction (Self T A) "new_zeroed_slice_in" (new_zeroed_slice_in T A).
  End Impl_alloc_boxed_Box_slice_T_A.
  
  Module Impl_alloc_boxed_Box_core_mem_maybe_uninit_MaybeUninit_T_A.
    Definition Self (T A : Ty.t) : Ty.t :=
      Ty.apply
        (Ty.path "alloc::boxed::Box")
        [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ T ]; A ].
    
    (*
        pub unsafe fn assume_init(self) -> Box<T, A> {
            let (raw, alloc) = Box::into_raw_with_allocator(self);
            unsafe { Box::from_raw_in(raw as *mut T, alloc) }
        }
    *)
    Definition assume_init (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "alloc::boxed::Box")
                      [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ T ]; A ],
                    "into_raw_with_allocator",
                    []
                  |),
                  [ M.read (| self |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let raw := M.copy (| γ0_0 |) in
                    let alloc := M.copy (| γ0_1 |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "alloc::boxed::Box") [ T; A ],
                          "from_raw_in",
                          []
                        |),
                        [ M.rust_cast (M.read (| raw |)); M.read (| alloc |) ]
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_assume_init :
      forall (T A : Ty.t),
      M.IsAssociatedFunction (Self T A) "assume_init" (assume_init T A).
    
    (*
        pub fn write(mut boxed: Self, value: T) -> Box<T, A> {
            unsafe {
                ( *boxed).write(value);
                boxed.assume_init()
            }
        }
    *)
    Definition write (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match τ, α with
      | [], [ boxed; value ] =>
        ltac:(M.monadic
          (let boxed := M.alloc (| boxed |) in
          let value := M.alloc (| value |) in
          M.read (|
            let _ :=
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ T ],
                    "write",
                    []
                  |),
                  [ M.read (| boxed |); M.read (| value |) ]
                |)
              |) in
            M.alloc (|
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "alloc::boxed::Box")
                    [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ T ]; A ],
                  "assume_init",
                  []
                |),
                [ M.read (| boxed |) ]
              |)
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_write :
      forall (T A : Ty.t),
      M.IsAssociatedFunction (Self T A) "write" (write T A).
  End Impl_alloc_boxed_Box_core_mem_maybe_uninit_MaybeUninit_T_A.
  
  Module Impl_alloc_boxed_Box_slice_core_mem_maybe_uninit_MaybeUninit_T_A.
    Definition Self (T A : Ty.t) : Ty.t :=
      Ty.apply
        (Ty.path "alloc::boxed::Box")
        [
          Ty.apply
            (Ty.path "slice")
            [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ T ] ];
          A
        ].
    
    (*
        pub unsafe fn assume_init(self) -> Box<[T], A> {
            let (raw, alloc) = Box::into_raw_with_allocator(self);
            unsafe { Box::from_raw_in(raw as *mut [T], alloc) }
        }
    *)
    Definition assume_init (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "alloc::boxed::Box")
                      [
                        Ty.apply
                          (Ty.path "slice")
                          [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ T ] ];
                        A
                      ],
                    "into_raw_with_allocator",
                    []
                  |),
                  [ M.read (| self |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let raw := M.copy (| γ0_0 |) in
                    let alloc := M.copy (| γ0_1 |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply
                            (Ty.path "alloc::boxed::Box")
                            [ Ty.apply (Ty.path "slice") [ T ]; A ],
                          "from_raw_in",
                          []
                        |),
                        [ M.rust_cast (M.read (| raw |)); M.read (| alloc |) ]
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_assume_init :
      forall (T A : Ty.t),
      M.IsAssociatedFunction (Self T A) "assume_init" (assume_init T A).
  End Impl_alloc_boxed_Box_slice_core_mem_maybe_uninit_MaybeUninit_T_A.
  
  
  
  Module Impl_core_ops_drop_Drop_where_core_marker_Sized_T_where_core_alloc_Allocator_A_for_alloc_boxed_Box_T_A.
    Definition Self (T A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::boxed::Box") [ T; A ].
    
    (*
        fn drop(&mut self) {
            // the T in the Box is dropped by the compiler before the destructor is run
    
            let ptr = self.0;
    
            unsafe {
                let layout = Layout::for_value_raw(ptr.as_ptr());
                if layout.size() != 0 {
                    self.1.deallocate(From::from(ptr.cast()), layout);
                }
            }
        }
    *)
    Definition drop (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            let ptr :=
              M.copy (|
                M.SubPointer.get_struct_tuple_field (| M.read (| self |), "alloc::boxed::Box", 0 |)
              |) in
            let layout :=
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.path "core::alloc::layout::Layout",
                    "for_value_raw",
                    [ T ]
                  |),
                  [
                    (* MutToConstPointer *)
                    M.pointer_coercion
                      (M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "core::ptr::unique::Unique") [ T ],
                          "as_ptr",
                          []
                        |),
                        [ M.read (| ptr |) ]
                      |))
                  ]
                |)
              |) in
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          BinOp.Pure.ne
                            (M.call_closure (|
                              M.get_associated_function (|
                                Ty.path "core::alloc::layout::Layout",
                                "size",
                                []
                              |),
                              [ layout ]
                            |))
                            (Value.Integer 0)
                        |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    let _ :=
                      M.alloc (|
                        M.call_closure (|
                          M.get_trait_method (|
                            "core::alloc::Allocator",
                            A,
                            [],
                            "deallocate",
                            []
                          |),
                          [
                            M.SubPointer.get_struct_tuple_field (|
                              M.read (| self |),
                              "alloc::boxed::Box",
                              1
                            |);
                            M.call_closure (|
                              M.get_trait_method (|
                                "core::convert::From",
                                Ty.apply (Ty.path "core::ptr::non_null::NonNull") [ Ty.path "u8" ],
                                [ Ty.apply (Ty.path "core::ptr::unique::Unique") [ Ty.path "u8" ] ],
                                "from",
                                []
                              |),
                              [
                                M.call_closure (|
                                  M.get_associated_function (|
                                    Ty.apply (Ty.path "core::ptr::unique::Unique") [ T ],
                                    "cast",
                                    [ Ty.path "u8" ]
                                  |),
                                  [ M.read (| ptr |) ]
                                |)
                              ]
                            |);
                            M.read (| layout |)
                          ]
                        |)
                      |) in
                    M.alloc (| Value.Tuple [] |)));
                fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (T A : Ty.t),
      M.IsTraitInstance
        "core::ops::drop::Drop"
        (Self T A)
        (* Trait polymorphic types *) []
        (* Instance *) [ ("drop", InstanceField.Method (drop T A)) ].
  End Impl_core_ops_drop_Drop_where_core_marker_Sized_T_where_core_alloc_Allocator_A_for_alloc_boxed_Box_T_A.
  
  Module Impl_core_default_Default_where_core_default_Default_T_for_alloc_boxed_Box_T_alloc_alloc_Global.
    Definition Self (T : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "alloc::boxed::Box") [ T; Ty.path "alloc::alloc::Global" ].
    
    (*
        fn default() -> Self {
            Box::new(T::default())
        }
    *)
    Definition default (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match τ, α with
      | [], [] =>
        ltac:(M.monadic
          (M.call_closure (|
            M.get_associated_function (|
              Ty.apply (Ty.path "alloc::boxed::Box") [ T; Ty.path "alloc::alloc::Global" ],
              "new",
              []
            |),
            [
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "core::default::Default"
        (Self T)
        (* Trait polymorphic types *) []
        (* Instance *) [ ("default", InstanceField.Method (default T)) ].
  End Impl_core_default_Default_where_core_default_Default_T_for_alloc_boxed_Box_T_alloc_alloc_Global.
  
  Module Impl_core_default_Default_for_alloc_boxed_Box_slice_T_alloc_alloc_Global.
    Definition Self (T : Ty.t) : Ty.t :=
      Ty.apply
        (Ty.path "alloc::boxed::Box")
        [ Ty.apply (Ty.path "slice") [ T ]; Ty.path "alloc::alloc::Global" ].
    
    (*
        fn default() -> Self {
            let ptr: Unique<[T]> = Unique::<[T; 0]>::dangling();
            Box(ptr, Global)
        }
    *)
    Definition default (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match τ, α with
      | [], [] =>
        ltac:(M.monadic
          (M.read (|
            let ptr :=
              M.alloc (|
                (* Unsize *)
                M.pointer_coercion
                  (M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "core::ptr::unique::Unique")
                        [ Ty.apply (Ty.path "array") [ T ] ],
                      "dangling",
                      []
                    |),
                    []
                  |))
              |) in
            M.alloc (|
              Value.StructTuple
                "alloc::boxed::Box"
                [ M.read (| ptr |); Value.StructTuple "alloc::alloc::Global" [] ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "core::default::Default"
        (Self T)
        (* Trait polymorphic types *) []
        (* Instance *) [ ("default", InstanceField.Method (default T)) ].
  End Impl_core_default_Default_for_alloc_boxed_Box_slice_T_alloc_alloc_Global.
  
  Module Impl_core_default_Default_for_alloc_boxed_Box_str_alloc_alloc_Global.
    Definition Self : Ty.t :=
      Ty.apply (Ty.path "alloc::boxed::Box") [ Ty.path "str"; Ty.path "alloc::alloc::Global" ].
    
    (*
        fn default() -> Self {
            // SAFETY: This is the same as `Unique::cast<U>` but with an unsized `U = str`.
            let ptr: Unique<str> = unsafe {
                let bytes: Unique<[u8]> = Unique::<[u8; 0]>::dangling();
                Unique::new_unchecked(bytes.as_ptr() as *mut str)
            };
            Box(ptr, Global)
        }
    *)
    Definition default (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [] =>
        ltac:(M.monadic
          (M.read (|
            let ptr :=
              M.copy (|
                let bytes :=
                  M.alloc (|
                    (* Unsize *)
                    M.pointer_coercion
                      (M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply
                            (Ty.path "core::ptr::unique::Unique")
                            [ Ty.apply (Ty.path "array") [ Ty.path "u8" ] ],
                          "dangling",
                          []
                        |),
                        []
                      |))
                  |) in
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply (Ty.path "core::ptr::unique::Unique") [ Ty.path "str" ],
                      "new_unchecked",
                      []
                    |),
                    [
                      M.rust_cast
                        (M.call_closure (|
                          M.get_associated_function (|
                            Ty.apply
                              (Ty.path "core::ptr::unique::Unique")
                              [ Ty.apply (Ty.path "slice") [ Ty.path "u8" ] ],
                            "as_ptr",
                            []
                          |),
                          [ M.read (| bytes |) ]
                        |))
                    ]
                  |)
                |)
              |) in
            M.alloc (|
              Value.StructTuple
                "alloc::boxed::Box"
                [ M.read (| ptr |); Value.StructTuple "alloc::alloc::Global" [] ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::default::Default"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("default", InstanceField.Method default) ].
  End Impl_core_default_Default_for_alloc_boxed_Box_str_alloc_alloc_Global.
  
  Module Impl_core_clone_Clone_where_core_clone_Clone_T_where_core_alloc_Allocator_A_where_core_clone_Clone_A_for_alloc_boxed_Box_T_A.
    Definition Self (T A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::boxed::Box") [ T; A ].
    
    (*
        fn clone(&self) -> Self {
            // Pre-allocate memory to allow writing the cloned value directly.
            let mut boxed = Self::new_uninit_in(self.1.clone());
            unsafe {
                ( **self).write_clone_into_raw(boxed.as_mut_ptr());
                boxed.assume_init()
            }
        }
    *)
    Definition clone (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            let boxed :=
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "alloc::boxed::Box") [ T; A ],
                    "new_uninit_in",
                    []
                  |),
                  [
                    M.call_closure (|
                      M.get_trait_method (| "core::clone::Clone", A, [], "clone", [] |),
                      [
                        M.SubPointer.get_struct_tuple_field (|
                          M.read (| self |),
                          "alloc::boxed::Box",
                          1
                        |)
                      ]
                    |)
                  ]
                |)
              |) in
            let _ :=
              M.alloc (|
                M.call_closure (|
                  M.get_trait_method (|
                    "alloc::alloc::WriteCloneIntoRaw",
                    T,
                    [],
                    "write_clone_into_raw",
                    []
                  |),
                  [
                    M.read (| M.read (| self |) |);
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ T ],
                        "as_mut_ptr",
                        []
                      |),
                      [ M.read (| boxed |) ]
                    |)
                  ]
                |)
              |) in
            M.alloc (|
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "alloc::boxed::Box")
                    [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ T ]; A ],
                  "assume_init",
                  []
                |),
                [ M.read (| boxed |) ]
              |)
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    (*
        fn clone_from(&mut self, source: &Self) {
            ( **self).clone_from(&( **source));
        }
    *)
    Definition clone_from (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match τ, α with
      | [], [ self; source ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let source := M.alloc (| source |) in
          M.read (|
            let _ :=
              M.alloc (|
                M.call_closure (|
                  M.get_trait_method (| "core::clone::Clone", T, [], "clone_from", [] |),
                  [ M.read (| M.read (| self |) |); M.read (| M.read (| source |) |) ]
                |)
              |) in
            M.alloc (| Value.Tuple [] |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (T A : Ty.t),
      M.IsTraitInstance
        "core::clone::Clone"
        (Self T A)
        (* Trait polymorphic types *) []
        (* Instance *)
        [
          ("clone", InstanceField.Method (clone T A));
          ("clone_from", InstanceField.Method (clone_from T A))
        ].
  End Impl_core_clone_Clone_where_core_clone_Clone_T_where_core_alloc_Allocator_A_where_core_clone_Clone_A_for_alloc_boxed_Box_T_A.
  
  Module Impl_core_clone_Clone_for_alloc_boxed_Box_str_alloc_alloc_Global.
    Definition Self : Ty.t :=
      Ty.apply (Ty.path "alloc::boxed::Box") [ Ty.path "str"; Ty.path "alloc::alloc::Global" ].
    
    (*
        fn clone(&self) -> Self {
            // this makes a copy of the data
            let buf: Box<[u8]> = self.as_bytes().into();
            unsafe { from_boxed_utf8_unchecked(buf) }
        }
    *)
    Definition clone (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            let buf :=
              M.alloc (|
                M.call_closure (|
                  M.get_trait_method (|
                    "core::convert::Into",
                    Ty.apply (Ty.path "&") [ Ty.apply (Ty.path "slice") [ Ty.path "u8" ] ],
                    [
                      Ty.apply
                        (Ty.path "alloc::boxed::Box")
                        [
                          Ty.apply (Ty.path "slice") [ Ty.path "u8" ];
                          Ty.path "alloc::alloc::Global"
                        ]
                    ],
                    "into",
                    []
                  |),
                  [
                    M.call_closure (|
                      M.get_associated_function (| Ty.path "str", "as_bytes", [] |),
                      [ M.read (| M.read (| self |) |) ]
                    |)
                  ]
                |)
              |) in
            M.alloc (|
              M.call_closure (|
                M.get_function (| "alloc::str::from_boxed_utf8_unchecked", [] |),
                [ M.read (| buf |) ]
              |)
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::clone::Clone"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("clone", InstanceField.Method clone) ].
  End Impl_core_clone_Clone_for_alloc_boxed_Box_str_alloc_alloc_Global.
  
  Module Impl_core_cmp_PartialEq_where_core_marker_Sized_T_where_core_cmp_PartialEq_T_where_core_alloc_Allocator_A_for_alloc_boxed_Box_T_A.
    Definition Self (T A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::boxed::Box") [ T; A ].
    
    (*
        fn eq(&self, other: &Self) -> bool {
            PartialEq::eq(&**self, &**other)
        }
    *)
    Definition eq (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match τ, α with
      | [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            M.get_trait_method (| "core::cmp::PartialEq", T, [ T ], "eq", [] |),
            [ M.read (| M.read (| self |) |); M.read (| M.read (| other |) |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    (*
        fn ne(&self, other: &Self) -> bool {
            PartialEq::ne(&**self, &**other)
        }
    *)
    Definition ne (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match τ, α with
      | [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            M.get_trait_method (| "core::cmp::PartialEq", T, [ T ], "ne", [] |),
            [ M.read (| M.read (| self |) |); M.read (| M.read (| other |) |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (T A : Ty.t),
      M.IsTraitInstance
        "core::cmp::PartialEq"
        (Self T A)
        (* Trait polymorphic types *) []
        (* Instance *)
        [ ("eq", InstanceField.Method (eq T A)); ("ne", InstanceField.Method (ne T A)) ].
  End Impl_core_cmp_PartialEq_where_core_marker_Sized_T_where_core_cmp_PartialEq_T_where_core_alloc_Allocator_A_for_alloc_boxed_Box_T_A.
  
  Module Impl_core_cmp_PartialOrd_where_core_marker_Sized_T_where_core_cmp_PartialOrd_T_where_core_alloc_Allocator_A_for_alloc_boxed_Box_T_A.
    Definition Self (T A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::boxed::Box") [ T; A ].
    
    (*
        fn partial_cmp(&self, other: &Self) -> Option<Ordering> {
            PartialOrd::partial_cmp(&**self, &**other)
        }
    *)
    Definition partial_cmp (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match τ, α with
      | [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            M.get_trait_method (| "core::cmp::PartialOrd", T, [ T ], "partial_cmp", [] |),
            [ M.read (| M.read (| self |) |); M.read (| M.read (| other |) |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    (*
        fn lt(&self, other: &Self) -> bool {
            PartialOrd::lt(&**self, &**other)
        }
    *)
    Definition lt (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match τ, α with
      | [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            M.get_trait_method (| "core::cmp::PartialOrd", T, [ T ], "lt", [] |),
            [ M.read (| M.read (| self |) |); M.read (| M.read (| other |) |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    (*
        fn le(&self, other: &Self) -> bool {
            PartialOrd::le(&**self, &**other)
        }
    *)
    Definition le (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match τ, α with
      | [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            M.get_trait_method (| "core::cmp::PartialOrd", T, [ T ], "le", [] |),
            [ M.read (| M.read (| self |) |); M.read (| M.read (| other |) |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    (*
        fn ge(&self, other: &Self) -> bool {
            PartialOrd::ge(&**self, &**other)
        }
    *)
    Definition ge (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match τ, α with
      | [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            M.get_trait_method (| "core::cmp::PartialOrd", T, [ T ], "ge", [] |),
            [ M.read (| M.read (| self |) |); M.read (| M.read (| other |) |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    (*
        fn gt(&self, other: &Self) -> bool {
            PartialOrd::gt(&**self, &**other)
        }
    *)
    Definition gt (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match τ, α with
      | [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            M.get_trait_method (| "core::cmp::PartialOrd", T, [ T ], "gt", [] |),
            [ M.read (| M.read (| self |) |); M.read (| M.read (| other |) |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (T A : Ty.t),
      M.IsTraitInstance
        "core::cmp::PartialOrd"
        (Self T A)
        (* Trait polymorphic types *) []
        (* Instance *)
        [
          ("partial_cmp", InstanceField.Method (partial_cmp T A));
          ("lt", InstanceField.Method (lt T A));
          ("le", InstanceField.Method (le T A));
          ("ge", InstanceField.Method (ge T A));
          ("gt", InstanceField.Method (gt T A))
        ].
  End Impl_core_cmp_PartialOrd_where_core_marker_Sized_T_where_core_cmp_PartialOrd_T_where_core_alloc_Allocator_A_for_alloc_boxed_Box_T_A.
  
  Module Impl_core_cmp_Ord_where_core_marker_Sized_T_where_core_cmp_Ord_T_where_core_alloc_Allocator_A_for_alloc_boxed_Box_T_A.
    Definition Self (T A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::boxed::Box") [ T; A ].
    
    (*
        fn cmp(&self, other: &Self) -> Ordering {
            Ord::cmp(&**self, &**other)
        }
    *)
    Definition cmp (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match τ, α with
      | [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            M.get_trait_method (| "core::cmp::Ord", T, [], "cmp", [] |),
            [ M.read (| M.read (| self |) |); M.read (| M.read (| other |) |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (T A : Ty.t),
      M.IsTraitInstance
        "core::cmp::Ord"
        (Self T A)
        (* Trait polymorphic types *) []
        (* Instance *) [ ("cmp", InstanceField.Method (cmp T A)) ].
  End Impl_core_cmp_Ord_where_core_marker_Sized_T_where_core_cmp_Ord_T_where_core_alloc_Allocator_A_for_alloc_boxed_Box_T_A.
  
  Module Impl_core_cmp_Eq_where_core_marker_Sized_T_where_core_cmp_Eq_T_where_core_alloc_Allocator_A_for_alloc_boxed_Box_T_A.
    Definition Self (T A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::boxed::Box") [ T; A ].
    
    Axiom Implements :
      forall (T A : Ty.t),
      M.IsTraitInstance
        "core::cmp::Eq"
        (Self T A)
        (* Trait polymorphic types *) []
        (* Instance *) [].
  End Impl_core_cmp_Eq_where_core_marker_Sized_T_where_core_cmp_Eq_T_where_core_alloc_Allocator_A_for_alloc_boxed_Box_T_A.
  
  Module Impl_core_hash_Hash_where_core_marker_Sized_T_where_core_hash_Hash_T_where_core_alloc_Allocator_A_for_alloc_boxed_Box_T_A.
    Definition Self (T A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::boxed::Box") [ T; A ].
    
    (*
        fn hash<H: Hasher>(&self, state: &mut H) {
            ( **self).hash(state);
        }
    *)
    Definition hash (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match τ, α with
      | [ H ], [ self; state ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let state := M.alloc (| state |) in
          M.read (|
            let _ :=
              M.alloc (|
                M.call_closure (|
                  M.get_trait_method (| "core::hash::Hash", T, [], "hash", [ H ] |),
                  [ M.read (| M.read (| self |) |); M.read (| state |) ]
                |)
              |) in
            M.alloc (| Value.Tuple [] |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (T A : Ty.t),
      M.IsTraitInstance
        "core::hash::Hash"
        (Self T A)
        (* Trait polymorphic types *) []
        (* Instance *) [ ("hash", InstanceField.Method (hash T A)) ].
  End Impl_core_hash_Hash_where_core_marker_Sized_T_where_core_hash_Hash_T_where_core_alloc_Allocator_A_for_alloc_boxed_Box_T_A.
  
  Module Impl_core_hash_Hasher_where_core_marker_Sized_T_where_core_hash_Hasher_T_where_core_alloc_Allocator_A_for_alloc_boxed_Box_T_A.
    Definition Self (T A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::boxed::Box") [ T; A ].
    
    (*
        fn finish(&self) -> u64 {
            ( **self).finish()
        }
    *)
    Definition finish (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_trait_method (| "core::hash::Hasher", T, [], "finish", [] |),
            [ M.read (| M.read (| self |) |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    (*
        fn write(&mut self, bytes: &[u8]) {
            ( **self).write(bytes)
        }
    *)
    Definition write (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match τ, α with
      | [], [ self; bytes ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let bytes := M.alloc (| bytes |) in
          M.call_closure (|
            M.get_trait_method (| "core::hash::Hasher", T, [], "write", [] |),
            [ M.read (| M.read (| self |) |); M.read (| bytes |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    (*
        fn write_u8(&mut self, i: u8) {
            ( **self).write_u8(i)
        }
    *)
    Definition write_u8 (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match τ, α with
      | [], [ self; i ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let i := M.alloc (| i |) in
          M.call_closure (|
            M.get_trait_method (| "core::hash::Hasher", T, [], "write_u8", [] |),
            [ M.read (| M.read (| self |) |); M.read (| i |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    (*
        fn write_u16(&mut self, i: u16) {
            ( **self).write_u16(i)
        }
    *)
    Definition write_u16 (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match τ, α with
      | [], [ self; i ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let i := M.alloc (| i |) in
          M.call_closure (|
            M.get_trait_method (| "core::hash::Hasher", T, [], "write_u16", [] |),
            [ M.read (| M.read (| self |) |); M.read (| i |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    (*
        fn write_u32(&mut self, i: u32) {
            ( **self).write_u32(i)
        }
    *)
    Definition write_u32 (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match τ, α with
      | [], [ self; i ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let i := M.alloc (| i |) in
          M.call_closure (|
            M.get_trait_method (| "core::hash::Hasher", T, [], "write_u32", [] |),
            [ M.read (| M.read (| self |) |); M.read (| i |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    (*
        fn write_u64(&mut self, i: u64) {
            ( **self).write_u64(i)
        }
    *)
    Definition write_u64 (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match τ, α with
      | [], [ self; i ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let i := M.alloc (| i |) in
          M.call_closure (|
            M.get_trait_method (| "core::hash::Hasher", T, [], "write_u64", [] |),
            [ M.read (| M.read (| self |) |); M.read (| i |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    (*
        fn write_u128(&mut self, i: u128) {
            ( **self).write_u128(i)
        }
    *)
    Definition write_u128 (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match τ, α with
      | [], [ self; i ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let i := M.alloc (| i |) in
          M.call_closure (|
            M.get_trait_method (| "core::hash::Hasher", T, [], "write_u128", [] |),
            [ M.read (| M.read (| self |) |); M.read (| i |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    (*
        fn write_usize(&mut self, i: usize) {
            ( **self).write_usize(i)
        }
    *)
    Definition write_usize (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match τ, α with
      | [], [ self; i ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let i := M.alloc (| i |) in
          M.call_closure (|
            M.get_trait_method (| "core::hash::Hasher", T, [], "write_usize", [] |),
            [ M.read (| M.read (| self |) |); M.read (| i |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    (*
        fn write_i8(&mut self, i: i8) {
            ( **self).write_i8(i)
        }
    *)
    Definition write_i8 (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match τ, α with
      | [], [ self; i ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let i := M.alloc (| i |) in
          M.call_closure (|
            M.get_trait_method (| "core::hash::Hasher", T, [], "write_i8", [] |),
            [ M.read (| M.read (| self |) |); M.read (| i |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    (*
        fn write_i16(&mut self, i: i16) {
            ( **self).write_i16(i)
        }
    *)
    Definition write_i16 (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match τ, α with
      | [], [ self; i ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let i := M.alloc (| i |) in
          M.call_closure (|
            M.get_trait_method (| "core::hash::Hasher", T, [], "write_i16", [] |),
            [ M.read (| M.read (| self |) |); M.read (| i |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    (*
        fn write_i32(&mut self, i: i32) {
            ( **self).write_i32(i)
        }
    *)
    Definition write_i32 (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match τ, α with
      | [], [ self; i ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let i := M.alloc (| i |) in
          M.call_closure (|
            M.get_trait_method (| "core::hash::Hasher", T, [], "write_i32", [] |),
            [ M.read (| M.read (| self |) |); M.read (| i |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    (*
        fn write_i64(&mut self, i: i64) {
            ( **self).write_i64(i)
        }
    *)
    Definition write_i64 (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match τ, α with
      | [], [ self; i ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let i := M.alloc (| i |) in
          M.call_closure (|
            M.get_trait_method (| "core::hash::Hasher", T, [], "write_i64", [] |),
            [ M.read (| M.read (| self |) |); M.read (| i |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    (*
        fn write_i128(&mut self, i: i128) {
            ( **self).write_i128(i)
        }
    *)
    Definition write_i128 (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match τ, α with
      | [], [ self; i ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let i := M.alloc (| i |) in
          M.call_closure (|
            M.get_trait_method (| "core::hash::Hasher", T, [], "write_i128", [] |),
            [ M.read (| M.read (| self |) |); M.read (| i |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    (*
        fn write_isize(&mut self, i: isize) {
            ( **self).write_isize(i)
        }
    *)
    Definition write_isize (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match τ, α with
      | [], [ self; i ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let i := M.alloc (| i |) in
          M.call_closure (|
            M.get_trait_method (| "core::hash::Hasher", T, [], "write_isize", [] |),
            [ M.read (| M.read (| self |) |); M.read (| i |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    (*
        fn write_length_prefix(&mut self, len: usize) {
            ( **self).write_length_prefix(len)
        }
    *)
    Definition write_length_prefix (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match τ, α with
      | [], [ self; len ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let len := M.alloc (| len |) in
          M.call_closure (|
            M.get_trait_method (| "core::hash::Hasher", T, [], "write_length_prefix", [] |),
            [ M.read (| M.read (| self |) |); M.read (| len |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    (*
        fn write_str(&mut self, s: &str) {
            ( **self).write_str(s)
        }
    *)
    Definition write_str (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match τ, α with
      | [], [ self; s ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let s := M.alloc (| s |) in
          M.call_closure (|
            M.get_trait_method (| "core::hash::Hasher", T, [], "write_str", [] |),
            [ M.read (| M.read (| self |) |); M.read (| s |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (T A : Ty.t),
      M.IsTraitInstance
        "core::hash::Hasher"
        (Self T A)
        (* Trait polymorphic types *) []
        (* Instance *)
        [
          ("finish", InstanceField.Method (finish T A));
          ("write", InstanceField.Method (write T A));
          ("write_u8", InstanceField.Method (write_u8 T A));
          ("write_u16", InstanceField.Method (write_u16 T A));
          ("write_u32", InstanceField.Method (write_u32 T A));
          ("write_u64", InstanceField.Method (write_u64 T A));
          ("write_u128", InstanceField.Method (write_u128 T A));
          ("write_usize", InstanceField.Method (write_usize T A));
          ("write_i8", InstanceField.Method (write_i8 T A));
          ("write_i16", InstanceField.Method (write_i16 T A));
          ("write_i32", InstanceField.Method (write_i32 T A));
          ("write_i64", InstanceField.Method (write_i64 T A));
          ("write_i128", InstanceField.Method (write_i128 T A));
          ("write_isize", InstanceField.Method (write_isize T A));
          ("write_length_prefix", InstanceField.Method (write_length_prefix T A));
          ("write_str", InstanceField.Method (write_str T A))
        ].
  End Impl_core_hash_Hasher_where_core_marker_Sized_T_where_core_hash_Hasher_T_where_core_alloc_Allocator_A_for_alloc_boxed_Box_T_A.
  
  Module Impl_core_convert_From_T_for_alloc_boxed_Box_T_alloc_alloc_Global.
    Definition Self (T : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "alloc::boxed::Box") [ T; Ty.path "alloc::alloc::Global" ].
    
    (*
        fn from(t: T) -> Self {
            Box::new(t)
        }
    *)
    Definition from (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match τ, α with
      | [], [ t ] =>
        ltac:(M.monadic
          (let t := M.alloc (| t |) in
          M.call_closure (|
            M.get_associated_function (|
              Ty.apply (Ty.path "alloc::boxed::Box") [ T; Ty.path "alloc::alloc::Global" ],
              "new",
              []
            |),
            [ M.read (| t |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "core::convert::From"
        (Self T)
        (* Trait polymorphic types *) [ (* T *) T ]
        (* Instance *) [ ("from", InstanceField.Method (from T)) ].
  End Impl_core_convert_From_T_for_alloc_boxed_Box_T_alloc_alloc_Global.
  
  Module Impl_core_convert_From_where_core_marker_Sized_T_where_core_alloc_Allocator_A_alloc_boxed_Box_T_A_for_core_pin_Pin_alloc_boxed_Box_T_A.
    Definition Self (T A : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "core::pin::Pin") [ Ty.apply (Ty.path "alloc::boxed::Box") [ T; A ] ].
    
    (*
        fn from(boxed: Box<T, A>) -> Self {
            Box::into_pin(boxed)
        }
    *)
    Definition from (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match τ, α with
      | [], [ boxed ] =>
        ltac:(M.monadic
          (let boxed := M.alloc (| boxed |) in
          M.call_closure (|
            M.get_associated_function (|
              Ty.apply (Ty.path "alloc::boxed::Box") [ T; A ],
              "into_pin",
              []
            |),
            [ M.read (| boxed |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (T A : Ty.t),
      M.IsTraitInstance
        "core::convert::From"
        (Self T A)
        (* Trait polymorphic types *) [ (* T *) Ty.apply (Ty.path "alloc::boxed::Box") [ T; A ] ]
        (* Instance *) [ ("from", InstanceField.Method (from T A)) ].
  End Impl_core_convert_From_where_core_marker_Sized_T_where_core_alloc_Allocator_A_alloc_boxed_Box_T_A_for_core_pin_Pin_alloc_boxed_Box_T_A.
  
  (* Trait *)
  (* Empty module 'BoxFromSlice' *)
  
  Module Impl_alloc_boxed_BoxFromSlice_where_core_clone_Clone_T_T_for_alloc_boxed_Box_slice_T_alloc_alloc_Global.
    Definition Self (T : Ty.t) : Ty.t :=
      Ty.apply
        (Ty.path "alloc::boxed::Box")
        [ Ty.apply (Ty.path "slice") [ T ]; Ty.path "alloc::alloc::Global" ].
    
    (*
        default fn from_slice(slice: &[T]) -> Self {
            slice.to_vec().into_boxed_slice()
        }
    *)
    Definition from_slice (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match τ, α with
      | [], [ slice ] =>
        ltac:(M.monadic
          (let slice := M.alloc (| slice |) in
          M.call_closure (|
            M.get_associated_function (|
              Ty.apply (Ty.path "alloc::vec::Vec") [ T; Ty.path "alloc::alloc::Global" ],
              "into_boxed_slice",
              []
            |),
            [
              M.call_closure (|
                M.get_associated_function (| Ty.apply (Ty.path "slice") [ T ], "to_vec", [] |),
                [ M.read (| slice |) ]
              |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "alloc::boxed::BoxFromSlice"
        (Self T)
        (* Trait polymorphic types *) [ (* T *) T ]
        (* Instance *) [ ("from_slice", InstanceField.Method (from_slice T)) ].
  End Impl_alloc_boxed_BoxFromSlice_where_core_clone_Clone_T_T_for_alloc_boxed_Box_slice_T_alloc_alloc_Global.
  
  Module Impl_alloc_boxed_BoxFromSlice_where_core_marker_Copy_T_T_for_alloc_boxed_Box_slice_T_alloc_alloc_Global.
    Definition Self (T : Ty.t) : Ty.t :=
      Ty.apply
        (Ty.path "alloc::boxed::Box")
        [ Ty.apply (Ty.path "slice") [ T ]; Ty.path "alloc::alloc::Global" ].
    
    (*
        fn from_slice(slice: &[T]) -> Self {
            let len = slice.len();
            let buf = RawVec::with_capacity(len);
            unsafe {
                ptr::copy_nonoverlapping(slice.as_ptr(), buf.ptr(), len);
                buf.into_box(slice.len()).assume_init()
            }
        }
    *)
    Definition from_slice (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match τ, α with
      | [], [ slice ] =>
        ltac:(M.monadic
          (let slice := M.alloc (| slice |) in
          M.read (|
            let len :=
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.apply (Ty.path "slice") [ T ], "len", [] |),
                  [ M.read (| slice |) ]
                |)
              |) in
            let buf :=
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "alloc::raw_vec::RawVec")
                      [ T; Ty.path "alloc::alloc::Global" ],
                    "with_capacity",
                    []
                  |),
                  [ M.read (| len |) ]
                |)
              |) in
            let _ :=
              M.alloc (|
                M.call_closure (|
                  M.get_function (| "core::intrinsics::copy_nonoverlapping", [ T ] |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "slice") [ T ],
                        "as_ptr",
                        []
                      |),
                      [ M.read (| slice |) ]
                    |);
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "alloc::raw_vec::RawVec")
                          [ T; Ty.path "alloc::alloc::Global" ],
                        "ptr",
                        []
                      |),
                      [ buf ]
                    |);
                    M.read (| len |)
                  ]
                |)
              |) in
            M.alloc (|
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "alloc::boxed::Box")
                    [
                      Ty.apply
                        (Ty.path "slice")
                        [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ T ] ];
                      Ty.path "alloc::alloc::Global"
                    ],
                  "assume_init",
                  []
                |),
                [
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "alloc::raw_vec::RawVec")
                        [ T; Ty.path "alloc::alloc::Global" ],
                      "into_box",
                      []
                    |),
                    [
                      M.read (| buf |);
                      M.call_closure (|
                        M.get_associated_function (| Ty.apply (Ty.path "slice") [ T ], "len", [] |),
                        [ M.read (| slice |) ]
                      |)
                    ]
                  |)
                ]
              |)
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "alloc::boxed::BoxFromSlice"
        (Self T)
        (* Trait polymorphic types *) [ (* T *) T ]
        (* Instance *) [ ("from_slice", InstanceField.Method (from_slice T)) ].
  End Impl_alloc_boxed_BoxFromSlice_where_core_marker_Copy_T_T_for_alloc_boxed_Box_slice_T_alloc_alloc_Global.
  
  Module Impl_core_convert_From_where_core_clone_Clone_T_ref__slice_T_for_alloc_boxed_Box_slice_T_alloc_alloc_Global.
    Definition Self (T : Ty.t) : Ty.t :=
      Ty.apply
        (Ty.path "alloc::boxed::Box")
        [ Ty.apply (Ty.path "slice") [ T ]; Ty.path "alloc::alloc::Global" ].
    
    (*
        fn from(slice: &[T]) -> Box<[T]> {
            <Self as BoxFromSlice<T>>::from_slice(slice)
        }
    *)
    Definition from (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match τ, α with
      | [], [ slice ] =>
        ltac:(M.monadic
          (let slice := M.alloc (| slice |) in
          M.call_closure (|
            M.get_trait_method (|
              "alloc::boxed::BoxFromSlice",
              Ty.apply
                (Ty.path "alloc::boxed::Box")
                [ Ty.apply (Ty.path "slice") [ T ]; Ty.path "alloc::alloc::Global" ],
              [ T ],
              "from_slice",
              []
            |),
            [ M.read (| slice |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "core::convert::From"
        (Self T)
        (* Trait polymorphic types *)
        [ (* T *) Ty.apply (Ty.path "&") [ Ty.apply (Ty.path "slice") [ T ] ] ]
        (* Instance *) [ ("from", InstanceField.Method (from T)) ].
  End Impl_core_convert_From_where_core_clone_Clone_T_ref__slice_T_for_alloc_boxed_Box_slice_T_alloc_alloc_Global.
  
  Module Impl_core_convert_From_where_core_clone_Clone_T_alloc_borrow_Cow_slice_T_for_alloc_boxed_Box_slice_T_alloc_alloc_Global.
    Definition Self (T : Ty.t) : Ty.t :=
      Ty.apply
        (Ty.path "alloc::boxed::Box")
        [ Ty.apply (Ty.path "slice") [ T ]; Ty.path "alloc::alloc::Global" ].
    
    (*
        fn from(cow: Cow<'_, [T]>) -> Box<[T]> {
            match cow {
                Cow::Borrowed(slice) => Box::from(slice),
                Cow::Owned(slice) => Box::from(slice),
            }
        }
    *)
    Definition from (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match τ, α with
      | [], [ cow ] =>
        ltac:(M.monadic
          (let cow := M.alloc (| cow |) in
          M.read (|
            M.match_operator (|
              cow,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "alloc::borrow::Cow::Borrowed",
                        0
                      |) in
                    let slice := M.copy (| γ0_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_trait_method (|
                          "core::convert::From",
                          Ty.apply
                            (Ty.path "alloc::boxed::Box")
                            [ Ty.apply (Ty.path "slice") [ T ]; Ty.path "alloc::alloc::Global" ],
                          [ Ty.apply (Ty.path "&") [ Ty.apply (Ty.path "slice") [ T ] ] ],
                          "from",
                          []
                        |),
                        [ M.read (| slice |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 :=
                      M.SubPointer.get_struct_tuple_field (| γ, "alloc::borrow::Cow::Owned", 0 |) in
                    let slice := M.copy (| γ0_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_trait_method (|
                          "core::convert::From",
                          Ty.apply
                            (Ty.path "alloc::boxed::Box")
                            [ Ty.apply (Ty.path "slice") [ T ]; Ty.path "alloc::alloc::Global" ],
                          [
                            Ty.apply
                              (Ty.path "alloc::vec::Vec")
                              [ T; Ty.path "alloc::alloc::Global" ]
                          ],
                          "from",
                          []
                        |),
                        [ M.read (| slice |) ]
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "core::convert::From"
        (Self T)
        (* Trait polymorphic types *)
        [ (* T *) Ty.apply (Ty.path "alloc::borrow::Cow") [ Ty.apply (Ty.path "slice") [ T ] ] ]
        (* Instance *) [ ("from", InstanceField.Method (from T)) ].
  End Impl_core_convert_From_where_core_clone_Clone_T_alloc_borrow_Cow_slice_T_for_alloc_boxed_Box_slice_T_alloc_alloc_Global.
  
  Module Impl_core_convert_From_ref__str_for_alloc_boxed_Box_str_alloc_alloc_Global.
    Definition Self : Ty.t :=
      Ty.apply (Ty.path "alloc::boxed::Box") [ Ty.path "str"; Ty.path "alloc::alloc::Global" ].
    
    (*
        fn from(s: &str) -> Box<str> {
            unsafe { from_boxed_utf8_unchecked(Box::from(s.as_bytes())) }
        }
    *)
    Definition from (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ s ] =>
        ltac:(M.monadic
          (let s := M.alloc (| s |) in
          M.call_closure (|
            M.get_function (| "alloc::str::from_boxed_utf8_unchecked", [] |),
            [
              M.call_closure (|
                M.get_trait_method (|
                  "core::convert::From",
                  Ty.apply
                    (Ty.path "alloc::boxed::Box")
                    [ Ty.apply (Ty.path "slice") [ Ty.path "u8" ]; Ty.path "alloc::alloc::Global" ],
                  [ Ty.apply (Ty.path "&") [ Ty.apply (Ty.path "slice") [ Ty.path "u8" ] ] ],
                  "from",
                  []
                |),
                [
                  M.call_closure (|
                    M.get_associated_function (| Ty.path "str", "as_bytes", [] |),
                    [ M.read (| s |) ]
                  |)
                ]
              |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::convert::From"
        Self
        (* Trait polymorphic types *) [ (* T *) Ty.apply (Ty.path "&") [ Ty.path "str" ] ]
        (* Instance *) [ ("from", InstanceField.Method from) ].
  End Impl_core_convert_From_ref__str_for_alloc_boxed_Box_str_alloc_alloc_Global.
  
  Module Impl_core_convert_From_alloc_borrow_Cow_str_for_alloc_boxed_Box_str_alloc_alloc_Global.
    Definition Self : Ty.t :=
      Ty.apply (Ty.path "alloc::boxed::Box") [ Ty.path "str"; Ty.path "alloc::alloc::Global" ].
    
    (*
        fn from(cow: Cow<'_, str>) -> Box<str> {
            match cow {
                Cow::Borrowed(s) => Box::from(s),
                Cow::Owned(s) => Box::from(s),
            }
        }
    *)
    Definition from (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ cow ] =>
        ltac:(M.monadic
          (let cow := M.alloc (| cow |) in
          M.read (|
            M.match_operator (|
              cow,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "alloc::borrow::Cow::Borrowed",
                        0
                      |) in
                    let s := M.copy (| γ0_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_trait_method (|
                          "core::convert::From",
                          Ty.apply
                            (Ty.path "alloc::boxed::Box")
                            [ Ty.path "str"; Ty.path "alloc::alloc::Global" ],
                          [ Ty.apply (Ty.path "&") [ Ty.path "str" ] ],
                          "from",
                          []
                        |),
                        [ M.read (| s |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 :=
                      M.SubPointer.get_struct_tuple_field (| γ, "alloc::borrow::Cow::Owned", 0 |) in
                    let s := M.copy (| γ0_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_trait_method (|
                          "core::convert::From",
                          Ty.apply
                            (Ty.path "alloc::boxed::Box")
                            [ Ty.path "str"; Ty.path "alloc::alloc::Global" ],
                          [ Ty.path "alloc::string::String" ],
                          "from",
                          []
                        |),
                        [ M.read (| s |) ]
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::convert::From"
        Self
        (* Trait polymorphic types *)
        [ (* T *) Ty.apply (Ty.path "alloc::borrow::Cow") [ Ty.path "str" ] ]
        (* Instance *) [ ("from", InstanceField.Method from) ].
  End Impl_core_convert_From_alloc_borrow_Cow_str_for_alloc_boxed_Box_str_alloc_alloc_Global.
  
  Module Impl_core_convert_From_where_core_alloc_Allocator_A_alloc_boxed_Box_str_A_for_alloc_boxed_Box_slice_u8_A.
    Definition Self (A : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "alloc::boxed::Box") [ Ty.apply (Ty.path "slice") [ Ty.path "u8" ]; A ].
    
    (*
        fn from(s: Box<str, A>) -> Self {
            let (raw, alloc) = Box::into_raw_with_allocator(s);
            unsafe { Box::from_raw_in(raw as *mut [u8], alloc) }
        }
    *)
    Definition from (A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self A in
      match τ, α with
      | [], [ s ] =>
        ltac:(M.monadic
          (let s := M.alloc (| s |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "alloc::boxed::Box") [ Ty.path "str"; A ],
                    "into_raw_with_allocator",
                    []
                  |),
                  [ M.read (| s |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let raw := M.copy (| γ0_0 |) in
                    let alloc := M.copy (| γ0_1 |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply
                            (Ty.path "alloc::boxed::Box")
                            [ Ty.apply (Ty.path "slice") [ Ty.path "u8" ]; A ],
                          "from_raw_in",
                          []
                        |),
                        [ M.rust_cast (M.read (| raw |)); M.read (| alloc |) ]
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (A : Ty.t),
      M.IsTraitInstance
        "core::convert::From"
        (Self A)
        (* Trait polymorphic types *)
        [ (* T *) Ty.apply (Ty.path "alloc::boxed::Box") [ Ty.path "str"; A ] ]
        (* Instance *) [ ("from", InstanceField.Method (from A)) ].
  End Impl_core_convert_From_where_core_alloc_Allocator_A_alloc_boxed_Box_str_A_for_alloc_boxed_Box_slice_u8_A.
  
  Module Impl_core_convert_From_array_T_for_alloc_boxed_Box_slice_T_alloc_alloc_Global.
    Definition Self (T : Ty.t) : Ty.t :=
      Ty.apply
        (Ty.path "alloc::boxed::Box")
        [ Ty.apply (Ty.path "slice") [ T ]; Ty.path "alloc::alloc::Global" ].
    
    (*
        fn from(array: [T; N]) -> Box<[T]> {
            Box::new(array)
        }
    *)
    Definition from (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match τ, α with
      | [], [ array ] =>
        ltac:(M.monadic
          (let array := M.alloc (| array |) in
          (* Unsize *)
          M.pointer_coercion
            (M.call_closure (|
              M.get_associated_function (|
                Ty.apply
                  (Ty.path "alloc::boxed::Box")
                  [ Ty.apply (Ty.path "array") [ T ]; Ty.path "alloc::alloc::Global" ],
                "new",
                []
              |),
              [ M.read (| array |) ]
            |))))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "core::convert::From"
        (Self T)
        (* Trait polymorphic types *) [ (* T *) Ty.apply (Ty.path "array") [ T ] ]
        (* Instance *) [ ("from", InstanceField.Method (from T)) ].
  End Impl_core_convert_From_array_T_for_alloc_boxed_Box_slice_T_alloc_alloc_Global.
  
  (*
  unsafe fn boxed_slice_as_array_unchecked<T, A: Allocator, const N: usize>(
      boxed_slice: Box<[T], A>,
  ) -> Box<[T; N], A> {
      debug_assert_eq!(boxed_slice.len(), N);
  
      let (ptr, alloc) = Box::into_raw_with_allocator(boxed_slice);
      // SAFETY: Pointer and allocator came from an existing box,
      // and our safety condition requires that the length is exactly `N`
      unsafe { Box::from_raw_in(ptr as *mut [T; N], alloc) }
  }
  *)
  Definition boxed_slice_as_array_unchecked (τ : list Ty.t) (α : list Value.t) : M :=
    match τ, α with
    | [ T; A ], [ boxed_slice ] =>
      ltac:(M.monadic
        (let boxed_slice := M.alloc (| boxed_slice |) in
        M.read (|
          let _ :=
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.use (M.alloc (| Value.Bool true |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    let _ :=
                      M.match_operator (|
                        M.alloc (|
                          Value.Tuple
                            [
                              M.alloc (|
                                M.call_closure (|
                                  M.get_associated_function (|
                                    Ty.apply (Ty.path "slice") [ T ],
                                    "len",
                                    []
                                  |),
                                  [ M.read (| boxed_slice |) ]
                                |)
                              |);
                              M.get_constant (| "alloc::boxed::boxed_slice_as_array_unchecked::N" |)
                            ]
                        |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                              let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                              let left_val := M.copy (| γ0_0 |) in
                              let right_val := M.copy (| γ0_1 |) in
                              M.match_operator (|
                                M.alloc (| Value.Tuple [] |),
                                [
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let γ :=
                                        M.use
                                          (M.alloc (|
                                            UnOp.Pure.not
                                              (BinOp.Pure.eq
                                                (M.read (| M.read (| left_val |) |))
                                                (M.read (| M.read (| right_val |) |)))
                                          |)) in
                                      let _ :=
                                        M.is_constant_or_break_match (|
                                          M.read (| γ |),
                                          Value.Bool true
                                        |) in
                                      M.alloc (|
                                        M.never_to_any (|
                                          M.read (|
                                            let kind :=
                                              M.alloc (|
                                                Value.StructTuple
                                                  "core::panicking::AssertKind::Eq"
                                                  []
                                              |) in
                                            M.alloc (|
                                              M.call_closure (|
                                                M.get_function (|
                                                  "core::panicking::assert_failed",
                                                  [ Ty.path "usize"; Ty.path "usize" ]
                                                |),
                                                [
                                                  M.read (| kind |);
                                                  M.read (| left_val |);
                                                  M.read (| right_val |);
                                                  Value.StructTuple "core::option::Option::None" []
                                                ]
                                              |)
                                            |)
                                          |)
                                        |)
                                      |)));
                                  fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                                ]
                              |)))
                        ]
                      |) in
                    M.alloc (| Value.Tuple [] |)));
                fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
              ]
            |) in
          M.match_operator (|
            M.alloc (|
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply (Ty.path "alloc::boxed::Box") [ Ty.apply (Ty.path "slice") [ T ]; A ],
                  "into_raw_with_allocator",
                  []
                |),
                [ M.read (| boxed_slice |) ]
              |)
            |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                  let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                  let ptr := M.copy (| γ0_0 |) in
                  let alloc := M.copy (| γ0_1 |) in
                  M.alloc (|
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "alloc::boxed::Box")
                          [ Ty.apply (Ty.path "array") [ T ]; A ],
                        "from_raw_in",
                        []
                      |),
                      [ M.rust_cast (M.read (| ptr |)); M.read (| alloc |) ]
                    |)
                  |)))
            ]
          |)
        |)))
    | _, _ => M.impossible
    end.
  
  Module Impl_core_convert_TryFrom_alloc_boxed_Box_slice_T_alloc_alloc_Global_for_alloc_boxed_Box_array_T_alloc_alloc_Global.
    Definition Self (T : Ty.t) : Ty.t :=
      Ty.apply
        (Ty.path "alloc::boxed::Box")
        [ Ty.apply (Ty.path "array") [ T ]; Ty.path "alloc::alloc::Global" ].
    
    (*     type Error = Box<[T]>; *)
    Definition _Error (T : Ty.t) : Ty.t :=
      Ty.apply
        (Ty.path "alloc::boxed::Box")
        [ Ty.apply (Ty.path "slice") [ T ]; Ty.path "alloc::alloc::Global" ].
    
    (*
        fn try_from(boxed_slice: Box<[T]>) -> Result<Self, Self::Error> {
            if boxed_slice.len() == N {
                Ok(unsafe { boxed_slice_as_array_unchecked(boxed_slice) })
            } else {
                Err(boxed_slice)
            }
        }
    *)
    Definition try_from (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match τ, α with
      | [], [ boxed_slice ] =>
        ltac:(M.monadic
          (let boxed_slice := M.alloc (| boxed_slice |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          BinOp.Pure.eq
                            (M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply (Ty.path "slice") [ T ],
                                "len",
                                []
                              |),
                              [ M.read (| boxed_slice |) ]
                            |))
                            (M.read (| M.get_constant (| "alloc::boxed::N" |) |))
                        |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          M.call_closure (|
                            M.get_function (|
                              "alloc::boxed::boxed_slice_as_array_unchecked",
                              [ T; Ty.path "alloc::alloc::Global" ]
                            |),
                            [ M.read (| boxed_slice |) ]
                          |)
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      Value.StructTuple "core::result::Result::Err" [ M.read (| boxed_slice |) ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "core::convert::TryFrom"
        (Self T)
        (* Trait polymorphic types *)
        [
          (* T *)
          Ty.apply
            (Ty.path "alloc::boxed::Box")
            [ Ty.apply (Ty.path "slice") [ T ]; Ty.path "alloc::alloc::Global" ]
        ]
        (* Instance *)
        [ ("Error", InstanceField.Ty (_Error T)); ("try_from", InstanceField.Method (try_from T)) ].
  End Impl_core_convert_TryFrom_alloc_boxed_Box_slice_T_alloc_alloc_Global_for_alloc_boxed_Box_array_T_alloc_alloc_Global.
  
  Module Impl_core_convert_TryFrom_alloc_vec_Vec_T_alloc_alloc_Global_for_alloc_boxed_Box_array_T_alloc_alloc_Global.
    Definition Self (T : Ty.t) : Ty.t :=
      Ty.apply
        (Ty.path "alloc::boxed::Box")
        [ Ty.apply (Ty.path "array") [ T ]; Ty.path "alloc::alloc::Global" ].
    
    (*     type Error = Vec<T>; *)
    Definition _Error (T : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "alloc::vec::Vec") [ T; Ty.path "alloc::alloc::Global" ].
    
    (*
        fn try_from(vec: Vec<T>) -> Result<Self, Self::Error> {
            if vec.len() == N {
                let boxed_slice = vec.into_boxed_slice();
                Ok(unsafe { boxed_slice_as_array_unchecked(boxed_slice) })
            } else {
                Err(vec)
            }
        }
    *)
    Definition try_from (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match τ, α with
      | [], [ vec ] =>
        ltac:(M.monadic
          (let vec := M.alloc (| vec |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          BinOp.Pure.eq
                            (M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "alloc::vec::Vec")
                                  [ T; Ty.path "alloc::alloc::Global" ],
                                "len",
                                []
                              |),
                              [ vec ]
                            |))
                            (M.read (| M.get_constant (| "alloc::boxed::N" |) |))
                        |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    let boxed_slice :=
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.apply
                              (Ty.path "alloc::vec::Vec")
                              [ T; Ty.path "alloc::alloc::Global" ],
                            "into_boxed_slice",
                            []
                          |),
                          [ M.read (| vec |) ]
                        |)
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          M.call_closure (|
                            M.get_function (|
                              "alloc::boxed::boxed_slice_as_array_unchecked",
                              [ T; Ty.path "alloc::alloc::Global" ]
                            |),
                            [ M.read (| boxed_slice |) ]
                          |)
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      Value.StructTuple "core::result::Result::Err" [ M.read (| vec |) ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "core::convert::TryFrom"
        (Self T)
        (* Trait polymorphic types *)
        [ (* T *) Ty.apply (Ty.path "alloc::vec::Vec") [ T; Ty.path "alloc::alloc::Global" ] ]
        (* Instance *)
        [ ("Error", InstanceField.Ty (_Error T)); ("try_from", InstanceField.Method (try_from T)) ].
  End Impl_core_convert_TryFrom_alloc_vec_Vec_T_alloc_alloc_Global_for_alloc_boxed_Box_array_T_alloc_alloc_Global.
  
  Module Impl_alloc_boxed_Box_Dyn_core_any_Any_Trait_A.
    Definition Self (A : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "alloc::boxed::Box") [ Ty.dyn [ ("core::any::Any::Trait", []) ]; A ].
    
    (*
        pub fn downcast<T: Any>(self) -> Result<Box<T, A>, Self> {
            if self.is::<T>() { unsafe { Ok(self.downcast_unchecked::<T>()) } } else { Err(self) }
        }
    *)
    Definition downcast (A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self A in
      match τ, α with
      | [ T ], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.dyn [ ("core::any::Any::Trait", []) ],
                              "is",
                              [ T ]
                            |),
                            [ M.read (| self |) ]
                          |)
                        |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply
                                (Ty.path "alloc::boxed::Box")
                                [ Ty.dyn [ ("core::any::Any::Trait", []) ]; A ],
                              "downcast_unchecked",
                              [ T ]
                            |),
                            [ M.read (| self |) ]
                          |)
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Err"
                        [ (* Unsize *) M.pointer_coercion (M.read (| self |)) ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_downcast :
      forall (A : Ty.t),
      M.IsAssociatedFunction (Self A) "downcast" (downcast A).
    
    (*
        pub unsafe fn downcast_unchecked<T: Any>(self) -> Box<T, A> {
            debug_assert!(self.is::<T>());
            unsafe {
                let (raw, alloc): ( *mut dyn Any, _) = Box::into_raw_with_allocator(self);
                Box::from_raw_in(raw as *mut T, alloc)
            }
        }
    *)
    Definition downcast_unchecked (A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self A in
      match τ, α with
      | [ T ], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            let _ :=
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.use (M.alloc (| Value.Bool true |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      let _ :=
                        M.match_operator (|
                          M.alloc (| Value.Tuple [] |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ :=
                                  M.use
                                    (M.alloc (|
                                      UnOp.Pure.not
                                        (M.call_closure (|
                                          M.get_associated_function (|
                                            Ty.dyn [ ("core::any::Any::Trait", []) ],
                                            "is",
                                            [ T ]
                                          |),
                                          [ M.read (| self |) ]
                                        |))
                                    |)) in
                                let _ :=
                                  M.is_constant_or_break_match (|
                                    M.read (| γ |),
                                    Value.Bool true
                                  |) in
                                M.alloc (|
                                  M.never_to_any (|
                                    M.call_closure (|
                                      M.get_function (| "core::panicking::panic", [] |),
                                      [ M.read (| Value.String "assertion failed: self.is::<T>()" |)
                                      ]
                                    |)
                                  |)
                                |)));
                            fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                          ]
                        |) in
                      M.alloc (| Value.Tuple [] |)));
                  fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                ]
              |) in
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "alloc::boxed::Box")
                      [ Ty.dyn [ ("core::any::Any::Trait", []) ]; A ],
                    "into_raw_with_allocator",
                    []
                  |),
                  [ (* Unsize *) M.pointer_coercion (M.read (| self |)) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let raw := M.copy (| γ0_0 |) in
                    let alloc := M.copy (| γ0_1 |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "alloc::boxed::Box") [ T; A ],
                          "from_raw_in",
                          []
                        |),
                        [ M.rust_cast (M.read (| raw |)); M.read (| alloc |) ]
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_downcast_unchecked :
      forall (A : Ty.t),
      M.IsAssociatedFunction (Self A) "downcast_unchecked" (downcast_unchecked A).
    (*
        pub fn downcast<T: Any>(self) -> Result<Box<T, A>, Self> {
            if self.is::<T>() { unsafe { Ok(self.downcast_unchecked::<T>()) } } else { Err(self) }
        }
    *)
    Definition downcast (A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self A in
      match τ, α with
      | [ T ], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.dyn [ ("core::any::Any::Trait", []) ],
                              "is",
                              [ T ]
                            |),
                            [ M.read (| self |) ]
                          |)
                        |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply
                                (Ty.path "alloc::boxed::Box")
                                [ Ty.dyn [ ("core::any::Any::Trait", []) ]; A ],
                              "downcast_unchecked",
                              [ T ]
                            |),
                            [ M.read (| self |) ]
                          |)
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Err"
                        [ (* Unsize *) M.pointer_coercion (M.read (| self |)) ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_downcast :
      forall (A : Ty.t),
      M.IsAssociatedFunction (Self A) "downcast" (downcast A).
    
    (*
        pub unsafe fn downcast_unchecked<T: Any>(self) -> Box<T, A> {
            debug_assert!(self.is::<T>());
            unsafe {
                let (raw, alloc): ( *mut (dyn Any + Send), _) = Box::into_raw_with_allocator(self);
                Box::from_raw_in(raw as *mut T, alloc)
            }
        }
    *)
    Definition downcast_unchecked (A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self A in
      match τ, α with
      | [ T ], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            let _ :=
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.use (M.alloc (| Value.Bool true |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      let _ :=
                        M.match_operator (|
                          M.alloc (| Value.Tuple [] |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ :=
                                  M.use
                                    (M.alloc (|
                                      UnOp.Pure.not
                                        (M.call_closure (|
                                          M.get_associated_function (|
                                            Ty.dyn [ ("core::any::Any::Trait", []) ],
                                            "is",
                                            [ T ]
                                          |),
                                          [ M.read (| self |) ]
                                        |))
                                    |)) in
                                let _ :=
                                  M.is_constant_or_break_match (|
                                    M.read (| γ |),
                                    Value.Bool true
                                  |) in
                                M.alloc (|
                                  M.never_to_any (|
                                    M.call_closure (|
                                      M.get_function (| "core::panicking::panic", [] |),
                                      [ M.read (| Value.String "assertion failed: self.is::<T>()" |)
                                      ]
                                    |)
                                  |)
                                |)));
                            fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                          ]
                        |) in
                      M.alloc (| Value.Tuple [] |)));
                  fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                ]
              |) in
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "alloc::boxed::Box")
                      [ Ty.dyn [ ("core::any::Any::Trait", []) ]; A ],
                    "into_raw_with_allocator",
                    []
                  |),
                  [ (* Unsize *) M.pointer_coercion (M.read (| self |)) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let raw := M.copy (| γ0_0 |) in
                    let alloc := M.copy (| γ0_1 |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "alloc::boxed::Box") [ T; A ],
                          "from_raw_in",
                          []
                        |),
                        [ M.rust_cast (M.read (| raw |)); M.read (| alloc |) ]
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_downcast_unchecked :
      forall (A : Ty.t),
      M.IsAssociatedFunction (Self A) "downcast_unchecked" (downcast_unchecked A).
    (*
        pub fn downcast<T: Any>(self) -> Result<Box<T, A>, Self> {
            if self.is::<T>() { unsafe { Ok(self.downcast_unchecked::<T>()) } } else { Err(self) }
        }
    *)
    Definition downcast (A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self A in
      match τ, α with
      | [ T ], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.dyn [ ("core::any::Any::Trait", []) ],
                              "is",
                              [ T ]
                            |),
                            [ M.read (| self |) ]
                          |)
                        |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply
                                (Ty.path "alloc::boxed::Box")
                                [ Ty.dyn [ ("core::any::Any::Trait", []) ]; A ],
                              "downcast_unchecked",
                              [ T ]
                            |),
                            [ M.read (| self |) ]
                          |)
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Err"
                        [ (* Unsize *) M.pointer_coercion (M.read (| self |)) ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_downcast :
      forall (A : Ty.t),
      M.IsAssociatedFunction (Self A) "downcast" (downcast A).
    
    (*
        pub unsafe fn downcast_unchecked<T: Any>(self) -> Box<T, A> {
            debug_assert!(self.is::<T>());
            unsafe {
                let (raw, alloc): ( *mut (dyn Any + Send + Sync), _) =
                    Box::into_raw_with_allocator(self);
                Box::from_raw_in(raw as *mut T, alloc)
            }
        }
    *)
    Definition downcast_unchecked (A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self A in
      match τ, α with
      | [ T ], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            let _ :=
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.use (M.alloc (| Value.Bool true |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      let _ :=
                        M.match_operator (|
                          M.alloc (| Value.Tuple [] |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ :=
                                  M.use
                                    (M.alloc (|
                                      UnOp.Pure.not
                                        (M.call_closure (|
                                          M.get_associated_function (|
                                            Ty.dyn [ ("core::any::Any::Trait", []) ],
                                            "is",
                                            [ T ]
                                          |),
                                          [ M.read (| self |) ]
                                        |))
                                    |)) in
                                let _ :=
                                  M.is_constant_or_break_match (|
                                    M.read (| γ |),
                                    Value.Bool true
                                  |) in
                                M.alloc (|
                                  M.never_to_any (|
                                    M.call_closure (|
                                      M.get_function (| "core::panicking::panic", [] |),
                                      [ M.read (| Value.String "assertion failed: self.is::<T>()" |)
                                      ]
                                    |)
                                  |)
                                |)));
                            fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                          ]
                        |) in
                      M.alloc (| Value.Tuple [] |)));
                  fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                ]
              |) in
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "alloc::boxed::Box")
                      [ Ty.dyn [ ("core::any::Any::Trait", []) ]; A ],
                    "into_raw_with_allocator",
                    []
                  |),
                  [ (* Unsize *) M.pointer_coercion (M.read (| self |)) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let raw := M.copy (| γ0_0 |) in
                    let alloc := M.copy (| γ0_1 |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "alloc::boxed::Box") [ T; A ],
                          "from_raw_in",
                          []
                        |),
                        [ M.rust_cast (M.read (| raw |)); M.read (| alloc |) ]
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_downcast_unchecked :
      forall (A : Ty.t),
      M.IsAssociatedFunction (Self A) "downcast_unchecked" (downcast_unchecked A).
  End Impl_alloc_boxed_Box_Dyn_core_any_Any_Trait_A.
  
  
  
  Module Impl_core_fmt_Display_where_core_fmt_Display_T_where_core_marker_Sized_T_where_core_alloc_Allocator_A_for_alloc_boxed_Box_T_A.
    Definition Self (T A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::boxed::Box") [ T; A ].
    
    (*
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            fmt::Display::fmt(&**self, f)
        }
    *)
    Definition fmt (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match τ, α with
      | [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.call_closure (|
            M.get_trait_method (| "core::fmt::Display", T, [], "fmt", [] |),
            [ M.read (| M.read (| self |) |); M.read (| f |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (T A : Ty.t),
      M.IsTraitInstance
        "core::fmt::Display"
        (Self T A)
        (* Trait polymorphic types *) []
        (* Instance *) [ ("fmt", InstanceField.Method (fmt T A)) ].
  End Impl_core_fmt_Display_where_core_fmt_Display_T_where_core_marker_Sized_T_where_core_alloc_Allocator_A_for_alloc_boxed_Box_T_A.
  
  Module Impl_core_fmt_Debug_where_core_fmt_Debug_T_where_core_marker_Sized_T_where_core_alloc_Allocator_A_for_alloc_boxed_Box_T_A.
    Definition Self (T A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::boxed::Box") [ T; A ].
    
    (*
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            fmt::Debug::fmt(&**self, f)
        }
    *)
    Definition fmt (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match τ, α with
      | [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.call_closure (|
            M.get_trait_method (| "core::fmt::Debug", T, [], "fmt", [] |),
            [ M.read (| M.read (| self |) |); M.read (| f |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (T A : Ty.t),
      M.IsTraitInstance
        "core::fmt::Debug"
        (Self T A)
        (* Trait polymorphic types *) []
        (* Instance *) [ ("fmt", InstanceField.Method (fmt T A)) ].
  End Impl_core_fmt_Debug_where_core_fmt_Debug_T_where_core_marker_Sized_T_where_core_alloc_Allocator_A_for_alloc_boxed_Box_T_A.
  
  Module Impl_core_fmt_Pointer_where_core_marker_Sized_T_where_core_alloc_Allocator_A_for_alloc_boxed_Box_T_A.
    Definition Self (T A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::boxed::Box") [ T; A ].
    
    (*
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            // It's not possible to extract the inner Uniq directly from the Box,
            // instead we cast it to a *const which aliases the Unique
            let ptr: *const T = &**self;
            fmt::Pointer::fmt(&ptr, f)
        }
    *)
    Definition fmt (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match τ, α with
      | [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.read (|
            let ptr := M.alloc (| M.read (| M.read (| self |) |) |) in
            M.alloc (|
              M.call_closure (|
                M.get_trait_method (|
                  "core::fmt::Pointer",
                  Ty.apply (Ty.path "*const") [ T ],
                  [],
                  "fmt",
                  []
                |),
                [ ptr; M.read (| f |) ]
              |)
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (T A : Ty.t),
      M.IsTraitInstance
        "core::fmt::Pointer"
        (Self T A)
        (* Trait polymorphic types *) []
        (* Instance *) [ ("fmt", InstanceField.Method (fmt T A)) ].
  End Impl_core_fmt_Pointer_where_core_marker_Sized_T_where_core_alloc_Allocator_A_for_alloc_boxed_Box_T_A.
  
  Module Impl_core_ops_deref_Deref_where_core_marker_Sized_T_where_core_alloc_Allocator_A_for_alloc_boxed_Box_T_A.
    Definition Self (T A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::boxed::Box") [ T; A ].
    
    (*     type Target = T; *)
    Definition _Target (T A : Ty.t) : Ty.t := T.
    
    (*
        fn deref(&self) -> &T {
            &**self
        }
    *)
    Definition deref (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (| M.read (| self |) |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (T A : Ty.t),
      M.IsTraitInstance
        "core::ops::deref::Deref"
        (Self T A)
        (* Trait polymorphic types *) []
        (* Instance *)
        [ ("Target", InstanceField.Ty (_Target T A)); ("deref", InstanceField.Method (deref T A)) ].
  End Impl_core_ops_deref_Deref_where_core_marker_Sized_T_where_core_alloc_Allocator_A_for_alloc_boxed_Box_T_A.
  
  Module Impl_core_ops_deref_DerefMut_where_core_marker_Sized_T_where_core_alloc_Allocator_A_for_alloc_boxed_Box_T_A.
    Definition Self (T A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::boxed::Box") [ T; A ].
    
    (*
        fn deref_mut(&mut self) -> &mut T {
            &mut **self
        }
    *)
    Definition deref_mut (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (| M.read (| self |) |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (T A : Ty.t),
      M.IsTraitInstance
        "core::ops::deref::DerefMut"
        (Self T A)
        (* Trait polymorphic types *) []
        (* Instance *) [ ("deref_mut", InstanceField.Method (deref_mut T A)) ].
  End Impl_core_ops_deref_DerefMut_where_core_marker_Sized_T_where_core_alloc_Allocator_A_for_alloc_boxed_Box_T_A.
  
  Module Impl_core_ops_deref_Receiver_where_core_marker_Sized_T_where_core_alloc_Allocator_A_for_alloc_boxed_Box_T_A.
    Definition Self (T A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::boxed::Box") [ T; A ].
    
    Axiom Implements :
      forall (T A : Ty.t),
      M.IsTraitInstance
        "core::ops::deref::Receiver"
        (Self T A)
        (* Trait polymorphic types *) []
        (* Instance *) [].
  End Impl_core_ops_deref_Receiver_where_core_marker_Sized_T_where_core_alloc_Allocator_A_for_alloc_boxed_Box_T_A.
  
  Module Impl_core_iter_traits_iterator_Iterator_where_core_iter_traits_iterator_Iterator_I_where_core_marker_Sized_I_where_core_alloc_Allocator_A_for_alloc_boxed_Box_I_A.
    Definition Self (I A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::boxed::Box") [ I; A ].
    
    (*     type Item = I::Item; *)
    Definition _Item (I A : Ty.t) : Ty.t := Ty.associated.
    
    (*
        fn next(&mut self) -> Option<I::Item> {
            ( **self).next()
        }
    *)
    Definition next (I A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self I A in
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_trait_method (| "core::iter::traits::iterator::Iterator", I, [], "next", [] |),
            [ M.read (| M.read (| self |) |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    (*
        fn size_hint(&self) -> (usize, Option<usize>) {
            ( **self).size_hint()
        }
    *)
    Definition size_hint (I A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self I A in
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_trait_method (|
              "core::iter::traits::iterator::Iterator",
              I,
              [],
              "size_hint",
              []
            |),
            [ M.read (| M.read (| self |) |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    (*
        fn nth(&mut self, n: usize) -> Option<I::Item> {
            ( **self).nth(n)
        }
    *)
    Definition nth (I A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self I A in
      match τ, α with
      | [], [ self; n ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let n := M.alloc (| n |) in
          M.call_closure (|
            M.get_trait_method (| "core::iter::traits::iterator::Iterator", I, [], "nth", [] |),
            [ M.read (| M.read (| self |) |); M.read (| n |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    (*
        fn last(self) -> Option<I::Item> {
            BoxIter::last(self)
        }
    *)
    Definition last (I A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self I A in
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_trait_method (|
              "alloc::boxed::BoxIter",
              Ty.apply (Ty.path "alloc::boxed::Box") [ I; A ],
              [],
              "last",
              []
            |),
            [ M.read (| self |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (I A : Ty.t),
      M.IsTraitInstance
        "core::iter::traits::iterator::Iterator"
        (Self I A)
        (* Trait polymorphic types *) []
        (* Instance *)
        [
          ("Item", InstanceField.Ty (_Item I A));
          ("next", InstanceField.Method (next I A));
          ("size_hint", InstanceField.Method (size_hint I A));
          ("nth", InstanceField.Method (nth I A));
          ("last", InstanceField.Method (last I A))
        ].
  End Impl_core_iter_traits_iterator_Iterator_where_core_iter_traits_iterator_Iterator_I_where_core_marker_Sized_I_where_core_alloc_Allocator_A_for_alloc_boxed_Box_I_A.
  
  (* Trait *)
  (* Empty module 'BoxIter' *)
  
  Module Impl_alloc_boxed_BoxIter_where_core_iter_traits_iterator_Iterator_I_where_core_marker_Sized_I_where_core_alloc_Allocator_A_for_alloc_boxed_Box_I_A.
    Definition Self (I A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::boxed::Box") [ I; A ].
    
    (*     type Item = I::Item; *)
    Definition _Item (I A : Ty.t) : Ty.t := Ty.associated.
    
    (*
        default fn last(self) -> Option<I::Item> {
            #[inline]
            fn some<T>(_: Option<T>, x: T) -> Option<T> {
                Some(x)
            }
    
            self.fold(None, some)
        }
    *)
    Definition last (I A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self I A in
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_trait_method (|
              "core::iter::traits::iterator::Iterator",
              Ty.apply (Ty.path "alloc::boxed::Box") [ I; A ],
              [],
              "fold",
              [
                Ty.apply (Ty.path "core::option::Option") [ Ty.associated ];
                Ty.function
                  [ Ty.apply (Ty.path "core::option::Option") [ Ty.associated ]; Ty.associated ]
                  (Ty.apply (Ty.path "core::option::Option") [ Ty.associated ])
              ]
            |),
            [
              M.read (| self |);
              Value.StructTuple "core::option::Option::None" [];
              M.get_associated_function (| Self, "some.last", [] |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (I A : Ty.t),
      M.IsTraitInstance
        "alloc::boxed::BoxIter"
        (Self I A)
        (* Trait polymorphic types *) []
        (* Instance *)
        [ ("Item", InstanceField.Ty (_Item I A)); ("last", InstanceField.Method (last I A)) ].
  End Impl_alloc_boxed_BoxIter_where_core_iter_traits_iterator_Iterator_I_where_core_marker_Sized_I_where_core_alloc_Allocator_A_for_alloc_boxed_Box_I_A.
  
  Module Impl_alloc_boxed_BoxIter_where_core_iter_traits_iterator_Iterator_I_where_core_alloc_Allocator_A_for_alloc_boxed_Box_I_A.
    Definition Self (I A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::boxed::Box") [ I; A ].
    
    (*
        fn last(self) -> Option<I::Item> {
            ( *self).last()
        }
    *)
    Definition last (I A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self I A in
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_trait_method (| "core::iter::traits::iterator::Iterator", I, [], "last", [] |),
            [ M.read (| M.read (| self |) |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (I A : Ty.t),
      M.IsTraitInstance
        "alloc::boxed::BoxIter"
        (Self I A)
        (* Trait polymorphic types *) []
        (* Instance *) [ ("last", InstanceField.Method (last I A)) ].
  End Impl_alloc_boxed_BoxIter_where_core_iter_traits_iterator_Iterator_I_where_core_alloc_Allocator_A_for_alloc_boxed_Box_I_A.
  
  Module Impl_core_iter_traits_double_ended_DoubleEndedIterator_where_core_iter_traits_double_ended_DoubleEndedIterator_I_where_core_marker_Sized_I_where_core_alloc_Allocator_A_for_alloc_boxed_Box_I_A.
    Definition Self (I A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::boxed::Box") [ I; A ].
    
    (*
        fn next_back(&mut self) -> Option<I::Item> {
            ( **self).next_back()
        }
    *)
    Definition next_back (I A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self I A in
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_trait_method (|
              "core::iter::traits::double_ended::DoubleEndedIterator",
              I,
              [],
              "next_back",
              []
            |),
            [ M.read (| M.read (| self |) |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    (*
        fn nth_back(&mut self, n: usize) -> Option<I::Item> {
            ( **self).nth_back(n)
        }
    *)
    Definition nth_back (I A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self I A in
      match τ, α with
      | [], [ self; n ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let n := M.alloc (| n |) in
          M.call_closure (|
            M.get_trait_method (|
              "core::iter::traits::double_ended::DoubleEndedIterator",
              I,
              [],
              "nth_back",
              []
            |),
            [ M.read (| M.read (| self |) |); M.read (| n |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (I A : Ty.t),
      M.IsTraitInstance
        "core::iter::traits::double_ended::DoubleEndedIterator"
        (Self I A)
        (* Trait polymorphic types *) []
        (* Instance *)
        [
          ("next_back", InstanceField.Method (next_back I A));
          ("nth_back", InstanceField.Method (nth_back I A))
        ].
  End Impl_core_iter_traits_double_ended_DoubleEndedIterator_where_core_iter_traits_double_ended_DoubleEndedIterator_I_where_core_marker_Sized_I_where_core_alloc_Allocator_A_for_alloc_boxed_Box_I_A.
  
  Module Impl_core_iter_traits_exact_size_ExactSizeIterator_where_core_iter_traits_exact_size_ExactSizeIterator_I_where_core_marker_Sized_I_where_core_alloc_Allocator_A_for_alloc_boxed_Box_I_A.
    Definition Self (I A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::boxed::Box") [ I; A ].
    
    (*
        fn len(&self) -> usize {
            ( **self).len()
        }
    *)
    Definition len (I A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self I A in
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_trait_method (|
              "core::iter::traits::exact_size::ExactSizeIterator",
              I,
              [],
              "len",
              []
            |),
            [ M.read (| M.read (| self |) |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    (*
        fn is_empty(&self) -> bool {
            ( **self).is_empty()
        }
    *)
    Definition is_empty (I A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self I A in
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_trait_method (|
              "core::iter::traits::exact_size::ExactSizeIterator",
              I,
              [],
              "is_empty",
              []
            |),
            [ M.read (| M.read (| self |) |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (I A : Ty.t),
      M.IsTraitInstance
        "core::iter::traits::exact_size::ExactSizeIterator"
        (Self I A)
        (* Trait polymorphic types *) []
        (* Instance *)
        [ ("len", InstanceField.Method (len I A)); ("is_empty", InstanceField.Method (is_empty I A))
        ].
  End Impl_core_iter_traits_exact_size_ExactSizeIterator_where_core_iter_traits_exact_size_ExactSizeIterator_I_where_core_marker_Sized_I_where_core_alloc_Allocator_A_for_alloc_boxed_Box_I_A.
  
  Module Impl_core_iter_traits_marker_FusedIterator_where_core_iter_traits_marker_FusedIterator_I_where_core_marker_Sized_I_where_core_alloc_Allocator_A_for_alloc_boxed_Box_I_A.
    Definition Self (I A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::boxed::Box") [ I; A ].
    
    Axiom Implements :
      forall (I A : Ty.t),
      M.IsTraitInstance
        "core::iter::traits::marker::FusedIterator"
        (Self I A)
        (* Trait polymorphic types *) []
        (* Instance *) [].
  End Impl_core_iter_traits_marker_FusedIterator_where_core_iter_traits_marker_FusedIterator_I_where_core_marker_Sized_I_where_core_alloc_Allocator_A_for_alloc_boxed_Box_I_A.
  
  Module Impl_core_ops_function_FnOnce_where_core_marker_Tuple_Args_where_core_ops_function_FnOnce_F_Args_where_core_marker_Sized_F_where_core_alloc_Allocator_A_Args_for_alloc_boxed_Box_F_A.
    Definition Self (Args F A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::boxed::Box") [ F; A ].
    
    (*     type Output = <F as FnOnce<Args>>::Output; *)
    Definition _Output (Args F A : Ty.t) : Ty.t := Ty.associated.
    
    (*
        extern "rust-call" fn call_once(self, args: Args) -> Self::Output {
            <F as FnOnce<Args>>::call_once( *self, args)
        }
    *)
    Definition call_once (Args F A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self Args F A in
      match τ, α with
      | [], [ self; args ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let args := M.alloc (| args |) in
          M.call_closure (|
            M.get_trait_method (| "core::ops::function::FnOnce", F, [ Args ], "call_once", [] |),
            [ M.read (| M.read (| self |) |); M.read (| args |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (Args F A : Ty.t),
      M.IsTraitInstance
        "core::ops::function::FnOnce"
        (Self Args F A)
        (* Trait polymorphic types *) [ (* Args *) Args ]
        (* Instance *)
        [
          ("Output", InstanceField.Ty (_Output Args F A));
          ("call_once", InstanceField.Method (call_once Args F A))
        ].
  End Impl_core_ops_function_FnOnce_where_core_marker_Tuple_Args_where_core_ops_function_FnOnce_F_Args_where_core_marker_Sized_F_where_core_alloc_Allocator_A_Args_for_alloc_boxed_Box_F_A.
  
  Module Impl_core_ops_function_FnMut_where_core_marker_Tuple_Args_where_core_ops_function_FnMut_F_Args_where_core_marker_Sized_F_where_core_alloc_Allocator_A_Args_for_alloc_boxed_Box_F_A.
    Definition Self (Args F A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::boxed::Box") [ F; A ].
    
    (*
        extern "rust-call" fn call_mut(&mut self, args: Args) -> Self::Output {
            <F as FnMut<Args>>::call_mut(self, args)
        }
    *)
    Definition call_mut (Args F A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self Args F A in
      match τ, α with
      | [], [ self; args ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let args := M.alloc (| args |) in
          M.call_closure (|
            M.get_trait_method (| "core::ops::function::FnMut", F, [ Args ], "call_mut", [] |),
            [ M.read (| M.read (| self |) |); M.read (| args |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (Args F A : Ty.t),
      M.IsTraitInstance
        "core::ops::function::FnMut"
        (Self Args F A)
        (* Trait polymorphic types *) [ (* Args *) Args ]
        (* Instance *) [ ("call_mut", InstanceField.Method (call_mut Args F A)) ].
  End Impl_core_ops_function_FnMut_where_core_marker_Tuple_Args_where_core_ops_function_FnMut_F_Args_where_core_marker_Sized_F_where_core_alloc_Allocator_A_Args_for_alloc_boxed_Box_F_A.
  
  Module Impl_core_ops_function_Fn_where_core_marker_Tuple_Args_where_core_ops_function_Fn_F_Args_where_core_marker_Sized_F_where_core_alloc_Allocator_A_Args_for_alloc_boxed_Box_F_A.
    Definition Self (Args F A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::boxed::Box") [ F; A ].
    
    (*
        extern "rust-call" fn call(&self, args: Args) -> Self::Output {
            <F as Fn<Args>>::call(self, args)
        }
    *)
    Definition call (Args F A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self Args F A in
      match τ, α with
      | [], [ self; args ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let args := M.alloc (| args |) in
          M.call_closure (|
            M.get_trait_method (| "core::ops::function::Fn", F, [ Args ], "call", [] |),
            [ M.read (| M.read (| self |) |); M.read (| args |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (Args F A : Ty.t),
      M.IsTraitInstance
        "core::ops::function::Fn"
        (Self Args F A)
        (* Trait polymorphic types *) [ (* Args *) Args ]
        (* Instance *) [ ("call", InstanceField.Method (call Args F A)) ].
  End Impl_core_ops_function_Fn_where_core_marker_Tuple_Args_where_core_ops_function_Fn_F_Args_where_core_marker_Sized_F_where_core_alloc_Allocator_A_Args_for_alloc_boxed_Box_F_A.
  
  Module Impl_core_ops_unsize_CoerceUnsized_where_core_marker_Sized_T_where_core_marker_Unsize_T_U_where_core_marker_Sized_U_where_core_alloc_Allocator_A_alloc_boxed_Box_U_A_for_alloc_boxed_Box_T_A.
    Definition Self (T U A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::boxed::Box") [ T; A ].
    
    Axiom Implements :
      forall (T U A : Ty.t),
      M.IsTraitInstance
        "core::ops::unsize::CoerceUnsized"
        (Self T U A)
        (* Trait polymorphic types *) [ (* T *) Ty.apply (Ty.path "alloc::boxed::Box") [ U; A ] ]
        (* Instance *) [].
  End Impl_core_ops_unsize_CoerceUnsized_where_core_marker_Sized_T_where_core_marker_Unsize_T_U_where_core_marker_Sized_U_where_core_alloc_Allocator_A_alloc_boxed_Box_U_A_for_alloc_boxed_Box_T_A.
  
  Module Impl_core_ops_unsize_DispatchFromDyn_where_core_marker_Sized_T_where_core_marker_Unsize_T_U_where_core_marker_Sized_U_alloc_boxed_Box_U_alloc_alloc_Global_for_alloc_boxed_Box_T_alloc_alloc_Global.
    Definition Self (T U : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "alloc::boxed::Box") [ T; Ty.path "alloc::alloc::Global" ].
    
    Axiom Implements :
      forall (T U : Ty.t),
      M.IsTraitInstance
        "core::ops::unsize::DispatchFromDyn"
        (Self T U)
        (* Trait polymorphic types *)
        [ (* T *) Ty.apply (Ty.path "alloc::boxed::Box") [ U; Ty.path "alloc::alloc::Global" ] ]
        (* Instance *) [].
  End Impl_core_ops_unsize_DispatchFromDyn_where_core_marker_Sized_T_where_core_marker_Unsize_T_U_where_core_marker_Sized_U_alloc_boxed_Box_U_alloc_alloc_Global_for_alloc_boxed_Box_T_alloc_alloc_Global.
  
  Module Impl_core_iter_traits_collect_FromIterator_I_for_alloc_boxed_Box_slice_I_alloc_alloc_Global.
    Definition Self (I : Ty.t) : Ty.t :=
      Ty.apply
        (Ty.path "alloc::boxed::Box")
        [ Ty.apply (Ty.path "slice") [ I ]; Ty.path "alloc::alloc::Global" ].
    
    (*
        fn from_iter<T: IntoIterator<Item = I>>(iter: T) -> Self {
            iter.into_iter().collect::<Vec<_>>().into_boxed_slice()
        }
    *)
    Definition from_iter (I : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self I in
      match τ, α with
      | [ T ], [ iter ] =>
        ltac:(M.monadic
          (let iter := M.alloc (| iter |) in
          M.call_closure (|
            M.get_associated_function (|
              Ty.apply (Ty.path "alloc::vec::Vec") [ I; Ty.path "alloc::alloc::Global" ],
              "into_boxed_slice",
              []
            |),
            [
              M.call_closure (|
                M.get_trait_method (|
                  "core::iter::traits::iterator::Iterator",
                  Ty.associated,
                  [],
                  "collect",
                  [ Ty.apply (Ty.path "alloc::vec::Vec") [ I; Ty.path "alloc::alloc::Global" ] ]
                |),
                [
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::iter::traits::collect::IntoIterator",
                      T,
                      [],
                      "into_iter",
                      []
                    |),
                    [ M.read (| iter |) ]
                  |)
                ]
              |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (I : Ty.t),
      M.IsTraitInstance
        "core::iter::traits::collect::FromIterator"
        (Self I)
        (* Trait polymorphic types *) [ (* A *) I ]
        (* Instance *) [ ("from_iter", InstanceField.Method (from_iter I)) ].
  End Impl_core_iter_traits_collect_FromIterator_I_for_alloc_boxed_Box_slice_I_alloc_alloc_Global.
  
  Module Impl_core_clone_Clone_where_core_clone_Clone_T_where_core_alloc_Allocator_A_where_core_clone_Clone_A_for_alloc_boxed_Box_slice_T_A.
    Definition Self (T A : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "alloc::boxed::Box") [ Ty.apply (Ty.path "slice") [ T ]; A ].
    
    (*
        fn clone(&self) -> Self {
            let alloc = Box::allocator(self).clone();
            self.to_vec_in(alloc).into_boxed_slice()
        }
    *)
    Definition clone (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            let alloc :=
              M.alloc (|
                M.call_closure (|
                  M.get_trait_method (| "core::clone::Clone", A, [], "clone", [] |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "alloc::boxed::Box")
                          [ Ty.apply (Ty.path "slice") [ T ]; A ],
                        "allocator",
                        []
                      |),
                      [ M.read (| self |) ]
                    |)
                  ]
                |)
              |) in
            M.alloc (|
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply (Ty.path "alloc::vec::Vec") [ T; A ],
                  "into_boxed_slice",
                  []
                |),
                [
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply (Ty.path "slice") [ T ],
                      "to_vec_in",
                      [ A ]
                    |),
                    [ M.read (| M.read (| self |) |); M.read (| alloc |) ]
                  |)
                ]
              |)
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    (*
        fn clone_from(&mut self, other: &Self) {
            if self.len() == other.len() {
                self.clone_from_slice(&other);
            } else {
                *self = other.clone();
            }
        }
    *)
    Definition clone_from (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match τ, α with
      | [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          BinOp.Pure.eq
                            (M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply (Ty.path "slice") [ T ],
                                "len",
                                []
                              |),
                              [ M.read (| M.read (| self |) |) ]
                            |))
                            (M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply (Ty.path "slice") [ T ],
                                "len",
                                []
                              |),
                              [ M.read (| M.read (| other |) |) ]
                            |))
                        |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    let _ :=
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.apply (Ty.path "slice") [ T ],
                            "clone_from_slice",
                            []
                          |),
                          [ M.read (| M.read (| self |) |); M.read (| M.read (| other |) |) ]
                        |)
                      |) in
                    M.alloc (| Value.Tuple [] |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.write (|
                        M.read (| self |),
                        M.call_closure (|
                          M.get_trait_method (|
                            "core::clone::Clone",
                            Ty.apply
                              (Ty.path "alloc::boxed::Box")
                              [ Ty.apply (Ty.path "slice") [ T ]; A ],
                            [],
                            "clone",
                            []
                          |),
                          [ M.read (| other |) ]
                        |)
                      |) in
                    M.alloc (| Value.Tuple [] |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (T A : Ty.t),
      M.IsTraitInstance
        "core::clone::Clone"
        (Self T A)
        (* Trait polymorphic types *) []
        (* Instance *)
        [
          ("clone", InstanceField.Method (clone T A));
          ("clone_from", InstanceField.Method (clone_from T A))
        ].
  End Impl_core_clone_Clone_where_core_clone_Clone_T_where_core_alloc_Allocator_A_where_core_clone_Clone_A_for_alloc_boxed_Box_slice_T_A.
  
  Module Impl_core_borrow_Borrow_where_core_marker_Sized_T_where_core_alloc_Allocator_A_T_for_alloc_boxed_Box_T_A.
    Definition Self (T A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::boxed::Box") [ T; A ].
    
    (*
        fn borrow(&self) -> &T {
            &**self
        }
    *)
    Definition borrow (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (| M.read (| self |) |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (T A : Ty.t),
      M.IsTraitInstance
        "core::borrow::Borrow"
        (Self T A)
        (* Trait polymorphic types *) [ (* Borrowed *) T ]
        (* Instance *) [ ("borrow", InstanceField.Method (borrow T A)) ].
  End Impl_core_borrow_Borrow_where_core_marker_Sized_T_where_core_alloc_Allocator_A_T_for_alloc_boxed_Box_T_A.
  
  Module Impl_core_borrow_BorrowMut_where_core_marker_Sized_T_where_core_alloc_Allocator_A_T_for_alloc_boxed_Box_T_A.
    Definition Self (T A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::boxed::Box") [ T; A ].
    
    (*
        fn borrow_mut(&mut self) -> &mut T {
            &mut **self
        }
    *)
    Definition borrow_mut (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (| M.read (| self |) |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (T A : Ty.t),
      M.IsTraitInstance
        "core::borrow::BorrowMut"
        (Self T A)
        (* Trait polymorphic types *) [ (* Borrowed *) T ]
        (* Instance *) [ ("borrow_mut", InstanceField.Method (borrow_mut T A)) ].
  End Impl_core_borrow_BorrowMut_where_core_marker_Sized_T_where_core_alloc_Allocator_A_T_for_alloc_boxed_Box_T_A.
  
  Module Impl_core_convert_AsRef_where_core_marker_Sized_T_where_core_alloc_Allocator_A_T_for_alloc_boxed_Box_T_A.
    Definition Self (T A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::boxed::Box") [ T; A ].
    
    (*
        fn as_ref(&self) -> &T {
            &**self
        }
    *)
    Definition as_ref (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (| M.read (| self |) |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (T A : Ty.t),
      M.IsTraitInstance
        "core::convert::AsRef"
        (Self T A)
        (* Trait polymorphic types *) [ (* T *) T ]
        (* Instance *) [ ("as_ref", InstanceField.Method (as_ref T A)) ].
  End Impl_core_convert_AsRef_where_core_marker_Sized_T_where_core_alloc_Allocator_A_T_for_alloc_boxed_Box_T_A.
  
  Module Impl_core_convert_AsMut_where_core_marker_Sized_T_where_core_alloc_Allocator_A_T_for_alloc_boxed_Box_T_A.
    Definition Self (T A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::boxed::Box") [ T; A ].
    
    (*
        fn as_mut(&mut self) -> &mut T {
            &mut **self
        }
    *)
    Definition as_mut (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (| M.read (| self |) |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (T A : Ty.t),
      M.IsTraitInstance
        "core::convert::AsMut"
        (Self T A)
        (* Trait polymorphic types *) [ (* T *) T ]
        (* Instance *) [ ("as_mut", InstanceField.Method (as_mut T A)) ].
  End Impl_core_convert_AsMut_where_core_marker_Sized_T_where_core_alloc_Allocator_A_T_for_alloc_boxed_Box_T_A.
  
  Module Impl_core_marker_Unpin_where_core_marker_Sized_T_where_core_alloc_Allocator_A_for_alloc_boxed_Box_T_A.
    Definition Self (T A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::boxed::Box") [ T; A ].
    
    Axiom Implements :
      forall (T A : Ty.t),
      M.IsTraitInstance
        "core::marker::Unpin"
        (Self T A)
        (* Trait polymorphic types *) []
        (* Instance *) [].
  End Impl_core_marker_Unpin_where_core_marker_Sized_T_where_core_alloc_Allocator_A_for_alloc_boxed_Box_T_A.
  
  Module Impl_core_ops_coroutine_Coroutine_where_core_marker_Sized_G_where_core_ops_coroutine_Coroutine_G_R_where_core_marker_Unpin_G_where_core_alloc_Allocator_A_R_for_alloc_boxed_Box_G_A.
    Definition Self (G R A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::boxed::Box") [ G; A ].
    
    (*     type Yield = G::Yield; *)
    Definition _Yield (G R A : Ty.t) : Ty.t := Ty.associated.
    
    (*     type Return = G::Return; *)
    Definition _Return (G R A : Ty.t) : Ty.t := Ty.associated.
    
    (*
        fn resume(mut self: Pin<&mut Self>, arg: R) -> CoroutineState<Self::Yield, Self::Return> {
            G::resume(Pin::new(&mut *self), arg)
        }
    *)
    Definition resume (G R A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self G R A in
      match τ, α with
      | [], [ self; arg ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let arg := M.alloc (| arg |) in
          M.call_closure (|
            M.get_trait_method (| "core::ops::coroutine::Coroutine", G, [ R ], "resume", [] |),
            [
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply (Ty.path "core::pin::Pin") [ Ty.apply (Ty.path "&mut") [ G ] ],
                  "new",
                  []
                |),
                [
                  M.read (|
                    M.call_closure (|
                      M.get_trait_method (|
                        "core::ops::deref::DerefMut",
                        Ty.apply
                          (Ty.path "core::pin::Pin")
                          [
                            Ty.apply
                              (Ty.path "&mut")
                              [ Ty.apply (Ty.path "alloc::boxed::Box") [ G; A ] ]
                          ],
                        [],
                        "deref_mut",
                        []
                      |),
                      [ self ]
                    |)
                  |)
                ]
              |);
              M.read (| arg |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (G R A : Ty.t),
      M.IsTraitInstance
        "core::ops::coroutine::Coroutine"
        (Self G R A)
        (* Trait polymorphic types *) [ (* R *) R ]
        (* Instance *)
        [
          ("Yield", InstanceField.Ty (_Yield G R A));
          ("Return", InstanceField.Ty (_Return G R A));
          ("resume", InstanceField.Method (resume G R A))
        ].
  End Impl_core_ops_coroutine_Coroutine_where_core_marker_Sized_G_where_core_ops_coroutine_Coroutine_G_R_where_core_marker_Unpin_G_where_core_alloc_Allocator_A_R_for_alloc_boxed_Box_G_A.
  
  Module Impl_core_ops_coroutine_Coroutine_where_core_marker_Sized_G_where_core_ops_coroutine_Coroutine_G_R_where_core_alloc_Allocator_A_R_for_core_pin_Pin_alloc_boxed_Box_G_A.
    Definition Self (G R A : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "core::pin::Pin") [ Ty.apply (Ty.path "alloc::boxed::Box") [ G; A ] ].
    
    (*     type Yield = G::Yield; *)
    Definition _Yield (G R A : Ty.t) : Ty.t := Ty.associated.
    
    (*     type Return = G::Return; *)
    Definition _Return (G R A : Ty.t) : Ty.t := Ty.associated.
    
    (*
        fn resume(mut self: Pin<&mut Self>, arg: R) -> CoroutineState<Self::Yield, Self::Return> {
            G::resume(( *self).as_mut(), arg)
        }
    *)
    Definition resume (G R A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self G R A in
      match τ, α with
      | [], [ self; arg ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let arg := M.alloc (| arg |) in
          M.call_closure (|
            M.get_trait_method (| "core::ops::coroutine::Coroutine", G, [ R ], "resume", [] |),
            [
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "core::pin::Pin")
                    [ Ty.apply (Ty.path "alloc::boxed::Box") [ G; A ] ],
                  "as_mut",
                  []
                |),
                [
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::deref::DerefMut",
                      Ty.apply
                        (Ty.path "core::pin::Pin")
                        [
                          Ty.apply
                            (Ty.path "&mut")
                            [
                              Ty.apply
                                (Ty.path "core::pin::Pin")
                                [ Ty.apply (Ty.path "alloc::boxed::Box") [ G; A ] ]
                            ]
                        ],
                      [],
                      "deref_mut",
                      []
                    |),
                    [ self ]
                  |)
                ]
              |);
              M.read (| arg |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (G R A : Ty.t),
      M.IsTraitInstance
        "core::ops::coroutine::Coroutine"
        (Self G R A)
        (* Trait polymorphic types *) [ (* R *) R ]
        (* Instance *)
        [
          ("Yield", InstanceField.Ty (_Yield G R A));
          ("Return", InstanceField.Ty (_Return G R A));
          ("resume", InstanceField.Method (resume G R A))
        ].
  End Impl_core_ops_coroutine_Coroutine_where_core_marker_Sized_G_where_core_ops_coroutine_Coroutine_G_R_where_core_alloc_Allocator_A_R_for_core_pin_Pin_alloc_boxed_Box_G_A.
  
  Module Impl_core_future_future_Future_where_core_marker_Sized_F_where_core_future_future_Future_F_where_core_marker_Unpin_F_where_core_alloc_Allocator_A_for_alloc_boxed_Box_F_A.
    Definition Self (F A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::boxed::Box") [ F; A ].
    
    (*     type Output = F::Output; *)
    Definition _Output (F A : Ty.t) : Ty.t := Ty.associated.
    
    (*
        fn poll(mut self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output> {
            F::poll(Pin::new(&mut *self), cx)
        }
    *)
    Definition poll (F A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self F A in
      match τ, α with
      | [], [ self; cx ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let cx := M.alloc (| cx |) in
          M.call_closure (|
            M.get_trait_method (| "core::future::future::Future", F, [], "poll", [] |),
            [
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply (Ty.path "core::pin::Pin") [ Ty.apply (Ty.path "&mut") [ F ] ],
                  "new",
                  []
                |),
                [
                  M.read (|
                    M.call_closure (|
                      M.get_trait_method (|
                        "core::ops::deref::DerefMut",
                        Ty.apply
                          (Ty.path "core::pin::Pin")
                          [
                            Ty.apply
                              (Ty.path "&mut")
                              [ Ty.apply (Ty.path "alloc::boxed::Box") [ F; A ] ]
                          ],
                        [],
                        "deref_mut",
                        []
                      |),
                      [ self ]
                    |)
                  |)
                ]
              |);
              M.read (| cx |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (F A : Ty.t),
      M.IsTraitInstance
        "core::future::future::Future"
        (Self F A)
        (* Trait polymorphic types *) []
        (* Instance *)
        [ ("Output", InstanceField.Ty (_Output F A)); ("poll", InstanceField.Method (poll F A)) ].
  End Impl_core_future_future_Future_where_core_marker_Sized_F_where_core_future_future_Future_F_where_core_marker_Unpin_F_where_core_alloc_Allocator_A_for_alloc_boxed_Box_F_A.
  
  Module Impl_core_async_iter_async_iter_AsyncIterator_where_core_marker_Sized_S_where_core_async_iter_async_iter_AsyncIterator_S_where_core_marker_Unpin_S_for_alloc_boxed_Box_S_alloc_alloc_Global.
    Definition Self (S : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "alloc::boxed::Box") [ S; Ty.path "alloc::alloc::Global" ].
    
    (*     type Item = S::Item; *)
    Definition _Item (S : Ty.t) : Ty.t := Ty.associated.
    
    (*
        fn poll_next(mut self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Option<Self::Item>> {
            Pin::new(&mut **self).poll_next(cx)
        }
    *)
    Definition poll_next (S : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self S in
      match τ, α with
      | [], [ self; cx ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let cx := M.alloc (| cx |) in
          M.call_closure (|
            M.get_trait_method (|
              "core::async_iter::async_iter::AsyncIterator",
              S,
              [],
              "poll_next",
              []
            |),
            [
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply (Ty.path "core::pin::Pin") [ Ty.apply (Ty.path "&mut") [ S ] ],
                  "new",
                  []
                |),
                [
                  M.read (|
                    M.call_closure (|
                      M.get_trait_method (|
                        "core::ops::deref::DerefMut",
                        Ty.apply
                          (Ty.path "core::pin::Pin")
                          [
                            Ty.apply
                              (Ty.path "&mut")
                              [
                                Ty.apply
                                  (Ty.path "alloc::boxed::Box")
                                  [ S; Ty.path "alloc::alloc::Global" ]
                              ]
                          ],
                        [],
                        "deref_mut",
                        []
                      |),
                      [ self ]
                    |)
                  |)
                ]
              |);
              M.read (| cx |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    (*
        fn size_hint(&self) -> (usize, Option<usize>) {
            ( **self).size_hint()
        }
    *)
    Definition size_hint (S : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self S in
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_trait_method (|
              "core::async_iter::async_iter::AsyncIterator",
              S,
              [],
              "size_hint",
              []
            |),
            [ M.read (| M.read (| self |) |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (S : Ty.t),
      M.IsTraitInstance
        "core::async_iter::async_iter::AsyncIterator"
        (Self S)
        (* Trait polymorphic types *) []
        (* Instance *)
        [
          ("Item", InstanceField.Ty (_Item S));
          ("poll_next", InstanceField.Method (poll_next S));
          ("size_hint", InstanceField.Method (size_hint S))
        ].
  End Impl_core_async_iter_async_iter_AsyncIterator_where_core_marker_Sized_S_where_core_async_iter_async_iter_AsyncIterator_S_where_core_marker_Unpin_S_for_alloc_boxed_Box_S_alloc_alloc_Global.
  
  Module Impl_Dyn_core_error_Error_Trait.
    Definition Self : Ty.t := Ty.dyn [ ("core::error::Error::Trait", []) ].
    
    (*
        pub fn downcast<T: Error + 'static>(self: Box<Self>) -> Result<Box<T>, Box<dyn Error>> {
            if self.is::<T>() {
                unsafe {
                    let raw: *mut dyn Error = Box::into_raw(self);
                    Ok(Box::from_raw(raw as *mut T))
                }
            } else {
                Err(self)
            }
        }
    *)
    Definition downcast (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [ T ], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.dyn [ ("core::error::Error::Trait", []) ],
                              "is",
                              [ T ]
                            |),
                            [ M.read (| self |) ]
                          |)
                        |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    let raw :=
                      M.alloc (|
                        (* Unsize *)
                        M.pointer_coercion
                          (M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply
                                (Ty.path "alloc::boxed::Box")
                                [
                                  Ty.dyn [ ("core::error::Error::Trait", []) ];
                                  Ty.path "alloc::alloc::Global"
                                ],
                              "into_raw",
                              []
                            |),
                            [ (* Unsize *) M.pointer_coercion (M.read (| self |)) ]
                          |))
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply
                                (Ty.path "alloc::boxed::Box")
                                [ T; Ty.path "alloc::alloc::Global" ],
                              "from_raw",
                              []
                            |),
                            [ M.rust_cast (M.read (| raw |)) ]
                          |)
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Err"
                        [ (* Unsize *) M.pointer_coercion (M.read (| self |)) ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_downcast : M.IsAssociatedFunction Self "downcast" downcast.
    (*
        pub fn downcast<T: Error + 'static>(self: Box<Self>) -> Result<Box<T>, Box<dyn Error + Send>> {
            let err: Box<dyn Error> = self;
            <dyn Error>::downcast(err).map_err(|s| unsafe {
                // Reapply the `Send` marker.
                Box::from_raw(Box::into_raw(s) as *mut (dyn Error + Send))
            })
        }
    *)
    Definition downcast (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [ T ], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            let err := M.alloc (| (* Unsize *) M.pointer_coercion (M.read (| self |)) |) in
            M.alloc (|
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "core::result::Result")
                    [
                      Ty.apply (Ty.path "alloc::boxed::Box") [ T; Ty.path "alloc::alloc::Global" ];
                      Ty.apply
                        (Ty.path "alloc::boxed::Box")
                        [
                          Ty.dyn [ ("core::error::Error::Trait", []) ];
                          Ty.path "alloc::alloc::Global"
                        ]
                    ],
                  "map_err",
                  [
                    Ty.apply
                      (Ty.path "alloc::boxed::Box")
                      [ Ty.dyn [ ("core::error::Error::Trait", []) ]; Ty.path "alloc::alloc::Global"
                      ];
                    Ty.function
                      [
                        Ty.tuple
                          [
                            Ty.apply
                              (Ty.path "alloc::boxed::Box")
                              [
                                Ty.dyn [ ("core::error::Error::Trait", []) ];
                                Ty.path "alloc::alloc::Global"
                              ]
                          ]
                      ]
                      (Ty.apply
                        (Ty.path "alloc::boxed::Box")
                        [
                          Ty.dyn [ ("core::error::Error::Trait", []) ];
                          Ty.path "alloc::alloc::Global"
                        ])
                  ]
                |),
                [
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.dyn [ ("core::error::Error::Trait", []) ],
                      "downcast",
                      [ T ]
                    |),
                    [ (* Unsize *) M.pointer_coercion (M.read (| err |)) ]
                  |);
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0 ] =>
                          M.match_operator (|
                            M.alloc (| α0 |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let s := M.copy (| γ |) in
                                  (* Unsize *)
                                  M.pointer_coercion
                                    (M.call_closure (|
                                      M.get_associated_function (|
                                        Ty.apply
                                          (Ty.path "alloc::boxed::Box")
                                          [
                                            Ty.dyn [ ("core::error::Error::Trait", []) ];
                                            Ty.path "alloc::alloc::Global"
                                          ],
                                        "from_raw",
                                        []
                                      |),
                                      [
                                        M.rust_cast
                                          (M.call_closure (|
                                            M.get_associated_function (|
                                              Ty.apply
                                                (Ty.path "alloc::boxed::Box")
                                                [
                                                  Ty.dyn [ ("core::error::Error::Trait", []) ];
                                                  Ty.path "alloc::alloc::Global"
                                                ],
                                              "into_raw",
                                              []
                                            |),
                                            [ M.read (| s |) ]
                                          |))
                                      ]
                                    |))))
                            ]
                          |)
                        | _ => M.impossible (||)
                        end))
                ]
              |)
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_downcast : M.IsAssociatedFunction Self "downcast" downcast.
    (*
        pub fn downcast<T: Error + 'static>(self: Box<Self>) -> Result<Box<T>, Box<Self>> {
            let err: Box<dyn Error> = self;
            <dyn Error>::downcast(err).map_err(|s| unsafe {
                // Reapply the `Send + Sync` marker.
                Box::from_raw(Box::into_raw(s) as *mut (dyn Error + Send + Sync))
            })
        }
    *)
    Definition downcast (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [ T ], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            let err := M.alloc (| (* Unsize *) M.pointer_coercion (M.read (| self |)) |) in
            M.alloc (|
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "core::result::Result")
                    [
                      Ty.apply (Ty.path "alloc::boxed::Box") [ T; Ty.path "alloc::alloc::Global" ];
                      Ty.apply
                        (Ty.path "alloc::boxed::Box")
                        [
                          Ty.dyn [ ("core::error::Error::Trait", []) ];
                          Ty.path "alloc::alloc::Global"
                        ]
                    ],
                  "map_err",
                  [
                    Ty.apply
                      (Ty.path "alloc::boxed::Box")
                      [ Ty.dyn [ ("core::error::Error::Trait", []) ]; Ty.path "alloc::alloc::Global"
                      ];
                    Ty.function
                      [
                        Ty.tuple
                          [
                            Ty.apply
                              (Ty.path "alloc::boxed::Box")
                              [
                                Ty.dyn [ ("core::error::Error::Trait", []) ];
                                Ty.path "alloc::alloc::Global"
                              ]
                          ]
                      ]
                      (Ty.apply
                        (Ty.path "alloc::boxed::Box")
                        [
                          Ty.dyn [ ("core::error::Error::Trait", []) ];
                          Ty.path "alloc::alloc::Global"
                        ])
                  ]
                |),
                [
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.dyn [ ("core::error::Error::Trait", []) ],
                      "downcast",
                      [ T ]
                    |),
                    [ (* Unsize *) M.pointer_coercion (M.read (| err |)) ]
                  |);
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0 ] =>
                          M.match_operator (|
                            M.alloc (| α0 |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let s := M.copy (| γ |) in
                                  (* Unsize *)
                                  M.pointer_coercion
                                    (M.call_closure (|
                                      M.get_associated_function (|
                                        Ty.apply
                                          (Ty.path "alloc::boxed::Box")
                                          [
                                            Ty.dyn [ ("core::error::Error::Trait", []) ];
                                            Ty.path "alloc::alloc::Global"
                                          ],
                                        "from_raw",
                                        []
                                      |),
                                      [
                                        M.rust_cast
                                          (M.call_closure (|
                                            M.get_associated_function (|
                                              Ty.apply
                                                (Ty.path "alloc::boxed::Box")
                                                [
                                                  Ty.dyn [ ("core::error::Error::Trait", []) ];
                                                  Ty.path "alloc::alloc::Global"
                                                ],
                                              "into_raw",
                                              []
                                            |),
                                            [ M.read (| s |) ]
                                          |))
                                      ]
                                    |))))
                            ]
                          |)
                        | _ => M.impossible (||)
                        end))
                ]
              |)
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_downcast : M.IsAssociatedFunction Self "downcast" downcast.
  End Impl_Dyn_core_error_Error_Trait.
  
  
  
  Module Impl_core_convert_From_where_core_error_Error_E_E_for_alloc_boxed_Box_Dyn_core_error_Error_Trait_alloc_alloc_Global.
    Definition Self (E : Ty.t) : Ty.t :=
      Ty.apply
        (Ty.path "alloc::boxed::Box")
        [ Ty.dyn [ ("core::error::Error::Trait", []) ]; Ty.path "alloc::alloc::Global" ].
    
    (*
        fn from(err: E) -> Box<dyn Error + 'a> {
            Box::new(err)
        }
    *)
    Definition from (E : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self E in
      match τ, α with
      | [], [ err ] =>
        ltac:(M.monadic
          (let err := M.alloc (| err |) in
          (* Unsize *)
          M.pointer_coercion
            (* Unsize *)
            (M.pointer_coercion
              (M.call_closure (|
                M.get_associated_function (|
                  Ty.apply (Ty.path "alloc::boxed::Box") [ E; Ty.path "alloc::alloc::Global" ],
                  "new",
                  []
                |),
                [ M.read (| err |) ]
              |)))))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (E : Ty.t),
      M.IsTraitInstance
        "core::convert::From"
        (Self E)
        (* Trait polymorphic types *) [ (* T *) E ]
        (* Instance *) [ ("from", InstanceField.Method (from E)) ].
  End Impl_core_convert_From_where_core_error_Error_E_E_for_alloc_boxed_Box_Dyn_core_error_Error_Trait_alloc_alloc_Global.
  
  Module Impl_core_convert_From_where_core_error_Error_E_where_core_marker_Send_E_where_core_marker_Sync_E_E_for_alloc_boxed_Box_Dyn_core_error_Error_Trait_alloc_alloc_Global.
    Definition Self (E : Ty.t) : Ty.t :=
      Ty.apply
        (Ty.path "alloc::boxed::Box")
        [ Ty.dyn [ ("core::error::Error::Trait", []) ]; Ty.path "alloc::alloc::Global" ].
    
    (*
        fn from(err: E) -> Box<dyn Error + Send + Sync + 'a> {
            Box::new(err)
        }
    *)
    Definition from (E : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self E in
      match τ, α with
      | [], [ err ] =>
        ltac:(M.monadic
          (let err := M.alloc (| err |) in
          (* Unsize *)
          M.pointer_coercion
            (* Unsize *)
            (M.pointer_coercion
              (M.call_closure (|
                M.get_associated_function (|
                  Ty.apply (Ty.path "alloc::boxed::Box") [ E; Ty.path "alloc::alloc::Global" ],
                  "new",
                  []
                |),
                [ M.read (| err |) ]
              |)))))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (E : Ty.t),
      M.IsTraitInstance
        "core::convert::From"
        (Self E)
        (* Trait polymorphic types *) [ (* T *) E ]
        (* Instance *) [ ("from", InstanceField.Method (from E)) ].
  End Impl_core_convert_From_where_core_error_Error_E_where_core_marker_Send_E_where_core_marker_Sync_E_E_for_alloc_boxed_Box_Dyn_core_error_Error_Trait_alloc_alloc_Global.
  
  Module Impl_core_convert_From_alloc_string_String_for_alloc_boxed_Box_Dyn_core_error_Error_Trait_alloc_alloc_Global.
    Definition Self : Ty.t :=
      Ty.apply
        (Ty.path "alloc::boxed::Box")
        [ Ty.dyn [ ("core::error::Error::Trait", []) ]; Ty.path "alloc::alloc::Global" ].
    
    (*
        fn from(err: String) -> Box<dyn Error + Send + Sync> {
            struct StringError(String);
    
            impl Error for StringError {
                #[allow(deprecated)]
                fn description(&self) -> &str {
                    &self.0
                }
            }
    
            impl fmt::Display for StringError {
                fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                    fmt::Display::fmt(&self.0, f)
                }
            }
    
            // Purposefully skip printing "StringError(..)"
            impl fmt::Debug for StringError {
                fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                    fmt::Debug::fmt(&self.0, f)
                }
            }
    
            Box::new(StringError(err))
        }
    *)
    Definition from (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ err ] =>
        ltac:(M.monadic
          (let err := M.alloc (| err |) in
          (* Unsize *)
          M.pointer_coercion
            (* Unsize *)
            (M.pointer_coercion
              (M.call_closure (|
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "alloc::boxed::Box")
                    [ Ty.path "alloc::boxed::from::StringError"; Ty.path "alloc::alloc::Global" ],
                  "new",
                  []
                |),
                [ Value.StructTuple "alloc::boxed::from::StringError" [ M.read (| err |) ] ]
              |)))))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::convert::From"
        Self
        (* Trait polymorphic types *) [ (* T *) Ty.path "alloc::string::String" ]
        (* Instance *) [ ("from", InstanceField.Method from) ].
    (*
        fn from(str_err: String) -> Box<dyn Error> {
            let err1: Box<dyn Error + Send + Sync> = From::from(str_err);
            let err2: Box<dyn Error> = err1;
            err2
        }
    *)
    Definition from (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ str_err ] =>
        ltac:(M.monadic
          (let str_err := M.alloc (| str_err |) in
          (* Unsize *)
          M.pointer_coercion
            (M.read (|
              let err1 :=
                M.alloc (|
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::convert::From",
                      Ty.apply
                        (Ty.path "alloc::boxed::Box")
                        [
                          Ty.dyn [ ("core::error::Error::Trait", []) ];
                          Ty.path "alloc::alloc::Global"
                        ],
                      [ Ty.path "alloc::string::String" ],
                      "from",
                      []
                    |),
                    [ M.read (| str_err |) ]
                  |)
                |) in
              let err2 := M.alloc (| (* Unsize *) M.pointer_coercion (M.read (| err1 |)) |) in
              M.alloc (| (* Unsize *) M.pointer_coercion (M.read (| err2 |)) |)
            |))))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::convert::From"
        Self
        (* Trait polymorphic types *) [ (* T *) Ty.path "alloc::string::String" ]
        (* Instance *) [ ("from", InstanceField.Method from) ].
  End Impl_core_convert_From_alloc_string_String_for_alloc_boxed_Box_Dyn_core_error_Error_Trait_alloc_alloc_Global.
  
  
  Module Impl_core_convert_From_ref__str_for_alloc_boxed_Box_Dyn_core_error_Error_Trait_alloc_alloc_Global.
    Definition Self : Ty.t :=
      Ty.apply
        (Ty.path "alloc::boxed::Box")
        [ Ty.dyn [ ("core::error::Error::Trait", []) ]; Ty.path "alloc::alloc::Global" ].
    
    (*
        fn from(err: &str) -> Box<dyn Error + Send + Sync + 'a> {
            From::from(String::from(err))
        }
    *)
    Definition from (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ err ] =>
        ltac:(M.monadic
          (let err := M.alloc (| err |) in
          (* Unsize *)
          M.pointer_coercion
            (M.call_closure (|
              M.get_trait_method (|
                "core::convert::From",
                Ty.apply
                  (Ty.path "alloc::boxed::Box")
                  [ Ty.dyn [ ("core::error::Error::Trait", []) ]; Ty.path "alloc::alloc::Global" ],
                [ Ty.path "alloc::string::String" ],
                "from",
                []
              |),
              [
                M.call_closure (|
                  M.get_trait_method (|
                    "core::convert::From",
                    Ty.path "alloc::string::String",
                    [ Ty.apply (Ty.path "&") [ Ty.path "str" ] ],
                    "from",
                    []
                  |),
                  [ M.read (| err |) ]
                |)
              ]
            |))))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::convert::From"
        Self
        (* Trait polymorphic types *) [ (* T *) Ty.apply (Ty.path "&") [ Ty.path "str" ] ]
        (* Instance *) [ ("from", InstanceField.Method from) ].
    (*
        fn from(err: &str) -> Box<dyn Error> {
            From::from(String::from(err))
        }
    *)
    Definition from (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ err ] =>
        ltac:(M.monadic
          (let err := M.alloc (| err |) in
          (* Unsize *)
          M.pointer_coercion
            (M.call_closure (|
              M.get_trait_method (|
                "core::convert::From",
                Ty.apply
                  (Ty.path "alloc::boxed::Box")
                  [ Ty.dyn [ ("core::error::Error::Trait", []) ]; Ty.path "alloc::alloc::Global" ],
                [ Ty.path "alloc::string::String" ],
                "from",
                []
              |),
              [
                M.call_closure (|
                  M.get_trait_method (|
                    "core::convert::From",
                    Ty.path "alloc::string::String",
                    [ Ty.apply (Ty.path "&") [ Ty.path "str" ] ],
                    "from",
                    []
                  |),
                  [ M.read (| err |) ]
                |)
              ]
            |))))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::convert::From"
        Self
        (* Trait polymorphic types *) [ (* T *) Ty.apply (Ty.path "&") [ Ty.path "str" ] ]
        (* Instance *) [ ("from", InstanceField.Method from) ].
  End Impl_core_convert_From_ref__str_for_alloc_boxed_Box_Dyn_core_error_Error_Trait_alloc_alloc_Global.
  
  
  Module Impl_core_convert_From_alloc_borrow_Cow_str_for_alloc_boxed_Box_Dyn_core_error_Error_Trait_alloc_alloc_Global.
    Definition Self : Ty.t :=
      Ty.apply
        (Ty.path "alloc::boxed::Box")
        [ Ty.dyn [ ("core::error::Error::Trait", []) ]; Ty.path "alloc::alloc::Global" ].
    
    (*
        fn from(err: Cow<'b, str>) -> Box<dyn Error + Send + Sync + 'a> {
            From::from(String::from(err))
        }
    *)
    Definition from (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ err ] =>
        ltac:(M.monadic
          (let err := M.alloc (| err |) in
          (* Unsize *)
          M.pointer_coercion
            (M.call_closure (|
              M.get_trait_method (|
                "core::convert::From",
                Ty.apply
                  (Ty.path "alloc::boxed::Box")
                  [ Ty.dyn [ ("core::error::Error::Trait", []) ]; Ty.path "alloc::alloc::Global" ],
                [ Ty.path "alloc::string::String" ],
                "from",
                []
              |),
              [
                M.call_closure (|
                  M.get_trait_method (|
                    "core::convert::From",
                    Ty.path "alloc::string::String",
                    [ Ty.apply (Ty.path "alloc::borrow::Cow") [ Ty.path "str" ] ],
                    "from",
                    []
                  |),
                  [ M.read (| err |) ]
                |)
              ]
            |))))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::convert::From"
        Self
        (* Trait polymorphic types *)
        [ (* T *) Ty.apply (Ty.path "alloc::borrow::Cow") [ Ty.path "str" ] ]
        (* Instance *) [ ("from", InstanceField.Method from) ].
    (*
        fn from(err: Cow<'a, str>) -> Box<dyn Error> {
            From::from(String::from(err))
        }
    *)
    Definition from (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ err ] =>
        ltac:(M.monadic
          (let err := M.alloc (| err |) in
          (* Unsize *)
          M.pointer_coercion
            (M.call_closure (|
              M.get_trait_method (|
                "core::convert::From",
                Ty.apply
                  (Ty.path "alloc::boxed::Box")
                  [ Ty.dyn [ ("core::error::Error::Trait", []) ]; Ty.path "alloc::alloc::Global" ],
                [ Ty.path "alloc::string::String" ],
                "from",
                []
              |),
              [
                M.call_closure (|
                  M.get_trait_method (|
                    "core::convert::From",
                    Ty.path "alloc::string::String",
                    [ Ty.apply (Ty.path "alloc::borrow::Cow") [ Ty.path "str" ] ],
                    "from",
                    []
                  |),
                  [ M.read (| err |) ]
                |)
              ]
            |))))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::convert::From"
        Self
        (* Trait polymorphic types *)
        [ (* T *) Ty.apply (Ty.path "alloc::borrow::Cow") [ Ty.path "str" ] ]
        (* Instance *) [ ("from", InstanceField.Method from) ].
  End Impl_core_convert_From_alloc_borrow_Cow_str_for_alloc_boxed_Box_Dyn_core_error_Error_Trait_alloc_alloc_Global.
  
  
  Module Impl_core_error_Error_where_core_error_Error_T_for_alloc_boxed_Box_T_alloc_alloc_Global.
    Definition Self (T : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "alloc::boxed::Box") [ T; Ty.path "alloc::alloc::Global" ].
    
    (*
        fn description(&self) -> &str {
            core::error::Error::description(&**self)
        }
    *)
    Definition description (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_trait_method (| "core::error::Error", T, [], "description", [] |),
            [ M.read (| M.read (| self |) |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    (*
        fn cause(&self) -> Option<&dyn core::error::Error> {
            core::error::Error::cause(&**self)
        }
    *)
    Definition cause (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_trait_method (| "core::error::Error", T, [], "cause", [] |),
            [ M.read (| M.read (| self |) |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    (*
        fn source(&self) -> Option<&(dyn core::error::Error + 'static)> {
            core::error::Error::source(&**self)
        }
    *)
    Definition source (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_trait_method (| "core::error::Error", T, [], "source", [] |),
            [ M.read (| M.read (| self |) |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    (*
        fn provide<'b>(&'b self, request: &mut core::error::Request<'b>) {
            core::error::Error::provide(&**self, request);
        }
    *)
    Definition provide (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match τ, α with
      | [], [ self; request ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let request := M.alloc (| request |) in
          M.read (|
            let _ :=
              M.alloc (|
                M.call_closure (|
                  M.get_trait_method (| "core::error::Error", T, [], "provide", [] |),
                  [ M.read (| M.read (| self |) |); M.read (| request |) ]
                |)
              |) in
            M.alloc (| Value.Tuple [] |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "core::error::Error"
        (Self T)
        (* Trait polymorphic types *) []
        (* Instance *)
        [
          ("description", InstanceField.Method (description T));
          ("cause", InstanceField.Method (cause T));
          ("source", InstanceField.Method (source T));
          ("provide", InstanceField.Method (provide T))
        ].
  End Impl_core_error_Error_where_core_error_Error_T_for_alloc_boxed_Box_T_alloc_alloc_Global.
End boxed.
