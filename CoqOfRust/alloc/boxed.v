(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module boxed.
  (* StructTuple
    {
      name := "Box";
      const_params := [];
      ty_params := [ "T"; "A" ];
      fields := [ Ty.apply (Ty.path "core::ptr::unique::Unique") [] [ T ]; A ];
    } *)
  
  Module Impl_alloc_boxed_Box_T_alloc_alloc_Global.
    Definition Self (T : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "alloc::boxed::Box") [] [ T; Ty.path "alloc::alloc::Global" ].
    
    (*
        pub fn new(x: T) -> Self {
            #[rustc_box]
            Box::new(x)
        }
    *)
    Definition new (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [], [ x ] =>
        ltac:(M.monadic
          (let x := M.alloc (| x |) in
          M.read (|
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply (Ty.path "alloc::boxed::Box") [] [ T; Ty.path "alloc::alloc::Global" ],
                "new",
                []
              |),
              [ x ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom AssociatedFunction_new : forall (T : Ty.t), M.IsAssociatedFunction (Self T) "new" (new T).
    
    (*
        pub fn new_uninit() -> Box<mem::MaybeUninit<T>> {
            Self::new_uninit_in(Global)
        }
    *)
    Definition new_uninit (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [], [] =>
        ltac:(M.monadic
          (M.call_closure (|
            M.get_associated_function (|
              Ty.apply (Ty.path "alloc::boxed::Box") [] [ T; Ty.path "alloc::alloc::Global" ],
              "new_uninit_in",
              []
            |),
            [ Value.StructTuple "alloc::alloc::Global" [] ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom AssociatedFunction_new_uninit :
      forall (T : Ty.t),
      M.IsAssociatedFunction (Self T) "new_uninit" (new_uninit T).
    
    (*
        pub fn new_zeroed() -> Box<mem::MaybeUninit<T>> {
            Self::new_zeroed_in(Global)
        }
    *)
    Definition new_zeroed (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [], [] =>
        ltac:(M.monadic
          (M.call_closure (|
            M.get_associated_function (|
              Ty.apply (Ty.path "alloc::boxed::Box") [] [ T; Ty.path "alloc::alloc::Global" ],
              "new_zeroed_in",
              []
            |),
            [ Value.StructTuple "alloc::alloc::Global" [] ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom AssociatedFunction_new_zeroed :
      forall (T : Ty.t),
      M.IsAssociatedFunction (Self T) "new_zeroed" (new_zeroed T).
    
    (*
        pub fn pin(x: T) -> Pin<Box<T>> {
            Box::new(x).into()
        }
    *)
    Definition pin (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [], [ x ] =>
        ltac:(M.monadic
          (let x := M.alloc (| x |) in
          M.call_closure (|
            M.get_trait_method (|
              "core::convert::Into",
              Ty.apply (Ty.path "alloc::boxed::Box") [] [ T; Ty.path "alloc::alloc::Global" ],
              [
                Ty.apply
                  (Ty.path "core::pin::Pin")
                  []
                  [ Ty.apply (Ty.path "alloc::boxed::Box") [] [ T; Ty.path "alloc::alloc::Global" ]
                  ]
              ],
              "into",
              []
            |),
            [
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply (Ty.path "alloc::boxed::Box") [] [ T; Ty.path "alloc::alloc::Global" ],
                  "new",
                  []
                |),
                [ M.read (| x |) ]
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom AssociatedFunction_pin : forall (T : Ty.t), M.IsAssociatedFunction (Self T) "pin" (pin T).
    
    (*
        pub fn try_new(x: T) -> Result<Self, AllocError> {
            Self::try_new_in(x, Global)
        }
    *)
    Definition try_new (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [], [ x ] =>
        ltac:(M.monadic
          (let x := M.alloc (| x |) in
          M.call_closure (|
            M.get_associated_function (|
              Ty.apply (Ty.path "alloc::boxed::Box") [] [ T; Ty.path "alloc::alloc::Global" ],
              "try_new_in",
              []
            |),
            [ M.read (| x |); Value.StructTuple "alloc::alloc::Global" [] ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom AssociatedFunction_try_new :
      forall (T : Ty.t),
      M.IsAssociatedFunction (Self T) "try_new" (try_new T).
    
    (*
        pub fn try_new_uninit() -> Result<Box<mem::MaybeUninit<T>>, AllocError> {
            Box::try_new_uninit_in(Global)
        }
    *)
    Definition try_new_uninit
        (T : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [], [] =>
        ltac:(M.monadic
          (M.call_closure (|
            M.get_associated_function (|
              Ty.apply (Ty.path "alloc::boxed::Box") [] [ T; Ty.path "alloc::alloc::Global" ],
              "try_new_uninit_in",
              []
            |),
            [ Value.StructTuple "alloc::alloc::Global" [] ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom AssociatedFunction_try_new_uninit :
      forall (T : Ty.t),
      M.IsAssociatedFunction (Self T) "try_new_uninit" (try_new_uninit T).
    
    (*
        pub fn try_new_zeroed() -> Result<Box<mem::MaybeUninit<T>>, AllocError> {
            Box::try_new_zeroed_in(Global)
        }
    *)
    Definition try_new_zeroed
        (T : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [], [] =>
        ltac:(M.monadic
          (M.call_closure (|
            M.get_associated_function (|
              Ty.apply (Ty.path "alloc::boxed::Box") [] [ T; Ty.path "alloc::alloc::Global" ],
              "try_new_zeroed_in",
              []
            |),
            [ Value.StructTuple "alloc::alloc::Global" [] ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom AssociatedFunction_try_new_zeroed :
      forall (T : Ty.t),
      M.IsAssociatedFunction (Self T) "try_new_zeroed" (try_new_zeroed T).
    (*
        pub unsafe fn from_raw(raw: *mut T) -> Self {
            unsafe { Self::from_raw_in(raw, Global) }
        }
    *)
    Definition from_raw (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [], [ raw ] =>
        ltac:(M.monadic
          (let raw := M.alloc (| raw |) in
          M.call_closure (|
            M.get_associated_function (|
              Ty.apply (Ty.path "alloc::boxed::Box") [] [ T; Ty.path "alloc::alloc::Global" ],
              "from_raw_in",
              []
            |),
            [ M.read (| raw |); Value.StructTuple "alloc::alloc::Global" [] ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom AssociatedFunction_from_raw :
      forall (T : Ty.t),
      M.IsAssociatedFunction (Self T) "from_raw" (from_raw T).
    
    (*
        pub unsafe fn from_non_null(ptr: NonNull<T>) -> Self {
            unsafe { Self::from_raw(ptr.as_ptr()) }
        }
    *)
    Definition from_non_null (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [], [ ptr ] =>
        ltac:(M.monadic
          (let ptr := M.alloc (| ptr |) in
          M.call_closure (|
            M.get_associated_function (|
              Ty.apply (Ty.path "alloc::boxed::Box") [] [ T; Ty.path "alloc::alloc::Global" ],
              "from_raw",
              []
            |),
            [
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply (Ty.path "core::ptr::non_null::NonNull") [] [ T ],
                  "as_ptr",
                  []
                |),
                [ M.read (| ptr |) ]
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom AssociatedFunction_from_non_null :
      forall (T : Ty.t),
      M.IsAssociatedFunction (Self T) "from_non_null" (from_non_null T).
  End Impl_alloc_boxed_Box_T_alloc_alloc_Global.
  
  Module Impl_alloc_boxed_Box_T_A.
    Definition Self (T A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::boxed::Box") [] [ T; A ].
    
    (*
        pub fn new_in(x: T, alloc: A) -> Self
        where
            A: Allocator,
        {
            let mut boxed = Self::new_uninit_in(alloc);
            unsafe {
                boxed.as_mut_ptr().write(x);
                boxed.assume_init()
            }
        }
    *)
    Definition new_in (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ x; alloc ] =>
        ltac:(M.monadic
          (let x := M.alloc (| x |) in
          let alloc := M.alloc (| alloc |) in
          M.read (|
            let~ boxed :=
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "alloc::boxed::Box") [] [ T; A ],
                    "new_uninit_in",
                    []
                  |),
                  [ M.read (| alloc |) ]
                |)
              |) in
            let~ _ :=
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.apply (Ty.path "*mut") [] [ T ], "write", [] |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ],
                        "as_mut_ptr",
                        []
                      |),
                      [ M.read (| boxed |) ]
                    |);
                    M.read (| x |)
                  ]
                |)
              |) in
            M.alloc (|
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "alloc::boxed::Box")
                    []
                    [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ]; A ],
                  "assume_init",
                  []
                |),
                [ M.read (| boxed |) ]
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom AssociatedFunction_new_in :
      forall (T A : Ty.t),
      M.IsAssociatedFunction (Self T A) "new_in" (new_in T A).
    
    (*
        pub fn try_new_in(x: T, alloc: A) -> Result<Self, AllocError>
        where
            A: Allocator,
        {
            let mut boxed = Self::try_new_uninit_in(alloc)?;
            unsafe {
                boxed.as_mut_ptr().write(x);
                Ok(boxed.assume_init())
            }
        }
    *)
    Definition try_new_in (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ x; alloc ] =>
        ltac:(M.monadic
          (let x := M.alloc (| x |) in
          let alloc := M.alloc (| alloc |) in
          M.catch_return (|
            ltac:(M.monadic
              (M.read (|
                let~ boxed :=
                  M.copy (|
                    M.match_operator (|
                      M.alloc (|
                        M.call_closure (|
                          M.get_trait_method (|
                            "core::ops::try_trait::Try",
                            Ty.apply
                              (Ty.path "core::result::Result")
                              []
                              [
                                Ty.apply
                                  (Ty.path "alloc::boxed::Box")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                      []
                                      [ T ];
                                    A
                                  ];
                                Ty.path "core::alloc::AllocError"
                              ],
                            [],
                            "branch",
                            []
                          |),
                          [
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply (Ty.path "alloc::boxed::Box") [] [ T; A ],
                                "try_new_uninit_in",
                                []
                              |),
                              [ M.read (| alloc |) ]
                            |)
                          ]
                        |)
                      |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "core::ops::control_flow::ControlFlow::Break",
                                0
                              |) in
                            let residual := M.copy (| γ0_0 |) in
                            M.alloc (|
                              M.never_to_any (|
                                M.read (|
                                  M.return_ (|
                                    M.call_closure (|
                                      M.get_trait_method (|
                                        "core::ops::try_trait::FromResidual",
                                        Ty.apply
                                          (Ty.path "core::result::Result")
                                          []
                                          [
                                            Ty.apply (Ty.path "alloc::boxed::Box") [] [ T; A ];
                                            Ty.path "core::alloc::AllocError"
                                          ],
                                        [
                                          Ty.apply
                                            (Ty.path "core::result::Result")
                                            []
                                            [
                                              Ty.path "core::convert::Infallible";
                                              Ty.path "core::alloc::AllocError"
                                            ]
                                        ],
                                        "from_residual",
                                        []
                                      |),
                                      [ M.read (| residual |) ]
                                    |)
                                  |)
                                |)
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "core::ops::control_flow::ControlFlow::Continue",
                                0
                              |) in
                            let val := M.copy (| γ0_0 |) in
                            val))
                      ]
                    |)
                  |) in
                let~ _ :=
                  M.alloc (|
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "*mut") [] [ T ],
                        "write",
                        []
                      |),
                      [
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ],
                            "as_mut_ptr",
                            []
                          |),
                          [ M.read (| boxed |) ]
                        |);
                        M.read (| x |)
                      ]
                    |)
                  |) in
                M.alloc (|
                  Value.StructTuple
                    "core::result::Result::Ok"
                    [
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply
                            (Ty.path "alloc::boxed::Box")
                            []
                            [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ]; A
                            ],
                          "assume_init",
                          []
                        |),
                        [ M.read (| boxed |) ]
                      |)
                    ]
                |)
              |)))
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom AssociatedFunction_try_new_in :
      forall (T A : Ty.t),
      M.IsAssociatedFunction (Self T A) "try_new_in" (try_new_in T A).
    
    (*
        pub fn new_uninit_in(alloc: A) -> Box<mem::MaybeUninit<T>, A>
        where
            A: Allocator,
        {
            let layout = Layout::new::<mem::MaybeUninit<T>>();
            // NOTE: Prefer match over unwrap_or_else since closure sometimes not inlineable.
            // That would make code size bigger.
            match Box::try_new_uninit_in(alloc) {
                Ok(m) => m,
                Err(_) => handle_alloc_error(layout),
            }
        }
    *)
    Definition new_uninit_in
        (T A : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ alloc ] =>
        ltac:(M.monadic
          (let alloc := M.alloc (| alloc |) in
          M.read (|
            let~ layout :=
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.path "core::alloc::layout::Layout",
                    "new",
                    [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ] ]
                  |),
                  []
                |)
              |) in
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "alloc::boxed::Box") [] [ T; A ],
                    "try_new_uninit_in",
                    []
                  |),
                  [ M.read (| alloc |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 :=
                      M.SubPointer.get_struct_tuple_field (| γ, "core::result::Result::Ok", 0 |) in
                    let m := M.copy (| γ0_0 |) in
                    m));
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 :=
                      M.SubPointer.get_struct_tuple_field (| γ, "core::result::Result::Err", 0 |) in
                    M.alloc (|
                      M.never_to_any (|
                        M.call_closure (|
                          M.get_function (| "alloc::alloc::handle_alloc_error", [], [] |),
                          [ M.read (| layout |) ]
                        |)
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom AssociatedFunction_new_uninit_in :
      forall (T A : Ty.t),
      M.IsAssociatedFunction (Self T A) "new_uninit_in" (new_uninit_in T A).
    
    (*
        pub fn try_new_uninit_in(alloc: A) -> Result<Box<mem::MaybeUninit<T>, A>, AllocError>
        where
            A: Allocator,
        {
            let ptr = if T::IS_ZST {
                NonNull::dangling()
            } else {
                let layout = Layout::new::<mem::MaybeUninit<T>>();
                alloc.allocate(layout)?.cast()
            };
            unsafe { Ok(Box::from_raw_in(ptr.as_ptr(), alloc)) }
        }
    *)
    Definition try_new_uninit_in
        (T A : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ alloc ] =>
        ltac:(M.monadic
          (let alloc := M.alloc (| alloc |) in
          M.catch_return (|
            ltac:(M.monadic
              (M.read (|
                let~ ptr :=
                  M.copy (|
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.get_constant (| "core::mem::SizedTypeProperties::IS_ZST" |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (|
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "core::ptr::non_null::NonNull")
                                    []
                                    [
                                      Ty.apply
                                        (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                        []
                                        [ T ]
                                    ],
                                  "dangling",
                                  []
                                |),
                                []
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let~ layout :=
                              M.alloc (|
                                M.call_closure (|
                                  M.get_associated_function (|
                                    Ty.path "core::alloc::layout::Layout",
                                    "new",
                                    [
                                      Ty.apply
                                        (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                        []
                                        [ T ]
                                    ]
                                  |),
                                  []
                                |)
                              |) in
                            M.alloc (|
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "core::ptr::non_null::NonNull")
                                    []
                                    [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                                  "cast",
                                  [
                                    Ty.apply
                                      (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                      []
                                      [ T ]
                                  ]
                                |),
                                [
                                  M.read (|
                                    M.match_operator (|
                                      M.alloc (|
                                        M.call_closure (|
                                          M.get_trait_method (|
                                            "core::ops::try_trait::Try",
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "core::ptr::non_null::NonNull")
                                                  []
                                                  [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ]
                                                  ];
                                                Ty.path "core::alloc::AllocError"
                                              ],
                                            [],
                                            "branch",
                                            []
                                          |),
                                          [
                                            M.call_closure (|
                                              M.get_trait_method (|
                                                "core::alloc::Allocator",
                                                A,
                                                [],
                                                "allocate",
                                                []
                                              |),
                                              [ alloc; M.read (| layout |) ]
                                            |)
                                          ]
                                        |)
                                      |),
                                      [
                                        fun γ =>
                                          ltac:(M.monadic
                                            (let γ0_0 :=
                                              M.SubPointer.get_struct_tuple_field (|
                                                γ,
                                                "core::ops::control_flow::ControlFlow::Break",
                                                0
                                              |) in
                                            let residual := M.copy (| γ0_0 |) in
                                            M.alloc (|
                                              M.never_to_any (|
                                                M.read (|
                                                  M.return_ (|
                                                    M.call_closure (|
                                                      M.get_trait_method (|
                                                        "core::ops::try_trait::FromResidual",
                                                        Ty.apply
                                                          (Ty.path "core::result::Result")
                                                          []
                                                          [
                                                            Ty.apply
                                                              (Ty.path "alloc::boxed::Box")
                                                              []
                                                              [
                                                                Ty.apply
                                                                  (Ty.path
                                                                    "core::mem::maybe_uninit::MaybeUninit")
                                                                  []
                                                                  [ T ];
                                                                A
                                                              ];
                                                            Ty.path "core::alloc::AllocError"
                                                          ],
                                                        [
                                                          Ty.apply
                                                            (Ty.path "core::result::Result")
                                                            []
                                                            [
                                                              Ty.path "core::convert::Infallible";
                                                              Ty.path "core::alloc::AllocError"
                                                            ]
                                                        ],
                                                        "from_residual",
                                                        []
                                                      |),
                                                      [ M.read (| residual |) ]
                                                    |)
                                                  |)
                                                |)
                                              |)
                                            |)));
                                        fun γ =>
                                          ltac:(M.monadic
                                            (let γ0_0 :=
                                              M.SubPointer.get_struct_tuple_field (|
                                                γ,
                                                "core::ops::control_flow::ControlFlow::Continue",
                                                0
                                              |) in
                                            let val := M.copy (| γ0_0 |) in
                                            val))
                                      ]
                                    |)
                                  |)
                                ]
                              |)
                            |)))
                      ]
                    |)
                  |) in
                M.alloc (|
                  Value.StructTuple
                    "core::result::Result::Ok"
                    [
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply
                            (Ty.path "alloc::boxed::Box")
                            []
                            [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ]; A
                            ],
                          "from_raw_in",
                          []
                        |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply
                                (Ty.path "core::ptr::non_null::NonNull")
                                []
                                [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ]
                                ],
                              "as_ptr",
                              []
                            |),
                            [ M.read (| ptr |) ]
                          |);
                          M.read (| alloc |)
                        ]
                      |)
                    ]
                |)
              |)))
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom AssociatedFunction_try_new_uninit_in :
      forall (T A : Ty.t),
      M.IsAssociatedFunction (Self T A) "try_new_uninit_in" (try_new_uninit_in T A).
    
    (*
        pub fn new_zeroed_in(alloc: A) -> Box<mem::MaybeUninit<T>, A>
        where
            A: Allocator,
        {
            let layout = Layout::new::<mem::MaybeUninit<T>>();
            // NOTE: Prefer match over unwrap_or_else since closure sometimes not inlineable.
            // That would make code size bigger.
            match Box::try_new_zeroed_in(alloc) {
                Ok(m) => m,
                Err(_) => handle_alloc_error(layout),
            }
        }
    *)
    Definition new_zeroed_in
        (T A : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ alloc ] =>
        ltac:(M.monadic
          (let alloc := M.alloc (| alloc |) in
          M.read (|
            let~ layout :=
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.path "core::alloc::layout::Layout",
                    "new",
                    [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ] ]
                  |),
                  []
                |)
              |) in
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "alloc::boxed::Box") [] [ T; A ],
                    "try_new_zeroed_in",
                    []
                  |),
                  [ M.read (| alloc |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 :=
                      M.SubPointer.get_struct_tuple_field (| γ, "core::result::Result::Ok", 0 |) in
                    let m := M.copy (| γ0_0 |) in
                    m));
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 :=
                      M.SubPointer.get_struct_tuple_field (| γ, "core::result::Result::Err", 0 |) in
                    M.alloc (|
                      M.never_to_any (|
                        M.call_closure (|
                          M.get_function (| "alloc::alloc::handle_alloc_error", [], [] |),
                          [ M.read (| layout |) ]
                        |)
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom AssociatedFunction_new_zeroed_in :
      forall (T A : Ty.t),
      M.IsAssociatedFunction (Self T A) "new_zeroed_in" (new_zeroed_in T A).
    
    (*
        pub fn try_new_zeroed_in(alloc: A) -> Result<Box<mem::MaybeUninit<T>, A>, AllocError>
        where
            A: Allocator,
        {
            let ptr = if T::IS_ZST {
                NonNull::dangling()
            } else {
                let layout = Layout::new::<mem::MaybeUninit<T>>();
                alloc.allocate_zeroed(layout)?.cast()
            };
            unsafe { Ok(Box::from_raw_in(ptr.as_ptr(), alloc)) }
        }
    *)
    Definition try_new_zeroed_in
        (T A : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ alloc ] =>
        ltac:(M.monadic
          (let alloc := M.alloc (| alloc |) in
          M.catch_return (|
            ltac:(M.monadic
              (M.read (|
                let~ ptr :=
                  M.copy (|
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.get_constant (| "core::mem::SizedTypeProperties::IS_ZST" |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (|
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "core::ptr::non_null::NonNull")
                                    []
                                    [
                                      Ty.apply
                                        (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                        []
                                        [ T ]
                                    ],
                                  "dangling",
                                  []
                                |),
                                []
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let~ layout :=
                              M.alloc (|
                                M.call_closure (|
                                  M.get_associated_function (|
                                    Ty.path "core::alloc::layout::Layout",
                                    "new",
                                    [
                                      Ty.apply
                                        (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                        []
                                        [ T ]
                                    ]
                                  |),
                                  []
                                |)
                              |) in
                            M.alloc (|
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "core::ptr::non_null::NonNull")
                                    []
                                    [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                                  "cast",
                                  [
                                    Ty.apply
                                      (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                      []
                                      [ T ]
                                  ]
                                |),
                                [
                                  M.read (|
                                    M.match_operator (|
                                      M.alloc (|
                                        M.call_closure (|
                                          M.get_trait_method (|
                                            "core::ops::try_trait::Try",
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "core::ptr::non_null::NonNull")
                                                  []
                                                  [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ]
                                                  ];
                                                Ty.path "core::alloc::AllocError"
                                              ],
                                            [],
                                            "branch",
                                            []
                                          |),
                                          [
                                            M.call_closure (|
                                              M.get_trait_method (|
                                                "core::alloc::Allocator",
                                                A,
                                                [],
                                                "allocate_zeroed",
                                                []
                                              |),
                                              [ alloc; M.read (| layout |) ]
                                            |)
                                          ]
                                        |)
                                      |),
                                      [
                                        fun γ =>
                                          ltac:(M.monadic
                                            (let γ0_0 :=
                                              M.SubPointer.get_struct_tuple_field (|
                                                γ,
                                                "core::ops::control_flow::ControlFlow::Break",
                                                0
                                              |) in
                                            let residual := M.copy (| γ0_0 |) in
                                            M.alloc (|
                                              M.never_to_any (|
                                                M.read (|
                                                  M.return_ (|
                                                    M.call_closure (|
                                                      M.get_trait_method (|
                                                        "core::ops::try_trait::FromResidual",
                                                        Ty.apply
                                                          (Ty.path "core::result::Result")
                                                          []
                                                          [
                                                            Ty.apply
                                                              (Ty.path "alloc::boxed::Box")
                                                              []
                                                              [
                                                                Ty.apply
                                                                  (Ty.path
                                                                    "core::mem::maybe_uninit::MaybeUninit")
                                                                  []
                                                                  [ T ];
                                                                A
                                                              ];
                                                            Ty.path "core::alloc::AllocError"
                                                          ],
                                                        [
                                                          Ty.apply
                                                            (Ty.path "core::result::Result")
                                                            []
                                                            [
                                                              Ty.path "core::convert::Infallible";
                                                              Ty.path "core::alloc::AllocError"
                                                            ]
                                                        ],
                                                        "from_residual",
                                                        []
                                                      |),
                                                      [ M.read (| residual |) ]
                                                    |)
                                                  |)
                                                |)
                                              |)
                                            |)));
                                        fun γ =>
                                          ltac:(M.monadic
                                            (let γ0_0 :=
                                              M.SubPointer.get_struct_tuple_field (|
                                                γ,
                                                "core::ops::control_flow::ControlFlow::Continue",
                                                0
                                              |) in
                                            let val := M.copy (| γ0_0 |) in
                                            val))
                                      ]
                                    |)
                                  |)
                                ]
                              |)
                            |)))
                      ]
                    |)
                  |) in
                M.alloc (|
                  Value.StructTuple
                    "core::result::Result::Ok"
                    [
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply
                            (Ty.path "alloc::boxed::Box")
                            []
                            [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ]; A
                            ],
                          "from_raw_in",
                          []
                        |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply
                                (Ty.path "core::ptr::non_null::NonNull")
                                []
                                [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ]
                                ],
                              "as_ptr",
                              []
                            |),
                            [ M.read (| ptr |) ]
                          |);
                          M.read (| alloc |)
                        ]
                      |)
                    ]
                |)
              |)))
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom AssociatedFunction_try_new_zeroed_in :
      forall (T A : Ty.t),
      M.IsAssociatedFunction (Self T A) "try_new_zeroed_in" (try_new_zeroed_in T A).
    
    (*
        pub fn pin_in(x: T, alloc: A) -> Pin<Self>
        where
            A: 'static + Allocator,
        {
            Self::into_pin(Self::new_in(x, alloc))
        }
    *)
    Definition pin_in (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ x; alloc ] =>
        ltac:(M.monadic
          (let x := M.alloc (| x |) in
          let alloc := M.alloc (| alloc |) in
          M.call_closure (|
            M.get_associated_function (|
              Ty.apply (Ty.path "alloc::boxed::Box") [] [ T; A ],
              "into_pin",
              []
            |),
            [
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply (Ty.path "alloc::boxed::Box") [] [ T; A ],
                  "new_in",
                  []
                |),
                [ M.read (| x |); M.read (| alloc |) ]
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom AssociatedFunction_pin_in :
      forall (T A : Ty.t),
      M.IsAssociatedFunction (Self T A) "pin_in" (pin_in T A).
    
    (*
        pub fn into_boxed_slice(boxed: Self) -> Box<[T], A> {
            let (raw, alloc) = Box::into_raw_with_allocator(boxed);
            unsafe { Box::from_raw_in(raw as *mut [T; 1], alloc) }
        }
    *)
    Definition into_boxed_slice
        (T A : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ boxed ] =>
        ltac:(M.monadic
          (let boxed := M.alloc (| boxed |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "alloc::boxed::Box") [] [ T; A ],
                    "into_raw_with_allocator",
                    []
                  |),
                  [ M.read (| boxed |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let raw := M.copy (| γ0_0 |) in
                    let alloc := M.copy (| γ0_1 |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply
                            (Ty.path "alloc::boxed::Box")
                            []
                            [ Ty.apply (Ty.path "slice") [] [ T ]; A ],
                          "from_raw_in",
                          []
                        |),
                        [ M.rust_cast (M.read (| raw |)); M.read (| alloc |) ]
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom AssociatedFunction_into_boxed_slice :
      forall (T A : Ty.t),
      M.IsAssociatedFunction (Self T A) "into_boxed_slice" (into_boxed_slice T A).
    
    (*
        pub fn into_inner(boxed: Self) -> T {
            *boxed
        }
    *)
    Definition into_inner (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ boxed ] =>
        ltac:(M.monadic
          (let boxed := M.alloc (| boxed |) in
          M.read (| M.read (| boxed |) |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom AssociatedFunction_into_inner :
      forall (T A : Ty.t),
      M.IsAssociatedFunction (Self T A) "into_inner" (into_inner T A).
    (*
        pub const unsafe fn from_raw_in(raw: *mut T, alloc: A) -> Self {
            Box(unsafe { Unique::new_unchecked(raw) }, alloc)
        }
    *)
    Definition from_raw_in (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ raw; alloc ] =>
        ltac:(M.monadic
          (let raw := M.alloc (| raw |) in
          let alloc := M.alloc (| alloc |) in
          Value.StructTuple
            "alloc::boxed::Box"
            [
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply (Ty.path "core::ptr::unique::Unique") [] [ T ],
                  "new_unchecked",
                  []
                |),
                [ M.read (| raw |) ]
              |);
              M.read (| alloc |)
            ]))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom AssociatedFunction_from_raw_in :
      forall (T A : Ty.t),
      M.IsAssociatedFunction (Self T A) "from_raw_in" (from_raw_in T A).
    
    (*
        pub const unsafe fn from_non_null_in(raw: NonNull<T>, alloc: A) -> Self {
            // SAFETY: guaranteed by the caller.
            unsafe { Box::from_raw_in(raw.as_ptr(), alloc) }
        }
    *)
    Definition from_non_null_in
        (T A : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ raw; alloc ] =>
        ltac:(M.monadic
          (let raw := M.alloc (| raw |) in
          let alloc := M.alloc (| alloc |) in
          M.call_closure (|
            M.get_associated_function (|
              Ty.apply (Ty.path "alloc::boxed::Box") [] [ T; A ],
              "from_raw_in",
              []
            |),
            [
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply (Ty.path "core::ptr::non_null::NonNull") [] [ T ],
                  "as_ptr",
                  []
                |),
                [ M.read (| raw |) ]
              |);
              M.read (| alloc |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom AssociatedFunction_from_non_null_in :
      forall (T A : Ty.t),
      M.IsAssociatedFunction (Self T A) "from_non_null_in" (from_non_null_in T A).
    
    (*
        pub fn into_raw(b: Self) -> *mut T {
            // Make sure Miri realizes that we transition from a noalias pointer to a raw pointer here.
            unsafe { &raw mut *&mut *Self::into_raw_with_allocator(b).0 }
        }
    *)
    Definition into_raw (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ b ] =>
        ltac:(M.monadic
          (let b := M.alloc (| b |) in
          M.read (|
            M.SubPointer.get_tuple_field (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "alloc::boxed::Box") [] [ T; A ],
                    "into_raw_with_allocator",
                    []
                  |),
                  [ M.read (| b |) ]
                |)
              |),
              0
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom AssociatedFunction_into_raw :
      forall (T A : Ty.t),
      M.IsAssociatedFunction (Self T A) "into_raw" (into_raw T A).
    
    (*
        pub fn into_non_null(b: Self) -> NonNull<T> {
            // SAFETY: `Box` is guaranteed to be non-null.
            unsafe { NonNull::new_unchecked(Self::into_raw(b)) }
        }
    *)
    Definition into_non_null
        (T A : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ b ] =>
        ltac:(M.monadic
          (let b := M.alloc (| b |) in
          M.call_closure (|
            M.get_associated_function (|
              Ty.apply (Ty.path "core::ptr::non_null::NonNull") [] [ T ],
              "new_unchecked",
              []
            |),
            [
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply (Ty.path "alloc::boxed::Box") [] [ T; A ],
                  "into_raw",
                  []
                |),
                [ M.read (| b |) ]
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom AssociatedFunction_into_non_null :
      forall (T A : Ty.t),
      M.IsAssociatedFunction (Self T A) "into_non_null" (into_non_null T A).
    
    (*
        pub fn into_raw_with_allocator(b: Self) -> ( *mut T, A) {
            let mut b = mem::ManuallyDrop::new(b);
            // We carefully get the raw pointer out in a way that Miri's aliasing model understands what
            // is happening: using the primitive "deref" of `Box`. In case `A` is *not* `Global`, we
            // want *no* aliasing requirements here!
            // In case `A` *is* `Global`, this does not quite have the right behavior; `into_raw`
            // works around that.
            let ptr = &raw mut **b;
            let alloc = unsafe { ptr::read(&b.1) };
            (ptr, alloc)
        }
    *)
    Definition into_raw_with_allocator
        (T A : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ b ] =>
        ltac:(M.monadic
          (let b := M.alloc (| b |) in
          M.read (|
            let~ b :=
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "core::mem::manually_drop::ManuallyDrop")
                      []
                      [ Ty.apply (Ty.path "alloc::boxed::Box") [] [ T; A ] ],
                    "new",
                    []
                  |),
                  [ M.read (| b |) ]
                |)
              |) in
            let~ ptr :=
              M.alloc (|
                M.read (|
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::deref::DerefMut",
                      Ty.apply
                        (Ty.path "core::mem::manually_drop::ManuallyDrop")
                        []
                        [ Ty.apply (Ty.path "alloc::boxed::Box") [] [ T; A ] ],
                      [],
                      "deref_mut",
                      []
                    |),
                    [ b ]
                  |)
                |)
              |) in
            let~ alloc :=
              M.alloc (|
                M.call_closure (|
                  M.get_function (| "core::ptr::read", [], [ A ] |),
                  [
                    M.SubPointer.get_struct_tuple_field (|
                      M.call_closure (|
                        M.get_trait_method (|
                          "core::ops::deref::Deref",
                          Ty.apply
                            (Ty.path "core::mem::manually_drop::ManuallyDrop")
                            []
                            [ Ty.apply (Ty.path "alloc::boxed::Box") [] [ T; A ] ],
                          [],
                          "deref",
                          []
                        |),
                        [ b ]
                      |),
                      "alloc::boxed::Box",
                      1
                    |)
                  ]
                |)
              |) in
            M.alloc (| Value.Tuple [ M.read (| ptr |); M.read (| alloc |) ] |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom AssociatedFunction_into_raw_with_allocator :
      forall (T A : Ty.t),
      M.IsAssociatedFunction (Self T A) "into_raw_with_allocator" (into_raw_with_allocator T A).
    
    (*
        pub fn into_non_null_with_allocator(b: Self) -> (NonNull<T>, A) {
            let (ptr, alloc) = Box::into_raw_with_allocator(b);
            // SAFETY: `Box` is guaranteed to be non-null.
            unsafe { (NonNull::new_unchecked(ptr), alloc) }
        }
    *)
    Definition into_non_null_with_allocator
        (T A : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ b ] =>
        ltac:(M.monadic
          (let b := M.alloc (| b |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "alloc::boxed::Box") [] [ T; A ],
                    "into_raw_with_allocator",
                    []
                  |),
                  [ M.read (| b |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let ptr := M.copy (| γ0_0 |) in
                    let alloc := M.copy (| γ0_1 |) in
                    M.alloc (|
                      Value.Tuple
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply (Ty.path "core::ptr::non_null::NonNull") [] [ T ],
                              "new_unchecked",
                              []
                            |),
                            [ M.read (| ptr |) ]
                          |);
                          M.read (| alloc |)
                        ]
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom AssociatedFunction_into_non_null_with_allocator :
      forall (T A : Ty.t),
      M.IsAssociatedFunction
        (Self T A)
        "into_non_null_with_allocator"
        (into_non_null_with_allocator T A).
    
    (*
        pub fn into_unique(b: Self) -> (Unique<T>, A) {
            let (ptr, alloc) = Box::into_raw_with_allocator(b);
            unsafe { (Unique::from(&mut *ptr), alloc) }
        }
    *)
    Definition into_unique (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ b ] =>
        ltac:(M.monadic
          (let b := M.alloc (| b |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "alloc::boxed::Box") [] [ T; A ],
                    "into_raw_with_allocator",
                    []
                  |),
                  [ M.read (| b |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let ptr := M.copy (| γ0_0 |) in
                    let alloc := M.copy (| γ0_1 |) in
                    M.alloc (|
                      Value.Tuple
                        [
                          M.call_closure (|
                            M.get_trait_method (|
                              "core::convert::From",
                              Ty.apply (Ty.path "core::ptr::unique::Unique") [] [ T ],
                              [ Ty.apply (Ty.path "&mut") [] [ T ] ],
                              "from",
                              []
                            |),
                            [ M.read (| ptr |) ]
                          |);
                          M.read (| alloc |)
                        ]
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom AssociatedFunction_into_unique :
      forall (T A : Ty.t),
      M.IsAssociatedFunction (Self T A) "into_unique" (into_unique T A).
    
    (*
        pub fn as_mut_ptr(b: &mut Self) -> *mut T {
            // This is a primitive deref, not going through `DerefMut`, and therefore not materializing
            // any references.
            &raw mut **b
        }
    *)
    Definition as_mut_ptr (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ b ] =>
        ltac:(M.monadic
          (let b := M.alloc (| b |) in
          M.read (| M.read (| b |) |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom AssociatedFunction_as_mut_ptr :
      forall (T A : Ty.t),
      M.IsAssociatedFunction (Self T A) "as_mut_ptr" (as_mut_ptr T A).
    
    (*
        pub fn as_ptr(b: &Self) -> *const T {
            // This is a primitive deref, not going through `DerefMut`, and therefore not materializing
            // any references.
            &raw const **b
        }
    *)
    Definition as_ptr (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ b ] =>
        ltac:(M.monadic
          (let b := M.alloc (| b |) in
          M.read (| M.read (| b |) |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom AssociatedFunction_as_ptr :
      forall (T A : Ty.t),
      M.IsAssociatedFunction (Self T A) "as_ptr" (as_ptr T A).
    
    (*
        pub const fn allocator(b: &Self) -> &A {
            &b.1
        }
    *)
    Definition allocator (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ b ] =>
        ltac:(M.monadic
          (let b := M.alloc (| b |) in
          M.SubPointer.get_struct_tuple_field (| M.read (| b |), "alloc::boxed::Box", 1 |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom AssociatedFunction_allocator :
      forall (T A : Ty.t),
      M.IsAssociatedFunction (Self T A) "allocator" (allocator T A).
    
    (*
        pub fn leak<'a>(b: Self) -> &'a mut T
        where
            A: 'a,
        {
            unsafe { &mut *Box::into_raw(b) }
        }
    *)
    Definition leak (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ b ] =>
        ltac:(M.monadic
          (let b := M.alloc (| b |) in
          M.call_closure (|
            M.get_associated_function (|
              Ty.apply (Ty.path "alloc::boxed::Box") [] [ T; A ],
              "into_raw",
              []
            |),
            [ M.read (| b |) ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom AssociatedFunction_leak :
      forall (T A : Ty.t),
      M.IsAssociatedFunction (Self T A) "leak" (leak T A).
    
    (*
        pub const fn into_pin(boxed: Self) -> Pin<Self>
        where
            A: 'static,
        {
            // It's not possible to move or replace the insides of a `Pin<Box<T>>`
            // when `T: !Unpin`, so it's safe to pin it directly without any
            // additional requirements.
            unsafe { Pin::new_unchecked(boxed) }
        }
    *)
    Definition into_pin (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ boxed ] =>
        ltac:(M.monadic
          (let boxed := M.alloc (| boxed |) in
          M.call_closure (|
            M.get_associated_function (|
              Ty.apply
                (Ty.path "core::pin::Pin")
                []
                [ Ty.apply (Ty.path "alloc::boxed::Box") [] [ T; A ] ],
              "new_unchecked",
              []
            |),
            [ M.read (| boxed |) ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom AssociatedFunction_into_pin :
      forall (T A : Ty.t),
      M.IsAssociatedFunction (Self T A) "into_pin" (into_pin T A).
  End Impl_alloc_boxed_Box_T_A.
  
  Module Impl_alloc_boxed_Box_slice_T_alloc_alloc_Global.
    Definition Self (T : Ty.t) : Ty.t :=
      Ty.apply
        (Ty.path "alloc::boxed::Box")
        []
        [ Ty.apply (Ty.path "slice") [] [ T ]; Ty.path "alloc::alloc::Global" ].
    
    (*
        pub fn new_uninit_slice(len: usize) -> Box<[mem::MaybeUninit<T>]> {
            unsafe { RawVec::with_capacity(len).into_box(len) }
        }
    *)
    Definition new_uninit_slice
        (T : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [], [ len ] =>
        ltac:(M.monadic
          (let len := M.alloc (| len |) in
          M.call_closure (|
            M.get_associated_function (|
              Ty.apply (Ty.path "alloc::raw_vec::RawVec") [] [ T; Ty.path "alloc::alloc::Global" ],
              "into_box",
              []
            |),
            [
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "alloc::raw_vec::RawVec")
                    []
                    [ T; Ty.path "alloc::alloc::Global" ],
                  "with_capacity",
                  []
                |),
                [ M.read (| len |) ]
              |);
              M.read (| len |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom AssociatedFunction_new_uninit_slice :
      forall (T : Ty.t),
      M.IsAssociatedFunction (Self T) "new_uninit_slice" (new_uninit_slice T).
    
    (*
        pub fn new_zeroed_slice(len: usize) -> Box<[mem::MaybeUninit<T>]> {
            unsafe { RawVec::with_capacity_zeroed(len).into_box(len) }
        }
    *)
    Definition new_zeroed_slice
        (T : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [], [ len ] =>
        ltac:(M.monadic
          (let len := M.alloc (| len |) in
          M.call_closure (|
            M.get_associated_function (|
              Ty.apply (Ty.path "alloc::raw_vec::RawVec") [] [ T; Ty.path "alloc::alloc::Global" ],
              "into_box",
              []
            |),
            [
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "alloc::raw_vec::RawVec")
                    []
                    [ T; Ty.path "alloc::alloc::Global" ],
                  "with_capacity_zeroed",
                  []
                |),
                [ M.read (| len |) ]
              |);
              M.read (| len |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom AssociatedFunction_new_zeroed_slice :
      forall (T : Ty.t),
      M.IsAssociatedFunction (Self T) "new_zeroed_slice" (new_zeroed_slice T).
    
    (*
        pub fn try_new_uninit_slice(len: usize) -> Result<Box<[mem::MaybeUninit<T>]>, AllocError> {
            let ptr = if T::IS_ZST || len == 0 {
                NonNull::dangling()
            } else {
                let layout = match Layout::array::<mem::MaybeUninit<T>>(len) {
                    Ok(l) => l,
                    Err(_) => return Err(AllocError),
                };
                Global.allocate(layout)?.cast()
            };
            unsafe { Ok(RawVec::from_raw_parts_in(ptr.as_ptr(), len, Global).into_box(len)) }
        }
    *)
    Definition try_new_uninit_slice
        (T : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [], [ len ] =>
        ltac:(M.monadic
          (let len := M.alloc (| len |) in
          M.catch_return (|
            ltac:(M.monadic
              (M.read (|
                let~ ptr :=
                  M.copy (|
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  LogicalOp.or (|
                                    M.read (|
                                      M.get_constant (| "core::mem::SizedTypeProperties::IS_ZST" |)
                                    |),
                                    ltac:(M.monadic
                                      (BinOp.eq (|
                                        M.read (| len |),
                                        Value.Integer IntegerKind.Usize 0
                                      |)))
                                  |)
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (|
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "core::ptr::non_null::NonNull") [] [ T ],
                                  "dangling",
                                  []
                                |),
                                []
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let~ layout :=
                              M.copy (|
                                M.match_operator (|
                                  M.alloc (|
                                    M.call_closure (|
                                      M.get_associated_function (|
                                        Ty.path "core::alloc::layout::Layout",
                                        "array",
                                        [
                                          Ty.apply
                                            (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                            []
                                            [ T ]
                                        ]
                                      |),
                                      [ M.read (| len |) ]
                                    |)
                                  |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ0_0 :=
                                          M.SubPointer.get_struct_tuple_field (|
                                            γ,
                                            "core::result::Result::Ok",
                                            0
                                          |) in
                                        let l := M.copy (| γ0_0 |) in
                                        l));
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ0_0 :=
                                          M.SubPointer.get_struct_tuple_field (|
                                            γ,
                                            "core::result::Result::Err",
                                            0
                                          |) in
                                        M.alloc (|
                                          M.never_to_any (|
                                            M.read (|
                                              M.return_ (|
                                                Value.StructTuple
                                                  "core::result::Result::Err"
                                                  [ Value.StructTuple "core::alloc::AllocError" [] ]
                                              |)
                                            |)
                                          |)
                                        |)))
                                  ]
                                |)
                              |) in
                            M.alloc (|
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "core::ptr::non_null::NonNull")
                                    []
                                    [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                                  "cast",
                                  [ T ]
                                |),
                                [
                                  M.read (|
                                    M.match_operator (|
                                      M.alloc (|
                                        M.call_closure (|
                                          M.get_trait_method (|
                                            "core::ops::try_trait::Try",
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "core::ptr::non_null::NonNull")
                                                  []
                                                  [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ]
                                                  ];
                                                Ty.path "core::alloc::AllocError"
                                              ],
                                            [],
                                            "branch",
                                            []
                                          |),
                                          [
                                            M.call_closure (|
                                              M.get_trait_method (|
                                                "core::alloc::Allocator",
                                                Ty.path "alloc::alloc::Global",
                                                [],
                                                "allocate",
                                                []
                                              |),
                                              [
                                                M.alloc (|
                                                  Value.StructTuple "alloc::alloc::Global" []
                                                |);
                                                M.read (| layout |)
                                              ]
                                            |)
                                          ]
                                        |)
                                      |),
                                      [
                                        fun γ =>
                                          ltac:(M.monadic
                                            (let γ0_0 :=
                                              M.SubPointer.get_struct_tuple_field (|
                                                γ,
                                                "core::ops::control_flow::ControlFlow::Break",
                                                0
                                              |) in
                                            let residual := M.copy (| γ0_0 |) in
                                            M.alloc (|
                                              M.never_to_any (|
                                                M.read (|
                                                  M.return_ (|
                                                    M.call_closure (|
                                                      M.get_trait_method (|
                                                        "core::ops::try_trait::FromResidual",
                                                        Ty.apply
                                                          (Ty.path "core::result::Result")
                                                          []
                                                          [
                                                            Ty.apply
                                                              (Ty.path "alloc::boxed::Box")
                                                              []
                                                              [
                                                                Ty.apply
                                                                  (Ty.path "slice")
                                                                  []
                                                                  [
                                                                    Ty.apply
                                                                      (Ty.path
                                                                        "core::mem::maybe_uninit::MaybeUninit")
                                                                      []
                                                                      [ T ]
                                                                  ];
                                                                Ty.path "alloc::alloc::Global"
                                                              ];
                                                            Ty.path "core::alloc::AllocError"
                                                          ],
                                                        [
                                                          Ty.apply
                                                            (Ty.path "core::result::Result")
                                                            []
                                                            [
                                                              Ty.path "core::convert::Infallible";
                                                              Ty.path "core::alloc::AllocError"
                                                            ]
                                                        ],
                                                        "from_residual",
                                                        []
                                                      |),
                                                      [ M.read (| residual |) ]
                                                    |)
                                                  |)
                                                |)
                                              |)
                                            |)));
                                        fun γ =>
                                          ltac:(M.monadic
                                            (let γ0_0 :=
                                              M.SubPointer.get_struct_tuple_field (|
                                                γ,
                                                "core::ops::control_flow::ControlFlow::Continue",
                                                0
                                              |) in
                                            let val := M.copy (| γ0_0 |) in
                                            val))
                                      ]
                                    |)
                                  |)
                                ]
                              |)
                            |)))
                      ]
                    |)
                  |) in
                M.alloc (|
                  Value.StructTuple
                    "core::result::Result::Ok"
                    [
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply
                            (Ty.path "alloc::raw_vec::RawVec")
                            []
                            [ T; Ty.path "alloc::alloc::Global" ],
                          "into_box",
                          []
                        |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply
                                (Ty.path "alloc::raw_vec::RawVec")
                                []
                                [ T; Ty.path "alloc::alloc::Global" ],
                              "from_raw_parts_in",
                              []
                            |),
                            [
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "core::ptr::non_null::NonNull") [] [ T ],
                                  "as_ptr",
                                  []
                                |),
                                [ M.read (| ptr |) ]
                              |);
                              M.read (| len |);
                              Value.StructTuple "alloc::alloc::Global" []
                            ]
                          |);
                          M.read (| len |)
                        ]
                      |)
                    ]
                |)
              |)))
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom AssociatedFunction_try_new_uninit_slice :
      forall (T : Ty.t),
      M.IsAssociatedFunction (Self T) "try_new_uninit_slice" (try_new_uninit_slice T).
    
    (*
        pub fn try_new_zeroed_slice(len: usize) -> Result<Box<[mem::MaybeUninit<T>]>, AllocError> {
            let ptr = if T::IS_ZST || len == 0 {
                NonNull::dangling()
            } else {
                let layout = match Layout::array::<mem::MaybeUninit<T>>(len) {
                    Ok(l) => l,
                    Err(_) => return Err(AllocError),
                };
                Global.allocate_zeroed(layout)?.cast()
            };
            unsafe { Ok(RawVec::from_raw_parts_in(ptr.as_ptr(), len, Global).into_box(len)) }
        }
    *)
    Definition try_new_zeroed_slice
        (T : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [], [ len ] =>
        ltac:(M.monadic
          (let len := M.alloc (| len |) in
          M.catch_return (|
            ltac:(M.monadic
              (M.read (|
                let~ ptr :=
                  M.copy (|
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  LogicalOp.or (|
                                    M.read (|
                                      M.get_constant (| "core::mem::SizedTypeProperties::IS_ZST" |)
                                    |),
                                    ltac:(M.monadic
                                      (BinOp.eq (|
                                        M.read (| len |),
                                        Value.Integer IntegerKind.Usize 0
                                      |)))
                                  |)
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (|
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "core::ptr::non_null::NonNull") [] [ T ],
                                  "dangling",
                                  []
                                |),
                                []
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let~ layout :=
                              M.copy (|
                                M.match_operator (|
                                  M.alloc (|
                                    M.call_closure (|
                                      M.get_associated_function (|
                                        Ty.path "core::alloc::layout::Layout",
                                        "array",
                                        [
                                          Ty.apply
                                            (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                            []
                                            [ T ]
                                        ]
                                      |),
                                      [ M.read (| len |) ]
                                    |)
                                  |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ0_0 :=
                                          M.SubPointer.get_struct_tuple_field (|
                                            γ,
                                            "core::result::Result::Ok",
                                            0
                                          |) in
                                        let l := M.copy (| γ0_0 |) in
                                        l));
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ0_0 :=
                                          M.SubPointer.get_struct_tuple_field (|
                                            γ,
                                            "core::result::Result::Err",
                                            0
                                          |) in
                                        M.alloc (|
                                          M.never_to_any (|
                                            M.read (|
                                              M.return_ (|
                                                Value.StructTuple
                                                  "core::result::Result::Err"
                                                  [ Value.StructTuple "core::alloc::AllocError" [] ]
                                              |)
                                            |)
                                          |)
                                        |)))
                                  ]
                                |)
                              |) in
                            M.alloc (|
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "core::ptr::non_null::NonNull")
                                    []
                                    [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                                  "cast",
                                  [ T ]
                                |),
                                [
                                  M.read (|
                                    M.match_operator (|
                                      M.alloc (|
                                        M.call_closure (|
                                          M.get_trait_method (|
                                            "core::ops::try_trait::Try",
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "core::ptr::non_null::NonNull")
                                                  []
                                                  [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ]
                                                  ];
                                                Ty.path "core::alloc::AllocError"
                                              ],
                                            [],
                                            "branch",
                                            []
                                          |),
                                          [
                                            M.call_closure (|
                                              M.get_trait_method (|
                                                "core::alloc::Allocator",
                                                Ty.path "alloc::alloc::Global",
                                                [],
                                                "allocate_zeroed",
                                                []
                                              |),
                                              [
                                                M.alloc (|
                                                  Value.StructTuple "alloc::alloc::Global" []
                                                |);
                                                M.read (| layout |)
                                              ]
                                            |)
                                          ]
                                        |)
                                      |),
                                      [
                                        fun γ =>
                                          ltac:(M.monadic
                                            (let γ0_0 :=
                                              M.SubPointer.get_struct_tuple_field (|
                                                γ,
                                                "core::ops::control_flow::ControlFlow::Break",
                                                0
                                              |) in
                                            let residual := M.copy (| γ0_0 |) in
                                            M.alloc (|
                                              M.never_to_any (|
                                                M.read (|
                                                  M.return_ (|
                                                    M.call_closure (|
                                                      M.get_trait_method (|
                                                        "core::ops::try_trait::FromResidual",
                                                        Ty.apply
                                                          (Ty.path "core::result::Result")
                                                          []
                                                          [
                                                            Ty.apply
                                                              (Ty.path "alloc::boxed::Box")
                                                              []
                                                              [
                                                                Ty.apply
                                                                  (Ty.path "slice")
                                                                  []
                                                                  [
                                                                    Ty.apply
                                                                      (Ty.path
                                                                        "core::mem::maybe_uninit::MaybeUninit")
                                                                      []
                                                                      [ T ]
                                                                  ];
                                                                Ty.path "alloc::alloc::Global"
                                                              ];
                                                            Ty.path "core::alloc::AllocError"
                                                          ],
                                                        [
                                                          Ty.apply
                                                            (Ty.path "core::result::Result")
                                                            []
                                                            [
                                                              Ty.path "core::convert::Infallible";
                                                              Ty.path "core::alloc::AllocError"
                                                            ]
                                                        ],
                                                        "from_residual",
                                                        []
                                                      |),
                                                      [ M.read (| residual |) ]
                                                    |)
                                                  |)
                                                |)
                                              |)
                                            |)));
                                        fun γ =>
                                          ltac:(M.monadic
                                            (let γ0_0 :=
                                              M.SubPointer.get_struct_tuple_field (|
                                                γ,
                                                "core::ops::control_flow::ControlFlow::Continue",
                                                0
                                              |) in
                                            let val := M.copy (| γ0_0 |) in
                                            val))
                                      ]
                                    |)
                                  |)
                                ]
                              |)
                            |)))
                      ]
                    |)
                  |) in
                M.alloc (|
                  Value.StructTuple
                    "core::result::Result::Ok"
                    [
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply
                            (Ty.path "alloc::raw_vec::RawVec")
                            []
                            [ T; Ty.path "alloc::alloc::Global" ],
                          "into_box",
                          []
                        |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply
                                (Ty.path "alloc::raw_vec::RawVec")
                                []
                                [ T; Ty.path "alloc::alloc::Global" ],
                              "from_raw_parts_in",
                              []
                            |),
                            [
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "core::ptr::non_null::NonNull") [] [ T ],
                                  "as_ptr",
                                  []
                                |),
                                [ M.read (| ptr |) ]
                              |);
                              M.read (| len |);
                              Value.StructTuple "alloc::alloc::Global" []
                            ]
                          |);
                          M.read (| len |)
                        ]
                      |)
                    ]
                |)
              |)))
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom AssociatedFunction_try_new_zeroed_slice :
      forall (T : Ty.t),
      M.IsAssociatedFunction (Self T) "try_new_zeroed_slice" (try_new_zeroed_slice T).
  End Impl_alloc_boxed_Box_slice_T_alloc_alloc_Global.
  
  Module Impl_alloc_boxed_Box_slice_T_A.
    Definition Self (T A : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "alloc::boxed::Box") [] [ Ty.apply (Ty.path "slice") [] [ T ]; A ].
    
    (*
        pub fn new_uninit_slice_in(len: usize, alloc: A) -> Box<[mem::MaybeUninit<T>], A> {
            unsafe { RawVec::with_capacity_in(len, alloc).into_box(len) }
        }
    *)
    Definition new_uninit_slice_in
        (T A : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ len; alloc ] =>
        ltac:(M.monadic
          (let len := M.alloc (| len |) in
          let alloc := M.alloc (| alloc |) in
          M.call_closure (|
            M.get_associated_function (|
              Ty.apply (Ty.path "alloc::raw_vec::RawVec") [] [ T; A ],
              "into_box",
              []
            |),
            [
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply (Ty.path "alloc::raw_vec::RawVec") [] [ T; A ],
                  "with_capacity_in",
                  []
                |),
                [ M.read (| len |); M.read (| alloc |) ]
              |);
              M.read (| len |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom AssociatedFunction_new_uninit_slice_in :
      forall (T A : Ty.t),
      M.IsAssociatedFunction (Self T A) "new_uninit_slice_in" (new_uninit_slice_in T A).
    
    (*
        pub fn new_zeroed_slice_in(len: usize, alloc: A) -> Box<[mem::MaybeUninit<T>], A> {
            unsafe { RawVec::with_capacity_zeroed_in(len, alloc).into_box(len) }
        }
    *)
    Definition new_zeroed_slice_in
        (T A : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ len; alloc ] =>
        ltac:(M.monadic
          (let len := M.alloc (| len |) in
          let alloc := M.alloc (| alloc |) in
          M.call_closure (|
            M.get_associated_function (|
              Ty.apply (Ty.path "alloc::raw_vec::RawVec") [] [ T; A ],
              "into_box",
              []
            |),
            [
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply (Ty.path "alloc::raw_vec::RawVec") [] [ T; A ],
                  "with_capacity_zeroed_in",
                  []
                |),
                [ M.read (| len |); M.read (| alloc |) ]
              |);
              M.read (| len |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom AssociatedFunction_new_zeroed_slice_in :
      forall (T A : Ty.t),
      M.IsAssociatedFunction (Self T A) "new_zeroed_slice_in" (new_zeroed_slice_in T A).
    
    (*
        pub fn try_new_uninit_slice_in(
            len: usize,
            alloc: A,
        ) -> Result<Box<[mem::MaybeUninit<T>], A>, AllocError> {
            let ptr = if T::IS_ZST || len == 0 {
                NonNull::dangling()
            } else {
                let layout = match Layout::array::<mem::MaybeUninit<T>>(len) {
                    Ok(l) => l,
                    Err(_) => return Err(AllocError),
                };
                alloc.allocate(layout)?.cast()
            };
            unsafe { Ok(RawVec::from_raw_parts_in(ptr.as_ptr(), len, alloc).into_box(len)) }
        }
    *)
    Definition try_new_uninit_slice_in
        (T A : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ len; alloc ] =>
        ltac:(M.monadic
          (let len := M.alloc (| len |) in
          let alloc := M.alloc (| alloc |) in
          M.catch_return (|
            ltac:(M.monadic
              (M.read (|
                let~ ptr :=
                  M.copy (|
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  LogicalOp.or (|
                                    M.read (|
                                      M.get_constant (| "core::mem::SizedTypeProperties::IS_ZST" |)
                                    |),
                                    ltac:(M.monadic
                                      (BinOp.eq (|
                                        M.read (| len |),
                                        Value.Integer IntegerKind.Usize 0
                                      |)))
                                  |)
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (|
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "core::ptr::non_null::NonNull") [] [ T ],
                                  "dangling",
                                  []
                                |),
                                []
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let~ layout :=
                              M.copy (|
                                M.match_operator (|
                                  M.alloc (|
                                    M.call_closure (|
                                      M.get_associated_function (|
                                        Ty.path "core::alloc::layout::Layout",
                                        "array",
                                        [
                                          Ty.apply
                                            (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                            []
                                            [ T ]
                                        ]
                                      |),
                                      [ M.read (| len |) ]
                                    |)
                                  |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ0_0 :=
                                          M.SubPointer.get_struct_tuple_field (|
                                            γ,
                                            "core::result::Result::Ok",
                                            0
                                          |) in
                                        let l := M.copy (| γ0_0 |) in
                                        l));
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ0_0 :=
                                          M.SubPointer.get_struct_tuple_field (|
                                            γ,
                                            "core::result::Result::Err",
                                            0
                                          |) in
                                        M.alloc (|
                                          M.never_to_any (|
                                            M.read (|
                                              M.return_ (|
                                                Value.StructTuple
                                                  "core::result::Result::Err"
                                                  [ Value.StructTuple "core::alloc::AllocError" [] ]
                                              |)
                                            |)
                                          |)
                                        |)))
                                  ]
                                |)
                              |) in
                            M.alloc (|
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "core::ptr::non_null::NonNull")
                                    []
                                    [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                                  "cast",
                                  [ T ]
                                |),
                                [
                                  M.read (|
                                    M.match_operator (|
                                      M.alloc (|
                                        M.call_closure (|
                                          M.get_trait_method (|
                                            "core::ops::try_trait::Try",
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "core::ptr::non_null::NonNull")
                                                  []
                                                  [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ]
                                                  ];
                                                Ty.path "core::alloc::AllocError"
                                              ],
                                            [],
                                            "branch",
                                            []
                                          |),
                                          [
                                            M.call_closure (|
                                              M.get_trait_method (|
                                                "core::alloc::Allocator",
                                                A,
                                                [],
                                                "allocate",
                                                []
                                              |),
                                              [ alloc; M.read (| layout |) ]
                                            |)
                                          ]
                                        |)
                                      |),
                                      [
                                        fun γ =>
                                          ltac:(M.monadic
                                            (let γ0_0 :=
                                              M.SubPointer.get_struct_tuple_field (|
                                                γ,
                                                "core::ops::control_flow::ControlFlow::Break",
                                                0
                                              |) in
                                            let residual := M.copy (| γ0_0 |) in
                                            M.alloc (|
                                              M.never_to_any (|
                                                M.read (|
                                                  M.return_ (|
                                                    M.call_closure (|
                                                      M.get_trait_method (|
                                                        "core::ops::try_trait::FromResidual",
                                                        Ty.apply
                                                          (Ty.path "core::result::Result")
                                                          []
                                                          [
                                                            Ty.apply
                                                              (Ty.path "alloc::boxed::Box")
                                                              []
                                                              [
                                                                Ty.apply
                                                                  (Ty.path "slice")
                                                                  []
                                                                  [
                                                                    Ty.apply
                                                                      (Ty.path
                                                                        "core::mem::maybe_uninit::MaybeUninit")
                                                                      []
                                                                      [ T ]
                                                                  ];
                                                                A
                                                              ];
                                                            Ty.path "core::alloc::AllocError"
                                                          ],
                                                        [
                                                          Ty.apply
                                                            (Ty.path "core::result::Result")
                                                            []
                                                            [
                                                              Ty.path "core::convert::Infallible";
                                                              Ty.path "core::alloc::AllocError"
                                                            ]
                                                        ],
                                                        "from_residual",
                                                        []
                                                      |),
                                                      [ M.read (| residual |) ]
                                                    |)
                                                  |)
                                                |)
                                              |)
                                            |)));
                                        fun γ =>
                                          ltac:(M.monadic
                                            (let γ0_0 :=
                                              M.SubPointer.get_struct_tuple_field (|
                                                γ,
                                                "core::ops::control_flow::ControlFlow::Continue",
                                                0
                                              |) in
                                            let val := M.copy (| γ0_0 |) in
                                            val))
                                      ]
                                    |)
                                  |)
                                ]
                              |)
                            |)))
                      ]
                    |)
                  |) in
                M.alloc (|
                  Value.StructTuple
                    "core::result::Result::Ok"
                    [
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "alloc::raw_vec::RawVec") [] [ T; A ],
                          "into_box",
                          []
                        |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply (Ty.path "alloc::raw_vec::RawVec") [] [ T; A ],
                              "from_raw_parts_in",
                              []
                            |),
                            [
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "core::ptr::non_null::NonNull") [] [ T ],
                                  "as_ptr",
                                  []
                                |),
                                [ M.read (| ptr |) ]
                              |);
                              M.read (| len |);
                              M.read (| alloc |)
                            ]
                          |);
                          M.read (| len |)
                        ]
                      |)
                    ]
                |)
              |)))
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom AssociatedFunction_try_new_uninit_slice_in :
      forall (T A : Ty.t),
      M.IsAssociatedFunction (Self T A) "try_new_uninit_slice_in" (try_new_uninit_slice_in T A).
    
    (*
        pub fn try_new_zeroed_slice_in(
            len: usize,
            alloc: A,
        ) -> Result<Box<[mem::MaybeUninit<T>], A>, AllocError> {
            let ptr = if T::IS_ZST || len == 0 {
                NonNull::dangling()
            } else {
                let layout = match Layout::array::<mem::MaybeUninit<T>>(len) {
                    Ok(l) => l,
                    Err(_) => return Err(AllocError),
                };
                alloc.allocate_zeroed(layout)?.cast()
            };
            unsafe { Ok(RawVec::from_raw_parts_in(ptr.as_ptr(), len, alloc).into_box(len)) }
        }
    *)
    Definition try_new_zeroed_slice_in
        (T A : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ len; alloc ] =>
        ltac:(M.monadic
          (let len := M.alloc (| len |) in
          let alloc := M.alloc (| alloc |) in
          M.catch_return (|
            ltac:(M.monadic
              (M.read (|
                let~ ptr :=
                  M.copy (|
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  LogicalOp.or (|
                                    M.read (|
                                      M.get_constant (| "core::mem::SizedTypeProperties::IS_ZST" |)
                                    |),
                                    ltac:(M.monadic
                                      (BinOp.eq (|
                                        M.read (| len |),
                                        Value.Integer IntegerKind.Usize 0
                                      |)))
                                  |)
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (|
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "core::ptr::non_null::NonNull") [] [ T ],
                                  "dangling",
                                  []
                                |),
                                []
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let~ layout :=
                              M.copy (|
                                M.match_operator (|
                                  M.alloc (|
                                    M.call_closure (|
                                      M.get_associated_function (|
                                        Ty.path "core::alloc::layout::Layout",
                                        "array",
                                        [
                                          Ty.apply
                                            (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                            []
                                            [ T ]
                                        ]
                                      |),
                                      [ M.read (| len |) ]
                                    |)
                                  |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ0_0 :=
                                          M.SubPointer.get_struct_tuple_field (|
                                            γ,
                                            "core::result::Result::Ok",
                                            0
                                          |) in
                                        let l := M.copy (| γ0_0 |) in
                                        l));
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ0_0 :=
                                          M.SubPointer.get_struct_tuple_field (|
                                            γ,
                                            "core::result::Result::Err",
                                            0
                                          |) in
                                        M.alloc (|
                                          M.never_to_any (|
                                            M.read (|
                                              M.return_ (|
                                                Value.StructTuple
                                                  "core::result::Result::Err"
                                                  [ Value.StructTuple "core::alloc::AllocError" [] ]
                                              |)
                                            |)
                                          |)
                                        |)))
                                  ]
                                |)
                              |) in
                            M.alloc (|
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "core::ptr::non_null::NonNull")
                                    []
                                    [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                                  "cast",
                                  [ T ]
                                |),
                                [
                                  M.read (|
                                    M.match_operator (|
                                      M.alloc (|
                                        M.call_closure (|
                                          M.get_trait_method (|
                                            "core::ops::try_trait::Try",
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "core::ptr::non_null::NonNull")
                                                  []
                                                  [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ]
                                                  ];
                                                Ty.path "core::alloc::AllocError"
                                              ],
                                            [],
                                            "branch",
                                            []
                                          |),
                                          [
                                            M.call_closure (|
                                              M.get_trait_method (|
                                                "core::alloc::Allocator",
                                                A,
                                                [],
                                                "allocate_zeroed",
                                                []
                                              |),
                                              [ alloc; M.read (| layout |) ]
                                            |)
                                          ]
                                        |)
                                      |),
                                      [
                                        fun γ =>
                                          ltac:(M.monadic
                                            (let γ0_0 :=
                                              M.SubPointer.get_struct_tuple_field (|
                                                γ,
                                                "core::ops::control_flow::ControlFlow::Break",
                                                0
                                              |) in
                                            let residual := M.copy (| γ0_0 |) in
                                            M.alloc (|
                                              M.never_to_any (|
                                                M.read (|
                                                  M.return_ (|
                                                    M.call_closure (|
                                                      M.get_trait_method (|
                                                        "core::ops::try_trait::FromResidual",
                                                        Ty.apply
                                                          (Ty.path "core::result::Result")
                                                          []
                                                          [
                                                            Ty.apply
                                                              (Ty.path "alloc::boxed::Box")
                                                              []
                                                              [
                                                                Ty.apply
                                                                  (Ty.path "slice")
                                                                  []
                                                                  [
                                                                    Ty.apply
                                                                      (Ty.path
                                                                        "core::mem::maybe_uninit::MaybeUninit")
                                                                      []
                                                                      [ T ]
                                                                  ];
                                                                A
                                                              ];
                                                            Ty.path "core::alloc::AllocError"
                                                          ],
                                                        [
                                                          Ty.apply
                                                            (Ty.path "core::result::Result")
                                                            []
                                                            [
                                                              Ty.path "core::convert::Infallible";
                                                              Ty.path "core::alloc::AllocError"
                                                            ]
                                                        ],
                                                        "from_residual",
                                                        []
                                                      |),
                                                      [ M.read (| residual |) ]
                                                    |)
                                                  |)
                                                |)
                                              |)
                                            |)));
                                        fun γ =>
                                          ltac:(M.monadic
                                            (let γ0_0 :=
                                              M.SubPointer.get_struct_tuple_field (|
                                                γ,
                                                "core::ops::control_flow::ControlFlow::Continue",
                                                0
                                              |) in
                                            let val := M.copy (| γ0_0 |) in
                                            val))
                                      ]
                                    |)
                                  |)
                                ]
                              |)
                            |)))
                      ]
                    |)
                  |) in
                M.alloc (|
                  Value.StructTuple
                    "core::result::Result::Ok"
                    [
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "alloc::raw_vec::RawVec") [] [ T; A ],
                          "into_box",
                          []
                        |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply (Ty.path "alloc::raw_vec::RawVec") [] [ T; A ],
                              "from_raw_parts_in",
                              []
                            |),
                            [
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "core::ptr::non_null::NonNull") [] [ T ],
                                  "as_ptr",
                                  []
                                |),
                                [ M.read (| ptr |) ]
                              |);
                              M.read (| len |);
                              M.read (| alloc |)
                            ]
                          |);
                          M.read (| len |)
                        ]
                      |)
                    ]
                |)
              |)))
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom AssociatedFunction_try_new_zeroed_slice_in :
      forall (T A : Ty.t),
      M.IsAssociatedFunction (Self T A) "try_new_zeroed_slice_in" (try_new_zeroed_slice_in T A).
  End Impl_alloc_boxed_Box_slice_T_A.
  
  Module Impl_alloc_boxed_Box_core_mem_maybe_uninit_MaybeUninit_T_A.
    Definition Self (T A : Ty.t) : Ty.t :=
      Ty.apply
        (Ty.path "alloc::boxed::Box")
        []
        [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ]; A ].
    
    (*
        pub unsafe fn assume_init(self) -> Box<T, A> {
            let (raw, alloc) = Box::into_raw_with_allocator(self);
            unsafe { Box::from_raw_in(raw as *mut T, alloc) }
        }
    *)
    Definition assume_init (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "alloc::boxed::Box")
                      []
                      [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ]; A ],
                    "into_raw_with_allocator",
                    []
                  |),
                  [ M.read (| self |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let raw := M.copy (| γ0_0 |) in
                    let alloc := M.copy (| γ0_1 |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "alloc::boxed::Box") [] [ T; A ],
                          "from_raw_in",
                          []
                        |),
                        [ M.rust_cast (M.read (| raw |)); M.read (| alloc |) ]
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom AssociatedFunction_assume_init :
      forall (T A : Ty.t),
      M.IsAssociatedFunction (Self T A) "assume_init" (assume_init T A).
    
    (*
        pub fn write(mut boxed: Self, value: T) -> Box<T, A> {
            unsafe {
                ( *boxed).write(value);
                boxed.assume_init()
            }
        }
    *)
    Definition write (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ boxed; value ] =>
        ltac:(M.monadic
          (let boxed := M.alloc (| boxed |) in
          let value := M.alloc (| value |) in
          M.read (|
            let~ _ :=
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ],
                    "write",
                    []
                  |),
                  [ M.read (| boxed |); M.read (| value |) ]
                |)
              |) in
            M.alloc (|
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "alloc::boxed::Box")
                    []
                    [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ]; A ],
                  "assume_init",
                  []
                |),
                [ M.read (| boxed |) ]
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom AssociatedFunction_write :
      forall (T A : Ty.t),
      M.IsAssociatedFunction (Self T A) "write" (write T A).
  End Impl_alloc_boxed_Box_core_mem_maybe_uninit_MaybeUninit_T_A.
  
  Module Impl_alloc_boxed_Box_slice_core_mem_maybe_uninit_MaybeUninit_T_A.
    Definition Self (T A : Ty.t) : Ty.t :=
      Ty.apply
        (Ty.path "alloc::boxed::Box")
        []
        [
          Ty.apply
            (Ty.path "slice")
            []
            [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ] ];
          A
        ].
    
    (*
        pub unsafe fn assume_init(self) -> Box<[T], A> {
            let (raw, alloc) = Box::into_raw_with_allocator(self);
            unsafe { Box::from_raw_in(raw as *mut [T], alloc) }
        }
    *)
    Definition assume_init (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "alloc::boxed::Box")
                      []
                      [
                        Ty.apply
                          (Ty.path "slice")
                          []
                          [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ] ];
                        A
                      ],
                    "into_raw_with_allocator",
                    []
                  |),
                  [ M.read (| self |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let raw := M.copy (| γ0_0 |) in
                    let alloc := M.copy (| γ0_1 |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply
                            (Ty.path "alloc::boxed::Box")
                            []
                            [ Ty.apply (Ty.path "slice") [] [ T ]; A ],
                          "from_raw_in",
                          []
                        |),
                        [ M.rust_cast (M.read (| raw |)); M.read (| alloc |) ]
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom AssociatedFunction_assume_init :
      forall (T A : Ty.t),
      M.IsAssociatedFunction (Self T A) "assume_init" (assume_init T A).
  End Impl_alloc_boxed_Box_slice_core_mem_maybe_uninit_MaybeUninit_T_A.
  
  
  
  Module Impl_core_ops_drop_Drop_where_core_marker_Sized_T_where_core_alloc_Allocator_A_for_alloc_boxed_Box_T_A.
    Definition Self (T A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::boxed::Box") [] [ T; A ].
    
    (*
        fn drop(&mut self) {
            // the T in the Box is dropped by the compiler before the destructor is run
    
            let ptr = self.0;
    
            unsafe {
                let layout = Layout::for_value_raw(ptr.as_ptr());
                if layout.size() != 0 {
                    self.1.deallocate(From::from(ptr.cast()), layout);
                }
            }
        }
    *)
    Definition drop (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            let~ ptr :=
              M.copy (|
                M.SubPointer.get_struct_tuple_field (| M.read (| self |), "alloc::boxed::Box", 0 |)
              |) in
            let~ layout :=
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.path "core::alloc::layout::Layout",
                    "for_value_raw",
                    [ T ]
                  |),
                  [
                    (* MutToConstPointer *)
                    M.pointer_coercion
                      (M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "core::ptr::unique::Unique") [] [ T ],
                          "as_ptr",
                          []
                        |),
                        [ M.read (| ptr |) ]
                      |))
                  ]
                |)
              |) in
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          BinOp.ne (|
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.path "core::alloc::layout::Layout",
                                "size",
                                []
                              |),
                              [ layout ]
                            |),
                            Value.Integer IntegerKind.Usize 0
                          |)
                        |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    let~ _ :=
                      M.alloc (|
                        M.call_closure (|
                          M.get_trait_method (|
                            "core::alloc::Allocator",
                            A,
                            [],
                            "deallocate",
                            []
                          |),
                          [
                            M.SubPointer.get_struct_tuple_field (|
                              M.read (| self |),
                              "alloc::boxed::Box",
                              1
                            |);
                            M.call_closure (|
                              M.get_trait_method (|
                                "core::convert::From",
                                Ty.apply
                                  (Ty.path "core::ptr::non_null::NonNull")
                                  []
                                  [ Ty.path "u8" ],
                                [ Ty.apply (Ty.path "core::ptr::unique::Unique") [] [ Ty.path "u8" ]
                                ],
                                "from",
                                []
                              |),
                              [
                                M.call_closure (|
                                  M.get_associated_function (|
                                    Ty.apply (Ty.path "core::ptr::unique::Unique") [] [ T ],
                                    "cast",
                                    [ Ty.path "u8" ]
                                  |),
                                  [ M.read (| ptr |) ]
                                |)
                              ]
                            |);
                            M.read (| layout |)
                          ]
                        |)
                      |) in
                    M.alloc (| Value.Tuple [] |)));
                fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (T A : Ty.t),
      M.IsTraitInstance
        "core::ops::drop::Drop"
        (Self T A)
        (* Trait polymorphic types *) []
        (* Instance *) [ ("drop", InstanceField.Method (drop T A)) ].
  End Impl_core_ops_drop_Drop_where_core_marker_Sized_T_where_core_alloc_Allocator_A_for_alloc_boxed_Box_T_A.
  
  Module Impl_core_default_Default_where_core_default_Default_T_for_alloc_boxed_Box_T_alloc_alloc_Global.
    Definition Self (T : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "alloc::boxed::Box") [] [ T; Ty.path "alloc::alloc::Global" ].
    
    (*
        fn default() -> Self {
            Box::new(T::default())
        }
    *)
    Definition default (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [], [] =>
        ltac:(M.monadic
          (M.call_closure (|
            M.get_associated_function (|
              Ty.apply (Ty.path "alloc::boxed::Box") [] [ T; Ty.path "alloc::alloc::Global" ],
              "new",
              []
            |),
            [
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "core::default::Default"
        (Self T)
        (* Trait polymorphic types *) []
        (* Instance *) [ ("default", InstanceField.Method (default T)) ].
  End Impl_core_default_Default_where_core_default_Default_T_for_alloc_boxed_Box_T_alloc_alloc_Global.
  
  Module Impl_core_default_Default_for_alloc_boxed_Box_slice_T_alloc_alloc_Global.
    Definition Self (T : Ty.t) : Ty.t :=
      Ty.apply
        (Ty.path "alloc::boxed::Box")
        []
        [ Ty.apply (Ty.path "slice") [] [ T ]; Ty.path "alloc::alloc::Global" ].
    
    (*
        fn default() -> Self {
            let ptr: Unique<[T]> = Unique::<[T; 0]>::dangling();
            Box(ptr, Global)
        }
    *)
    Definition default (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [], [] =>
        ltac:(M.monadic
          (M.read (|
            let~ ptr :=
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "core::ptr::unique::Unique")
                      []
                      [ Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 0 ] [ T ] ],
                    "dangling",
                    []
                  |),
                  []
                |)
              |) in
            M.alloc (|
              Value.StructTuple
                "alloc::boxed::Box"
                [ M.read (| ptr |); Value.StructTuple "alloc::alloc::Global" [] ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "core::default::Default"
        (Self T)
        (* Trait polymorphic types *) []
        (* Instance *) [ ("default", InstanceField.Method (default T)) ].
  End Impl_core_default_Default_for_alloc_boxed_Box_slice_T_alloc_alloc_Global.
  
  Module Impl_core_default_Default_for_alloc_boxed_Box_str_alloc_alloc_Global.
    Definition Self : Ty.t :=
      Ty.apply (Ty.path "alloc::boxed::Box") [] [ Ty.path "str"; Ty.path "alloc::alloc::Global" ].
    
    (*
        fn default() -> Self {
            // SAFETY: This is the same as `Unique::cast<U>` but with an unsized `U = str`.
            let ptr: Unique<str> = unsafe {
                let bytes: Unique<[u8]> = Unique::<[u8; 0]>::dangling();
                Unique::new_unchecked(bytes.as_ptr() as *mut str)
            };
            Box(ptr, Global)
        }
    *)
    Definition default (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [] =>
        ltac:(M.monadic
          (M.read (|
            let~ ptr :=
              M.copy (|
                let~ bytes :=
                  M.alloc (|
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "core::ptr::unique::Unique")
                          []
                          [
                            Ty.apply
                              (Ty.path "array")
                              [ Value.Integer IntegerKind.Usize 0 ]
                              [ Ty.path "u8" ]
                          ],
                        "dangling",
                        []
                      |),
                      []
                    |)
                  |) in
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply (Ty.path "core::ptr::unique::Unique") [] [ Ty.path "str" ],
                      "new_unchecked",
                      []
                    |),
                    [
                      M.rust_cast
                        (M.call_closure (|
                          M.get_associated_function (|
                            Ty.apply
                              (Ty.path "core::ptr::unique::Unique")
                              []
                              [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                            "as_ptr",
                            []
                          |),
                          [ M.read (| bytes |) ]
                        |))
                    ]
                  |)
                |)
              |) in
            M.alloc (|
              Value.StructTuple
                "alloc::boxed::Box"
                [ M.read (| ptr |); Value.StructTuple "alloc::alloc::Global" [] ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::default::Default"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("default", InstanceField.Method default) ].
  End Impl_core_default_Default_for_alloc_boxed_Box_str_alloc_alloc_Global.
  
  Module Impl_core_clone_Clone_where_core_clone_Clone_T_where_core_alloc_Allocator_A_where_core_clone_Clone_A_for_alloc_boxed_Box_T_A.
    Definition Self (T A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::boxed::Box") [] [ T; A ].
    
    (*
        fn clone(&self) -> Self {
            // Pre-allocate memory to allow writing the cloned value directly.
            let mut boxed = Self::new_uninit_in(self.1.clone());
            unsafe {
                ( **self).clone_to_uninit(boxed.as_mut_ptr());
                boxed.assume_init()
            }
        }
    *)
    Definition clone (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            let~ boxed :=
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "alloc::boxed::Box") [] [ T; A ],
                    "new_uninit_in",
                    []
                  |),
                  [
                    M.call_closure (|
                      M.get_trait_method (| "core::clone::Clone", A, [], "clone", [] |),
                      [
                        M.SubPointer.get_struct_tuple_field (|
                          M.read (| self |),
                          "alloc::boxed::Box",
                          1
                        |)
                      ]
                    |)
                  ]
                |)
              |) in
            let~ _ :=
              M.alloc (|
                M.call_closure (|
                  M.get_trait_method (|
                    "core::clone::CloneToUninit",
                    T,
                    [],
                    "clone_to_uninit",
                    []
                  |),
                  [
                    M.read (| M.read (| self |) |);
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ],
                        "as_mut_ptr",
                        []
                      |),
                      [ M.read (| boxed |) ]
                    |)
                  ]
                |)
              |) in
            M.alloc (|
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "alloc::boxed::Box")
                    []
                    [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ]; A ],
                  "assume_init",
                  []
                |),
                [ M.read (| boxed |) ]
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    (*
        fn clone_from(&mut self, source: &Self) {
            ( **self).clone_from(&( **source));
        }
    *)
    Definition clone_from (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ self; source ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let source := M.alloc (| source |) in
          M.read (|
            let~ _ :=
              M.alloc (|
                M.call_closure (|
                  M.get_trait_method (| "core::clone::Clone", T, [], "clone_from", [] |),
                  [ M.read (| M.read (| self |) |); M.read (| M.read (| source |) |) ]
                |)
              |) in
            M.alloc (| Value.Tuple [] |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (T A : Ty.t),
      M.IsTraitInstance
        "core::clone::Clone"
        (Self T A)
        (* Trait polymorphic types *) []
        (* Instance *)
        [
          ("clone", InstanceField.Method (clone T A));
          ("clone_from", InstanceField.Method (clone_from T A))
        ].
  End Impl_core_clone_Clone_where_core_clone_Clone_T_where_core_alloc_Allocator_A_where_core_clone_Clone_A_for_alloc_boxed_Box_T_A.
  
  Module Impl_core_clone_Clone_for_alloc_boxed_Box_str_alloc_alloc_Global.
    Definition Self : Ty.t :=
      Ty.apply (Ty.path "alloc::boxed::Box") [] [ Ty.path "str"; Ty.path "alloc::alloc::Global" ].
    
    (*
        fn clone(&self) -> Self {
            // this makes a copy of the data
            let buf: Box<[u8]> = self.as_bytes().into();
            unsafe { from_boxed_utf8_unchecked(buf) }
        }
    *)
    Definition clone (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            let~ buf :=
              M.alloc (|
                M.call_closure (|
                  M.get_trait_method (|
                    "core::convert::Into",
                    Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                    [
                      Ty.apply
                        (Ty.path "alloc::boxed::Box")
                        []
                        [
                          Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ];
                          Ty.path "alloc::alloc::Global"
                        ]
                    ],
                    "into",
                    []
                  |),
                  [
                    M.call_closure (|
                      M.get_associated_function (| Ty.path "str", "as_bytes", [] |),
                      [ M.read (| M.read (| self |) |) ]
                    |)
                  ]
                |)
              |) in
            M.alloc (|
              M.call_closure (|
                M.get_function (| "alloc::str::from_boxed_utf8_unchecked", [], [] |),
                [ M.read (| buf |) ]
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::clone::Clone"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("clone", InstanceField.Method clone) ].
  End Impl_core_clone_Clone_for_alloc_boxed_Box_str_alloc_alloc_Global.
  
  Module Impl_core_cmp_PartialEq_where_core_marker_Sized_T_where_core_cmp_PartialEq_T_where_core_alloc_Allocator_A_for_alloc_boxed_Box_T_A.
    Definition Self (T A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::boxed::Box") [] [ T; A ].
    
    (*
        fn eq(&self, other: &Self) -> bool {
            PartialEq::eq(&**self, &**other)
        }
    *)
    Definition eq (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            M.get_trait_method (| "core::cmp::PartialEq", T, [ T ], "eq", [] |),
            [ M.read (| M.read (| self |) |); M.read (| M.read (| other |) |) ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    (*
        fn ne(&self, other: &Self) -> bool {
            PartialEq::ne(&**self, &**other)
        }
    *)
    Definition ne (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            M.get_trait_method (| "core::cmp::PartialEq", T, [ T ], "ne", [] |),
            [ M.read (| M.read (| self |) |); M.read (| M.read (| other |) |) ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (T A : Ty.t),
      M.IsTraitInstance
        "core::cmp::PartialEq"
        (Self T A)
        (* Trait polymorphic types *) []
        (* Instance *)
        [ ("eq", InstanceField.Method (eq T A)); ("ne", InstanceField.Method (ne T A)) ].
  End Impl_core_cmp_PartialEq_where_core_marker_Sized_T_where_core_cmp_PartialEq_T_where_core_alloc_Allocator_A_for_alloc_boxed_Box_T_A.
  
  Module Impl_core_cmp_PartialOrd_where_core_marker_Sized_T_where_core_cmp_PartialOrd_T_where_core_alloc_Allocator_A_for_alloc_boxed_Box_T_A.
    Definition Self (T A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::boxed::Box") [] [ T; A ].
    
    (*
        fn partial_cmp(&self, other: &Self) -> Option<Ordering> {
            PartialOrd::partial_cmp(&**self, &**other)
        }
    *)
    Definition partial_cmp (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            M.get_trait_method (| "core::cmp::PartialOrd", T, [ T ], "partial_cmp", [] |),
            [ M.read (| M.read (| self |) |); M.read (| M.read (| other |) |) ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    (*
        fn lt(&self, other: &Self) -> bool {
            PartialOrd::lt(&**self, &**other)
        }
    *)
    Definition lt (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            M.get_trait_method (| "core::cmp::PartialOrd", T, [ T ], "lt", [] |),
            [ M.read (| M.read (| self |) |); M.read (| M.read (| other |) |) ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    (*
        fn le(&self, other: &Self) -> bool {
            PartialOrd::le(&**self, &**other)
        }
    *)
    Definition le (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            M.get_trait_method (| "core::cmp::PartialOrd", T, [ T ], "le", [] |),
            [ M.read (| M.read (| self |) |); M.read (| M.read (| other |) |) ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    (*
        fn ge(&self, other: &Self) -> bool {
            PartialOrd::ge(&**self, &**other)
        }
    *)
    Definition ge (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            M.get_trait_method (| "core::cmp::PartialOrd", T, [ T ], "ge", [] |),
            [ M.read (| M.read (| self |) |); M.read (| M.read (| other |) |) ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    (*
        fn gt(&self, other: &Self) -> bool {
            PartialOrd::gt(&**self, &**other)
        }
    *)
    Definition gt (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            M.get_trait_method (| "core::cmp::PartialOrd", T, [ T ], "gt", [] |),
            [ M.read (| M.read (| self |) |); M.read (| M.read (| other |) |) ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (T A : Ty.t),
      M.IsTraitInstance
        "core::cmp::PartialOrd"
        (Self T A)
        (* Trait polymorphic types *) []
        (* Instance *)
        [
          ("partial_cmp", InstanceField.Method (partial_cmp T A));
          ("lt", InstanceField.Method (lt T A));
          ("le", InstanceField.Method (le T A));
          ("ge", InstanceField.Method (ge T A));
          ("gt", InstanceField.Method (gt T A))
        ].
  End Impl_core_cmp_PartialOrd_where_core_marker_Sized_T_where_core_cmp_PartialOrd_T_where_core_alloc_Allocator_A_for_alloc_boxed_Box_T_A.
  
  Module Impl_core_cmp_Ord_where_core_marker_Sized_T_where_core_cmp_Ord_T_where_core_alloc_Allocator_A_for_alloc_boxed_Box_T_A.
    Definition Self (T A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::boxed::Box") [] [ T; A ].
    
    (*
        fn cmp(&self, other: &Self) -> Ordering {
            Ord::cmp(&**self, &**other)
        }
    *)
    Definition cmp (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            M.get_trait_method (| "core::cmp::Ord", T, [], "cmp", [] |),
            [ M.read (| M.read (| self |) |); M.read (| M.read (| other |) |) ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (T A : Ty.t),
      M.IsTraitInstance
        "core::cmp::Ord"
        (Self T A)
        (* Trait polymorphic types *) []
        (* Instance *) [ ("cmp", InstanceField.Method (cmp T A)) ].
  End Impl_core_cmp_Ord_where_core_marker_Sized_T_where_core_cmp_Ord_T_where_core_alloc_Allocator_A_for_alloc_boxed_Box_T_A.
  
  Module Impl_core_cmp_Eq_where_core_marker_Sized_T_where_core_cmp_Eq_T_where_core_alloc_Allocator_A_for_alloc_boxed_Box_T_A.
    Definition Self (T A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::boxed::Box") [] [ T; A ].
    
    Axiom Implements :
      forall (T A : Ty.t),
      M.IsTraitInstance
        "core::cmp::Eq"
        (Self T A)
        (* Trait polymorphic types *) []
        (* Instance *) [].
  End Impl_core_cmp_Eq_where_core_marker_Sized_T_where_core_cmp_Eq_T_where_core_alloc_Allocator_A_for_alloc_boxed_Box_T_A.
  
  Module Impl_core_hash_Hash_where_core_marker_Sized_T_where_core_hash_Hash_T_where_core_alloc_Allocator_A_for_alloc_boxed_Box_T_A.
    Definition Self (T A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::boxed::Box") [] [ T; A ].
    
    (*
        fn hash<H: Hasher>(&self, state: &mut H) {
            ( **self).hash(state);
        }
    *)
    Definition hash (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [ H ], [ self; state ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let state := M.alloc (| state |) in
          M.read (|
            let~ _ :=
              M.alloc (|
                M.call_closure (|
                  M.get_trait_method (| "core::hash::Hash", T, [], "hash", [ H ] |),
                  [ M.read (| M.read (| self |) |); M.read (| state |) ]
                |)
              |) in
            M.alloc (| Value.Tuple [] |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (T A : Ty.t),
      M.IsTraitInstance
        "core::hash::Hash"
        (Self T A)
        (* Trait polymorphic types *) []
        (* Instance *) [ ("hash", InstanceField.Method (hash T A)) ].
  End Impl_core_hash_Hash_where_core_marker_Sized_T_where_core_hash_Hash_T_where_core_alloc_Allocator_A_for_alloc_boxed_Box_T_A.
  
  Module Impl_core_hash_Hasher_where_core_marker_Sized_T_where_core_hash_Hasher_T_where_core_alloc_Allocator_A_for_alloc_boxed_Box_T_A.
    Definition Self (T A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::boxed::Box") [] [ T; A ].
    
    (*
        fn finish(&self) -> u64 {
            ( **self).finish()
        }
    *)
    Definition finish (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_trait_method (| "core::hash::Hasher", T, [], "finish", [] |),
            [ M.read (| M.read (| self |) |) ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    (*
        fn write(&mut self, bytes: &[u8]) {
            ( **self).write(bytes)
        }
    *)
    Definition write (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ self; bytes ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let bytes := M.alloc (| bytes |) in
          M.call_closure (|
            M.get_trait_method (| "core::hash::Hasher", T, [], "write", [] |),
            [ M.read (| M.read (| self |) |); M.read (| bytes |) ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    (*
        fn write_u8(&mut self, i: u8) {
            ( **self).write_u8(i)
        }
    *)
    Definition write_u8 (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ self; i ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let i := M.alloc (| i |) in
          M.call_closure (|
            M.get_trait_method (| "core::hash::Hasher", T, [], "write_u8", [] |),
            [ M.read (| M.read (| self |) |); M.read (| i |) ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    (*
        fn write_u16(&mut self, i: u16) {
            ( **self).write_u16(i)
        }
    *)
    Definition write_u16 (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ self; i ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let i := M.alloc (| i |) in
          M.call_closure (|
            M.get_trait_method (| "core::hash::Hasher", T, [], "write_u16", [] |),
            [ M.read (| M.read (| self |) |); M.read (| i |) ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    (*
        fn write_u32(&mut self, i: u32) {
            ( **self).write_u32(i)
        }
    *)
    Definition write_u32 (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ self; i ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let i := M.alloc (| i |) in
          M.call_closure (|
            M.get_trait_method (| "core::hash::Hasher", T, [], "write_u32", [] |),
            [ M.read (| M.read (| self |) |); M.read (| i |) ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    (*
        fn write_u64(&mut self, i: u64) {
            ( **self).write_u64(i)
        }
    *)
    Definition write_u64 (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ self; i ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let i := M.alloc (| i |) in
          M.call_closure (|
            M.get_trait_method (| "core::hash::Hasher", T, [], "write_u64", [] |),
            [ M.read (| M.read (| self |) |); M.read (| i |) ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    (*
        fn write_u128(&mut self, i: u128) {
            ( **self).write_u128(i)
        }
    *)
    Definition write_u128 (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ self; i ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let i := M.alloc (| i |) in
          M.call_closure (|
            M.get_trait_method (| "core::hash::Hasher", T, [], "write_u128", [] |),
            [ M.read (| M.read (| self |) |); M.read (| i |) ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    (*
        fn write_usize(&mut self, i: usize) {
            ( **self).write_usize(i)
        }
    *)
    Definition write_usize (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ self; i ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let i := M.alloc (| i |) in
          M.call_closure (|
            M.get_trait_method (| "core::hash::Hasher", T, [], "write_usize", [] |),
            [ M.read (| M.read (| self |) |); M.read (| i |) ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    (*
        fn write_i8(&mut self, i: i8) {
            ( **self).write_i8(i)
        }
    *)
    Definition write_i8 (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ self; i ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let i := M.alloc (| i |) in
          M.call_closure (|
            M.get_trait_method (| "core::hash::Hasher", T, [], "write_i8", [] |),
            [ M.read (| M.read (| self |) |); M.read (| i |) ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    (*
        fn write_i16(&mut self, i: i16) {
            ( **self).write_i16(i)
        }
    *)
    Definition write_i16 (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ self; i ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let i := M.alloc (| i |) in
          M.call_closure (|
            M.get_trait_method (| "core::hash::Hasher", T, [], "write_i16", [] |),
            [ M.read (| M.read (| self |) |); M.read (| i |) ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    (*
        fn write_i32(&mut self, i: i32) {
            ( **self).write_i32(i)
        }
    *)
    Definition write_i32 (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ self; i ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let i := M.alloc (| i |) in
          M.call_closure (|
            M.get_trait_method (| "core::hash::Hasher", T, [], "write_i32", [] |),
            [ M.read (| M.read (| self |) |); M.read (| i |) ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    (*
        fn write_i64(&mut self, i: i64) {
            ( **self).write_i64(i)
        }
    *)
    Definition write_i64 (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ self; i ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let i := M.alloc (| i |) in
          M.call_closure (|
            M.get_trait_method (| "core::hash::Hasher", T, [], "write_i64", [] |),
            [ M.read (| M.read (| self |) |); M.read (| i |) ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    (*
        fn write_i128(&mut self, i: i128) {
            ( **self).write_i128(i)
        }
    *)
    Definition write_i128 (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ self; i ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let i := M.alloc (| i |) in
          M.call_closure (|
            M.get_trait_method (| "core::hash::Hasher", T, [], "write_i128", [] |),
            [ M.read (| M.read (| self |) |); M.read (| i |) ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    (*
        fn write_isize(&mut self, i: isize) {
            ( **self).write_isize(i)
        }
    *)
    Definition write_isize (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ self; i ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let i := M.alloc (| i |) in
          M.call_closure (|
            M.get_trait_method (| "core::hash::Hasher", T, [], "write_isize", [] |),
            [ M.read (| M.read (| self |) |); M.read (| i |) ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    (*
        fn write_length_prefix(&mut self, len: usize) {
            ( **self).write_length_prefix(len)
        }
    *)
    Definition write_length_prefix
        (T A : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ self; len ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let len := M.alloc (| len |) in
          M.call_closure (|
            M.get_trait_method (| "core::hash::Hasher", T, [], "write_length_prefix", [] |),
            [ M.read (| M.read (| self |) |); M.read (| len |) ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    (*
        fn write_str(&mut self, s: &str) {
            ( **self).write_str(s)
        }
    *)
    Definition write_str (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ self; s ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let s := M.alloc (| s |) in
          M.call_closure (|
            M.get_trait_method (| "core::hash::Hasher", T, [], "write_str", [] |),
            [ M.read (| M.read (| self |) |); M.read (| s |) ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (T A : Ty.t),
      M.IsTraitInstance
        "core::hash::Hasher"
        (Self T A)
        (* Trait polymorphic types *) []
        (* Instance *)
        [
          ("finish", InstanceField.Method (finish T A));
          ("write", InstanceField.Method (write T A));
          ("write_u8", InstanceField.Method (write_u8 T A));
          ("write_u16", InstanceField.Method (write_u16 T A));
          ("write_u32", InstanceField.Method (write_u32 T A));
          ("write_u64", InstanceField.Method (write_u64 T A));
          ("write_u128", InstanceField.Method (write_u128 T A));
          ("write_usize", InstanceField.Method (write_usize T A));
          ("write_i8", InstanceField.Method (write_i8 T A));
          ("write_i16", InstanceField.Method (write_i16 T A));
          ("write_i32", InstanceField.Method (write_i32 T A));
          ("write_i64", InstanceField.Method (write_i64 T A));
          ("write_i128", InstanceField.Method (write_i128 T A));
          ("write_isize", InstanceField.Method (write_isize T A));
          ("write_length_prefix", InstanceField.Method (write_length_prefix T A));
          ("write_str", InstanceField.Method (write_str T A))
        ].
  End Impl_core_hash_Hasher_where_core_marker_Sized_T_where_core_hash_Hasher_T_where_core_alloc_Allocator_A_for_alloc_boxed_Box_T_A.
  
  Module Impl_core_convert_From_T_for_alloc_boxed_Box_T_alloc_alloc_Global.
    Definition Self (T : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "alloc::boxed::Box") [] [ T; Ty.path "alloc::alloc::Global" ].
    
    (*
        fn from(t: T) -> Self {
            Box::new(t)
        }
    *)
    Definition from (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [], [ t ] =>
        ltac:(M.monadic
          (let t := M.alloc (| t |) in
          M.call_closure (|
            M.get_associated_function (|
              Ty.apply (Ty.path "alloc::boxed::Box") [] [ T; Ty.path "alloc::alloc::Global" ],
              "new",
              []
            |),
            [ M.read (| t |) ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "core::convert::From"
        (Self T)
        (* Trait polymorphic types *) [ (* T *) T ]
        (* Instance *) [ ("from", InstanceField.Method (from T)) ].
  End Impl_core_convert_From_T_for_alloc_boxed_Box_T_alloc_alloc_Global.
  
  Module Impl_core_convert_From_where_core_marker_Sized_T_where_core_alloc_Allocator_A_alloc_boxed_Box_T_A_for_core_pin_Pin_alloc_boxed_Box_T_A.
    Definition Self (T A : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "core::pin::Pin") [] [ Ty.apply (Ty.path "alloc::boxed::Box") [] [ T; A ] ].
    
    (*
        fn from(boxed: Box<T, A>) -> Self {
            Box::into_pin(boxed)
        }
    *)
    Definition from (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ boxed ] =>
        ltac:(M.monadic
          (let boxed := M.alloc (| boxed |) in
          M.call_closure (|
            M.get_associated_function (|
              Ty.apply (Ty.path "alloc::boxed::Box") [] [ T; A ],
              "into_pin",
              []
            |),
            [ M.read (| boxed |) ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (T A : Ty.t),
      M.IsTraitInstance
        "core::convert::From"
        (Self T A)
        (* Trait polymorphic types *) [ (* T *) Ty.apply (Ty.path "alloc::boxed::Box") [] [ T; A ] ]
        (* Instance *) [ ("from", InstanceField.Method (from T A)) ].
  End Impl_core_convert_From_where_core_marker_Sized_T_where_core_alloc_Allocator_A_alloc_boxed_Box_T_A_for_core_pin_Pin_alloc_boxed_Box_T_A.
  
  (* Trait *)
  (* Empty module 'BoxFromSlice' *)
  
  Module Impl_alloc_boxed_BoxFromSlice_where_core_clone_Clone_T_T_for_alloc_boxed_Box_slice_T_alloc_alloc_Global.
    Definition Self (T : Ty.t) : Ty.t :=
      Ty.apply
        (Ty.path "alloc::boxed::Box")
        []
        [ Ty.apply (Ty.path "slice") [] [ T ]; Ty.path "alloc::alloc::Global" ].
    
    (*
        default fn from_slice(slice: &[T]) -> Self {
            slice.to_vec().into_boxed_slice()
        }
    *)
    Definition from_slice (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [], [ slice ] =>
        ltac:(M.monadic
          (let slice := M.alloc (| slice |) in
          M.call_closure (|
            M.get_associated_function (|
              Ty.apply (Ty.path "alloc::vec::Vec") [] [ T; Ty.path "alloc::alloc::Global" ],
              "into_boxed_slice",
              []
            |),
            [
              M.call_closure (|
                M.get_associated_function (| Ty.apply (Ty.path "slice") [] [ T ], "to_vec", [] |),
                [ M.read (| slice |) ]
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "alloc::boxed::BoxFromSlice"
        (Self T)
        (* Trait polymorphic types *) [ (* T *) T ]
        (* Instance *) [ ("from_slice", InstanceField.Method (from_slice T)) ].
  End Impl_alloc_boxed_BoxFromSlice_where_core_clone_Clone_T_T_for_alloc_boxed_Box_slice_T_alloc_alloc_Global.
  
  Module Impl_alloc_boxed_BoxFromSlice_where_core_marker_Copy_T_T_for_alloc_boxed_Box_slice_T_alloc_alloc_Global.
    Definition Self (T : Ty.t) : Ty.t :=
      Ty.apply
        (Ty.path "alloc::boxed::Box")
        []
        [ Ty.apply (Ty.path "slice") [] [ T ]; Ty.path "alloc::alloc::Global" ].
    
    (*
        fn from_slice(slice: &[T]) -> Self {
            let len = slice.len();
            let buf = RawVec::with_capacity(len);
            unsafe {
                ptr::copy_nonoverlapping(slice.as_ptr(), buf.ptr(), len);
                buf.into_box(slice.len()).assume_init()
            }
        }
    *)
    Definition from_slice (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [], [ slice ] =>
        ltac:(M.monadic
          (let slice := M.alloc (| slice |) in
          M.read (|
            let~ len :=
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.apply (Ty.path "slice") [] [ T ], "len", [] |),
                  [ M.read (| slice |) ]
                |)
              |) in
            let~ buf :=
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "alloc::raw_vec::RawVec")
                      []
                      [ T; Ty.path "alloc::alloc::Global" ],
                    "with_capacity",
                    []
                  |),
                  [ M.read (| len |) ]
                |)
              |) in
            let~ _ :=
              M.alloc (|
                M.call_closure (|
                  M.get_function (| "core::intrinsics::copy_nonoverlapping", [], [ T ] |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "slice") [] [ T ],
                        "as_ptr",
                        []
                      |),
                      [ M.read (| slice |) ]
                    |);
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "alloc::raw_vec::RawVec")
                          []
                          [ T; Ty.path "alloc::alloc::Global" ],
                        "ptr",
                        []
                      |),
                      [ buf ]
                    |);
                    M.read (| len |)
                  ]
                |)
              |) in
            M.alloc (|
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "alloc::boxed::Box")
                    []
                    [
                      Ty.apply
                        (Ty.path "slice")
                        []
                        [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ] ];
                      Ty.path "alloc::alloc::Global"
                    ],
                  "assume_init",
                  []
                |),
                [
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "alloc::raw_vec::RawVec")
                        []
                        [ T; Ty.path "alloc::alloc::Global" ],
                      "into_box",
                      []
                    |),
                    [
                      M.read (| buf |);
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "slice") [] [ T ],
                          "len",
                          []
                        |),
                        [ M.read (| slice |) ]
                      |)
                    ]
                  |)
                ]
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "alloc::boxed::BoxFromSlice"
        (Self T)
        (* Trait polymorphic types *) [ (* T *) T ]
        (* Instance *) [ ("from_slice", InstanceField.Method (from_slice T)) ].
  End Impl_alloc_boxed_BoxFromSlice_where_core_marker_Copy_T_T_for_alloc_boxed_Box_slice_T_alloc_alloc_Global.
  
  Module Impl_core_convert_From_where_core_clone_Clone_T_ref__slice_T_for_alloc_boxed_Box_slice_T_alloc_alloc_Global.
    Definition Self (T : Ty.t) : Ty.t :=
      Ty.apply
        (Ty.path "alloc::boxed::Box")
        []
        [ Ty.apply (Ty.path "slice") [] [ T ]; Ty.path "alloc::alloc::Global" ].
    
    (*
        fn from(slice: &[T]) -> Box<[T]> {
            <Self as BoxFromSlice<T>>::from_slice(slice)
        }
    *)
    Definition from (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [], [ slice ] =>
        ltac:(M.monadic
          (let slice := M.alloc (| slice |) in
          M.call_closure (|
            M.get_trait_method (|
              "alloc::boxed::BoxFromSlice",
              Ty.apply
                (Ty.path "alloc::boxed::Box")
                []
                [ Ty.apply (Ty.path "slice") [] [ T ]; Ty.path "alloc::alloc::Global" ],
              [ T ],
              "from_slice",
              []
            |),
            [ M.read (| slice |) ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "core::convert::From"
        (Self T)
        (* Trait polymorphic types *)
        [ (* T *) Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ T ] ] ]
        (* Instance *) [ ("from", InstanceField.Method (from T)) ].
  End Impl_core_convert_From_where_core_clone_Clone_T_ref__slice_T_for_alloc_boxed_Box_slice_T_alloc_alloc_Global.
  
  Module Impl_core_convert_From_where_core_clone_Clone_T_alloc_borrow_Cow_slice_T_for_alloc_boxed_Box_slice_T_alloc_alloc_Global.
    Definition Self (T : Ty.t) : Ty.t :=
      Ty.apply
        (Ty.path "alloc::boxed::Box")
        []
        [ Ty.apply (Ty.path "slice") [] [ T ]; Ty.path "alloc::alloc::Global" ].
    
    (*
        fn from(cow: Cow<'_, [T]>) -> Box<[T]> {
            match cow {
                Cow::Borrowed(slice) => Box::from(slice),
                Cow::Owned(slice) => Box::from(slice),
            }
        }
    *)
    Definition from (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [], [ cow ] =>
        ltac:(M.monadic
          (let cow := M.alloc (| cow |) in
          M.read (|
            M.match_operator (|
              cow,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "alloc::borrow::Cow::Borrowed",
                        0
                      |) in
                    let slice := M.copy (| γ0_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_trait_method (|
                          "core::convert::From",
                          Ty.apply
                            (Ty.path "alloc::boxed::Box")
                            []
                            [ Ty.apply (Ty.path "slice") [] [ T ]; Ty.path "alloc::alloc::Global" ],
                          [ Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ T ] ] ],
                          "from",
                          []
                        |),
                        [ M.read (| slice |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 :=
                      M.SubPointer.get_struct_tuple_field (| γ, "alloc::borrow::Cow::Owned", 0 |) in
                    let slice := M.copy (| γ0_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_trait_method (|
                          "core::convert::From",
                          Ty.apply
                            (Ty.path "alloc::boxed::Box")
                            []
                            [ Ty.apply (Ty.path "slice") [] [ T ]; Ty.path "alloc::alloc::Global" ],
                          [
                            Ty.apply
                              (Ty.path "alloc::vec::Vec")
                              []
                              [ T; Ty.path "alloc::alloc::Global" ]
                          ],
                          "from",
                          []
                        |),
                        [ M.read (| slice |) ]
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "core::convert::From"
        (Self T)
        (* Trait polymorphic types *)
        [ (* T *) Ty.apply (Ty.path "alloc::borrow::Cow") [] [ Ty.apply (Ty.path "slice") [] [ T ] ]
        ]
        (* Instance *) [ ("from", InstanceField.Method (from T)) ].
  End Impl_core_convert_From_where_core_clone_Clone_T_alloc_borrow_Cow_slice_T_for_alloc_boxed_Box_slice_T_alloc_alloc_Global.
  
  Module Impl_core_convert_From_ref__str_for_alloc_boxed_Box_str_alloc_alloc_Global.
    Definition Self : Ty.t :=
      Ty.apply (Ty.path "alloc::boxed::Box") [] [ Ty.path "str"; Ty.path "alloc::alloc::Global" ].
    
    (*
        fn from(s: &str) -> Box<str> {
            unsafe { from_boxed_utf8_unchecked(Box::from(s.as_bytes())) }
        }
    *)
    Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ s ] =>
        ltac:(M.monadic
          (let s := M.alloc (| s |) in
          M.call_closure (|
            M.get_function (| "alloc::str::from_boxed_utf8_unchecked", [], [] |),
            [
              M.call_closure (|
                M.get_trait_method (|
                  "core::convert::From",
                  Ty.apply
                    (Ty.path "alloc::boxed::Box")
                    []
                    [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ]; Ty.path "alloc::alloc::Global"
                    ],
                  [ Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ] ],
                  "from",
                  []
                |),
                [
                  M.call_closure (|
                    M.get_associated_function (| Ty.path "str", "as_bytes", [] |),
                    [ M.read (| s |) ]
                  |)
                ]
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::convert::From"
        Self
        (* Trait polymorphic types *) [ (* T *) Ty.apply (Ty.path "&") [] [ Ty.path "str" ] ]
        (* Instance *) [ ("from", InstanceField.Method from) ].
  End Impl_core_convert_From_ref__str_for_alloc_boxed_Box_str_alloc_alloc_Global.
  
  Module Impl_core_convert_From_alloc_borrow_Cow_str_for_alloc_boxed_Box_str_alloc_alloc_Global.
    Definition Self : Ty.t :=
      Ty.apply (Ty.path "alloc::boxed::Box") [] [ Ty.path "str"; Ty.path "alloc::alloc::Global" ].
    
    (*
        fn from(cow: Cow<'_, str>) -> Box<str> {
            match cow {
                Cow::Borrowed(s) => Box::from(s),
                Cow::Owned(s) => Box::from(s),
            }
        }
    *)
    Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ cow ] =>
        ltac:(M.monadic
          (let cow := M.alloc (| cow |) in
          M.read (|
            M.match_operator (|
              cow,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "alloc::borrow::Cow::Borrowed",
                        0
                      |) in
                    let s := M.copy (| γ0_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_trait_method (|
                          "core::convert::From",
                          Ty.apply
                            (Ty.path "alloc::boxed::Box")
                            []
                            [ Ty.path "str"; Ty.path "alloc::alloc::Global" ],
                          [ Ty.apply (Ty.path "&") [] [ Ty.path "str" ] ],
                          "from",
                          []
                        |),
                        [ M.read (| s |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 :=
                      M.SubPointer.get_struct_tuple_field (| γ, "alloc::borrow::Cow::Owned", 0 |) in
                    let s := M.copy (| γ0_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_trait_method (|
                          "core::convert::From",
                          Ty.apply
                            (Ty.path "alloc::boxed::Box")
                            []
                            [ Ty.path "str"; Ty.path "alloc::alloc::Global" ],
                          [ Ty.path "alloc::string::String" ],
                          "from",
                          []
                        |),
                        [ M.read (| s |) ]
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::convert::From"
        Self
        (* Trait polymorphic types *)
        [ (* T *) Ty.apply (Ty.path "alloc::borrow::Cow") [] [ Ty.path "str" ] ]
        (* Instance *) [ ("from", InstanceField.Method from) ].
  End Impl_core_convert_From_alloc_borrow_Cow_str_for_alloc_boxed_Box_str_alloc_alloc_Global.
  
  Module Impl_core_convert_From_where_core_alloc_Allocator_A_alloc_boxed_Box_str_A_for_alloc_boxed_Box_slice_u8_A.
    Definition Self (A : Ty.t) : Ty.t :=
      Ty.apply
        (Ty.path "alloc::boxed::Box")
        []
        [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ]; A ].
    
    (*
        fn from(s: Box<str, A>) -> Self {
            let (raw, alloc) = Box::into_raw_with_allocator(s);
            unsafe { Box::from_raw_in(raw as *mut [u8], alloc) }
        }
    *)
    Definition from (A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self A in
      match ε, τ, α with
      | [], [], [ s ] =>
        ltac:(M.monadic
          (let s := M.alloc (| s |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "alloc::boxed::Box") [] [ Ty.path "str"; A ],
                    "into_raw_with_allocator",
                    []
                  |),
                  [ M.read (| s |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let raw := M.copy (| γ0_0 |) in
                    let alloc := M.copy (| γ0_1 |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply
                            (Ty.path "alloc::boxed::Box")
                            []
                            [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ]; A ],
                          "from_raw_in",
                          []
                        |),
                        [ M.rust_cast (M.read (| raw |)); M.read (| alloc |) ]
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (A : Ty.t),
      M.IsTraitInstance
        "core::convert::From"
        (Self A)
        (* Trait polymorphic types *)
        [ (* T *) Ty.apply (Ty.path "alloc::boxed::Box") [] [ Ty.path "str"; A ] ]
        (* Instance *) [ ("from", InstanceField.Method (from A)) ].
  End Impl_core_convert_From_where_core_alloc_Allocator_A_alloc_boxed_Box_str_A_for_alloc_boxed_Box_slice_u8_A.
  
  Module Impl_core_convert_From_array_N_T_for_alloc_boxed_Box_slice_T_alloc_alloc_Global.
    Definition Self (N : Value.t) (T : Ty.t) : Ty.t :=
      Ty.apply
        (Ty.path "alloc::boxed::Box")
        []
        [ Ty.apply (Ty.path "slice") [] [ T ]; Ty.path "alloc::alloc::Global" ].
    
    (*
        fn from(array: [T; N]) -> Box<[T]> {
            Box::new(array)
        }
    *)
    Definition from
        (N : Value.t)
        (T : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self N T in
      match ε, τ, α with
      | [], [], [ array ] =>
        ltac:(M.monadic
          (let array := M.alloc (| array |) in
          M.call_closure (|
            M.get_associated_function (|
              Ty.apply
                (Ty.path "alloc::boxed::Box")
                []
                [ Ty.apply (Ty.path "array") [ N ] [ T ]; Ty.path "alloc::alloc::Global" ],
              "new",
              []
            |),
            [ M.read (| array |) ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (N : Value.t) (T : Ty.t),
      M.IsTraitInstance
        "core::convert::From"
        (Self N T)
        (* Trait polymorphic types *) [ (* T *) Ty.apply (Ty.path "array") [ N ] [ T ] ]
        (* Instance *) [ ("from", InstanceField.Method (from N T)) ].
  End Impl_core_convert_From_array_N_T_for_alloc_boxed_Box_slice_T_alloc_alloc_Global.
  
  (*
  unsafe fn boxed_slice_as_array_unchecked<T, A: Allocator, const N: usize>(
      boxed_slice: Box<[T], A>,
  ) -> Box<[T; N], A> {
      debug_assert_eq!(boxed_slice.len(), N);
  
      let (ptr, alloc) = Box::into_raw_with_allocator(boxed_slice);
      // SAFETY: Pointer and allocator came from an existing box,
      // and our safety condition requires that the length is exactly `N`
      unsafe { Box::from_raw_in(ptr as *mut [T; N], alloc) }
  }
  *)
  Definition boxed_slice_as_array_unchecked
      (ε : list Value.t)
      (τ : list Ty.t)
      (α : list Value.t)
      : M :=
    match ε, τ, α with
    | [ N ], [ T; A ], [ boxed_slice ] =>
      ltac:(M.monadic
        (let boxed_slice := M.alloc (| boxed_slice |) in
        M.read (|
          let~ _ :=
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.use (M.alloc (| Value.Bool true |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    let~ _ :=
                      M.match_operator (|
                        M.alloc (|
                          Value.Tuple
                            [
                              M.alloc (|
                                M.call_closure (|
                                  M.get_associated_function (|
                                    Ty.apply (Ty.path "slice") [] [ T ],
                                    "len",
                                    []
                                  |),
                                  [ M.read (| boxed_slice |) ]
                                |)
                              |);
                              M.get_constant (| "alloc::boxed::boxed_slice_as_array_unchecked::N" |)
                            ]
                        |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                              let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                              let left_val := M.copy (| γ0_0 |) in
                              let right_val := M.copy (| γ0_1 |) in
                              M.match_operator (|
                                M.alloc (| Value.Tuple [] |),
                                [
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let γ :=
                                        M.use
                                          (M.alloc (|
                                            UnOp.not (|
                                              BinOp.eq (|
                                                M.read (| M.read (| left_val |) |),
                                                M.read (| M.read (| right_val |) |)
                                              |)
                                            |)
                                          |)) in
                                      let _ :=
                                        M.is_constant_or_break_match (|
                                          M.read (| γ |),
                                          Value.Bool true
                                        |) in
                                      M.alloc (|
                                        M.never_to_any (|
                                          M.read (|
                                            let~ kind :=
                                              M.alloc (|
                                                Value.StructTuple
                                                  "core::panicking::AssertKind::Eq"
                                                  []
                                              |) in
                                            M.alloc (|
                                              M.call_closure (|
                                                M.get_function (|
                                                  "core::panicking::assert_failed",
                                                  [],
                                                  [ Ty.path "usize"; Ty.path "usize" ]
                                                |),
                                                [
                                                  M.read (| kind |);
                                                  M.read (| left_val |);
                                                  M.read (| right_val |);
                                                  Value.StructTuple "core::option::Option::None" []
                                                ]
                                              |)
                                            |)
                                          |)
                                        |)
                                      |)));
                                  fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                                ]
                              |)))
                        ]
                      |) in
                    M.alloc (| Value.Tuple [] |)));
                fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
              ]
            |) in
          M.match_operator (|
            M.alloc (|
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "alloc::boxed::Box")
                    []
                    [ Ty.apply (Ty.path "slice") [] [ T ]; A ],
                  "into_raw_with_allocator",
                  []
                |),
                [ M.read (| boxed_slice |) ]
              |)
            |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                  let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                  let ptr := M.copy (| γ0_0 |) in
                  let alloc := M.copy (| γ0_1 |) in
                  M.alloc (|
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "alloc::boxed::Box")
                          []
                          [ Ty.apply (Ty.path "array") [ N ] [ T ]; A ],
                        "from_raw_in",
                        []
                      |),
                      [ M.rust_cast (M.read (| ptr |)); M.read (| alloc |) ]
                    |)
                  |)))
            ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Axiom Function_boxed_slice_as_array_unchecked :
    M.IsFunction "alloc::boxed::boxed_slice_as_array_unchecked" boxed_slice_as_array_unchecked.
  
  Module Impl_core_convert_TryFrom_alloc_boxed_Box_slice_T_alloc_alloc_Global_for_alloc_boxed_Box_array_N_T_alloc_alloc_Global.
    Definition Self (N : Value.t) (T : Ty.t) : Ty.t :=
      Ty.apply
        (Ty.path "alloc::boxed::Box")
        []
        [ Ty.apply (Ty.path "array") [ N ] [ T ]; Ty.path "alloc::alloc::Global" ].
    
    (*     type Error = Box<[T]>; *)
    Definition _Error (N : Value.t) (T : Ty.t) : Ty.t :=
      Ty.apply
        (Ty.path "alloc::boxed::Box")
        []
        [ Ty.apply (Ty.path "slice") [] [ T ]; Ty.path "alloc::alloc::Global" ].
    
    (*
        fn try_from(boxed_slice: Box<[T]>) -> Result<Self, Self::Error> {
            if boxed_slice.len() == N {
                Ok(unsafe { boxed_slice_as_array_unchecked(boxed_slice) })
            } else {
                Err(boxed_slice)
            }
        }
    *)
    Definition try_from
        (N : Value.t)
        (T : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self N T in
      match ε, τ, α with
      | [], [], [ boxed_slice ] =>
        ltac:(M.monadic
          (let boxed_slice := M.alloc (| boxed_slice |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          BinOp.eq (|
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply (Ty.path "slice") [] [ T ],
                                "len",
                                []
                              |),
                              [ M.read (| boxed_slice |) ]
                            |),
                            M.read (| M.get_constant (| "alloc::boxed::N" |) |)
                          |)
                        |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          M.call_closure (|
                            M.get_function (|
                              "alloc::boxed::boxed_slice_as_array_unchecked",
                              [ N ],
                              [ T; Ty.path "alloc::alloc::Global" ]
                            |),
                            [ M.read (| boxed_slice |) ]
                          |)
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      Value.StructTuple "core::result::Result::Err" [ M.read (| boxed_slice |) ]
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (N : Value.t) (T : Ty.t),
      M.IsTraitInstance
        "core::convert::TryFrom"
        (Self N T)
        (* Trait polymorphic types *)
        [
          (* T *)
          Ty.apply
            (Ty.path "alloc::boxed::Box")
            []
            [ Ty.apply (Ty.path "slice") [] [ T ]; Ty.path "alloc::alloc::Global" ]
        ]
        (* Instance *)
        [
          ("Error", InstanceField.Ty (_Error N T));
          ("try_from", InstanceField.Method (try_from N T))
        ].
  End Impl_core_convert_TryFrom_alloc_boxed_Box_slice_T_alloc_alloc_Global_for_alloc_boxed_Box_array_N_T_alloc_alloc_Global.
  
  Module Impl_core_convert_TryFrom_alloc_vec_Vec_T_alloc_alloc_Global_for_alloc_boxed_Box_array_N_T_alloc_alloc_Global.
    Definition Self (N : Value.t) (T : Ty.t) : Ty.t :=
      Ty.apply
        (Ty.path "alloc::boxed::Box")
        []
        [ Ty.apply (Ty.path "array") [ N ] [ T ]; Ty.path "alloc::alloc::Global" ].
    
    (*     type Error = Vec<T>; *)
    Definition _Error (N : Value.t) (T : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "alloc::vec::Vec") [] [ T; Ty.path "alloc::alloc::Global" ].
    
    (*
        fn try_from(vec: Vec<T>) -> Result<Self, Self::Error> {
            if vec.len() == N {
                let boxed_slice = vec.into_boxed_slice();
                Ok(unsafe { boxed_slice_as_array_unchecked(boxed_slice) })
            } else {
                Err(vec)
            }
        }
    *)
    Definition try_from
        (N : Value.t)
        (T : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self N T in
      match ε, τ, α with
      | [], [], [ vec ] =>
        ltac:(M.monadic
          (let vec := M.alloc (| vec |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          BinOp.eq (|
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "alloc::vec::Vec")
                                  []
                                  [ T; Ty.path "alloc::alloc::Global" ],
                                "len",
                                []
                              |),
                              [ vec ]
                            |),
                            M.read (| M.get_constant (| "alloc::boxed::N" |) |)
                          |)
                        |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    let~ boxed_slice :=
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.apply
                              (Ty.path "alloc::vec::Vec")
                              []
                              [ T; Ty.path "alloc::alloc::Global" ],
                            "into_boxed_slice",
                            []
                          |),
                          [ M.read (| vec |) ]
                        |)
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          M.call_closure (|
                            M.get_function (|
                              "alloc::boxed::boxed_slice_as_array_unchecked",
                              [ N ],
                              [ T; Ty.path "alloc::alloc::Global" ]
                            |),
                            [ M.read (| boxed_slice |) ]
                          |)
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      Value.StructTuple "core::result::Result::Err" [ M.read (| vec |) ]
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (N : Value.t) (T : Ty.t),
      M.IsTraitInstance
        "core::convert::TryFrom"
        (Self N T)
        (* Trait polymorphic types *)
        [ (* T *) Ty.apply (Ty.path "alloc::vec::Vec") [] [ T; Ty.path "alloc::alloc::Global" ] ]
        (* Instance *)
        [
          ("Error", InstanceField.Ty (_Error N T));
          ("try_from", InstanceField.Method (try_from N T))
        ].
  End Impl_core_convert_TryFrom_alloc_vec_Vec_T_alloc_alloc_Global_for_alloc_boxed_Box_array_N_T_alloc_alloc_Global.
  
  Module Impl_alloc_boxed_Box_Dyn_core_any_Any_Trait_A.
    Definition Self (A : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "alloc::boxed::Box") [] [ Ty.dyn [ ("core::any::Any::Trait", []) ]; A ].
    
    (*
        pub fn downcast<T: Any>(self) -> Result<Box<T, A>, Self> {
            if self.is::<T>() { unsafe { Ok(self.downcast_unchecked::<T>()) } } else { Err(self) }
        }
    *)
    Definition downcast (A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self A in
      match ε, τ, α with
      | [], [ T ], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.dyn [ ("core::any::Any::Trait", []) ],
                              "is",
                              [ T ]
                            |),
                            [ M.read (| self |) ]
                          |)
                        |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply
                                (Ty.path "alloc::boxed::Box")
                                []
                                [ Ty.dyn [ ("core::any::Any::Trait", []) ]; A ],
                              "downcast_unchecked",
                              [ T ]
                            |),
                            [ M.read (| self |) ]
                          |)
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      Value.StructTuple "core::result::Result::Err" [ M.read (| self |) ]
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom AssociatedFunction_downcast :
      forall (A : Ty.t),
      M.IsAssociatedFunction (Self A) "downcast" (downcast A).
    
    (*
        pub unsafe fn downcast_unchecked<T: Any>(self) -> Box<T, A> {
            debug_assert!(self.is::<T>());
            unsafe {
                let (raw, alloc): ( *mut dyn Any, _) = Box::into_raw_with_allocator(self);
                Box::from_raw_in(raw as *mut T, alloc)
            }
        }
    *)
    Definition downcast_unchecked
        (A : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self A in
      match ε, τ, α with
      | [], [ T ], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            let~ _ :=
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.use (M.alloc (| Value.Bool true |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      let~ _ :=
                        M.match_operator (|
                          M.alloc (| Value.Tuple [] |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ :=
                                  M.use
                                    (M.alloc (|
                                      UnOp.not (|
                                        M.call_closure (|
                                          M.get_associated_function (|
                                            Ty.dyn [ ("core::any::Any::Trait", []) ],
                                            "is",
                                            [ T ]
                                          |),
                                          [ M.read (| self |) ]
                                        |)
                                      |)
                                    |)) in
                                let _ :=
                                  M.is_constant_or_break_match (|
                                    M.read (| γ |),
                                    Value.Bool true
                                  |) in
                                M.alloc (|
                                  M.never_to_any (|
                                    M.call_closure (|
                                      M.get_function (| "core::panicking::panic", [], [] |),
                                      [ M.read (| Value.String "assertion failed: self.is::<T>()" |)
                                      ]
                                    |)
                                  |)
                                |)));
                            fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                          ]
                        |) in
                      M.alloc (| Value.Tuple [] |)));
                  fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                ]
              |) in
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "alloc::boxed::Box")
                      []
                      [ Ty.dyn [ ("core::any::Any::Trait", []) ]; A ],
                    "into_raw_with_allocator",
                    []
                  |),
                  [ M.read (| self |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let raw := M.copy (| γ0_0 |) in
                    let alloc := M.copy (| γ0_1 |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "alloc::boxed::Box") [] [ T; A ],
                          "from_raw_in",
                          []
                        |),
                        [ M.rust_cast (M.read (| raw |)); M.read (| alloc |) ]
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom AssociatedFunction_downcast_unchecked :
      forall (A : Ty.t),
      M.IsAssociatedFunction (Self A) "downcast_unchecked" (downcast_unchecked A).
  End Impl_alloc_boxed_Box_Dyn_core_any_Any_Trait_A.
  
  Module Impl_alloc_boxed_Box_Dyn_core_any_Any_Trait_core_marker_Send_AutoTrait_A.
    Definition Self (A : Ty.t) : Ty.t :=
      Ty.apply
        (Ty.path "alloc::boxed::Box")
        []
        [ Ty.dyn [ ("core::any::Any::Trait", []); ("core::marker::Send::AutoTrait", []) ]; A ].
    
    (*
        pub fn downcast<T: Any>(self) -> Result<Box<T, A>, Self> {
            if self.is::<T>() { unsafe { Ok(self.downcast_unchecked::<T>()) } } else { Err(self) }
        }
    *)
    Definition downcast (A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self A in
      match ε, τ, α with
      | [], [ T ], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.dyn
                                [
                                  ("core::any::Any::Trait", []);
                                  ("core::marker::Send::AutoTrait", [])
                                ],
                              "is",
                              [ T ]
                            |),
                            [ M.read (| self |) ]
                          |)
                        |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply
                                (Ty.path "alloc::boxed::Box")
                                []
                                [
                                  Ty.dyn
                                    [
                                      ("core::any::Any::Trait", []);
                                      ("core::marker::Send::AutoTrait", [])
                                    ];
                                  A
                                ],
                              "downcast_unchecked",
                              [ T ]
                            |),
                            [ M.read (| self |) ]
                          |)
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      Value.StructTuple "core::result::Result::Err" [ M.read (| self |) ]
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom AssociatedFunction_downcast :
      forall (A : Ty.t),
      M.IsAssociatedFunction (Self A) "downcast" (downcast A).
    
    (*
        pub unsafe fn downcast_unchecked<T: Any>(self) -> Box<T, A> {
            debug_assert!(self.is::<T>());
            unsafe {
                let (raw, alloc): ( *mut (dyn Any + Send), _) = Box::into_raw_with_allocator(self);
                Box::from_raw_in(raw as *mut T, alloc)
            }
        }
    *)
    Definition downcast_unchecked
        (A : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self A in
      match ε, τ, α with
      | [], [ T ], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            let~ _ :=
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.use (M.alloc (| Value.Bool true |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      let~ _ :=
                        M.match_operator (|
                          M.alloc (| Value.Tuple [] |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ :=
                                  M.use
                                    (M.alloc (|
                                      UnOp.not (|
                                        M.call_closure (|
                                          M.get_associated_function (|
                                            Ty.dyn
                                              [
                                                ("core::any::Any::Trait", []);
                                                ("core::marker::Send::AutoTrait", [])
                                              ],
                                            "is",
                                            [ T ]
                                          |),
                                          [ M.read (| self |) ]
                                        |)
                                      |)
                                    |)) in
                                let _ :=
                                  M.is_constant_or_break_match (|
                                    M.read (| γ |),
                                    Value.Bool true
                                  |) in
                                M.alloc (|
                                  M.never_to_any (|
                                    M.call_closure (|
                                      M.get_function (| "core::panicking::panic", [], [] |),
                                      [ M.read (| Value.String "assertion failed: self.is::<T>()" |)
                                      ]
                                    |)
                                  |)
                                |)));
                            fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                          ]
                        |) in
                      M.alloc (| Value.Tuple [] |)));
                  fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                ]
              |) in
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "alloc::boxed::Box")
                      []
                      [
                        Ty.dyn
                          [ ("core::any::Any::Trait", []); ("core::marker::Send::AutoTrait", []) ];
                        A
                      ],
                    "into_raw_with_allocator",
                    []
                  |),
                  [ M.read (| self |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let raw := M.copy (| γ0_0 |) in
                    let alloc := M.copy (| γ0_1 |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "alloc::boxed::Box") [] [ T; A ],
                          "from_raw_in",
                          []
                        |),
                        [ M.rust_cast (M.read (| raw |)); M.read (| alloc |) ]
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom AssociatedFunction_downcast_unchecked :
      forall (A : Ty.t),
      M.IsAssociatedFunction (Self A) "downcast_unchecked" (downcast_unchecked A).
  End Impl_alloc_boxed_Box_Dyn_core_any_Any_Trait_core_marker_Send_AutoTrait_A.
  
  Module Impl_alloc_boxed_Box_Dyn_core_any_Any_Trait_core_marker_Send_AutoTrait_core_marker_Sync_AutoTrait_A.
    Definition Self (A : Ty.t) : Ty.t :=
      Ty.apply
        (Ty.path "alloc::boxed::Box")
        []
        [
          Ty.dyn
            [
              ("core::any::Any::Trait", []);
              ("core::marker::Send::AutoTrait", []);
              ("core::marker::Sync::AutoTrait", [])
            ];
          A
        ].
    
    (*
        pub fn downcast<T: Any>(self) -> Result<Box<T, A>, Self> {
            if self.is::<T>() { unsafe { Ok(self.downcast_unchecked::<T>()) } } else { Err(self) }
        }
    *)
    Definition downcast (A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self A in
      match ε, τ, α with
      | [], [ T ], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.dyn
                                [
                                  ("core::any::Any::Trait", []);
                                  ("core::marker::Send::AutoTrait", []);
                                  ("core::marker::Sync::AutoTrait", [])
                                ],
                              "is",
                              [ T ]
                            |),
                            [ M.read (| self |) ]
                          |)
                        |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply
                                (Ty.path "alloc::boxed::Box")
                                []
                                [
                                  Ty.dyn
                                    [
                                      ("core::any::Any::Trait", []);
                                      ("core::marker::Send::AutoTrait", []);
                                      ("core::marker::Sync::AutoTrait", [])
                                    ];
                                  A
                                ],
                              "downcast_unchecked",
                              [ T ]
                            |),
                            [ M.read (| self |) ]
                          |)
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      Value.StructTuple "core::result::Result::Err" [ M.read (| self |) ]
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom AssociatedFunction_downcast :
      forall (A : Ty.t),
      M.IsAssociatedFunction (Self A) "downcast" (downcast A).
    
    (*
        pub unsafe fn downcast_unchecked<T: Any>(self) -> Box<T, A> {
            debug_assert!(self.is::<T>());
            unsafe {
                let (raw, alloc): ( *mut (dyn Any + Send + Sync), _) =
                    Box::into_raw_with_allocator(self);
                Box::from_raw_in(raw as *mut T, alloc)
            }
        }
    *)
    Definition downcast_unchecked
        (A : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self A in
      match ε, τ, α with
      | [], [ T ], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            let~ _ :=
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.use (M.alloc (| Value.Bool true |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      let~ _ :=
                        M.match_operator (|
                          M.alloc (| Value.Tuple [] |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ :=
                                  M.use
                                    (M.alloc (|
                                      UnOp.not (|
                                        M.call_closure (|
                                          M.get_associated_function (|
                                            Ty.dyn
                                              [
                                                ("core::any::Any::Trait", []);
                                                ("core::marker::Send::AutoTrait", []);
                                                ("core::marker::Sync::AutoTrait", [])
                                              ],
                                            "is",
                                            [ T ]
                                          |),
                                          [ M.read (| self |) ]
                                        |)
                                      |)
                                    |)) in
                                let _ :=
                                  M.is_constant_or_break_match (|
                                    M.read (| γ |),
                                    Value.Bool true
                                  |) in
                                M.alloc (|
                                  M.never_to_any (|
                                    M.call_closure (|
                                      M.get_function (| "core::panicking::panic", [], [] |),
                                      [ M.read (| Value.String "assertion failed: self.is::<T>()" |)
                                      ]
                                    |)
                                  |)
                                |)));
                            fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                          ]
                        |) in
                      M.alloc (| Value.Tuple [] |)));
                  fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                ]
              |) in
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "alloc::boxed::Box")
                      []
                      [
                        Ty.dyn
                          [
                            ("core::any::Any::Trait", []);
                            ("core::marker::Send::AutoTrait", []);
                            ("core::marker::Sync::AutoTrait", [])
                          ];
                        A
                      ],
                    "into_raw_with_allocator",
                    []
                  |),
                  [ M.read (| self |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let raw := M.copy (| γ0_0 |) in
                    let alloc := M.copy (| γ0_1 |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "alloc::boxed::Box") [] [ T; A ],
                          "from_raw_in",
                          []
                        |),
                        [ M.rust_cast (M.read (| raw |)); M.read (| alloc |) ]
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom AssociatedFunction_downcast_unchecked :
      forall (A : Ty.t),
      M.IsAssociatedFunction (Self A) "downcast_unchecked" (downcast_unchecked A).
  End Impl_alloc_boxed_Box_Dyn_core_any_Any_Trait_core_marker_Send_AutoTrait_core_marker_Sync_AutoTrait_A.
  
  Module Impl_core_fmt_Display_where_core_fmt_Display_T_where_core_marker_Sized_T_where_core_alloc_Allocator_A_for_alloc_boxed_Box_T_A.
    Definition Self (T A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::boxed::Box") [] [ T; A ].
    
    (*
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            fmt::Display::fmt(&**self, f)
        }
    *)
    Definition fmt (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.call_closure (|
            M.get_trait_method (| "core::fmt::Display", T, [], "fmt", [] |),
            [ M.read (| M.read (| self |) |); M.read (| f |) ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (T A : Ty.t),
      M.IsTraitInstance
        "core::fmt::Display"
        (Self T A)
        (* Trait polymorphic types *) []
        (* Instance *) [ ("fmt", InstanceField.Method (fmt T A)) ].
  End Impl_core_fmt_Display_where_core_fmt_Display_T_where_core_marker_Sized_T_where_core_alloc_Allocator_A_for_alloc_boxed_Box_T_A.
  
  Module Impl_core_fmt_Debug_where_core_fmt_Debug_T_where_core_marker_Sized_T_where_core_alloc_Allocator_A_for_alloc_boxed_Box_T_A.
    Definition Self (T A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::boxed::Box") [] [ T; A ].
    
    (*
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            fmt::Debug::fmt(&**self, f)
        }
    *)
    Definition fmt (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.call_closure (|
            M.get_trait_method (| "core::fmt::Debug", T, [], "fmt", [] |),
            [ M.read (| M.read (| self |) |); M.read (| f |) ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (T A : Ty.t),
      M.IsTraitInstance
        "core::fmt::Debug"
        (Self T A)
        (* Trait polymorphic types *) []
        (* Instance *) [ ("fmt", InstanceField.Method (fmt T A)) ].
  End Impl_core_fmt_Debug_where_core_fmt_Debug_T_where_core_marker_Sized_T_where_core_alloc_Allocator_A_for_alloc_boxed_Box_T_A.
  
  Module Impl_core_fmt_Pointer_where_core_marker_Sized_T_where_core_alloc_Allocator_A_for_alloc_boxed_Box_T_A.
    Definition Self (T A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::boxed::Box") [] [ T; A ].
    
    (*
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            // It's not possible to extract the inner Uniq directly from the Box,
            // instead we cast it to a *const which aliases the Unique
            let ptr: *const T = &**self;
            fmt::Pointer::fmt(&ptr, f)
        }
    *)
    Definition fmt (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.read (|
            let~ ptr := M.alloc (| M.read (| M.read (| self |) |) |) in
            M.alloc (|
              M.call_closure (|
                M.get_trait_method (|
                  "core::fmt::Pointer",
                  Ty.apply (Ty.path "*const") [] [ T ],
                  [],
                  "fmt",
                  []
                |),
                [ ptr; M.read (| f |) ]
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (T A : Ty.t),
      M.IsTraitInstance
        "core::fmt::Pointer"
        (Self T A)
        (* Trait polymorphic types *) []
        (* Instance *) [ ("fmt", InstanceField.Method (fmt T A)) ].
  End Impl_core_fmt_Pointer_where_core_marker_Sized_T_where_core_alloc_Allocator_A_for_alloc_boxed_Box_T_A.
  
  Module Impl_core_ops_deref_Deref_where_core_marker_Sized_T_where_core_alloc_Allocator_A_for_alloc_boxed_Box_T_A.
    Definition Self (T A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::boxed::Box") [] [ T; A ].
    
    (*     type Target = T; *)
    Definition _Target (T A : Ty.t) : Ty.t := T.
    
    (*
        fn deref(&self) -> &T {
            &**self
        }
    *)
    Definition deref (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (| M.read (| self |) |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (T A : Ty.t),
      M.IsTraitInstance
        "core::ops::deref::Deref"
        (Self T A)
        (* Trait polymorphic types *) []
        (* Instance *)
        [ ("Target", InstanceField.Ty (_Target T A)); ("deref", InstanceField.Method (deref T A)) ].
  End Impl_core_ops_deref_Deref_where_core_marker_Sized_T_where_core_alloc_Allocator_A_for_alloc_boxed_Box_T_A.
  
  Module Impl_core_ops_deref_DerefMut_where_core_marker_Sized_T_where_core_alloc_Allocator_A_for_alloc_boxed_Box_T_A.
    Definition Self (T A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::boxed::Box") [] [ T; A ].
    
    (*
        fn deref_mut(&mut self) -> &mut T {
            &mut **self
        }
    *)
    Definition deref_mut (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (| M.read (| self |) |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (T A : Ty.t),
      M.IsTraitInstance
        "core::ops::deref::DerefMut"
        (Self T A)
        (* Trait polymorphic types *) []
        (* Instance *) [ ("deref_mut", InstanceField.Method (deref_mut T A)) ].
  End Impl_core_ops_deref_DerefMut_where_core_marker_Sized_T_where_core_alloc_Allocator_A_for_alloc_boxed_Box_T_A.
  
  Module Impl_core_ops_deref_DerefPure_where_core_marker_Sized_T_where_core_alloc_Allocator_A_for_alloc_boxed_Box_T_A.
    Definition Self (T A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::boxed::Box") [] [ T; A ].
    
    Axiom Implements :
      forall (T A : Ty.t),
      M.IsTraitInstance
        "core::ops::deref::DerefPure"
        (Self T A)
        (* Trait polymorphic types *) []
        (* Instance *) [].
  End Impl_core_ops_deref_DerefPure_where_core_marker_Sized_T_where_core_alloc_Allocator_A_for_alloc_boxed_Box_T_A.
  
  Module Impl_core_ops_deref_Receiver_where_core_marker_Sized_T_where_core_alloc_Allocator_A_for_alloc_boxed_Box_T_A.
    Definition Self (T A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::boxed::Box") [] [ T; A ].
    
    Axiom Implements :
      forall (T A : Ty.t),
      M.IsTraitInstance
        "core::ops::deref::Receiver"
        (Self T A)
        (* Trait polymorphic types *) []
        (* Instance *) [].
  End Impl_core_ops_deref_Receiver_where_core_marker_Sized_T_where_core_alloc_Allocator_A_for_alloc_boxed_Box_T_A.
  
  Module Impl_core_iter_traits_iterator_Iterator_where_core_iter_traits_iterator_Iterator_I_where_core_marker_Sized_I_where_core_alloc_Allocator_A_for_alloc_boxed_Box_I_A.
    Definition Self (I A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::boxed::Box") [] [ I; A ].
    
    (*     type Item = I::Item; *)
    Definition _Item (I A : Ty.t) : Ty.t := Ty.associated.
    
    (*
        fn next(&mut self) -> Option<I::Item> {
            ( **self).next()
        }
    *)
    Definition next (I A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self I A in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_trait_method (| "core::iter::traits::iterator::Iterator", I, [], "next", [] |),
            [ M.read (| M.read (| self |) |) ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    (*
        fn size_hint(&self) -> (usize, Option<usize>) {
            ( **self).size_hint()
        }
    *)
    Definition size_hint (I A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self I A in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_trait_method (|
              "core::iter::traits::iterator::Iterator",
              I,
              [],
              "size_hint",
              []
            |),
            [ M.read (| M.read (| self |) |) ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    (*
        fn nth(&mut self, n: usize) -> Option<I::Item> {
            ( **self).nth(n)
        }
    *)
    Definition nth (I A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self I A in
      match ε, τ, α with
      | [], [], [ self; n ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let n := M.alloc (| n |) in
          M.call_closure (|
            M.get_trait_method (| "core::iter::traits::iterator::Iterator", I, [], "nth", [] |),
            [ M.read (| M.read (| self |) |); M.read (| n |) ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    (*
        fn last(self) -> Option<I::Item> {
            BoxIter::last(self)
        }
    *)
    Definition last (I A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self I A in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_trait_method (|
              "alloc::boxed::BoxIter",
              Ty.apply (Ty.path "alloc::boxed::Box") [] [ I; A ],
              [],
              "last",
              []
            |),
            [ M.read (| self |) ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (I A : Ty.t),
      M.IsTraitInstance
        "core::iter::traits::iterator::Iterator"
        (Self I A)
        (* Trait polymorphic types *) []
        (* Instance *)
        [
          ("Item", InstanceField.Ty (_Item I A));
          ("next", InstanceField.Method (next I A));
          ("size_hint", InstanceField.Method (size_hint I A));
          ("nth", InstanceField.Method (nth I A));
          ("last", InstanceField.Method (last I A))
        ].
  End Impl_core_iter_traits_iterator_Iterator_where_core_iter_traits_iterator_Iterator_I_where_core_marker_Sized_I_where_core_alloc_Allocator_A_for_alloc_boxed_Box_I_A.
  
  (* Trait *)
  (* Empty module 'BoxIter' *)
  
  Module Impl_alloc_boxed_BoxIter_where_core_iter_traits_iterator_Iterator_I_where_core_marker_Sized_I_where_core_alloc_Allocator_A_for_alloc_boxed_Box_I_A.
    Definition Self (I A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::boxed::Box") [] [ I; A ].
    
    (*     type Item = I::Item; *)
    Definition _Item (I A : Ty.t) : Ty.t := Ty.associated.
    
    (*
        default fn last(self) -> Option<I::Item> {
            #[inline]
            fn some<T>(_: Option<T>, x: T) -> Option<T> {
                Some(x)
            }
    
            self.fold(None, some)
        }
    *)
    Definition last (I A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self I A in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_trait_method (|
              "core::iter::traits::iterator::Iterator",
              Ty.apply (Ty.path "alloc::boxed::Box") [] [ I; A ],
              [],
              "fold",
              [
                Ty.apply (Ty.path "core::option::Option") [] [ Ty.associated ];
                Ty.function
                  [ Ty.apply (Ty.path "core::option::Option") [] [ Ty.associated ]; Ty.associated ]
                  (Ty.apply (Ty.path "core::option::Option") [] [ Ty.associated ])
              ]
            |),
            [
              M.read (| self |);
              Value.StructTuple "core::option::Option::None" [];
              M.get_associated_function (| Self, "some.last", [] |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (I A : Ty.t),
      M.IsTraitInstance
        "alloc::boxed::BoxIter"
        (Self I A)
        (* Trait polymorphic types *) []
        (* Instance *)
        [ ("Item", InstanceField.Ty (_Item I A)); ("last", InstanceField.Method (last I A)) ].
  End Impl_alloc_boxed_BoxIter_where_core_iter_traits_iterator_Iterator_I_where_core_marker_Sized_I_where_core_alloc_Allocator_A_for_alloc_boxed_Box_I_A.
  
  Module Impl_alloc_boxed_BoxIter_where_core_iter_traits_iterator_Iterator_I_where_core_alloc_Allocator_A_for_alloc_boxed_Box_I_A.
    Definition Self (I A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::boxed::Box") [] [ I; A ].
    
    (*
        fn last(self) -> Option<I::Item> {
            ( *self).last()
        }
    *)
    Definition last (I A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self I A in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_trait_method (| "core::iter::traits::iterator::Iterator", I, [], "last", [] |),
            [ M.read (| M.read (| self |) |) ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (I A : Ty.t),
      M.IsTraitInstance
        "alloc::boxed::BoxIter"
        (Self I A)
        (* Trait polymorphic types *) []
        (* Instance *) [ ("last", InstanceField.Method (last I A)) ].
  End Impl_alloc_boxed_BoxIter_where_core_iter_traits_iterator_Iterator_I_where_core_alloc_Allocator_A_for_alloc_boxed_Box_I_A.
  
  Module Impl_core_iter_traits_double_ended_DoubleEndedIterator_where_core_iter_traits_double_ended_DoubleEndedIterator_I_where_core_marker_Sized_I_where_core_alloc_Allocator_A_for_alloc_boxed_Box_I_A.
    Definition Self (I A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::boxed::Box") [] [ I; A ].
    
    (*
        fn next_back(&mut self) -> Option<I::Item> {
            ( **self).next_back()
        }
    *)
    Definition next_back (I A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self I A in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_trait_method (|
              "core::iter::traits::double_ended::DoubleEndedIterator",
              I,
              [],
              "next_back",
              []
            |),
            [ M.read (| M.read (| self |) |) ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    (*
        fn nth_back(&mut self, n: usize) -> Option<I::Item> {
            ( **self).nth_back(n)
        }
    *)
    Definition nth_back (I A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self I A in
      match ε, τ, α with
      | [], [], [ self; n ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let n := M.alloc (| n |) in
          M.call_closure (|
            M.get_trait_method (|
              "core::iter::traits::double_ended::DoubleEndedIterator",
              I,
              [],
              "nth_back",
              []
            |),
            [ M.read (| M.read (| self |) |); M.read (| n |) ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (I A : Ty.t),
      M.IsTraitInstance
        "core::iter::traits::double_ended::DoubleEndedIterator"
        (Self I A)
        (* Trait polymorphic types *) []
        (* Instance *)
        [
          ("next_back", InstanceField.Method (next_back I A));
          ("nth_back", InstanceField.Method (nth_back I A))
        ].
  End Impl_core_iter_traits_double_ended_DoubleEndedIterator_where_core_iter_traits_double_ended_DoubleEndedIterator_I_where_core_marker_Sized_I_where_core_alloc_Allocator_A_for_alloc_boxed_Box_I_A.
  
  Module Impl_core_iter_traits_exact_size_ExactSizeIterator_where_core_iter_traits_exact_size_ExactSizeIterator_I_where_core_marker_Sized_I_where_core_alloc_Allocator_A_for_alloc_boxed_Box_I_A.
    Definition Self (I A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::boxed::Box") [] [ I; A ].
    
    (*
        fn len(&self) -> usize {
            ( **self).len()
        }
    *)
    Definition len (I A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self I A in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_trait_method (|
              "core::iter::traits::exact_size::ExactSizeIterator",
              I,
              [],
              "len",
              []
            |),
            [ M.read (| M.read (| self |) |) ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    (*
        fn is_empty(&self) -> bool {
            ( **self).is_empty()
        }
    *)
    Definition is_empty (I A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self I A in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_trait_method (|
              "core::iter::traits::exact_size::ExactSizeIterator",
              I,
              [],
              "is_empty",
              []
            |),
            [ M.read (| M.read (| self |) |) ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (I A : Ty.t),
      M.IsTraitInstance
        "core::iter::traits::exact_size::ExactSizeIterator"
        (Self I A)
        (* Trait polymorphic types *) []
        (* Instance *)
        [ ("len", InstanceField.Method (len I A)); ("is_empty", InstanceField.Method (is_empty I A))
        ].
  End Impl_core_iter_traits_exact_size_ExactSizeIterator_where_core_iter_traits_exact_size_ExactSizeIterator_I_where_core_marker_Sized_I_where_core_alloc_Allocator_A_for_alloc_boxed_Box_I_A.
  
  Module Impl_core_iter_traits_marker_FusedIterator_where_core_iter_traits_marker_FusedIterator_I_where_core_marker_Sized_I_where_core_alloc_Allocator_A_for_alloc_boxed_Box_I_A.
    Definition Self (I A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::boxed::Box") [] [ I; A ].
    
    Axiom Implements :
      forall (I A : Ty.t),
      M.IsTraitInstance
        "core::iter::traits::marker::FusedIterator"
        (Self I A)
        (* Trait polymorphic types *) []
        (* Instance *) [].
  End Impl_core_iter_traits_marker_FusedIterator_where_core_iter_traits_marker_FusedIterator_I_where_core_marker_Sized_I_where_core_alloc_Allocator_A_for_alloc_boxed_Box_I_A.
  
  Module Impl_core_ops_function_FnOnce_where_core_marker_Tuple_Args_where_core_ops_function_FnOnce_F_Args_where_core_marker_Sized_F_where_core_alloc_Allocator_A_Args_for_alloc_boxed_Box_F_A.
    Definition Self (Args F A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::boxed::Box") [] [ F; A ].
    
    (*     type Output = <F as FnOnce<Args>>::Output; *)
    Definition _Output (Args F A : Ty.t) : Ty.t := Ty.associated.
    
    (*
        extern "rust-call" fn call_once(self, args: Args) -> Self::Output {
            <F as FnOnce<Args>>::call_once( *self, args)
        }
    *)
    Definition call_once
        (Args F A : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self Args F A in
      match ε, τ, α with
      | [], [], [ self; args ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let args := M.alloc (| args |) in
          M.call_closure (|
            M.get_trait_method (| "core::ops::function::FnOnce", F, [ Args ], "call_once", [] |),
            [ M.read (| M.read (| self |) |); M.read (| args |) ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (Args F A : Ty.t),
      M.IsTraitInstance
        "core::ops::function::FnOnce"
        (Self Args F A)
        (* Trait polymorphic types *) [ (* Args *) Args ]
        (* Instance *)
        [
          ("Output", InstanceField.Ty (_Output Args F A));
          ("call_once", InstanceField.Method (call_once Args F A))
        ].
  End Impl_core_ops_function_FnOnce_where_core_marker_Tuple_Args_where_core_ops_function_FnOnce_F_Args_where_core_marker_Sized_F_where_core_alloc_Allocator_A_Args_for_alloc_boxed_Box_F_A.
  
  Module Impl_core_ops_function_FnMut_where_core_marker_Tuple_Args_where_core_ops_function_FnMut_F_Args_where_core_marker_Sized_F_where_core_alloc_Allocator_A_Args_for_alloc_boxed_Box_F_A.
    Definition Self (Args F A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::boxed::Box") [] [ F; A ].
    
    (*
        extern "rust-call" fn call_mut(&mut self, args: Args) -> Self::Output {
            <F as FnMut<Args>>::call_mut(self, args)
        }
    *)
    Definition call_mut
        (Args F A : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self Args F A in
      match ε, τ, α with
      | [], [], [ self; args ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let args := M.alloc (| args |) in
          M.call_closure (|
            M.get_trait_method (| "core::ops::function::FnMut", F, [ Args ], "call_mut", [] |),
            [ M.read (| M.read (| self |) |); M.read (| args |) ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (Args F A : Ty.t),
      M.IsTraitInstance
        "core::ops::function::FnMut"
        (Self Args F A)
        (* Trait polymorphic types *) [ (* Args *) Args ]
        (* Instance *) [ ("call_mut", InstanceField.Method (call_mut Args F A)) ].
  End Impl_core_ops_function_FnMut_where_core_marker_Tuple_Args_where_core_ops_function_FnMut_F_Args_where_core_marker_Sized_F_where_core_alloc_Allocator_A_Args_for_alloc_boxed_Box_F_A.
  
  Module Impl_core_ops_function_Fn_where_core_marker_Tuple_Args_where_core_ops_function_Fn_F_Args_where_core_marker_Sized_F_where_core_alloc_Allocator_A_Args_for_alloc_boxed_Box_F_A.
    Definition Self (Args F A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::boxed::Box") [] [ F; A ].
    
    (*
        extern "rust-call" fn call(&self, args: Args) -> Self::Output {
            <F as Fn<Args>>::call(self, args)
        }
    *)
    Definition call (Args F A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self Args F A in
      match ε, τ, α with
      | [], [], [ self; args ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let args := M.alloc (| args |) in
          M.call_closure (|
            M.get_trait_method (| "core::ops::function::Fn", F, [ Args ], "call", [] |),
            [ M.read (| M.read (| self |) |); M.read (| args |) ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (Args F A : Ty.t),
      M.IsTraitInstance
        "core::ops::function::Fn"
        (Self Args F A)
        (* Trait polymorphic types *) [ (* Args *) Args ]
        (* Instance *) [ ("call", InstanceField.Method (call Args F A)) ].
  End Impl_core_ops_function_Fn_where_core_marker_Tuple_Args_where_core_ops_function_Fn_F_Args_where_core_marker_Sized_F_where_core_alloc_Allocator_A_Args_for_alloc_boxed_Box_F_A.
  
  Module Impl_core_ops_async_function_AsyncFnOnce_where_core_marker_Tuple_Args_where_core_ops_async_function_AsyncFnOnce_F_Args_where_core_marker_Sized_F_where_core_alloc_Allocator_A_Args_for_alloc_boxed_Box_F_A.
    Definition Self (Args F A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::boxed::Box") [] [ F; A ].
    
    (*     type Output = F::Output; *)
    Definition _Output (Args F A : Ty.t) : Ty.t := Ty.associated.
    
    (*     type CallOnceFuture = F::CallOnceFuture; *)
    Definition _CallOnceFuture (Args F A : Ty.t) : Ty.t := Ty.associated.
    
    (*
        extern "rust-call" fn async_call_once(self, args: Args) -> Self::CallOnceFuture {
            F::async_call_once( *self, args)
        }
    *)
    Definition async_call_once
        (Args F A : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self Args F A in
      match ε, τ, α with
      | [], [], [ self; args ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let args := M.alloc (| args |) in
          M.call_closure (|
            M.get_trait_method (|
              "core::ops::async_function::AsyncFnOnce",
              F,
              [ Args ],
              "async_call_once",
              []
            |),
            [ M.read (| M.read (| self |) |); M.read (| args |) ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (Args F A : Ty.t),
      M.IsTraitInstance
        "core::ops::async_function::AsyncFnOnce"
        (Self Args F A)
        (* Trait polymorphic types *) [ (* Args *) Args ]
        (* Instance *)
        [
          ("Output", InstanceField.Ty (_Output Args F A));
          ("CallOnceFuture", InstanceField.Ty (_CallOnceFuture Args F A));
          ("async_call_once", InstanceField.Method (async_call_once Args F A))
        ].
  End Impl_core_ops_async_function_AsyncFnOnce_where_core_marker_Tuple_Args_where_core_ops_async_function_AsyncFnOnce_F_Args_where_core_marker_Sized_F_where_core_alloc_Allocator_A_Args_for_alloc_boxed_Box_F_A.
  
  Module Impl_core_ops_async_function_AsyncFnMut_where_core_marker_Tuple_Args_where_core_ops_async_function_AsyncFnMut_F_Args_where_core_marker_Sized_F_where_core_alloc_Allocator_A_Args_for_alloc_boxed_Box_F_A.
    Definition Self (Args F A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::boxed::Box") [] [ F; A ].
    
    (*
        type CallRefFuture<'a>
            = F::CallRefFuture<'a>
        where
            Self: 'a;
    *)
    Definition _CallRefFuture (Args F A : Ty.t) : Ty.t := Ty.associated.
    
    (*
        extern "rust-call" fn async_call_mut(&mut self, args: Args) -> Self::CallRefFuture<'_> {
            F::async_call_mut(self, args)
        }
    *)
    Definition async_call_mut
        (Args F A : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self Args F A in
      match ε, τ, α with
      | [], [], [ self; args ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let args := M.alloc (| args |) in
          M.call_closure (|
            M.get_trait_method (|
              "core::ops::async_function::AsyncFnMut",
              F,
              [ Args ],
              "async_call_mut",
              []
            |),
            [ M.read (| M.read (| self |) |); M.read (| args |) ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (Args F A : Ty.t),
      M.IsTraitInstance
        "core::ops::async_function::AsyncFnMut"
        (Self Args F A)
        (* Trait polymorphic types *) [ (* Args *) Args ]
        (* Instance *)
        [
          ("CallRefFuture", InstanceField.Ty (_CallRefFuture Args F A));
          ("async_call_mut", InstanceField.Method (async_call_mut Args F A))
        ].
  End Impl_core_ops_async_function_AsyncFnMut_where_core_marker_Tuple_Args_where_core_ops_async_function_AsyncFnMut_F_Args_where_core_marker_Sized_F_where_core_alloc_Allocator_A_Args_for_alloc_boxed_Box_F_A.
  
  Module Impl_core_ops_async_function_AsyncFn_where_core_marker_Tuple_Args_where_core_ops_async_function_AsyncFn_F_Args_where_core_marker_Sized_F_where_core_alloc_Allocator_A_Args_for_alloc_boxed_Box_F_A.
    Definition Self (Args F A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::boxed::Box") [] [ F; A ].
    
    (*
        extern "rust-call" fn async_call(&self, args: Args) -> Self::CallRefFuture<'_> {
            F::async_call(self, args)
        }
    *)
    Definition async_call
        (Args F A : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self Args F A in
      match ε, τ, α with
      | [], [], [ self; args ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let args := M.alloc (| args |) in
          M.call_closure (|
            M.get_trait_method (|
              "core::ops::async_function::AsyncFn",
              F,
              [ Args ],
              "async_call",
              []
            |),
            [ M.read (| M.read (| self |) |); M.read (| args |) ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (Args F A : Ty.t),
      M.IsTraitInstance
        "core::ops::async_function::AsyncFn"
        (Self Args F A)
        (* Trait polymorphic types *) [ (* Args *) Args ]
        (* Instance *) [ ("async_call", InstanceField.Method (async_call Args F A)) ].
  End Impl_core_ops_async_function_AsyncFn_where_core_marker_Tuple_Args_where_core_ops_async_function_AsyncFn_F_Args_where_core_marker_Sized_F_where_core_alloc_Allocator_A_Args_for_alloc_boxed_Box_F_A.
  
  Module Impl_core_ops_unsize_CoerceUnsized_where_core_marker_Sized_T_where_core_marker_Unsize_T_U_where_core_marker_Sized_U_where_core_alloc_Allocator_A_alloc_boxed_Box_U_A_for_alloc_boxed_Box_T_A.
    Definition Self (T U A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::boxed::Box") [] [ T; A ].
    
    Axiom Implements :
      forall (T U A : Ty.t),
      M.IsTraitInstance
        "core::ops::unsize::CoerceUnsized"
        (Self T U A)
        (* Trait polymorphic types *) [ (* T *) Ty.apply (Ty.path "alloc::boxed::Box") [] [ U; A ] ]
        (* Instance *) [].
  End Impl_core_ops_unsize_CoerceUnsized_where_core_marker_Sized_T_where_core_marker_Unsize_T_U_where_core_marker_Sized_U_where_core_alloc_Allocator_A_alloc_boxed_Box_U_A_for_alloc_boxed_Box_T_A.
  
  Module Impl_core_ops_unsize_DispatchFromDyn_where_core_marker_Sized_T_where_core_marker_Unsize_T_U_where_core_marker_Sized_U_alloc_boxed_Box_U_alloc_alloc_Global_for_alloc_boxed_Box_T_alloc_alloc_Global.
    Definition Self (T U : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "alloc::boxed::Box") [] [ T; Ty.path "alloc::alloc::Global" ].
    
    Axiom Implements :
      forall (T U : Ty.t),
      M.IsTraitInstance
        "core::ops::unsize::DispatchFromDyn"
        (Self T U)
        (* Trait polymorphic types *)
        [ (* T *) Ty.apply (Ty.path "alloc::boxed::Box") [] [ U; Ty.path "alloc::alloc::Global" ] ]
        (* Instance *) [].
  End Impl_core_ops_unsize_DispatchFromDyn_where_core_marker_Sized_T_where_core_marker_Unsize_T_U_where_core_marker_Sized_U_alloc_boxed_Box_U_alloc_alloc_Global_for_alloc_boxed_Box_T_alloc_alloc_Global.
  
  Module Impl_core_iter_traits_collect_FromIterator_I_for_alloc_boxed_Box_slice_I_alloc_alloc_Global.
    Definition Self (I : Ty.t) : Ty.t :=
      Ty.apply
        (Ty.path "alloc::boxed::Box")
        []
        [ Ty.apply (Ty.path "slice") [] [ I ]; Ty.path "alloc::alloc::Global" ].
    
    (*
        fn from_iter<T: IntoIterator<Item = I>>(iter: T) -> Self {
            iter.into_iter().collect::<Vec<_>>().into_boxed_slice()
        }
    *)
    Definition from_iter (I : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self I in
      match ε, τ, α with
      | [], [ T ], [ iter ] =>
        ltac:(M.monadic
          (let iter := M.alloc (| iter |) in
          M.call_closure (|
            M.get_associated_function (|
              Ty.apply (Ty.path "alloc::vec::Vec") [] [ I; Ty.path "alloc::alloc::Global" ],
              "into_boxed_slice",
              []
            |),
            [
              M.call_closure (|
                M.get_trait_method (|
                  "core::iter::traits::iterator::Iterator",
                  Ty.associated,
                  [],
                  "collect",
                  [ Ty.apply (Ty.path "alloc::vec::Vec") [] [ I; Ty.path "alloc::alloc::Global" ] ]
                |),
                [
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::iter::traits::collect::IntoIterator",
                      T,
                      [],
                      "into_iter",
                      []
                    |),
                    [ M.read (| iter |) ]
                  |)
                ]
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (I : Ty.t),
      M.IsTraitInstance
        "core::iter::traits::collect::FromIterator"
        (Self I)
        (* Trait polymorphic types *) [ (* A *) I ]
        (* Instance *) [ ("from_iter", InstanceField.Method (from_iter I)) ].
  End Impl_core_iter_traits_collect_FromIterator_I_for_alloc_boxed_Box_slice_I_alloc_alloc_Global.
  
  Module Impl_core_iter_traits_iterator_Iterator_where_core_alloc_Allocator_A_for_alloc_boxed_Box_slice_I_A.
    Definition Self (I A : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "alloc::boxed::Box") [] [ Ty.apply (Ty.path "slice") [] [ I ]; A ].
    
    Axiom Implements :
      forall (I A : Ty.t),
      M.IsTraitInstance
        "core::iter::traits::iterator::Iterator"
        (Self I A)
        (* Trait polymorphic types *) []
        (* Instance *) [].
  End Impl_core_iter_traits_iterator_Iterator_where_core_alloc_Allocator_A_for_alloc_boxed_Box_slice_I_A.
  
  Module Impl_core_iter_traits_iterator_Iterator_where_core_alloc_Allocator_A_for_ref__alloc_boxed_Box_slice_I_A.
    Definition Self (I A : Ty.t) : Ty.t :=
      Ty.apply
        (Ty.path "&")
        []
        [ Ty.apply (Ty.path "alloc::boxed::Box") [] [ Ty.apply (Ty.path "slice") [] [ I ]; A ] ].
    
    Axiom Implements :
      forall (I A : Ty.t),
      M.IsTraitInstance
        "core::iter::traits::iterator::Iterator"
        (Self I A)
        (* Trait polymorphic types *) []
        (* Instance *) [].
  End Impl_core_iter_traits_iterator_Iterator_where_core_alloc_Allocator_A_for_ref__alloc_boxed_Box_slice_I_A.
  
  Module Impl_core_iter_traits_iterator_Iterator_where_core_alloc_Allocator_A_for_ref_mut_alloc_boxed_Box_slice_I_A.
    Definition Self (I A : Ty.t) : Ty.t :=
      Ty.apply
        (Ty.path "&mut")
        []
        [ Ty.apply (Ty.path "alloc::boxed::Box") [] [ Ty.apply (Ty.path "slice") [] [ I ]; A ] ].
    
    Axiom Implements :
      forall (I A : Ty.t),
      M.IsTraitInstance
        "core::iter::traits::iterator::Iterator"
        (Self I A)
        (* Trait polymorphic types *) []
        (* Instance *) [].
  End Impl_core_iter_traits_iterator_Iterator_where_core_alloc_Allocator_A_for_ref_mut_alloc_boxed_Box_slice_I_A.
  
  Module Impl_core_iter_traits_collect_IntoIterator_where_core_alloc_Allocator_A_for_alloc_boxed_Box_slice_I_A.
    Definition Self (I A : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "alloc::boxed::Box") [] [ Ty.apply (Ty.path "slice") [] [ I ]; A ].
    
    (*     type IntoIter = vec::IntoIter<I, A>; *)
    Definition _IntoIter (I A : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "alloc::vec::into_iter::IntoIter") [] [ I; A ].
    
    (*     type Item = I; *)
    Definition _Item (I A : Ty.t) : Ty.t := I.
    
    (*
        fn into_iter(self) -> vec::IntoIter<I, A> {
            self.into_vec().into_iter()
        }
    *)
    Definition into_iter (I A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self I A in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_trait_method (|
              "core::iter::traits::collect::IntoIterator",
              Ty.apply (Ty.path "alloc::vec::Vec") [] [ I; A ],
              [],
              "into_iter",
              []
            |),
            [
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply (Ty.path "slice") [] [ I ],
                  "into_vec",
                  [ A ]
                |),
                [ M.read (| self |) ]
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (I A : Ty.t),
      M.IsTraitInstance
        "core::iter::traits::collect::IntoIterator"
        (Self I A)
        (* Trait polymorphic types *) []
        (* Instance *)
        [
          ("IntoIter", InstanceField.Ty (_IntoIter I A));
          ("Item", InstanceField.Ty (_Item I A));
          ("into_iter", InstanceField.Method (into_iter I A))
        ].
  End Impl_core_iter_traits_collect_IntoIterator_where_core_alloc_Allocator_A_for_alloc_boxed_Box_slice_I_A.
  
  Module Impl_core_iter_traits_collect_IntoIterator_where_core_alloc_Allocator_A_for_ref__alloc_boxed_Box_slice_I_A.
    Definition Self (I A : Ty.t) : Ty.t :=
      Ty.apply
        (Ty.path "&")
        []
        [ Ty.apply (Ty.path "alloc::boxed::Box") [] [ Ty.apply (Ty.path "slice") [] [ I ]; A ] ].
    
    (*     type IntoIter = slice::Iter<'a, I>; *)
    Definition _IntoIter (I A : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "core::slice::iter::Iter") [] [ I ].
    
    (*     type Item = &'a I; *)
    Definition _Item (I A : Ty.t) : Ty.t := Ty.apply (Ty.path "&") [] [ I ].
    
    (*
        fn into_iter(self) -> slice::Iter<'a, I> {
            self.iter()
        }
    *)
    Definition into_iter (I A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self I A in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_associated_function (| Ty.apply (Ty.path "slice") [] [ I ], "iter", [] |),
            [ M.read (| M.read (| self |) |) ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (I A : Ty.t),
      M.IsTraitInstance
        "core::iter::traits::collect::IntoIterator"
        (Self I A)
        (* Trait polymorphic types *) []
        (* Instance *)
        [
          ("IntoIter", InstanceField.Ty (_IntoIter I A));
          ("Item", InstanceField.Ty (_Item I A));
          ("into_iter", InstanceField.Method (into_iter I A))
        ].
  End Impl_core_iter_traits_collect_IntoIterator_where_core_alloc_Allocator_A_for_ref__alloc_boxed_Box_slice_I_A.
  
  Module Impl_core_iter_traits_collect_IntoIterator_where_core_alloc_Allocator_A_for_ref_mut_alloc_boxed_Box_slice_I_A.
    Definition Self (I A : Ty.t) : Ty.t :=
      Ty.apply
        (Ty.path "&mut")
        []
        [ Ty.apply (Ty.path "alloc::boxed::Box") [] [ Ty.apply (Ty.path "slice") [] [ I ]; A ] ].
    
    (*     type IntoIter = slice::IterMut<'a, I>; *)
    Definition _IntoIter (I A : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "core::slice::iter::IterMut") [] [ I ].
    
    (*     type Item = &'a mut I; *)
    Definition _Item (I A : Ty.t) : Ty.t := Ty.apply (Ty.path "&mut") [] [ I ].
    
    (*
        fn into_iter(self) -> slice::IterMut<'a, I> {
            self.iter_mut()
        }
    *)
    Definition into_iter (I A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self I A in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_associated_function (| Ty.apply (Ty.path "slice") [] [ I ], "iter_mut", [] |),
            [ M.read (| M.read (| self |) |) ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (I A : Ty.t),
      M.IsTraitInstance
        "core::iter::traits::collect::IntoIterator"
        (Self I A)
        (* Trait polymorphic types *) []
        (* Instance *)
        [
          ("IntoIter", InstanceField.Ty (_IntoIter I A));
          ("Item", InstanceField.Ty (_Item I A));
          ("into_iter", InstanceField.Method (into_iter I A))
        ].
  End Impl_core_iter_traits_collect_IntoIterator_where_core_alloc_Allocator_A_for_ref_mut_alloc_boxed_Box_slice_I_A.
  
  Module Impl_core_iter_traits_collect_FromIterator_char_for_alloc_boxed_Box_str_alloc_alloc_Global.
    Definition Self : Ty.t :=
      Ty.apply (Ty.path "alloc::boxed::Box") [] [ Ty.path "str"; Ty.path "alloc::alloc::Global" ].
    
    (*
        fn from_iter<T: IntoIterator<Item = char>>(iter: T) -> Self {
            String::from_iter(iter).into_boxed_str()
        }
    *)
    Definition from_iter (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [ T ], [ iter ] =>
        ltac:(M.monadic
          (let iter := M.alloc (| iter |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "alloc::string::String", "into_boxed_str", [] |),
            [
              M.call_closure (|
                M.get_trait_method (|
                  "core::iter::traits::collect::FromIterator",
                  Ty.path "alloc::string::String",
                  [ Ty.path "char" ],
                  "from_iter",
                  [ T ]
                |),
                [ M.read (| iter |) ]
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::iter::traits::collect::FromIterator"
        Self
        (* Trait polymorphic types *) [ (* A *) Ty.path "char" ]
        (* Instance *) [ ("from_iter", InstanceField.Method from_iter) ].
  End Impl_core_iter_traits_collect_FromIterator_char_for_alloc_boxed_Box_str_alloc_alloc_Global.
  
  Module Impl_core_iter_traits_collect_FromIterator_ref__char_for_alloc_boxed_Box_str_alloc_alloc_Global.
    Definition Self : Ty.t :=
      Ty.apply (Ty.path "alloc::boxed::Box") [] [ Ty.path "str"; Ty.path "alloc::alloc::Global" ].
    
    (*
        fn from_iter<T: IntoIterator<Item = &'a char>>(iter: T) -> Self {
            String::from_iter(iter).into_boxed_str()
        }
    *)
    Definition from_iter (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [ T ], [ iter ] =>
        ltac:(M.monadic
          (let iter := M.alloc (| iter |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "alloc::string::String", "into_boxed_str", [] |),
            [
              M.call_closure (|
                M.get_trait_method (|
                  "core::iter::traits::collect::FromIterator",
                  Ty.path "alloc::string::String",
                  [ Ty.apply (Ty.path "&") [] [ Ty.path "char" ] ],
                  "from_iter",
                  [ T ]
                |),
                [ M.read (| iter |) ]
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::iter::traits::collect::FromIterator"
        Self
        (* Trait polymorphic types *) [ (* A *) Ty.apply (Ty.path "&") [] [ Ty.path "char" ] ]
        (* Instance *) [ ("from_iter", InstanceField.Method from_iter) ].
  End Impl_core_iter_traits_collect_FromIterator_ref__char_for_alloc_boxed_Box_str_alloc_alloc_Global.
  
  Module Impl_core_iter_traits_collect_FromIterator_ref__str_for_alloc_boxed_Box_str_alloc_alloc_Global.
    Definition Self : Ty.t :=
      Ty.apply (Ty.path "alloc::boxed::Box") [] [ Ty.path "str"; Ty.path "alloc::alloc::Global" ].
    
    (*
        fn from_iter<T: IntoIterator<Item = &'a str>>(iter: T) -> Self {
            String::from_iter(iter).into_boxed_str()
        }
    *)
    Definition from_iter (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [ T ], [ iter ] =>
        ltac:(M.monadic
          (let iter := M.alloc (| iter |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "alloc::string::String", "into_boxed_str", [] |),
            [
              M.call_closure (|
                M.get_trait_method (|
                  "core::iter::traits::collect::FromIterator",
                  Ty.path "alloc::string::String",
                  [ Ty.apply (Ty.path "&") [] [ Ty.path "str" ] ],
                  "from_iter",
                  [ T ]
                |),
                [ M.read (| iter |) ]
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::iter::traits::collect::FromIterator"
        Self
        (* Trait polymorphic types *) [ (* A *) Ty.apply (Ty.path "&") [] [ Ty.path "str" ] ]
        (* Instance *) [ ("from_iter", InstanceField.Method from_iter) ].
  End Impl_core_iter_traits_collect_FromIterator_ref__str_for_alloc_boxed_Box_str_alloc_alloc_Global.
  
  Module Impl_core_iter_traits_collect_FromIterator_alloc_string_String_for_alloc_boxed_Box_str_alloc_alloc_Global.
    Definition Self : Ty.t :=
      Ty.apply (Ty.path "alloc::boxed::Box") [] [ Ty.path "str"; Ty.path "alloc::alloc::Global" ].
    
    (*
        fn from_iter<T: IntoIterator<Item = String>>(iter: T) -> Self {
            String::from_iter(iter).into_boxed_str()
        }
    *)
    Definition from_iter (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [ T ], [ iter ] =>
        ltac:(M.monadic
          (let iter := M.alloc (| iter |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "alloc::string::String", "into_boxed_str", [] |),
            [
              M.call_closure (|
                M.get_trait_method (|
                  "core::iter::traits::collect::FromIterator",
                  Ty.path "alloc::string::String",
                  [ Ty.path "alloc::string::String" ],
                  "from_iter",
                  [ T ]
                |),
                [ M.read (| iter |) ]
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::iter::traits::collect::FromIterator"
        Self
        (* Trait polymorphic types *) [ (* A *) Ty.path "alloc::string::String" ]
        (* Instance *) [ ("from_iter", InstanceField.Method from_iter) ].
  End Impl_core_iter_traits_collect_FromIterator_alloc_string_String_for_alloc_boxed_Box_str_alloc_alloc_Global.
  
  Module Impl_core_iter_traits_collect_FromIterator_where_core_alloc_Allocator_A_alloc_boxed_Box_str_A_for_alloc_boxed_Box_str_alloc_alloc_Global.
    Definition Self (A : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "alloc::boxed::Box") [] [ Ty.path "str"; Ty.path "alloc::alloc::Global" ].
    
    (*
        fn from_iter<T: IntoIterator<Item = Box<str, A>>>(iter: T) -> Self {
            String::from_iter(iter).into_boxed_str()
        }
    *)
    Definition from_iter (A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self A in
      match ε, τ, α with
      | [], [ T ], [ iter ] =>
        ltac:(M.monadic
          (let iter := M.alloc (| iter |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "alloc::string::String", "into_boxed_str", [] |),
            [
              M.call_closure (|
                M.get_trait_method (|
                  "core::iter::traits::collect::FromIterator",
                  Ty.path "alloc::string::String",
                  [ Ty.apply (Ty.path "alloc::boxed::Box") [] [ Ty.path "str"; A ] ],
                  "from_iter",
                  [ T ]
                |),
                [ M.read (| iter |) ]
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (A : Ty.t),
      M.IsTraitInstance
        "core::iter::traits::collect::FromIterator"
        (Self A)
        (* Trait polymorphic types *)
        [ (* A *) Ty.apply (Ty.path "alloc::boxed::Box") [] [ Ty.path "str"; A ] ]
        (* Instance *) [ ("from_iter", InstanceField.Method (from_iter A)) ].
  End Impl_core_iter_traits_collect_FromIterator_where_core_alloc_Allocator_A_alloc_boxed_Box_str_A_for_alloc_boxed_Box_str_alloc_alloc_Global.
  
  Module Impl_core_iter_traits_collect_FromIterator_alloc_borrow_Cow_str_for_alloc_boxed_Box_str_alloc_alloc_Global.
    Definition Self : Ty.t :=
      Ty.apply (Ty.path "alloc::boxed::Box") [] [ Ty.path "str"; Ty.path "alloc::alloc::Global" ].
    
    (*
        fn from_iter<T: IntoIterator<Item = Cow<'a, str>>>(iter: T) -> Self {
            String::from_iter(iter).into_boxed_str()
        }
    *)
    Definition from_iter (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [ T ], [ iter ] =>
        ltac:(M.monadic
          (let iter := M.alloc (| iter |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "alloc::string::String", "into_boxed_str", [] |),
            [
              M.call_closure (|
                M.get_trait_method (|
                  "core::iter::traits::collect::FromIterator",
                  Ty.path "alloc::string::String",
                  [ Ty.apply (Ty.path "alloc::borrow::Cow") [] [ Ty.path "str" ] ],
                  "from_iter",
                  [ T ]
                |),
                [ M.read (| iter |) ]
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::iter::traits::collect::FromIterator"
        Self
        (* Trait polymorphic types *)
        [ (* A *) Ty.apply (Ty.path "alloc::borrow::Cow") [] [ Ty.path "str" ] ]
        (* Instance *) [ ("from_iter", InstanceField.Method from_iter) ].
  End Impl_core_iter_traits_collect_FromIterator_alloc_borrow_Cow_str_for_alloc_boxed_Box_str_alloc_alloc_Global.
  
  Module Impl_core_clone_Clone_where_core_clone_Clone_T_where_core_alloc_Allocator_A_where_core_clone_Clone_A_for_alloc_boxed_Box_slice_T_A.
    Definition Self (T A : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "alloc::boxed::Box") [] [ Ty.apply (Ty.path "slice") [] [ T ]; A ].
    
    (*
        fn clone(&self) -> Self {
            let alloc = Box::allocator(self).clone();
            self.to_vec_in(alloc).into_boxed_slice()
        }
    *)
    Definition clone (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            let~ alloc :=
              M.alloc (|
                M.call_closure (|
                  M.get_trait_method (| "core::clone::Clone", A, [], "clone", [] |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "alloc::boxed::Box")
                          []
                          [ Ty.apply (Ty.path "slice") [] [ T ]; A ],
                        "allocator",
                        []
                      |),
                      [ M.read (| self |) ]
                    |)
                  ]
                |)
              |) in
            M.alloc (|
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply (Ty.path "alloc::vec::Vec") [] [ T; A ],
                  "into_boxed_slice",
                  []
                |),
                [
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply (Ty.path "slice") [] [ T ],
                      "to_vec_in",
                      [ A ]
                    |),
                    [ M.read (| M.read (| self |) |); M.read (| alloc |) ]
                  |)
                ]
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    (*
        fn clone_from(&mut self, source: &Self) {
            if self.len() == source.len() {
                self.clone_from_slice(&source);
            } else {
                *self = source.clone();
            }
        }
    *)
    Definition clone_from (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ self; source ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let source := M.alloc (| source |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          BinOp.eq (|
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply (Ty.path "slice") [] [ T ],
                                "len",
                                []
                              |),
                              [ M.read (| M.read (| self |) |) ]
                            |),
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply (Ty.path "slice") [] [ T ],
                                "len",
                                []
                              |),
                              [ M.read (| M.read (| source |) |) ]
                            |)
                          |)
                        |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    let~ _ :=
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.apply (Ty.path "slice") [] [ T ],
                            "clone_from_slice",
                            []
                          |),
                          [ M.read (| M.read (| self |) |); M.read (| M.read (| source |) |) ]
                        |)
                      |) in
                    M.alloc (| Value.Tuple [] |)));
                fun γ =>
                  ltac:(M.monadic
                    (let~ _ :=
                      M.write (|
                        M.read (| self |),
                        M.call_closure (|
                          M.get_trait_method (|
                            "core::clone::Clone",
                            Ty.apply
                              (Ty.path "alloc::boxed::Box")
                              []
                              [ Ty.apply (Ty.path "slice") [] [ T ]; A ],
                            [],
                            "clone",
                            []
                          |),
                          [ M.read (| source |) ]
                        |)
                      |) in
                    M.alloc (| Value.Tuple [] |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (T A : Ty.t),
      M.IsTraitInstance
        "core::clone::Clone"
        (Self T A)
        (* Trait polymorphic types *) []
        (* Instance *)
        [
          ("clone", InstanceField.Method (clone T A));
          ("clone_from", InstanceField.Method (clone_from T A))
        ].
  End Impl_core_clone_Clone_where_core_clone_Clone_T_where_core_alloc_Allocator_A_where_core_clone_Clone_A_for_alloc_boxed_Box_slice_T_A.
  
  Module Impl_core_borrow_Borrow_where_core_marker_Sized_T_where_core_alloc_Allocator_A_T_for_alloc_boxed_Box_T_A.
    Definition Self (T A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::boxed::Box") [] [ T; A ].
    
    (*
        fn borrow(&self) -> &T {
            &**self
        }
    *)
    Definition borrow (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (| M.read (| self |) |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (T A : Ty.t),
      M.IsTraitInstance
        "core::borrow::Borrow"
        (Self T A)
        (* Trait polymorphic types *) [ (* Borrowed *) T ]
        (* Instance *) [ ("borrow", InstanceField.Method (borrow T A)) ].
  End Impl_core_borrow_Borrow_where_core_marker_Sized_T_where_core_alloc_Allocator_A_T_for_alloc_boxed_Box_T_A.
  
  Module Impl_core_borrow_BorrowMut_where_core_marker_Sized_T_where_core_alloc_Allocator_A_T_for_alloc_boxed_Box_T_A.
    Definition Self (T A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::boxed::Box") [] [ T; A ].
    
    (*
        fn borrow_mut(&mut self) -> &mut T {
            &mut **self
        }
    *)
    Definition borrow_mut (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (| M.read (| self |) |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (T A : Ty.t),
      M.IsTraitInstance
        "core::borrow::BorrowMut"
        (Self T A)
        (* Trait polymorphic types *) [ (* Borrowed *) T ]
        (* Instance *) [ ("borrow_mut", InstanceField.Method (borrow_mut T A)) ].
  End Impl_core_borrow_BorrowMut_where_core_marker_Sized_T_where_core_alloc_Allocator_A_T_for_alloc_boxed_Box_T_A.
  
  Module Impl_core_convert_AsRef_where_core_marker_Sized_T_where_core_alloc_Allocator_A_T_for_alloc_boxed_Box_T_A.
    Definition Self (T A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::boxed::Box") [] [ T; A ].
    
    (*
        fn as_ref(&self) -> &T {
            &**self
        }
    *)
    Definition as_ref (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (| M.read (| self |) |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (T A : Ty.t),
      M.IsTraitInstance
        "core::convert::AsRef"
        (Self T A)
        (* Trait polymorphic types *) [ (* T *) T ]
        (* Instance *) [ ("as_ref", InstanceField.Method (as_ref T A)) ].
  End Impl_core_convert_AsRef_where_core_marker_Sized_T_where_core_alloc_Allocator_A_T_for_alloc_boxed_Box_T_A.
  
  Module Impl_core_convert_AsMut_where_core_marker_Sized_T_where_core_alloc_Allocator_A_T_for_alloc_boxed_Box_T_A.
    Definition Self (T A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::boxed::Box") [] [ T; A ].
    
    (*
        fn as_mut(&mut self) -> &mut T {
            &mut **self
        }
    *)
    Definition as_mut (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (| M.read (| self |) |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (T A : Ty.t),
      M.IsTraitInstance
        "core::convert::AsMut"
        (Self T A)
        (* Trait polymorphic types *) [ (* T *) T ]
        (* Instance *) [ ("as_mut", InstanceField.Method (as_mut T A)) ].
  End Impl_core_convert_AsMut_where_core_marker_Sized_T_where_core_alloc_Allocator_A_T_for_alloc_boxed_Box_T_A.
  
  Module Impl_core_marker_Unpin_where_core_marker_Sized_T_where_core_alloc_Allocator_A_for_alloc_boxed_Box_T_A.
    Definition Self (T A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::boxed::Box") [] [ T; A ].
    
    Axiom Implements :
      forall (T A : Ty.t),
      M.IsTraitInstance
        "core::marker::Unpin"
        (Self T A)
        (* Trait polymorphic types *) []
        (* Instance *) [].
  End Impl_core_marker_Unpin_where_core_marker_Sized_T_where_core_alloc_Allocator_A_for_alloc_boxed_Box_T_A.
  
  Module Impl_core_ops_coroutine_Coroutine_where_core_marker_Sized_G_where_core_ops_coroutine_Coroutine_G_R_where_core_marker_Unpin_G_where_core_alloc_Allocator_A_R_for_alloc_boxed_Box_G_A.
    Definition Self (G R A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::boxed::Box") [] [ G; A ].
    
    (*     type Yield = G::Yield; *)
    Definition _Yield (G R A : Ty.t) : Ty.t := Ty.associated.
    
    (*     type Return = G::Return; *)
    Definition _Return (G R A : Ty.t) : Ty.t := Ty.associated.
    
    (*
        fn resume(mut self: Pin<&mut Self>, arg: R) -> CoroutineState<Self::Yield, Self::Return> {
            G::resume(Pin::new(&mut *self), arg)
        }
    *)
    Definition resume (G R A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self G R A in
      match ε, τ, α with
      | [], [], [ self; arg ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let arg := M.alloc (| arg |) in
          M.call_closure (|
            M.get_trait_method (| "core::ops::coroutine::Coroutine", G, [ R ], "resume", [] |),
            [
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply (Ty.path "core::pin::Pin") [] [ Ty.apply (Ty.path "&mut") [] [ G ] ],
                  "new",
                  []
                |),
                [
                  M.read (|
                    M.call_closure (|
                      M.get_trait_method (|
                        "core::ops::deref::DerefMut",
                        Ty.apply
                          (Ty.path "core::pin::Pin")
                          []
                          [
                            Ty.apply
                              (Ty.path "&mut")
                              []
                              [ Ty.apply (Ty.path "alloc::boxed::Box") [] [ G; A ] ]
                          ],
                        [],
                        "deref_mut",
                        []
                      |),
                      [ self ]
                    |)
                  |)
                ]
              |);
              M.read (| arg |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (G R A : Ty.t),
      M.IsTraitInstance
        "core::ops::coroutine::Coroutine"
        (Self G R A)
        (* Trait polymorphic types *) [ (* R *) R ]
        (* Instance *)
        [
          ("Yield", InstanceField.Ty (_Yield G R A));
          ("Return", InstanceField.Ty (_Return G R A));
          ("resume", InstanceField.Method (resume G R A))
        ].
  End Impl_core_ops_coroutine_Coroutine_where_core_marker_Sized_G_where_core_ops_coroutine_Coroutine_G_R_where_core_marker_Unpin_G_where_core_alloc_Allocator_A_R_for_alloc_boxed_Box_G_A.
  
  Module Impl_core_ops_coroutine_Coroutine_where_core_marker_Sized_G_where_core_ops_coroutine_Coroutine_G_R_where_core_alloc_Allocator_A_R_for_core_pin_Pin_alloc_boxed_Box_G_A.
    Definition Self (G R A : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "core::pin::Pin") [] [ Ty.apply (Ty.path "alloc::boxed::Box") [] [ G; A ] ].
    
    (*     type Yield = G::Yield; *)
    Definition _Yield (G R A : Ty.t) : Ty.t := Ty.associated.
    
    (*     type Return = G::Return; *)
    Definition _Return (G R A : Ty.t) : Ty.t := Ty.associated.
    
    (*
        fn resume(mut self: Pin<&mut Self>, arg: R) -> CoroutineState<Self::Yield, Self::Return> {
            G::resume(( *self).as_mut(), arg)
        }
    *)
    Definition resume (G R A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self G R A in
      match ε, τ, α with
      | [], [], [ self; arg ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let arg := M.alloc (| arg |) in
          M.call_closure (|
            M.get_trait_method (| "core::ops::coroutine::Coroutine", G, [ R ], "resume", [] |),
            [
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "core::pin::Pin")
                    []
                    [ Ty.apply (Ty.path "alloc::boxed::Box") [] [ G; A ] ],
                  "as_mut",
                  []
                |),
                [
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::deref::DerefMut",
                      Ty.apply
                        (Ty.path "core::pin::Pin")
                        []
                        [
                          Ty.apply
                            (Ty.path "&mut")
                            []
                            [
                              Ty.apply
                                (Ty.path "core::pin::Pin")
                                []
                                [ Ty.apply (Ty.path "alloc::boxed::Box") [] [ G; A ] ]
                            ]
                        ],
                      [],
                      "deref_mut",
                      []
                    |),
                    [ self ]
                  |)
                ]
              |);
              M.read (| arg |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (G R A : Ty.t),
      M.IsTraitInstance
        "core::ops::coroutine::Coroutine"
        (Self G R A)
        (* Trait polymorphic types *) [ (* R *) R ]
        (* Instance *)
        [
          ("Yield", InstanceField.Ty (_Yield G R A));
          ("Return", InstanceField.Ty (_Return G R A));
          ("resume", InstanceField.Method (resume G R A))
        ].
  End Impl_core_ops_coroutine_Coroutine_where_core_marker_Sized_G_where_core_ops_coroutine_Coroutine_G_R_where_core_alloc_Allocator_A_R_for_core_pin_Pin_alloc_boxed_Box_G_A.
  
  Module Impl_core_future_future_Future_where_core_marker_Sized_F_where_core_future_future_Future_F_where_core_marker_Unpin_F_where_core_alloc_Allocator_A_for_alloc_boxed_Box_F_A.
    Definition Self (F A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::boxed::Box") [] [ F; A ].
    
    (*     type Output = F::Output; *)
    Definition _Output (F A : Ty.t) : Ty.t := Ty.associated.
    
    (*
        fn poll(mut self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output> {
            F::poll(Pin::new(&mut *self), cx)
        }
    *)
    Definition poll (F A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self F A in
      match ε, τ, α with
      | [], [], [ self; cx ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let cx := M.alloc (| cx |) in
          M.call_closure (|
            M.get_trait_method (| "core::future::future::Future", F, [], "poll", [] |),
            [
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply (Ty.path "core::pin::Pin") [] [ Ty.apply (Ty.path "&mut") [] [ F ] ],
                  "new",
                  []
                |),
                [
                  M.read (|
                    M.call_closure (|
                      M.get_trait_method (|
                        "core::ops::deref::DerefMut",
                        Ty.apply
                          (Ty.path "core::pin::Pin")
                          []
                          [
                            Ty.apply
                              (Ty.path "&mut")
                              []
                              [ Ty.apply (Ty.path "alloc::boxed::Box") [] [ F; A ] ]
                          ],
                        [],
                        "deref_mut",
                        []
                      |),
                      [ self ]
                    |)
                  |)
                ]
              |);
              M.read (| cx |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (F A : Ty.t),
      M.IsTraitInstance
        "core::future::future::Future"
        (Self F A)
        (* Trait polymorphic types *) []
        (* Instance *)
        [ ("Output", InstanceField.Ty (_Output F A)); ("poll", InstanceField.Method (poll F A)) ].
  End Impl_core_future_future_Future_where_core_marker_Sized_F_where_core_future_future_Future_F_where_core_marker_Unpin_F_where_core_alloc_Allocator_A_for_alloc_boxed_Box_F_A.
  
  Module Impl_core_async_iter_async_iter_AsyncIterator_where_core_marker_Sized_S_where_core_async_iter_async_iter_AsyncIterator_S_where_core_marker_Unpin_S_for_alloc_boxed_Box_S_alloc_alloc_Global.
    Definition Self (S : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "alloc::boxed::Box") [] [ S; Ty.path "alloc::alloc::Global" ].
    
    (*     type Item = S::Item; *)
    Definition _Item (S : Ty.t) : Ty.t := Ty.associated.
    
    (*
        fn poll_next(mut self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Option<Self::Item>> {
            Pin::new(&mut **self).poll_next(cx)
        }
    *)
    Definition poll_next (S : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self S in
      match ε, τ, α with
      | [], [], [ self; cx ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let cx := M.alloc (| cx |) in
          M.call_closure (|
            M.get_trait_method (|
              "core::async_iter::async_iter::AsyncIterator",
              S,
              [],
              "poll_next",
              []
            |),
            [
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply (Ty.path "core::pin::Pin") [] [ Ty.apply (Ty.path "&mut") [] [ S ] ],
                  "new",
                  []
                |),
                [
                  M.read (|
                    M.call_closure (|
                      M.get_trait_method (|
                        "core::ops::deref::DerefMut",
                        Ty.apply
                          (Ty.path "core::pin::Pin")
                          []
                          [
                            Ty.apply
                              (Ty.path "&mut")
                              []
                              [
                                Ty.apply
                                  (Ty.path "alloc::boxed::Box")
                                  []
                                  [ S; Ty.path "alloc::alloc::Global" ]
                              ]
                          ],
                        [],
                        "deref_mut",
                        []
                      |),
                      [ self ]
                    |)
                  |)
                ]
              |);
              M.read (| cx |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    (*
        fn size_hint(&self) -> (usize, Option<usize>) {
            ( **self).size_hint()
        }
    *)
    Definition size_hint (S : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self S in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_trait_method (|
              "core::async_iter::async_iter::AsyncIterator",
              S,
              [],
              "size_hint",
              []
            |),
            [ M.read (| M.read (| self |) |) ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (S : Ty.t),
      M.IsTraitInstance
        "core::async_iter::async_iter::AsyncIterator"
        (Self S)
        (* Trait polymorphic types *) []
        (* Instance *)
        [
          ("Item", InstanceField.Ty (_Item S));
          ("poll_next", InstanceField.Method (poll_next S));
          ("size_hint", InstanceField.Method (size_hint S))
        ].
  End Impl_core_async_iter_async_iter_AsyncIterator_where_core_marker_Sized_S_where_core_async_iter_async_iter_AsyncIterator_S_where_core_marker_Unpin_S_for_alloc_boxed_Box_S_alloc_alloc_Global.
  
  Module Impl_Dyn_core_error_Error_Trait.
    Definition Self : Ty.t := Ty.dyn [ ("core::error::Error::Trait", []) ].
    
    (*
        pub fn downcast<T: Error + 'static>(self: Box<Self>) -> Result<Box<T>, Box<dyn Error>> {
            if self.is::<T>() {
                unsafe {
                    let raw: *mut dyn Error = Box::into_raw(self);
                    Ok(Box::from_raw(raw as *mut T))
                }
            } else {
                Err(self)
            }
        }
    *)
    Definition downcast (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [ T ], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.dyn [ ("core::error::Error::Trait", []) ],
                              "is",
                              [ T ]
                            |),
                            [ M.read (| self |) ]
                          |)
                        |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    let~ raw :=
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.apply
                              (Ty.path "alloc::boxed::Box")
                              []
                              [
                                Ty.dyn [ ("core::error::Error::Trait", []) ];
                                Ty.path "alloc::alloc::Global"
                              ],
                            "into_raw",
                            []
                          |),
                          [ M.read (| self |) ]
                        |)
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply
                                (Ty.path "alloc::boxed::Box")
                                []
                                [ T; Ty.path "alloc::alloc::Global" ],
                              "from_raw",
                              []
                            |),
                            [ M.rust_cast (M.read (| raw |)) ]
                          |)
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      Value.StructTuple "core::result::Result::Err" [ M.read (| self |) ]
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom AssociatedFunction_downcast : M.IsAssociatedFunction Self "downcast" downcast.
  End Impl_Dyn_core_error_Error_Trait.
  
  Module Impl_Dyn_core_error_Error_Trait_core_marker_Send_AutoTrait.
    Definition Self : Ty.t :=
      Ty.dyn [ ("core::error::Error::Trait", []); ("core::marker::Send::AutoTrait", []) ].
    
    (*
        pub fn downcast<T: Error + 'static>(self: Box<Self>) -> Result<Box<T>, Box<dyn Error + Send>> {
            let err: Box<dyn Error> = self;
            <dyn Error>::downcast(err).map_err(|s| unsafe {
                // Reapply the `Send` marker.
                mem::transmute::<Box<dyn Error>, Box<dyn Error + Send>>(s)
            })
        }
    *)
    Definition downcast (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [ T ], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            let~ err := M.alloc (| M.read (| self |) |) in
            M.alloc (|
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "core::result::Result")
                    []
                    [
                      Ty.apply
                        (Ty.path "alloc::boxed::Box")
                        []
                        [ T; Ty.path "alloc::alloc::Global" ];
                      Ty.apply
                        (Ty.path "alloc::boxed::Box")
                        []
                        [
                          Ty.dyn [ ("core::error::Error::Trait", []) ];
                          Ty.path "alloc::alloc::Global"
                        ]
                    ],
                  "map_err",
                  [
                    Ty.apply
                      (Ty.path "alloc::boxed::Box")
                      []
                      [
                        Ty.dyn
                          [ ("core::error::Error::Trait", []); ("core::marker::Send::AutoTrait", [])
                          ];
                        Ty.path "alloc::alloc::Global"
                      ];
                    Ty.function
                      [
                        Ty.tuple
                          [
                            Ty.apply
                              (Ty.path "alloc::boxed::Box")
                              []
                              [
                                Ty.dyn [ ("core::error::Error::Trait", []) ];
                                Ty.path "alloc::alloc::Global"
                              ]
                          ]
                      ]
                      (Ty.apply
                        (Ty.path "alloc::boxed::Box")
                        []
                        [
                          Ty.dyn
                            [
                              ("core::error::Error::Trait", []);
                              ("core::marker::Send::AutoTrait", [])
                            ];
                          Ty.path "alloc::alloc::Global"
                        ])
                  ]
                |),
                [
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.dyn [ ("core::error::Error::Trait", []) ],
                      "downcast",
                      [ T ]
                    |),
                    [ M.read (| err |) ]
                  |);
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0 ] =>
                          ltac:(M.monadic
                            (M.match_operator (|
                              M.alloc (| α0 |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let s := M.copy (| γ |) in
                                    M.call_closure (|
                                      M.get_function (|
                                        "core::intrinsics::transmute",
                                        [],
                                        [
                                          Ty.apply
                                            (Ty.path "alloc::boxed::Box")
                                            []
                                            [
                                              Ty.dyn [ ("core::error::Error::Trait", []) ];
                                              Ty.path "alloc::alloc::Global"
                                            ];
                                          Ty.apply
                                            (Ty.path "alloc::boxed::Box")
                                            []
                                            [
                                              Ty.dyn
                                                [
                                                  ("core::error::Error::Trait", []);
                                                  ("core::marker::Send::AutoTrait", [])
                                                ];
                                              Ty.path "alloc::alloc::Global"
                                            ]
                                        ]
                                      |),
                                      [ M.read (| s |) ]
                                    |)))
                              ]
                            |)))
                        | _ => M.impossible "wrong number of arguments"
                        end))
                ]
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom AssociatedFunction_downcast : M.IsAssociatedFunction Self "downcast" downcast.
  End Impl_Dyn_core_error_Error_Trait_core_marker_Send_AutoTrait.
  
  Module Impl_Dyn_core_error_Error_Trait_core_marker_Send_AutoTrait_core_marker_Sync_AutoTrait.
    Definition Self : Ty.t :=
      Ty.dyn
        [
          ("core::error::Error::Trait", []);
          ("core::marker::Send::AutoTrait", []);
          ("core::marker::Sync::AutoTrait", [])
        ].
    
    (*
        pub fn downcast<T: Error + 'static>(self: Box<Self>) -> Result<Box<T>, Box<Self>> {
            let err: Box<dyn Error> = self;
            <dyn Error>::downcast(err).map_err(|s| unsafe {
                // Reapply the `Send + Sync` markers.
                mem::transmute::<Box<dyn Error>, Box<dyn Error + Send + Sync>>(s)
            })
        }
    *)
    Definition downcast (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [ T ], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            let~ err := M.alloc (| M.read (| self |) |) in
            M.alloc (|
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "core::result::Result")
                    []
                    [
                      Ty.apply
                        (Ty.path "alloc::boxed::Box")
                        []
                        [ T; Ty.path "alloc::alloc::Global" ];
                      Ty.apply
                        (Ty.path "alloc::boxed::Box")
                        []
                        [
                          Ty.dyn [ ("core::error::Error::Trait", []) ];
                          Ty.path "alloc::alloc::Global"
                        ]
                    ],
                  "map_err",
                  [
                    Ty.apply
                      (Ty.path "alloc::boxed::Box")
                      []
                      [
                        Ty.dyn
                          [
                            ("core::error::Error::Trait", []);
                            ("core::marker::Send::AutoTrait", []);
                            ("core::marker::Sync::AutoTrait", [])
                          ];
                        Ty.path "alloc::alloc::Global"
                      ];
                    Ty.function
                      [
                        Ty.tuple
                          [
                            Ty.apply
                              (Ty.path "alloc::boxed::Box")
                              []
                              [
                                Ty.dyn [ ("core::error::Error::Trait", []) ];
                                Ty.path "alloc::alloc::Global"
                              ]
                          ]
                      ]
                      (Ty.apply
                        (Ty.path "alloc::boxed::Box")
                        []
                        [
                          Ty.dyn
                            [
                              ("core::error::Error::Trait", []);
                              ("core::marker::Send::AutoTrait", []);
                              ("core::marker::Sync::AutoTrait", [])
                            ];
                          Ty.path "alloc::alloc::Global"
                        ])
                  ]
                |),
                [
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.dyn [ ("core::error::Error::Trait", []) ],
                      "downcast",
                      [ T ]
                    |),
                    [ M.read (| err |) ]
                  |);
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0 ] =>
                          ltac:(M.monadic
                            (M.match_operator (|
                              M.alloc (| α0 |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let s := M.copy (| γ |) in
                                    M.call_closure (|
                                      M.get_function (|
                                        "core::intrinsics::transmute",
                                        [],
                                        [
                                          Ty.apply
                                            (Ty.path "alloc::boxed::Box")
                                            []
                                            [
                                              Ty.dyn [ ("core::error::Error::Trait", []) ];
                                              Ty.path "alloc::alloc::Global"
                                            ];
                                          Ty.apply
                                            (Ty.path "alloc::boxed::Box")
                                            []
                                            [
                                              Ty.dyn
                                                [
                                                  ("core::error::Error::Trait", []);
                                                  ("core::marker::Send::AutoTrait", []);
                                                  ("core::marker::Sync::AutoTrait", [])
                                                ];
                                              Ty.path "alloc::alloc::Global"
                                            ]
                                        ]
                                      |),
                                      [ M.read (| s |) ]
                                    |)))
                              ]
                            |)))
                        | _ => M.impossible "wrong number of arguments"
                        end))
                ]
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom AssociatedFunction_downcast : M.IsAssociatedFunction Self "downcast" downcast.
  End Impl_Dyn_core_error_Error_Trait_core_marker_Send_AutoTrait_core_marker_Sync_AutoTrait.
  
  Module Impl_core_convert_From_where_core_error_Error_E_E_for_alloc_boxed_Box_Dyn_core_error_Error_Trait_alloc_alloc_Global.
    Definition Self (E : Ty.t) : Ty.t :=
      Ty.apply
        (Ty.path "alloc::boxed::Box")
        []
        [ Ty.dyn [ ("core::error::Error::Trait", []) ]; Ty.path "alloc::alloc::Global" ].
    
    (*
        fn from(err: E) -> Box<dyn Error + 'a> {
            Box::new(err)
        }
    *)
    Definition from (E : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self E in
      match ε, τ, α with
      | [], [], [ err ] =>
        ltac:(M.monadic
          (let err := M.alloc (| err |) in
          M.call_closure (|
            M.get_associated_function (|
              Ty.apply (Ty.path "alloc::boxed::Box") [] [ E; Ty.path "alloc::alloc::Global" ],
              "new",
              []
            |),
            [ M.read (| err |) ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (E : Ty.t),
      M.IsTraitInstance
        "core::convert::From"
        (Self E)
        (* Trait polymorphic types *) [ (* T *) E ]
        (* Instance *) [ ("from", InstanceField.Method (from E)) ].
  End Impl_core_convert_From_where_core_error_Error_E_E_for_alloc_boxed_Box_Dyn_core_error_Error_Trait_alloc_alloc_Global.
  
  Module Impl_core_convert_From_where_core_error_Error_E_where_core_marker_Send_E_where_core_marker_Sync_E_E_for_alloc_boxed_Box_Dyn_core_error_Error_Trait_core_marker_Send_AutoTrait_core_marker_Sync_AutoTrait_alloc_alloc_Global.
    Definition Self (E : Ty.t) : Ty.t :=
      Ty.apply
        (Ty.path "alloc::boxed::Box")
        []
        [
          Ty.dyn
            [
              ("core::error::Error::Trait", []);
              ("core::marker::Send::AutoTrait", []);
              ("core::marker::Sync::AutoTrait", [])
            ];
          Ty.path "alloc::alloc::Global"
        ].
    
    (*
        fn from(err: E) -> Box<dyn Error + Send + Sync + 'a> {
            Box::new(err)
        }
    *)
    Definition from (E : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self E in
      match ε, τ, α with
      | [], [], [ err ] =>
        ltac:(M.monadic
          (let err := M.alloc (| err |) in
          M.call_closure (|
            M.get_associated_function (|
              Ty.apply (Ty.path "alloc::boxed::Box") [] [ E; Ty.path "alloc::alloc::Global" ],
              "new",
              []
            |),
            [ M.read (| err |) ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (E : Ty.t),
      M.IsTraitInstance
        "core::convert::From"
        (Self E)
        (* Trait polymorphic types *) [ (* T *) E ]
        (* Instance *) [ ("from", InstanceField.Method (from E)) ].
  End Impl_core_convert_From_where_core_error_Error_E_where_core_marker_Send_E_where_core_marker_Sync_E_E_for_alloc_boxed_Box_Dyn_core_error_Error_Trait_core_marker_Send_AutoTrait_core_marker_Sync_AutoTrait_alloc_alloc_Global.
  
  Module Impl_core_convert_From_alloc_string_String_for_alloc_boxed_Box_Dyn_core_error_Error_Trait_core_marker_Send_AutoTrait_core_marker_Sync_AutoTrait_alloc_alloc_Global.
    Definition Self : Ty.t :=
      Ty.apply
        (Ty.path "alloc::boxed::Box")
        []
        [
          Ty.dyn
            [
              ("core::error::Error::Trait", []);
              ("core::marker::Send::AutoTrait", []);
              ("core::marker::Sync::AutoTrait", [])
            ];
          Ty.path "alloc::alloc::Global"
        ].
    
    (*
        fn from(err: String) -> Box<dyn Error + Send + Sync + 'a> {
            struct StringError(String);
    
            impl Error for StringError {
                #[allow(deprecated)]
                fn description(&self) -> &str {
                    &self.0
                }
            }
    
            impl fmt::Display for StringError {
                fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                    fmt::Display::fmt(&self.0, f)
                }
            }
    
            // Purposefully skip printing "StringError(..)"
            impl fmt::Debug for StringError {
                fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                    fmt::Debug::fmt(&self.0, f)
                }
            }
    
            Box::new(StringError(err))
        }
    *)
    Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ err ] =>
        ltac:(M.monadic
          (let err := M.alloc (| err |) in
          M.call_closure (|
            M.get_associated_function (|
              Ty.apply
                (Ty.path "alloc::boxed::Box")
                []
                [ Ty.path "alloc::boxed::from::StringError"; Ty.path "alloc::alloc::Global" ],
              "new",
              []
            |),
            [ Value.StructTuple "alloc::boxed::from::StringError" [ M.read (| err |) ] ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::convert::From"
        Self
        (* Trait polymorphic types *) [ (* T *) Ty.path "alloc::string::String" ]
        (* Instance *) [ ("from", InstanceField.Method from) ].
  End Impl_core_convert_From_alloc_string_String_for_alloc_boxed_Box_Dyn_core_error_Error_Trait_core_marker_Send_AutoTrait_core_marker_Sync_AutoTrait_alloc_alloc_Global.
  
  Module Impl_core_convert_From_alloc_string_String_for_alloc_boxed_Box_Dyn_core_error_Error_Trait_alloc_alloc_Global.
    Definition Self : Ty.t :=
      Ty.apply
        (Ty.path "alloc::boxed::Box")
        []
        [ Ty.dyn [ ("core::error::Error::Trait", []) ]; Ty.path "alloc::alloc::Global" ].
    
    (*
        fn from(str_err: String) -> Box<dyn Error + 'a> {
            let err1: Box<dyn Error + Send + Sync> = From::from(str_err);
            let err2: Box<dyn Error> = err1;
            err2
        }
    *)
    Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ str_err ] =>
        ltac:(M.monadic
          (let str_err := M.alloc (| str_err |) in
          M.read (|
            let~ err1 :=
              M.alloc (|
                M.call_closure (|
                  M.get_trait_method (|
                    "core::convert::From",
                    Ty.apply
                      (Ty.path "alloc::boxed::Box")
                      []
                      [
                        Ty.dyn
                          [
                            ("core::error::Error::Trait", []);
                            ("core::marker::Send::AutoTrait", []);
                            ("core::marker::Sync::AutoTrait", [])
                          ];
                        Ty.path "alloc::alloc::Global"
                      ],
                    [ Ty.path "alloc::string::String" ],
                    "from",
                    []
                  |),
                  [ M.read (| str_err |) ]
                |)
              |) in
            let~ err2 := M.alloc (| M.read (| err1 |) |) in
            M.alloc (| M.read (| err2 |) |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::convert::From"
        Self
        (* Trait polymorphic types *) [ (* T *) Ty.path "alloc::string::String" ]
        (* Instance *) [ ("from", InstanceField.Method from) ].
  End Impl_core_convert_From_alloc_string_String_for_alloc_boxed_Box_Dyn_core_error_Error_Trait_alloc_alloc_Global.
  
  Module Impl_core_convert_From_ref__str_for_alloc_boxed_Box_Dyn_core_error_Error_Trait_core_marker_Send_AutoTrait_core_marker_Sync_AutoTrait_alloc_alloc_Global.
    Definition Self : Ty.t :=
      Ty.apply
        (Ty.path "alloc::boxed::Box")
        []
        [
          Ty.dyn
            [
              ("core::error::Error::Trait", []);
              ("core::marker::Send::AutoTrait", []);
              ("core::marker::Sync::AutoTrait", [])
            ];
          Ty.path "alloc::alloc::Global"
        ].
    
    (*
        fn from(err: &str) -> Box<dyn Error + Send + Sync + 'a> {
            From::from(String::from(err))
        }
    *)
    Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ err ] =>
        ltac:(M.monadic
          (let err := M.alloc (| err |) in
          M.call_closure (|
            M.get_trait_method (|
              "core::convert::From",
              Ty.apply
                (Ty.path "alloc::boxed::Box")
                []
                [
                  Ty.dyn
                    [
                      ("core::error::Error::Trait", []);
                      ("core::marker::Send::AutoTrait", []);
                      ("core::marker::Sync::AutoTrait", [])
                    ];
                  Ty.path "alloc::alloc::Global"
                ],
              [ Ty.path "alloc::string::String" ],
              "from",
              []
            |),
            [
              M.call_closure (|
                M.get_trait_method (|
                  "core::convert::From",
                  Ty.path "alloc::string::String",
                  [ Ty.apply (Ty.path "&") [] [ Ty.path "str" ] ],
                  "from",
                  []
                |),
                [ M.read (| err |) ]
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::convert::From"
        Self
        (* Trait polymorphic types *) [ (* T *) Ty.apply (Ty.path "&") [] [ Ty.path "str" ] ]
        (* Instance *) [ ("from", InstanceField.Method from) ].
  End Impl_core_convert_From_ref__str_for_alloc_boxed_Box_Dyn_core_error_Error_Trait_core_marker_Send_AutoTrait_core_marker_Sync_AutoTrait_alloc_alloc_Global.
  
  Module Impl_core_convert_From_ref__str_for_alloc_boxed_Box_Dyn_core_error_Error_Trait_alloc_alloc_Global.
    Definition Self : Ty.t :=
      Ty.apply
        (Ty.path "alloc::boxed::Box")
        []
        [ Ty.dyn [ ("core::error::Error::Trait", []) ]; Ty.path "alloc::alloc::Global" ].
    
    (*
        fn from(err: &str) -> Box<dyn Error + 'a> {
            From::from(String::from(err))
        }
    *)
    Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ err ] =>
        ltac:(M.monadic
          (let err := M.alloc (| err |) in
          M.call_closure (|
            M.get_trait_method (|
              "core::convert::From",
              Ty.apply
                (Ty.path "alloc::boxed::Box")
                []
                [ Ty.dyn [ ("core::error::Error::Trait", []) ]; Ty.path "alloc::alloc::Global" ],
              [ Ty.path "alloc::string::String" ],
              "from",
              []
            |),
            [
              M.call_closure (|
                M.get_trait_method (|
                  "core::convert::From",
                  Ty.path "alloc::string::String",
                  [ Ty.apply (Ty.path "&") [] [ Ty.path "str" ] ],
                  "from",
                  []
                |),
                [ M.read (| err |) ]
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::convert::From"
        Self
        (* Trait polymorphic types *) [ (* T *) Ty.apply (Ty.path "&") [] [ Ty.path "str" ] ]
        (* Instance *) [ ("from", InstanceField.Method from) ].
  End Impl_core_convert_From_ref__str_for_alloc_boxed_Box_Dyn_core_error_Error_Trait_alloc_alloc_Global.
  
  Module Impl_core_convert_From_alloc_borrow_Cow_str_for_alloc_boxed_Box_Dyn_core_error_Error_Trait_core_marker_Send_AutoTrait_core_marker_Sync_AutoTrait_alloc_alloc_Global.
    Definition Self : Ty.t :=
      Ty.apply
        (Ty.path "alloc::boxed::Box")
        []
        [
          Ty.dyn
            [
              ("core::error::Error::Trait", []);
              ("core::marker::Send::AutoTrait", []);
              ("core::marker::Sync::AutoTrait", [])
            ];
          Ty.path "alloc::alloc::Global"
        ].
    
    (*
        fn from(err: Cow<'b, str>) -> Box<dyn Error + Send + Sync + 'a> {
            From::from(String::from(err))
        }
    *)
    Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ err ] =>
        ltac:(M.monadic
          (let err := M.alloc (| err |) in
          M.call_closure (|
            M.get_trait_method (|
              "core::convert::From",
              Ty.apply
                (Ty.path "alloc::boxed::Box")
                []
                [
                  Ty.dyn
                    [
                      ("core::error::Error::Trait", []);
                      ("core::marker::Send::AutoTrait", []);
                      ("core::marker::Sync::AutoTrait", [])
                    ];
                  Ty.path "alloc::alloc::Global"
                ],
              [ Ty.path "alloc::string::String" ],
              "from",
              []
            |),
            [
              M.call_closure (|
                M.get_trait_method (|
                  "core::convert::From",
                  Ty.path "alloc::string::String",
                  [ Ty.apply (Ty.path "alloc::borrow::Cow") [] [ Ty.path "str" ] ],
                  "from",
                  []
                |),
                [ M.read (| err |) ]
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::convert::From"
        Self
        (* Trait polymorphic types *)
        [ (* T *) Ty.apply (Ty.path "alloc::borrow::Cow") [] [ Ty.path "str" ] ]
        (* Instance *) [ ("from", InstanceField.Method from) ].
  End Impl_core_convert_From_alloc_borrow_Cow_str_for_alloc_boxed_Box_Dyn_core_error_Error_Trait_core_marker_Send_AutoTrait_core_marker_Sync_AutoTrait_alloc_alloc_Global.
  
  Module Impl_core_convert_From_alloc_borrow_Cow_str_for_alloc_boxed_Box_Dyn_core_error_Error_Trait_alloc_alloc_Global.
    Definition Self : Ty.t :=
      Ty.apply
        (Ty.path "alloc::boxed::Box")
        []
        [ Ty.dyn [ ("core::error::Error::Trait", []) ]; Ty.path "alloc::alloc::Global" ].
    
    (*
        fn from(err: Cow<'b, str>) -> Box<dyn Error + 'a> {
            From::from(String::from(err))
        }
    *)
    Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ err ] =>
        ltac:(M.monadic
          (let err := M.alloc (| err |) in
          M.call_closure (|
            M.get_trait_method (|
              "core::convert::From",
              Ty.apply
                (Ty.path "alloc::boxed::Box")
                []
                [ Ty.dyn [ ("core::error::Error::Trait", []) ]; Ty.path "alloc::alloc::Global" ],
              [ Ty.path "alloc::string::String" ],
              "from",
              []
            |),
            [
              M.call_closure (|
                M.get_trait_method (|
                  "core::convert::From",
                  Ty.path "alloc::string::String",
                  [ Ty.apply (Ty.path "alloc::borrow::Cow") [] [ Ty.path "str" ] ],
                  "from",
                  []
                |),
                [ M.read (| err |) ]
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::convert::From"
        Self
        (* Trait polymorphic types *)
        [ (* T *) Ty.apply (Ty.path "alloc::borrow::Cow") [] [ Ty.path "str" ] ]
        (* Instance *) [ ("from", InstanceField.Method from) ].
  End Impl_core_convert_From_alloc_borrow_Cow_str_for_alloc_boxed_Box_Dyn_core_error_Error_Trait_alloc_alloc_Global.
  
  Module Impl_core_error_Error_where_core_error_Error_T_for_alloc_boxed_Box_T_alloc_alloc_Global.
    Definition Self (T : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "alloc::boxed::Box") [] [ T; Ty.path "alloc::alloc::Global" ].
    
    (*
        fn description(&self) -> &str {
            core::error::Error::description(&**self)
        }
    *)
    Definition description (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_trait_method (| "core::error::Error", T, [], "description", [] |),
            [ M.read (| M.read (| self |) |) ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    (*
        fn cause(&self) -> Option<&dyn core::error::Error> {
            core::error::Error::cause(&**self)
        }
    *)
    Definition cause (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_trait_method (| "core::error::Error", T, [], "cause", [] |),
            [ M.read (| M.read (| self |) |) ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    (*
        fn source(&self) -> Option<&(dyn core::error::Error + 'static)> {
            core::error::Error::source(&**self)
        }
    *)
    Definition source (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_trait_method (| "core::error::Error", T, [], "source", [] |),
            [ M.read (| M.read (| self |) |) ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    (*
        fn provide<'b>(&'b self, request: &mut core::error::Request<'b>) {
            core::error::Error::provide(&**self, request);
        }
    *)
    Definition provide (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [], [ self; request ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let request := M.alloc (| request |) in
          M.read (|
            let~ _ :=
              M.alloc (|
                M.call_closure (|
                  M.get_trait_method (| "core::error::Error", T, [], "provide", [] |),
                  [ M.read (| M.read (| self |) |); M.read (| request |) ]
                |)
              |) in
            M.alloc (| Value.Tuple [] |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "core::error::Error"
        (Self T)
        (* Trait polymorphic types *) []
        (* Instance *)
        [
          ("description", InstanceField.Method (description T));
          ("cause", InstanceField.Method (cause T));
          ("source", InstanceField.Method (source T));
          ("provide", InstanceField.Method (provide T))
        ].
  End Impl_core_error_Error_where_core_error_Error_T_for_alloc_boxed_Box_T_alloc_alloc_Global.
  
  Module Impl_core_pin_PinCoerceUnsized_where_core_marker_Sized_T_where_core_alloc_Allocator_A_for_alloc_boxed_Box_T_A.
    Definition Self (T A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::boxed::Box") [] [ T; A ].
    
    Axiom Implements :
      forall (T A : Ty.t),
      M.IsTraitInstance
        "core::pin::PinCoerceUnsized"
        (Self T A)
        (* Trait polymorphic types *) []
        (* Instance *) [].
  End Impl_core_pin_PinCoerceUnsized_where_core_marker_Sized_T_where_core_alloc_Allocator_A_for_alloc_boxed_Box_T_A.
End boxed.
