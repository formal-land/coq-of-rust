(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module boxed.
  (* StructTuple
    {
      name := "Box";
      const_params := [];
      ty_params := [ "T"; "A" ];
      fields := [ Ty.apply (Ty.path "core::ptr::unique::Unique") [] [ T ]; A ];
    } *)
  
  Module Impl_alloc_boxed_Box_T_alloc_alloc_Global.
    Definition Self (T : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "alloc::boxed::Box") [] [ T; Ty.path "alloc::alloc::Global" ].
    
    (*
        pub fn new(x: T) -> Self {
            #[rustc_box]
            Box::new(x)
        }
    *)
    Definition new (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [], [ x ] =>
        ltac:(M.monadic
          (let x := M.alloc (| x |) in
          M.read (|
            M.call_closure (|
              Ty.apply (Ty.path "alloc::boxed::Box") [] [ T; Ty.path "alloc::alloc::Global" ],
              M.get_associated_function (|
                Ty.apply (Ty.path "alloc::boxed::Box") [] [ T; Ty.path "alloc::alloc::Global" ],
                "new",
                [],
                []
              |),
              [ x ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_new :
      forall (T : Ty.t),
      M.IsAssociatedFunction.Trait (Self T) "new" (new T).
    Admitted.
    Global Typeclasses Opaque new.
    
    (*
        pub fn new_uninit() -> Box<mem::MaybeUninit<T>> {
            Self::new_uninit_in(Global)
        }
    *)
    Definition new_uninit (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [], [] =>
        ltac:(M.monadic
          (M.call_closure (|
            Ty.apply
              (Ty.path "alloc::boxed::Box")
              []
              [
                Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ];
                Ty.path "alloc::alloc::Global"
              ],
            M.get_associated_function (|
              Ty.apply (Ty.path "alloc::boxed::Box") [] [ T; Ty.path "alloc::alloc::Global" ],
              "new_uninit_in",
              [],
              []
            |),
            [ Value.StructTuple "alloc::alloc::Global" [] ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_new_uninit :
      forall (T : Ty.t),
      M.IsAssociatedFunction.Trait (Self T) "new_uninit" (new_uninit T).
    Admitted.
    Global Typeclasses Opaque new_uninit.
    
    (*
        pub fn new_zeroed() -> Box<mem::MaybeUninit<T>> {
            Self::new_zeroed_in(Global)
        }
    *)
    Definition new_zeroed (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [], [] =>
        ltac:(M.monadic
          (M.call_closure (|
            Ty.apply
              (Ty.path "alloc::boxed::Box")
              []
              [
                Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ];
                Ty.path "alloc::alloc::Global"
              ],
            M.get_associated_function (|
              Ty.apply (Ty.path "alloc::boxed::Box") [] [ T; Ty.path "alloc::alloc::Global" ],
              "new_zeroed_in",
              [],
              []
            |),
            [ Value.StructTuple "alloc::alloc::Global" [] ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_new_zeroed :
      forall (T : Ty.t),
      M.IsAssociatedFunction.Trait (Self T) "new_zeroed" (new_zeroed T).
    Admitted.
    Global Typeclasses Opaque new_zeroed.
    
    (*
        pub fn pin(x: T) -> Pin<Box<T>> {
            Box::new(x).into()
        }
    *)
    Definition pin (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [], [ x ] =>
        ltac:(M.monadic
          (let x := M.alloc (| x |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "core::pin::Pin")
              []
              [ Ty.apply (Ty.path "alloc::boxed::Box") [] [ T; Ty.path "alloc::alloc::Global" ] ],
            M.get_trait_method (|
              "core::convert::Into",
              Ty.apply (Ty.path "alloc::boxed::Box") [] [ T; Ty.path "alloc::alloc::Global" ],
              [],
              [
                Ty.apply
                  (Ty.path "core::pin::Pin")
                  []
                  [ Ty.apply (Ty.path "alloc::boxed::Box") [] [ T; Ty.path "alloc::alloc::Global" ]
                  ]
              ],
              "into",
              [],
              []
            |),
            [
              M.call_closure (|
                Ty.apply (Ty.path "alloc::boxed::Box") [] [ T; Ty.path "alloc::alloc::Global" ],
                M.get_associated_function (|
                  Ty.apply (Ty.path "alloc::boxed::Box") [] [ T; Ty.path "alloc::alloc::Global" ],
                  "new",
                  [],
                  []
                |),
                [ M.read (| x |) ]
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_pin :
      forall (T : Ty.t),
      M.IsAssociatedFunction.Trait (Self T) "pin" (pin T).
    Admitted.
    Global Typeclasses Opaque pin.
    
    (*
        pub fn try_new(x: T) -> Result<Self, AllocError> {
            Self::try_new_in(x, Global)
        }
    *)
    Definition try_new (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [], [ x ] =>
        ltac:(M.monadic
          (let x := M.alloc (| x |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "core::result::Result")
              []
              [
                Ty.apply (Ty.path "alloc::boxed::Box") [] [ T; Ty.path "alloc::alloc::Global" ];
                Ty.path "core::alloc::AllocError"
              ],
            M.get_associated_function (|
              Ty.apply (Ty.path "alloc::boxed::Box") [] [ T; Ty.path "alloc::alloc::Global" ],
              "try_new_in",
              [],
              []
            |),
            [ M.read (| x |); Value.StructTuple "alloc::alloc::Global" [] ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_try_new :
      forall (T : Ty.t),
      M.IsAssociatedFunction.Trait (Self T) "try_new" (try_new T).
    Admitted.
    Global Typeclasses Opaque try_new.
    
    (*
        pub fn try_new_uninit() -> Result<Box<mem::MaybeUninit<T>>, AllocError> {
            Box::try_new_uninit_in(Global)
        }
    *)
    Definition try_new_uninit
        (T : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [], [] =>
        ltac:(M.monadic
          (M.call_closure (|
            Ty.apply
              (Ty.path "core::result::Result")
              []
              [
                Ty.apply
                  (Ty.path "alloc::boxed::Box")
                  []
                  [
                    Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ];
                    Ty.path "alloc::alloc::Global"
                  ];
                Ty.path "core::alloc::AllocError"
              ],
            M.get_associated_function (|
              Ty.apply (Ty.path "alloc::boxed::Box") [] [ T; Ty.path "alloc::alloc::Global" ],
              "try_new_uninit_in",
              [],
              []
            |),
            [ Value.StructTuple "alloc::alloc::Global" [] ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_try_new_uninit :
      forall (T : Ty.t),
      M.IsAssociatedFunction.Trait (Self T) "try_new_uninit" (try_new_uninit T).
    Admitted.
    Global Typeclasses Opaque try_new_uninit.
    
    (*
        pub fn try_new_zeroed() -> Result<Box<mem::MaybeUninit<T>>, AllocError> {
            Box::try_new_zeroed_in(Global)
        }
    *)
    Definition try_new_zeroed
        (T : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [], [] =>
        ltac:(M.monadic
          (M.call_closure (|
            Ty.apply
              (Ty.path "core::result::Result")
              []
              [
                Ty.apply
                  (Ty.path "alloc::boxed::Box")
                  []
                  [
                    Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ];
                    Ty.path "alloc::alloc::Global"
                  ];
                Ty.path "core::alloc::AllocError"
              ],
            M.get_associated_function (|
              Ty.apply (Ty.path "alloc::boxed::Box") [] [ T; Ty.path "alloc::alloc::Global" ],
              "try_new_zeroed_in",
              [],
              []
            |),
            [ Value.StructTuple "alloc::alloc::Global" [] ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_try_new_zeroed :
      forall (T : Ty.t),
      M.IsAssociatedFunction.Trait (Self T) "try_new_zeroed" (try_new_zeroed T).
    Admitted.
    Global Typeclasses Opaque try_new_zeroed.
    (*
        pub unsafe fn from_raw(raw: *mut T) -> Self {
            unsafe { Self::from_raw_in(raw, Global) }
        }
    *)
    Definition from_raw (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [], [ raw ] =>
        ltac:(M.monadic
          (let raw := M.alloc (| raw |) in
          M.call_closure (|
            Ty.apply (Ty.path "alloc::boxed::Box") [] [ T; Ty.path "alloc::alloc::Global" ],
            M.get_associated_function (|
              Ty.apply (Ty.path "alloc::boxed::Box") [] [ T; Ty.path "alloc::alloc::Global" ],
              "from_raw_in",
              [],
              []
            |),
            [ M.read (| raw |); Value.StructTuple "alloc::alloc::Global" [] ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_from_raw :
      forall (T : Ty.t),
      M.IsAssociatedFunction.Trait (Self T) "from_raw" (from_raw T).
    Admitted.
    Global Typeclasses Opaque from_raw.
    
    (*
        pub unsafe fn from_non_null(ptr: NonNull<T>) -> Self {
            unsafe { Self::from_raw(ptr.as_ptr()) }
        }
    *)
    Definition from_non_null (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [], [ ptr ] =>
        ltac:(M.monadic
          (let ptr := M.alloc (| ptr |) in
          M.call_closure (|
            Ty.apply (Ty.path "alloc::boxed::Box") [] [ T; Ty.path "alloc::alloc::Global" ],
            M.get_associated_function (|
              Ty.apply (Ty.path "alloc::boxed::Box") [] [ T; Ty.path "alloc::alloc::Global" ],
              "from_raw",
              [],
              []
            |),
            [
              M.call_closure (|
                Ty.apply (Ty.path "*mut") [] [ T ],
                M.get_associated_function (|
                  Ty.apply (Ty.path "core::ptr::non_null::NonNull") [] [ T ],
                  "as_ptr",
                  [],
                  []
                |),
                [ M.read (| ptr |) ]
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_from_non_null :
      forall (T : Ty.t),
      M.IsAssociatedFunction.Trait (Self T) "from_non_null" (from_non_null T).
    Admitted.
    Global Typeclasses Opaque from_non_null.
  End Impl_alloc_boxed_Box_T_alloc_alloc_Global.
  
  Module Impl_alloc_boxed_Box_T_A.
    Definition Self (T A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::boxed::Box") [] [ T; A ].
    
    (*
        pub fn new_in(x: T, alloc: A) -> Self
        where
            A: Allocator,
        {
            let mut boxed = Self::new_uninit_in(alloc);
            unsafe {
                boxed.as_mut_ptr().write(x);
                boxed.assume_init()
            }
        }
    *)
    Definition new_in (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ x; alloc ] =>
        ltac:(M.monadic
          (let x := M.alloc (| x |) in
          let alloc := M.alloc (| alloc |) in
          M.read (|
            let~ boxed :
                Ty.apply
                  (Ty.path "alloc::boxed::Box")
                  []
                  [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ]; A ] :=
              M.alloc (|
                M.call_closure (|
                  Ty.apply
                    (Ty.path "alloc::boxed::Box")
                    []
                    [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ]; A ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "alloc::boxed::Box") [] [ T; A ],
                    "new_uninit_in",
                    [],
                    []
                  |),
                  [ M.read (| alloc |) ]
                |)
              |) in
            let~ _ : Ty.tuple [] :=
              M.alloc (|
                M.call_closure (|
                  Ty.tuple [],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "*mut") [] [ T ],
                    "write",
                    [],
                    []
                  |),
                  [
                    M.call_closure (|
                      Ty.apply (Ty.path "*mut") [] [ T ],
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ],
                        "as_mut_ptr",
                        [],
                        []
                      |),
                      [ M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| boxed |) |) |) ]
                    |);
                    M.read (| x |)
                  ]
                |)
              |) in
            M.alloc (|
              M.call_closure (|
                Ty.apply (Ty.path "alloc::boxed::Box") [] [ T; A ],
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "alloc::boxed::Box")
                    []
                    [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ]; A ],
                  "assume_init",
                  [],
                  []
                |),
                [ M.read (| boxed |) ]
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_new_in :
      forall (T A : Ty.t),
      M.IsAssociatedFunction.Trait (Self T A) "new_in" (new_in T A).
    Admitted.
    Global Typeclasses Opaque new_in.
    
    (*
        pub fn try_new_in(x: T, alloc: A) -> Result<Self, AllocError>
        where
            A: Allocator,
        {
            let mut boxed = Self::try_new_uninit_in(alloc)?;
            unsafe {
                boxed.as_mut_ptr().write(x);
                Ok(boxed.assume_init())
            }
        }
    *)
    Definition try_new_in (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ x; alloc ] =>
        ltac:(M.monadic
          (let x := M.alloc (| x |) in
          let alloc := M.alloc (| alloc |) in
          M.catch_return (|
            ltac:(M.monadic
              (M.read (|
                let~ boxed :
                    Ty.apply
                      (Ty.path "alloc::boxed::Box")
                      []
                      [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ]; A ] :=
                  M.copy (|
                    M.match_operator (|
                      Some
                        (Ty.apply
                          (Ty.path "alloc::boxed::Box")
                          []
                          [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ]; A
                          ]),
                      M.alloc (|
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "core::ops::control_flow::ControlFlow")
                            []
                            [
                              Ty.apply
                                (Ty.path "core::result::Result")
                                []
                                [
                                  Ty.path "core::convert::Infallible";
                                  Ty.path "core::alloc::AllocError"
                                ];
                              Ty.apply
                                (Ty.path "alloc::boxed::Box")
                                []
                                [
                                  Ty.apply
                                    (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                    []
                                    [ T ];
                                  A
                                ]
                            ],
                          M.get_trait_method (|
                            "core::ops::try_trait::Try",
                            Ty.apply
                              (Ty.path "core::result::Result")
                              []
                              [
                                Ty.apply
                                  (Ty.path "alloc::boxed::Box")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                      []
                                      [ T ];
                                    A
                                  ];
                                Ty.path "core::alloc::AllocError"
                              ],
                            [],
                            [],
                            "branch",
                            [],
                            []
                          |),
                          [
                            M.call_closure (|
                              Ty.apply
                                (Ty.path "core::result::Result")
                                []
                                [
                                  Ty.apply
                                    (Ty.path "alloc::boxed::Box")
                                    []
                                    [
                                      Ty.apply
                                        (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                        []
                                        [ T ];
                                      A
                                    ];
                                  Ty.path "core::alloc::AllocError"
                                ],
                              M.get_associated_function (|
                                Ty.apply (Ty.path "alloc::boxed::Box") [] [ T; A ],
                                "try_new_uninit_in",
                                [],
                                []
                              |),
                              [ M.read (| alloc |) ]
                            |)
                          ]
                        |)
                      |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "core::ops::control_flow::ControlFlow::Break",
                                0
                              |) in
                            let residual := M.copy (| γ0_0 |) in
                            M.alloc (|
                              M.never_to_any (|
                                M.read (|
                                  M.return_ (|
                                    M.call_closure (|
                                      Ty.apply
                                        (Ty.path "core::result::Result")
                                        []
                                        [
                                          Ty.apply (Ty.path "alloc::boxed::Box") [] [ T; A ];
                                          Ty.path "core::alloc::AllocError"
                                        ],
                                      M.get_trait_method (|
                                        "core::ops::try_trait::FromResidual",
                                        Ty.apply
                                          (Ty.path "core::result::Result")
                                          []
                                          [
                                            Ty.apply (Ty.path "alloc::boxed::Box") [] [ T; A ];
                                            Ty.path "core::alloc::AllocError"
                                          ],
                                        [],
                                        [
                                          Ty.apply
                                            (Ty.path "core::result::Result")
                                            []
                                            [
                                              Ty.path "core::convert::Infallible";
                                              Ty.path "core::alloc::AllocError"
                                            ]
                                        ],
                                        "from_residual",
                                        [],
                                        []
                                      |),
                                      [ M.read (| residual |) ]
                                    |)
                                  |)
                                |)
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "core::ops::control_flow::ControlFlow::Continue",
                                0
                              |) in
                            let val := M.copy (| γ0_0 |) in
                            val))
                      ]
                    |)
                  |) in
                let~ _ : Ty.tuple [] :=
                  M.alloc (|
                    M.call_closure (|
                      Ty.tuple [],
                      M.get_associated_function (|
                        Ty.apply (Ty.path "*mut") [] [ T ],
                        "write",
                        [],
                        []
                      |),
                      [
                        M.call_closure (|
                          Ty.apply (Ty.path "*mut") [] [ T ],
                          M.get_associated_function (|
                            Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ],
                            "as_mut_ptr",
                            [],
                            []
                          |),
                          [ M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| boxed |) |) |) ]
                        |);
                        M.read (| x |)
                      ]
                    |)
                  |) in
                M.alloc (|
                  Value.StructTuple
                    "core::result::Result::Ok"
                    [
                      M.call_closure (|
                        Ty.apply (Ty.path "alloc::boxed::Box") [] [ T; A ],
                        M.get_associated_function (|
                          Ty.apply
                            (Ty.path "alloc::boxed::Box")
                            []
                            [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ]; A
                            ],
                          "assume_init",
                          [],
                          []
                        |),
                        [ M.read (| boxed |) ]
                      |)
                    ]
                |)
              |)))
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_try_new_in :
      forall (T A : Ty.t),
      M.IsAssociatedFunction.Trait (Self T A) "try_new_in" (try_new_in T A).
    Admitted.
    Global Typeclasses Opaque try_new_in.
    
    (*
        pub fn new_uninit_in(alloc: A) -> Box<mem::MaybeUninit<T>, A>
        where
            A: Allocator,
        {
            let layout = Layout::new::<mem::MaybeUninit<T>>();
            // NOTE: Prefer match over unwrap_or_else since closure sometimes not inlineable.
            // That would make code size bigger.
            match Box::try_new_uninit_in(alloc) {
                Ok(m) => m,
                Err(_) => handle_alloc_error(layout),
            }
        }
    *)
    Definition new_uninit_in
        (T A : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ alloc ] =>
        ltac:(M.monadic
          (let alloc := M.alloc (| alloc |) in
          M.read (|
            let~ layout : Ty.path "core::alloc::layout::Layout" :=
              M.alloc (|
                M.call_closure (|
                  Ty.path "core::alloc::layout::Layout",
                  M.get_associated_function (|
                    Ty.path "core::alloc::layout::Layout",
                    "new",
                    [],
                    [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ] ]
                  |),
                  []
                |)
              |) in
            M.match_operator (|
              Some
                (Ty.apply
                  (Ty.path "alloc::boxed::Box")
                  []
                  [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ]; A ]),
              M.alloc (|
                M.call_closure (|
                  Ty.apply
                    (Ty.path "core::result::Result")
                    []
                    [
                      Ty.apply
                        (Ty.path "alloc::boxed::Box")
                        []
                        [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ]; A ];
                      Ty.path "core::alloc::AllocError"
                    ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "alloc::boxed::Box") [] [ T; A ],
                    "try_new_uninit_in",
                    [],
                    []
                  |),
                  [ M.read (| alloc |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 :=
                      M.SubPointer.get_struct_tuple_field (| γ, "core::result::Result::Ok", 0 |) in
                    let m := M.copy (| γ0_0 |) in
                    m));
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 :=
                      M.SubPointer.get_struct_tuple_field (| γ, "core::result::Result::Err", 0 |) in
                    M.alloc (|
                      M.never_to_any (|
                        M.call_closure (|
                          Ty.path "never",
                          M.get_function (| "alloc::alloc::handle_alloc_error", [], [] |),
                          [ M.read (| layout |) ]
                        |)
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_new_uninit_in :
      forall (T A : Ty.t),
      M.IsAssociatedFunction.Trait (Self T A) "new_uninit_in" (new_uninit_in T A).
    Admitted.
    Global Typeclasses Opaque new_uninit_in.
    
    (*
        pub fn try_new_uninit_in(alloc: A) -> Result<Box<mem::MaybeUninit<T>, A>, AllocError>
        where
            A: Allocator,
        {
            let ptr = if T::IS_ZST {
                NonNull::dangling()
            } else {
                let layout = Layout::new::<mem::MaybeUninit<T>>();
                alloc.allocate(layout)?.cast()
            };
            unsafe { Ok(Box::from_raw_in(ptr.as_ptr(), alloc)) }
        }
    *)
    Definition try_new_uninit_in
        (T A : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ alloc ] =>
        ltac:(M.monadic
          (let alloc := M.alloc (| alloc |) in
          M.catch_return (|
            ltac:(M.monadic
              (M.read (|
                let~ ptr :
                    Ty.apply
                      (Ty.path "core::ptr::non_null::NonNull")
                      []
                      [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ] ] :=
                  M.copy (|
                    M.match_operator (|
                      Some
                        (Ty.apply
                          (Ty.path "core::ptr::non_null::NonNull")
                          []
                          [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ] ]),
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use (M.get_constant "core::mem::SizedTypeProperties::IS_ZST") in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (|
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "core::ptr::non_null::NonNull")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                      []
                                      [ T ]
                                  ],
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "core::ptr::non_null::NonNull")
                                    []
                                    [
                                      Ty.apply
                                        (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                        []
                                        [ T ]
                                    ],
                                  "dangling",
                                  [],
                                  []
                                |),
                                []
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let~ layout : Ty.path "core::alloc::layout::Layout" :=
                              M.alloc (|
                                M.call_closure (|
                                  Ty.path "core::alloc::layout::Layout",
                                  M.get_associated_function (|
                                    Ty.path "core::alloc::layout::Layout",
                                    "new",
                                    [],
                                    [
                                      Ty.apply
                                        (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                        []
                                        [ T ]
                                    ]
                                  |),
                                  []
                                |)
                              |) in
                            M.alloc (|
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "core::ptr::non_null::NonNull")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                      []
                                      [ T ]
                                  ],
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "core::ptr::non_null::NonNull")
                                    []
                                    [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                                  "cast",
                                  [],
                                  [
                                    Ty.apply
                                      (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                      []
                                      [ T ]
                                  ]
                                |),
                                [
                                  M.read (|
                                    M.match_operator (|
                                      Some
                                        (Ty.apply
                                          (Ty.path "core::ptr::non_null::NonNull")
                                          []
                                          [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]),
                                      M.alloc (|
                                        M.call_closure (|
                                          Ty.apply
                                            (Ty.path "core::ops::control_flow::ControlFlow")
                                            []
                                            [
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                []
                                                [
                                                  Ty.path "core::convert::Infallible";
                                                  Ty.path "core::alloc::AllocError"
                                                ];
                                              Ty.apply
                                                (Ty.path "core::ptr::non_null::NonNull")
                                                []
                                                [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
                                            ],
                                          M.get_trait_method (|
                                            "core::ops::try_trait::Try",
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "core::ptr::non_null::NonNull")
                                                  []
                                                  [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ]
                                                  ];
                                                Ty.path "core::alloc::AllocError"
                                              ],
                                            [],
                                            [],
                                            "branch",
                                            [],
                                            []
                                          |),
                                          [
                                            M.call_closure (|
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path "core::ptr::non_null::NonNull")
                                                    []
                                                    [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ]
                                                    ];
                                                  Ty.path "core::alloc::AllocError"
                                                ],
                                              M.get_trait_method (|
                                                "core::alloc::Allocator",
                                                A,
                                                [],
                                                [],
                                                "allocate",
                                                [],
                                                []
                                              |),
                                              [
                                                M.borrow (| Pointer.Kind.Ref, alloc |);
                                                M.read (| layout |)
                                              ]
                                            |)
                                          ]
                                        |)
                                      |),
                                      [
                                        fun γ =>
                                          ltac:(M.monadic
                                            (let γ0_0 :=
                                              M.SubPointer.get_struct_tuple_field (|
                                                γ,
                                                "core::ops::control_flow::ControlFlow::Break",
                                                0
                                              |) in
                                            let residual := M.copy (| γ0_0 |) in
                                            M.alloc (|
                                              M.never_to_any (|
                                                M.read (|
                                                  M.return_ (|
                                                    M.call_closure (|
                                                      Ty.apply
                                                        (Ty.path "core::result::Result")
                                                        []
                                                        [
                                                          Ty.apply
                                                            (Ty.path "alloc::boxed::Box")
                                                            []
                                                            [
                                                              Ty.apply
                                                                (Ty.path
                                                                  "core::mem::maybe_uninit::MaybeUninit")
                                                                []
                                                                [ T ];
                                                              A
                                                            ];
                                                          Ty.path "core::alloc::AllocError"
                                                        ],
                                                      M.get_trait_method (|
                                                        "core::ops::try_trait::FromResidual",
                                                        Ty.apply
                                                          (Ty.path "core::result::Result")
                                                          []
                                                          [
                                                            Ty.apply
                                                              (Ty.path "alloc::boxed::Box")
                                                              []
                                                              [
                                                                Ty.apply
                                                                  (Ty.path
                                                                    "core::mem::maybe_uninit::MaybeUninit")
                                                                  []
                                                                  [ T ];
                                                                A
                                                              ];
                                                            Ty.path "core::alloc::AllocError"
                                                          ],
                                                        [],
                                                        [
                                                          Ty.apply
                                                            (Ty.path "core::result::Result")
                                                            []
                                                            [
                                                              Ty.path "core::convert::Infallible";
                                                              Ty.path "core::alloc::AllocError"
                                                            ]
                                                        ],
                                                        "from_residual",
                                                        [],
                                                        []
                                                      |),
                                                      [ M.read (| residual |) ]
                                                    |)
                                                  |)
                                                |)
                                              |)
                                            |)));
                                        fun γ =>
                                          ltac:(M.monadic
                                            (let γ0_0 :=
                                              M.SubPointer.get_struct_tuple_field (|
                                                γ,
                                                "core::ops::control_flow::ControlFlow::Continue",
                                                0
                                              |) in
                                            let val := M.copy (| γ0_0 |) in
                                            val))
                                      ]
                                    |)
                                  |)
                                ]
                              |)
                            |)))
                      ]
                    |)
                  |) in
                M.alloc (|
                  Value.StructTuple
                    "core::result::Result::Ok"
                    [
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "alloc::boxed::Box")
                          []
                          [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ]; A ],
                        M.get_associated_function (|
                          Ty.apply
                            (Ty.path "alloc::boxed::Box")
                            []
                            [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ]; A
                            ],
                          "from_raw_in",
                          [],
                          []
                        |),
                        [
                          M.call_closure (|
                            Ty.apply
                              (Ty.path "*mut")
                              []
                              [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ]
                              ],
                            M.get_associated_function (|
                              Ty.apply
                                (Ty.path "core::ptr::non_null::NonNull")
                                []
                                [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ]
                                ],
                              "as_ptr",
                              [],
                              []
                            |),
                            [ M.read (| ptr |) ]
                          |);
                          M.read (| alloc |)
                        ]
                      |)
                    ]
                |)
              |)))
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_try_new_uninit_in :
      forall (T A : Ty.t),
      M.IsAssociatedFunction.Trait (Self T A) "try_new_uninit_in" (try_new_uninit_in T A).
    Admitted.
    Global Typeclasses Opaque try_new_uninit_in.
    
    (*
        pub fn new_zeroed_in(alloc: A) -> Box<mem::MaybeUninit<T>, A>
        where
            A: Allocator,
        {
            let layout = Layout::new::<mem::MaybeUninit<T>>();
            // NOTE: Prefer match over unwrap_or_else since closure sometimes not inlineable.
            // That would make code size bigger.
            match Box::try_new_zeroed_in(alloc) {
                Ok(m) => m,
                Err(_) => handle_alloc_error(layout),
            }
        }
    *)
    Definition new_zeroed_in
        (T A : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ alloc ] =>
        ltac:(M.monadic
          (let alloc := M.alloc (| alloc |) in
          M.read (|
            let~ layout : Ty.path "core::alloc::layout::Layout" :=
              M.alloc (|
                M.call_closure (|
                  Ty.path "core::alloc::layout::Layout",
                  M.get_associated_function (|
                    Ty.path "core::alloc::layout::Layout",
                    "new",
                    [],
                    [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ] ]
                  |),
                  []
                |)
              |) in
            M.match_operator (|
              Some
                (Ty.apply
                  (Ty.path "alloc::boxed::Box")
                  []
                  [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ]; A ]),
              M.alloc (|
                M.call_closure (|
                  Ty.apply
                    (Ty.path "core::result::Result")
                    []
                    [
                      Ty.apply
                        (Ty.path "alloc::boxed::Box")
                        []
                        [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ]; A ];
                      Ty.path "core::alloc::AllocError"
                    ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "alloc::boxed::Box") [] [ T; A ],
                    "try_new_zeroed_in",
                    [],
                    []
                  |),
                  [ M.read (| alloc |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 :=
                      M.SubPointer.get_struct_tuple_field (| γ, "core::result::Result::Ok", 0 |) in
                    let m := M.copy (| γ0_0 |) in
                    m));
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 :=
                      M.SubPointer.get_struct_tuple_field (| γ, "core::result::Result::Err", 0 |) in
                    M.alloc (|
                      M.never_to_any (|
                        M.call_closure (|
                          Ty.path "never",
                          M.get_function (| "alloc::alloc::handle_alloc_error", [], [] |),
                          [ M.read (| layout |) ]
                        |)
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_new_zeroed_in :
      forall (T A : Ty.t),
      M.IsAssociatedFunction.Trait (Self T A) "new_zeroed_in" (new_zeroed_in T A).
    Admitted.
    Global Typeclasses Opaque new_zeroed_in.
    
    (*
        pub fn try_new_zeroed_in(alloc: A) -> Result<Box<mem::MaybeUninit<T>, A>, AllocError>
        where
            A: Allocator,
        {
            let ptr = if T::IS_ZST {
                NonNull::dangling()
            } else {
                let layout = Layout::new::<mem::MaybeUninit<T>>();
                alloc.allocate_zeroed(layout)?.cast()
            };
            unsafe { Ok(Box::from_raw_in(ptr.as_ptr(), alloc)) }
        }
    *)
    Definition try_new_zeroed_in
        (T A : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ alloc ] =>
        ltac:(M.monadic
          (let alloc := M.alloc (| alloc |) in
          M.catch_return (|
            ltac:(M.monadic
              (M.read (|
                let~ ptr :
                    Ty.apply
                      (Ty.path "core::ptr::non_null::NonNull")
                      []
                      [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ] ] :=
                  M.copy (|
                    M.match_operator (|
                      Some
                        (Ty.apply
                          (Ty.path "core::ptr::non_null::NonNull")
                          []
                          [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ] ]),
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use (M.get_constant "core::mem::SizedTypeProperties::IS_ZST") in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (|
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "core::ptr::non_null::NonNull")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                      []
                                      [ T ]
                                  ],
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "core::ptr::non_null::NonNull")
                                    []
                                    [
                                      Ty.apply
                                        (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                        []
                                        [ T ]
                                    ],
                                  "dangling",
                                  [],
                                  []
                                |),
                                []
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let~ layout : Ty.path "core::alloc::layout::Layout" :=
                              M.alloc (|
                                M.call_closure (|
                                  Ty.path "core::alloc::layout::Layout",
                                  M.get_associated_function (|
                                    Ty.path "core::alloc::layout::Layout",
                                    "new",
                                    [],
                                    [
                                      Ty.apply
                                        (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                        []
                                        [ T ]
                                    ]
                                  |),
                                  []
                                |)
                              |) in
                            M.alloc (|
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "core::ptr::non_null::NonNull")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                      []
                                      [ T ]
                                  ],
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "core::ptr::non_null::NonNull")
                                    []
                                    [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                                  "cast",
                                  [],
                                  [
                                    Ty.apply
                                      (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                      []
                                      [ T ]
                                  ]
                                |),
                                [
                                  M.read (|
                                    M.match_operator (|
                                      Some
                                        (Ty.apply
                                          (Ty.path "core::ptr::non_null::NonNull")
                                          []
                                          [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]),
                                      M.alloc (|
                                        M.call_closure (|
                                          Ty.apply
                                            (Ty.path "core::ops::control_flow::ControlFlow")
                                            []
                                            [
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                []
                                                [
                                                  Ty.path "core::convert::Infallible";
                                                  Ty.path "core::alloc::AllocError"
                                                ];
                                              Ty.apply
                                                (Ty.path "core::ptr::non_null::NonNull")
                                                []
                                                [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
                                            ],
                                          M.get_trait_method (|
                                            "core::ops::try_trait::Try",
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "core::ptr::non_null::NonNull")
                                                  []
                                                  [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ]
                                                  ];
                                                Ty.path "core::alloc::AllocError"
                                              ],
                                            [],
                                            [],
                                            "branch",
                                            [],
                                            []
                                          |),
                                          [
                                            M.call_closure (|
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path "core::ptr::non_null::NonNull")
                                                    []
                                                    [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ]
                                                    ];
                                                  Ty.path "core::alloc::AllocError"
                                                ],
                                              M.get_trait_method (|
                                                "core::alloc::Allocator",
                                                A,
                                                [],
                                                [],
                                                "allocate_zeroed",
                                                [],
                                                []
                                              |),
                                              [
                                                M.borrow (| Pointer.Kind.Ref, alloc |);
                                                M.read (| layout |)
                                              ]
                                            |)
                                          ]
                                        |)
                                      |),
                                      [
                                        fun γ =>
                                          ltac:(M.monadic
                                            (let γ0_0 :=
                                              M.SubPointer.get_struct_tuple_field (|
                                                γ,
                                                "core::ops::control_flow::ControlFlow::Break",
                                                0
                                              |) in
                                            let residual := M.copy (| γ0_0 |) in
                                            M.alloc (|
                                              M.never_to_any (|
                                                M.read (|
                                                  M.return_ (|
                                                    M.call_closure (|
                                                      Ty.apply
                                                        (Ty.path "core::result::Result")
                                                        []
                                                        [
                                                          Ty.apply
                                                            (Ty.path "alloc::boxed::Box")
                                                            []
                                                            [
                                                              Ty.apply
                                                                (Ty.path
                                                                  "core::mem::maybe_uninit::MaybeUninit")
                                                                []
                                                                [ T ];
                                                              A
                                                            ];
                                                          Ty.path "core::alloc::AllocError"
                                                        ],
                                                      M.get_trait_method (|
                                                        "core::ops::try_trait::FromResidual",
                                                        Ty.apply
                                                          (Ty.path "core::result::Result")
                                                          []
                                                          [
                                                            Ty.apply
                                                              (Ty.path "alloc::boxed::Box")
                                                              []
                                                              [
                                                                Ty.apply
                                                                  (Ty.path
                                                                    "core::mem::maybe_uninit::MaybeUninit")
                                                                  []
                                                                  [ T ];
                                                                A
                                                              ];
                                                            Ty.path "core::alloc::AllocError"
                                                          ],
                                                        [],
                                                        [
                                                          Ty.apply
                                                            (Ty.path "core::result::Result")
                                                            []
                                                            [
                                                              Ty.path "core::convert::Infallible";
                                                              Ty.path "core::alloc::AllocError"
                                                            ]
                                                        ],
                                                        "from_residual",
                                                        [],
                                                        []
                                                      |),
                                                      [ M.read (| residual |) ]
                                                    |)
                                                  |)
                                                |)
                                              |)
                                            |)));
                                        fun γ =>
                                          ltac:(M.monadic
                                            (let γ0_0 :=
                                              M.SubPointer.get_struct_tuple_field (|
                                                γ,
                                                "core::ops::control_flow::ControlFlow::Continue",
                                                0
                                              |) in
                                            let val := M.copy (| γ0_0 |) in
                                            val))
                                      ]
                                    |)
                                  |)
                                ]
                              |)
                            |)))
                      ]
                    |)
                  |) in
                M.alloc (|
                  Value.StructTuple
                    "core::result::Result::Ok"
                    [
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "alloc::boxed::Box")
                          []
                          [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ]; A ],
                        M.get_associated_function (|
                          Ty.apply
                            (Ty.path "alloc::boxed::Box")
                            []
                            [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ]; A
                            ],
                          "from_raw_in",
                          [],
                          []
                        |),
                        [
                          M.call_closure (|
                            Ty.apply
                              (Ty.path "*mut")
                              []
                              [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ]
                              ],
                            M.get_associated_function (|
                              Ty.apply
                                (Ty.path "core::ptr::non_null::NonNull")
                                []
                                [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ]
                                ],
                              "as_ptr",
                              [],
                              []
                            |),
                            [ M.read (| ptr |) ]
                          |);
                          M.read (| alloc |)
                        ]
                      |)
                    ]
                |)
              |)))
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_try_new_zeroed_in :
      forall (T A : Ty.t),
      M.IsAssociatedFunction.Trait (Self T A) "try_new_zeroed_in" (try_new_zeroed_in T A).
    Admitted.
    Global Typeclasses Opaque try_new_zeroed_in.
    
    (*
        pub fn pin_in(x: T, alloc: A) -> Pin<Self>
        where
            A: 'static + Allocator,
        {
            Self::into_pin(Self::new_in(x, alloc))
        }
    *)
    Definition pin_in (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ x; alloc ] =>
        ltac:(M.monadic
          (let x := M.alloc (| x |) in
          let alloc := M.alloc (| alloc |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "core::pin::Pin")
              []
              [ Ty.apply (Ty.path "alloc::boxed::Box") [] [ T; A ] ],
            M.get_associated_function (|
              Ty.apply (Ty.path "alloc::boxed::Box") [] [ T; A ],
              "into_pin",
              [],
              []
            |),
            [
              M.call_closure (|
                Ty.apply (Ty.path "alloc::boxed::Box") [] [ T; A ],
                M.get_associated_function (|
                  Ty.apply (Ty.path "alloc::boxed::Box") [] [ T; A ],
                  "new_in",
                  [],
                  []
                |),
                [ M.read (| x |); M.read (| alloc |) ]
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_pin_in :
      forall (T A : Ty.t),
      M.IsAssociatedFunction.Trait (Self T A) "pin_in" (pin_in T A).
    Admitted.
    Global Typeclasses Opaque pin_in.
    
    (*
        pub fn into_boxed_slice(boxed: Self) -> Box<[T], A> {
            let (raw, alloc) = Box::into_raw_with_allocator(boxed);
            unsafe { Box::from_raw_in(raw as *mut [T; 1], alloc) }
        }
    *)
    Definition into_boxed_slice
        (T A : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ boxed ] =>
        ltac:(M.monadic
          (let boxed := M.alloc (| boxed |) in
          M.read (|
            M.match_operator (|
              None,
              M.alloc (|
                M.call_closure (|
                  Ty.tuple [ Ty.apply (Ty.path "*mut") [] [ T ]; A ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "alloc::boxed::Box") [] [ T; A ],
                    "into_raw_with_allocator",
                    [],
                    []
                  |),
                  [ M.read (| boxed |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let raw := M.copy (| γ0_0 |) in
                    let alloc := M.copy (| γ0_1 |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "alloc::boxed::Box")
                          []
                          [ Ty.apply (Ty.path "slice") [] [ T ]; A ],
                        M.get_associated_function (|
                          Ty.apply
                            (Ty.path "alloc::boxed::Box")
                            []
                            [ Ty.apply (Ty.path "slice") [] [ T ]; A ],
                          "from_raw_in",
                          [],
                          []
                        |),
                        [
                          M.cast
                            (Ty.apply
                              (Ty.path "*mut")
                              []
                              [
                                Ty.apply
                                  (Ty.path "array")
                                  [ Value.Integer IntegerKind.Usize 1 ]
                                  [ T ]
                              ])
                            (M.read (| raw |));
                          M.read (| alloc |)
                        ]
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_into_boxed_slice :
      forall (T A : Ty.t),
      M.IsAssociatedFunction.Trait (Self T A) "into_boxed_slice" (into_boxed_slice T A).
    Admitted.
    Global Typeclasses Opaque into_boxed_slice.
    
    (*
        pub fn into_inner(boxed: Self) -> T {
            *boxed
        }
    *)
    Definition into_inner (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ boxed ] =>
        ltac:(M.monadic
          (let boxed := M.alloc (| boxed |) in
          M.read (| M.deref (| M.read (| boxed |) |) |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_into_inner :
      forall (T A : Ty.t),
      M.IsAssociatedFunction.Trait (Self T A) "into_inner" (into_inner T A).
    Admitted.
    Global Typeclasses Opaque into_inner.
    (*
        pub const unsafe fn from_raw_in(raw: *mut T, alloc: A) -> Self {
            Box(unsafe { Unique::new_unchecked(raw) }, alloc)
        }
    *)
    Definition from_raw_in (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ raw; alloc ] =>
        ltac:(M.monadic
          (let raw := M.alloc (| raw |) in
          let alloc := M.alloc (| alloc |) in
          Value.StructTuple
            "alloc::boxed::Box"
            [
              M.call_closure (|
                Ty.apply (Ty.path "core::ptr::unique::Unique") [] [ T ],
                M.get_associated_function (|
                  Ty.apply (Ty.path "core::ptr::unique::Unique") [] [ T ],
                  "new_unchecked",
                  [],
                  []
                |),
                [ M.read (| raw |) ]
              |);
              M.read (| alloc |)
            ]))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_from_raw_in :
      forall (T A : Ty.t),
      M.IsAssociatedFunction.Trait (Self T A) "from_raw_in" (from_raw_in T A).
    Admitted.
    Global Typeclasses Opaque from_raw_in.
    
    (*
        pub const unsafe fn from_non_null_in(raw: NonNull<T>, alloc: A) -> Self {
            // SAFETY: guaranteed by the caller.
            unsafe { Box::from_raw_in(raw.as_ptr(), alloc) }
        }
    *)
    Definition from_non_null_in
        (T A : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ raw; alloc ] =>
        ltac:(M.monadic
          (let raw := M.alloc (| raw |) in
          let alloc := M.alloc (| alloc |) in
          M.call_closure (|
            Ty.apply (Ty.path "alloc::boxed::Box") [] [ T; A ],
            M.get_associated_function (|
              Ty.apply (Ty.path "alloc::boxed::Box") [] [ T; A ],
              "from_raw_in",
              [],
              []
            |),
            [
              M.call_closure (|
                Ty.apply (Ty.path "*mut") [] [ T ],
                M.get_associated_function (|
                  Ty.apply (Ty.path "core::ptr::non_null::NonNull") [] [ T ],
                  "as_ptr",
                  [],
                  []
                |),
                [ M.read (| raw |) ]
              |);
              M.read (| alloc |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_from_non_null_in :
      forall (T A : Ty.t),
      M.IsAssociatedFunction.Trait (Self T A) "from_non_null_in" (from_non_null_in T A).
    Admitted.
    Global Typeclasses Opaque from_non_null_in.
    
    (*
        pub fn into_raw(b: Self) -> *mut T {
            // Make sure Miri realizes that we transition from a noalias pointer to a raw pointer here.
            unsafe { &raw mut *&mut *Self::into_raw_with_allocator(b).0 }
        }
    *)
    Definition into_raw (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ b ] =>
        ltac:(M.monadic
          (let b := M.alloc (| b |) in
          M.borrow (|
            Pointer.Kind.MutPointer,
            M.deref (|
              M.borrow (|
                Pointer.Kind.MutRef,
                M.deref (|
                  M.read (|
                    M.SubPointer.get_tuple_field (|
                      M.alloc (|
                        M.call_closure (|
                          Ty.tuple [ Ty.apply (Ty.path "*mut") [] [ T ]; A ],
                          M.get_associated_function (|
                            Ty.apply (Ty.path "alloc::boxed::Box") [] [ T; A ],
                            "into_raw_with_allocator",
                            [],
                            []
                          |),
                          [ M.read (| b |) ]
                        |)
                      |),
                      0
                    |)
                  |)
                |)
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_into_raw :
      forall (T A : Ty.t),
      M.IsAssociatedFunction.Trait (Self T A) "into_raw" (into_raw T A).
    Admitted.
    Global Typeclasses Opaque into_raw.
    
    (*
        pub fn into_non_null(b: Self) -> NonNull<T> {
            // SAFETY: `Box` is guaranteed to be non-null.
            unsafe { NonNull::new_unchecked(Self::into_raw(b)) }
        }
    *)
    Definition into_non_null
        (T A : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ b ] =>
        ltac:(M.monadic
          (let b := M.alloc (| b |) in
          M.call_closure (|
            Ty.apply (Ty.path "core::ptr::non_null::NonNull") [] [ T ],
            M.get_associated_function (|
              Ty.apply (Ty.path "core::ptr::non_null::NonNull") [] [ T ],
              "new_unchecked",
              [],
              []
            |),
            [
              M.call_closure (|
                Ty.apply (Ty.path "*mut") [] [ T ],
                M.get_associated_function (|
                  Ty.apply (Ty.path "alloc::boxed::Box") [] [ T; A ],
                  "into_raw",
                  [],
                  []
                |),
                [ M.read (| b |) ]
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_into_non_null :
      forall (T A : Ty.t),
      M.IsAssociatedFunction.Trait (Self T A) "into_non_null" (into_non_null T A).
    Admitted.
    Global Typeclasses Opaque into_non_null.
    
    (*
        pub fn into_raw_with_allocator(b: Self) -> ( *mut T, A) {
            let mut b = mem::ManuallyDrop::new(b);
            // We carefully get the raw pointer out in a way that Miri's aliasing model understands what
            // is happening: using the primitive "deref" of `Box`. In case `A` is *not* `Global`, we
            // want *no* aliasing requirements here!
            // In case `A` *is* `Global`, this does not quite have the right behavior; `into_raw`
            // works around that.
            let ptr = &raw mut **b;
            let alloc = unsafe { ptr::read(&b.1) };
            (ptr, alloc)
        }
    *)
    Definition into_raw_with_allocator
        (T A : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ b ] =>
        ltac:(M.monadic
          (let b := M.alloc (| b |) in
          M.read (|
            let~ b :
                Ty.apply
                  (Ty.path "core::mem::manually_drop::ManuallyDrop")
                  []
                  [ Ty.apply (Ty.path "alloc::boxed::Box") [] [ T; A ] ] :=
              M.alloc (|
                M.call_closure (|
                  Ty.apply
                    (Ty.path "core::mem::manually_drop::ManuallyDrop")
                    []
                    [ Ty.apply (Ty.path "alloc::boxed::Box") [] [ T; A ] ],
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "core::mem::manually_drop::ManuallyDrop")
                      []
                      [ Ty.apply (Ty.path "alloc::boxed::Box") [] [ T; A ] ],
                    "new",
                    [],
                    []
                  |),
                  [ M.read (| b |) ]
                |)
              |) in
            let~ ptr : Ty.apply (Ty.path "*mut") [] [ T ] :=
              M.alloc (|
                M.borrow (|
                  Pointer.Kind.MutPointer,
                  M.deref (|
                    M.read (|
                      M.deref (|
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "&mut")
                            []
                            [ Ty.apply (Ty.path "alloc::boxed::Box") [] [ T; A ] ],
                          M.get_trait_method (|
                            "core::ops::deref::DerefMut",
                            Ty.apply
                              (Ty.path "core::mem::manually_drop::ManuallyDrop")
                              []
                              [ Ty.apply (Ty.path "alloc::boxed::Box") [] [ T; A ] ],
                            [],
                            [],
                            "deref_mut",
                            [],
                            []
                          |),
                          [ M.borrow (| Pointer.Kind.MutRef, b |) ]
                        |)
                      |)
                    |)
                  |)
                |)
              |) in
            let~ alloc : A :=
              M.alloc (|
                M.call_closure (|
                  A,
                  M.get_function (| "core::ptr::read", [], [ A ] |),
                  [
                    M.borrow (|
                      Pointer.Kind.ConstPointer,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_tuple_field (|
                            M.deref (|
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "&")
                                  []
                                  [ Ty.apply (Ty.path "alloc::boxed::Box") [] [ T; A ] ],
                                M.get_trait_method (|
                                  "core::ops::deref::Deref",
                                  Ty.apply
                                    (Ty.path "core::mem::manually_drop::ManuallyDrop")
                                    []
                                    [ Ty.apply (Ty.path "alloc::boxed::Box") [] [ T; A ] ],
                                  [],
                                  [],
                                  "deref",
                                  [],
                                  []
                                |),
                                [ M.borrow (| Pointer.Kind.Ref, b |) ]
                              |)
                            |),
                            "alloc::boxed::Box",
                            1
                          |)
                        |)
                      |)
                    |)
                  ]
                |)
              |) in
            M.alloc (| Value.Tuple [ M.read (| ptr |); M.read (| alloc |) ] |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_into_raw_with_allocator :
      forall (T A : Ty.t),
      M.IsAssociatedFunction.Trait
        (Self T A)
        "into_raw_with_allocator"
        (into_raw_with_allocator T A).
    Admitted.
    Global Typeclasses Opaque into_raw_with_allocator.
    
    (*
        pub fn into_non_null_with_allocator(b: Self) -> (NonNull<T>, A) {
            let (ptr, alloc) = Box::into_raw_with_allocator(b);
            // SAFETY: `Box` is guaranteed to be non-null.
            unsafe { (NonNull::new_unchecked(ptr), alloc) }
        }
    *)
    Definition into_non_null_with_allocator
        (T A : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ b ] =>
        ltac:(M.monadic
          (let b := M.alloc (| b |) in
          M.read (|
            M.match_operator (|
              None,
              M.alloc (|
                M.call_closure (|
                  Ty.tuple [ Ty.apply (Ty.path "*mut") [] [ T ]; A ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "alloc::boxed::Box") [] [ T; A ],
                    "into_raw_with_allocator",
                    [],
                    []
                  |),
                  [ M.read (| b |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let ptr := M.copy (| γ0_0 |) in
                    let alloc := M.copy (| γ0_1 |) in
                    M.alloc (|
                      Value.Tuple
                        [
                          M.call_closure (|
                            Ty.apply (Ty.path "core::ptr::non_null::NonNull") [] [ T ],
                            M.get_associated_function (|
                              Ty.apply (Ty.path "core::ptr::non_null::NonNull") [] [ T ],
                              "new_unchecked",
                              [],
                              []
                            |),
                            [ M.read (| ptr |) ]
                          |);
                          M.read (| alloc |)
                        ]
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_into_non_null_with_allocator :
      forall (T A : Ty.t),
      M.IsAssociatedFunction.Trait
        (Self T A)
        "into_non_null_with_allocator"
        (into_non_null_with_allocator T A).
    Admitted.
    Global Typeclasses Opaque into_non_null_with_allocator.
    
    (*
        pub fn into_unique(b: Self) -> (Unique<T>, A) {
            let (ptr, alloc) = Box::into_raw_with_allocator(b);
            unsafe { (Unique::from(&mut *ptr), alloc) }
        }
    *)
    Definition into_unique (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ b ] =>
        ltac:(M.monadic
          (let b := M.alloc (| b |) in
          M.read (|
            M.match_operator (|
              None,
              M.alloc (|
                M.call_closure (|
                  Ty.tuple [ Ty.apply (Ty.path "*mut") [] [ T ]; A ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "alloc::boxed::Box") [] [ T; A ],
                    "into_raw_with_allocator",
                    [],
                    []
                  |),
                  [ M.read (| b |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let ptr := M.copy (| γ0_0 |) in
                    let alloc := M.copy (| γ0_1 |) in
                    M.alloc (|
                      Value.Tuple
                        [
                          M.call_closure (|
                            Ty.apply (Ty.path "core::ptr::unique::Unique") [] [ T ],
                            M.get_trait_method (|
                              "core::convert::From",
                              Ty.apply (Ty.path "core::ptr::unique::Unique") [] [ T ],
                              [],
                              [ Ty.apply (Ty.path "&mut") [] [ T ] ],
                              "from",
                              [],
                              []
                            |),
                            [ M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| ptr |) |) |) ]
                          |);
                          M.read (| alloc |)
                        ]
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_into_unique :
      forall (T A : Ty.t),
      M.IsAssociatedFunction.Trait (Self T A) "into_unique" (into_unique T A).
    Admitted.
    Global Typeclasses Opaque into_unique.
    
    (*
        pub fn as_mut_ptr(b: &mut Self) -> *mut T {
            // This is a primitive deref, not going through `DerefMut`, and therefore not materializing
            // any references.
            &raw mut **b
        }
    *)
    Definition as_mut_ptr (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ b ] =>
        ltac:(M.monadic
          (let b := M.alloc (| b |) in
          M.borrow (|
            Pointer.Kind.MutPointer,
            M.deref (| M.read (| M.deref (| M.read (| b |) |) |) |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_as_mut_ptr :
      forall (T A : Ty.t),
      M.IsAssociatedFunction.Trait (Self T A) "as_mut_ptr" (as_mut_ptr T A).
    Admitted.
    Global Typeclasses Opaque as_mut_ptr.
    
    (*
        pub fn as_ptr(b: &Self) -> *const T {
            // This is a primitive deref, not going through `DerefMut`, and therefore not materializing
            // any references.
            &raw const **b
        }
    *)
    Definition as_ptr (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ b ] =>
        ltac:(M.monadic
          (let b := M.alloc (| b |) in
          M.borrow (|
            Pointer.Kind.ConstPointer,
            M.deref (| M.read (| M.deref (| M.read (| b |) |) |) |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_as_ptr :
      forall (T A : Ty.t),
      M.IsAssociatedFunction.Trait (Self T A) "as_ptr" (as_ptr T A).
    Admitted.
    Global Typeclasses Opaque as_ptr.
    
    (*
        pub const fn allocator(b: &Self) -> &A {
            &b.1
        }
    *)
    Definition allocator (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ b ] =>
        ltac:(M.monadic
          (let b := M.alloc (| b |) in
          M.borrow (|
            Pointer.Kind.Ref,
            M.deref (|
              M.borrow (|
                Pointer.Kind.Ref,
                M.SubPointer.get_struct_tuple_field (|
                  M.deref (| M.read (| b |) |),
                  "alloc::boxed::Box",
                  1
                |)
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_allocator :
      forall (T A : Ty.t),
      M.IsAssociatedFunction.Trait (Self T A) "allocator" (allocator T A).
    Admitted.
    Global Typeclasses Opaque allocator.
    
    (*
        pub fn leak<'a>(b: Self) -> &'a mut T
        where
            A: 'a,
        {
            unsafe { &mut *Box::into_raw(b) }
        }
    *)
    Definition leak (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ b ] =>
        ltac:(M.monadic
          (let b := M.alloc (| b |) in
          M.borrow (|
            Pointer.Kind.MutRef,
            M.deref (|
              M.borrow (|
                Pointer.Kind.MutRef,
                M.deref (|
                  M.borrow (|
                    Pointer.Kind.MutRef,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.MutRef,
                        M.deref (|
                          M.call_closure (|
                            Ty.apply (Ty.path "*mut") [] [ T ],
                            M.get_associated_function (|
                              Ty.apply (Ty.path "alloc::boxed::Box") [] [ T; A ],
                              "into_raw",
                              [],
                              []
                            |),
                            [ M.read (| b |) ]
                          |)
                        |)
                      |)
                    |)
                  |)
                |)
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_leak :
      forall (T A : Ty.t),
      M.IsAssociatedFunction.Trait (Self T A) "leak" (leak T A).
    Admitted.
    Global Typeclasses Opaque leak.
    
    (*
        pub const fn into_pin(boxed: Self) -> Pin<Self>
        where
            A: 'static,
        {
            // It's not possible to move or replace the insides of a `Pin<Box<T>>`
            // when `T: !Unpin`, so it's safe to pin it directly without any
            // additional requirements.
            unsafe { Pin::new_unchecked(boxed) }
        }
    *)
    Definition into_pin (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ boxed ] =>
        ltac:(M.monadic
          (let boxed := M.alloc (| boxed |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "core::pin::Pin")
              []
              [ Ty.apply (Ty.path "alloc::boxed::Box") [] [ T; A ] ],
            M.get_associated_function (|
              Ty.apply
                (Ty.path "core::pin::Pin")
                []
                [ Ty.apply (Ty.path "alloc::boxed::Box") [] [ T; A ] ],
              "new_unchecked",
              [],
              []
            |),
            [ M.read (| boxed |) ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_into_pin :
      forall (T A : Ty.t),
      M.IsAssociatedFunction.Trait (Self T A) "into_pin" (into_pin T A).
    Admitted.
    Global Typeclasses Opaque into_pin.
  End Impl_alloc_boxed_Box_T_A.
  
  Module Impl_alloc_boxed_Box_slice_T_alloc_alloc_Global.
    Definition Self (T : Ty.t) : Ty.t :=
      Ty.apply
        (Ty.path "alloc::boxed::Box")
        []
        [ Ty.apply (Ty.path "slice") [] [ T ]; Ty.path "alloc::alloc::Global" ].
    
    (*
        pub fn new_uninit_slice(len: usize) -> Box<[mem::MaybeUninit<T>]> {
            unsafe { RawVec::with_capacity(len).into_box(len) }
        }
    *)
    Definition new_uninit_slice
        (T : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [], [ len ] =>
        ltac:(M.monadic
          (let len := M.alloc (| len |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "alloc::boxed::Box")
              []
              [
                Ty.apply
                  (Ty.path "slice")
                  []
                  [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ] ];
                Ty.path "alloc::alloc::Global"
              ],
            M.get_associated_function (|
              Ty.apply (Ty.path "alloc::raw_vec::RawVec") [] [ T; Ty.path "alloc::alloc::Global" ],
              "into_box",
              [],
              []
            |),
            [
              M.call_closure (|
                Ty.apply
                  (Ty.path "alloc::raw_vec::RawVec")
                  []
                  [ T; Ty.path "alloc::alloc::Global" ],
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "alloc::raw_vec::RawVec")
                    []
                    [ T; Ty.path "alloc::alloc::Global" ],
                  "with_capacity",
                  [],
                  []
                |),
                [ M.read (| len |) ]
              |);
              M.read (| len |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_new_uninit_slice :
      forall (T : Ty.t),
      M.IsAssociatedFunction.Trait (Self T) "new_uninit_slice" (new_uninit_slice T).
    Admitted.
    Global Typeclasses Opaque new_uninit_slice.
    
    (*
        pub fn new_zeroed_slice(len: usize) -> Box<[mem::MaybeUninit<T>]> {
            unsafe { RawVec::with_capacity_zeroed(len).into_box(len) }
        }
    *)
    Definition new_zeroed_slice
        (T : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [], [ len ] =>
        ltac:(M.monadic
          (let len := M.alloc (| len |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "alloc::boxed::Box")
              []
              [
                Ty.apply
                  (Ty.path "slice")
                  []
                  [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ] ];
                Ty.path "alloc::alloc::Global"
              ],
            M.get_associated_function (|
              Ty.apply (Ty.path "alloc::raw_vec::RawVec") [] [ T; Ty.path "alloc::alloc::Global" ],
              "into_box",
              [],
              []
            |),
            [
              M.call_closure (|
                Ty.apply
                  (Ty.path "alloc::raw_vec::RawVec")
                  []
                  [ T; Ty.path "alloc::alloc::Global" ],
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "alloc::raw_vec::RawVec")
                    []
                    [ T; Ty.path "alloc::alloc::Global" ],
                  "with_capacity_zeroed",
                  [],
                  []
                |),
                [ M.read (| len |) ]
              |);
              M.read (| len |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_new_zeroed_slice :
      forall (T : Ty.t),
      M.IsAssociatedFunction.Trait (Self T) "new_zeroed_slice" (new_zeroed_slice T).
    Admitted.
    Global Typeclasses Opaque new_zeroed_slice.
    
    (*
        pub fn try_new_uninit_slice(len: usize) -> Result<Box<[mem::MaybeUninit<T>]>, AllocError> {
            let ptr = if T::IS_ZST || len == 0 {
                NonNull::dangling()
            } else {
                let layout = match Layout::array::<mem::MaybeUninit<T>>(len) {
                    Ok(l) => l,
                    Err(_) => return Err(AllocError),
                };
                Global.allocate(layout)?.cast()
            };
            unsafe { Ok(RawVec::from_raw_parts_in(ptr.as_ptr(), len, Global).into_box(len)) }
        }
    *)
    Definition try_new_uninit_slice
        (T : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [], [ len ] =>
        ltac:(M.monadic
          (let len := M.alloc (| len |) in
          M.catch_return (|
            ltac:(M.monadic
              (M.read (|
                let~ ptr : Ty.apply (Ty.path "core::ptr::non_null::NonNull") [] [ T ] :=
                  M.copy (|
                    M.match_operator (|
                      Some (Ty.apply (Ty.path "core::ptr::non_null::NonNull") [] [ T ]),
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  LogicalOp.or (|
                                    M.read (|
                                      M.get_constant "core::mem::SizedTypeProperties::IS_ZST"
                                    |),
                                    ltac:(M.monadic
                                      (BinOp.eq (|
                                        M.read (| len |),
                                        Value.Integer IntegerKind.Usize 0
                                      |)))
                                  |)
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (|
                              M.call_closure (|
                                Ty.apply (Ty.path "core::ptr::non_null::NonNull") [] [ T ],
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "core::ptr::non_null::NonNull") [] [ T ],
                                  "dangling",
                                  [],
                                  []
                                |),
                                []
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let~ layout : Ty.path "core::alloc::layout::Layout" :=
                              M.copy (|
                                M.match_operator (|
                                  Some (Ty.path "core::alloc::layout::Layout"),
                                  M.alloc (|
                                    M.call_closure (|
                                      Ty.apply
                                        (Ty.path "core::result::Result")
                                        []
                                        [
                                          Ty.path "core::alloc::layout::Layout";
                                          Ty.path "core::alloc::layout::LayoutError"
                                        ],
                                      M.get_associated_function (|
                                        Ty.path "core::alloc::layout::Layout",
                                        "array",
                                        [],
                                        [
                                          Ty.apply
                                            (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                            []
                                            [ T ]
                                        ]
                                      |),
                                      [ M.read (| len |) ]
                                    |)
                                  |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ0_0 :=
                                          M.SubPointer.get_struct_tuple_field (|
                                            γ,
                                            "core::result::Result::Ok",
                                            0
                                          |) in
                                        let l := M.copy (| γ0_0 |) in
                                        l));
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ0_0 :=
                                          M.SubPointer.get_struct_tuple_field (|
                                            γ,
                                            "core::result::Result::Err",
                                            0
                                          |) in
                                        M.alloc (|
                                          M.never_to_any (|
                                            M.read (|
                                              M.return_ (|
                                                Value.StructTuple
                                                  "core::result::Result::Err"
                                                  [ Value.StructTuple "core::alloc::AllocError" [] ]
                                              |)
                                            |)
                                          |)
                                        |)))
                                  ]
                                |)
                              |) in
                            M.alloc (|
                              M.call_closure (|
                                Ty.apply (Ty.path "core::ptr::non_null::NonNull") [] [ T ],
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "core::ptr::non_null::NonNull")
                                    []
                                    [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                                  "cast",
                                  [],
                                  [ T ]
                                |),
                                [
                                  M.read (|
                                    M.match_operator (|
                                      Some
                                        (Ty.apply
                                          (Ty.path "core::ptr::non_null::NonNull")
                                          []
                                          [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]),
                                      M.alloc (|
                                        M.call_closure (|
                                          Ty.apply
                                            (Ty.path "core::ops::control_flow::ControlFlow")
                                            []
                                            [
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                []
                                                [
                                                  Ty.path "core::convert::Infallible";
                                                  Ty.path "core::alloc::AllocError"
                                                ];
                                              Ty.apply
                                                (Ty.path "core::ptr::non_null::NonNull")
                                                []
                                                [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
                                            ],
                                          M.get_trait_method (|
                                            "core::ops::try_trait::Try",
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "core::ptr::non_null::NonNull")
                                                  []
                                                  [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ]
                                                  ];
                                                Ty.path "core::alloc::AllocError"
                                              ],
                                            [],
                                            [],
                                            "branch",
                                            [],
                                            []
                                          |),
                                          [
                                            M.call_closure (|
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path "core::ptr::non_null::NonNull")
                                                    []
                                                    [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ]
                                                    ];
                                                  Ty.path "core::alloc::AllocError"
                                                ],
                                              M.get_trait_method (|
                                                "core::alloc::Allocator",
                                                Ty.path "alloc::alloc::Global",
                                                [],
                                                [],
                                                "allocate",
                                                [],
                                                []
                                              |),
                                              [
                                                M.borrow (|
                                                  Pointer.Kind.Ref,
                                                  M.alloc (|
                                                    Value.StructTuple "alloc::alloc::Global" []
                                                  |)
                                                |);
                                                M.read (| layout |)
                                              ]
                                            |)
                                          ]
                                        |)
                                      |),
                                      [
                                        fun γ =>
                                          ltac:(M.monadic
                                            (let γ0_0 :=
                                              M.SubPointer.get_struct_tuple_field (|
                                                γ,
                                                "core::ops::control_flow::ControlFlow::Break",
                                                0
                                              |) in
                                            let residual := M.copy (| γ0_0 |) in
                                            M.alloc (|
                                              M.never_to_any (|
                                                M.read (|
                                                  M.return_ (|
                                                    M.call_closure (|
                                                      Ty.apply
                                                        (Ty.path "core::result::Result")
                                                        []
                                                        [
                                                          Ty.apply
                                                            (Ty.path "alloc::boxed::Box")
                                                            []
                                                            [
                                                              Ty.apply
                                                                (Ty.path "slice")
                                                                []
                                                                [
                                                                  Ty.apply
                                                                    (Ty.path
                                                                      "core::mem::maybe_uninit::MaybeUninit")
                                                                    []
                                                                    [ T ]
                                                                ];
                                                              Ty.path "alloc::alloc::Global"
                                                            ];
                                                          Ty.path "core::alloc::AllocError"
                                                        ],
                                                      M.get_trait_method (|
                                                        "core::ops::try_trait::FromResidual",
                                                        Ty.apply
                                                          (Ty.path "core::result::Result")
                                                          []
                                                          [
                                                            Ty.apply
                                                              (Ty.path "alloc::boxed::Box")
                                                              []
                                                              [
                                                                Ty.apply
                                                                  (Ty.path "slice")
                                                                  []
                                                                  [
                                                                    Ty.apply
                                                                      (Ty.path
                                                                        "core::mem::maybe_uninit::MaybeUninit")
                                                                      []
                                                                      [ T ]
                                                                  ];
                                                                Ty.path "alloc::alloc::Global"
                                                              ];
                                                            Ty.path "core::alloc::AllocError"
                                                          ],
                                                        [],
                                                        [
                                                          Ty.apply
                                                            (Ty.path "core::result::Result")
                                                            []
                                                            [
                                                              Ty.path "core::convert::Infallible";
                                                              Ty.path "core::alloc::AllocError"
                                                            ]
                                                        ],
                                                        "from_residual",
                                                        [],
                                                        []
                                                      |),
                                                      [ M.read (| residual |) ]
                                                    |)
                                                  |)
                                                |)
                                              |)
                                            |)));
                                        fun γ =>
                                          ltac:(M.monadic
                                            (let γ0_0 :=
                                              M.SubPointer.get_struct_tuple_field (|
                                                γ,
                                                "core::ops::control_flow::ControlFlow::Continue",
                                                0
                                              |) in
                                            let val := M.copy (| γ0_0 |) in
                                            val))
                                      ]
                                    |)
                                  |)
                                ]
                              |)
                            |)))
                      ]
                    |)
                  |) in
                M.alloc (|
                  Value.StructTuple
                    "core::result::Result::Ok"
                    [
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "alloc::boxed::Box")
                          []
                          [
                            Ty.apply
                              (Ty.path "slice")
                              []
                              [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ]
                              ];
                            Ty.path "alloc::alloc::Global"
                          ],
                        M.get_associated_function (|
                          Ty.apply
                            (Ty.path "alloc::raw_vec::RawVec")
                            []
                            [ T; Ty.path "alloc::alloc::Global" ],
                          "into_box",
                          [],
                          []
                        |),
                        [
                          M.call_closure (|
                            Ty.apply
                              (Ty.path "alloc::raw_vec::RawVec")
                              []
                              [ T; Ty.path "alloc::alloc::Global" ],
                            M.get_associated_function (|
                              Ty.apply
                                (Ty.path "alloc::raw_vec::RawVec")
                                []
                                [ T; Ty.path "alloc::alloc::Global" ],
                              "from_raw_parts_in",
                              [],
                              []
                            |),
                            [
                              M.call_closure (|
                                Ty.apply (Ty.path "*mut") [] [ T ],
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "core::ptr::non_null::NonNull") [] [ T ],
                                  "as_ptr",
                                  [],
                                  []
                                |),
                                [ M.read (| ptr |) ]
                              |);
                              M.read (| len |);
                              Value.StructTuple "alloc::alloc::Global" []
                            ]
                          |);
                          M.read (| len |)
                        ]
                      |)
                    ]
                |)
              |)))
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_try_new_uninit_slice :
      forall (T : Ty.t),
      M.IsAssociatedFunction.Trait (Self T) "try_new_uninit_slice" (try_new_uninit_slice T).
    Admitted.
    Global Typeclasses Opaque try_new_uninit_slice.
    
    (*
        pub fn try_new_zeroed_slice(len: usize) -> Result<Box<[mem::MaybeUninit<T>]>, AllocError> {
            let ptr = if T::IS_ZST || len == 0 {
                NonNull::dangling()
            } else {
                let layout = match Layout::array::<mem::MaybeUninit<T>>(len) {
                    Ok(l) => l,
                    Err(_) => return Err(AllocError),
                };
                Global.allocate_zeroed(layout)?.cast()
            };
            unsafe { Ok(RawVec::from_raw_parts_in(ptr.as_ptr(), len, Global).into_box(len)) }
        }
    *)
    Definition try_new_zeroed_slice
        (T : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [], [ len ] =>
        ltac:(M.monadic
          (let len := M.alloc (| len |) in
          M.catch_return (|
            ltac:(M.monadic
              (M.read (|
                let~ ptr : Ty.apply (Ty.path "core::ptr::non_null::NonNull") [] [ T ] :=
                  M.copy (|
                    M.match_operator (|
                      Some (Ty.apply (Ty.path "core::ptr::non_null::NonNull") [] [ T ]),
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  LogicalOp.or (|
                                    M.read (|
                                      M.get_constant "core::mem::SizedTypeProperties::IS_ZST"
                                    |),
                                    ltac:(M.monadic
                                      (BinOp.eq (|
                                        M.read (| len |),
                                        Value.Integer IntegerKind.Usize 0
                                      |)))
                                  |)
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (|
                              M.call_closure (|
                                Ty.apply (Ty.path "core::ptr::non_null::NonNull") [] [ T ],
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "core::ptr::non_null::NonNull") [] [ T ],
                                  "dangling",
                                  [],
                                  []
                                |),
                                []
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let~ layout : Ty.path "core::alloc::layout::Layout" :=
                              M.copy (|
                                M.match_operator (|
                                  Some (Ty.path "core::alloc::layout::Layout"),
                                  M.alloc (|
                                    M.call_closure (|
                                      Ty.apply
                                        (Ty.path "core::result::Result")
                                        []
                                        [
                                          Ty.path "core::alloc::layout::Layout";
                                          Ty.path "core::alloc::layout::LayoutError"
                                        ],
                                      M.get_associated_function (|
                                        Ty.path "core::alloc::layout::Layout",
                                        "array",
                                        [],
                                        [
                                          Ty.apply
                                            (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                            []
                                            [ T ]
                                        ]
                                      |),
                                      [ M.read (| len |) ]
                                    |)
                                  |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ0_0 :=
                                          M.SubPointer.get_struct_tuple_field (|
                                            γ,
                                            "core::result::Result::Ok",
                                            0
                                          |) in
                                        let l := M.copy (| γ0_0 |) in
                                        l));
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ0_0 :=
                                          M.SubPointer.get_struct_tuple_field (|
                                            γ,
                                            "core::result::Result::Err",
                                            0
                                          |) in
                                        M.alloc (|
                                          M.never_to_any (|
                                            M.read (|
                                              M.return_ (|
                                                Value.StructTuple
                                                  "core::result::Result::Err"
                                                  [ Value.StructTuple "core::alloc::AllocError" [] ]
                                              |)
                                            |)
                                          |)
                                        |)))
                                  ]
                                |)
                              |) in
                            M.alloc (|
                              M.call_closure (|
                                Ty.apply (Ty.path "core::ptr::non_null::NonNull") [] [ T ],
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "core::ptr::non_null::NonNull")
                                    []
                                    [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                                  "cast",
                                  [],
                                  [ T ]
                                |),
                                [
                                  M.read (|
                                    M.match_operator (|
                                      Some
                                        (Ty.apply
                                          (Ty.path "core::ptr::non_null::NonNull")
                                          []
                                          [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]),
                                      M.alloc (|
                                        M.call_closure (|
                                          Ty.apply
                                            (Ty.path "core::ops::control_flow::ControlFlow")
                                            []
                                            [
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                []
                                                [
                                                  Ty.path "core::convert::Infallible";
                                                  Ty.path "core::alloc::AllocError"
                                                ];
                                              Ty.apply
                                                (Ty.path "core::ptr::non_null::NonNull")
                                                []
                                                [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
                                            ],
                                          M.get_trait_method (|
                                            "core::ops::try_trait::Try",
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "core::ptr::non_null::NonNull")
                                                  []
                                                  [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ]
                                                  ];
                                                Ty.path "core::alloc::AllocError"
                                              ],
                                            [],
                                            [],
                                            "branch",
                                            [],
                                            []
                                          |),
                                          [
                                            M.call_closure (|
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path "core::ptr::non_null::NonNull")
                                                    []
                                                    [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ]
                                                    ];
                                                  Ty.path "core::alloc::AllocError"
                                                ],
                                              M.get_trait_method (|
                                                "core::alloc::Allocator",
                                                Ty.path "alloc::alloc::Global",
                                                [],
                                                [],
                                                "allocate_zeroed",
                                                [],
                                                []
                                              |),
                                              [
                                                M.borrow (|
                                                  Pointer.Kind.Ref,
                                                  M.alloc (|
                                                    Value.StructTuple "alloc::alloc::Global" []
                                                  |)
                                                |);
                                                M.read (| layout |)
                                              ]
                                            |)
                                          ]
                                        |)
                                      |),
                                      [
                                        fun γ =>
                                          ltac:(M.monadic
                                            (let γ0_0 :=
                                              M.SubPointer.get_struct_tuple_field (|
                                                γ,
                                                "core::ops::control_flow::ControlFlow::Break",
                                                0
                                              |) in
                                            let residual := M.copy (| γ0_0 |) in
                                            M.alloc (|
                                              M.never_to_any (|
                                                M.read (|
                                                  M.return_ (|
                                                    M.call_closure (|
                                                      Ty.apply
                                                        (Ty.path "core::result::Result")
                                                        []
                                                        [
                                                          Ty.apply
                                                            (Ty.path "alloc::boxed::Box")
                                                            []
                                                            [
                                                              Ty.apply
                                                                (Ty.path "slice")
                                                                []
                                                                [
                                                                  Ty.apply
                                                                    (Ty.path
                                                                      "core::mem::maybe_uninit::MaybeUninit")
                                                                    []
                                                                    [ T ]
                                                                ];
                                                              Ty.path "alloc::alloc::Global"
                                                            ];
                                                          Ty.path "core::alloc::AllocError"
                                                        ],
                                                      M.get_trait_method (|
                                                        "core::ops::try_trait::FromResidual",
                                                        Ty.apply
                                                          (Ty.path "core::result::Result")
                                                          []
                                                          [
                                                            Ty.apply
                                                              (Ty.path "alloc::boxed::Box")
                                                              []
                                                              [
                                                                Ty.apply
                                                                  (Ty.path "slice")
                                                                  []
                                                                  [
                                                                    Ty.apply
                                                                      (Ty.path
                                                                        "core::mem::maybe_uninit::MaybeUninit")
                                                                      []
                                                                      [ T ]
                                                                  ];
                                                                Ty.path "alloc::alloc::Global"
                                                              ];
                                                            Ty.path "core::alloc::AllocError"
                                                          ],
                                                        [],
                                                        [
                                                          Ty.apply
                                                            (Ty.path "core::result::Result")
                                                            []
                                                            [
                                                              Ty.path "core::convert::Infallible";
                                                              Ty.path "core::alloc::AllocError"
                                                            ]
                                                        ],
                                                        "from_residual",
                                                        [],
                                                        []
                                                      |),
                                                      [ M.read (| residual |) ]
                                                    |)
                                                  |)
                                                |)
                                              |)
                                            |)));
                                        fun γ =>
                                          ltac:(M.monadic
                                            (let γ0_0 :=
                                              M.SubPointer.get_struct_tuple_field (|
                                                γ,
                                                "core::ops::control_flow::ControlFlow::Continue",
                                                0
                                              |) in
                                            let val := M.copy (| γ0_0 |) in
                                            val))
                                      ]
                                    |)
                                  |)
                                ]
                              |)
                            |)))
                      ]
                    |)
                  |) in
                M.alloc (|
                  Value.StructTuple
                    "core::result::Result::Ok"
                    [
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "alloc::boxed::Box")
                          []
                          [
                            Ty.apply
                              (Ty.path "slice")
                              []
                              [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ]
                              ];
                            Ty.path "alloc::alloc::Global"
                          ],
                        M.get_associated_function (|
                          Ty.apply
                            (Ty.path "alloc::raw_vec::RawVec")
                            []
                            [ T; Ty.path "alloc::alloc::Global" ],
                          "into_box",
                          [],
                          []
                        |),
                        [
                          M.call_closure (|
                            Ty.apply
                              (Ty.path "alloc::raw_vec::RawVec")
                              []
                              [ T; Ty.path "alloc::alloc::Global" ],
                            M.get_associated_function (|
                              Ty.apply
                                (Ty.path "alloc::raw_vec::RawVec")
                                []
                                [ T; Ty.path "alloc::alloc::Global" ],
                              "from_raw_parts_in",
                              [],
                              []
                            |),
                            [
                              M.call_closure (|
                                Ty.apply (Ty.path "*mut") [] [ T ],
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "core::ptr::non_null::NonNull") [] [ T ],
                                  "as_ptr",
                                  [],
                                  []
                                |),
                                [ M.read (| ptr |) ]
                              |);
                              M.read (| len |);
                              Value.StructTuple "alloc::alloc::Global" []
                            ]
                          |);
                          M.read (| len |)
                        ]
                      |)
                    ]
                |)
              |)))
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_try_new_zeroed_slice :
      forall (T : Ty.t),
      M.IsAssociatedFunction.Trait (Self T) "try_new_zeroed_slice" (try_new_zeroed_slice T).
    Admitted.
    Global Typeclasses Opaque try_new_zeroed_slice.
  End Impl_alloc_boxed_Box_slice_T_alloc_alloc_Global.
  
  Module Impl_alloc_boxed_Box_slice_T_A.
    Definition Self (T A : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "alloc::boxed::Box") [] [ Ty.apply (Ty.path "slice") [] [ T ]; A ].
    
    (*
        pub fn new_uninit_slice_in(len: usize, alloc: A) -> Box<[mem::MaybeUninit<T>], A> {
            unsafe { RawVec::with_capacity_in(len, alloc).into_box(len) }
        }
    *)
    Definition new_uninit_slice_in
        (T A : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ len; alloc ] =>
        ltac:(M.monadic
          (let len := M.alloc (| len |) in
          let alloc := M.alloc (| alloc |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "alloc::boxed::Box")
              []
              [
                Ty.apply
                  (Ty.path "slice")
                  []
                  [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ] ];
                A
              ],
            M.get_associated_function (|
              Ty.apply (Ty.path "alloc::raw_vec::RawVec") [] [ T; A ],
              "into_box",
              [],
              []
            |),
            [
              M.call_closure (|
                Ty.apply (Ty.path "alloc::raw_vec::RawVec") [] [ T; A ],
                M.get_associated_function (|
                  Ty.apply (Ty.path "alloc::raw_vec::RawVec") [] [ T; A ],
                  "with_capacity_in",
                  [],
                  []
                |),
                [ M.read (| len |); M.read (| alloc |) ]
              |);
              M.read (| len |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_new_uninit_slice_in :
      forall (T A : Ty.t),
      M.IsAssociatedFunction.Trait (Self T A) "new_uninit_slice_in" (new_uninit_slice_in T A).
    Admitted.
    Global Typeclasses Opaque new_uninit_slice_in.
    
    (*
        pub fn new_zeroed_slice_in(len: usize, alloc: A) -> Box<[mem::MaybeUninit<T>], A> {
            unsafe { RawVec::with_capacity_zeroed_in(len, alloc).into_box(len) }
        }
    *)
    Definition new_zeroed_slice_in
        (T A : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ len; alloc ] =>
        ltac:(M.monadic
          (let len := M.alloc (| len |) in
          let alloc := M.alloc (| alloc |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "alloc::boxed::Box")
              []
              [
                Ty.apply
                  (Ty.path "slice")
                  []
                  [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ] ];
                A
              ],
            M.get_associated_function (|
              Ty.apply (Ty.path "alloc::raw_vec::RawVec") [] [ T; A ],
              "into_box",
              [],
              []
            |),
            [
              M.call_closure (|
                Ty.apply (Ty.path "alloc::raw_vec::RawVec") [] [ T; A ],
                M.get_associated_function (|
                  Ty.apply (Ty.path "alloc::raw_vec::RawVec") [] [ T; A ],
                  "with_capacity_zeroed_in",
                  [],
                  []
                |),
                [ M.read (| len |); M.read (| alloc |) ]
              |);
              M.read (| len |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_new_zeroed_slice_in :
      forall (T A : Ty.t),
      M.IsAssociatedFunction.Trait (Self T A) "new_zeroed_slice_in" (new_zeroed_slice_in T A).
    Admitted.
    Global Typeclasses Opaque new_zeroed_slice_in.
    
    (*
        pub fn try_new_uninit_slice_in(
            len: usize,
            alloc: A,
        ) -> Result<Box<[mem::MaybeUninit<T>], A>, AllocError> {
            let ptr = if T::IS_ZST || len == 0 {
                NonNull::dangling()
            } else {
                let layout = match Layout::array::<mem::MaybeUninit<T>>(len) {
                    Ok(l) => l,
                    Err(_) => return Err(AllocError),
                };
                alloc.allocate(layout)?.cast()
            };
            unsafe { Ok(RawVec::from_raw_parts_in(ptr.as_ptr(), len, alloc).into_box(len)) }
        }
    *)
    Definition try_new_uninit_slice_in
        (T A : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ len; alloc ] =>
        ltac:(M.monadic
          (let len := M.alloc (| len |) in
          let alloc := M.alloc (| alloc |) in
          M.catch_return (|
            ltac:(M.monadic
              (M.read (|
                let~ ptr : Ty.apply (Ty.path "core::ptr::non_null::NonNull") [] [ T ] :=
                  M.copy (|
                    M.match_operator (|
                      Some (Ty.apply (Ty.path "core::ptr::non_null::NonNull") [] [ T ]),
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  LogicalOp.or (|
                                    M.read (|
                                      M.get_constant "core::mem::SizedTypeProperties::IS_ZST"
                                    |),
                                    ltac:(M.monadic
                                      (BinOp.eq (|
                                        M.read (| len |),
                                        Value.Integer IntegerKind.Usize 0
                                      |)))
                                  |)
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (|
                              M.call_closure (|
                                Ty.apply (Ty.path "core::ptr::non_null::NonNull") [] [ T ],
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "core::ptr::non_null::NonNull") [] [ T ],
                                  "dangling",
                                  [],
                                  []
                                |),
                                []
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let~ layout : Ty.path "core::alloc::layout::Layout" :=
                              M.copy (|
                                M.match_operator (|
                                  Some (Ty.path "core::alloc::layout::Layout"),
                                  M.alloc (|
                                    M.call_closure (|
                                      Ty.apply
                                        (Ty.path "core::result::Result")
                                        []
                                        [
                                          Ty.path "core::alloc::layout::Layout";
                                          Ty.path "core::alloc::layout::LayoutError"
                                        ],
                                      M.get_associated_function (|
                                        Ty.path "core::alloc::layout::Layout",
                                        "array",
                                        [],
                                        [
                                          Ty.apply
                                            (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                            []
                                            [ T ]
                                        ]
                                      |),
                                      [ M.read (| len |) ]
                                    |)
                                  |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ0_0 :=
                                          M.SubPointer.get_struct_tuple_field (|
                                            γ,
                                            "core::result::Result::Ok",
                                            0
                                          |) in
                                        let l := M.copy (| γ0_0 |) in
                                        l));
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ0_0 :=
                                          M.SubPointer.get_struct_tuple_field (|
                                            γ,
                                            "core::result::Result::Err",
                                            0
                                          |) in
                                        M.alloc (|
                                          M.never_to_any (|
                                            M.read (|
                                              M.return_ (|
                                                Value.StructTuple
                                                  "core::result::Result::Err"
                                                  [ Value.StructTuple "core::alloc::AllocError" [] ]
                                              |)
                                            |)
                                          |)
                                        |)))
                                  ]
                                |)
                              |) in
                            M.alloc (|
                              M.call_closure (|
                                Ty.apply (Ty.path "core::ptr::non_null::NonNull") [] [ T ],
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "core::ptr::non_null::NonNull")
                                    []
                                    [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                                  "cast",
                                  [],
                                  [ T ]
                                |),
                                [
                                  M.read (|
                                    M.match_operator (|
                                      Some
                                        (Ty.apply
                                          (Ty.path "core::ptr::non_null::NonNull")
                                          []
                                          [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]),
                                      M.alloc (|
                                        M.call_closure (|
                                          Ty.apply
                                            (Ty.path "core::ops::control_flow::ControlFlow")
                                            []
                                            [
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                []
                                                [
                                                  Ty.path "core::convert::Infallible";
                                                  Ty.path "core::alloc::AllocError"
                                                ];
                                              Ty.apply
                                                (Ty.path "core::ptr::non_null::NonNull")
                                                []
                                                [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
                                            ],
                                          M.get_trait_method (|
                                            "core::ops::try_trait::Try",
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "core::ptr::non_null::NonNull")
                                                  []
                                                  [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ]
                                                  ];
                                                Ty.path "core::alloc::AllocError"
                                              ],
                                            [],
                                            [],
                                            "branch",
                                            [],
                                            []
                                          |),
                                          [
                                            M.call_closure (|
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path "core::ptr::non_null::NonNull")
                                                    []
                                                    [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ]
                                                    ];
                                                  Ty.path "core::alloc::AllocError"
                                                ],
                                              M.get_trait_method (|
                                                "core::alloc::Allocator",
                                                A,
                                                [],
                                                [],
                                                "allocate",
                                                [],
                                                []
                                              |),
                                              [
                                                M.borrow (| Pointer.Kind.Ref, alloc |);
                                                M.read (| layout |)
                                              ]
                                            |)
                                          ]
                                        |)
                                      |),
                                      [
                                        fun γ =>
                                          ltac:(M.monadic
                                            (let γ0_0 :=
                                              M.SubPointer.get_struct_tuple_field (|
                                                γ,
                                                "core::ops::control_flow::ControlFlow::Break",
                                                0
                                              |) in
                                            let residual := M.copy (| γ0_0 |) in
                                            M.alloc (|
                                              M.never_to_any (|
                                                M.read (|
                                                  M.return_ (|
                                                    M.call_closure (|
                                                      Ty.apply
                                                        (Ty.path "core::result::Result")
                                                        []
                                                        [
                                                          Ty.apply
                                                            (Ty.path "alloc::boxed::Box")
                                                            []
                                                            [
                                                              Ty.apply
                                                                (Ty.path "slice")
                                                                []
                                                                [
                                                                  Ty.apply
                                                                    (Ty.path
                                                                      "core::mem::maybe_uninit::MaybeUninit")
                                                                    []
                                                                    [ T ]
                                                                ];
                                                              A
                                                            ];
                                                          Ty.path "core::alloc::AllocError"
                                                        ],
                                                      M.get_trait_method (|
                                                        "core::ops::try_trait::FromResidual",
                                                        Ty.apply
                                                          (Ty.path "core::result::Result")
                                                          []
                                                          [
                                                            Ty.apply
                                                              (Ty.path "alloc::boxed::Box")
                                                              []
                                                              [
                                                                Ty.apply
                                                                  (Ty.path "slice")
                                                                  []
                                                                  [
                                                                    Ty.apply
                                                                      (Ty.path
                                                                        "core::mem::maybe_uninit::MaybeUninit")
                                                                      []
                                                                      [ T ]
                                                                  ];
                                                                A
                                                              ];
                                                            Ty.path "core::alloc::AllocError"
                                                          ],
                                                        [],
                                                        [
                                                          Ty.apply
                                                            (Ty.path "core::result::Result")
                                                            []
                                                            [
                                                              Ty.path "core::convert::Infallible";
                                                              Ty.path "core::alloc::AllocError"
                                                            ]
                                                        ],
                                                        "from_residual",
                                                        [],
                                                        []
                                                      |),
                                                      [ M.read (| residual |) ]
                                                    |)
                                                  |)
                                                |)
                                              |)
                                            |)));
                                        fun γ =>
                                          ltac:(M.monadic
                                            (let γ0_0 :=
                                              M.SubPointer.get_struct_tuple_field (|
                                                γ,
                                                "core::ops::control_flow::ControlFlow::Continue",
                                                0
                                              |) in
                                            let val := M.copy (| γ0_0 |) in
                                            val))
                                      ]
                                    |)
                                  |)
                                ]
                              |)
                            |)))
                      ]
                    |)
                  |) in
                M.alloc (|
                  Value.StructTuple
                    "core::result::Result::Ok"
                    [
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "alloc::boxed::Box")
                          []
                          [
                            Ty.apply
                              (Ty.path "slice")
                              []
                              [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ]
                              ];
                            A
                          ],
                        M.get_associated_function (|
                          Ty.apply (Ty.path "alloc::raw_vec::RawVec") [] [ T; A ],
                          "into_box",
                          [],
                          []
                        |),
                        [
                          M.call_closure (|
                            Ty.apply (Ty.path "alloc::raw_vec::RawVec") [] [ T; A ],
                            M.get_associated_function (|
                              Ty.apply (Ty.path "alloc::raw_vec::RawVec") [] [ T; A ],
                              "from_raw_parts_in",
                              [],
                              []
                            |),
                            [
                              M.call_closure (|
                                Ty.apply (Ty.path "*mut") [] [ T ],
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "core::ptr::non_null::NonNull") [] [ T ],
                                  "as_ptr",
                                  [],
                                  []
                                |),
                                [ M.read (| ptr |) ]
                              |);
                              M.read (| len |);
                              M.read (| alloc |)
                            ]
                          |);
                          M.read (| len |)
                        ]
                      |)
                    ]
                |)
              |)))
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_try_new_uninit_slice_in :
      forall (T A : Ty.t),
      M.IsAssociatedFunction.Trait
        (Self T A)
        "try_new_uninit_slice_in"
        (try_new_uninit_slice_in T A).
    Admitted.
    Global Typeclasses Opaque try_new_uninit_slice_in.
    
    (*
        pub fn try_new_zeroed_slice_in(
            len: usize,
            alloc: A,
        ) -> Result<Box<[mem::MaybeUninit<T>], A>, AllocError> {
            let ptr = if T::IS_ZST || len == 0 {
                NonNull::dangling()
            } else {
                let layout = match Layout::array::<mem::MaybeUninit<T>>(len) {
                    Ok(l) => l,
                    Err(_) => return Err(AllocError),
                };
                alloc.allocate_zeroed(layout)?.cast()
            };
            unsafe { Ok(RawVec::from_raw_parts_in(ptr.as_ptr(), len, alloc).into_box(len)) }
        }
    *)
    Definition try_new_zeroed_slice_in
        (T A : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ len; alloc ] =>
        ltac:(M.monadic
          (let len := M.alloc (| len |) in
          let alloc := M.alloc (| alloc |) in
          M.catch_return (|
            ltac:(M.monadic
              (M.read (|
                let~ ptr : Ty.apply (Ty.path "core::ptr::non_null::NonNull") [] [ T ] :=
                  M.copy (|
                    M.match_operator (|
                      Some (Ty.apply (Ty.path "core::ptr::non_null::NonNull") [] [ T ]),
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  LogicalOp.or (|
                                    M.read (|
                                      M.get_constant "core::mem::SizedTypeProperties::IS_ZST"
                                    |),
                                    ltac:(M.monadic
                                      (BinOp.eq (|
                                        M.read (| len |),
                                        Value.Integer IntegerKind.Usize 0
                                      |)))
                                  |)
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (|
                              M.call_closure (|
                                Ty.apply (Ty.path "core::ptr::non_null::NonNull") [] [ T ],
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "core::ptr::non_null::NonNull") [] [ T ],
                                  "dangling",
                                  [],
                                  []
                                |),
                                []
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let~ layout : Ty.path "core::alloc::layout::Layout" :=
                              M.copy (|
                                M.match_operator (|
                                  Some (Ty.path "core::alloc::layout::Layout"),
                                  M.alloc (|
                                    M.call_closure (|
                                      Ty.apply
                                        (Ty.path "core::result::Result")
                                        []
                                        [
                                          Ty.path "core::alloc::layout::Layout";
                                          Ty.path "core::alloc::layout::LayoutError"
                                        ],
                                      M.get_associated_function (|
                                        Ty.path "core::alloc::layout::Layout",
                                        "array",
                                        [],
                                        [
                                          Ty.apply
                                            (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                            []
                                            [ T ]
                                        ]
                                      |),
                                      [ M.read (| len |) ]
                                    |)
                                  |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ0_0 :=
                                          M.SubPointer.get_struct_tuple_field (|
                                            γ,
                                            "core::result::Result::Ok",
                                            0
                                          |) in
                                        let l := M.copy (| γ0_0 |) in
                                        l));
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ0_0 :=
                                          M.SubPointer.get_struct_tuple_field (|
                                            γ,
                                            "core::result::Result::Err",
                                            0
                                          |) in
                                        M.alloc (|
                                          M.never_to_any (|
                                            M.read (|
                                              M.return_ (|
                                                Value.StructTuple
                                                  "core::result::Result::Err"
                                                  [ Value.StructTuple "core::alloc::AllocError" [] ]
                                              |)
                                            |)
                                          |)
                                        |)))
                                  ]
                                |)
                              |) in
                            M.alloc (|
                              M.call_closure (|
                                Ty.apply (Ty.path "core::ptr::non_null::NonNull") [] [ T ],
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "core::ptr::non_null::NonNull")
                                    []
                                    [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                                  "cast",
                                  [],
                                  [ T ]
                                |),
                                [
                                  M.read (|
                                    M.match_operator (|
                                      Some
                                        (Ty.apply
                                          (Ty.path "core::ptr::non_null::NonNull")
                                          []
                                          [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]),
                                      M.alloc (|
                                        M.call_closure (|
                                          Ty.apply
                                            (Ty.path "core::ops::control_flow::ControlFlow")
                                            []
                                            [
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                []
                                                [
                                                  Ty.path "core::convert::Infallible";
                                                  Ty.path "core::alloc::AllocError"
                                                ];
                                              Ty.apply
                                                (Ty.path "core::ptr::non_null::NonNull")
                                                []
                                                [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
                                            ],
                                          M.get_trait_method (|
                                            "core::ops::try_trait::Try",
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "core::ptr::non_null::NonNull")
                                                  []
                                                  [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ]
                                                  ];
                                                Ty.path "core::alloc::AllocError"
                                              ],
                                            [],
                                            [],
                                            "branch",
                                            [],
                                            []
                                          |),
                                          [
                                            M.call_closure (|
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path "core::ptr::non_null::NonNull")
                                                    []
                                                    [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ]
                                                    ];
                                                  Ty.path "core::alloc::AllocError"
                                                ],
                                              M.get_trait_method (|
                                                "core::alloc::Allocator",
                                                A,
                                                [],
                                                [],
                                                "allocate_zeroed",
                                                [],
                                                []
                                              |),
                                              [
                                                M.borrow (| Pointer.Kind.Ref, alloc |);
                                                M.read (| layout |)
                                              ]
                                            |)
                                          ]
                                        |)
                                      |),
                                      [
                                        fun γ =>
                                          ltac:(M.monadic
                                            (let γ0_0 :=
                                              M.SubPointer.get_struct_tuple_field (|
                                                γ,
                                                "core::ops::control_flow::ControlFlow::Break",
                                                0
                                              |) in
                                            let residual := M.copy (| γ0_0 |) in
                                            M.alloc (|
                                              M.never_to_any (|
                                                M.read (|
                                                  M.return_ (|
                                                    M.call_closure (|
                                                      Ty.apply
                                                        (Ty.path "core::result::Result")
                                                        []
                                                        [
                                                          Ty.apply
                                                            (Ty.path "alloc::boxed::Box")
                                                            []
                                                            [
                                                              Ty.apply
                                                                (Ty.path "slice")
                                                                []
                                                                [
                                                                  Ty.apply
                                                                    (Ty.path
                                                                      "core::mem::maybe_uninit::MaybeUninit")
                                                                    []
                                                                    [ T ]
                                                                ];
                                                              A
                                                            ];
                                                          Ty.path "core::alloc::AllocError"
                                                        ],
                                                      M.get_trait_method (|
                                                        "core::ops::try_trait::FromResidual",
                                                        Ty.apply
                                                          (Ty.path "core::result::Result")
                                                          []
                                                          [
                                                            Ty.apply
                                                              (Ty.path "alloc::boxed::Box")
                                                              []
                                                              [
                                                                Ty.apply
                                                                  (Ty.path "slice")
                                                                  []
                                                                  [
                                                                    Ty.apply
                                                                      (Ty.path
                                                                        "core::mem::maybe_uninit::MaybeUninit")
                                                                      []
                                                                      [ T ]
                                                                  ];
                                                                A
                                                              ];
                                                            Ty.path "core::alloc::AllocError"
                                                          ],
                                                        [],
                                                        [
                                                          Ty.apply
                                                            (Ty.path "core::result::Result")
                                                            []
                                                            [
                                                              Ty.path "core::convert::Infallible";
                                                              Ty.path "core::alloc::AllocError"
                                                            ]
                                                        ],
                                                        "from_residual",
                                                        [],
                                                        []
                                                      |),
                                                      [ M.read (| residual |) ]
                                                    |)
                                                  |)
                                                |)
                                              |)
                                            |)));
                                        fun γ =>
                                          ltac:(M.monadic
                                            (let γ0_0 :=
                                              M.SubPointer.get_struct_tuple_field (|
                                                γ,
                                                "core::ops::control_flow::ControlFlow::Continue",
                                                0
                                              |) in
                                            let val := M.copy (| γ0_0 |) in
                                            val))
                                      ]
                                    |)
                                  |)
                                ]
                              |)
                            |)))
                      ]
                    |)
                  |) in
                M.alloc (|
                  Value.StructTuple
                    "core::result::Result::Ok"
                    [
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "alloc::boxed::Box")
                          []
                          [
                            Ty.apply
                              (Ty.path "slice")
                              []
                              [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ]
                              ];
                            A
                          ],
                        M.get_associated_function (|
                          Ty.apply (Ty.path "alloc::raw_vec::RawVec") [] [ T; A ],
                          "into_box",
                          [],
                          []
                        |),
                        [
                          M.call_closure (|
                            Ty.apply (Ty.path "alloc::raw_vec::RawVec") [] [ T; A ],
                            M.get_associated_function (|
                              Ty.apply (Ty.path "alloc::raw_vec::RawVec") [] [ T; A ],
                              "from_raw_parts_in",
                              [],
                              []
                            |),
                            [
                              M.call_closure (|
                                Ty.apply (Ty.path "*mut") [] [ T ],
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "core::ptr::non_null::NonNull") [] [ T ],
                                  "as_ptr",
                                  [],
                                  []
                                |),
                                [ M.read (| ptr |) ]
                              |);
                              M.read (| len |);
                              M.read (| alloc |)
                            ]
                          |);
                          M.read (| len |)
                        ]
                      |)
                    ]
                |)
              |)))
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_try_new_zeroed_slice_in :
      forall (T A : Ty.t),
      M.IsAssociatedFunction.Trait
        (Self T A)
        "try_new_zeroed_slice_in"
        (try_new_zeroed_slice_in T A).
    Admitted.
    Global Typeclasses Opaque try_new_zeroed_slice_in.
  End Impl_alloc_boxed_Box_slice_T_A.
  
  Module Impl_alloc_boxed_Box_core_mem_maybe_uninit_MaybeUninit_T_A.
    Definition Self (T A : Ty.t) : Ty.t :=
      Ty.apply
        (Ty.path "alloc::boxed::Box")
        []
        [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ]; A ].
    
    (*
        pub unsafe fn assume_init(self) -> Box<T, A> {
            let (raw, alloc) = Box::into_raw_with_allocator(self);
            unsafe { Box::from_raw_in(raw as *mut T, alloc) }
        }
    *)
    Definition assume_init (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              None,
              M.alloc (|
                M.call_closure (|
                  Ty.tuple
                    [
                      Ty.apply
                        (Ty.path "*mut")
                        []
                        [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ] ];
                      A
                    ],
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "alloc::boxed::Box")
                      []
                      [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ]; A ],
                    "into_raw_with_allocator",
                    [],
                    []
                  |),
                  [ M.read (| self |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let raw := M.copy (| γ0_0 |) in
                    let alloc := M.copy (| γ0_1 |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply (Ty.path "alloc::boxed::Box") [] [ T; A ],
                        M.get_associated_function (|
                          Ty.apply (Ty.path "alloc::boxed::Box") [] [ T; A ],
                          "from_raw_in",
                          [],
                          []
                        |),
                        [
                          M.cast (Ty.apply (Ty.path "*mut") [] [ T ]) (M.read (| raw |));
                          M.read (| alloc |)
                        ]
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_assume_init :
      forall (T A : Ty.t),
      M.IsAssociatedFunction.Trait (Self T A) "assume_init" (assume_init T A).
    Admitted.
    Global Typeclasses Opaque assume_init.
    
    (*
        pub fn write(mut boxed: Self, value: T) -> Box<T, A> {
            unsafe {
                ( *boxed).write(value);
                boxed.assume_init()
            }
        }
    *)
    Definition write (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ boxed; value ] =>
        ltac:(M.monadic
          (let boxed := M.alloc (| boxed |) in
          let value := M.alloc (| value |) in
          M.read (|
            let~ _ : Ty.apply (Ty.path "&mut") [] [ T ] :=
              M.alloc (|
                M.call_closure (|
                  Ty.apply (Ty.path "&mut") [] [ T ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ],
                    "write",
                    [],
                    []
                  |),
                  [
                    M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| boxed |) |) |);
                    M.read (| value |)
                  ]
                |)
              |) in
            M.alloc (|
              M.call_closure (|
                Ty.apply (Ty.path "alloc::boxed::Box") [] [ T; A ],
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "alloc::boxed::Box")
                    []
                    [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ]; A ],
                  "assume_init",
                  [],
                  []
                |),
                [ M.read (| boxed |) ]
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_write :
      forall (T A : Ty.t),
      M.IsAssociatedFunction.Trait (Self T A) "write" (write T A).
    Admitted.
    Global Typeclasses Opaque write.
  End Impl_alloc_boxed_Box_core_mem_maybe_uninit_MaybeUninit_T_A.
  
  Module Impl_alloc_boxed_Box_slice_core_mem_maybe_uninit_MaybeUninit_T_A.
    Definition Self (T A : Ty.t) : Ty.t :=
      Ty.apply
        (Ty.path "alloc::boxed::Box")
        []
        [
          Ty.apply
            (Ty.path "slice")
            []
            [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ] ];
          A
        ].
    
    (*
        pub unsafe fn assume_init(self) -> Box<[T], A> {
            let (raw, alloc) = Box::into_raw_with_allocator(self);
            unsafe { Box::from_raw_in(raw as *mut [T], alloc) }
        }
    *)
    Definition assume_init (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              None,
              M.alloc (|
                M.call_closure (|
                  Ty.tuple
                    [
                      Ty.apply
                        (Ty.path "*mut")
                        []
                        [
                          Ty.apply
                            (Ty.path "slice")
                            []
                            [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ] ]
                        ];
                      A
                    ],
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "alloc::boxed::Box")
                      []
                      [
                        Ty.apply
                          (Ty.path "slice")
                          []
                          [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ] ];
                        A
                      ],
                    "into_raw_with_allocator",
                    [],
                    []
                  |),
                  [ M.read (| self |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let raw := M.copy (| γ0_0 |) in
                    let alloc := M.copy (| γ0_1 |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "alloc::boxed::Box")
                          []
                          [ Ty.apply (Ty.path "slice") [] [ T ]; A ],
                        M.get_associated_function (|
                          Ty.apply
                            (Ty.path "alloc::boxed::Box")
                            []
                            [ Ty.apply (Ty.path "slice") [] [ T ]; A ],
                          "from_raw_in",
                          [],
                          []
                        |),
                        [
                          M.cast
                            (Ty.apply (Ty.path "*mut") [] [ Ty.apply (Ty.path "slice") [] [ T ] ])
                            (M.read (| raw |));
                          M.read (| alloc |)
                        ]
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_assume_init :
      forall (T A : Ty.t),
      M.IsAssociatedFunction.Trait (Self T A) "assume_init" (assume_init T A).
    Admitted.
    Global Typeclasses Opaque assume_init.
  End Impl_alloc_boxed_Box_slice_core_mem_maybe_uninit_MaybeUninit_T_A.
  
  
  
  Module Impl_core_ops_drop_Drop_where_core_marker_Sized_T_where_core_alloc_Allocator_A_for_alloc_boxed_Box_T_A.
    Definition Self (T A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::boxed::Box") [] [ T; A ].
    
    (*
        fn drop(&mut self) {
            // the T in the Box is dropped by the compiler before the destructor is run
    
            let ptr = self.0;
    
            unsafe {
                let layout = Layout::for_value_raw(ptr.as_ptr());
                if layout.size() != 0 {
                    self.1.deallocate(From::from(ptr.cast()), layout);
                }
            }
        }
    *)
    Definition drop (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            let~ ptr : Ty.apply (Ty.path "core::ptr::unique::Unique") [] [ T ] :=
              M.copy (|
                M.SubPointer.get_struct_tuple_field (|
                  M.deref (| M.read (| self |) |),
                  "alloc::boxed::Box",
                  0
                |)
              |) in
            let~ layout : Ty.path "core::alloc::layout::Layout" :=
              M.alloc (|
                M.call_closure (|
                  Ty.path "core::alloc::layout::Layout",
                  M.get_associated_function (|
                    Ty.path "core::alloc::layout::Layout",
                    "for_value_raw",
                    [],
                    [ T ]
                  |),
                  [
                    (* MutToConstPointer *)
                    M.pointer_coercion
                      (M.call_closure (|
                        Ty.apply (Ty.path "*mut") [] [ T ],
                        M.get_associated_function (|
                          Ty.apply (Ty.path "core::ptr::unique::Unique") [] [ T ],
                          "as_ptr",
                          [],
                          []
                        |),
                        [ M.read (| ptr |) ]
                      |))
                  ]
                |)
              |) in
            M.match_operator (|
              Some (Ty.tuple []),
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          BinOp.ne (|
                            M.call_closure (|
                              Ty.path "usize",
                              M.get_associated_function (|
                                Ty.path "core::alloc::layout::Layout",
                                "size",
                                [],
                                []
                              |),
                              [ M.borrow (| Pointer.Kind.Ref, layout |) ]
                            |),
                            Value.Integer IntegerKind.Usize 0
                          |)
                        |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    let~ _ : Ty.tuple [] :=
                      M.alloc (|
                        M.call_closure (|
                          Ty.tuple [],
                          M.get_trait_method (|
                            "core::alloc::Allocator",
                            A,
                            [],
                            [],
                            "deallocate",
                            [],
                            []
                          |),
                          [
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.SubPointer.get_struct_tuple_field (|
                                M.deref (| M.read (| self |) |),
                                "alloc::boxed::Box",
                                1
                              |)
                            |);
                            M.call_closure (|
                              Ty.apply (Ty.path "core::ptr::non_null::NonNull") [] [ Ty.path "u8" ],
                              M.get_trait_method (|
                                "core::convert::From",
                                Ty.apply
                                  (Ty.path "core::ptr::non_null::NonNull")
                                  []
                                  [ Ty.path "u8" ],
                                [],
                                [ Ty.apply (Ty.path "core::ptr::unique::Unique") [] [ Ty.path "u8" ]
                                ],
                                "from",
                                [],
                                []
                              |),
                              [
                                M.call_closure (|
                                  Ty.apply
                                    (Ty.path "core::ptr::unique::Unique")
                                    []
                                    [ Ty.path "u8" ],
                                  M.get_associated_function (|
                                    Ty.apply (Ty.path "core::ptr::unique::Unique") [] [ T ],
                                    "cast",
                                    [],
                                    [ Ty.path "u8" ]
                                  |),
                                  [ M.read (| ptr |) ]
                                |)
                              ]
                            |);
                            M.read (| layout |)
                          ]
                        |)
                      |) in
                    M.alloc (| Value.Tuple [] |)));
                fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (T A : Ty.t),
      M.IsTraitInstance
        "core::ops::drop::Drop"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self T A)
        (* Instance *) [ ("drop", InstanceField.Method (drop T A)) ].
  End Impl_core_ops_drop_Drop_where_core_marker_Sized_T_where_core_alloc_Allocator_A_for_alloc_boxed_Box_T_A.
  
  Module Impl_core_default_Default_where_core_default_Default_T_for_alloc_boxed_Box_T_alloc_alloc_Global.
    Definition Self (T : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "alloc::boxed::Box") [] [ T; Ty.path "alloc::alloc::Global" ].
    
    (*
        fn default() -> Self {
            Box::write(Box::new_uninit(), T::default())
        }
    *)
    Definition default (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [], [] =>
        ltac:(M.monadic
          (M.call_closure (|
            Ty.apply (Ty.path "alloc::boxed::Box") [] [ T; Ty.path "alloc::alloc::Global" ],
            M.get_associated_function (|
              Ty.apply
                (Ty.path "alloc::boxed::Box")
                []
                [
                  Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ];
                  Ty.path "alloc::alloc::Global"
                ],
              "write",
              [],
              []
            |),
            [
              M.call_closure (|
                Ty.apply
                  (Ty.path "alloc::boxed::Box")
                  []
                  [
                    Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ];
                    Ty.path "alloc::alloc::Global"
                  ],
                M.get_associated_function (|
                  Ty.apply (Ty.path "alloc::boxed::Box") [] [ T; Ty.path "alloc::alloc::Global" ],
                  "new_uninit",
                  [],
                  []
                |),
                []
              |);
              M.call_closure (|
                T,
                M.get_trait_method (| "core::default::Default", T, [], [], "default", [], [] |),
                []
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "core::default::Default"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self T)
        (* Instance *) [ ("default", InstanceField.Method (default T)) ].
  End Impl_core_default_Default_where_core_default_Default_T_for_alloc_boxed_Box_T_alloc_alloc_Global.
  
  Module Impl_core_default_Default_for_alloc_boxed_Box_slice_T_alloc_alloc_Global.
    Definition Self (T : Ty.t) : Ty.t :=
      Ty.apply
        (Ty.path "alloc::boxed::Box")
        []
        [ Ty.apply (Ty.path "slice") [] [ T ]; Ty.path "alloc::alloc::Global" ].
    
    (*
        fn default() -> Self {
            let ptr: Unique<[T]> = Unique::<[T; 0]>::dangling();
            Box(ptr, Global)
        }
    *)
    Definition default (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [], [] =>
        ltac:(M.monadic
          (M.read (|
            let~ ptr :
                Ty.apply
                  (Ty.path "core::ptr::unique::Unique")
                  []
                  [ Ty.apply (Ty.path "slice") [] [ T ] ] :=
              M.alloc (|
                M.call_closure (|
                  Ty.apply
                    (Ty.path "core::ptr::unique::Unique")
                    []
                    [ Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 0 ] [ T ] ],
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "core::ptr::unique::Unique")
                      []
                      [ Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 0 ] [ T ] ],
                    "dangling",
                    [],
                    []
                  |),
                  []
                |)
              |) in
            M.alloc (|
              Value.StructTuple
                "alloc::boxed::Box"
                [ M.read (| ptr |); Value.StructTuple "alloc::alloc::Global" [] ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "core::default::Default"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self T)
        (* Instance *) [ ("default", InstanceField.Method (default T)) ].
  End Impl_core_default_Default_for_alloc_boxed_Box_slice_T_alloc_alloc_Global.
  
  Module Impl_core_default_Default_for_alloc_boxed_Box_str_alloc_alloc_Global.
    Definition Self : Ty.t :=
      Ty.apply (Ty.path "alloc::boxed::Box") [] [ Ty.path "str"; Ty.path "alloc::alloc::Global" ].
    
    (*
        fn default() -> Self {
            // SAFETY: This is the same as `Unique::cast<U>` but with an unsized `U = str`.
            let ptr: Unique<str> = unsafe {
                let bytes: Unique<[u8]> = Unique::<[u8; 0]>::dangling();
                Unique::new_unchecked(bytes.as_ptr() as *mut str)
            };
            Box(ptr, Global)
        }
    *)
    Definition default (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [] =>
        ltac:(M.monadic
          (M.read (|
            let~ ptr : Ty.apply (Ty.path "core::ptr::unique::Unique") [] [ Ty.path "str" ] :=
              M.copy (|
                let~ bytes :
                    Ty.apply
                      (Ty.path "core::ptr::unique::Unique")
                      []
                      [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ] :=
                  M.alloc (|
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "core::ptr::unique::Unique")
                        []
                        [
                          Ty.apply
                            (Ty.path "array")
                            [ Value.Integer IntegerKind.Usize 0 ]
                            [ Ty.path "u8" ]
                        ],
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "core::ptr::unique::Unique")
                          []
                          [
                            Ty.apply
                              (Ty.path "array")
                              [ Value.Integer IntegerKind.Usize 0 ]
                              [ Ty.path "u8" ]
                          ],
                        "dangling",
                        [],
                        []
                      |),
                      []
                    |)
                  |) in
                M.alloc (|
                  M.call_closure (|
                    Ty.apply (Ty.path "core::ptr::unique::Unique") [] [ Ty.path "str" ],
                    M.get_associated_function (|
                      Ty.apply (Ty.path "core::ptr::unique::Unique") [] [ Ty.path "str" ],
                      "new_unchecked",
                      [],
                      []
                    |),
                    [
                      M.cast
                        (Ty.apply (Ty.path "*mut") [] [ Ty.path "str" ])
                        (M.call_closure (|
                          Ty.apply
                            (Ty.path "*mut")
                            []
                            [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                          M.get_associated_function (|
                            Ty.apply
                              (Ty.path "core::ptr::unique::Unique")
                              []
                              [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                            "as_ptr",
                            [],
                            []
                          |),
                          [ M.read (| bytes |) ]
                        |))
                    ]
                  |)
                |)
              |) in
            M.alloc (|
              Value.StructTuple
                "alloc::boxed::Box"
                [ M.read (| ptr |); Value.StructTuple "alloc::alloc::Global" [] ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::default::Default"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("default", InstanceField.Method default) ].
  End Impl_core_default_Default_for_alloc_boxed_Box_str_alloc_alloc_Global.
  
  Module Impl_core_clone_Clone_where_core_clone_Clone_T_where_core_alloc_Allocator_A_where_core_clone_Clone_A_for_alloc_boxed_Box_T_A.
    Definition Self (T A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::boxed::Box") [] [ T; A ].
    
    (*
        fn clone(&self) -> Self {
            // Pre-allocate memory to allow writing the cloned value directly.
            let mut boxed = Self::new_uninit_in(self.1.clone());
            unsafe {
                ( **self).clone_to_uninit(boxed.as_mut_ptr().cast());
                boxed.assume_init()
            }
        }
    *)
    Definition clone (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            let~ boxed :
                Ty.apply
                  (Ty.path "alloc::boxed::Box")
                  []
                  [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ]; A ] :=
              M.alloc (|
                M.call_closure (|
                  Ty.apply
                    (Ty.path "alloc::boxed::Box")
                    []
                    [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ]; A ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "alloc::boxed::Box") [] [ T; A ],
                    "new_uninit_in",
                    [],
                    []
                  |),
                  [
                    M.call_closure (|
                      A,
                      M.get_trait_method (| "core::clone::Clone", A, [], [], "clone", [], [] |),
                      [
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_tuple_field (|
                            M.deref (| M.read (| self |) |),
                            "alloc::boxed::Box",
                            1
                          |)
                        |)
                      ]
                    |)
                  ]
                |)
              |) in
            let~ _ : Ty.tuple [] :=
              M.alloc (|
                M.call_closure (|
                  Ty.tuple [],
                  M.get_trait_method (|
                    "core::clone::CloneToUninit",
                    T,
                    [],
                    [],
                    "clone_to_uninit",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
                    |);
                    M.call_closure (|
                      Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ],
                      M.get_associated_function (|
                        Ty.apply (Ty.path "*mut") [] [ T ],
                        "cast",
                        [],
                        [ Ty.path "u8" ]
                      |),
                      [
                        M.call_closure (|
                          Ty.apply (Ty.path "*mut") [] [ T ],
                          M.get_associated_function (|
                            Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ],
                            "as_mut_ptr",
                            [],
                            []
                          |),
                          [ M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| boxed |) |) |) ]
                        |)
                      ]
                    |)
                  ]
                |)
              |) in
            M.alloc (|
              M.call_closure (|
                Ty.apply (Ty.path "alloc::boxed::Box") [] [ T; A ],
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "alloc::boxed::Box")
                    []
                    [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ]; A ],
                  "assume_init",
                  [],
                  []
                |),
                [ M.read (| boxed |) ]
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    (*
        fn clone_from(&mut self, source: &Self) {
            ( **self).clone_from(&( **source));
        }
    *)
    Definition clone_from (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ self; source ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let source := M.alloc (| source |) in
          M.read (|
            let~ _ : Ty.tuple [] :=
              M.alloc (|
                M.call_closure (|
                  Ty.tuple [],
                  M.get_trait_method (| "core::clone::Clone", T, [], [], "clone_from", [], [] |),
                  [
                    M.borrow (|
                      Pointer.Kind.MutRef,
                      M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
                    |);
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.deref (| M.read (| M.deref (| M.read (| source |) |) |) |)
                        |)
                      |)
                    |)
                  ]
                |)
              |) in
            M.alloc (| Value.Tuple [] |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (T A : Ty.t),
      M.IsTraitInstance
        "core::clone::Clone"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self T A)
        (* Instance *)
        [
          ("clone", InstanceField.Method (clone T A));
          ("clone_from", InstanceField.Method (clone_from T A))
        ].
  End Impl_core_clone_Clone_where_core_clone_Clone_T_where_core_alloc_Allocator_A_where_core_clone_Clone_A_for_alloc_boxed_Box_T_A.
  
  Module Impl_core_clone_Clone_where_core_clone_Clone_T_where_core_alloc_Allocator_A_where_core_clone_Clone_A_for_alloc_boxed_Box_slice_T_A.
    Definition Self (T A : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "alloc::boxed::Box") [] [ Ty.apply (Ty.path "slice") [] [ T ]; A ].
    
    (*
        fn clone(&self) -> Self {
            let alloc = Box::allocator(self).clone();
            self.to_vec_in(alloc).into_boxed_slice()
        }
    *)
    Definition clone (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            let~ alloc : A :=
              M.alloc (|
                M.call_closure (|
                  A,
                  M.get_trait_method (| "core::clone::Clone", A, [], [], "clone", [], [] |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.call_closure (|
                          Ty.apply (Ty.path "&") [] [ A ],
                          M.get_associated_function (|
                            Ty.apply
                              (Ty.path "alloc::boxed::Box")
                              []
                              [ Ty.apply (Ty.path "slice") [] [ T ]; A ],
                            "allocator",
                            [],
                            []
                          |),
                          [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                        |)
                      |)
                    |)
                  ]
                |)
              |) in
            M.alloc (|
              M.call_closure (|
                Ty.apply
                  (Ty.path "alloc::boxed::Box")
                  []
                  [ Ty.apply (Ty.path "slice") [] [ T ]; A ],
                M.get_associated_function (|
                  Ty.apply (Ty.path "alloc::vec::Vec") [] [ T; A ],
                  "into_boxed_slice",
                  [],
                  []
                |),
                [
                  M.call_closure (|
                    Ty.apply (Ty.path "alloc::vec::Vec") [] [ T; A ],
                    M.get_associated_function (|
                      Ty.apply (Ty.path "slice") [] [ T ],
                      "to_vec_in",
                      [],
                      [ A ]
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
                      |);
                      M.read (| alloc |)
                    ]
                  |)
                ]
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    (*
        fn clone_from(&mut self, source: &Self) {
            if self.len() == source.len() {
                self.clone_from_slice(&source);
            } else {
                *self = source.clone();
            }
        }
    *)
    Definition clone_from (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ self; source ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let source := M.alloc (| source |) in
          M.read (|
            M.match_operator (|
              Some (Ty.tuple []),
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          BinOp.eq (|
                            M.call_closure (|
                              Ty.path "usize",
                              M.get_associated_function (|
                                Ty.apply (Ty.path "slice") [] [ T ],
                                "len",
                                [],
                                []
                              |),
                              [
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
                                |)
                              ]
                            |),
                            M.call_closure (|
                              Ty.path "usize",
                              M.get_associated_function (|
                                Ty.apply (Ty.path "slice") [] [ T ],
                                "len",
                                [],
                                []
                              |),
                              [
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.deref (| M.read (| M.deref (| M.read (| source |) |) |) |)
                                |)
                              ]
                            |)
                          |)
                        |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    let~ _ : Ty.tuple [] :=
                      M.alloc (|
                        M.call_closure (|
                          Ty.tuple [],
                          M.get_associated_function (|
                            Ty.apply (Ty.path "slice") [] [ T ],
                            "clone_from_slice",
                            [],
                            []
                          |),
                          [
                            M.borrow (|
                              Pointer.Kind.MutRef,
                              M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
                            |);
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.deref (|
                                M.read (|
                                  M.deref (|
                                    M.read (|
                                      M.deref (| M.borrow (| Pointer.Kind.Ref, source |) |)
                                    |)
                                  |)
                                |)
                              |)
                            |)
                          ]
                        |)
                      |) in
                    M.alloc (| Value.Tuple [] |)));
                fun γ =>
                  ltac:(M.monadic
                    (let~ _ : Ty.tuple [] :=
                      M.alloc (|
                        M.write (|
                          M.deref (| M.read (| self |) |),
                          M.call_closure (|
                            Ty.apply
                              (Ty.path "alloc::boxed::Box")
                              []
                              [ Ty.apply (Ty.path "slice") [] [ T ]; A ],
                            M.get_trait_method (|
                              "core::clone::Clone",
                              Ty.apply
                                (Ty.path "alloc::boxed::Box")
                                []
                                [ Ty.apply (Ty.path "slice") [] [ T ]; A ],
                              [],
                              [],
                              "clone",
                              [],
                              []
                            |),
                            [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| source |) |) |) ]
                          |)
                        |)
                      |) in
                    M.alloc (| Value.Tuple [] |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (T A : Ty.t),
      M.IsTraitInstance
        "core::clone::Clone"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self T A)
        (* Instance *)
        [
          ("clone", InstanceField.Method (clone T A));
          ("clone_from", InstanceField.Method (clone_from T A))
        ].
  End Impl_core_clone_Clone_where_core_clone_Clone_T_where_core_alloc_Allocator_A_where_core_clone_Clone_A_for_alloc_boxed_Box_slice_T_A.
  
  Module Impl_core_clone_Clone_for_alloc_boxed_Box_str_alloc_alloc_Global.
    Definition Self : Ty.t :=
      Ty.apply (Ty.path "alloc::boxed::Box") [] [ Ty.path "str"; Ty.path "alloc::alloc::Global" ].
    
    (*
        fn clone(&self) -> Self {
            // this makes a copy of the data
            let buf: Box<[u8]> = self.as_bytes().into();
            unsafe { from_boxed_utf8_unchecked(buf) }
        }
    *)
    Definition clone (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            let~ buf :
                Ty.apply
                  (Ty.path "alloc::boxed::Box")
                  []
                  [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ]; Ty.path "alloc::alloc::Global"
                  ] :=
              M.alloc (|
                M.call_closure (|
                  Ty.apply
                    (Ty.path "alloc::boxed::Box")
                    []
                    [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ]; Ty.path "alloc::alloc::Global"
                    ],
                  M.get_trait_method (|
                    "core::convert::Into",
                    Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                    [],
                    [
                      Ty.apply
                        (Ty.path "alloc::boxed::Box")
                        []
                        [
                          Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ];
                          Ty.path "alloc::alloc::Global"
                        ]
                    ],
                    "into",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "&")
                            []
                            [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                          M.get_associated_function (| Ty.path "str", "as_bytes", [], [] |),
                          [
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
                            |)
                          ]
                        |)
                      |)
                    |)
                  ]
                |)
              |) in
            M.alloc (|
              M.call_closure (|
                Ty.apply
                  (Ty.path "alloc::boxed::Box")
                  []
                  [ Ty.path "str"; Ty.path "alloc::alloc::Global" ],
                M.get_function (| "alloc::str::from_boxed_utf8_unchecked", [], [] |),
                [ M.read (| buf |) ]
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::clone::Clone"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("clone", InstanceField.Method clone) ].
  End Impl_core_clone_Clone_for_alloc_boxed_Box_str_alloc_alloc_Global.
  
  Module Impl_core_cmp_PartialEq_where_core_marker_Sized_T_where_core_cmp_PartialEq_T_where_core_alloc_Allocator_A_alloc_boxed_Box_T_A_for_alloc_boxed_Box_T_A.
    Definition Self (T A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::boxed::Box") [] [ T; A ].
    
    (*
        fn eq(&self, other: &Self) -> bool {
            PartialEq::eq(&**self, &**other)
        }
    *)
    Definition eq (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            Ty.path "bool",
            M.get_trait_method (| "core::cmp::PartialEq", T, [], [ T ], "eq", [], [] |),
            [
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
                  |)
                |)
              |);
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (| M.read (| M.deref (| M.read (| other |) |) |) |)
                  |)
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    (*
        fn ne(&self, other: &Self) -> bool {
            PartialEq::ne(&**self, &**other)
        }
    *)
    Definition ne (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            Ty.path "bool",
            M.get_trait_method (| "core::cmp::PartialEq", T, [], [ T ], "ne", [], [] |),
            [
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
                  |)
                |)
              |);
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (| M.read (| M.deref (| M.read (| other |) |) |) |)
                  |)
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (T A : Ty.t),
      M.IsTraitInstance
        "core::cmp::PartialEq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.apply (Ty.path "alloc::boxed::Box") [] [ T; A ] ]
        (Self T A)
        (* Instance *)
        [ ("eq", InstanceField.Method (eq T A)); ("ne", InstanceField.Method (ne T A)) ].
  End Impl_core_cmp_PartialEq_where_core_marker_Sized_T_where_core_cmp_PartialEq_T_where_core_alloc_Allocator_A_alloc_boxed_Box_T_A_for_alloc_boxed_Box_T_A.
  
  Module Impl_core_cmp_PartialOrd_where_core_marker_Sized_T_where_core_cmp_PartialOrd_T_where_core_alloc_Allocator_A_alloc_boxed_Box_T_A_for_alloc_boxed_Box_T_A.
    Definition Self (T A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::boxed::Box") [] [ T; A ].
    
    (*
        fn partial_cmp(&self, other: &Self) -> Option<Ordering> {
            PartialOrd::partial_cmp(&**self, &**other)
        }
    *)
    Definition partial_cmp (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "core::cmp::Ordering" ],
            M.get_trait_method (| "core::cmp::PartialOrd", T, [], [ T ], "partial_cmp", [], [] |),
            [
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
                  |)
                |)
              |);
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (| M.read (| M.deref (| M.read (| other |) |) |) |)
                  |)
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    (*
        fn lt(&self, other: &Self) -> bool {
            PartialOrd::lt(&**self, &**other)
        }
    *)
    Definition lt (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            Ty.path "bool",
            M.get_trait_method (| "core::cmp::PartialOrd", T, [], [ T ], "lt", [], [] |),
            [
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
                  |)
                |)
              |);
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (| M.read (| M.deref (| M.read (| other |) |) |) |)
                  |)
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    (*
        fn le(&self, other: &Self) -> bool {
            PartialOrd::le(&**self, &**other)
        }
    *)
    Definition le (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            Ty.path "bool",
            M.get_trait_method (| "core::cmp::PartialOrd", T, [], [ T ], "le", [], [] |),
            [
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
                  |)
                |)
              |);
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (| M.read (| M.deref (| M.read (| other |) |) |) |)
                  |)
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    (*
        fn ge(&self, other: &Self) -> bool {
            PartialOrd::ge(&**self, &**other)
        }
    *)
    Definition ge (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            Ty.path "bool",
            M.get_trait_method (| "core::cmp::PartialOrd", T, [], [ T ], "ge", [], [] |),
            [
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
                  |)
                |)
              |);
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (| M.read (| M.deref (| M.read (| other |) |) |) |)
                  |)
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    (*
        fn gt(&self, other: &Self) -> bool {
            PartialOrd::gt(&**self, &**other)
        }
    *)
    Definition gt (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            Ty.path "bool",
            M.get_trait_method (| "core::cmp::PartialOrd", T, [], [ T ], "gt", [], [] |),
            [
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
                  |)
                |)
              |);
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (| M.read (| M.deref (| M.read (| other |) |) |) |)
                  |)
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (T A : Ty.t),
      M.IsTraitInstance
        "core::cmp::PartialOrd"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.apply (Ty.path "alloc::boxed::Box") [] [ T; A ] ]
        (Self T A)
        (* Instance *)
        [
          ("partial_cmp", InstanceField.Method (partial_cmp T A));
          ("lt", InstanceField.Method (lt T A));
          ("le", InstanceField.Method (le T A));
          ("ge", InstanceField.Method (ge T A));
          ("gt", InstanceField.Method (gt T A))
        ].
  End Impl_core_cmp_PartialOrd_where_core_marker_Sized_T_where_core_cmp_PartialOrd_T_where_core_alloc_Allocator_A_alloc_boxed_Box_T_A_for_alloc_boxed_Box_T_A.
  
  Module Impl_core_cmp_Ord_where_core_marker_Sized_T_where_core_cmp_Ord_T_where_core_alloc_Allocator_A_for_alloc_boxed_Box_T_A.
    Definition Self (T A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::boxed::Box") [] [ T; A ].
    
    (*
        fn cmp(&self, other: &Self) -> Ordering {
            Ord::cmp(&**self, &**other)
        }
    *)
    Definition cmp (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            Ty.path "core::cmp::Ordering",
            M.get_trait_method (| "core::cmp::Ord", T, [], [], "cmp", [], [] |),
            [
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
                  |)
                |)
              |);
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (| M.read (| M.deref (| M.read (| other |) |) |) |)
                  |)
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (T A : Ty.t),
      M.IsTraitInstance
        "core::cmp::Ord"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self T A)
        (* Instance *) [ ("cmp", InstanceField.Method (cmp T A)) ].
  End Impl_core_cmp_Ord_where_core_marker_Sized_T_where_core_cmp_Ord_T_where_core_alloc_Allocator_A_for_alloc_boxed_Box_T_A.
  
  Module Impl_core_cmp_Eq_where_core_marker_Sized_T_where_core_cmp_Eq_T_where_core_alloc_Allocator_A_for_alloc_boxed_Box_T_A.
    Definition Self (T A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::boxed::Box") [] [ T; A ].
    
    Axiom Implements :
      forall (T A : Ty.t),
      M.IsTraitInstance
        "core::cmp::Eq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self T A)
        (* Instance *) [].
  End Impl_core_cmp_Eq_where_core_marker_Sized_T_where_core_cmp_Eq_T_where_core_alloc_Allocator_A_for_alloc_boxed_Box_T_A.
  
  Module Impl_core_hash_Hash_where_core_marker_Sized_T_where_core_hash_Hash_T_where_core_alloc_Allocator_A_for_alloc_boxed_Box_T_A.
    Definition Self (T A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::boxed::Box") [] [ T; A ].
    
    (*
        fn hash<H: Hasher>(&self, state: &mut H) {
            ( **self).hash(state);
        }
    *)
    Definition hash (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [ H ], [ self; state ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let state := M.alloc (| state |) in
          M.read (|
            let~ _ : Ty.tuple [] :=
              M.alloc (|
                M.call_closure (|
                  Ty.tuple [],
                  M.get_trait_method (| "core::hash::Hash", T, [], [], "hash", [], [ H ] |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
                    |);
                    M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                  ]
                |)
              |) in
            M.alloc (| Value.Tuple [] |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (T A : Ty.t),
      M.IsTraitInstance
        "core::hash::Hash"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self T A)
        (* Instance *) [ ("hash", InstanceField.Method (hash T A)) ].
  End Impl_core_hash_Hash_where_core_marker_Sized_T_where_core_hash_Hash_T_where_core_alloc_Allocator_A_for_alloc_boxed_Box_T_A.
  
  Module Impl_core_hash_Hasher_where_core_marker_Sized_T_where_core_hash_Hasher_T_where_core_alloc_Allocator_A_for_alloc_boxed_Box_T_A.
    Definition Self (T A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::boxed::Box") [] [ T; A ].
    
    (*
        fn finish(&self) -> u64 {
            ( **self).finish()
        }
    *)
    Definition finish (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            Ty.path "u64",
            M.get_trait_method (| "core::hash::Hasher", T, [], [], "finish", [], [] |),
            [
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    (*
        fn write(&mut self, bytes: &[u8]) {
            ( **self).write(bytes)
        }
    *)
    Definition write (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ self; bytes ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let bytes := M.alloc (| bytes |) in
          M.call_closure (|
            Ty.tuple [],
            M.get_trait_method (| "core::hash::Hasher", T, [], [], "write", [], [] |),
            [
              M.borrow (|
                Pointer.Kind.MutRef,
                M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
              |);
              M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| bytes |) |) |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    (*
        fn write_u8(&mut self, i: u8) {
            ( **self).write_u8(i)
        }
    *)
    Definition write_u8 (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ self; i ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let i := M.alloc (| i |) in
          M.call_closure (|
            Ty.tuple [],
            M.get_trait_method (| "core::hash::Hasher", T, [], [], "write_u8", [], [] |),
            [
              M.borrow (|
                Pointer.Kind.MutRef,
                M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
              |);
              M.read (| i |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    (*
        fn write_u16(&mut self, i: u16) {
            ( **self).write_u16(i)
        }
    *)
    Definition write_u16 (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ self; i ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let i := M.alloc (| i |) in
          M.call_closure (|
            Ty.tuple [],
            M.get_trait_method (| "core::hash::Hasher", T, [], [], "write_u16", [], [] |),
            [
              M.borrow (|
                Pointer.Kind.MutRef,
                M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
              |);
              M.read (| i |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    (*
        fn write_u32(&mut self, i: u32) {
            ( **self).write_u32(i)
        }
    *)
    Definition write_u32 (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ self; i ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let i := M.alloc (| i |) in
          M.call_closure (|
            Ty.tuple [],
            M.get_trait_method (| "core::hash::Hasher", T, [], [], "write_u32", [], [] |),
            [
              M.borrow (|
                Pointer.Kind.MutRef,
                M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
              |);
              M.read (| i |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    (*
        fn write_u64(&mut self, i: u64) {
            ( **self).write_u64(i)
        }
    *)
    Definition write_u64 (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ self; i ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let i := M.alloc (| i |) in
          M.call_closure (|
            Ty.tuple [],
            M.get_trait_method (| "core::hash::Hasher", T, [], [], "write_u64", [], [] |),
            [
              M.borrow (|
                Pointer.Kind.MutRef,
                M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
              |);
              M.read (| i |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    (*
        fn write_u128(&mut self, i: u128) {
            ( **self).write_u128(i)
        }
    *)
    Definition write_u128 (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ self; i ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let i := M.alloc (| i |) in
          M.call_closure (|
            Ty.tuple [],
            M.get_trait_method (| "core::hash::Hasher", T, [], [], "write_u128", [], [] |),
            [
              M.borrow (|
                Pointer.Kind.MutRef,
                M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
              |);
              M.read (| i |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    (*
        fn write_usize(&mut self, i: usize) {
            ( **self).write_usize(i)
        }
    *)
    Definition write_usize (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ self; i ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let i := M.alloc (| i |) in
          M.call_closure (|
            Ty.tuple [],
            M.get_trait_method (| "core::hash::Hasher", T, [], [], "write_usize", [], [] |),
            [
              M.borrow (|
                Pointer.Kind.MutRef,
                M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
              |);
              M.read (| i |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    (*
        fn write_i8(&mut self, i: i8) {
            ( **self).write_i8(i)
        }
    *)
    Definition write_i8 (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ self; i ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let i := M.alloc (| i |) in
          M.call_closure (|
            Ty.tuple [],
            M.get_trait_method (| "core::hash::Hasher", T, [], [], "write_i8", [], [] |),
            [
              M.borrow (|
                Pointer.Kind.MutRef,
                M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
              |);
              M.read (| i |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    (*
        fn write_i16(&mut self, i: i16) {
            ( **self).write_i16(i)
        }
    *)
    Definition write_i16 (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ self; i ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let i := M.alloc (| i |) in
          M.call_closure (|
            Ty.tuple [],
            M.get_trait_method (| "core::hash::Hasher", T, [], [], "write_i16", [], [] |),
            [
              M.borrow (|
                Pointer.Kind.MutRef,
                M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
              |);
              M.read (| i |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    (*
        fn write_i32(&mut self, i: i32) {
            ( **self).write_i32(i)
        }
    *)
    Definition write_i32 (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ self; i ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let i := M.alloc (| i |) in
          M.call_closure (|
            Ty.tuple [],
            M.get_trait_method (| "core::hash::Hasher", T, [], [], "write_i32", [], [] |),
            [
              M.borrow (|
                Pointer.Kind.MutRef,
                M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
              |);
              M.read (| i |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    (*
        fn write_i64(&mut self, i: i64) {
            ( **self).write_i64(i)
        }
    *)
    Definition write_i64 (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ self; i ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let i := M.alloc (| i |) in
          M.call_closure (|
            Ty.tuple [],
            M.get_trait_method (| "core::hash::Hasher", T, [], [], "write_i64", [], [] |),
            [
              M.borrow (|
                Pointer.Kind.MutRef,
                M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
              |);
              M.read (| i |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    (*
        fn write_i128(&mut self, i: i128) {
            ( **self).write_i128(i)
        }
    *)
    Definition write_i128 (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ self; i ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let i := M.alloc (| i |) in
          M.call_closure (|
            Ty.tuple [],
            M.get_trait_method (| "core::hash::Hasher", T, [], [], "write_i128", [], [] |),
            [
              M.borrow (|
                Pointer.Kind.MutRef,
                M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
              |);
              M.read (| i |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    (*
        fn write_isize(&mut self, i: isize) {
            ( **self).write_isize(i)
        }
    *)
    Definition write_isize (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ self; i ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let i := M.alloc (| i |) in
          M.call_closure (|
            Ty.tuple [],
            M.get_trait_method (| "core::hash::Hasher", T, [], [], "write_isize", [], [] |),
            [
              M.borrow (|
                Pointer.Kind.MutRef,
                M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
              |);
              M.read (| i |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    (*
        fn write_length_prefix(&mut self, len: usize) {
            ( **self).write_length_prefix(len)
        }
    *)
    Definition write_length_prefix
        (T A : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ self; len ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let len := M.alloc (| len |) in
          M.call_closure (|
            Ty.tuple [],
            M.get_trait_method (| "core::hash::Hasher", T, [], [], "write_length_prefix", [], [] |),
            [
              M.borrow (|
                Pointer.Kind.MutRef,
                M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
              |);
              M.read (| len |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    (*
        fn write_str(&mut self, s: &str) {
            ( **self).write_str(s)
        }
    *)
    Definition write_str (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ self; s ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let s := M.alloc (| s |) in
          M.call_closure (|
            Ty.tuple [],
            M.get_trait_method (| "core::hash::Hasher", T, [], [], "write_str", [], [] |),
            [
              M.borrow (|
                Pointer.Kind.MutRef,
                M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
              |);
              M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| s |) |) |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (T A : Ty.t),
      M.IsTraitInstance
        "core::hash::Hasher"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self T A)
        (* Instance *)
        [
          ("finish", InstanceField.Method (finish T A));
          ("write", InstanceField.Method (write T A));
          ("write_u8", InstanceField.Method (write_u8 T A));
          ("write_u16", InstanceField.Method (write_u16 T A));
          ("write_u32", InstanceField.Method (write_u32 T A));
          ("write_u64", InstanceField.Method (write_u64 T A));
          ("write_u128", InstanceField.Method (write_u128 T A));
          ("write_usize", InstanceField.Method (write_usize T A));
          ("write_i8", InstanceField.Method (write_i8 T A));
          ("write_i16", InstanceField.Method (write_i16 T A));
          ("write_i32", InstanceField.Method (write_i32 T A));
          ("write_i64", InstanceField.Method (write_i64 T A));
          ("write_i128", InstanceField.Method (write_i128 T A));
          ("write_isize", InstanceField.Method (write_isize T A));
          ("write_length_prefix", InstanceField.Method (write_length_prefix T A));
          ("write_str", InstanceField.Method (write_str T A))
        ].
  End Impl_core_hash_Hasher_where_core_marker_Sized_T_where_core_hash_Hasher_T_where_core_alloc_Allocator_A_for_alloc_boxed_Box_T_A.
  
  Module Impl_core_fmt_Display_where_core_fmt_Display_T_where_core_marker_Sized_T_where_core_alloc_Allocator_A_for_alloc_boxed_Box_T_A.
    Definition Self (T A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::boxed::Box") [] [ T; A ].
    
    (*
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            fmt::Display::fmt(&**self, f)
        }
    *)
    Definition fmt (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "core::result::Result")
              []
              [ Ty.tuple []; Ty.path "core::fmt::Error" ],
            M.get_trait_method (| "core::fmt::Display", T, [], [], "fmt", [], [] |),
            [
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
                  |)
                |)
              |);
              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (T A : Ty.t),
      M.IsTraitInstance
        "core::fmt::Display"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self T A)
        (* Instance *) [ ("fmt", InstanceField.Method (fmt T A)) ].
  End Impl_core_fmt_Display_where_core_fmt_Display_T_where_core_marker_Sized_T_where_core_alloc_Allocator_A_for_alloc_boxed_Box_T_A.
  
  Module Impl_core_fmt_Debug_where_core_fmt_Debug_T_where_core_marker_Sized_T_where_core_alloc_Allocator_A_for_alloc_boxed_Box_T_A.
    Definition Self (T A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::boxed::Box") [] [ T; A ].
    
    (*
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            fmt::Debug::fmt(&**self, f)
        }
    *)
    Definition fmt (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "core::result::Result")
              []
              [ Ty.tuple []; Ty.path "core::fmt::Error" ],
            M.get_trait_method (| "core::fmt::Debug", T, [], [], "fmt", [], [] |),
            [
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
                  |)
                |)
              |);
              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (T A : Ty.t),
      M.IsTraitInstance
        "core::fmt::Debug"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self T A)
        (* Instance *) [ ("fmt", InstanceField.Method (fmt T A)) ].
  End Impl_core_fmt_Debug_where_core_fmt_Debug_T_where_core_marker_Sized_T_where_core_alloc_Allocator_A_for_alloc_boxed_Box_T_A.
  
  Module Impl_core_fmt_Pointer_where_core_marker_Sized_T_where_core_alloc_Allocator_A_for_alloc_boxed_Box_T_A.
    Definition Self (T A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::boxed::Box") [] [ T; A ].
    
    (*
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            // It's not possible to extract the inner Uniq directly from the Box,
            // instead we cast it to a *const which aliases the Unique
            let ptr: *const T = &**self;
            fmt::Pointer::fmt(&ptr, f)
        }
    *)
    Definition fmt (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.read (|
            let~ ptr : Ty.apply (Ty.path "*const") [] [ T ] :=
              M.alloc (|
                M.borrow (|
                  Pointer.Kind.ConstPointer,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
                    |)
                  |)
                |)
              |) in
            M.alloc (|
              M.call_closure (|
                Ty.apply
                  (Ty.path "core::result::Result")
                  []
                  [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                M.get_trait_method (|
                  "core::fmt::Pointer",
                  Ty.apply (Ty.path "*const") [] [ T ],
                  [],
                  [],
                  "fmt",
                  [],
                  []
                |),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (| M.borrow (| Pointer.Kind.Ref, ptr |) |)
                  |);
                  M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |)
                ]
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (T A : Ty.t),
      M.IsTraitInstance
        "core::fmt::Pointer"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self T A)
        (* Instance *) [ ("fmt", InstanceField.Method (fmt T A)) ].
  End Impl_core_fmt_Pointer_where_core_marker_Sized_T_where_core_alloc_Allocator_A_for_alloc_boxed_Box_T_A.
  
  Module Impl_core_ops_deref_Deref_where_core_marker_Sized_T_where_core_alloc_Allocator_A_for_alloc_boxed_Box_T_A.
    Definition Self (T A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::boxed::Box") [] [ T; A ].
    
    (*     type Target = T; *)
    Definition _Target (T A : Ty.t) : Ty.t := T.
    
    (*
        fn deref(&self) -> &T {
            &**self
        }
    *)
    Definition deref (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.borrow (|
            Pointer.Kind.Ref,
            M.deref (|
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (T A : Ty.t),
      M.IsTraitInstance
        "core::ops::deref::Deref"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self T A)
        (* Instance *)
        [ ("Target", InstanceField.Ty (_Target T A)); ("deref", InstanceField.Method (deref T A)) ].
  End Impl_core_ops_deref_Deref_where_core_marker_Sized_T_where_core_alloc_Allocator_A_for_alloc_boxed_Box_T_A.
  
  Module Impl_core_ops_deref_DerefMut_where_core_marker_Sized_T_where_core_alloc_Allocator_A_for_alloc_boxed_Box_T_A.
    Definition Self (T A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::boxed::Box") [] [ T; A ].
    
    (*
        fn deref_mut(&mut self) -> &mut T {
            &mut **self
        }
    *)
    Definition deref_mut (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.borrow (|
            Pointer.Kind.MutRef,
            M.deref (|
              M.borrow (|
                Pointer.Kind.MutRef,
                M.deref (|
                  M.borrow (|
                    Pointer.Kind.MutRef,
                    M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
                  |)
                |)
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (T A : Ty.t),
      M.IsTraitInstance
        "core::ops::deref::DerefMut"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self T A)
        (* Instance *) [ ("deref_mut", InstanceField.Method (deref_mut T A)) ].
  End Impl_core_ops_deref_DerefMut_where_core_marker_Sized_T_where_core_alloc_Allocator_A_for_alloc_boxed_Box_T_A.
  
  Module Impl_core_ops_deref_DerefPure_where_core_marker_Sized_T_where_core_alloc_Allocator_A_for_alloc_boxed_Box_T_A.
    Definition Self (T A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::boxed::Box") [] [ T; A ].
    
    Axiom Implements :
      forall (T A : Ty.t),
      M.IsTraitInstance
        "core::ops::deref::DerefPure"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self T A)
        (* Instance *) [].
  End Impl_core_ops_deref_DerefPure_where_core_marker_Sized_T_where_core_alloc_Allocator_A_for_alloc_boxed_Box_T_A.
  
  Module Impl_core_ops_deref_LegacyReceiver_where_core_marker_Sized_T_where_core_alloc_Allocator_A_for_alloc_boxed_Box_T_A.
    Definition Self (T A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::boxed::Box") [] [ T; A ].
    
    Axiom Implements :
      forall (T A : Ty.t),
      M.IsTraitInstance
        "core::ops::deref::LegacyReceiver"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self T A)
        (* Instance *) [].
  End Impl_core_ops_deref_LegacyReceiver_where_core_marker_Sized_T_where_core_alloc_Allocator_A_for_alloc_boxed_Box_T_A.
  
  Module Impl_core_ops_function_FnOnce_where_core_marker_Tuple_Args_where_core_ops_function_FnOnce_F_Args_where_core_marker_Sized_F_where_core_alloc_Allocator_A_Args_for_alloc_boxed_Box_F_A.
    Definition Self (Args F A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::boxed::Box") [] [ F; A ].
    
    (*     type Output = <F as FnOnce<Args>>::Output; *)
    Definition _Output (Args F A : Ty.t) : Ty.t :=
      Ty.associated_in_trait "core::ops::function::FnOnce" [] [ Args ] F "Output".
    
    (*
        extern "rust-call" fn call_once(self, args: Args) -> Self::Output {
            <F as FnOnce<Args>>::call_once( *self, args)
        }
    *)
    Definition call_once
        (Args F A : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self Args F A in
      match ε, τ, α with
      | [], [], [ self; args ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let args := M.alloc (| args |) in
          M.call_closure (|
            Ty.associated_in_trait "core::ops::function::FnOnce" [] [ Args ] F "Output",
            M.get_trait_method (|
              "core::ops::function::FnOnce",
              F,
              [],
              [ Args ],
              "call_once",
              [],
              []
            |),
            [ M.read (| M.deref (| M.read (| self |) |) |); M.read (| args |) ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (Args F A : Ty.t),
      M.IsTraitInstance
        "core::ops::function::FnOnce"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Args ]
        (Self Args F A)
        (* Instance *)
        [
          ("Output", InstanceField.Ty (_Output Args F A));
          ("call_once", InstanceField.Method (call_once Args F A))
        ].
  End Impl_core_ops_function_FnOnce_where_core_marker_Tuple_Args_where_core_ops_function_FnOnce_F_Args_where_core_marker_Sized_F_where_core_alloc_Allocator_A_Args_for_alloc_boxed_Box_F_A.
  
  Module Impl_core_ops_function_FnMut_where_core_marker_Tuple_Args_where_core_ops_function_FnMut_F_Args_where_core_marker_Sized_F_where_core_alloc_Allocator_A_Args_for_alloc_boxed_Box_F_A.
    Definition Self (Args F A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::boxed::Box") [] [ F; A ].
    
    (*
        extern "rust-call" fn call_mut(&mut self, args: Args) -> Self::Output {
            <F as FnMut<Args>>::call_mut(self, args)
        }
    *)
    Definition call_mut
        (Args F A : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self Args F A in
      match ε, τ, α with
      | [], [], [ self; args ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let args := M.alloc (| args |) in
          M.call_closure (|
            Ty.associated_in_trait "core::ops::function::FnOnce" [] [ Args ] F "Output",
            M.get_trait_method (|
              "core::ops::function::FnMut",
              F,
              [],
              [ Args ],
              "call_mut",
              [],
              []
            |),
            [
              M.borrow (|
                Pointer.Kind.MutRef,
                M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
              |);
              M.read (| args |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (Args F A : Ty.t),
      M.IsTraitInstance
        "core::ops::function::FnMut"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Args ]
        (Self Args F A)
        (* Instance *) [ ("call_mut", InstanceField.Method (call_mut Args F A)) ].
  End Impl_core_ops_function_FnMut_where_core_marker_Tuple_Args_where_core_ops_function_FnMut_F_Args_where_core_marker_Sized_F_where_core_alloc_Allocator_A_Args_for_alloc_boxed_Box_F_A.
  
  Module Impl_core_ops_function_Fn_where_core_marker_Tuple_Args_where_core_ops_function_Fn_F_Args_where_core_marker_Sized_F_where_core_alloc_Allocator_A_Args_for_alloc_boxed_Box_F_A.
    Definition Self (Args F A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::boxed::Box") [] [ F; A ].
    
    (*
        extern "rust-call" fn call(&self, args: Args) -> Self::Output {
            <F as Fn<Args>>::call(self, args)
        }
    *)
    Definition call (Args F A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self Args F A in
      match ε, τ, α with
      | [], [], [ self; args ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let args := M.alloc (| args |) in
          M.call_closure (|
            Ty.associated_in_trait "core::ops::function::FnOnce" [] [ Args ] F "Output",
            M.get_trait_method (| "core::ops::function::Fn", F, [], [ Args ], "call", [], [] |),
            [
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
              |);
              M.read (| args |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (Args F A : Ty.t),
      M.IsTraitInstance
        "core::ops::function::Fn"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Args ]
        (Self Args F A)
        (* Instance *) [ ("call", InstanceField.Method (call Args F A)) ].
  End Impl_core_ops_function_Fn_where_core_marker_Tuple_Args_where_core_ops_function_Fn_F_Args_where_core_marker_Sized_F_where_core_alloc_Allocator_A_Args_for_alloc_boxed_Box_F_A.
  
  Module Impl_core_ops_async_function_AsyncFnOnce_where_core_marker_Tuple_Args_where_core_ops_async_function_AsyncFnOnce_F_Args_where_core_marker_Sized_F_where_core_alloc_Allocator_A_Args_for_alloc_boxed_Box_F_A.
    Definition Self (Args F A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::boxed::Box") [] [ F; A ].
    
    (*     type Output = F::Output; *)
    Definition _Output (Args F A : Ty.t) : Ty.t :=
      Ty.associated_in_trait "core::ops::async_function::AsyncFnOnce" [] [ Args ] F "Output".
    
    (*     type CallOnceFuture = F::CallOnceFuture; *)
    Definition _CallOnceFuture (Args F A : Ty.t) : Ty.t :=
      Ty.associated_in_trait
        "core::ops::async_function::AsyncFnOnce"
        []
        [ Args ]
        F
        "CallOnceFuture".
    
    (*
        extern "rust-call" fn async_call_once(self, args: Args) -> Self::CallOnceFuture {
            F::async_call_once( *self, args)
        }
    *)
    Definition async_call_once
        (Args F A : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self Args F A in
      match ε, τ, α with
      | [], [], [ self; args ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let args := M.alloc (| args |) in
          M.call_closure (|
            Ty.associated_in_trait
              "core::ops::async_function::AsyncFnOnce"
              []
              [ Args ]
              F
              "CallOnceFuture",
            M.get_trait_method (|
              "core::ops::async_function::AsyncFnOnce",
              F,
              [],
              [ Args ],
              "async_call_once",
              [],
              []
            |),
            [ M.read (| M.deref (| M.read (| self |) |) |); M.read (| args |) ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (Args F A : Ty.t),
      M.IsTraitInstance
        "core::ops::async_function::AsyncFnOnce"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Args ]
        (Self Args F A)
        (* Instance *)
        [
          ("Output", InstanceField.Ty (_Output Args F A));
          ("CallOnceFuture", InstanceField.Ty (_CallOnceFuture Args F A));
          ("async_call_once", InstanceField.Method (async_call_once Args F A))
        ].
  End Impl_core_ops_async_function_AsyncFnOnce_where_core_marker_Tuple_Args_where_core_ops_async_function_AsyncFnOnce_F_Args_where_core_marker_Sized_F_where_core_alloc_Allocator_A_Args_for_alloc_boxed_Box_F_A.
  
  Module Impl_core_ops_async_function_AsyncFnMut_where_core_marker_Tuple_Args_where_core_ops_async_function_AsyncFnMut_F_Args_where_core_marker_Sized_F_where_core_alloc_Allocator_A_Args_for_alloc_boxed_Box_F_A.
    Definition Self (Args F A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::boxed::Box") [] [ F; A ].
    
    (*
        type CallRefFuture<'a>
            = F::CallRefFuture<'a>
        where
            Self: 'a;
    *)
    Definition _CallRefFuture (Args F A : Ty.t) : Ty.t :=
      Ty.associated_in_trait "core::ops::async_function::AsyncFnMut" [] [ Args ] F "CallRefFuture".
    
    (*
        extern "rust-call" fn async_call_mut(&mut self, args: Args) -> Self::CallRefFuture<'_> {
            F::async_call_mut(self, args)
        }
    *)
    Definition async_call_mut
        (Args F A : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self Args F A in
      match ε, τ, α with
      | [], [], [ self; args ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let args := M.alloc (| args |) in
          M.call_closure (|
            Ty.associated_in_trait
              "core::ops::async_function::AsyncFnMut"
              []
              [ Args ]
              F
              "CallRefFuture",
            M.get_trait_method (|
              "core::ops::async_function::AsyncFnMut",
              F,
              [],
              [ Args ],
              "async_call_mut",
              [],
              []
            |),
            [
              M.borrow (|
                Pointer.Kind.MutRef,
                M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
              |);
              M.read (| args |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (Args F A : Ty.t),
      M.IsTraitInstance
        "core::ops::async_function::AsyncFnMut"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Args ]
        (Self Args F A)
        (* Instance *)
        [
          ("CallRefFuture", InstanceField.Ty (_CallRefFuture Args F A));
          ("async_call_mut", InstanceField.Method (async_call_mut Args F A))
        ].
  End Impl_core_ops_async_function_AsyncFnMut_where_core_marker_Tuple_Args_where_core_ops_async_function_AsyncFnMut_F_Args_where_core_marker_Sized_F_where_core_alloc_Allocator_A_Args_for_alloc_boxed_Box_F_A.
  
  Module Impl_core_ops_async_function_AsyncFn_where_core_marker_Tuple_Args_where_core_ops_async_function_AsyncFn_F_Args_where_core_marker_Sized_F_where_core_alloc_Allocator_A_Args_for_alloc_boxed_Box_F_A.
    Definition Self (Args F A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::boxed::Box") [] [ F; A ].
    
    (*
        extern "rust-call" fn async_call(&self, args: Args) -> Self::CallRefFuture<'_> {
            F::async_call(self, args)
        }
    *)
    Definition async_call
        (Args F A : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self Args F A in
      match ε, τ, α with
      | [], [], [ self; args ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let args := M.alloc (| args |) in
          M.call_closure (|
            Ty.associated_in_trait
              "core::ops::async_function::AsyncFnMut"
              []
              [ Args ]
              F
              "CallRefFuture",
            M.get_trait_method (|
              "core::ops::async_function::AsyncFn",
              F,
              [],
              [ Args ],
              "async_call",
              [],
              []
            |),
            [
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
              |);
              M.read (| args |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (Args F A : Ty.t),
      M.IsTraitInstance
        "core::ops::async_function::AsyncFn"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Args ]
        (Self Args F A)
        (* Instance *) [ ("async_call", InstanceField.Method (async_call Args F A)) ].
  End Impl_core_ops_async_function_AsyncFn_where_core_marker_Tuple_Args_where_core_ops_async_function_AsyncFn_F_Args_where_core_marker_Sized_F_where_core_alloc_Allocator_A_Args_for_alloc_boxed_Box_F_A.
  
  Module Impl_core_ops_unsize_CoerceUnsized_where_core_marker_Sized_T_where_core_marker_Unsize_T_U_where_core_marker_Sized_U_where_core_alloc_Allocator_A_alloc_boxed_Box_U_A_for_alloc_boxed_Box_T_A.
    Definition Self (T U A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::boxed::Box") [] [ T; A ].
    
    Axiom Implements :
      forall (T U A : Ty.t),
      M.IsTraitInstance
        "core::ops::unsize::CoerceUnsized"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.apply (Ty.path "alloc::boxed::Box") [] [ U; A ] ]
        (Self T U A)
        (* Instance *) [].
  End Impl_core_ops_unsize_CoerceUnsized_where_core_marker_Sized_T_where_core_marker_Unsize_T_U_where_core_marker_Sized_U_where_core_alloc_Allocator_A_alloc_boxed_Box_U_A_for_alloc_boxed_Box_T_A.
  
  Module Impl_core_pin_PinCoerceUnsized_where_core_marker_Sized_T_where_core_alloc_Allocator_A_for_alloc_boxed_Box_T_A.
    Definition Self (T A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::boxed::Box") [] [ T; A ].
    
    Axiom Implements :
      forall (T A : Ty.t),
      M.IsTraitInstance
        "core::pin::PinCoerceUnsized"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self T A)
        (* Instance *) [].
  End Impl_core_pin_PinCoerceUnsized_where_core_marker_Sized_T_where_core_alloc_Allocator_A_for_alloc_boxed_Box_T_A.
  
  Module Impl_core_ops_unsize_DispatchFromDyn_where_core_marker_Sized_T_where_core_marker_Unsize_T_U_where_core_marker_Sized_U_alloc_boxed_Box_U_alloc_alloc_Global_for_alloc_boxed_Box_T_alloc_alloc_Global.
    Definition Self (T U : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "alloc::boxed::Box") [] [ T; Ty.path "alloc::alloc::Global" ].
    
    Axiom Implements :
      forall (T U : Ty.t),
      M.IsTraitInstance
        "core::ops::unsize::DispatchFromDyn"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *)
        [ Ty.apply (Ty.path "alloc::boxed::Box") [] [ U; Ty.path "alloc::alloc::Global" ] ]
        (Self T U)
        (* Instance *) [].
  End Impl_core_ops_unsize_DispatchFromDyn_where_core_marker_Sized_T_where_core_marker_Unsize_T_U_where_core_marker_Sized_U_alloc_boxed_Box_U_alloc_alloc_Global_for_alloc_boxed_Box_T_alloc_alloc_Global.
  
  Module Impl_core_borrow_Borrow_where_core_marker_Sized_T_where_core_alloc_Allocator_A_T_for_alloc_boxed_Box_T_A.
    Definition Self (T A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::boxed::Box") [] [ T; A ].
    
    (*
        fn borrow(&self) -> &T {
            &**self
        }
    *)
    Definition borrow (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.borrow (|
            Pointer.Kind.Ref,
            M.deref (|
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (T A : Ty.t),
      M.IsTraitInstance
        "core::borrow::Borrow"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ T ]
        (Self T A)
        (* Instance *) [ ("borrow", InstanceField.Method (borrow T A)) ].
  End Impl_core_borrow_Borrow_where_core_marker_Sized_T_where_core_alloc_Allocator_A_T_for_alloc_boxed_Box_T_A.
  
  Module Impl_core_borrow_BorrowMut_where_core_marker_Sized_T_where_core_alloc_Allocator_A_T_for_alloc_boxed_Box_T_A.
    Definition Self (T A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::boxed::Box") [] [ T; A ].
    
    (*
        fn borrow_mut(&mut self) -> &mut T {
            &mut **self
        }
    *)
    Definition borrow_mut (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.borrow (|
            Pointer.Kind.MutRef,
            M.deref (|
              M.borrow (|
                Pointer.Kind.MutRef,
                M.deref (|
                  M.borrow (|
                    Pointer.Kind.MutRef,
                    M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
                  |)
                |)
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (T A : Ty.t),
      M.IsTraitInstance
        "core::borrow::BorrowMut"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ T ]
        (Self T A)
        (* Instance *) [ ("borrow_mut", InstanceField.Method (borrow_mut T A)) ].
  End Impl_core_borrow_BorrowMut_where_core_marker_Sized_T_where_core_alloc_Allocator_A_T_for_alloc_boxed_Box_T_A.
  
  Module Impl_core_convert_AsRef_where_core_marker_Sized_T_where_core_alloc_Allocator_A_T_for_alloc_boxed_Box_T_A.
    Definition Self (T A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::boxed::Box") [] [ T; A ].
    
    (*
        fn as_ref(&self) -> &T {
            &**self
        }
    *)
    Definition as_ref (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.borrow (|
            Pointer.Kind.Ref,
            M.deref (|
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (T A : Ty.t),
      M.IsTraitInstance
        "core::convert::AsRef"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ T ]
        (Self T A)
        (* Instance *) [ ("as_ref", InstanceField.Method (as_ref T A)) ].
  End Impl_core_convert_AsRef_where_core_marker_Sized_T_where_core_alloc_Allocator_A_T_for_alloc_boxed_Box_T_A.
  
  Module Impl_core_convert_AsMut_where_core_marker_Sized_T_where_core_alloc_Allocator_A_T_for_alloc_boxed_Box_T_A.
    Definition Self (T A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::boxed::Box") [] [ T; A ].
    
    (*
        fn as_mut(&mut self) -> &mut T {
            &mut **self
        }
    *)
    Definition as_mut (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.borrow (|
            Pointer.Kind.MutRef,
            M.deref (|
              M.borrow (|
                Pointer.Kind.MutRef,
                M.deref (|
                  M.borrow (|
                    Pointer.Kind.MutRef,
                    M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
                  |)
                |)
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (T A : Ty.t),
      M.IsTraitInstance
        "core::convert::AsMut"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ T ]
        (Self T A)
        (* Instance *) [ ("as_mut", InstanceField.Method (as_mut T A)) ].
  End Impl_core_convert_AsMut_where_core_marker_Sized_T_where_core_alloc_Allocator_A_T_for_alloc_boxed_Box_T_A.
  
  Module Impl_core_marker_Unpin_where_core_marker_Sized_T_where_core_alloc_Allocator_A_for_alloc_boxed_Box_T_A.
    Definition Self (T A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::boxed::Box") [] [ T; A ].
    
    Axiom Implements :
      forall (T A : Ty.t),
      M.IsTraitInstance
        "core::marker::Unpin"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self T A)
        (* Instance *) [].
  End Impl_core_marker_Unpin_where_core_marker_Sized_T_where_core_alloc_Allocator_A_for_alloc_boxed_Box_T_A.
  
  Module Impl_core_ops_coroutine_Coroutine_where_core_marker_Sized_G_where_core_ops_coroutine_Coroutine_G_R_where_core_marker_Unpin_G_where_core_alloc_Allocator_A_R_for_alloc_boxed_Box_G_A.
    Definition Self (G R A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::boxed::Box") [] [ G; A ].
    
    (*     type Yield = G::Yield; *)
    Definition _Yield (G R A : Ty.t) : Ty.t :=
      Ty.associated_in_trait "core::ops::coroutine::Coroutine" [] [ R ] G "Yield".
    
    (*     type Return = G::Return; *)
    Definition _Return (G R A : Ty.t) : Ty.t :=
      Ty.associated_in_trait "core::ops::coroutine::Coroutine" [] [ R ] G "Return".
    
    (*
        fn resume(mut self: Pin<&mut Self>, arg: R) -> CoroutineState<Self::Yield, Self::Return> {
            G::resume(Pin::new(&mut *self), arg)
        }
    *)
    Definition resume (G R A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self G R A in
      match ε, τ, α with
      | [], [], [ self; arg ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let arg := M.alloc (| arg |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "core::ops::coroutine::CoroutineState")
              []
              [
                Ty.associated_in_trait "core::ops::coroutine::Coroutine" [] [ R ] G "Yield";
                Ty.associated_in_trait "core::ops::coroutine::Coroutine" [] [ R ] G "Return"
              ],
            M.get_trait_method (|
              "core::ops::coroutine::Coroutine",
              G,
              [],
              [ R ],
              "resume",
              [],
              []
            |),
            [
              M.call_closure (|
                Ty.apply (Ty.path "core::pin::Pin") [] [ Ty.apply (Ty.path "&mut") [] [ G ] ],
                M.get_associated_function (|
                  Ty.apply (Ty.path "core::pin::Pin") [] [ Ty.apply (Ty.path "&mut") [] [ G ] ],
                  "new",
                  [],
                  []
                |),
                [
                  M.borrow (|
                    Pointer.Kind.MutRef,
                    M.deref (|
                      M.read (|
                        M.deref (|
                          M.borrow (|
                            Pointer.Kind.MutRef,
                            M.deref (|
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "&mut")
                                  []
                                  [ Ty.apply (Ty.path "alloc::boxed::Box") [] [ G; A ] ],
                                M.get_trait_method (|
                                  "core::ops::deref::DerefMut",
                                  Ty.apply
                                    (Ty.path "core::pin::Pin")
                                    []
                                    [
                                      Ty.apply
                                        (Ty.path "&mut")
                                        []
                                        [ Ty.apply (Ty.path "alloc::boxed::Box") [] [ G; A ] ]
                                    ],
                                  [],
                                  [],
                                  "deref_mut",
                                  [],
                                  []
                                |),
                                [ M.borrow (| Pointer.Kind.MutRef, self |) ]
                              |)
                            |)
                          |)
                        |)
                      |)
                    |)
                  |)
                ]
              |);
              M.read (| arg |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (G R A : Ty.t),
      M.IsTraitInstance
        "core::ops::coroutine::Coroutine"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ R ]
        (Self G R A)
        (* Instance *)
        [
          ("Yield", InstanceField.Ty (_Yield G R A));
          ("Return", InstanceField.Ty (_Return G R A));
          ("resume", InstanceField.Method (resume G R A))
        ].
  End Impl_core_ops_coroutine_Coroutine_where_core_marker_Sized_G_where_core_ops_coroutine_Coroutine_G_R_where_core_marker_Unpin_G_where_core_alloc_Allocator_A_R_for_alloc_boxed_Box_G_A.
  
  Module Impl_core_ops_coroutine_Coroutine_where_core_marker_Sized_G_where_core_ops_coroutine_Coroutine_G_R_where_core_alloc_Allocator_A_R_for_core_pin_Pin_alloc_boxed_Box_G_A.
    Definition Self (G R A : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "core::pin::Pin") [] [ Ty.apply (Ty.path "alloc::boxed::Box") [] [ G; A ] ].
    
    (*     type Yield = G::Yield; *)
    Definition _Yield (G R A : Ty.t) : Ty.t :=
      Ty.associated_in_trait "core::ops::coroutine::Coroutine" [] [ R ] G "Yield".
    
    (*     type Return = G::Return; *)
    Definition _Return (G R A : Ty.t) : Ty.t :=
      Ty.associated_in_trait "core::ops::coroutine::Coroutine" [] [ R ] G "Return".
    
    (*
        fn resume(mut self: Pin<&mut Self>, arg: R) -> CoroutineState<Self::Yield, Self::Return> {
            G::resume(( *self).as_mut(), arg)
        }
    *)
    Definition resume (G R A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self G R A in
      match ε, τ, α with
      | [], [], [ self; arg ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let arg := M.alloc (| arg |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "core::ops::coroutine::CoroutineState")
              []
              [
                Ty.associated_in_trait "core::ops::coroutine::Coroutine" [] [ R ] G "Yield";
                Ty.associated_in_trait "core::ops::coroutine::Coroutine" [] [ R ] G "Return"
              ],
            M.get_trait_method (|
              "core::ops::coroutine::Coroutine",
              G,
              [],
              [ R ],
              "resume",
              [],
              []
            |),
            [
              M.call_closure (|
                Ty.apply (Ty.path "core::pin::Pin") [] [ Ty.apply (Ty.path "&mut") [] [ G ] ],
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "core::pin::Pin")
                    []
                    [ Ty.apply (Ty.path "alloc::boxed::Box") [] [ G; A ] ],
                  "as_mut",
                  [],
                  []
                |),
                [
                  M.borrow (|
                    Pointer.Kind.MutRef,
                    M.deref (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "&mut")
                          []
                          [
                            Ty.apply
                              (Ty.path "core::pin::Pin")
                              []
                              [ Ty.apply (Ty.path "alloc::boxed::Box") [] [ G; A ] ]
                          ],
                        M.get_trait_method (|
                          "core::ops::deref::DerefMut",
                          Ty.apply
                            (Ty.path "core::pin::Pin")
                            []
                            [
                              Ty.apply
                                (Ty.path "&mut")
                                []
                                [
                                  Ty.apply
                                    (Ty.path "core::pin::Pin")
                                    []
                                    [ Ty.apply (Ty.path "alloc::boxed::Box") [] [ G; A ] ]
                                ]
                            ],
                          [],
                          [],
                          "deref_mut",
                          [],
                          []
                        |),
                        [ M.borrow (| Pointer.Kind.MutRef, self |) ]
                      |)
                    |)
                  |)
                ]
              |);
              M.read (| arg |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (G R A : Ty.t),
      M.IsTraitInstance
        "core::ops::coroutine::Coroutine"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ R ]
        (Self G R A)
        (* Instance *)
        [
          ("Yield", InstanceField.Ty (_Yield G R A));
          ("Return", InstanceField.Ty (_Return G R A));
          ("resume", InstanceField.Method (resume G R A))
        ].
  End Impl_core_ops_coroutine_Coroutine_where_core_marker_Sized_G_where_core_ops_coroutine_Coroutine_G_R_where_core_alloc_Allocator_A_R_for_core_pin_Pin_alloc_boxed_Box_G_A.
  
  Module Impl_core_future_future_Future_where_core_marker_Sized_F_where_core_future_future_Future_F_where_core_marker_Unpin_F_where_core_alloc_Allocator_A_for_alloc_boxed_Box_F_A.
    Definition Self (F A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::boxed::Box") [] [ F; A ].
    
    (*     type Output = F::Output; *)
    Definition _Output (F A : Ty.t) : Ty.t :=
      Ty.associated_in_trait "core::future::future::Future" [] [] F "Output".
    
    (*
        fn poll(mut self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output> {
            F::poll(Pin::new(&mut *self), cx)
        }
    *)
    Definition poll (F A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self F A in
      match ε, τ, α with
      | [], [], [ self; cx ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let cx := M.alloc (| cx |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "core::task::poll::Poll")
              []
              [ Ty.associated_in_trait "core::future::future::Future" [] [] F "Output" ],
            M.get_trait_method (| "core::future::future::Future", F, [], [], "poll", [], [] |),
            [
              M.call_closure (|
                Ty.apply (Ty.path "core::pin::Pin") [] [ Ty.apply (Ty.path "&mut") [] [ F ] ],
                M.get_associated_function (|
                  Ty.apply (Ty.path "core::pin::Pin") [] [ Ty.apply (Ty.path "&mut") [] [ F ] ],
                  "new",
                  [],
                  []
                |),
                [
                  M.borrow (|
                    Pointer.Kind.MutRef,
                    M.deref (|
                      M.read (|
                        M.deref (|
                          M.borrow (|
                            Pointer.Kind.MutRef,
                            M.deref (|
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "&mut")
                                  []
                                  [ Ty.apply (Ty.path "alloc::boxed::Box") [] [ F; A ] ],
                                M.get_trait_method (|
                                  "core::ops::deref::DerefMut",
                                  Ty.apply
                                    (Ty.path "core::pin::Pin")
                                    []
                                    [
                                      Ty.apply
                                        (Ty.path "&mut")
                                        []
                                        [ Ty.apply (Ty.path "alloc::boxed::Box") [] [ F; A ] ]
                                    ],
                                  [],
                                  [],
                                  "deref_mut",
                                  [],
                                  []
                                |),
                                [ M.borrow (| Pointer.Kind.MutRef, self |) ]
                              |)
                            |)
                          |)
                        |)
                      |)
                    |)
                  |)
                ]
              |);
              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| cx |) |) |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (F A : Ty.t),
      M.IsTraitInstance
        "core::future::future::Future"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self F A)
        (* Instance *)
        [ ("Output", InstanceField.Ty (_Output F A)); ("poll", InstanceField.Method (poll F A)) ].
  End Impl_core_future_future_Future_where_core_marker_Sized_F_where_core_future_future_Future_F_where_core_marker_Unpin_F_where_core_alloc_Allocator_A_for_alloc_boxed_Box_F_A.
  
  Module Impl_core_error_Error_where_core_error_Error_E_for_alloc_boxed_Box_E_alloc_alloc_Global.
    Definition Self (E : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "alloc::boxed::Box") [] [ E; Ty.path "alloc::alloc::Global" ].
    
    (*
        fn description(&self) -> &str {
            Error::description(&**self)
        }
    *)
    Definition description (E : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self E in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.borrow (|
            Pointer.Kind.Ref,
            M.deref (|
              M.call_closure (|
                Ty.apply (Ty.path "&") [] [ Ty.path "str" ],
                M.get_trait_method (| "core::error::Error", E, [], [], "description", [], [] |),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
                      |)
                    |)
                  |)
                ]
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    (*
        fn cause(&self) -> Option<&dyn Error> {
            Error::cause(&**self)
        }
    *)
    Definition cause (E : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self E in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "core::option::Option")
              []
              [ Ty.apply (Ty.path "&") [] [ Ty.dyn [ ("core::error::Error::Trait", []) ] ] ],
            M.get_trait_method (| "core::error::Error", E, [], [], "cause", [], [] |),
            [
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
                  |)
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    (*
        fn source(&self) -> Option<&(dyn Error + 'static)> {
            Error::source(&**self)
        }
    *)
    Definition source (E : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self E in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "core::option::Option")
              []
              [ Ty.apply (Ty.path "&") [] [ Ty.dyn [ ("core::error::Error::Trait", []) ] ] ],
            M.get_trait_method (| "core::error::Error", E, [], [], "source", [], [] |),
            [
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
                  |)
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    (*
        fn provide<'b>(&'b self, request: &mut error::Request<'b>) {
            Error::provide(&**self, request);
        }
    *)
    Definition provide (E : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self E in
      match ε, τ, α with
      | [], [], [ self; request ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let request := M.alloc (| request |) in
          M.read (|
            let~ _ : Ty.tuple [] :=
              M.alloc (|
                M.call_closure (|
                  Ty.tuple [],
                  M.get_trait_method (| "core::error::Error", E, [], [], "provide", [], [] |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
                        |)
                      |)
                    |);
                    M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| request |) |) |)
                  ]
                |)
              |) in
            M.alloc (| Value.Tuple [] |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (E : Ty.t),
      M.IsTraitInstance
        "core::error::Error"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self E)
        (* Instance *)
        [
          ("description", InstanceField.Method (description E));
          ("cause", InstanceField.Method (cause E));
          ("source", InstanceField.Method (source E));
          ("provide", InstanceField.Method (provide E))
        ].
  End Impl_core_error_Error_where_core_error_Error_E_for_alloc_boxed_Box_E_alloc_alloc_Global.
  
  Module Impl_core_marker_PointerLike_for_alloc_boxed_Box_T_alloc_alloc_Global.
    Definition Self (T : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "alloc::boxed::Box") [] [ T; Ty.path "alloc::alloc::Global" ].
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "core::marker::PointerLike"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self T)
        (* Instance *) [].
  End Impl_core_marker_PointerLike_for_alloc_boxed_Box_T_alloc_alloc_Global.
End boxed.
