(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module boxed.
  Module convert.
    Module Impl_core_convert_From_T_for_alloc_boxed_Box_T_alloc_alloc_Global.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "alloc::boxed::Box") [] [ T; Ty.path "alloc::alloc::Global" ].
      
      (*
          fn from(t: T) -> Self {
              Box::new(t)
          }
      *)
      Definition from (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ t ] =>
          ltac:(M.monadic
            (let t := M.alloc (| t |) in
            M.call_closure (|
              Ty.apply (Ty.path "alloc::boxed::Box") [] [ T; Ty.path "alloc::alloc::Global" ],
              M.get_associated_function (|
                Ty.apply (Ty.path "alloc::boxed::Box") [] [ T; Ty.path "alloc::alloc::Global" ],
                "new",
                [],
                []
              |),
              [ M.read (| t |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ T ]
          (Self T)
          (* Instance *) [ ("from", InstanceField.Method (from T)) ].
    End Impl_core_convert_From_T_for_alloc_boxed_Box_T_alloc_alloc_Global.
    
    Module Impl_core_convert_From_where_core_marker_Sized_T_where_core_alloc_Allocator_A_alloc_boxed_Box_T_A_for_core_pin_Pin_alloc_boxed_Box_T_A.
      Definition Self (T A : Ty.t) : Ty.t :=
        Ty.apply
          (Ty.path "core::pin::Pin")
          []
          [ Ty.apply (Ty.path "alloc::boxed::Box") [] [ T; A ] ].
      
      (*
          fn from(boxed: Box<T, A>) -> Self {
              Box::into_pin(boxed)
          }
      *)
      Definition from (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match ε, τ, α with
        | [], [], [ boxed ] =>
          ltac:(M.monadic
            (let boxed := M.alloc (| boxed |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "core::pin::Pin")
                []
                [ Ty.apply (Ty.path "alloc::boxed::Box") [] [ T; A ] ],
              M.get_associated_function (|
                Ty.apply (Ty.path "alloc::boxed::Box") [] [ T; A ],
                "into_pin",
                [],
                []
              |),
              [ M.read (| boxed |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T A : Ty.t),
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.apply (Ty.path "alloc::boxed::Box") [] [ T; A ] ]
          (Self T A)
          (* Instance *) [ ("from", InstanceField.Method (from T A)) ].
    End Impl_core_convert_From_where_core_marker_Sized_T_where_core_alloc_Allocator_A_alloc_boxed_Box_T_A_for_core_pin_Pin_alloc_boxed_Box_T_A.
    
    (* Trait *)
    (* Empty module 'BoxFromSlice' *)
    
    Module Impl_alloc_boxed_convert_BoxFromSlice_where_core_clone_Clone_T_T_for_alloc_boxed_Box_slice_T_alloc_alloc_Global.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply
          (Ty.path "alloc::boxed::Box")
          []
          [ Ty.apply (Ty.path "slice") [] [ T ]; Ty.path "alloc::alloc::Global" ].
      
      (*
          default fn from_slice(slice: &[T]) -> Self {
              slice.to_vec().into_boxed_slice()
          }
      *)
      Definition from_slice (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ slice ] =>
          ltac:(M.monadic
            (let slice := M.alloc (| slice |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "alloc::boxed::Box")
                []
                [ Ty.apply (Ty.path "slice") [] [ T ]; Ty.path "alloc::alloc::Global" ],
              M.get_associated_function (|
                Ty.apply (Ty.path "alloc::vec::Vec") [] [ T; Ty.path "alloc::alloc::Global" ],
                "into_boxed_slice",
                [],
                []
              |),
              [
                M.call_closure (|
                  Ty.apply (Ty.path "alloc::vec::Vec") [] [ T; Ty.path "alloc::alloc::Global" ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "slice") [] [ T ],
                    "to_vec",
                    [],
                    []
                  |),
                  [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| slice |) |) |) ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "alloc::boxed::convert::BoxFromSlice"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ T ]
          (Self T)
          (* Instance *) [ ("from_slice", InstanceField.Method (from_slice T)) ].
    End Impl_alloc_boxed_convert_BoxFromSlice_where_core_clone_Clone_T_T_for_alloc_boxed_Box_slice_T_alloc_alloc_Global.
    
    Module Impl_alloc_boxed_convert_BoxFromSlice_where_core_marker_Copy_T_T_for_alloc_boxed_Box_slice_T_alloc_alloc_Global.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply
          (Ty.path "alloc::boxed::Box")
          []
          [ Ty.apply (Ty.path "slice") [] [ T ]; Ty.path "alloc::alloc::Global" ].
      
      (*
          fn from_slice(slice: &[T]) -> Self {
              let len = slice.len();
              let buf = RawVec::with_capacity(len);
              unsafe {
                  ptr::copy_nonoverlapping(slice.as_ptr(), buf.ptr(), len);
                  buf.into_box(slice.len()).assume_init()
              }
          }
      *)
      Definition from_slice (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ slice ] =>
          ltac:(M.monadic
            (let slice := M.alloc (| slice |) in
            M.read (|
              let~ len : Ty.apply (Ty.path "*") [] [ Ty.path "usize" ] :=
                M.alloc (|
                  M.call_closure (|
                    Ty.path "usize",
                    M.get_associated_function (|
                      Ty.apply (Ty.path "slice") [] [ T ],
                      "len",
                      [],
                      []
                    |),
                    [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| slice |) |) |) ]
                  |)
                |) in
              let~ buf :
                  Ty.apply
                    (Ty.path "*")
                    []
                    [
                      Ty.apply
                        (Ty.path "alloc::raw_vec::RawVec")
                        []
                        [ T; Ty.path "alloc::alloc::Global" ]
                    ] :=
                M.alloc (|
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "alloc::raw_vec::RawVec")
                      []
                      [ T; Ty.path "alloc::alloc::Global" ],
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "alloc::raw_vec::RawVec")
                        []
                        [ T; Ty.path "alloc::alloc::Global" ],
                      "with_capacity",
                      [],
                      []
                    |),
                    [ M.read (| len |) ]
                  |)
                |) in
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.call_closure (|
                    Ty.tuple [],
                    M.get_function (| "core::intrinsics::copy_nonoverlapping", [], [ T ] |),
                    [
                      M.call_closure (|
                        Ty.apply (Ty.path "*const") [] [ T ],
                        M.get_associated_function (|
                          Ty.apply (Ty.path "slice") [] [ T ],
                          "as_ptr",
                          [],
                          []
                        |),
                        [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| slice |) |) |) ]
                      |);
                      M.call_closure (|
                        Ty.apply (Ty.path "*mut") [] [ T ],
                        M.get_associated_function (|
                          Ty.apply
                            (Ty.path "alloc::raw_vec::RawVec")
                            []
                            [ T; Ty.path "alloc::alloc::Global" ],
                          "ptr",
                          [],
                          []
                        |),
                        [ M.borrow (| Pointer.Kind.Ref, buf |) ]
                      |);
                      M.read (| len |)
                    ]
                  |)
                |) in
              M.alloc (|
                M.call_closure (|
                  Ty.apply
                    (Ty.path "alloc::boxed::Box")
                    []
                    [ Ty.apply (Ty.path "slice") [] [ T ]; Ty.path "alloc::alloc::Global" ],
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "alloc::boxed::Box")
                      []
                      [
                        Ty.apply
                          (Ty.path "slice")
                          []
                          [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ] ];
                        Ty.path "alloc::alloc::Global"
                      ],
                    "assume_init",
                    [],
                    []
                  |),
                  [
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "alloc::boxed::Box")
                        []
                        [
                          Ty.apply
                            (Ty.path "slice")
                            []
                            [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ] ];
                          Ty.path "alloc::alloc::Global"
                        ],
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "alloc::raw_vec::RawVec")
                          []
                          [ T; Ty.path "alloc::alloc::Global" ],
                        "into_box",
                        [],
                        []
                      |),
                      [
                        M.read (| buf |);
                        M.call_closure (|
                          Ty.path "usize",
                          M.get_associated_function (|
                            Ty.apply (Ty.path "slice") [] [ T ],
                            "len",
                            [],
                            []
                          |),
                          [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| slice |) |) |) ]
                        |)
                      ]
                    |)
                  ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "alloc::boxed::convert::BoxFromSlice"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ T ]
          (Self T)
          (* Instance *) [ ("from_slice", InstanceField.Method (from_slice T)) ].
    End Impl_alloc_boxed_convert_BoxFromSlice_where_core_marker_Copy_T_T_for_alloc_boxed_Box_slice_T_alloc_alloc_Global.
    
    Module Impl_core_convert_From_where_core_clone_Clone_T_ref__slice_T_for_alloc_boxed_Box_slice_T_alloc_alloc_Global.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply
          (Ty.path "alloc::boxed::Box")
          []
          [ Ty.apply (Ty.path "slice") [] [ T ]; Ty.path "alloc::alloc::Global" ].
      
      (*
          fn from(slice: &[T]) -> Box<[T]> {
              <Self as BoxFromSlice<T>>::from_slice(slice)
          }
      *)
      Definition from (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ slice ] =>
          ltac:(M.monadic
            (let slice := M.alloc (| slice |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "alloc::boxed::Box")
                []
                [ Ty.apply (Ty.path "slice") [] [ T ]; Ty.path "alloc::alloc::Global" ],
              M.get_trait_method (|
                "alloc::boxed::convert::BoxFromSlice",
                Ty.apply
                  (Ty.path "alloc::boxed::Box")
                  []
                  [ Ty.apply (Ty.path "slice") [] [ T ]; Ty.path "alloc::alloc::Global" ],
                [],
                [ T ],
                "from_slice",
                [],
                []
              |),
              [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| slice |) |) |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ T ] ] ]
          (Self T)
          (* Instance *) [ ("from", InstanceField.Method (from T)) ].
    End Impl_core_convert_From_where_core_clone_Clone_T_ref__slice_T_for_alloc_boxed_Box_slice_T_alloc_alloc_Global.
    
    Module Impl_core_convert_From_where_core_clone_Clone_T_ref_mut_slice_T_for_alloc_boxed_Box_slice_T_alloc_alloc_Global.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply
          (Ty.path "alloc::boxed::Box")
          []
          [ Ty.apply (Ty.path "slice") [] [ T ]; Ty.path "alloc::alloc::Global" ].
      
      (*
          fn from(slice: &mut [T]) -> Box<[T]> {
              Self::from(&*slice)
          }
      *)
      Definition from (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ slice ] =>
          ltac:(M.monadic
            (let slice := M.alloc (| slice |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "alloc::boxed::Box")
                []
                [ Ty.apply (Ty.path "slice") [] [ T ]; Ty.path "alloc::alloc::Global" ],
              M.get_trait_method (|
                "core::convert::From",
                Ty.apply
                  (Ty.path "alloc::boxed::Box")
                  []
                  [ Ty.apply (Ty.path "slice") [] [ T ]; Ty.path "alloc::alloc::Global" ],
                [],
                [ Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ T ] ] ],
                "from",
                [],
                []
              |),
              [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| slice |) |) |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "slice") [] [ T ] ] ]
          (Self T)
          (* Instance *) [ ("from", InstanceField.Method (from T)) ].
    End Impl_core_convert_From_where_core_clone_Clone_T_ref_mut_slice_T_for_alloc_boxed_Box_slice_T_alloc_alloc_Global.
    
    Module Impl_core_convert_From_where_core_clone_Clone_T_alloc_borrow_Cow_slice_T_for_alloc_boxed_Box_slice_T_alloc_alloc_Global.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply
          (Ty.path "alloc::boxed::Box")
          []
          [ Ty.apply (Ty.path "slice") [] [ T ]; Ty.path "alloc::alloc::Global" ].
      
      (*
          fn from(cow: Cow<'_, [T]>) -> Box<[T]> {
              match cow {
                  Cow::Borrowed(slice) => Box::from(slice),
                  Cow::Owned(slice) => Box::from(slice),
              }
          }
      *)
      Definition from (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ cow ] =>
          ltac:(M.monadic
            (let cow := M.alloc (| cow |) in
            M.read (|
              M.match_operator (|
                Ty.apply
                  (Ty.path "*")
                  []
                  [
                    Ty.apply
                      (Ty.path "alloc::boxed::Box")
                      []
                      [ Ty.apply (Ty.path "slice") [] [ T ]; Ty.path "alloc::alloc::Global" ]
                  ],
                cow,
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "alloc::borrow::Cow::Borrowed",
                          0
                        |) in
                      let slice := M.copy (| γ0_0 |) in
                      M.alloc (|
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "alloc::boxed::Box")
                            []
                            [ Ty.apply (Ty.path "slice") [] [ T ]; Ty.path "alloc::alloc::Global" ],
                          M.get_trait_method (|
                            "core::convert::From",
                            Ty.apply
                              (Ty.path "alloc::boxed::Box")
                              []
                              [ Ty.apply (Ty.path "slice") [] [ T ]; Ty.path "alloc::alloc::Global"
                              ],
                            [],
                            [ Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ T ] ] ],
                            "from",
                            [],
                            []
                          |),
                          [ M.read (| slice |) ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "alloc::borrow::Cow::Owned",
                          0
                        |) in
                      let slice := M.copy (| γ0_0 |) in
                      M.alloc (|
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "alloc::boxed::Box")
                            []
                            [ Ty.apply (Ty.path "slice") [] [ T ]; Ty.path "alloc::alloc::Global" ],
                          M.get_trait_method (|
                            "core::convert::From",
                            Ty.apply
                              (Ty.path "alloc::boxed::Box")
                              []
                              [ Ty.apply (Ty.path "slice") [] [ T ]; Ty.path "alloc::alloc::Global"
                              ],
                            [],
                            [
                              Ty.apply
                                (Ty.path "alloc::vec::Vec")
                                []
                                [ T; Ty.path "alloc::alloc::Global" ]
                            ],
                            "from",
                            [],
                            []
                          |),
                          [ M.read (| slice |) ]
                        |)
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "alloc::borrow::Cow") [] [ Ty.apply (Ty.path "slice") [] [ T ] ] ]
          (Self T)
          (* Instance *) [ ("from", InstanceField.Method (from T)) ].
    End Impl_core_convert_From_where_core_clone_Clone_T_alloc_borrow_Cow_slice_T_for_alloc_boxed_Box_slice_T_alloc_alloc_Global.
    
    Module Impl_core_convert_From_ref__str_for_alloc_boxed_Box_str_alloc_alloc_Global.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "alloc::boxed::Box") [] [ Ty.path "str"; Ty.path "alloc::alloc::Global" ].
      
      (*
          fn from(s: &str) -> Box<str> {
              unsafe { from_boxed_utf8_unchecked(Box::from(s.as_bytes())) }
          }
      *)
      Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ s ] =>
          ltac:(M.monadic
            (let s := M.alloc (| s |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "alloc::boxed::Box")
                []
                [ Ty.path "str"; Ty.path "alloc::alloc::Global" ],
              M.get_function (| "alloc::str::from_boxed_utf8_unchecked", [], [] |),
              [
                M.call_closure (|
                  Ty.apply
                    (Ty.path "alloc::boxed::Box")
                    []
                    [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ]; Ty.path "alloc::alloc::Global"
                    ],
                  M.get_trait_method (|
                    "core::convert::From",
                    Ty.apply
                      (Ty.path "alloc::boxed::Box")
                      []
                      [
                        Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ];
                        Ty.path "alloc::alloc::Global"
                      ],
                    [],
                    [ Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
                    ],
                    "from",
                    [],
                    []
                  |),
                  [
                    M.call_closure (|
                      Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                      M.get_associated_function (| Ty.path "str", "as_bytes", [], [] |),
                      [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| s |) |) |) ]
                    |)
                  ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.apply (Ty.path "&") [] [ Ty.path "str" ] ]
          Self
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_ref__str_for_alloc_boxed_Box_str_alloc_alloc_Global.
    
    Module Impl_core_convert_From_ref_mut_str_for_alloc_boxed_Box_str_alloc_alloc_Global.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "alloc::boxed::Box") [] [ Ty.path "str"; Ty.path "alloc::alloc::Global" ].
      
      (*
          fn from(s: &mut str) -> Box<str> {
              Self::from(&*s)
          }
      *)
      Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ s ] =>
          ltac:(M.monadic
            (let s := M.alloc (| s |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "alloc::boxed::Box")
                []
                [ Ty.path "str"; Ty.path "alloc::alloc::Global" ],
              M.get_trait_method (|
                "core::convert::From",
                Ty.apply
                  (Ty.path "alloc::boxed::Box")
                  []
                  [ Ty.path "str"; Ty.path "alloc::alloc::Global" ],
                [],
                [ Ty.apply (Ty.path "&") [] [ Ty.path "str" ] ],
                "from",
                [],
                []
              |),
              [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| s |) |) |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.apply (Ty.path "&mut") [] [ Ty.path "str" ] ]
          Self
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_ref_mut_str_for_alloc_boxed_Box_str_alloc_alloc_Global.
    
    Module Impl_core_convert_From_alloc_borrow_Cow_str_for_alloc_boxed_Box_str_alloc_alloc_Global.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "alloc::boxed::Box") [] [ Ty.path "str"; Ty.path "alloc::alloc::Global" ].
      
      (*
          fn from(cow: Cow<'_, str>) -> Box<str> {
              match cow {
                  Cow::Borrowed(s) => Box::from(s),
                  Cow::Owned(s) => Box::from(s),
              }
          }
      *)
      Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ cow ] =>
          ltac:(M.monadic
            (let cow := M.alloc (| cow |) in
            M.read (|
              M.match_operator (|
                Ty.apply
                  (Ty.path "*")
                  []
                  [
                    Ty.apply
                      (Ty.path "alloc::boxed::Box")
                      []
                      [ Ty.path "str"; Ty.path "alloc::alloc::Global" ]
                  ],
                cow,
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "alloc::borrow::Cow::Borrowed",
                          0
                        |) in
                      let s := M.copy (| γ0_0 |) in
                      M.alloc (|
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "alloc::boxed::Box")
                            []
                            [ Ty.path "str"; Ty.path "alloc::alloc::Global" ],
                          M.get_trait_method (|
                            "core::convert::From",
                            Ty.apply
                              (Ty.path "alloc::boxed::Box")
                              []
                              [ Ty.path "str"; Ty.path "alloc::alloc::Global" ],
                            [],
                            [ Ty.apply (Ty.path "&") [] [ Ty.path "str" ] ],
                            "from",
                            [],
                            []
                          |),
                          [ M.read (| s |) ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "alloc::borrow::Cow::Owned",
                          0
                        |) in
                      let s := M.copy (| γ0_0 |) in
                      M.alloc (|
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "alloc::boxed::Box")
                            []
                            [ Ty.path "str"; Ty.path "alloc::alloc::Global" ],
                          M.get_trait_method (|
                            "core::convert::From",
                            Ty.apply
                              (Ty.path "alloc::boxed::Box")
                              []
                              [ Ty.path "str"; Ty.path "alloc::alloc::Global" ],
                            [],
                            [ Ty.path "alloc::string::String" ],
                            "from",
                            [],
                            []
                          |),
                          [ M.read (| s |) ]
                        |)
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "alloc::borrow::Cow") [] [ Ty.path "str" ] ]
          Self
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_alloc_borrow_Cow_str_for_alloc_boxed_Box_str_alloc_alloc_Global.
    
    Module Impl_core_convert_From_where_core_alloc_Allocator_A_alloc_boxed_Box_str_A_for_alloc_boxed_Box_slice_u8_A.
      Definition Self (A : Ty.t) : Ty.t :=
        Ty.apply
          (Ty.path "alloc::boxed::Box")
          []
          [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ]; A ].
      
      (*
          fn from(s: Box<str, A>) -> Self {
              let (raw, alloc) = Box::into_raw_with_allocator(s);
              unsafe { Box::from_raw_in(raw as *mut [u8], alloc) }
          }
      *)
      Definition from (A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self A in
        match ε, τ, α with
        | [], [], [ s ] =>
          ltac:(M.monadic
            (let s := M.alloc (| s |) in
            M.read (|
              M.match_operator (|
                Ty.apply
                  (Ty.path "*")
                  []
                  [
                    Ty.apply
                      (Ty.path "alloc::boxed::Box")
                      []
                      [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ]; A ]
                  ],
                M.alloc (|
                  M.call_closure (|
                    Ty.tuple [ Ty.apply (Ty.path "*mut") [] [ Ty.path "str" ]; A ],
                    M.get_associated_function (|
                      Ty.apply (Ty.path "alloc::boxed::Box") [] [ Ty.path "str"; A ],
                      "into_raw_with_allocator",
                      [],
                      []
                    |),
                    [ M.read (| s |) ]
                  |)
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      let raw := M.copy (| γ0_0 |) in
                      let alloc := M.copy (| γ0_1 |) in
                      M.alloc (|
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "alloc::boxed::Box")
                            []
                            [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ]; A ],
                          M.get_associated_function (|
                            Ty.apply
                              (Ty.path "alloc::boxed::Box")
                              []
                              [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ]; A ],
                            "from_raw_in",
                            [],
                            []
                          |),
                          [
                            M.cast
                              (Ty.apply
                                (Ty.path "*mut")
                                []
                                [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ])
                              (M.read (| raw |));
                            M.read (| alloc |)
                          ]
                        |)
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (A : Ty.t),
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "alloc::boxed::Box") [] [ Ty.path "str"; A ] ]
          (Self A)
          (* Instance *) [ ("from", InstanceField.Method (from A)) ].
    End Impl_core_convert_From_where_core_alloc_Allocator_A_alloc_boxed_Box_str_A_for_alloc_boxed_Box_slice_u8_A.
    
    Module Impl_core_convert_From_array_N_T_for_alloc_boxed_Box_slice_T_alloc_alloc_Global.
      Definition Self (N : Value.t) (T : Ty.t) : Ty.t :=
        Ty.apply
          (Ty.path "alloc::boxed::Box")
          []
          [ Ty.apply (Ty.path "slice") [] [ T ]; Ty.path "alloc::alloc::Global" ].
      
      (*
          fn from(array: [T; N]) -> Box<[T]> {
              Box::new(array)
          }
      *)
      Definition from
          (N : Value.t)
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self N T in
        match ε, τ, α with
        | [], [], [ array ] =>
          ltac:(M.monadic
            (let array := M.alloc (| array |) in
            (* Unsize *)
            M.pointer_coercion
              (M.call_closure (|
                Ty.apply
                  (Ty.path "alloc::boxed::Box")
                  []
                  [ Ty.apply (Ty.path "array") [ N ] [ T ]; Ty.path "alloc::alloc::Global" ],
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "alloc::boxed::Box")
                    []
                    [ Ty.apply (Ty.path "array") [ N ] [ T ]; Ty.path "alloc::alloc::Global" ],
                  "new",
                  [],
                  []
                |),
                [ M.read (| array |) ]
              |))))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (N : Value.t) (T : Ty.t),
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.apply (Ty.path "array") [ N ] [ T ] ]
          (Self N T)
          (* Instance *) [ ("from", InstanceField.Method (from N T)) ].
    End Impl_core_convert_From_array_N_T_for_alloc_boxed_Box_slice_T_alloc_alloc_Global.
    
    (*
    unsafe fn boxed_slice_as_array_unchecked<T, A: Allocator, const N: usize>(
        boxed_slice: Box<[T], A>,
    ) -> Box<[T; N], A> {
        debug_assert_eq!(boxed_slice.len(), N);
    
        let (ptr, alloc) = Box::into_raw_with_allocator(boxed_slice);
        // SAFETY: Pointer and allocator came from an existing box,
        // and our safety condition requires that the length is exactly `N`
        unsafe { Box::from_raw_in(ptr as *mut [T; N], alloc) }
    }
    *)
    Definition boxed_slice_as_array_unchecked
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      match ε, τ, α with
      | [ N ], [ T; A ], [ boxed_slice ] =>
        ltac:(M.monadic
          (let boxed_slice := M.alloc (| boxed_slice |) in
          M.read (|
            let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
              M.match_operator (|
                Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.use (M.alloc (| Value.Bool true |)) in
                      let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                        M.match_operator (|
                          Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                          M.alloc (|
                            Value.Tuple
                              [
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.alloc (|
                                    M.call_closure (|
                                      Ty.path "usize",
                                      M.get_associated_function (|
                                        Ty.apply (Ty.path "slice") [] [ T ],
                                        "len",
                                        [],
                                        []
                                      |),
                                      [
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.deref (| M.read (| boxed_slice |) |)
                                        |)
                                      ]
                                    |)
                                  |)
                                |);
                                M.borrow (| Pointer.Kind.Ref, M.alloc (| N |) |)
                              ]
                          |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                                let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                let left_val := M.copy (| γ0_0 |) in
                                let right_val := M.copy (| γ0_1 |) in
                                M.match_operator (|
                                  Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                                  M.alloc (| Value.Tuple [] |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ :=
                                          M.use
                                            (M.alloc (|
                                              UnOp.not (|
                                                M.call_closure (|
                                                  Ty.path "bool",
                                                  BinOp.eq,
                                                  [
                                                    M.read (|
                                                      M.deref (| M.read (| left_val |) |)
                                                    |);
                                                    M.read (|
                                                      M.deref (| M.read (| right_val |) |)
                                                    |)
                                                  ]
                                                |)
                                              |)
                                            |)) in
                                        let _ :=
                                          is_constant_or_break_match (|
                                            M.read (| γ |),
                                            Value.Bool true
                                          |) in
                                        M.alloc (|
                                          M.never_to_any (|
                                            M.read (|
                                              let~ kind :
                                                  Ty.apply
                                                    (Ty.path "*")
                                                    []
                                                    [ Ty.path "core::panicking::AssertKind" ] :=
                                                M.alloc (|
                                                  Value.StructTuple
                                                    "core::panicking::AssertKind::Eq"
                                                    []
                                                    []
                                                    []
                                                |) in
                                              M.alloc (|
                                                M.call_closure (|
                                                  Ty.path "never",
                                                  M.get_function (|
                                                    "core::panicking::assert_failed",
                                                    [],
                                                    [ Ty.path "usize"; Ty.path "usize" ]
                                                  |),
                                                  [
                                                    M.read (| kind |);
                                                    M.borrow (|
                                                      Pointer.Kind.Ref,
                                                      M.deref (|
                                                        M.borrow (|
                                                          Pointer.Kind.Ref,
                                                          M.deref (| M.read (| left_val |) |)
                                                        |)
                                                      |)
                                                    |);
                                                    M.borrow (|
                                                      Pointer.Kind.Ref,
                                                      M.deref (|
                                                        M.borrow (|
                                                          Pointer.Kind.Ref,
                                                          M.deref (| M.read (| right_val |) |)
                                                        |)
                                                      |)
                                                    |);
                                                    Value.StructTuple
                                                      "core::option::Option::None"
                                                      []
                                                      [ Ty.path "core::fmt::Arguments" ]
                                                      []
                                                  ]
                                                |)
                                              |)
                                            |)
                                          |)
                                        |)));
                                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                                  ]
                                |)))
                          ]
                        |) in
                      M.alloc (| Value.Tuple [] |)));
                  fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                ]
              |) in
            M.match_operator (|
              Ty.apply
                (Ty.path "*")
                []
                [
                  Ty.apply
                    (Ty.path "alloc::boxed::Box")
                    []
                    [ Ty.apply (Ty.path "array") [ N ] [ T ]; A ]
                ],
              M.alloc (|
                M.call_closure (|
                  Ty.tuple
                    [ Ty.apply (Ty.path "*mut") [] [ Ty.apply (Ty.path "slice") [] [ T ] ]; A ],
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "alloc::boxed::Box")
                      []
                      [ Ty.apply (Ty.path "slice") [] [ T ]; A ],
                    "into_raw_with_allocator",
                    [],
                    []
                  |),
                  [ M.read (| boxed_slice |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let ptr := M.copy (| γ0_0 |) in
                    let alloc := M.copy (| γ0_1 |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "alloc::boxed::Box")
                          []
                          [ Ty.apply (Ty.path "array") [ N ] [ T ]; A ],
                        M.get_associated_function (|
                          Ty.apply
                            (Ty.path "alloc::boxed::Box")
                            []
                            [ Ty.apply (Ty.path "array") [ N ] [ T ]; A ],
                          "from_raw_in",
                          [],
                          []
                        |),
                        [
                          M.cast
                            (Ty.apply
                              (Ty.path "*mut")
                              []
                              [ Ty.apply (Ty.path "array") [ N ] [ T ] ])
                            (M.read (| ptr |));
                          M.read (| alloc |)
                        ]
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance Instance_IsFunction_boxed_slice_as_array_unchecked :
      M.IsFunction.C
        "alloc::boxed::convert::boxed_slice_as_array_unchecked"
        boxed_slice_as_array_unchecked.
    Admitted.
    Global Typeclasses Opaque boxed_slice_as_array_unchecked.
    
    Module Impl_core_convert_TryFrom_alloc_boxed_Box_slice_T_alloc_alloc_Global_for_alloc_boxed_Box_array_N_T_alloc_alloc_Global.
      Definition Self (N : Value.t) (T : Ty.t) : Ty.t :=
        Ty.apply
          (Ty.path "alloc::boxed::Box")
          []
          [ Ty.apply (Ty.path "array") [ N ] [ T ]; Ty.path "alloc::alloc::Global" ].
      
      (*     type Error = Box<[T]>; *)
      Definition _Error (N : Value.t) (T : Ty.t) : Ty.t :=
        Ty.apply
          (Ty.path "alloc::boxed::Box")
          []
          [ Ty.apply (Ty.path "slice") [] [ T ]; Ty.path "alloc::alloc::Global" ].
      
      (*
          fn try_from(boxed_slice: Box<[T]>) -> Result<Self, Self::Error> {
              if boxed_slice.len() == N {
                  Ok(unsafe { boxed_slice_as_array_unchecked(boxed_slice) })
              } else {
                  Err(boxed_slice)
              }
          }
      *)
      Definition try_from
          (N : Value.t)
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self N T in
        match ε, τ, α with
        | [], [], [ boxed_slice ] =>
          ltac:(M.monadic
            (let boxed_slice := M.alloc (| boxed_slice |) in
            M.read (|
              M.match_operator (|
                Ty.apply
                  (Ty.path "*")
                  []
                  [
                    Ty.apply
                      (Ty.path "core::result::Result")
                      []
                      [
                        Ty.apply
                          (Ty.path "alloc::boxed::Box")
                          []
                          [ Ty.apply (Ty.path "array") [ N ] [ T ]; Ty.path "alloc::alloc::Global"
                          ];
                        Ty.apply
                          (Ty.path "alloc::boxed::Box")
                          []
                          [ Ty.apply (Ty.path "slice") [] [ T ]; Ty.path "alloc::alloc::Global" ]
                      ]
                  ],
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            M.call_closure (|
                              Ty.path "bool",
                              BinOp.eq,
                              [
                                M.call_closure (|
                                  Ty.path "usize",
                                  M.get_associated_function (|
                                    Ty.apply (Ty.path "slice") [] [ T ],
                                    "len",
                                    [],
                                    []
                                  |),
                                  [
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.deref (| M.read (| boxed_slice |) |)
                                    |)
                                  ]
                                |);
                                N
                              ]
                            |)
                          |)) in
                      let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::result::Result::Ok"
                          []
                          [
                            Ty.apply
                              (Ty.path "alloc::boxed::Box")
                              []
                              [
                                Ty.apply (Ty.path "array") [ N ] [ T ];
                                Ty.path "alloc::alloc::Global"
                              ];
                            Ty.apply
                              (Ty.path "alloc::boxed::Box")
                              []
                              [ Ty.apply (Ty.path "slice") [] [ T ]; Ty.path "alloc::alloc::Global"
                              ]
                          ]
                          [
                            M.call_closure (|
                              Ty.apply
                                (Ty.path "alloc::boxed::Box")
                                []
                                [
                                  Ty.apply (Ty.path "array") [ N ] [ T ];
                                  Ty.path "alloc::alloc::Global"
                                ],
                              M.get_function (|
                                "alloc::boxed::convert::boxed_slice_as_array_unchecked",
                                [ N ],
                                [ T; Ty.path "alloc::alloc::Global" ]
                              |),
                              [ M.read (| boxed_slice |) ]
                            |)
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (|
                        Value.StructTuple
                          "core::result::Result::Err"
                          []
                          [
                            Ty.apply
                              (Ty.path "alloc::boxed::Box")
                              []
                              [
                                Ty.apply (Ty.path "array") [ N ] [ T ];
                                Ty.path "alloc::alloc::Global"
                              ];
                            Ty.apply
                              (Ty.path "alloc::boxed::Box")
                              []
                              [ Ty.apply (Ty.path "slice") [] [ T ]; Ty.path "alloc::alloc::Global"
                              ]
                          ]
                          [ M.read (| boxed_slice |) ]
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (N : Value.t) (T : Ty.t),
        M.IsTraitInstance
          "core::convert::TryFrom"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [
            Ty.apply
              (Ty.path "alloc::boxed::Box")
              []
              [ Ty.apply (Ty.path "slice") [] [ T ]; Ty.path "alloc::alloc::Global" ]
          ]
          (Self N T)
          (* Instance *)
          [
            ("Error", InstanceField.Ty (_Error N T));
            ("try_from", InstanceField.Method (try_from N T))
          ].
    End Impl_core_convert_TryFrom_alloc_boxed_Box_slice_T_alloc_alloc_Global_for_alloc_boxed_Box_array_N_T_alloc_alloc_Global.
    
    Module Impl_core_convert_TryFrom_alloc_vec_Vec_T_alloc_alloc_Global_for_alloc_boxed_Box_array_N_T_alloc_alloc_Global.
      Definition Self (N : Value.t) (T : Ty.t) : Ty.t :=
        Ty.apply
          (Ty.path "alloc::boxed::Box")
          []
          [ Ty.apply (Ty.path "array") [ N ] [ T ]; Ty.path "alloc::alloc::Global" ].
      
      (*     type Error = Vec<T>; *)
      Definition _Error (N : Value.t) (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "alloc::vec::Vec") [] [ T; Ty.path "alloc::alloc::Global" ].
      
      (*
          fn try_from(vec: Vec<T>) -> Result<Self, Self::Error> {
              if vec.len() == N {
                  let boxed_slice = vec.into_boxed_slice();
                  Ok(unsafe { boxed_slice_as_array_unchecked(boxed_slice) })
              } else {
                  Err(vec)
              }
          }
      *)
      Definition try_from
          (N : Value.t)
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self N T in
        match ε, τ, α with
        | [], [], [ vec ] =>
          ltac:(M.monadic
            (let vec := M.alloc (| vec |) in
            M.read (|
              M.match_operator (|
                Ty.apply
                  (Ty.path "*")
                  []
                  [
                    Ty.apply
                      (Ty.path "core::result::Result")
                      []
                      [
                        Ty.apply
                          (Ty.path "alloc::boxed::Box")
                          []
                          [ Ty.apply (Ty.path "array") [ N ] [ T ]; Ty.path "alloc::alloc::Global"
                          ];
                        Ty.apply
                          (Ty.path "alloc::vec::Vec")
                          []
                          [ T; Ty.path "alloc::alloc::Global" ]
                      ]
                  ],
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            M.call_closure (|
                              Ty.path "bool",
                              BinOp.eq,
                              [
                                M.call_closure (|
                                  Ty.path "usize",
                                  M.get_associated_function (|
                                    Ty.apply
                                      (Ty.path "alloc::vec::Vec")
                                      []
                                      [ T; Ty.path "alloc::alloc::Global" ],
                                    "len",
                                    [],
                                    []
                                  |),
                                  [ M.borrow (| Pointer.Kind.Ref, vec |) ]
                                |);
                                N
                              ]
                            |)
                          |)) in
                      let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      let~ boxed_slice :
                          Ty.apply
                            (Ty.path "*")
                            []
                            [
                              Ty.apply
                                (Ty.path "alloc::boxed::Box")
                                []
                                [
                                  Ty.apply (Ty.path "slice") [] [ T ];
                                  Ty.path "alloc::alloc::Global"
                                ]
                            ] :=
                        M.alloc (|
                          M.call_closure (|
                            Ty.apply
                              (Ty.path "alloc::boxed::Box")
                              []
                              [ Ty.apply (Ty.path "slice") [] [ T ]; Ty.path "alloc::alloc::Global"
                              ],
                            M.get_associated_function (|
                              Ty.apply
                                (Ty.path "alloc::vec::Vec")
                                []
                                [ T; Ty.path "alloc::alloc::Global" ],
                              "into_boxed_slice",
                              [],
                              []
                            |),
                            [ M.read (| vec |) ]
                          |)
                        |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::result::Result::Ok"
                          []
                          [
                            Ty.apply
                              (Ty.path "alloc::boxed::Box")
                              []
                              [
                                Ty.apply (Ty.path "array") [ N ] [ T ];
                                Ty.path "alloc::alloc::Global"
                              ];
                            Ty.apply
                              (Ty.path "alloc::vec::Vec")
                              []
                              [ T; Ty.path "alloc::alloc::Global" ]
                          ]
                          [
                            M.call_closure (|
                              Ty.apply
                                (Ty.path "alloc::boxed::Box")
                                []
                                [
                                  Ty.apply (Ty.path "array") [ N ] [ T ];
                                  Ty.path "alloc::alloc::Global"
                                ],
                              M.get_function (|
                                "alloc::boxed::convert::boxed_slice_as_array_unchecked",
                                [ N ],
                                [ T; Ty.path "alloc::alloc::Global" ]
                              |),
                              [ M.read (| boxed_slice |) ]
                            |)
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (|
                        Value.StructTuple
                          "core::result::Result::Err"
                          []
                          [
                            Ty.apply
                              (Ty.path "alloc::boxed::Box")
                              []
                              [
                                Ty.apply (Ty.path "array") [ N ] [ T ];
                                Ty.path "alloc::alloc::Global"
                              ];
                            Ty.apply
                              (Ty.path "alloc::vec::Vec")
                              []
                              [ T; Ty.path "alloc::alloc::Global" ]
                          ]
                          [ M.read (| vec |) ]
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (N : Value.t) (T : Ty.t),
        M.IsTraitInstance
          "core::convert::TryFrom"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "alloc::vec::Vec") [] [ T; Ty.path "alloc::alloc::Global" ] ]
          (Self N T)
          (* Instance *)
          [
            ("Error", InstanceField.Ty (_Error N T));
            ("try_from", InstanceField.Method (try_from N T))
          ].
    End Impl_core_convert_TryFrom_alloc_vec_Vec_T_alloc_alloc_Global_for_alloc_boxed_Box_array_N_T_alloc_alloc_Global.
    
    Module Impl_alloc_boxed_Box_Dyn_core_any_Any_Trait_A.
      Definition Self (A : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "alloc::boxed::Box") [] [ Ty.dyn [ ("core::any::Any::Trait", []) ]; A ].
      
      (*
          pub fn downcast<T: Any>(self) -> Result<Box<T, A>, Self> {
              if self.is::<T>() { unsafe { Ok(self.downcast_unchecked::<T>()) } } else { Err(self) }
          }
      *)
      Definition downcast (A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self A in
        match ε, τ, α with
        | [], [ T ], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                Ty.apply
                  (Ty.path "*")
                  []
                  [
                    Ty.apply
                      (Ty.path "core::result::Result")
                      []
                      [
                        Ty.apply (Ty.path "alloc::boxed::Box") [] [ T; A ];
                        Ty.apply
                          (Ty.path "alloc::boxed::Box")
                          []
                          [ Ty.dyn [ ("core::any::Any::Trait", []) ]; A ]
                      ]
                  ],
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            M.call_closure (|
                              Ty.path "bool",
                              M.get_associated_function (|
                                Ty.dyn [ ("core::any::Any::Trait", []) ],
                                "is",
                                [],
                                [ T ]
                              |),
                              [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                            |)
                          |)) in
                      let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::result::Result::Ok"
                          []
                          [
                            Ty.apply (Ty.path "alloc::boxed::Box") [] [ T; A ];
                            Ty.apply
                              (Ty.path "alloc::boxed::Box")
                              []
                              [ Ty.dyn [ ("core::any::Any::Trait", []) ]; A ]
                          ]
                          [
                            M.call_closure (|
                              Ty.apply (Ty.path "alloc::boxed::Box") [] [ T; A ],
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "alloc::boxed::Box")
                                  []
                                  [ Ty.dyn [ ("core::any::Any::Trait", []) ]; A ],
                                "downcast_unchecked",
                                [],
                                [ T ]
                              |),
                              [ M.read (| self |) ]
                            |)
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (|
                        Value.StructTuple
                          "core::result::Result::Err"
                          []
                          [
                            Ty.apply (Ty.path "alloc::boxed::Box") [] [ T; A ];
                            Ty.apply
                              (Ty.path "alloc::boxed::Box")
                              []
                              [ Ty.dyn [ ("core::any::Any::Trait", []) ]; A ]
                          ]
                          [ (* Unsize *) M.pointer_coercion (M.read (| self |)) ]
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_downcast :
        forall (A : Ty.t),
        M.IsAssociatedFunction.C (Self A) "downcast" (downcast A).
      Admitted.
      Global Typeclasses Opaque downcast.
      
      (*
          pub unsafe fn downcast_unchecked<T: Any>(self) -> Box<T, A> {
              debug_assert!(self.is::<T>());
              unsafe {
                  let (raw, alloc): ( *mut dyn Any, _) = Box::into_raw_with_allocator(self);
                  Box::from_raw_in(raw as *mut T, alloc)
              }
          }
      *)
      Definition downcast_unchecked
          (A : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self A in
        match ε, τ, α with
        | [], [ T ], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.match_operator (|
                  Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.use (M.alloc (| Value.Bool true |)) in
                        let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                          M.match_operator (|
                            Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                            M.alloc (| Value.Tuple [] |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ :=
                                    M.use
                                      (M.alloc (|
                                        UnOp.not (|
                                          M.call_closure (|
                                            Ty.path "bool",
                                            M.get_associated_function (|
                                              Ty.dyn [ ("core::any::Any::Trait", []) ],
                                              "is",
                                              [],
                                              [ T ]
                                            |),
                                            [
                                              M.borrow (|
                                                Pointer.Kind.Ref,
                                                M.deref (| M.read (| self |) |)
                                              |)
                                            ]
                                          |)
                                        |)
                                      |)) in
                                  let _ :=
                                    is_constant_or_break_match (|
                                      M.read (| γ |),
                                      Value.Bool true
                                    |) in
                                  M.alloc (|
                                    M.never_to_any (|
                                      M.call_closure (|
                                        Ty.path "never",
                                        M.get_function (| "core::panicking::panic", [], [] |),
                                        [ mk_str (| "assertion failed: self.is::<T>()" |) ]
                                      |)
                                    |)
                                  |)));
                              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                            ]
                          |) in
                        M.alloc (| Value.Tuple [] |)));
                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                  ]
                |) in
              M.match_operator (|
                Ty.apply (Ty.path "*") [] [ Ty.apply (Ty.path "alloc::boxed::Box") [] [ T; A ] ],
                M.alloc (|
                  M.call_closure (|
                    Ty.tuple
                      [ Ty.apply (Ty.path "*mut") [] [ Ty.dyn [ ("core::any::Any::Trait", []) ] ]; A
                      ],
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "alloc::boxed::Box")
                        []
                        [ Ty.dyn [ ("core::any::Any::Trait", []) ]; A ],
                      "into_raw_with_allocator",
                      [],
                      []
                    |),
                    [ (* Unsize *) M.pointer_coercion (M.read (| self |)) ]
                  |)
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      let raw := M.copy (| γ0_0 |) in
                      let alloc := M.copy (| γ0_1 |) in
                      M.alloc (|
                        M.call_closure (|
                          Ty.apply (Ty.path "alloc::boxed::Box") [] [ T; A ],
                          M.get_associated_function (|
                            Ty.apply (Ty.path "alloc::boxed::Box") [] [ T; A ],
                            "from_raw_in",
                            [],
                            []
                          |),
                          [
                            M.cast (Ty.apply (Ty.path "*mut") [] [ T ]) (M.read (| raw |));
                            M.read (| alloc |)
                          ]
                        |)
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_downcast_unchecked :
        forall (A : Ty.t),
        M.IsAssociatedFunction.C (Self A) "downcast_unchecked" (downcast_unchecked A).
      Admitted.
      Global Typeclasses Opaque downcast_unchecked.
    End Impl_alloc_boxed_Box_Dyn_core_any_Any_Trait_A.
    
    Module Impl_alloc_boxed_Box_Dyn_core_any_Any_Trait_core_marker_Send_AutoTrait_A.
      Definition Self (A : Ty.t) : Ty.t :=
        Ty.apply
          (Ty.path "alloc::boxed::Box")
          []
          [ Ty.dyn [ ("core::any::Any::Trait", []); ("core::marker::Send::AutoTrait", []) ]; A ].
      
      (*
          pub fn downcast<T: Any>(self) -> Result<Box<T, A>, Self> {
              if self.is::<T>() { unsafe { Ok(self.downcast_unchecked::<T>()) } } else { Err(self) }
          }
      *)
      Definition downcast (A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self A in
        match ε, τ, α with
        | [], [ T ], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                Ty.apply
                  (Ty.path "*")
                  []
                  [
                    Ty.apply
                      (Ty.path "core::result::Result")
                      []
                      [
                        Ty.apply (Ty.path "alloc::boxed::Box") [] [ T; A ];
                        Ty.apply
                          (Ty.path "alloc::boxed::Box")
                          []
                          [
                            Ty.dyn
                              [ ("core::any::Any::Trait", []); ("core::marker::Send::AutoTrait", [])
                              ];
                            A
                          ]
                      ]
                  ],
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            M.call_closure (|
                              Ty.path "bool",
                              M.get_associated_function (|
                                Ty.dyn
                                  [
                                    ("core::any::Any::Trait", []);
                                    ("core::marker::Send::AutoTrait", [])
                                  ],
                                "is",
                                [],
                                [ T ]
                              |),
                              [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                            |)
                          |)) in
                      let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::result::Result::Ok"
                          []
                          [
                            Ty.apply (Ty.path "alloc::boxed::Box") [] [ T; A ];
                            Ty.apply
                              (Ty.path "alloc::boxed::Box")
                              []
                              [
                                Ty.dyn
                                  [
                                    ("core::any::Any::Trait", []);
                                    ("core::marker::Send::AutoTrait", [])
                                  ];
                                A
                              ]
                          ]
                          [
                            M.call_closure (|
                              Ty.apply (Ty.path "alloc::boxed::Box") [] [ T; A ],
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "alloc::boxed::Box")
                                  []
                                  [
                                    Ty.dyn
                                      [
                                        ("core::any::Any::Trait", []);
                                        ("core::marker::Send::AutoTrait", [])
                                      ];
                                    A
                                  ],
                                "downcast_unchecked",
                                [],
                                [ T ]
                              |),
                              [ M.read (| self |) ]
                            |)
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (|
                        Value.StructTuple
                          "core::result::Result::Err"
                          []
                          [
                            Ty.apply (Ty.path "alloc::boxed::Box") [] [ T; A ];
                            Ty.apply
                              (Ty.path "alloc::boxed::Box")
                              []
                              [
                                Ty.dyn
                                  [
                                    ("core::any::Any::Trait", []);
                                    ("core::marker::Send::AutoTrait", [])
                                  ];
                                A
                              ]
                          ]
                          [ (* Unsize *) M.pointer_coercion (M.read (| self |)) ]
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_downcast :
        forall (A : Ty.t),
        M.IsAssociatedFunction.C (Self A) "downcast" (downcast A).
      Admitted.
      Global Typeclasses Opaque downcast.
      
      (*
          pub unsafe fn downcast_unchecked<T: Any>(self) -> Box<T, A> {
              debug_assert!(self.is::<T>());
              unsafe {
                  let (raw, alloc): ( *mut (dyn Any + Send), _) = Box::into_raw_with_allocator(self);
                  Box::from_raw_in(raw as *mut T, alloc)
              }
          }
      *)
      Definition downcast_unchecked
          (A : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self A in
        match ε, τ, α with
        | [], [ T ], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.match_operator (|
                  Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.use (M.alloc (| Value.Bool true |)) in
                        let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                          M.match_operator (|
                            Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                            M.alloc (| Value.Tuple [] |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ :=
                                    M.use
                                      (M.alloc (|
                                        UnOp.not (|
                                          M.call_closure (|
                                            Ty.path "bool",
                                            M.get_associated_function (|
                                              Ty.dyn
                                                [
                                                  ("core::any::Any::Trait", []);
                                                  ("core::marker::Send::AutoTrait", [])
                                                ],
                                              "is",
                                              [],
                                              [ T ]
                                            |),
                                            [
                                              M.borrow (|
                                                Pointer.Kind.Ref,
                                                M.deref (| M.read (| self |) |)
                                              |)
                                            ]
                                          |)
                                        |)
                                      |)) in
                                  let _ :=
                                    is_constant_or_break_match (|
                                      M.read (| γ |),
                                      Value.Bool true
                                    |) in
                                  M.alloc (|
                                    M.never_to_any (|
                                      M.call_closure (|
                                        Ty.path "never",
                                        M.get_function (| "core::panicking::panic", [], [] |),
                                        [ mk_str (| "assertion failed: self.is::<T>()" |) ]
                                      |)
                                    |)
                                  |)));
                              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                            ]
                          |) in
                        M.alloc (| Value.Tuple [] |)));
                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                  ]
                |) in
              M.match_operator (|
                Ty.apply (Ty.path "*") [] [ Ty.apply (Ty.path "alloc::boxed::Box") [] [ T; A ] ],
                M.alloc (|
                  M.call_closure (|
                    Ty.tuple
                      [
                        Ty.apply
                          (Ty.path "*mut")
                          []
                          [
                            Ty.dyn
                              [ ("core::any::Any::Trait", []); ("core::marker::Send::AutoTrait", [])
                              ]
                          ];
                        A
                      ],
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "alloc::boxed::Box")
                        []
                        [
                          Ty.dyn
                            [ ("core::any::Any::Trait", []); ("core::marker::Send::AutoTrait", [])
                            ];
                          A
                        ],
                      "into_raw_with_allocator",
                      [],
                      []
                    |),
                    [ (* Unsize *) M.pointer_coercion (M.read (| self |)) ]
                  |)
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      let raw := M.copy (| γ0_0 |) in
                      let alloc := M.copy (| γ0_1 |) in
                      M.alloc (|
                        M.call_closure (|
                          Ty.apply (Ty.path "alloc::boxed::Box") [] [ T; A ],
                          M.get_associated_function (|
                            Ty.apply (Ty.path "alloc::boxed::Box") [] [ T; A ],
                            "from_raw_in",
                            [],
                            []
                          |),
                          [
                            M.cast (Ty.apply (Ty.path "*mut") [] [ T ]) (M.read (| raw |));
                            M.read (| alloc |)
                          ]
                        |)
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_downcast_unchecked :
        forall (A : Ty.t),
        M.IsAssociatedFunction.C (Self A) "downcast_unchecked" (downcast_unchecked A).
      Admitted.
      Global Typeclasses Opaque downcast_unchecked.
    End Impl_alloc_boxed_Box_Dyn_core_any_Any_Trait_core_marker_Send_AutoTrait_A.
    
    Module Impl_alloc_boxed_Box_Dyn_core_any_Any_Trait_core_marker_Sync_AutoTrait_core_marker_Send_AutoTrait_A.
      Definition Self (A : Ty.t) : Ty.t :=
        Ty.apply
          (Ty.path "alloc::boxed::Box")
          []
          [
            Ty.dyn
              [
                ("core::any::Any::Trait", []);
                ("core::marker::Sync::AutoTrait", []);
                ("core::marker::Send::AutoTrait", [])
              ];
            A
          ].
      
      (*
          pub fn downcast<T: Any>(self) -> Result<Box<T, A>, Self> {
              if self.is::<T>() { unsafe { Ok(self.downcast_unchecked::<T>()) } } else { Err(self) }
          }
      *)
      Definition downcast (A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self A in
        match ε, τ, α with
        | [], [ T ], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                Ty.apply
                  (Ty.path "*")
                  []
                  [
                    Ty.apply
                      (Ty.path "core::result::Result")
                      []
                      [
                        Ty.apply (Ty.path "alloc::boxed::Box") [] [ T; A ];
                        Ty.apply
                          (Ty.path "alloc::boxed::Box")
                          []
                          [
                            Ty.dyn
                              [
                                ("core::any::Any::Trait", []);
                                ("core::marker::Sync::AutoTrait", []);
                                ("core::marker::Send::AutoTrait", [])
                              ];
                            A
                          ]
                      ]
                  ],
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            M.call_closure (|
                              Ty.path "bool",
                              M.get_associated_function (|
                                Ty.dyn
                                  [
                                    ("core::any::Any::Trait", []);
                                    ("core::marker::Sync::AutoTrait", []);
                                    ("core::marker::Send::AutoTrait", [])
                                  ],
                                "is",
                                [],
                                [ T ]
                              |),
                              [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                            |)
                          |)) in
                      let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::result::Result::Ok"
                          []
                          [
                            Ty.apply (Ty.path "alloc::boxed::Box") [] [ T; A ];
                            Ty.apply
                              (Ty.path "alloc::boxed::Box")
                              []
                              [
                                Ty.dyn
                                  [
                                    ("core::any::Any::Trait", []);
                                    ("core::marker::Sync::AutoTrait", []);
                                    ("core::marker::Send::AutoTrait", [])
                                  ];
                                A
                              ]
                          ]
                          [
                            M.call_closure (|
                              Ty.apply (Ty.path "alloc::boxed::Box") [] [ T; A ],
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "alloc::boxed::Box")
                                  []
                                  [
                                    Ty.dyn
                                      [
                                        ("core::any::Any::Trait", []);
                                        ("core::marker::Sync::AutoTrait", []);
                                        ("core::marker::Send::AutoTrait", [])
                                      ];
                                    A
                                  ],
                                "downcast_unchecked",
                                [],
                                [ T ]
                              |),
                              [ M.read (| self |) ]
                            |)
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (|
                        Value.StructTuple
                          "core::result::Result::Err"
                          []
                          [
                            Ty.apply (Ty.path "alloc::boxed::Box") [] [ T; A ];
                            Ty.apply
                              (Ty.path "alloc::boxed::Box")
                              []
                              [
                                Ty.dyn
                                  [
                                    ("core::any::Any::Trait", []);
                                    ("core::marker::Sync::AutoTrait", []);
                                    ("core::marker::Send::AutoTrait", [])
                                  ];
                                A
                              ]
                          ]
                          [ (* Unsize *) M.pointer_coercion (M.read (| self |)) ]
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_downcast :
        forall (A : Ty.t),
        M.IsAssociatedFunction.C (Self A) "downcast" (downcast A).
      Admitted.
      Global Typeclasses Opaque downcast.
      
      (*
          pub unsafe fn downcast_unchecked<T: Any>(self) -> Box<T, A> {
              debug_assert!(self.is::<T>());
              unsafe {
                  let (raw, alloc): ( *mut (dyn Any + Send + Sync), _) =
                      Box::into_raw_with_allocator(self);
                  Box::from_raw_in(raw as *mut T, alloc)
              }
          }
      *)
      Definition downcast_unchecked
          (A : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self A in
        match ε, τ, α with
        | [], [ T ], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.match_operator (|
                  Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.use (M.alloc (| Value.Bool true |)) in
                        let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                          M.match_operator (|
                            Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                            M.alloc (| Value.Tuple [] |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ :=
                                    M.use
                                      (M.alloc (|
                                        UnOp.not (|
                                          M.call_closure (|
                                            Ty.path "bool",
                                            M.get_associated_function (|
                                              Ty.dyn
                                                [
                                                  ("core::any::Any::Trait", []);
                                                  ("core::marker::Sync::AutoTrait", []);
                                                  ("core::marker::Send::AutoTrait", [])
                                                ],
                                              "is",
                                              [],
                                              [ T ]
                                            |),
                                            [
                                              M.borrow (|
                                                Pointer.Kind.Ref,
                                                M.deref (| M.read (| self |) |)
                                              |)
                                            ]
                                          |)
                                        |)
                                      |)) in
                                  let _ :=
                                    is_constant_or_break_match (|
                                      M.read (| γ |),
                                      Value.Bool true
                                    |) in
                                  M.alloc (|
                                    M.never_to_any (|
                                      M.call_closure (|
                                        Ty.path "never",
                                        M.get_function (| "core::panicking::panic", [], [] |),
                                        [ mk_str (| "assertion failed: self.is::<T>()" |) ]
                                      |)
                                    |)
                                  |)));
                              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                            ]
                          |) in
                        M.alloc (| Value.Tuple [] |)));
                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                  ]
                |) in
              M.match_operator (|
                Ty.apply (Ty.path "*") [] [ Ty.apply (Ty.path "alloc::boxed::Box") [] [ T; A ] ],
                M.alloc (|
                  M.call_closure (|
                    Ty.tuple
                      [
                        Ty.apply
                          (Ty.path "*mut")
                          []
                          [
                            Ty.dyn
                              [
                                ("core::any::Any::Trait", []);
                                ("core::marker::Sync::AutoTrait", []);
                                ("core::marker::Send::AutoTrait", [])
                              ]
                          ];
                        A
                      ],
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "alloc::boxed::Box")
                        []
                        [
                          Ty.dyn
                            [
                              ("core::any::Any::Trait", []);
                              ("core::marker::Sync::AutoTrait", []);
                              ("core::marker::Send::AutoTrait", [])
                            ];
                          A
                        ],
                      "into_raw_with_allocator",
                      [],
                      []
                    |),
                    [ (* Unsize *) M.pointer_coercion (M.read (| self |)) ]
                  |)
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      let raw := M.copy (| γ0_0 |) in
                      let alloc := M.copy (| γ0_1 |) in
                      M.alloc (|
                        M.call_closure (|
                          Ty.apply (Ty.path "alloc::boxed::Box") [] [ T; A ],
                          M.get_associated_function (|
                            Ty.apply (Ty.path "alloc::boxed::Box") [] [ T; A ],
                            "from_raw_in",
                            [],
                            []
                          |),
                          [
                            M.cast (Ty.apply (Ty.path "*mut") [] [ T ]) (M.read (| raw |));
                            M.read (| alloc |)
                          ]
                        |)
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_downcast_unchecked :
        forall (A : Ty.t),
        M.IsAssociatedFunction.C (Self A) "downcast_unchecked" (downcast_unchecked A).
      Admitted.
      Global Typeclasses Opaque downcast_unchecked.
    End Impl_alloc_boxed_Box_Dyn_core_any_Any_Trait_core_marker_Sync_AutoTrait_core_marker_Send_AutoTrait_A.
    
    Module Impl_core_convert_From_where_core_error_Error_E_E_for_alloc_boxed_Box_Dyn_core_error_Error_Trait_alloc_alloc_Global.
      Definition Self (E : Ty.t) : Ty.t :=
        Ty.apply
          (Ty.path "alloc::boxed::Box")
          []
          [ Ty.dyn [ ("core::error::Error::Trait", []) ]; Ty.path "alloc::alloc::Global" ].
      
      (*
          fn from(err: E) -> Box<dyn Error + 'a> {
              Box::new(err)
          }
      *)
      Definition from (E : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self E in
        match ε, τ, α with
        | [], [], [ err ] =>
          ltac:(M.monadic
            (let err := M.alloc (| err |) in
            (* Unsize *)
            M.pointer_coercion
              (* Unsize *)
              (M.pointer_coercion
                (M.call_closure (|
                  Ty.apply (Ty.path "alloc::boxed::Box") [] [ E; Ty.path "alloc::alloc::Global" ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "alloc::boxed::Box") [] [ E; Ty.path "alloc::alloc::Global" ],
                    "new",
                    [],
                    []
                  |),
                  [ M.read (| err |) ]
                |)))))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (E : Ty.t),
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ E ]
          (Self E)
          (* Instance *) [ ("from", InstanceField.Method (from E)) ].
    End Impl_core_convert_From_where_core_error_Error_E_E_for_alloc_boxed_Box_Dyn_core_error_Error_Trait_alloc_alloc_Global.
    
    Module Impl_core_convert_From_where_core_error_Error_E_where_core_marker_Send_E_where_core_marker_Sync_E_E_for_alloc_boxed_Box_Dyn_core_error_Error_Trait_core_marker_Sync_AutoTrait_core_marker_Send_AutoTrait_alloc_alloc_Global.
      Definition Self (E : Ty.t) : Ty.t :=
        Ty.apply
          (Ty.path "alloc::boxed::Box")
          []
          [
            Ty.dyn
              [
                ("core::error::Error::Trait", []);
                ("core::marker::Sync::AutoTrait", []);
                ("core::marker::Send::AutoTrait", [])
              ];
            Ty.path "alloc::alloc::Global"
          ].
      
      (*
          fn from(err: E) -> Box<dyn Error + Send + Sync + 'a> {
              Box::new(err)
          }
      *)
      Definition from (E : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self E in
        match ε, τ, α with
        | [], [], [ err ] =>
          ltac:(M.monadic
            (let err := M.alloc (| err |) in
            (* Unsize *)
            M.pointer_coercion
              (* Unsize *)
              (M.pointer_coercion
                (M.call_closure (|
                  Ty.apply (Ty.path "alloc::boxed::Box") [] [ E; Ty.path "alloc::alloc::Global" ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "alloc::boxed::Box") [] [ E; Ty.path "alloc::alloc::Global" ],
                    "new",
                    [],
                    []
                  |),
                  [ M.read (| err |) ]
                |)))))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (E : Ty.t),
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ E ]
          (Self E)
          (* Instance *) [ ("from", InstanceField.Method (from E)) ].
    End Impl_core_convert_From_where_core_error_Error_E_where_core_marker_Send_E_where_core_marker_Sync_E_E_for_alloc_boxed_Box_Dyn_core_error_Error_Trait_core_marker_Sync_AutoTrait_core_marker_Send_AutoTrait_alloc_alloc_Global.
    
    Module Impl_core_convert_From_alloc_string_String_for_alloc_boxed_Box_Dyn_core_error_Error_Trait_core_marker_Sync_AutoTrait_core_marker_Send_AutoTrait_alloc_alloc_Global.
      Definition Self : Ty.t :=
        Ty.apply
          (Ty.path "alloc::boxed::Box")
          []
          [
            Ty.dyn
              [
                ("core::error::Error::Trait", []);
                ("core::marker::Sync::AutoTrait", []);
                ("core::marker::Send::AutoTrait", [])
              ];
            Ty.path "alloc::alloc::Global"
          ].
      
      (*
          fn from(err: String) -> Box<dyn Error + Send + Sync + 'a> {
              struct StringError(String);
      
              impl Error for StringError {
                  #[allow(deprecated)]
                  fn description(&self) -> &str {
                      &self.0
                  }
              }
      
              impl fmt::Display for StringError {
                  fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                      fmt::Display::fmt(&self.0, f)
                  }
              }
      
              // Purposefully skip printing "StringError(..)"
              impl fmt::Debug for StringError {
                  fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                      fmt::Debug::fmt(&self.0, f)
                  }
              }
      
              Box::new(StringError(err))
          }
      *)
      Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ err ] =>
          ltac:(M.monadic
            (let err := M.alloc (| err |) in
            (* Unsize *)
            M.pointer_coercion
              (* Unsize *)
              (M.pointer_coercion
                (M.call_closure (|
                  Ty.apply
                    (Ty.path "alloc::boxed::Box")
                    []
                    [
                      Ty.path "alloc::boxed::convert::from::StringError";
                      Ty.path "alloc::alloc::Global"
                    ],
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "alloc::boxed::Box")
                      []
                      [
                        Ty.path "alloc::boxed::convert::from::StringError";
                        Ty.path "alloc::alloc::Global"
                      ],
                    "new",
                    [],
                    []
                  |),
                  [
                    Value.StructTuple
                      "alloc::boxed::convert::from::StringError"
                      []
                      []
                      [ M.read (| err |) ]
                  ]
                |)))))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "alloc::string::String" ]
          Self
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_alloc_string_String_for_alloc_boxed_Box_Dyn_core_error_Error_Trait_core_marker_Sync_AutoTrait_core_marker_Send_AutoTrait_alloc_alloc_Global.
    
    Module Impl_core_convert_From_alloc_string_String_for_alloc_boxed_Box_Dyn_core_error_Error_Trait_alloc_alloc_Global.
      Definition Self : Ty.t :=
        Ty.apply
          (Ty.path "alloc::boxed::Box")
          []
          [ Ty.dyn [ ("core::error::Error::Trait", []) ]; Ty.path "alloc::alloc::Global" ].
      
      (*
          fn from(str_err: String) -> Box<dyn Error + 'a> {
              let err1: Box<dyn Error + Send + Sync> = From::from(str_err);
              let err2: Box<dyn Error> = err1;
              err2
          }
      *)
      Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ str_err ] =>
          ltac:(M.monadic
            (let str_err := M.alloc (| str_err |) in
            (* Unsize *)
            M.pointer_coercion
              (M.read (|
                let~ err1 :
                    Ty.apply
                      (Ty.path "*")
                      []
                      [
                        Ty.apply
                          (Ty.path "alloc::boxed::Box")
                          []
                          [
                            Ty.dyn
                              [
                                ("core::error::Error::Trait", []);
                                ("core::marker::Sync::AutoTrait", []);
                                ("core::marker::Send::AutoTrait", [])
                              ];
                            Ty.path "alloc::alloc::Global"
                          ]
                      ] :=
                  M.alloc (|
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "alloc::boxed::Box")
                        []
                        [
                          Ty.dyn
                            [
                              ("core::error::Error::Trait", []);
                              ("core::marker::Sync::AutoTrait", []);
                              ("core::marker::Send::AutoTrait", [])
                            ];
                          Ty.path "alloc::alloc::Global"
                        ],
                      M.get_trait_method (|
                        "core::convert::From",
                        Ty.apply
                          (Ty.path "alloc::boxed::Box")
                          []
                          [
                            Ty.dyn
                              [
                                ("core::error::Error::Trait", []);
                                ("core::marker::Sync::AutoTrait", []);
                                ("core::marker::Send::AutoTrait", [])
                              ];
                            Ty.path "alloc::alloc::Global"
                          ],
                        [],
                        [ Ty.path "alloc::string::String" ],
                        "from",
                        [],
                        []
                      |),
                      [ M.read (| str_err |) ]
                    |)
                  |) in
                let~ err2 :
                    Ty.apply
                      (Ty.path "*")
                      []
                      [
                        Ty.apply
                          (Ty.path "alloc::boxed::Box")
                          []
                          [
                            Ty.dyn [ ("core::error::Error::Trait", []) ];
                            Ty.path "alloc::alloc::Global"
                          ]
                      ] :=
                  M.alloc (| (* Unsize *) M.pointer_coercion (M.read (| err1 |)) |) in
                M.alloc (| (* Unsize *) M.pointer_coercion (M.read (| err2 |)) |)
              |))))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "alloc::string::String" ]
          Self
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_alloc_string_String_for_alloc_boxed_Box_Dyn_core_error_Error_Trait_alloc_alloc_Global.
    
    Module Impl_core_convert_From_ref__str_for_alloc_boxed_Box_Dyn_core_error_Error_Trait_core_marker_Sync_AutoTrait_core_marker_Send_AutoTrait_alloc_alloc_Global.
      Definition Self : Ty.t :=
        Ty.apply
          (Ty.path "alloc::boxed::Box")
          []
          [
            Ty.dyn
              [
                ("core::error::Error::Trait", []);
                ("core::marker::Sync::AutoTrait", []);
                ("core::marker::Send::AutoTrait", [])
              ];
            Ty.path "alloc::alloc::Global"
          ].
      
      (*
          fn from(err: &str) -> Box<dyn Error + Send + Sync + 'a> {
              From::from(String::from(err))
          }
      *)
      Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ err ] =>
          ltac:(M.monadic
            (let err := M.alloc (| err |) in
            (* Unsize *)
            M.pointer_coercion
              (M.call_closure (|
                Ty.apply
                  (Ty.path "alloc::boxed::Box")
                  []
                  [
                    Ty.dyn
                      [
                        ("core::error::Error::Trait", []);
                        ("core::marker::Sync::AutoTrait", []);
                        ("core::marker::Send::AutoTrait", [])
                      ];
                    Ty.path "alloc::alloc::Global"
                  ],
                M.get_trait_method (|
                  "core::convert::From",
                  Ty.apply
                    (Ty.path "alloc::boxed::Box")
                    []
                    [
                      Ty.dyn
                        [
                          ("core::error::Error::Trait", []);
                          ("core::marker::Sync::AutoTrait", []);
                          ("core::marker::Send::AutoTrait", [])
                        ];
                      Ty.path "alloc::alloc::Global"
                    ],
                  [],
                  [ Ty.path "alloc::string::String" ],
                  "from",
                  [],
                  []
                |),
                [
                  M.call_closure (|
                    Ty.path "alloc::string::String",
                    M.get_trait_method (|
                      "core::convert::From",
                      Ty.path "alloc::string::String",
                      [],
                      [ Ty.apply (Ty.path "&") [] [ Ty.path "str" ] ],
                      "from",
                      [],
                      []
                    |),
                    [ M.read (| err |) ]
                  |)
                ]
              |))))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.apply (Ty.path "&") [] [ Ty.path "str" ] ]
          Self
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_ref__str_for_alloc_boxed_Box_Dyn_core_error_Error_Trait_core_marker_Sync_AutoTrait_core_marker_Send_AutoTrait_alloc_alloc_Global.
    
    Module Impl_core_convert_From_ref__str_for_alloc_boxed_Box_Dyn_core_error_Error_Trait_alloc_alloc_Global.
      Definition Self : Ty.t :=
        Ty.apply
          (Ty.path "alloc::boxed::Box")
          []
          [ Ty.dyn [ ("core::error::Error::Trait", []) ]; Ty.path "alloc::alloc::Global" ].
      
      (*
          fn from(err: &str) -> Box<dyn Error + 'a> {
              From::from(String::from(err))
          }
      *)
      Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ err ] =>
          ltac:(M.monadic
            (let err := M.alloc (| err |) in
            (* Unsize *)
            M.pointer_coercion
              (M.call_closure (|
                Ty.apply
                  (Ty.path "alloc::boxed::Box")
                  []
                  [ Ty.dyn [ ("core::error::Error::Trait", []) ]; Ty.path "alloc::alloc::Global" ],
                M.get_trait_method (|
                  "core::convert::From",
                  Ty.apply
                    (Ty.path "alloc::boxed::Box")
                    []
                    [ Ty.dyn [ ("core::error::Error::Trait", []) ]; Ty.path "alloc::alloc::Global"
                    ],
                  [],
                  [ Ty.path "alloc::string::String" ],
                  "from",
                  [],
                  []
                |),
                [
                  M.call_closure (|
                    Ty.path "alloc::string::String",
                    M.get_trait_method (|
                      "core::convert::From",
                      Ty.path "alloc::string::String",
                      [],
                      [ Ty.apply (Ty.path "&") [] [ Ty.path "str" ] ],
                      "from",
                      [],
                      []
                    |),
                    [ M.read (| err |) ]
                  |)
                ]
              |))))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.apply (Ty.path "&") [] [ Ty.path "str" ] ]
          Self
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_ref__str_for_alloc_boxed_Box_Dyn_core_error_Error_Trait_alloc_alloc_Global.
    
    Module Impl_core_convert_From_alloc_borrow_Cow_str_for_alloc_boxed_Box_Dyn_core_error_Error_Trait_core_marker_Sync_AutoTrait_core_marker_Send_AutoTrait_alloc_alloc_Global.
      Definition Self : Ty.t :=
        Ty.apply
          (Ty.path "alloc::boxed::Box")
          []
          [
            Ty.dyn
              [
                ("core::error::Error::Trait", []);
                ("core::marker::Sync::AutoTrait", []);
                ("core::marker::Send::AutoTrait", [])
              ];
            Ty.path "alloc::alloc::Global"
          ].
      
      (*
          fn from(err: Cow<'b, str>) -> Box<dyn Error + Send + Sync + 'a> {
              From::from(String::from(err))
          }
      *)
      Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ err ] =>
          ltac:(M.monadic
            (let err := M.alloc (| err |) in
            (* Unsize *)
            M.pointer_coercion
              (M.call_closure (|
                Ty.apply
                  (Ty.path "alloc::boxed::Box")
                  []
                  [
                    Ty.dyn
                      [
                        ("core::error::Error::Trait", []);
                        ("core::marker::Sync::AutoTrait", []);
                        ("core::marker::Send::AutoTrait", [])
                      ];
                    Ty.path "alloc::alloc::Global"
                  ],
                M.get_trait_method (|
                  "core::convert::From",
                  Ty.apply
                    (Ty.path "alloc::boxed::Box")
                    []
                    [
                      Ty.dyn
                        [
                          ("core::error::Error::Trait", []);
                          ("core::marker::Sync::AutoTrait", []);
                          ("core::marker::Send::AutoTrait", [])
                        ];
                      Ty.path "alloc::alloc::Global"
                    ],
                  [],
                  [ Ty.path "alloc::string::String" ],
                  "from",
                  [],
                  []
                |),
                [
                  M.call_closure (|
                    Ty.path "alloc::string::String",
                    M.get_trait_method (|
                      "core::convert::From",
                      Ty.path "alloc::string::String",
                      [],
                      [ Ty.apply (Ty.path "alloc::borrow::Cow") [] [ Ty.path "str" ] ],
                      "from",
                      [],
                      []
                    |),
                    [ M.read (| err |) ]
                  |)
                ]
              |))))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "alloc::borrow::Cow") [] [ Ty.path "str" ] ]
          Self
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_alloc_borrow_Cow_str_for_alloc_boxed_Box_Dyn_core_error_Error_Trait_core_marker_Sync_AutoTrait_core_marker_Send_AutoTrait_alloc_alloc_Global.
    
    Module Impl_core_convert_From_alloc_borrow_Cow_str_for_alloc_boxed_Box_Dyn_core_error_Error_Trait_alloc_alloc_Global.
      Definition Self : Ty.t :=
        Ty.apply
          (Ty.path "alloc::boxed::Box")
          []
          [ Ty.dyn [ ("core::error::Error::Trait", []) ]; Ty.path "alloc::alloc::Global" ].
      
      (*
          fn from(err: Cow<'b, str>) -> Box<dyn Error + 'a> {
              From::from(String::from(err))
          }
      *)
      Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ err ] =>
          ltac:(M.monadic
            (let err := M.alloc (| err |) in
            (* Unsize *)
            M.pointer_coercion
              (M.call_closure (|
                Ty.apply
                  (Ty.path "alloc::boxed::Box")
                  []
                  [ Ty.dyn [ ("core::error::Error::Trait", []) ]; Ty.path "alloc::alloc::Global" ],
                M.get_trait_method (|
                  "core::convert::From",
                  Ty.apply
                    (Ty.path "alloc::boxed::Box")
                    []
                    [ Ty.dyn [ ("core::error::Error::Trait", []) ]; Ty.path "alloc::alloc::Global"
                    ],
                  [],
                  [ Ty.path "alloc::string::String" ],
                  "from",
                  [],
                  []
                |),
                [
                  M.call_closure (|
                    Ty.path "alloc::string::String",
                    M.get_trait_method (|
                      "core::convert::From",
                      Ty.path "alloc::string::String",
                      [],
                      [ Ty.apply (Ty.path "alloc::borrow::Cow") [] [ Ty.path "str" ] ],
                      "from",
                      [],
                      []
                    |),
                    [ M.read (| err |) ]
                  |)
                ]
              |))))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "alloc::borrow::Cow") [] [ Ty.path "str" ] ]
          Self
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_alloc_borrow_Cow_str_for_alloc_boxed_Box_Dyn_core_error_Error_Trait_alloc_alloc_Global.
    
    Module Impl_Dyn_core_error_Error_Trait.
      Definition Self : Ty.t := Ty.dyn [ ("core::error::Error::Trait", []) ].
      
      (*
          pub fn downcast<T: Error + 'static>(self: Box<Self>) -> Result<Box<T>, Box<dyn Error>> {
              if self.is::<T>() {
                  unsafe {
                      let raw: *mut dyn Error = Box::into_raw(self);
                      Ok(Box::from_raw(raw as *mut T))
                  }
              } else {
                  Err(self)
              }
          }
      *)
      Definition downcast (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [ T ], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                Ty.apply
                  (Ty.path "*")
                  []
                  [
                    Ty.apply
                      (Ty.path "core::result::Result")
                      []
                      [
                        Ty.apply
                          (Ty.path "alloc::boxed::Box")
                          []
                          [ T; Ty.path "alloc::alloc::Global" ];
                        Ty.apply
                          (Ty.path "alloc::boxed::Box")
                          []
                          [
                            Ty.dyn [ ("core::error::Error::Trait", []) ];
                            Ty.path "alloc::alloc::Global"
                          ]
                      ]
                  ],
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            M.call_closure (|
                              Ty.path "bool",
                              M.get_associated_function (|
                                Ty.dyn [ ("core::error::Error::Trait", []) ],
                                "is",
                                [],
                                [ T ]
                              |),
                              [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                            |)
                          |)) in
                      let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      let~ raw :
                          Ty.apply
                            (Ty.path "*")
                            []
                            [
                              Ty.apply
                                (Ty.path "*mut")
                                []
                                [ Ty.dyn [ ("core::error::Error::Trait", []) ] ]
                            ] :=
                        M.alloc (|
                          (* Unsize *)
                          M.pointer_coercion
                            (M.call_closure (|
                              Ty.apply
                                (Ty.path "*mut")
                                []
                                [ Ty.dyn [ ("core::error::Error::Trait", []) ] ],
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "alloc::boxed::Box")
                                  []
                                  [
                                    Ty.dyn [ ("core::error::Error::Trait", []) ];
                                    Ty.path "alloc::alloc::Global"
                                  ],
                                "into_raw",
                                [],
                                []
                              |),
                              [ (* Unsize *) M.pointer_coercion (M.read (| self |)) ]
                            |))
                        |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::result::Result::Ok"
                          []
                          [
                            Ty.apply
                              (Ty.path "alloc::boxed::Box")
                              []
                              [ T; Ty.path "alloc::alloc::Global" ];
                            Ty.apply
                              (Ty.path "alloc::boxed::Box")
                              []
                              [
                                Ty.dyn [ ("core::error::Error::Trait", []) ];
                                Ty.path "alloc::alloc::Global"
                              ]
                          ]
                          [
                            M.call_closure (|
                              Ty.apply
                                (Ty.path "alloc::boxed::Box")
                                []
                                [ T; Ty.path "alloc::alloc::Global" ],
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "alloc::boxed::Box")
                                  []
                                  [ T; Ty.path "alloc::alloc::Global" ],
                                "from_raw",
                                [],
                                []
                              |),
                              [ M.cast (Ty.apply (Ty.path "*mut") [] [ T ]) (M.read (| raw |)) ]
                            |)
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (|
                        Value.StructTuple
                          "core::result::Result::Err"
                          []
                          [
                            Ty.apply
                              (Ty.path "alloc::boxed::Box")
                              []
                              [ T; Ty.path "alloc::alloc::Global" ];
                            Ty.apply
                              (Ty.path "alloc::boxed::Box")
                              []
                              [
                                Ty.dyn [ ("core::error::Error::Trait", []) ];
                                Ty.path "alloc::alloc::Global"
                              ]
                          ]
                          [ (* Unsize *) M.pointer_coercion (M.read (| self |)) ]
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_downcast :
        M.IsAssociatedFunction.C Self "downcast" downcast.
      Admitted.
      Global Typeclasses Opaque downcast.
    End Impl_Dyn_core_error_Error_Trait.
    
    Module Impl_Dyn_core_error_Error_Trait_core_marker_Send_AutoTrait.
      Definition Self : Ty.t :=
        Ty.dyn [ ("core::error::Error::Trait", []); ("core::marker::Send::AutoTrait", []) ].
      
      (*
          pub fn downcast<T: Error + 'static>(self: Box<Self>) -> Result<Box<T>, Box<dyn Error + Send>> {
              let err: Box<dyn Error> = self;
              <dyn Error>::downcast(err).map_err(|s| unsafe {
                  // Reapply the `Send` marker.
                  mem::transmute::<Box<dyn Error>, Box<dyn Error + Send>>(s)
              })
          }
      *)
      Definition downcast (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [ T ], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              let~ err :
                  Ty.apply
                    (Ty.path "*")
                    []
                    [
                      Ty.apply
                        (Ty.path "alloc::boxed::Box")
                        []
                        [
                          Ty.dyn [ ("core::error::Error::Trait", []) ];
                          Ty.path "alloc::alloc::Global"
                        ]
                    ] :=
                M.alloc (| (* Unsize *) M.pointer_coercion (M.read (| self |)) |) in
              M.alloc (|
                M.call_closure (|
                  Ty.apply
                    (Ty.path "core::result::Result")
                    []
                    [
                      Ty.apply
                        (Ty.path "alloc::boxed::Box")
                        []
                        [ T; Ty.path "alloc::alloc::Global" ];
                      Ty.apply
                        (Ty.path "alloc::boxed::Box")
                        []
                        [
                          Ty.dyn
                            [
                              ("core::error::Error::Trait", []);
                              ("core::marker::Send::AutoTrait", [])
                            ];
                          Ty.path "alloc::alloc::Global"
                        ]
                    ],
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "core::result::Result")
                      []
                      [
                        Ty.apply
                          (Ty.path "alloc::boxed::Box")
                          []
                          [ T; Ty.path "alloc::alloc::Global" ];
                        Ty.apply
                          (Ty.path "alloc::boxed::Box")
                          []
                          [
                            Ty.dyn [ ("core::error::Error::Trait", []) ];
                            Ty.path "alloc::alloc::Global"
                          ]
                      ],
                    "map_err",
                    [],
                    [
                      Ty.apply
                        (Ty.path "alloc::boxed::Box")
                        []
                        [
                          Ty.dyn
                            [
                              ("core::error::Error::Trait", []);
                              ("core::marker::Send::AutoTrait", [])
                            ];
                          Ty.path "alloc::alloc::Global"
                        ];
                      Ty.function
                        [
                          Ty.tuple
                            [
                              Ty.apply
                                (Ty.path "alloc::boxed::Box")
                                []
                                [
                                  Ty.dyn [ ("core::error::Error::Trait", []) ];
                                  Ty.path "alloc::alloc::Global"
                                ]
                            ]
                        ]
                        (Ty.apply
                          (Ty.path "alloc::boxed::Box")
                          []
                          [
                            Ty.dyn
                              [
                                ("core::error::Error::Trait", []);
                                ("core::marker::Send::AutoTrait", [])
                              ];
                            Ty.path "alloc::alloc::Global"
                          ])
                    ]
                  |),
                  [
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "core::result::Result")
                        []
                        [
                          Ty.apply
                            (Ty.path "alloc::boxed::Box")
                            []
                            [ T; Ty.path "alloc::alloc::Global" ];
                          Ty.apply
                            (Ty.path "alloc::boxed::Box")
                            []
                            [
                              Ty.dyn [ ("core::error::Error::Trait", []) ];
                              Ty.path "alloc::alloc::Global"
                            ]
                        ],
                      M.get_associated_function (|
                        Ty.dyn [ ("core::error::Error::Trait", []) ],
                        "downcast",
                        [],
                        [ T ]
                      |),
                      [ (* Unsize *) M.pointer_coercion (M.read (| err |)) ]
                    |);
                    M.closure
                      (fun γ =>
                        ltac:(M.monadic
                          match γ with
                          | [ α0 ] =>
                            ltac:(M.monadic
                              (M.match_operator (|
                                Ty.apply
                                  (Ty.path "*")
                                  []
                                  [
                                    Ty.function
                                      [
                                        Ty.tuple
                                          [
                                            Ty.apply
                                              (Ty.path "alloc::boxed::Box")
                                              []
                                              [
                                                Ty.dyn [ ("core::error::Error::Trait", []) ];
                                                Ty.path "alloc::alloc::Global"
                                              ]
                                          ]
                                      ]
                                      (Ty.apply
                                        (Ty.path "alloc::boxed::Box")
                                        []
                                        [
                                          Ty.dyn
                                            [
                                              ("core::error::Error::Trait", []);
                                              ("core::marker::Send::AutoTrait", [])
                                            ];
                                          Ty.path "alloc::alloc::Global"
                                        ])
                                  ],
                                M.alloc (| α0 |),
                                [
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let s := M.copy (| γ |) in
                                      (* Unsize *)
                                      M.pointer_coercion
                                        (M.call_closure (|
                                          Ty.apply
                                            (Ty.path "alloc::boxed::Box")
                                            []
                                            [
                                              Ty.dyn
                                                [
                                                  ("core::error::Error::Trait", []);
                                                  ("core::marker::Send::AutoTrait", [])
                                                ];
                                              Ty.path "alloc::alloc::Global"
                                            ],
                                          M.get_function (|
                                            "core::intrinsics::transmute",
                                            [],
                                            [
                                              Ty.apply
                                                (Ty.path "alloc::boxed::Box")
                                                []
                                                [
                                                  Ty.dyn [ ("core::error::Error::Trait", []) ];
                                                  Ty.path "alloc::alloc::Global"
                                                ];
                                              Ty.apply
                                                (Ty.path "alloc::boxed::Box")
                                                []
                                                [
                                                  Ty.dyn
                                                    [
                                                      ("core::error::Error::Trait", []);
                                                      ("core::marker::Send::AutoTrait", [])
                                                    ];
                                                  Ty.path "alloc::alloc::Global"
                                                ]
                                            ]
                                          |),
                                          [ (* Unsize *) M.pointer_coercion (M.read (| s |)) ]
                                        |))))
                                ]
                              |)))
                          | _ => M.impossible "wrong number of arguments"
                          end))
                  ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_downcast :
        M.IsAssociatedFunction.C Self "downcast" downcast.
      Admitted.
      Global Typeclasses Opaque downcast.
    End Impl_Dyn_core_error_Error_Trait_core_marker_Send_AutoTrait.
    
    Module Impl_Dyn_core_error_Error_Trait_core_marker_Sync_AutoTrait_core_marker_Send_AutoTrait.
      Definition Self : Ty.t :=
        Ty.dyn
          [
            ("core::error::Error::Trait", []);
            ("core::marker::Sync::AutoTrait", []);
            ("core::marker::Send::AutoTrait", [])
          ].
      
      (*
          pub fn downcast<T: Error + 'static>(self: Box<Self>) -> Result<Box<T>, Box<Self>> {
              let err: Box<dyn Error> = self;
              <dyn Error>::downcast(err).map_err(|s| unsafe {
                  // Reapply the `Send + Sync` markers.
                  mem::transmute::<Box<dyn Error>, Box<dyn Error + Send + Sync>>(s)
              })
          }
      *)
      Definition downcast (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [ T ], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              let~ err :
                  Ty.apply
                    (Ty.path "*")
                    []
                    [
                      Ty.apply
                        (Ty.path "alloc::boxed::Box")
                        []
                        [
                          Ty.dyn [ ("core::error::Error::Trait", []) ];
                          Ty.path "alloc::alloc::Global"
                        ]
                    ] :=
                M.alloc (| (* Unsize *) M.pointer_coercion (M.read (| self |)) |) in
              M.alloc (|
                M.call_closure (|
                  Ty.apply
                    (Ty.path "core::result::Result")
                    []
                    [
                      Ty.apply
                        (Ty.path "alloc::boxed::Box")
                        []
                        [ T; Ty.path "alloc::alloc::Global" ];
                      Ty.apply
                        (Ty.path "alloc::boxed::Box")
                        []
                        [
                          Ty.dyn
                            [
                              ("core::error::Error::Trait", []);
                              ("core::marker::Sync::AutoTrait", []);
                              ("core::marker::Send::AutoTrait", [])
                            ];
                          Ty.path "alloc::alloc::Global"
                        ]
                    ],
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "core::result::Result")
                      []
                      [
                        Ty.apply
                          (Ty.path "alloc::boxed::Box")
                          []
                          [ T; Ty.path "alloc::alloc::Global" ];
                        Ty.apply
                          (Ty.path "alloc::boxed::Box")
                          []
                          [
                            Ty.dyn [ ("core::error::Error::Trait", []) ];
                            Ty.path "alloc::alloc::Global"
                          ]
                      ],
                    "map_err",
                    [],
                    [
                      Ty.apply
                        (Ty.path "alloc::boxed::Box")
                        []
                        [
                          Ty.dyn
                            [
                              ("core::error::Error::Trait", []);
                              ("core::marker::Sync::AutoTrait", []);
                              ("core::marker::Send::AutoTrait", [])
                            ];
                          Ty.path "alloc::alloc::Global"
                        ];
                      Ty.function
                        [
                          Ty.tuple
                            [
                              Ty.apply
                                (Ty.path "alloc::boxed::Box")
                                []
                                [
                                  Ty.dyn [ ("core::error::Error::Trait", []) ];
                                  Ty.path "alloc::alloc::Global"
                                ]
                            ]
                        ]
                        (Ty.apply
                          (Ty.path "alloc::boxed::Box")
                          []
                          [
                            Ty.dyn
                              [
                                ("core::error::Error::Trait", []);
                                ("core::marker::Sync::AutoTrait", []);
                                ("core::marker::Send::AutoTrait", [])
                              ];
                            Ty.path "alloc::alloc::Global"
                          ])
                    ]
                  |),
                  [
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "core::result::Result")
                        []
                        [
                          Ty.apply
                            (Ty.path "alloc::boxed::Box")
                            []
                            [ T; Ty.path "alloc::alloc::Global" ];
                          Ty.apply
                            (Ty.path "alloc::boxed::Box")
                            []
                            [
                              Ty.dyn [ ("core::error::Error::Trait", []) ];
                              Ty.path "alloc::alloc::Global"
                            ]
                        ],
                      M.get_associated_function (|
                        Ty.dyn [ ("core::error::Error::Trait", []) ],
                        "downcast",
                        [],
                        [ T ]
                      |),
                      [ (* Unsize *) M.pointer_coercion (M.read (| err |)) ]
                    |);
                    M.closure
                      (fun γ =>
                        ltac:(M.monadic
                          match γ with
                          | [ α0 ] =>
                            ltac:(M.monadic
                              (M.match_operator (|
                                Ty.apply
                                  (Ty.path "*")
                                  []
                                  [
                                    Ty.function
                                      [
                                        Ty.tuple
                                          [
                                            Ty.apply
                                              (Ty.path "alloc::boxed::Box")
                                              []
                                              [
                                                Ty.dyn [ ("core::error::Error::Trait", []) ];
                                                Ty.path "alloc::alloc::Global"
                                              ]
                                          ]
                                      ]
                                      (Ty.apply
                                        (Ty.path "alloc::boxed::Box")
                                        []
                                        [
                                          Ty.dyn
                                            [
                                              ("core::error::Error::Trait", []);
                                              ("core::marker::Sync::AutoTrait", []);
                                              ("core::marker::Send::AutoTrait", [])
                                            ];
                                          Ty.path "alloc::alloc::Global"
                                        ])
                                  ],
                                M.alloc (| α0 |),
                                [
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let s := M.copy (| γ |) in
                                      (* Unsize *)
                                      M.pointer_coercion
                                        (M.call_closure (|
                                          Ty.apply
                                            (Ty.path "alloc::boxed::Box")
                                            []
                                            [
                                              Ty.dyn
                                                [
                                                  ("core::error::Error::Trait", []);
                                                  ("core::marker::Sync::AutoTrait", []);
                                                  ("core::marker::Send::AutoTrait", [])
                                                ];
                                              Ty.path "alloc::alloc::Global"
                                            ],
                                          M.get_function (|
                                            "core::intrinsics::transmute",
                                            [],
                                            [
                                              Ty.apply
                                                (Ty.path "alloc::boxed::Box")
                                                []
                                                [
                                                  Ty.dyn [ ("core::error::Error::Trait", []) ];
                                                  Ty.path "alloc::alloc::Global"
                                                ];
                                              Ty.apply
                                                (Ty.path "alloc::boxed::Box")
                                                []
                                                [
                                                  Ty.dyn
                                                    [
                                                      ("core::error::Error::Trait", []);
                                                      ("core::marker::Sync::AutoTrait", []);
                                                      ("core::marker::Send::AutoTrait", [])
                                                    ];
                                                  Ty.path "alloc::alloc::Global"
                                                ]
                                            ]
                                          |),
                                          [ (* Unsize *) M.pointer_coercion (M.read (| s |)) ]
                                        |))))
                                ]
                              |)))
                          | _ => M.impossible "wrong number of arguments"
                          end))
                  ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_downcast :
        M.IsAssociatedFunction.C Self "downcast" downcast.
      Admitted.
      Global Typeclasses Opaque downcast.
    End Impl_Dyn_core_error_Error_Trait_core_marker_Sync_AutoTrait_core_marker_Send_AutoTrait.
  End convert.
End boxed.
