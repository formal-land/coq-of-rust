(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module boxed.
  Module iter.
    Module Impl_core_iter_traits_iterator_Iterator_where_core_iter_traits_iterator_Iterator_I_where_core_marker_Sized_I_where_core_alloc_Allocator_A_for_alloc_boxed_Box_I_A.
      Definition Self (I A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::boxed::Box") [] [ I; A ].
      
      (*     type Item = I::Item; *)
      Definition _Item (I A : Ty.t) : Ty.t :=
        Ty.associated_in_trait "core::iter::traits::iterator::Iterator" [] [] I "Item".
      
      (*
          fn next(&mut self) -> Option<I::Item> {
              ( **self).next()
          }
      *)
      Definition next (I A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self I A in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "core::option::Option")
                []
                [ Ty.associated_in_trait "core::iter::traits::iterator::Iterator" [] [] I "Item" ],
              M.get_trait_method (|
                "core::iter::traits::iterator::Iterator",
                I,
                [],
                [],
                "next",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn size_hint(&self) -> (usize, Option<usize>) {
              ( **self).size_hint()
          }
      *)
      Definition size_hint (I A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self I A in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.tuple
                [ Ty.path "usize"; Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "usize" ]
                ],
              M.get_trait_method (|
                "core::iter::traits::iterator::Iterator",
                I,
                [],
                [],
                "size_hint",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn nth(&mut self, n: usize) -> Option<I::Item> {
              ( **self).nth(n)
          }
      *)
      Definition nth (I A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self I A in
        match ε, τ, α with
        | [], [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "core::option::Option")
                []
                [ Ty.associated_in_trait "core::iter::traits::iterator::Iterator" [] [] I "Item" ],
              M.get_trait_method (|
                "core::iter::traits::iterator::Iterator",
                I,
                [],
                [],
                "nth",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
                |);
                M.read (| n |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn last(self) -> Option<I::Item> {
              BoxIter::last(self)
          }
      *)
      Definition last (I A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self I A in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "core::option::Option")
                []
                [ Ty.associated_in_trait "core::iter::traits::iterator::Iterator" [] [] I "Item" ],
              M.get_trait_method (|
                "alloc::boxed::iter::BoxIter",
                Ty.apply (Ty.path "alloc::boxed::Box") [] [ I; A ],
                [],
                [],
                "last",
                [],
                []
              |),
              [ M.read (| self |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (I A : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::iterator::Iterator"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self I A)
          (* Instance *)
          [
            ("Item", InstanceField.Ty (_Item I A));
            ("next", InstanceField.Method (next I A));
            ("size_hint", InstanceField.Method (size_hint I A));
            ("nth", InstanceField.Method (nth I A));
            ("last", InstanceField.Method (last I A))
          ].
    End Impl_core_iter_traits_iterator_Iterator_where_core_iter_traits_iterator_Iterator_I_where_core_marker_Sized_I_where_core_alloc_Allocator_A_for_alloc_boxed_Box_I_A.
    
    (* Trait *)
    (* Empty module 'BoxIter' *)
    
    Module Impl_alloc_boxed_iter_BoxIter_where_core_iter_traits_iterator_Iterator_I_where_core_marker_Sized_I_where_core_alloc_Allocator_A_for_alloc_boxed_Box_I_A.
      Definition Self (I A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::boxed::Box") [] [ I; A ].
      
      (*     type Item = I::Item; *)
      Definition _Item (I A : Ty.t) : Ty.t :=
        Ty.associated_in_trait "core::iter::traits::iterator::Iterator" [] [] I "Item".
      
      (*
          default fn last(self) -> Option<I::Item> {
              #[inline]
              fn some<T>(_: Option<T>, x: T) -> Option<T> {
                  Some(x)
              }
      
              self.fold(None, some)
          }
      *)
      Definition last (I A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self I A in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "core::option::Option")
                []
                [ Ty.associated_in_trait "core::iter::traits::iterator::Iterator" [] [] I "Item" ],
              M.get_trait_method (|
                "core::iter::traits::iterator::Iterator",
                Ty.apply (Ty.path "alloc::boxed::Box") [] [ I; A ],
                [],
                [],
                "fold",
                [],
                [
                  Ty.apply
                    (Ty.path "core::option::Option")
                    []
                    [ Ty.associated_in_trait "core::iter::traits::iterator::Iterator" [] [] I "Item"
                    ];
                  Ty.function
                    [
                      Ty.apply
                        (Ty.path "core::option::Option")
                        []
                        [
                          Ty.associated_in_trait
                            "core::iter::traits::iterator::Iterator"
                            []
                            []
                            I
                            "Item"
                        ];
                      Ty.associated_in_trait "core::iter::traits::iterator::Iterator" [] [] I "Item"
                    ]
                    (Ty.apply
                      (Ty.path "core::option::Option")
                      []
                      [
                        Ty.associated_in_trait
                          "core::iter::traits::iterator::Iterator"
                          []
                          []
                          I
                          "Item"
                      ])
                ]
              |),
              [
                M.read (| self |);
                Value.StructTuple
                  "core::option::Option::None"
                  []
                  [ Ty.associated_in_trait "core::iter::traits::iterator::Iterator" [] [] I "Item" ]
                  [];
                M.get_associated_function (| Self, "some.last", [], [] |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (I A : Ty.t),
        M.IsTraitInstance
          "alloc::boxed::iter::BoxIter"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self I A)
          (* Instance *)
          [ ("Item", InstanceField.Ty (_Item I A)); ("last", InstanceField.Method (last I A)) ].
    End Impl_alloc_boxed_iter_BoxIter_where_core_iter_traits_iterator_Iterator_I_where_core_marker_Sized_I_where_core_alloc_Allocator_A_for_alloc_boxed_Box_I_A.
    
    Module Impl_alloc_boxed_iter_BoxIter_where_core_iter_traits_iterator_Iterator_I_where_core_alloc_Allocator_A_for_alloc_boxed_Box_I_A.
      Definition Self (I A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::boxed::Box") [] [ I; A ].
      
      (*
          fn last(self) -> Option<I::Item> {
              ( *self).last()
          }
      *)
      Definition last (I A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self I A in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "core::option::Option")
                []
                [ Ty.associated_in_trait "core::iter::traits::iterator::Iterator" [] [] I "Item" ],
              M.get_trait_method (|
                "core::iter::traits::iterator::Iterator",
                I,
                [],
                [],
                "last",
                [],
                []
              |),
              [ M.read (| M.deref (| M.read (| self |) |) |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (I A : Ty.t),
        M.IsTraitInstance
          "alloc::boxed::iter::BoxIter"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self I A)
          (* Instance *) [ ("last", InstanceField.Method (last I A)) ].
    End Impl_alloc_boxed_iter_BoxIter_where_core_iter_traits_iterator_Iterator_I_where_core_alloc_Allocator_A_for_alloc_boxed_Box_I_A.
    
    Module Impl_core_iter_traits_double_ended_DoubleEndedIterator_where_core_iter_traits_double_ended_DoubleEndedIterator_I_where_core_marker_Sized_I_where_core_alloc_Allocator_A_for_alloc_boxed_Box_I_A.
      Definition Self (I A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::boxed::Box") [] [ I; A ].
      
      (*
          fn next_back(&mut self) -> Option<I::Item> {
              ( **self).next_back()
          }
      *)
      Definition next_back (I A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self I A in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "core::option::Option")
                []
                [ Ty.associated_in_trait "core::iter::traits::iterator::Iterator" [] [] I "Item" ],
              M.get_trait_method (|
                "core::iter::traits::double_ended::DoubleEndedIterator",
                I,
                [],
                [],
                "next_back",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn nth_back(&mut self, n: usize) -> Option<I::Item> {
              ( **self).nth_back(n)
          }
      *)
      Definition nth_back (I A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self I A in
        match ε, τ, α with
        | [], [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "core::option::Option")
                []
                [ Ty.associated_in_trait "core::iter::traits::iterator::Iterator" [] [] I "Item" ],
              M.get_trait_method (|
                "core::iter::traits::double_ended::DoubleEndedIterator",
                I,
                [],
                [],
                "nth_back",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
                |);
                M.read (| n |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (I A : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::double_ended::DoubleEndedIterator"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self I A)
          (* Instance *)
          [
            ("next_back", InstanceField.Method (next_back I A));
            ("nth_back", InstanceField.Method (nth_back I A))
          ].
    End Impl_core_iter_traits_double_ended_DoubleEndedIterator_where_core_iter_traits_double_ended_DoubleEndedIterator_I_where_core_marker_Sized_I_where_core_alloc_Allocator_A_for_alloc_boxed_Box_I_A.
    
    Module Impl_core_iter_traits_exact_size_ExactSizeIterator_where_core_iter_traits_exact_size_ExactSizeIterator_I_where_core_marker_Sized_I_where_core_alloc_Allocator_A_for_alloc_boxed_Box_I_A.
      Definition Self (I A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::boxed::Box") [] [ I; A ].
      
      (*
          fn len(&self) -> usize {
              ( **self).len()
          }
      *)
      Definition len (I A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self I A in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "usize",
              M.get_trait_method (|
                "core::iter::traits::exact_size::ExactSizeIterator",
                I,
                [],
                [],
                "len",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn is_empty(&self) -> bool {
              ( **self).is_empty()
          }
      *)
      Definition is_empty (I A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self I A in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "bool",
              M.get_trait_method (|
                "core::iter::traits::exact_size::ExactSizeIterator",
                I,
                [],
                [],
                "is_empty",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (I A : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::exact_size::ExactSizeIterator"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self I A)
          (* Instance *)
          [
            ("len", InstanceField.Method (len I A));
            ("is_empty", InstanceField.Method (is_empty I A))
          ].
    End Impl_core_iter_traits_exact_size_ExactSizeIterator_where_core_iter_traits_exact_size_ExactSizeIterator_I_where_core_marker_Sized_I_where_core_alloc_Allocator_A_for_alloc_boxed_Box_I_A.
    
    Module Impl_core_iter_traits_marker_FusedIterator_where_core_iter_traits_marker_FusedIterator_I_where_core_marker_Sized_I_where_core_alloc_Allocator_A_for_alloc_boxed_Box_I_A.
      Definition Self (I A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::boxed::Box") [] [ I; A ].
      
      Axiom Implements :
        forall (I A : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::marker::FusedIterator"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self I A)
          (* Instance *) [].
    End Impl_core_iter_traits_marker_FusedIterator_where_core_iter_traits_marker_FusedIterator_I_where_core_marker_Sized_I_where_core_alloc_Allocator_A_for_alloc_boxed_Box_I_A.
    
    Module Impl_core_async_iter_async_iter_AsyncIterator_where_core_marker_Sized_S_where_core_async_iter_async_iter_AsyncIterator_S_where_core_marker_Unpin_S_for_alloc_boxed_Box_S_alloc_alloc_Global.
      Definition Self (S : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "alloc::boxed::Box") [] [ S; Ty.path "alloc::alloc::Global" ].
      
      (*     type Item = S::Item; *)
      Definition _Item (S : Ty.t) : Ty.t :=
        Ty.associated_in_trait "core::async_iter::async_iter::AsyncIterator" [] [] S "Item".
      
      (*
          fn poll_next(mut self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Option<Self::Item>> {
              Pin::new(&mut **self).poll_next(cx)
          }
      *)
      Definition poll_next (S : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self S in
        match ε, τ, α with
        | [], [], [ self; cx ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let cx := M.alloc (| cx |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "core::task::poll::Poll")
                []
                [
                  Ty.apply
                    (Ty.path "core::option::Option")
                    []
                    [
                      Ty.associated_in_trait
                        "core::async_iter::async_iter::AsyncIterator"
                        []
                        []
                        S
                        "Item"
                    ]
                ],
              M.get_trait_method (|
                "core::async_iter::async_iter::AsyncIterator",
                S,
                [],
                [],
                "poll_next",
                [],
                []
              |),
              [
                M.call_closure (|
                  Ty.apply (Ty.path "core::pin::Pin") [] [ Ty.apply (Ty.path "&mut") [] [ S ] ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::pin::Pin") [] [ Ty.apply (Ty.path "&mut") [] [ S ] ],
                    "new",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.MutRef,
                      M.deref (|
                        M.read (|
                          M.deref (|
                            M.call_closure (|
                              Ty.apply
                                (Ty.path "&mut")
                                []
                                [
                                  Ty.apply
                                    (Ty.path "alloc::boxed::Box")
                                    []
                                    [ S; Ty.path "alloc::alloc::Global" ]
                                ],
                              M.get_trait_method (|
                                "core::ops::deref::DerefMut",
                                Ty.apply
                                  (Ty.path "core::pin::Pin")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "&mut")
                                      []
                                      [
                                        Ty.apply
                                          (Ty.path "alloc::boxed::Box")
                                          []
                                          [ S; Ty.path "alloc::alloc::Global" ]
                                      ]
                                  ],
                                [],
                                [],
                                "deref_mut",
                                [],
                                []
                              |),
                              [ M.borrow (| Pointer.Kind.MutRef, self |) ]
                            |)
                          |)
                        |)
                      |)
                    |)
                  ]
                |);
                M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| cx |) |) |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn size_hint(&self) -> (usize, Option<usize>) {
              ( **self).size_hint()
          }
      *)
      Definition size_hint (S : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self S in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.tuple
                [ Ty.path "usize"; Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "usize" ]
                ],
              M.get_trait_method (|
                "core::async_iter::async_iter::AsyncIterator",
                S,
                [],
                [],
                "size_hint",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (S : Ty.t),
        M.IsTraitInstance
          "core::async_iter::async_iter::AsyncIterator"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self S)
          (* Instance *)
          [
            ("Item", InstanceField.Ty (_Item S));
            ("poll_next", InstanceField.Method (poll_next S));
            ("size_hint", InstanceField.Method (size_hint S))
          ].
    End Impl_core_async_iter_async_iter_AsyncIterator_where_core_marker_Sized_S_where_core_async_iter_async_iter_AsyncIterator_S_where_core_marker_Unpin_S_for_alloc_boxed_Box_S_alloc_alloc_Global.
    
    Module Impl_core_iter_traits_iterator_Iterator_where_core_alloc_Allocator_A_for_alloc_boxed_Box_slice_I_A.
      Definition Self (I A : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "alloc::boxed::Box") [] [ Ty.apply (Ty.path "slice") [] [ I ]; A ].
      
      Axiom Implements :
        forall (I A : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::iterator::Iterator"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self I A)
          (* Instance *) [].
    End Impl_core_iter_traits_iterator_Iterator_where_core_alloc_Allocator_A_for_alloc_boxed_Box_slice_I_A.
    
    Module Impl_core_iter_traits_iterator_Iterator_where_core_alloc_Allocator_A_for_ref__alloc_boxed_Box_slice_I_A.
      Definition Self (I A : Ty.t) : Ty.t :=
        Ty.apply
          (Ty.path "&")
          []
          [ Ty.apply (Ty.path "alloc::boxed::Box") [] [ Ty.apply (Ty.path "slice") [] [ I ]; A ] ].
      
      Axiom Implements :
        forall (I A : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::iterator::Iterator"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self I A)
          (* Instance *) [].
    End Impl_core_iter_traits_iterator_Iterator_where_core_alloc_Allocator_A_for_ref__alloc_boxed_Box_slice_I_A.
    
    Module Impl_core_iter_traits_iterator_Iterator_where_core_alloc_Allocator_A_for_ref_mut_alloc_boxed_Box_slice_I_A.
      Definition Self (I A : Ty.t) : Ty.t :=
        Ty.apply
          (Ty.path "&mut")
          []
          [ Ty.apply (Ty.path "alloc::boxed::Box") [] [ Ty.apply (Ty.path "slice") [] [ I ]; A ] ].
      
      Axiom Implements :
        forall (I A : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::iterator::Iterator"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self I A)
          (* Instance *) [].
    End Impl_core_iter_traits_iterator_Iterator_where_core_alloc_Allocator_A_for_ref_mut_alloc_boxed_Box_slice_I_A.
    
    Module Impl_core_iter_traits_collect_IntoIterator_where_core_alloc_Allocator_A_for_alloc_boxed_Box_slice_I_A.
      Definition Self (I A : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "alloc::boxed::Box") [] [ Ty.apply (Ty.path "slice") [] [ I ]; A ].
      
      (*     type IntoIter = vec::IntoIter<I, A>; *)
      Definition _IntoIter (I A : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "alloc::vec::into_iter::IntoIter") [] [ I; A ].
      
      (*     type Item = I; *)
      Definition _Item (I A : Ty.t) : Ty.t := I.
      
      (*
          fn into_iter(self) -> vec::IntoIter<I, A> {
              self.into_vec().into_iter()
          }
      *)
      Definition into_iter (I A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self I A in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.apply (Ty.path "alloc::vec::into_iter::IntoIter") [] [ I; A ],
              M.get_trait_method (|
                "core::iter::traits::collect::IntoIterator",
                Ty.apply (Ty.path "alloc::vec::Vec") [] [ I; A ],
                [],
                [],
                "into_iter",
                [],
                []
              |),
              [
                M.call_closure (|
                  Ty.apply (Ty.path "alloc::vec::Vec") [] [ I; A ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "slice") [] [ I ],
                    "into_vec",
                    [],
                    [ A ]
                  |),
                  [ M.read (| self |) ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (I A : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::collect::IntoIterator"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self I A)
          (* Instance *)
          [
            ("IntoIter", InstanceField.Ty (_IntoIter I A));
            ("Item", InstanceField.Ty (_Item I A));
            ("into_iter", InstanceField.Method (into_iter I A))
          ].
    End Impl_core_iter_traits_collect_IntoIterator_where_core_alloc_Allocator_A_for_alloc_boxed_Box_slice_I_A.
    
    Module Impl_core_iter_traits_collect_IntoIterator_where_core_alloc_Allocator_A_for_ref__alloc_boxed_Box_slice_I_A.
      Definition Self (I A : Ty.t) : Ty.t :=
        Ty.apply
          (Ty.path "&")
          []
          [ Ty.apply (Ty.path "alloc::boxed::Box") [] [ Ty.apply (Ty.path "slice") [] [ I ]; A ] ].
      
      (*     type IntoIter = slice::Iter<'a, I>; *)
      Definition _IntoIter (I A : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::Iter") [] [ I ].
      
      (*     type Item = &'a I; *)
      Definition _Item (I A : Ty.t) : Ty.t := Ty.apply (Ty.path "&") [] [ I ].
      
      (*
          fn into_iter(self) -> slice::Iter<'a, I> {
              self.iter()
          }
      *)
      Definition into_iter (I A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self I A in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.apply (Ty.path "core::slice::iter::Iter") [] [ I ],
              M.get_associated_function (| Ty.apply (Ty.path "slice") [] [ I ], "iter", [], [] |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (I A : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::collect::IntoIterator"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self I A)
          (* Instance *)
          [
            ("IntoIter", InstanceField.Ty (_IntoIter I A));
            ("Item", InstanceField.Ty (_Item I A));
            ("into_iter", InstanceField.Method (into_iter I A))
          ].
    End Impl_core_iter_traits_collect_IntoIterator_where_core_alloc_Allocator_A_for_ref__alloc_boxed_Box_slice_I_A.
    
    Module Impl_core_iter_traits_collect_IntoIterator_where_core_alloc_Allocator_A_for_ref_mut_alloc_boxed_Box_slice_I_A.
      Definition Self (I A : Ty.t) : Ty.t :=
        Ty.apply
          (Ty.path "&mut")
          []
          [ Ty.apply (Ty.path "alloc::boxed::Box") [] [ Ty.apply (Ty.path "slice") [] [ I ]; A ] ].
      
      (*     type IntoIter = slice::IterMut<'a, I>; *)
      Definition _IntoIter (I A : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::slice::iter::IterMut") [] [ I ].
      
      (*     type Item = &'a mut I; *)
      Definition _Item (I A : Ty.t) : Ty.t := Ty.apply (Ty.path "&mut") [] [ I ].
      
      (*
          fn into_iter(self) -> slice::IterMut<'a, I> {
              self.iter_mut()
          }
      *)
      Definition into_iter (I A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self I A in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.apply (Ty.path "core::slice::iter::IterMut") [] [ I ],
              M.get_associated_function (|
                Ty.apply (Ty.path "slice") [] [ I ],
                "iter_mut",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (I A : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::collect::IntoIterator"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self I A)
          (* Instance *)
          [
            ("IntoIter", InstanceField.Ty (_IntoIter I A));
            ("Item", InstanceField.Ty (_Item I A));
            ("into_iter", InstanceField.Method (into_iter I A))
          ].
    End Impl_core_iter_traits_collect_IntoIterator_where_core_alloc_Allocator_A_for_ref_mut_alloc_boxed_Box_slice_I_A.
    
    Module Impl_core_iter_traits_collect_FromIterator_I_for_alloc_boxed_Box_slice_I_alloc_alloc_Global.
      Definition Self (I : Ty.t) : Ty.t :=
        Ty.apply
          (Ty.path "alloc::boxed::Box")
          []
          [ Ty.apply (Ty.path "slice") [] [ I ]; Ty.path "alloc::alloc::Global" ].
      
      (*
          fn from_iter<T: IntoIterator<Item = I>>(iter: T) -> Self {
              iter.into_iter().collect::<Vec<_>>().into_boxed_slice()
          }
      *)
      Definition from_iter (I : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self I in
        match ε, τ, α with
        | [], [ T ], [ iter ] =>
          ltac:(M.monadic
            (let iter := M.alloc (| iter |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "alloc::boxed::Box")
                []
                [ Ty.apply (Ty.path "slice") [] [ I ]; Ty.path "alloc::alloc::Global" ],
              M.get_associated_function (|
                Ty.apply (Ty.path "alloc::vec::Vec") [] [ I; Ty.path "alloc::alloc::Global" ],
                "into_boxed_slice",
                [],
                []
              |),
              [
                M.call_closure (|
                  Ty.apply (Ty.path "alloc::vec::Vec") [] [ I; Ty.path "alloc::alloc::Global" ],
                  M.get_trait_method (|
                    "core::iter::traits::iterator::Iterator",
                    Ty.associated_in_trait
                      "core::iter::traits::collect::IntoIterator"
                      []
                      []
                      T
                      "IntoIter",
                    [],
                    [],
                    "collect",
                    [],
                    [ Ty.apply (Ty.path "alloc::vec::Vec") [] [ I; Ty.path "alloc::alloc::Global" ]
                    ]
                  |),
                  [
                    M.call_closure (|
                      Ty.associated_in_trait
                        "core::iter::traits::collect::IntoIterator"
                        []
                        []
                        T
                        "IntoIter",
                      M.get_trait_method (|
                        "core::iter::traits::collect::IntoIterator",
                        T,
                        [],
                        [],
                        "into_iter",
                        [],
                        []
                      |),
                      [ M.read (| iter |) ]
                    |)
                  ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (I : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::collect::FromIterator"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ I ]
          (Self I)
          (* Instance *) [ ("from_iter", InstanceField.Method (from_iter I)) ].
    End Impl_core_iter_traits_collect_FromIterator_I_for_alloc_boxed_Box_slice_I_alloc_alloc_Global.
    
    Module Impl_core_iter_traits_collect_FromIterator_char_for_alloc_boxed_Box_str_alloc_alloc_Global.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "alloc::boxed::Box") [] [ Ty.path "str"; Ty.path "alloc::alloc::Global" ].
      
      (*
          fn from_iter<T: IntoIterator<Item = char>>(iter: T) -> Self {
              String::from_iter(iter).into_boxed_str()
          }
      *)
      Definition from_iter (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [ T ], [ iter ] =>
          ltac:(M.monadic
            (let iter := M.alloc (| iter |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "alloc::boxed::Box")
                []
                [ Ty.path "str"; Ty.path "alloc::alloc::Global" ],
              M.get_associated_function (|
                Ty.path "alloc::string::String",
                "into_boxed_str",
                [],
                []
              |),
              [
                M.call_closure (|
                  Ty.path "alloc::string::String",
                  M.get_trait_method (|
                    "core::iter::traits::collect::FromIterator",
                    Ty.path "alloc::string::String",
                    [],
                    [ Ty.path "char" ],
                    "from_iter",
                    [],
                    [ T ]
                  |),
                  [ M.read (| iter |) ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::iter::traits::collect::FromIterator"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "char" ]
          Self
          (* Instance *) [ ("from_iter", InstanceField.Method from_iter) ].
    End Impl_core_iter_traits_collect_FromIterator_char_for_alloc_boxed_Box_str_alloc_alloc_Global.
    
    Module Impl_core_iter_traits_collect_FromIterator_ref__char_for_alloc_boxed_Box_str_alloc_alloc_Global.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "alloc::boxed::Box") [] [ Ty.path "str"; Ty.path "alloc::alloc::Global" ].
      
      (*
          fn from_iter<T: IntoIterator<Item = &'a char>>(iter: T) -> Self {
              String::from_iter(iter).into_boxed_str()
          }
      *)
      Definition from_iter (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [ T ], [ iter ] =>
          ltac:(M.monadic
            (let iter := M.alloc (| iter |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "alloc::boxed::Box")
                []
                [ Ty.path "str"; Ty.path "alloc::alloc::Global" ],
              M.get_associated_function (|
                Ty.path "alloc::string::String",
                "into_boxed_str",
                [],
                []
              |),
              [
                M.call_closure (|
                  Ty.path "alloc::string::String",
                  M.get_trait_method (|
                    "core::iter::traits::collect::FromIterator",
                    Ty.path "alloc::string::String",
                    [],
                    [ Ty.apply (Ty.path "&") [] [ Ty.path "char" ] ],
                    "from_iter",
                    [],
                    [ T ]
                  |),
                  [ M.read (| iter |) ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::iter::traits::collect::FromIterator"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.apply (Ty.path "&") [] [ Ty.path "char" ] ]
          Self
          (* Instance *) [ ("from_iter", InstanceField.Method from_iter) ].
    End Impl_core_iter_traits_collect_FromIterator_ref__char_for_alloc_boxed_Box_str_alloc_alloc_Global.
    
    Module Impl_core_iter_traits_collect_FromIterator_ref__str_for_alloc_boxed_Box_str_alloc_alloc_Global.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "alloc::boxed::Box") [] [ Ty.path "str"; Ty.path "alloc::alloc::Global" ].
      
      (*
          fn from_iter<T: IntoIterator<Item = &'a str>>(iter: T) -> Self {
              String::from_iter(iter).into_boxed_str()
          }
      *)
      Definition from_iter (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [ T ], [ iter ] =>
          ltac:(M.monadic
            (let iter := M.alloc (| iter |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "alloc::boxed::Box")
                []
                [ Ty.path "str"; Ty.path "alloc::alloc::Global" ],
              M.get_associated_function (|
                Ty.path "alloc::string::String",
                "into_boxed_str",
                [],
                []
              |),
              [
                M.call_closure (|
                  Ty.path "alloc::string::String",
                  M.get_trait_method (|
                    "core::iter::traits::collect::FromIterator",
                    Ty.path "alloc::string::String",
                    [],
                    [ Ty.apply (Ty.path "&") [] [ Ty.path "str" ] ],
                    "from_iter",
                    [],
                    [ T ]
                  |),
                  [ M.read (| iter |) ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::iter::traits::collect::FromIterator"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.apply (Ty.path "&") [] [ Ty.path "str" ] ]
          Self
          (* Instance *) [ ("from_iter", InstanceField.Method from_iter) ].
    End Impl_core_iter_traits_collect_FromIterator_ref__str_for_alloc_boxed_Box_str_alloc_alloc_Global.
    
    Module Impl_core_iter_traits_collect_FromIterator_alloc_string_String_for_alloc_boxed_Box_str_alloc_alloc_Global.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "alloc::boxed::Box") [] [ Ty.path "str"; Ty.path "alloc::alloc::Global" ].
      
      (*
          fn from_iter<T: IntoIterator<Item = String>>(iter: T) -> Self {
              String::from_iter(iter).into_boxed_str()
          }
      *)
      Definition from_iter (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [ T ], [ iter ] =>
          ltac:(M.monadic
            (let iter := M.alloc (| iter |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "alloc::boxed::Box")
                []
                [ Ty.path "str"; Ty.path "alloc::alloc::Global" ],
              M.get_associated_function (|
                Ty.path "alloc::string::String",
                "into_boxed_str",
                [],
                []
              |),
              [
                M.call_closure (|
                  Ty.path "alloc::string::String",
                  M.get_trait_method (|
                    "core::iter::traits::collect::FromIterator",
                    Ty.path "alloc::string::String",
                    [],
                    [ Ty.path "alloc::string::String" ],
                    "from_iter",
                    [],
                    [ T ]
                  |),
                  [ M.read (| iter |) ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::iter::traits::collect::FromIterator"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "alloc::string::String" ]
          Self
          (* Instance *) [ ("from_iter", InstanceField.Method from_iter) ].
    End Impl_core_iter_traits_collect_FromIterator_alloc_string_String_for_alloc_boxed_Box_str_alloc_alloc_Global.
    
    Module Impl_core_iter_traits_collect_FromIterator_where_core_alloc_Allocator_A_alloc_boxed_Box_str_A_for_alloc_boxed_Box_str_alloc_alloc_Global.
      Definition Self (A : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "alloc::boxed::Box") [] [ Ty.path "str"; Ty.path "alloc::alloc::Global" ].
      
      (*
          fn from_iter<T: IntoIterator<Item = Box<str, A>>>(iter: T) -> Self {
              String::from_iter(iter).into_boxed_str()
          }
      *)
      Definition from_iter (A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self A in
        match ε, τ, α with
        | [], [ T ], [ iter ] =>
          ltac:(M.monadic
            (let iter := M.alloc (| iter |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "alloc::boxed::Box")
                []
                [ Ty.path "str"; Ty.path "alloc::alloc::Global" ],
              M.get_associated_function (|
                Ty.path "alloc::string::String",
                "into_boxed_str",
                [],
                []
              |),
              [
                M.call_closure (|
                  Ty.path "alloc::string::String",
                  M.get_trait_method (|
                    "core::iter::traits::collect::FromIterator",
                    Ty.path "alloc::string::String",
                    [],
                    [ Ty.apply (Ty.path "alloc::boxed::Box") [] [ Ty.path "str"; A ] ],
                    "from_iter",
                    [],
                    [ T ]
                  |),
                  [ M.read (| iter |) ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (A : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::collect::FromIterator"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "alloc::boxed::Box") [] [ Ty.path "str"; A ] ]
          (Self A)
          (* Instance *) [ ("from_iter", InstanceField.Method (from_iter A)) ].
    End Impl_core_iter_traits_collect_FromIterator_where_core_alloc_Allocator_A_alloc_boxed_Box_str_A_for_alloc_boxed_Box_str_alloc_alloc_Global.
    
    Module Impl_core_iter_traits_collect_FromIterator_alloc_borrow_Cow_str_for_alloc_boxed_Box_str_alloc_alloc_Global.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "alloc::boxed::Box") [] [ Ty.path "str"; Ty.path "alloc::alloc::Global" ].
      
      (*
          fn from_iter<T: IntoIterator<Item = Cow<'a, str>>>(iter: T) -> Self {
              String::from_iter(iter).into_boxed_str()
          }
      *)
      Definition from_iter (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [ T ], [ iter ] =>
          ltac:(M.monadic
            (let iter := M.alloc (| iter |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "alloc::boxed::Box")
                []
                [ Ty.path "str"; Ty.path "alloc::alloc::Global" ],
              M.get_associated_function (|
                Ty.path "alloc::string::String",
                "into_boxed_str",
                [],
                []
              |),
              [
                M.call_closure (|
                  Ty.path "alloc::string::String",
                  M.get_trait_method (|
                    "core::iter::traits::collect::FromIterator",
                    Ty.path "alloc::string::String",
                    [],
                    [ Ty.apply (Ty.path "alloc::borrow::Cow") [] [ Ty.path "str" ] ],
                    "from_iter",
                    [],
                    [ T ]
                  |),
                  [ M.read (| iter |) ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::iter::traits::collect::FromIterator"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "alloc::borrow::Cow") [] [ Ty.path "str" ] ]
          Self
          (* Instance *) [ ("from_iter", InstanceField.Method from_iter) ].
    End Impl_core_iter_traits_collect_FromIterator_alloc_borrow_Cow_str_for_alloc_boxed_Box_str_alloc_alloc_Global.
  End iter.
End boxed.
