(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module collections.
  Module binary_heap.
    (* StructRecord
      {
        name := "BinaryHeap";
        ty_params := [ "T"; "A" ];
        fields := [ ("data", Ty.apply (Ty.path "alloc::vec::Vec") [ T; A ]) ];
      } *)
    
    (* StructRecord
      {
        name := "PeekMut";
        ty_params := [ "T"; "A" ];
        fields :=
          [
            ("heap",
              Ty.apply
                (Ty.path "&mut")
                [ Ty.apply (Ty.path "alloc::collections::binary_heap::BinaryHeap") [ T; A ] ]);
            ("original_len",
              Ty.apply
                (Ty.path "core::option::Option")
                [ Ty.path "core::num::nonzero::NonZeroUsize" ])
          ];
      } *)
    
    Module Impl_core_fmt_Debug_where_core_cmp_Ord_T_where_core_fmt_Debug_T_where_core_alloc_Allocator_A_for_alloc_collections_binary_heap_PeekMut_T_A.
      Definition Self (T A : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "alloc::collections::binary_heap::PeekMut") [ T; A ].
      
      (*
          fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
              f.debug_tuple("PeekMut").field(&self.heap.data[0]).finish()
          }
      *)
      Definition fmt (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "core::fmt::builders::DebugTuple",
                "finish",
                []
              |),
              [
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.path "core::fmt::builders::DebugTuple",
                    "field",
                    []
                  |),
                  [
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "debug_tuple",
                          []
                        |),
                        [ M.read (| f |); M.read (| Value.String "PeekMut" |) ]
                      |)
                    |);
                    (* Unsize *)
                    M.pointer_coercion
                      (M.call_closure (|
                        M.get_trait_method (|
                          "core::ops::index::Index",
                          Ty.apply (Ty.path "alloc::vec::Vec") [ T; A ],
                          [ Ty.path "usize" ],
                          "index",
                          []
                        |),
                        [
                          M.SubPointer.get_struct_record_field (|
                            M.read (|
                              M.SubPointer.get_struct_record_field (|
                                M.read (| self |),
                                "alloc::collections::binary_heap::PeekMut",
                                "heap"
                              |)
                            |),
                            "alloc::collections::binary_heap::BinaryHeap",
                            "data"
                          |);
                          Value.Integer 0
                        ]
                      |))
                  ]
                |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (T A : Ty.t),
        M.IsTraitInstance
          "core::fmt::Debug"
          (Self T A)
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method (fmt T A)) ].
    End Impl_core_fmt_Debug_where_core_cmp_Ord_T_where_core_fmt_Debug_T_where_core_alloc_Allocator_A_for_alloc_collections_binary_heap_PeekMut_T_A.
    
    Module Impl_core_ops_drop_Drop_where_core_cmp_Ord_T_where_core_alloc_Allocator_A_for_alloc_collections_binary_heap_PeekMut_T_A.
      Definition Self (T A : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "alloc::collections::binary_heap::PeekMut") [ T; A ].
      
      (*
          fn drop(&mut self) {
              if let Some(original_len) = self.original_len {
                  // SAFETY: That's how many elements were in the Vec at the time of
                  // the PeekMut::deref_mut call, and therefore also at the time of
                  // the BinaryHeap::peek_mut call. Since the PeekMut did not end up
                  // getting leaked, we are now undoing the leak amplification that
                  // the DerefMut prepared for.
                  unsafe { self.heap.data.set_len(original_len.get()) };
      
                  // SAFETY: PeekMut is only instantiated for non-empty heaps.
                  unsafe { self.heap.sift_down(0) };
              }
          }
      *)
      Definition drop (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.SubPointer.get_struct_record_field (|
                          M.read (| self |),
                          "alloc::collections::binary_heap::PeekMut",
                          "original_len"
                        |) in
                      let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::option::Option::Some",
                          0
                        |) in
                      let original_len := M.copy (| γ0_0 |) in
                      let~ _ :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply (Ty.path "alloc::vec::Vec") [ T; A ],
                              "set_len",
                              []
                            |),
                            [
                              M.SubPointer.get_struct_record_field (|
                                M.read (|
                                  M.SubPointer.get_struct_record_field (|
                                    M.read (| self |),
                                    "alloc::collections::binary_heap::PeekMut",
                                    "heap"
                                  |)
                                |),
                                "alloc::collections::binary_heap::BinaryHeap",
                                "data"
                              |);
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.path "core::num::nonzero::NonZeroUsize",
                                  "get",
                                  []
                                |),
                                [ M.read (| original_len |) ]
                              |)
                            ]
                          |)
                        |) in
                      let~ _ :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply
                                (Ty.path "alloc::collections::binary_heap::BinaryHeap")
                                [ T; A ],
                              "sift_down",
                              []
                            |),
                            [
                              M.read (|
                                M.SubPointer.get_struct_record_field (|
                                  M.read (| self |),
                                  "alloc::collections::binary_heap::PeekMut",
                                  "heap"
                                |)
                              |);
                              Value.Integer 0
                            ]
                          |)
                        |) in
                      M.alloc (| Value.Tuple [] |)));
                  fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (T A : Ty.t),
        M.IsTraitInstance
          "core::ops::drop::Drop"
          (Self T A)
          (* Trait polymorphic types *) []
          (* Instance *) [ ("drop", InstanceField.Method (drop T A)) ].
    End Impl_core_ops_drop_Drop_where_core_cmp_Ord_T_where_core_alloc_Allocator_A_for_alloc_collections_binary_heap_PeekMut_T_A.
    
    Module Impl_core_ops_deref_Deref_where_core_cmp_Ord_T_where_core_alloc_Allocator_A_for_alloc_collections_binary_heap_PeekMut_T_A.
      Definition Self (T A : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "alloc::collections::binary_heap::PeekMut") [ T; A ].
      
      (*     type Target = T; *)
      Definition _Target (T A : Ty.t) : Ty.t := T.
      
      (*
          fn deref(&self) -> &T {
              debug_assert!(!self.heap.is_empty());
              // SAFE: PeekMut is only instantiated for non-empty heaps
              unsafe { self.heap.data.get_unchecked(0) }
          }
      *)
      Definition deref (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              let~ _ :=
                M.match_operator (|
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.use (M.alloc (| Value.Bool true |)) in
                        let _ :=
                          M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        let~ _ :=
                          M.match_operator (|
                            M.alloc (| Value.Tuple [] |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ :=
                                    M.use
                                      (M.alloc (|
                                        UnOp.Pure.not
                                          (UnOp.Pure.not
                                            (M.call_closure (|
                                              M.get_associated_function (|
                                                Ty.apply
                                                  (Ty.path
                                                    "alloc::collections::binary_heap::BinaryHeap")
                                                  [ T; A ],
                                                "is_empty",
                                                []
                                              |),
                                              [
                                                M.read (|
                                                  M.SubPointer.get_struct_record_field (|
                                                    M.read (| self |),
                                                    "alloc::collections::binary_heap::PeekMut",
                                                    "heap"
                                                  |)
                                                |)
                                              ]
                                            |)))
                                      |)) in
                                  let _ :=
                                    M.is_constant_or_break_match (|
                                      M.read (| γ |),
                                      Value.Bool true
                                    |) in
                                  M.alloc (|
                                    M.never_to_any (|
                                      M.call_closure (|
                                        M.get_function (| "core::panicking::panic", [] |),
                                        [
                                          M.read (|
                                            Value.String "assertion failed: !self.heap.is_empty()"
                                          |)
                                        ]
                                      |)
                                    |)
                                  |)));
                              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                            ]
                          |) in
                        M.alloc (| Value.Tuple [] |)));
                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                  ]
                |) in
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "slice") [ T ],
                    "get_unchecked",
                    [ Ty.path "usize" ]
                  |),
                  [
                    M.call_closure (|
                      M.get_trait_method (|
                        "core::ops::deref::Deref",
                        Ty.apply (Ty.path "alloc::vec::Vec") [ T; A ],
                        [],
                        "deref",
                        []
                      |),
                      [
                        M.SubPointer.get_struct_record_field (|
                          M.read (|
                            M.SubPointer.get_struct_record_field (|
                              M.read (| self |),
                              "alloc::collections::binary_heap::PeekMut",
                              "heap"
                            |)
                          |),
                          "alloc::collections::binary_heap::BinaryHeap",
                          "data"
                        |)
                      ]
                    |);
                    Value.Integer 0
                  ]
                |)
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (T A : Ty.t),
        M.IsTraitInstance
          "core::ops::deref::Deref"
          (Self T A)
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("Target", InstanceField.Ty (_Target T A)); ("deref", InstanceField.Method (deref T A))
          ].
    End Impl_core_ops_deref_Deref_where_core_cmp_Ord_T_where_core_alloc_Allocator_A_for_alloc_collections_binary_heap_PeekMut_T_A.
    
    Module Impl_core_ops_deref_DerefMut_where_core_cmp_Ord_T_where_core_alloc_Allocator_A_for_alloc_collections_binary_heap_PeekMut_T_A.
      Definition Self (T A : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "alloc::collections::binary_heap::PeekMut") [ T; A ].
      
      (*
          fn deref_mut(&mut self) -> &mut T {
              debug_assert!(!self.heap.is_empty());
      
              let len = self.heap.len();
              if len > 1 {
                  // Here we preemptively leak all the rest of the underlying vector
                  // after the currently max element. If the caller mutates the &mut T
                  // we're about to give them, and then leaks the PeekMut, all these
                  // elements will remain leaked. If they don't leak the PeekMut, then
                  // either Drop or PeekMut::pop will un-leak the vector elements.
                  //
                  // This is technique is described throughout several other places in
                  // the standard library as "leak amplification".
                  unsafe {
                      // SAFETY: len > 1 so len != 0.
                      self.original_len = Some(NonZeroUsize::new_unchecked(len));
                      // SAFETY: len > 1 so all this does for now is leak elements,
                      // which is safe.
                      self.heap.data.set_len(1);
                  }
              }
      
              // SAFE: PeekMut is only instantiated for non-empty heaps
              unsafe { self.heap.data.get_unchecked_mut(0) }
          }
      *)
      Definition deref_mut (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              let~ _ :=
                M.match_operator (|
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.use (M.alloc (| Value.Bool true |)) in
                        let _ :=
                          M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        let~ _ :=
                          M.match_operator (|
                            M.alloc (| Value.Tuple [] |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ :=
                                    M.use
                                      (M.alloc (|
                                        UnOp.Pure.not
                                          (UnOp.Pure.not
                                            (M.call_closure (|
                                              M.get_associated_function (|
                                                Ty.apply
                                                  (Ty.path
                                                    "alloc::collections::binary_heap::BinaryHeap")
                                                  [ T; A ],
                                                "is_empty",
                                                []
                                              |),
                                              [
                                                M.read (|
                                                  M.SubPointer.get_struct_record_field (|
                                                    M.read (| self |),
                                                    "alloc::collections::binary_heap::PeekMut",
                                                    "heap"
                                                  |)
                                                |)
                                              ]
                                            |)))
                                      |)) in
                                  let _ :=
                                    M.is_constant_or_break_match (|
                                      M.read (| γ |),
                                      Value.Bool true
                                    |) in
                                  M.alloc (|
                                    M.never_to_any (|
                                      M.call_closure (|
                                        M.get_function (| "core::panicking::panic", [] |),
                                        [
                                          M.read (|
                                            Value.String "assertion failed: !self.heap.is_empty()"
                                          |)
                                        ]
                                      |)
                                    |)
                                  |)));
                              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                            ]
                          |) in
                        M.alloc (| Value.Tuple [] |)));
                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                  ]
                |) in
              let~ len :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply (Ty.path "alloc::collections::binary_heap::BinaryHeap") [ T; A ],
                      "len",
                      []
                    |),
                    [
                      M.read (|
                        M.SubPointer.get_struct_record_field (|
                          M.read (| self |),
                          "alloc::collections::binary_heap::PeekMut",
                          "heap"
                        |)
                      |)
                    ]
                  |)
                |) in
              let~ _ :=
                M.match_operator (|
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ :=
                          M.use
                            (M.alloc (| BinOp.Pure.gt (M.read (| len |)) (Value.Integer 1) |)) in
                        let _ :=
                          M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        let~ _ :=
                          M.write (|
                            M.SubPointer.get_struct_record_field (|
                              M.read (| self |),
                              "alloc::collections::binary_heap::PeekMut",
                              "original_len"
                            |),
                            Value.StructTuple
                              "core::option::Option::Some"
                              [
                                M.call_closure (|
                                  M.get_associated_function (|
                                    Ty.path "core::num::nonzero::NonZeroUsize",
                                    "new_unchecked",
                                    []
                                  |),
                                  [ M.read (| len |) ]
                                |)
                              ]
                          |) in
                        let~ _ :=
                          M.alloc (|
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply (Ty.path "alloc::vec::Vec") [ T; A ],
                                "set_len",
                                []
                              |),
                              [
                                M.SubPointer.get_struct_record_field (|
                                  M.read (|
                                    M.SubPointer.get_struct_record_field (|
                                      M.read (| self |),
                                      "alloc::collections::binary_heap::PeekMut",
                                      "heap"
                                    |)
                                  |),
                                  "alloc::collections::binary_heap::BinaryHeap",
                                  "data"
                                |);
                                Value.Integer 1
                              ]
                            |)
                          |) in
                        M.alloc (| Value.Tuple [] |)));
                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                  ]
                |) in
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "slice") [ T ],
                    "get_unchecked_mut",
                    [ Ty.path "usize" ]
                  |),
                  [
                    M.call_closure (|
                      M.get_trait_method (|
                        "core::ops::deref::DerefMut",
                        Ty.apply (Ty.path "alloc::vec::Vec") [ T; A ],
                        [],
                        "deref_mut",
                        []
                      |),
                      [
                        M.SubPointer.get_struct_record_field (|
                          M.read (|
                            M.SubPointer.get_struct_record_field (|
                              M.read (| self |),
                              "alloc::collections::binary_heap::PeekMut",
                              "heap"
                            |)
                          |),
                          "alloc::collections::binary_heap::BinaryHeap",
                          "data"
                        |)
                      ]
                    |);
                    Value.Integer 0
                  ]
                |)
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (T A : Ty.t),
        M.IsTraitInstance
          "core::ops::deref::DerefMut"
          (Self T A)
          (* Trait polymorphic types *) []
          (* Instance *) [ ("deref_mut", InstanceField.Method (deref_mut T A)) ].
    End Impl_core_ops_deref_DerefMut_where_core_cmp_Ord_T_where_core_alloc_Allocator_A_for_alloc_collections_binary_heap_PeekMut_T_A.
    
    Module Impl_alloc_collections_binary_heap_PeekMut_T_A.
      Definition Self (T A : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "alloc::collections::binary_heap::PeekMut") [ T; A ].
      
      (*
          pub fn pop(mut this: PeekMut<'a, T, A>) -> T {
              if let Some(original_len) = this.original_len.take() {
                  // SAFETY: This is how many elements were in the Vec at the time of
                  // the BinaryHeap::peek_mut call.
                  unsafe { this.heap.data.set_len(original_len.get()) };
      
                  // Unlike in Drop, here we don't also need to do a sift_down even if
                  // the caller could've mutated the element. It is removed from the
                  // heap on the next line and pop() is not sensitive to its value.
              }
              this.heap.pop().unwrap()
          }
      *)
      Definition pop (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match τ, α with
        | [], [ this ] =>
          ltac:(M.monadic
            (let this := M.alloc (| this |) in
            M.read (|
              let~ _ :=
                M.match_operator (|
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ :=
                          M.alloc (|
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "core::option::Option")
                                  [ Ty.path "core::num::nonzero::NonZeroUsize" ],
                                "take",
                                []
                              |),
                              [
                                M.SubPointer.get_struct_record_field (|
                                  this,
                                  "alloc::collections::binary_heap::PeekMut",
                                  "original_len"
                                |)
                              ]
                            |)
                          |) in
                        let γ0_0 :=
                          M.SubPointer.get_struct_tuple_field (|
                            γ,
                            "core::option::Option::Some",
                            0
                          |) in
                        let original_len := M.copy (| γ0_0 |) in
                        let~ _ :=
                          M.alloc (|
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply (Ty.path "alloc::vec::Vec") [ T; A ],
                                "set_len",
                                []
                              |),
                              [
                                M.SubPointer.get_struct_record_field (|
                                  M.read (|
                                    M.SubPointer.get_struct_record_field (|
                                      this,
                                      "alloc::collections::binary_heap::PeekMut",
                                      "heap"
                                    |)
                                  |),
                                  "alloc::collections::binary_heap::BinaryHeap",
                                  "data"
                                |);
                                M.call_closure (|
                                  M.get_associated_function (|
                                    Ty.path "core::num::nonzero::NonZeroUsize",
                                    "get",
                                    []
                                  |),
                                  [ M.read (| original_len |) ]
                                |)
                              ]
                            |)
                          |) in
                        M.alloc (| Value.Tuple [] |)));
                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                  ]
                |) in
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::option::Option") [ T ],
                    "unwrap",
                    []
                  |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "alloc::collections::binary_heap::BinaryHeap") [ T; A ],
                        "pop",
                        []
                      |),
                      [
                        M.read (|
                          M.SubPointer.get_struct_record_field (|
                            this,
                            "alloc::collections::binary_heap::PeekMut",
                            "heap"
                          |)
                        |)
                      ]
                    |)
                  ]
                |)
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_pop :
        forall (T A : Ty.t),
        M.IsAssociatedFunction (Self T A) "pop" (pop T A).
    End Impl_alloc_collections_binary_heap_PeekMut_T_A.
    
    Module Impl_core_clone_Clone_where_core_clone_Clone_T_where_core_alloc_Allocator_A_where_core_clone_Clone_A_for_alloc_collections_binary_heap_BinaryHeap_T_A.
      Definition Self (T A : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "alloc::collections::binary_heap::BinaryHeap") [ T; A ].
      
      (*
          fn clone(&self) -> Self {
              BinaryHeap { data: self.data.clone() }
          }
      *)
      Definition clone (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructRecord
              "alloc::collections::binary_heap::BinaryHeap"
              [
                ("data",
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::clone::Clone",
                      Ty.apply (Ty.path "alloc::vec::Vec") [ T; A ],
                      [],
                      "clone",
                      []
                    |),
                    [
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "alloc::collections::binary_heap::BinaryHeap",
                        "data"
                      |)
                    ]
                  |))
              ]))
        | _, _ => M.impossible
        end.
      
      (*
          fn clone_from(&mut self, source: &Self) {
              self.data.clone_from(&source.data);
          }
      *)
      Definition clone_from (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match τ, α with
        | [], [ self; source ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let source := M.alloc (| source |) in
            M.read (|
              let~ _ :=
                M.alloc (|
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::clone::Clone",
                      Ty.apply (Ty.path "alloc::vec::Vec") [ T; A ],
                      [],
                      "clone_from",
                      []
                    |),
                    [
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "alloc::collections::binary_heap::BinaryHeap",
                        "data"
                      |);
                      M.SubPointer.get_struct_record_field (|
                        M.read (| source |),
                        "alloc::collections::binary_heap::BinaryHeap",
                        "data"
                      |)
                    ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (T A : Ty.t),
        M.IsTraitInstance
          "core::clone::Clone"
          (Self T A)
          (* Trait polymorphic types *) []
          (* Instance *)
          [
            ("clone", InstanceField.Method (clone T A));
            ("clone_from", InstanceField.Method (clone_from T A))
          ].
    End Impl_core_clone_Clone_where_core_clone_Clone_T_where_core_alloc_Allocator_A_where_core_clone_Clone_A_for_alloc_collections_binary_heap_BinaryHeap_T_A.
    
    Module Impl_core_default_Default_where_core_cmp_Ord_T_for_alloc_collections_binary_heap_BinaryHeap_T_alloc_alloc_Global.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply
          (Ty.path "alloc::collections::binary_heap::BinaryHeap")
          [ T; Ty.path "alloc::alloc::Global" ].
      
      (*
          fn default() -> BinaryHeap<T> {
              BinaryHeap::new()
          }
      *)
      Definition default (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [] =>
          ltac:(M.monadic
            (M.call_closure (|
              M.get_associated_function (|
                Ty.apply
                  (Ty.path "alloc::collections::binary_heap::BinaryHeap")
                  [ T; Ty.path "alloc::alloc::Global" ],
                "new",
                []
              |),
              []
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::default::Default"
          (Self T)
          (* Trait polymorphic types *) []
          (* Instance *) [ ("default", InstanceField.Method (default T)) ].
    End Impl_core_default_Default_where_core_cmp_Ord_T_for_alloc_collections_binary_heap_BinaryHeap_T_alloc_alloc_Global.
    
    Module Impl_core_fmt_Debug_where_core_fmt_Debug_T_where_core_alloc_Allocator_A_for_alloc_collections_binary_heap_BinaryHeap_T_A.
      Definition Self (T A : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "alloc::collections::binary_heap::BinaryHeap") [ T; A ].
      
      (*
          fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
              f.debug_list().entries(self.iter()).finish()
          }
      *)
      Definition fmt (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "core::fmt::builders::DebugList",
                "finish",
                []
              |),
              [
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.path "core::fmt::builders::DebugList",
                    "entries",
                    [
                      Ty.apply (Ty.path "&") [ T ];
                      Ty.apply (Ty.path "alloc::collections::binary_heap::Iter") [ T ]
                    ]
                  |),
                  [
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "debug_list",
                          []
                        |),
                        [ M.read (| f |) ]
                      |)
                    |);
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "alloc::collections::binary_heap::BinaryHeap") [ T; A ],
                        "iter",
                        []
                      |),
                      [ M.read (| self |) ]
                    |)
                  ]
                |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (T A : Ty.t),
        M.IsTraitInstance
          "core::fmt::Debug"
          (Self T A)
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method (fmt T A)) ].
    End Impl_core_fmt_Debug_where_core_fmt_Debug_T_where_core_alloc_Allocator_A_for_alloc_collections_binary_heap_BinaryHeap_T_A.
    
    (* StructRecord
      {
        name := "RebuildOnDrop";
        ty_params := [ "T"; "A" ];
        fields :=
          [
            ("heap",
              Ty.apply
                (Ty.path "&mut")
                [ Ty.apply (Ty.path "alloc::collections::binary_heap::BinaryHeap") [ T; A ] ]);
            ("rebuild_from", Ty.path "usize")
          ];
      } *)
    
    Module Impl_core_ops_drop_Drop_where_core_cmp_Ord_T_where_core_alloc_Allocator_A_for_alloc_collections_binary_heap_RebuildOnDrop_T_A.
      Definition Self (T A : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "alloc::collections::binary_heap::RebuildOnDrop") [ T; A ].
      
      (*
          fn drop(&mut self) {
              self.heap.rebuild_tail(self.rebuild_from);
          }
      *)
      Definition drop (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              let~ _ :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply (Ty.path "alloc::collections::binary_heap::BinaryHeap") [ T; A ],
                      "rebuild_tail",
                      []
                    |),
                    [
                      M.read (|
                        M.SubPointer.get_struct_record_field (|
                          M.read (| self |),
                          "alloc::collections::binary_heap::RebuildOnDrop",
                          "heap"
                        |)
                      |);
                      M.read (|
                        M.SubPointer.get_struct_record_field (|
                          M.read (| self |),
                          "alloc::collections::binary_heap::RebuildOnDrop",
                          "rebuild_from"
                        |)
                      |)
                    ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (T A : Ty.t),
        M.IsTraitInstance
          "core::ops::drop::Drop"
          (Self T A)
          (* Trait polymorphic types *) []
          (* Instance *) [ ("drop", InstanceField.Method (drop T A)) ].
    End Impl_core_ops_drop_Drop_where_core_cmp_Ord_T_where_core_alloc_Allocator_A_for_alloc_collections_binary_heap_RebuildOnDrop_T_A.
    
    Module Impl_alloc_collections_binary_heap_BinaryHeap_T_alloc_alloc_Global.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply
          (Ty.path "alloc::collections::binary_heap::BinaryHeap")
          [ T; Ty.path "alloc::alloc::Global" ].
      
      (*
          pub const fn new() -> BinaryHeap<T> {
              BinaryHeap { data: vec![] }
          }
      *)
      Definition new (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [] =>
          ltac:(M.monadic
            (Value.StructRecord
              "alloc::collections::binary_heap::BinaryHeap"
              [
                ("data",
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply (Ty.path "alloc::vec::Vec") [ T; Ty.path "alloc::alloc::Global" ],
                      "new",
                      []
                    |),
                    []
                  |))
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_new :
        forall (T : Ty.t),
        M.IsAssociatedFunction (Self T) "new" (new T).
      
      (*
          pub fn with_capacity(capacity: usize) -> BinaryHeap<T> {
              BinaryHeap { data: Vec::with_capacity(capacity) }
          }
      *)
      Definition with_capacity (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ capacity ] =>
          ltac:(M.monadic
            (let capacity := M.alloc (| capacity |) in
            Value.StructRecord
              "alloc::collections::binary_heap::BinaryHeap"
              [
                ("data",
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply (Ty.path "alloc::vec::Vec") [ T; Ty.path "alloc::alloc::Global" ],
                      "with_capacity",
                      []
                    |),
                    [ M.read (| capacity |) ]
                  |))
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_with_capacity :
        forall (T : Ty.t),
        M.IsAssociatedFunction (Self T) "with_capacity" (with_capacity T).
    End Impl_alloc_collections_binary_heap_BinaryHeap_T_alloc_alloc_Global.
    
    Module Impl_alloc_collections_binary_heap_BinaryHeap_T_A.
      Definition Self (T A : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "alloc::collections::binary_heap::BinaryHeap") [ T; A ].
      
      (*
          pub const fn new_in(alloc: A) -> BinaryHeap<T, A> {
              BinaryHeap { data: Vec::new_in(alloc) }
          }
      *)
      Definition new_in (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match τ, α with
        | [], [ alloc ] =>
          ltac:(M.monadic
            (let alloc := M.alloc (| alloc |) in
            Value.StructRecord
              "alloc::collections::binary_heap::BinaryHeap"
              [
                ("data",
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply (Ty.path "alloc::vec::Vec") [ T; A ],
                      "new_in",
                      []
                    |),
                    [ M.read (| alloc |) ]
                  |))
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_new_in :
        forall (T A : Ty.t),
        M.IsAssociatedFunction (Self T A) "new_in" (new_in T A).
      
      (*
          pub fn with_capacity_in(capacity: usize, alloc: A) -> BinaryHeap<T, A> {
              BinaryHeap { data: Vec::with_capacity_in(capacity, alloc) }
          }
      *)
      Definition with_capacity_in (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match τ, α with
        | [], [ capacity; alloc ] =>
          ltac:(M.monadic
            (let capacity := M.alloc (| capacity |) in
            let alloc := M.alloc (| alloc |) in
            Value.StructRecord
              "alloc::collections::binary_heap::BinaryHeap"
              [
                ("data",
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply (Ty.path "alloc::vec::Vec") [ T; A ],
                      "with_capacity_in",
                      []
                    |),
                    [ M.read (| capacity |); M.read (| alloc |) ]
                  |))
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_with_capacity_in :
        forall (T A : Ty.t),
        M.IsAssociatedFunction (Self T A) "with_capacity_in" (with_capacity_in T A).
      
      (*
          pub fn peek_mut(&mut self) -> Option<PeekMut<'_, T, A>> {
              if self.is_empty() { None } else { Some(PeekMut { heap: self, original_len: None }) }
          }
      *)
      Definition peek_mut (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "alloc::collections::binary_heap::BinaryHeap")
                                  [ T; A ],
                                "is_empty",
                                []
                              |),
                              [ M.read (| self |) ]
                            |)
                          |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (|
                        Value.StructTuple
                          "core::option::Option::Some"
                          [
                            Value.StructRecord
                              "alloc::collections::binary_heap::PeekMut"
                              [
                                ("heap", M.read (| self |));
                                ("original_len", Value.StructTuple "core::option::Option::None" [])
                              ]
                          ]
                      |)))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_peek_mut :
        forall (T A : Ty.t),
        M.IsAssociatedFunction (Self T A) "peek_mut" (peek_mut T A).
      
      (*
          pub fn pop(&mut self) -> Option<T> {
              self.data.pop().map(|mut item| {
                  if !self.is_empty() {
                      swap(&mut item, &mut self.data[0]);
                      // SAFETY: !self.is_empty() means that self.len() > 0
                      unsafe { self.sift_down_to_bottom(0) };
                  }
                  item
              })
          }
      *)
      Definition pop (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply (Ty.path "core::option::Option") [ T ],
                "map",
                [ T; Ty.function [ Ty.tuple [ T ] ] T ]
              |),
              [
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "alloc::vec::Vec") [ T; A ],
                    "pop",
                    []
                  |),
                  [
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "alloc::collections::binary_heap::BinaryHeap",
                      "data"
                    |)
                  ]
                |);
                M.closure
                  (fun γ =>
                    ltac:(M.monadic
                      match γ with
                      | [ α0 ] =>
                        M.match_operator (|
                          M.alloc (| α0 |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let item := M.copy (| γ |) in
                                M.read (|
                                  let~ _ :=
                                    M.match_operator (|
                                      M.alloc (| Value.Tuple [] |),
                                      [
                                        fun γ =>
                                          ltac:(M.monadic
                                            (let γ :=
                                              M.use
                                                (M.alloc (|
                                                  UnOp.Pure.not
                                                    (M.call_closure (|
                                                      M.get_associated_function (|
                                                        Ty.apply
                                                          (Ty.path
                                                            "alloc::collections::binary_heap::BinaryHeap")
                                                          [ T; A ],
                                                        "is_empty",
                                                        []
                                                      |),
                                                      [ M.read (| self |) ]
                                                    |))
                                                |)) in
                                            let _ :=
                                              M.is_constant_or_break_match (|
                                                M.read (| γ |),
                                                Value.Bool true
                                              |) in
                                            let~ _ :=
                                              M.alloc (|
                                                M.call_closure (|
                                                  M.get_function (| "core::mem::swap", [ T ] |),
                                                  [
                                                    item;
                                                    M.call_closure (|
                                                      M.get_trait_method (|
                                                        "core::ops::index::IndexMut",
                                                        Ty.apply
                                                          (Ty.path "alloc::vec::Vec")
                                                          [ T; A ],
                                                        [ Ty.path "usize" ],
                                                        "index_mut",
                                                        []
                                                      |),
                                                      [
                                                        M.SubPointer.get_struct_record_field (|
                                                          M.read (| self |),
                                                          "alloc::collections::binary_heap::BinaryHeap",
                                                          "data"
                                                        |);
                                                        Value.Integer 0
                                                      ]
                                                    |)
                                                  ]
                                                |)
                                              |) in
                                            let~ _ :=
                                              M.alloc (|
                                                M.call_closure (|
                                                  M.get_associated_function (|
                                                    Ty.apply
                                                      (Ty.path
                                                        "alloc::collections::binary_heap::BinaryHeap")
                                                      [ T; A ],
                                                    "sift_down_to_bottom",
                                                    []
                                                  |),
                                                  [ M.read (| self |); Value.Integer 0 ]
                                                |)
                                              |) in
                                            M.alloc (| Value.Tuple [] |)));
                                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                                      ]
                                    |) in
                                  item
                                |)))
                          ]
                        |)
                      | _ => M.impossible (||)
                      end))
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_pop :
        forall (T A : Ty.t),
        M.IsAssociatedFunction (Self T A) "pop" (pop T A).
      
      (*
          pub fn push(&mut self, item: T) {
              let old_len = self.len();
              self.data.push(item);
              // SAFETY: Since we pushed a new item it means that
              //  old_len = self.len() - 1 < self.len()
              unsafe { self.sift_up(0, old_len) };
          }
      *)
      Definition push (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match τ, α with
        | [], [ self; item ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let item := M.alloc (| item |) in
            M.read (|
              let~ old_len :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply (Ty.path "alloc::collections::binary_heap::BinaryHeap") [ T; A ],
                      "len",
                      []
                    |),
                    [ M.read (| self |) ]
                  |)
                |) in
              let~ _ :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply (Ty.path "alloc::vec::Vec") [ T; A ],
                      "push",
                      []
                    |),
                    [
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "alloc::collections::binary_heap::BinaryHeap",
                        "data"
                      |);
                      M.read (| item |)
                    ]
                  |)
                |) in
              let~ _ :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply (Ty.path "alloc::collections::binary_heap::BinaryHeap") [ T; A ],
                      "sift_up",
                      []
                    |),
                    [ M.read (| self |); Value.Integer 0; M.read (| old_len |) ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_push :
        forall (T A : Ty.t),
        M.IsAssociatedFunction (Self T A) "push" (push T A).
      
      (*
          pub fn into_sorted_vec(mut self) -> Vec<T, A> {
              let mut end = self.len();
              while end > 1 {
                  end -= 1;
                  // SAFETY: `end` goes from `self.len() - 1` to 1 (both included),
                  //  so it's always a valid index to access.
                  //  It is safe to access index 0 (i.e. `ptr`), because
                  //  1 <= end < self.len(), which means self.len() >= 2.
                  unsafe {
                      let ptr = self.data.as_mut_ptr();
                      ptr::swap(ptr, ptr.add(end));
                  }
                  // SAFETY: `end` goes from `self.len() - 1` to 1 (both included) so:
                  //  0 < 1 <= end <= self.len() - 1 < self.len()
                  //  Which means 0 < end and end < self.len().
                  unsafe { self.sift_down_range(0, end) };
              }
              self.into_vec()
          }
      *)
      Definition into_sorted_vec (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              let~ end_ :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply (Ty.path "alloc::collections::binary_heap::BinaryHeap") [ T; A ],
                      "len",
                      []
                    |),
                    [ self ]
                  |)
                |) in
              let~ _ :=
                M.loop (|
                  ltac:(M.monadic
                    (M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  BinOp.Pure.gt (M.read (| end_ |)) (Value.Integer 1)
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            let~ _ :=
                              let β := end_ in
                              M.write (|
                                β,
                                BinOp.Wrap.sub Integer.Usize (M.read (| β |)) (Value.Integer 1)
                              |) in
                            let~ _ :=
                              let~ ptr :=
                                M.alloc (|
                                  M.call_closure (|
                                    M.get_associated_function (|
                                      Ty.apply (Ty.path "alloc::vec::Vec") [ T; A ],
                                      "as_mut_ptr",
                                      []
                                    |),
                                    [
                                      M.SubPointer.get_struct_record_field (|
                                        self,
                                        "alloc::collections::binary_heap::BinaryHeap",
                                        "data"
                                      |)
                                    ]
                                  |)
                                |) in
                              let~ _ :=
                                M.alloc (|
                                  M.call_closure (|
                                    M.get_function (| "core::ptr::swap", [ T ] |),
                                    [
                                      M.read (| ptr |);
                                      M.call_closure (|
                                        M.get_associated_function (|
                                          Ty.apply (Ty.path "*mut") [ T ],
                                          "add",
                                          []
                                        |),
                                        [ M.read (| ptr |); M.read (| end_ |) ]
                                      |)
                                    ]
                                  |)
                                |) in
                              M.alloc (| Value.Tuple [] |) in
                            let~ _ :=
                              M.alloc (|
                                M.call_closure (|
                                  M.get_associated_function (|
                                    Ty.apply
                                      (Ty.path "alloc::collections::binary_heap::BinaryHeap")
                                      [ T; A ],
                                    "sift_down_range",
                                    []
                                  |),
                                  [ self; Value.Integer 0; M.read (| end_ |) ]
                                |)
                              |) in
                            M.alloc (| Value.Tuple [] |)));
                        fun γ =>
                          ltac:(M.monadic
                            (M.alloc (|
                              M.never_to_any (|
                                M.read (|
                                  let~ _ :=
                                    M.alloc (| M.never_to_any (| M.read (| M.break (||) |) |) |) in
                                  M.alloc (| Value.Tuple [] |)
                                |)
                              |)
                            |)))
                      ]
                    |)))
                |) in
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "alloc::collections::binary_heap::BinaryHeap") [ T; A ],
                    "into_vec",
                    []
                  |),
                  [ M.read (| self |) ]
                |)
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_into_sorted_vec :
        forall (T A : Ty.t),
        M.IsAssociatedFunction (Self T A) "into_sorted_vec" (into_sorted_vec T A).
      
      (*
          unsafe fn sift_up(&mut self, start: usize, pos: usize) -> usize {
              // Take out the value at `pos` and create a hole.
              // SAFETY: The caller guarantees that pos < self.len()
              let mut hole = unsafe { Hole::new(&mut self.data, pos) };
      
              while hole.pos() > start {
                  let parent = (hole.pos() - 1) / 2;
      
                  // SAFETY: hole.pos() > start >= 0, which means hole.pos() > 0
                  //  and so hole.pos() - 1 can't underflow.
                  //  This guarantees that parent < hole.pos() so
                  //  it's a valid index and also != hole.pos().
                  if hole.element() <= unsafe { hole.get(parent) } {
                      break;
                  }
      
                  // SAFETY: Same as above
                  unsafe { hole.move_to(parent) };
              }
      
              hole.pos()
          }
      *)
      Definition sift_up (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match τ, α with
        | [], [ self; start; pos ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let start := M.alloc (| start |) in
            let pos := M.alloc (| pos |) in
            M.read (|
              let~ hole :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply (Ty.path "alloc::collections::binary_heap::Hole") [ T ],
                      "new",
                      []
                    |),
                    [
                      M.call_closure (|
                        M.get_trait_method (|
                          "core::ops::deref::DerefMut",
                          Ty.apply (Ty.path "alloc::vec::Vec") [ T; A ],
                          [],
                          "deref_mut",
                          []
                        |),
                        [
                          M.SubPointer.get_struct_record_field (|
                            M.read (| self |),
                            "alloc::collections::binary_heap::BinaryHeap",
                            "data"
                          |)
                        ]
                      |);
                      M.read (| pos |)
                    ]
                  |)
                |) in
              let~ _ :=
                M.loop (|
                  ltac:(M.monadic
                    (M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  BinOp.Pure.gt
                                    (M.call_closure (|
                                      M.get_associated_function (|
                                        Ty.apply
                                          (Ty.path "alloc::collections::binary_heap::Hole")
                                          [ T ],
                                        "pos",
                                        []
                                      |),
                                      [ hole ]
                                    |))
                                    (M.read (| start |))
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            let~ parent :=
                              M.alloc (|
                                BinOp.Wrap.div
                                  Integer.Usize
                                  (BinOp.Wrap.sub
                                    Integer.Usize
                                    (M.call_closure (|
                                      M.get_associated_function (|
                                        Ty.apply
                                          (Ty.path "alloc::collections::binary_heap::Hole")
                                          [ T ],
                                        "pos",
                                        []
                                      |),
                                      [ hole ]
                                    |))
                                    (Value.Integer 1))
                                  (Value.Integer 2)
                              |) in
                            let~ _ :=
                              M.match_operator (|
                                M.alloc (| Value.Tuple [] |),
                                [
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let γ :=
                                        M.use
                                          (M.alloc (|
                                            M.call_closure (|
                                              M.get_trait_method (|
                                                "core::cmp::PartialOrd",
                                                Ty.apply (Ty.path "&") [ T ],
                                                [ Ty.apply (Ty.path "&") [ T ] ],
                                                "le",
                                                []
                                              |),
                                              [
                                                M.alloc (|
                                                  M.call_closure (|
                                                    M.get_associated_function (|
                                                      Ty.apply
                                                        (Ty.path
                                                          "alloc::collections::binary_heap::Hole")
                                                        [ T ],
                                                      "element",
                                                      []
                                                    |),
                                                    [ hole ]
                                                  |)
                                                |);
                                                M.alloc (|
                                                  M.call_closure (|
                                                    M.get_associated_function (|
                                                      Ty.apply
                                                        (Ty.path
                                                          "alloc::collections::binary_heap::Hole")
                                                        [ T ],
                                                      "get",
                                                      []
                                                    |),
                                                    [ hole; M.read (| parent |) ]
                                                  |)
                                                |)
                                              ]
                                            |)
                                          |)) in
                                      let _ :=
                                        M.is_constant_or_break_match (|
                                          M.read (| γ |),
                                          Value.Bool true
                                        |) in
                                      M.alloc (|
                                        M.never_to_any (| M.read (| M.break (||) |) |)
                                      |)));
                                  fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                                ]
                              |) in
                            let~ _ :=
                              M.alloc (|
                                M.call_closure (|
                                  M.get_associated_function (|
                                    Ty.apply
                                      (Ty.path "alloc::collections::binary_heap::Hole")
                                      [ T ],
                                    "move_to",
                                    []
                                  |),
                                  [ hole; M.read (| parent |) ]
                                |)
                              |) in
                            M.alloc (| Value.Tuple [] |)));
                        fun γ =>
                          ltac:(M.monadic
                            (M.alloc (|
                              M.never_to_any (|
                                M.read (|
                                  let~ _ :=
                                    M.alloc (| M.never_to_any (| M.read (| M.break (||) |) |) |) in
                                  M.alloc (| Value.Tuple [] |)
                                |)
                              |)
                            |)))
                      ]
                    |)))
                |) in
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "alloc::collections::binary_heap::Hole") [ T ],
                    "pos",
                    []
                  |),
                  [ hole ]
                |)
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_sift_up :
        forall (T A : Ty.t),
        M.IsAssociatedFunction (Self T A) "sift_up" (sift_up T A).
      
      (*
          unsafe fn sift_down_range(&mut self, pos: usize, end: usize) {
              // SAFETY: The caller guarantees that pos < end <= self.len().
              let mut hole = unsafe { Hole::new(&mut self.data, pos) };
              let mut child = 2 * hole.pos() + 1;
      
              // Loop invariant: child == 2 * hole.pos() + 1.
              while child <= end.saturating_sub(2) {
                  // compare with the greater of the two children
                  // SAFETY: child < end - 1 < self.len() and
                  //  child + 1 < end <= self.len(), so they're valid indexes.
                  //  child == 2 * hole.pos() + 1 != hole.pos() and
                  //  child + 1 == 2 * hole.pos() + 2 != hole.pos().
                  // FIXME: 2 * hole.pos() + 1 or 2 * hole.pos() + 2 could overflow
                  //  if T is a ZST
                  child += unsafe { hole.get(child) <= hole.get(child + 1) } as usize;
      
                  // if we are already in order, stop.
                  // SAFETY: child is now either the old child or the old child+1
                  //  We already proven that both are < self.len() and != hole.pos()
                  if hole.element() >= unsafe { hole.get(child) } {
                      return;
                  }
      
                  // SAFETY: same as above.
                  unsafe { hole.move_to(child) };
                  child = 2 * hole.pos() + 1;
              }
      
              // SAFETY: && short circuit, which means that in the
              //  second condition it's already true that child == end - 1 < self.len().
              if child == end - 1 && hole.element() < unsafe { hole.get(child) } {
                  // SAFETY: child is already proven to be a valid index and
                  //  child == 2 * hole.pos() + 1 != hole.pos().
                  unsafe { hole.move_to(child) };
              }
          }
      *)
      Definition sift_down_range (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match τ, α with
        | [], [ self; pos; end_ ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let pos := M.alloc (| pos |) in
            let end_ := M.alloc (| end_ |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.read (|
                  let~ hole :=
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "alloc::collections::binary_heap::Hole") [ T ],
                          "new",
                          []
                        |),
                        [
                          M.call_closure (|
                            M.get_trait_method (|
                              "core::ops::deref::DerefMut",
                              Ty.apply (Ty.path "alloc::vec::Vec") [ T; A ],
                              [],
                              "deref_mut",
                              []
                            |),
                            [
                              M.SubPointer.get_struct_record_field (|
                                M.read (| self |),
                                "alloc::collections::binary_heap::BinaryHeap",
                                "data"
                              |)
                            ]
                          |);
                          M.read (| pos |)
                        ]
                      |)
                    |) in
                  let~ child :=
                    M.alloc (|
                      BinOp.Wrap.add
                        Integer.Usize
                        (BinOp.Wrap.mul
                          Integer.Usize
                          (Value.Integer 2)
                          (M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply (Ty.path "alloc::collections::binary_heap::Hole") [ T ],
                              "pos",
                              []
                            |),
                            [ hole ]
                          |)))
                        (Value.Integer 1)
                    |) in
                  let~ _ :=
                    M.loop (|
                      ltac:(M.monadic
                        (M.match_operator (|
                          M.alloc (| Value.Tuple [] |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ :=
                                  M.use
                                    (M.alloc (|
                                      BinOp.Pure.le
                                        (M.read (| child |))
                                        (M.call_closure (|
                                          M.get_associated_function (|
                                            Ty.path "usize",
                                            "saturating_sub",
                                            []
                                          |),
                                          [ M.read (| end_ |); Value.Integer 2 ]
                                        |))
                                    |)) in
                                let _ :=
                                  M.is_constant_or_break_match (|
                                    M.read (| γ |),
                                    Value.Bool true
                                  |) in
                                let~ _ :=
                                  let β := child in
                                  M.write (|
                                    β,
                                    BinOp.Wrap.add
                                      Integer.Usize
                                      (M.read (| β |))
                                      (M.rust_cast
                                        (M.call_closure (|
                                          M.get_trait_method (|
                                            "core::cmp::PartialOrd",
                                            Ty.apply (Ty.path "&") [ T ],
                                            [ Ty.apply (Ty.path "&") [ T ] ],
                                            "le",
                                            []
                                          |),
                                          [
                                            M.alloc (|
                                              M.call_closure (|
                                                M.get_associated_function (|
                                                  Ty.apply
                                                    (Ty.path
                                                      "alloc::collections::binary_heap::Hole")
                                                    [ T ],
                                                  "get",
                                                  []
                                                |),
                                                [ hole; M.read (| child |) ]
                                              |)
                                            |);
                                            M.alloc (|
                                              M.call_closure (|
                                                M.get_associated_function (|
                                                  Ty.apply
                                                    (Ty.path
                                                      "alloc::collections::binary_heap::Hole")
                                                    [ T ],
                                                  "get",
                                                  []
                                                |),
                                                [
                                                  hole;
                                                  BinOp.Wrap.add
                                                    Integer.Usize
                                                    (M.read (| child |))
                                                    (Value.Integer 1)
                                                ]
                                              |)
                                            |)
                                          ]
                                        |)))
                                  |) in
                                let~ _ :=
                                  M.match_operator (|
                                    M.alloc (| Value.Tuple [] |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let γ :=
                                            M.use
                                              (M.alloc (|
                                                M.call_closure (|
                                                  M.get_trait_method (|
                                                    "core::cmp::PartialOrd",
                                                    Ty.apply (Ty.path "&") [ T ],
                                                    [ Ty.apply (Ty.path "&") [ T ] ],
                                                    "ge",
                                                    []
                                                  |),
                                                  [
                                                    M.alloc (|
                                                      M.call_closure (|
                                                        M.get_associated_function (|
                                                          Ty.apply
                                                            (Ty.path
                                                              "alloc::collections::binary_heap::Hole")
                                                            [ T ],
                                                          "element",
                                                          []
                                                        |),
                                                        [ hole ]
                                                      |)
                                                    |);
                                                    M.alloc (|
                                                      M.call_closure (|
                                                        M.get_associated_function (|
                                                          Ty.apply
                                                            (Ty.path
                                                              "alloc::collections::binary_heap::Hole")
                                                            [ T ],
                                                          "get",
                                                          []
                                                        |),
                                                        [ hole; M.read (| child |) ]
                                                      |)
                                                    |)
                                                  ]
                                                |)
                                              |)) in
                                          let _ :=
                                            M.is_constant_or_break_match (|
                                              M.read (| γ |),
                                              Value.Bool true
                                            |) in
                                          M.alloc (|
                                            M.never_to_any (|
                                              M.read (| M.return_ (| Value.Tuple [] |) |)
                                            |)
                                          |)));
                                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                                    ]
                                  |) in
                                let~ _ :=
                                  M.alloc (|
                                    M.call_closure (|
                                      M.get_associated_function (|
                                        Ty.apply
                                          (Ty.path "alloc::collections::binary_heap::Hole")
                                          [ T ],
                                        "move_to",
                                        []
                                      |),
                                      [ hole; M.read (| child |) ]
                                    |)
                                  |) in
                                let~ _ :=
                                  M.write (|
                                    child,
                                    BinOp.Wrap.add
                                      Integer.Usize
                                      (BinOp.Wrap.mul
                                        Integer.Usize
                                        (Value.Integer 2)
                                        (M.call_closure (|
                                          M.get_associated_function (|
                                            Ty.apply
                                              (Ty.path "alloc::collections::binary_heap::Hole")
                                              [ T ],
                                            "pos",
                                            []
                                          |),
                                          [ hole ]
                                        |)))
                                      (Value.Integer 1)
                                  |) in
                                M.alloc (| Value.Tuple [] |)));
                            fun γ =>
                              ltac:(M.monadic
                                (M.alloc (|
                                  M.never_to_any (|
                                    M.read (|
                                      let~ _ :=
                                        M.alloc (|
                                          M.never_to_any (| M.read (| M.break (||) |) |)
                                        |) in
                                      M.alloc (| Value.Tuple [] |)
                                    |)
                                  |)
                                |)))
                          ]
                        |)))
                    |) in
                  M.match_operator (|
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                LogicalOp.and (|
                                  BinOp.Pure.eq
                                    (M.read (| child |))
                                    (BinOp.Wrap.sub
                                      Integer.Usize
                                      (M.read (| end_ |))
                                      (Value.Integer 1)),
                                  ltac:(M.monadic
                                    (M.call_closure (|
                                      M.get_trait_method (|
                                        "core::cmp::PartialOrd",
                                        Ty.apply (Ty.path "&") [ T ],
                                        [ Ty.apply (Ty.path "&") [ T ] ],
                                        "lt",
                                        []
                                      |),
                                      [
                                        M.alloc (|
                                          M.call_closure (|
                                            M.get_associated_function (|
                                              Ty.apply
                                                (Ty.path "alloc::collections::binary_heap::Hole")
                                                [ T ],
                                              "element",
                                              []
                                            |),
                                            [ hole ]
                                          |)
                                        |);
                                        M.alloc (|
                                          M.call_closure (|
                                            M.get_associated_function (|
                                              Ty.apply
                                                (Ty.path "alloc::collections::binary_heap::Hole")
                                                [ T ],
                                              "get",
                                              []
                                            |),
                                            [ hole; M.read (| child |) ]
                                          |)
                                        |)
                                      ]
                                    |)))
                                |)
                              |)) in
                          let _ :=
                            M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          let~ _ :=
                            M.alloc (|
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "alloc::collections::binary_heap::Hole") [ T ],
                                  "move_to",
                                  []
                                |),
                                [ hole; M.read (| child |) ]
                              |)
                            |) in
                          M.alloc (| Value.Tuple [] |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |)
                |)))
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_sift_down_range :
        forall (T A : Ty.t),
        M.IsAssociatedFunction (Self T A) "sift_down_range" (sift_down_range T A).
      
      (*
          unsafe fn sift_down(&mut self, pos: usize) {
              let len = self.len();
              // SAFETY: pos < len is guaranteed by the caller and
              //  obviously len = self.len() <= self.len().
              unsafe { self.sift_down_range(pos, len) };
          }
      *)
      Definition sift_down (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match τ, α with
        | [], [ self; pos ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let pos := M.alloc (| pos |) in
            M.read (|
              let~ len :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply (Ty.path "alloc::collections::binary_heap::BinaryHeap") [ T; A ],
                      "len",
                      []
                    |),
                    [ M.read (| self |) ]
                  |)
                |) in
              let~ _ :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply (Ty.path "alloc::collections::binary_heap::BinaryHeap") [ T; A ],
                      "sift_down_range",
                      []
                    |),
                    [ M.read (| self |); M.read (| pos |); M.read (| len |) ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_sift_down :
        forall (T A : Ty.t),
        M.IsAssociatedFunction (Self T A) "sift_down" (sift_down T A).
      
      (*
          unsafe fn sift_down_to_bottom(&mut self, mut pos: usize) {
              let end = self.len();
              let start = pos;
      
              // SAFETY: The caller guarantees that pos < self.len().
              let mut hole = unsafe { Hole::new(&mut self.data, pos) };
              let mut child = 2 * hole.pos() + 1;
      
              // Loop invariant: child == 2 * hole.pos() + 1.
              while child <= end.saturating_sub(2) {
                  // SAFETY: child < end - 1 < self.len() and
                  //  child + 1 < end <= self.len(), so they're valid indexes.
                  //  child == 2 * hole.pos() + 1 != hole.pos() and
                  //  child + 1 == 2 * hole.pos() + 2 != hole.pos().
                  // FIXME: 2 * hole.pos() + 1 or 2 * hole.pos() + 2 could overflow
                  //  if T is a ZST
                  child += unsafe { hole.get(child) <= hole.get(child + 1) } as usize;
      
                  // SAFETY: Same as above
                  unsafe { hole.move_to(child) };
                  child = 2 * hole.pos() + 1;
              }
      
              if child == end - 1 {
                  // SAFETY: child == end - 1 < self.len(), so it's a valid index
                  //  and child == 2 * hole.pos() + 1 != hole.pos().
                  unsafe { hole.move_to(child) };
              }
              pos = hole.pos();
              drop(hole);
      
              // SAFETY: pos is the position in the hole and was already proven
              //  to be a valid index.
              unsafe { self.sift_up(start, pos) };
          }
      *)
      Definition sift_down_to_bottom (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match τ, α with
        | [], [ self; pos ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let pos := M.alloc (| pos |) in
            M.read (|
              let~ end_ :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply (Ty.path "alloc::collections::binary_heap::BinaryHeap") [ T; A ],
                      "len",
                      []
                    |),
                    [ M.read (| self |) ]
                  |)
                |) in
              let~ start := M.copy (| pos |) in
              let~ hole :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply (Ty.path "alloc::collections::binary_heap::Hole") [ T ],
                      "new",
                      []
                    |),
                    [
                      M.call_closure (|
                        M.get_trait_method (|
                          "core::ops::deref::DerefMut",
                          Ty.apply (Ty.path "alloc::vec::Vec") [ T; A ],
                          [],
                          "deref_mut",
                          []
                        |),
                        [
                          M.SubPointer.get_struct_record_field (|
                            M.read (| self |),
                            "alloc::collections::binary_heap::BinaryHeap",
                            "data"
                          |)
                        ]
                      |);
                      M.read (| pos |)
                    ]
                  |)
                |) in
              let~ child :=
                M.alloc (|
                  BinOp.Wrap.add
                    Integer.Usize
                    (BinOp.Wrap.mul
                      Integer.Usize
                      (Value.Integer 2)
                      (M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "alloc::collections::binary_heap::Hole") [ T ],
                          "pos",
                          []
                        |),
                        [ hole ]
                      |)))
                    (Value.Integer 1)
                |) in
              let~ _ :=
                M.loop (|
                  ltac:(M.monadic
                    (M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  BinOp.Pure.le
                                    (M.read (| child |))
                                    (M.call_closure (|
                                      M.get_associated_function (|
                                        Ty.path "usize",
                                        "saturating_sub",
                                        []
                                      |),
                                      [ M.read (| end_ |); Value.Integer 2 ]
                                    |))
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            let~ _ :=
                              let β := child in
                              M.write (|
                                β,
                                BinOp.Wrap.add
                                  Integer.Usize
                                  (M.read (| β |))
                                  (M.rust_cast
                                    (M.call_closure (|
                                      M.get_trait_method (|
                                        "core::cmp::PartialOrd",
                                        Ty.apply (Ty.path "&") [ T ],
                                        [ Ty.apply (Ty.path "&") [ T ] ],
                                        "le",
                                        []
                                      |),
                                      [
                                        M.alloc (|
                                          M.call_closure (|
                                            M.get_associated_function (|
                                              Ty.apply
                                                (Ty.path "alloc::collections::binary_heap::Hole")
                                                [ T ],
                                              "get",
                                              []
                                            |),
                                            [ hole; M.read (| child |) ]
                                          |)
                                        |);
                                        M.alloc (|
                                          M.call_closure (|
                                            M.get_associated_function (|
                                              Ty.apply
                                                (Ty.path "alloc::collections::binary_heap::Hole")
                                                [ T ],
                                              "get",
                                              []
                                            |),
                                            [
                                              hole;
                                              BinOp.Wrap.add
                                                Integer.Usize
                                                (M.read (| child |))
                                                (Value.Integer 1)
                                            ]
                                          |)
                                        |)
                                      ]
                                    |)))
                              |) in
                            let~ _ :=
                              M.alloc (|
                                M.call_closure (|
                                  M.get_associated_function (|
                                    Ty.apply
                                      (Ty.path "alloc::collections::binary_heap::Hole")
                                      [ T ],
                                    "move_to",
                                    []
                                  |),
                                  [ hole; M.read (| child |) ]
                                |)
                              |) in
                            let~ _ :=
                              M.write (|
                                child,
                                BinOp.Wrap.add
                                  Integer.Usize
                                  (BinOp.Wrap.mul
                                    Integer.Usize
                                    (Value.Integer 2)
                                    (M.call_closure (|
                                      M.get_associated_function (|
                                        Ty.apply
                                          (Ty.path "alloc::collections::binary_heap::Hole")
                                          [ T ],
                                        "pos",
                                        []
                                      |),
                                      [ hole ]
                                    |)))
                                  (Value.Integer 1)
                              |) in
                            M.alloc (| Value.Tuple [] |)));
                        fun γ =>
                          ltac:(M.monadic
                            (M.alloc (|
                              M.never_to_any (|
                                M.read (|
                                  let~ _ :=
                                    M.alloc (| M.never_to_any (| M.read (| M.break (||) |) |) |) in
                                  M.alloc (| Value.Tuple [] |)
                                |)
                              |)
                            |)))
                      ]
                    |)))
                |) in
              let~ _ :=
                M.match_operator (|
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ :=
                          M.use
                            (M.alloc (|
                              BinOp.Pure.eq
                                (M.read (| child |))
                                (BinOp.Wrap.sub Integer.Usize (M.read (| end_ |)) (Value.Integer 1))
                            |)) in
                        let _ :=
                          M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        let~ _ :=
                          M.alloc (|
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply (Ty.path "alloc::collections::binary_heap::Hole") [ T ],
                                "move_to",
                                []
                              |),
                              [ hole; M.read (| child |) ]
                            |)
                          |) in
                        M.alloc (| Value.Tuple [] |)));
                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                  ]
                |) in
              let~ _ :=
                M.write (|
                  pos,
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply (Ty.path "alloc::collections::binary_heap::Hole") [ T ],
                      "pos",
                      []
                    |),
                    [ hole ]
                  |)
                |) in
              let~ _ :=
                M.alloc (|
                  M.call_closure (|
                    M.get_function (|
                      "core::mem::drop",
                      [ Ty.apply (Ty.path "alloc::collections::binary_heap::Hole") [ T ] ]
                    |),
                    [ M.read (| hole |) ]
                  |)
                |) in
              let~ _ :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply (Ty.path "alloc::collections::binary_heap::BinaryHeap") [ T; A ],
                      "sift_up",
                      []
                    |),
                    [ M.read (| self |); M.read (| start |); M.read (| pos |) ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_sift_down_to_bottom :
        forall (T A : Ty.t),
        M.IsAssociatedFunction (Self T A) "sift_down_to_bottom" (sift_down_to_bottom T A).
      
      (*
          fn rebuild_tail(&mut self, start: usize) {
              if start == self.len() {
                  return;
              }
      
              let tail_len = self.len() - start;
      
              #[inline(always)]
              fn log2_fast(x: usize) -> usize {
                  (usize::BITS - x.leading_zeros() - 1) as usize
              }
      
              // `rebuild` takes O(self.len()) operations
              // and about 2 * self.len() comparisons in the worst case
              // while repeating `sift_up` takes O(tail_len * log(start)) operations
              // and about 1 * tail_len * log_2(start) comparisons in the worst case,
              // assuming start >= tail_len. For larger heaps, the crossover point
              // no longer follows this reasoning and was determined empirically.
              let better_to_rebuild = if start < tail_len {
                  true
              } else if self.len() <= 2048 {
                  2 * self.len() < tail_len * log2_fast(start)
              } else {
                  2 * self.len() < tail_len * 11
              };
      
              if better_to_rebuild {
                  self.rebuild();
              } else {
                  for i in start..self.len() {
                      // SAFETY: The index `i` is always less than self.len().
                      unsafe { self.sift_up(0, i) };
                  }
              }
          }
      *)
      Definition rebuild_tail (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match τ, α with
        | [], [ self; start ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let start := M.alloc (| start |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.read (|
                  let~ _ :=
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  BinOp.Pure.eq
                                    (M.read (| start |))
                                    (M.call_closure (|
                                      M.get_associated_function (|
                                        Ty.apply
                                          (Ty.path "alloc::collections::binary_heap::BinaryHeap")
                                          [ T; A ],
                                        "len",
                                        []
                                      |),
                                      [ M.read (| self |) ]
                                    |))
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (|
                              M.never_to_any (| M.read (| M.return_ (| Value.Tuple [] |) |) |)
                            |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                      ]
                    |) in
                  let~ tail_len :=
                    M.alloc (|
                      BinOp.Wrap.sub
                        Integer.Usize
                        (M.call_closure (|
                          M.get_associated_function (|
                            Ty.apply
                              (Ty.path "alloc::collections::binary_heap::BinaryHeap")
                              [ T; A ],
                            "len",
                            []
                          |),
                          [ M.read (| self |) ]
                        |))
                        (M.read (| start |))
                    |) in
                  let~ better_to_rebuild :=
                    M.copy (|
                      M.match_operator (|
                        M.alloc (| Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.use
                                  (M.alloc (|
                                    BinOp.Pure.lt (M.read (| start |)) (M.read (| tail_len |))
                                  |)) in
                              let _ :=
                                M.is_constant_or_break_match (|
                                  M.read (| γ |),
                                  Value.Bool true
                                |) in
                              M.alloc (| Value.Bool true |)));
                          fun γ =>
                            ltac:(M.monadic
                              (M.match_operator (|
                                M.alloc (| Value.Tuple [] |),
                                [
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let γ :=
                                        M.use
                                          (M.alloc (|
                                            BinOp.Pure.le
                                              (M.call_closure (|
                                                M.get_associated_function (|
                                                  Ty.apply
                                                    (Ty.path
                                                      "alloc::collections::binary_heap::BinaryHeap")
                                                    [ T; A ],
                                                  "len",
                                                  []
                                                |),
                                                [ M.read (| self |) ]
                                              |))
                                              (Value.Integer 2048)
                                          |)) in
                                      let _ :=
                                        M.is_constant_or_break_match (|
                                          M.read (| γ |),
                                          Value.Bool true
                                        |) in
                                      M.alloc (|
                                        BinOp.Pure.lt
                                          (BinOp.Wrap.mul
                                            Integer.Usize
                                            (Value.Integer 2)
                                            (M.call_closure (|
                                              M.get_associated_function (|
                                                Ty.apply
                                                  (Ty.path
                                                    "alloc::collections::binary_heap::BinaryHeap")
                                                  [ T; A ],
                                                "len",
                                                []
                                              |),
                                              [ M.read (| self |) ]
                                            |)))
                                          (BinOp.Wrap.mul
                                            Integer.Usize
                                            (M.read (| tail_len |))
                                            (M.call_closure (|
                                              M.get_associated_function (|
                                                Self,
                                                "log2_fast.rebuild_tail",
                                                []
                                              |),
                                              [ M.read (| start |) ]
                                            |)))
                                      |)));
                                  fun γ =>
                                    ltac:(M.monadic
                                      (M.alloc (|
                                        BinOp.Pure.lt
                                          (BinOp.Wrap.mul
                                            Integer.Usize
                                            (Value.Integer 2)
                                            (M.call_closure (|
                                              M.get_associated_function (|
                                                Ty.apply
                                                  (Ty.path
                                                    "alloc::collections::binary_heap::BinaryHeap")
                                                  [ T; A ],
                                                "len",
                                                []
                                              |),
                                              [ M.read (| self |) ]
                                            |)))
                                          (BinOp.Wrap.mul
                                            Integer.Usize
                                            (M.read (| tail_len |))
                                            (Value.Integer 11))
                                      |)))
                                ]
                              |)))
                        ]
                      |)
                    |) in
                  M.match_operator (|
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ := M.use better_to_rebuild in
                          let _ :=
                            M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          let~ _ :=
                            M.alloc (|
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "alloc::collections::binary_heap::BinaryHeap")
                                    [ T; A ],
                                  "rebuild",
                                  []
                                |),
                                [ M.read (| self |) ]
                              |)
                            |) in
                          M.alloc (| Value.Tuple [] |)));
                      fun γ =>
                        ltac:(M.monadic
                          (M.use
                            (M.match_operator (|
                              M.alloc (|
                                M.call_closure (|
                                  M.get_trait_method (|
                                    "core::iter::traits::collect::IntoIterator",
                                    Ty.apply
                                      (Ty.path "core::ops::range::Range")
                                      [ Ty.path "usize" ],
                                    [],
                                    "into_iter",
                                    []
                                  |),
                                  [
                                    Value.StructRecord
                                      "core::ops::range::Range"
                                      [
                                        ("start", M.read (| start |));
                                        ("end_",
                                          M.call_closure (|
                                            M.get_associated_function (|
                                              Ty.apply
                                                (Ty.path
                                                  "alloc::collections::binary_heap::BinaryHeap")
                                                [ T; A ],
                                              "len",
                                              []
                                            |),
                                            [ M.read (| self |) ]
                                          |))
                                      ]
                                  ]
                                |)
                              |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let iter := M.copy (| γ |) in
                                    M.loop (|
                                      ltac:(M.monadic
                                        (let~ _ :=
                                          M.match_operator (|
                                            M.alloc (|
                                              M.call_closure (|
                                                M.get_trait_method (|
                                                  "core::iter::traits::iterator::Iterator",
                                                  Ty.apply
                                                    (Ty.path "core::ops::range::Range")
                                                    [ Ty.path "usize" ],
                                                  [],
                                                  "next",
                                                  []
                                                |),
                                                [ iter ]
                                              |)
                                            |),
                                            [
                                              fun γ =>
                                                ltac:(M.monadic
                                                  (let _ :=
                                                    M.is_struct_tuple (|
                                                      γ,
                                                      "core::option::Option::None"
                                                    |) in
                                                  M.alloc (|
                                                    M.never_to_any (| M.read (| M.break (||) |) |)
                                                  |)));
                                              fun γ =>
                                                ltac:(M.monadic
                                                  (let γ0_0 :=
                                                    M.SubPointer.get_struct_tuple_field (|
                                                      γ,
                                                      "core::option::Option::Some",
                                                      0
                                                    |) in
                                                  let i := M.copy (| γ0_0 |) in
                                                  let~ _ :=
                                                    M.alloc (|
                                                      M.call_closure (|
                                                        M.get_associated_function (|
                                                          Ty.apply
                                                            (Ty.path
                                                              "alloc::collections::binary_heap::BinaryHeap")
                                                            [ T; A ],
                                                          "sift_up",
                                                          []
                                                        |),
                                                        [
                                                          M.read (| self |);
                                                          Value.Integer 0;
                                                          M.read (| i |)
                                                        ]
                                                      |)
                                                    |) in
                                                  M.alloc (| Value.Tuple [] |)))
                                            ]
                                          |) in
                                        M.alloc (| Value.Tuple [] |)))
                                    |)))
                              ]
                            |))))
                    ]
                  |)
                |)))
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_rebuild_tail :
        forall (T A : Ty.t),
        M.IsAssociatedFunction (Self T A) "rebuild_tail" (rebuild_tail T A).
      
      (*
          fn rebuild(&mut self) {
              let mut n = self.len() / 2;
              while n > 0 {
                  n -= 1;
                  // SAFETY: n starts from self.len() / 2 and goes down to 0.
                  //  The only case when !(n < self.len()) is if
                  //  self.len() == 0, but it's ruled out by the loop condition.
                  unsafe { self.sift_down(n) };
              }
          }
      *)
      Definition rebuild (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              let~ n :=
                M.alloc (|
                  BinOp.Wrap.div
                    Integer.Usize
                    (M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "alloc::collections::binary_heap::BinaryHeap") [ T; A ],
                        "len",
                        []
                      |),
                      [ M.read (| self |) ]
                    |))
                    (Value.Integer 2)
                |) in
              M.loop (|
                ltac:(M.monadic
                  (M.match_operator (|
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (| BinOp.Pure.gt (M.read (| n |)) (Value.Integer 0) |)) in
                          let _ :=
                            M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          let~ _ :=
                            let β := n in
                            M.write (|
                              β,
                              BinOp.Wrap.sub Integer.Usize (M.read (| β |)) (Value.Integer 1)
                            |) in
                          let~ _ :=
                            M.alloc (|
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "alloc::collections::binary_heap::BinaryHeap")
                                    [ T; A ],
                                  "sift_down",
                                  []
                                |),
                                [ M.read (| self |); M.read (| n |) ]
                              |)
                            |) in
                          M.alloc (| Value.Tuple [] |)));
                      fun γ =>
                        ltac:(M.monadic
                          (M.alloc (|
                            M.never_to_any (|
                              M.read (|
                                let~ _ :=
                                  M.alloc (| M.never_to_any (| M.read (| M.break (||) |) |) |) in
                                M.alloc (| Value.Tuple [] |)
                              |)
                            |)
                          |)))
                    ]
                  |)))
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_rebuild :
        forall (T A : Ty.t),
        M.IsAssociatedFunction (Self T A) "rebuild" (rebuild T A).
      
      (*
          pub fn append(&mut self, other: &mut Self) {
              if self.len() < other.len() {
                  swap(self, other);
              }
      
              let start = self.data.len();
      
              self.data.append(&mut other.data);
      
              self.rebuild_tail(start);
          }
      *)
      Definition append (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let~ _ :=
                M.match_operator (|
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ :=
                          M.use
                            (M.alloc (|
                              BinOp.Pure.lt
                                (M.call_closure (|
                                  M.get_associated_function (|
                                    Ty.apply
                                      (Ty.path "alloc::collections::binary_heap::BinaryHeap")
                                      [ T; A ],
                                    "len",
                                    []
                                  |),
                                  [ M.read (| self |) ]
                                |))
                                (M.call_closure (|
                                  M.get_associated_function (|
                                    Ty.apply
                                      (Ty.path "alloc::collections::binary_heap::BinaryHeap")
                                      [ T; A ],
                                    "len",
                                    []
                                  |),
                                  [ M.read (| other |) ]
                                |))
                            |)) in
                        let _ :=
                          M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        let~ _ :=
                          M.alloc (|
                            M.call_closure (|
                              M.get_function (|
                                "core::mem::swap",
                                [
                                  Ty.apply
                                    (Ty.path "alloc::collections::binary_heap::BinaryHeap")
                                    [ T; A ]
                                ]
                              |),
                              [ M.read (| self |); M.read (| other |) ]
                            |)
                          |) in
                        M.alloc (| Value.Tuple [] |)));
                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                  ]
                |) in
              let~ start :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply (Ty.path "alloc::vec::Vec") [ T; A ],
                      "len",
                      []
                    |),
                    [
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "alloc::collections::binary_heap::BinaryHeap",
                        "data"
                      |)
                    ]
                  |)
                |) in
              let~ _ :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply (Ty.path "alloc::vec::Vec") [ T; A ],
                      "append",
                      []
                    |),
                    [
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "alloc::collections::binary_heap::BinaryHeap",
                        "data"
                      |);
                      M.SubPointer.get_struct_record_field (|
                        M.read (| other |),
                        "alloc::collections::binary_heap::BinaryHeap",
                        "data"
                      |)
                    ]
                  |)
                |) in
              let~ _ :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply (Ty.path "alloc::collections::binary_heap::BinaryHeap") [ T; A ],
                      "rebuild_tail",
                      []
                    |),
                    [ M.read (| self |); M.read (| start |) ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_append :
        forall (T A : Ty.t),
        M.IsAssociatedFunction (Self T A) "append" (append T A).
      
      (*
          pub fn drain_sorted(&mut self) -> DrainSorted<'_, T, A> {
              DrainSorted { inner: self }
          }
      *)
      Definition drain_sorted (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructRecord
              "alloc::collections::binary_heap::DrainSorted"
              [ ("inner", M.read (| self |)) ]))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_drain_sorted :
        forall (T A : Ty.t),
        M.IsAssociatedFunction (Self T A) "drain_sorted" (drain_sorted T A).
      
      (*
          pub fn retain<F>(&mut self, mut f: F)
          where
              F: FnMut(&T) -> bool,
          {
              // rebuild_start will be updated to the first touched element below, and the rebuild will
              // only be done for the tail.
              let mut guard = RebuildOnDrop { rebuild_from: self.len(), heap: self };
              let mut i = 0;
      
              guard.heap.data.retain(|e| {
                  let keep = f(e);
                  if !keep && i < guard.rebuild_from {
                      guard.rebuild_from = i;
                  }
                  i += 1;
                  keep
              });
          }
      *)
      Definition retain (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match τ, α with
        | [ F ], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.read (|
              let~ guard :=
                M.alloc (|
                  Value.StructRecord
                    "alloc::collections::binary_heap::RebuildOnDrop"
                    [
                      ("rebuild_from",
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.apply
                              (Ty.path "alloc::collections::binary_heap::BinaryHeap")
                              [ T; A ],
                            "len",
                            []
                          |),
                          [ M.read (| self |) ]
                        |));
                      ("heap", M.read (| self |))
                    ]
                |) in
              let~ i := M.alloc (| Value.Integer 0 |) in
              let~ _ :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply (Ty.path "alloc::vec::Vec") [ T; A ],
                      "retain",
                      [ Ty.function [ Ty.tuple [ Ty.apply (Ty.path "&") [ T ] ] ] (Ty.path "bool") ]
                    |),
                    [
                      M.SubPointer.get_struct_record_field (|
                        M.read (|
                          M.SubPointer.get_struct_record_field (|
                            guard,
                            "alloc::collections::binary_heap::RebuildOnDrop",
                            "heap"
                          |)
                        |),
                        "alloc::collections::binary_heap::BinaryHeap",
                        "data"
                      |);
                      M.closure
                        (fun γ =>
                          ltac:(M.monadic
                            match γ with
                            | [ α0 ] =>
                              M.match_operator (|
                                M.alloc (| α0 |),
                                [
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let e := M.copy (| γ |) in
                                      M.read (|
                                        let~ keep :=
                                          M.alloc (|
                                            M.call_closure (|
                                              M.get_trait_method (|
                                                "core::ops::function::FnMut",
                                                F,
                                                [ Ty.tuple [ Ty.apply (Ty.path "&") [ T ] ] ],
                                                "call_mut",
                                                []
                                              |),
                                              [ f; Value.Tuple [ M.read (| e |) ] ]
                                            |)
                                          |) in
                                        let~ _ :=
                                          M.match_operator (|
                                            M.alloc (| Value.Tuple [] |),
                                            [
                                              fun γ =>
                                                ltac:(M.monadic
                                                  (let γ :=
                                                    M.use
                                                      (M.alloc (|
                                                        LogicalOp.and (|
                                                          UnOp.Pure.not (M.read (| keep |)),
                                                          ltac:(M.monadic
                                                            (BinOp.Pure.lt
                                                              (M.read (| i |))
                                                              (M.read (|
                                                                M.SubPointer.get_struct_record_field (|
                                                                  guard,
                                                                  "alloc::collections::binary_heap::RebuildOnDrop",
                                                                  "rebuild_from"
                                                                |)
                                                              |))))
                                                        |)
                                                      |)) in
                                                  let _ :=
                                                    M.is_constant_or_break_match (|
                                                      M.read (| γ |),
                                                      Value.Bool true
                                                    |) in
                                                  let~ _ :=
                                                    M.write (|
                                                      M.SubPointer.get_struct_record_field (|
                                                        guard,
                                                        "alloc::collections::binary_heap::RebuildOnDrop",
                                                        "rebuild_from"
                                                      |),
                                                      M.read (| i |)
                                                    |) in
                                                  M.alloc (| Value.Tuple [] |)));
                                              fun γ =>
                                                ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                                            ]
                                          |) in
                                        let~ _ :=
                                          let β := i in
                                          M.write (|
                                            β,
                                            BinOp.Wrap.add
                                              Integer.Usize
                                              (M.read (| β |))
                                              (Value.Integer 1)
                                          |) in
                                        keep
                                      |)))
                                ]
                              |)
                            | _ => M.impossible (||)
                            end))
                    ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_retain :
        forall (T A : Ty.t),
        M.IsAssociatedFunction (Self T A) "retain" (retain T A).
      (*
          pub fn iter(&self) -> Iter<'_, T> {
              Iter { iter: self.data.iter() }
          }
      *)
      Definition iter (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructRecord
              "alloc::collections::binary_heap::Iter"
              [
                ("iter",
                  M.call_closure (|
                    M.get_associated_function (| Ty.apply (Ty.path "slice") [ T ], "iter", [] |),
                    [
                      M.call_closure (|
                        M.get_trait_method (|
                          "core::ops::deref::Deref",
                          Ty.apply (Ty.path "alloc::vec::Vec") [ T; A ],
                          [],
                          "deref",
                          []
                        |),
                        [
                          M.SubPointer.get_struct_record_field (|
                            M.read (| self |),
                            "alloc::collections::binary_heap::BinaryHeap",
                            "data"
                          |)
                        ]
                      |)
                    ]
                  |))
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_iter :
        forall (T A : Ty.t),
        M.IsAssociatedFunction (Self T A) "iter" (iter T A).
      
      (*
          pub fn into_iter_sorted(self) -> IntoIterSorted<T, A> {
              IntoIterSorted { inner: self }
          }
      *)
      Definition into_iter_sorted (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructRecord
              "alloc::collections::binary_heap::IntoIterSorted"
              [ ("inner", M.read (| self |)) ]))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_into_iter_sorted :
        forall (T A : Ty.t),
        M.IsAssociatedFunction (Self T A) "into_iter_sorted" (into_iter_sorted T A).
      
      (*
          pub fn peek(&self) -> Option<&T> {
              self.data.get(0)
          }
      *)
      Definition peek (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply (Ty.path "slice") [ T ],
                "get",
                [ Ty.path "usize" ]
              |),
              [
                M.call_closure (|
                  M.get_trait_method (|
                    "core::ops::deref::Deref",
                    Ty.apply (Ty.path "alloc::vec::Vec") [ T; A ],
                    [],
                    "deref",
                    []
                  |),
                  [
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "alloc::collections::binary_heap::BinaryHeap",
                      "data"
                    |)
                  ]
                |);
                Value.Integer 0
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_peek :
        forall (T A : Ty.t),
        M.IsAssociatedFunction (Self T A) "peek" (peek T A).
      
      (*
          pub fn capacity(&self) -> usize {
              self.data.capacity()
          }
      *)
      Definition capacity (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply (Ty.path "alloc::vec::Vec") [ T; A ],
                "capacity",
                []
              |),
              [
                M.SubPointer.get_struct_record_field (|
                  M.read (| self |),
                  "alloc::collections::binary_heap::BinaryHeap",
                  "data"
                |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_capacity :
        forall (T A : Ty.t),
        M.IsAssociatedFunction (Self T A) "capacity" (capacity T A).
      
      (*
          pub fn reserve_exact(&mut self, additional: usize) {
              self.data.reserve_exact(additional);
          }
      *)
      Definition reserve_exact (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match τ, α with
        | [], [ self; additional ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let additional := M.alloc (| additional |) in
            M.read (|
              let~ _ :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply (Ty.path "alloc::vec::Vec") [ T; A ],
                      "reserve_exact",
                      []
                    |),
                    [
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "alloc::collections::binary_heap::BinaryHeap",
                        "data"
                      |);
                      M.read (| additional |)
                    ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_reserve_exact :
        forall (T A : Ty.t),
        M.IsAssociatedFunction (Self T A) "reserve_exact" (reserve_exact T A).
      
      (*
          pub fn reserve(&mut self, additional: usize) {
              self.data.reserve(additional);
          }
      *)
      Definition reserve (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match τ, α with
        | [], [ self; additional ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let additional := M.alloc (| additional |) in
            M.read (|
              let~ _ :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply (Ty.path "alloc::vec::Vec") [ T; A ],
                      "reserve",
                      []
                    |),
                    [
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "alloc::collections::binary_heap::BinaryHeap",
                        "data"
                      |);
                      M.read (| additional |)
                    ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_reserve :
        forall (T A : Ty.t),
        M.IsAssociatedFunction (Self T A) "reserve" (reserve T A).
      
      (*
          pub fn try_reserve_exact(&mut self, additional: usize) -> Result<(), TryReserveError> {
              self.data.try_reserve_exact(additional)
          }
      *)
      Definition try_reserve_exact (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match τ, α with
        | [], [ self; additional ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let additional := M.alloc (| additional |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply (Ty.path "alloc::vec::Vec") [ T; A ],
                "try_reserve_exact",
                []
              |),
              [
                M.SubPointer.get_struct_record_field (|
                  M.read (| self |),
                  "alloc::collections::binary_heap::BinaryHeap",
                  "data"
                |);
                M.read (| additional |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_try_reserve_exact :
        forall (T A : Ty.t),
        M.IsAssociatedFunction (Self T A) "try_reserve_exact" (try_reserve_exact T A).
      
      (*
          pub fn try_reserve(&mut self, additional: usize) -> Result<(), TryReserveError> {
              self.data.try_reserve(additional)
          }
      *)
      Definition try_reserve (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match τ, α with
        | [], [ self; additional ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let additional := M.alloc (| additional |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply (Ty.path "alloc::vec::Vec") [ T; A ],
                "try_reserve",
                []
              |),
              [
                M.SubPointer.get_struct_record_field (|
                  M.read (| self |),
                  "alloc::collections::binary_heap::BinaryHeap",
                  "data"
                |);
                M.read (| additional |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_try_reserve :
        forall (T A : Ty.t),
        M.IsAssociatedFunction (Self T A) "try_reserve" (try_reserve T A).
      
      (*
          pub fn shrink_to_fit(&mut self) {
              self.data.shrink_to_fit();
          }
      *)
      Definition shrink_to_fit (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              let~ _ :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply (Ty.path "alloc::vec::Vec") [ T; A ],
                      "shrink_to_fit",
                      []
                    |),
                    [
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "alloc::collections::binary_heap::BinaryHeap",
                        "data"
                      |)
                    ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_shrink_to_fit :
        forall (T A : Ty.t),
        M.IsAssociatedFunction (Self T A) "shrink_to_fit" (shrink_to_fit T A).
      
      (*
          pub fn shrink_to(&mut self, min_capacity: usize) {
              self.data.shrink_to(min_capacity)
          }
      *)
      Definition shrink_to (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match τ, α with
        | [], [ self; min_capacity ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let min_capacity := M.alloc (| min_capacity |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply (Ty.path "alloc::vec::Vec") [ T; A ],
                "shrink_to",
                []
              |),
              [
                M.SubPointer.get_struct_record_field (|
                  M.read (| self |),
                  "alloc::collections::binary_heap::BinaryHeap",
                  "data"
                |);
                M.read (| min_capacity |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_shrink_to :
        forall (T A : Ty.t),
        M.IsAssociatedFunction (Self T A) "shrink_to" (shrink_to T A).
      
      (*
          pub fn as_slice(&self) -> &[T] {
              self.data.as_slice()
          }
      *)
      Definition as_slice (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply (Ty.path "alloc::vec::Vec") [ T; A ],
                "as_slice",
                []
              |),
              [
                M.SubPointer.get_struct_record_field (|
                  M.read (| self |),
                  "alloc::collections::binary_heap::BinaryHeap",
                  "data"
                |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_as_slice :
        forall (T A : Ty.t),
        M.IsAssociatedFunction (Self T A) "as_slice" (as_slice T A).
      
      (*
          pub fn into_vec(self) -> Vec<T, A> {
              self.into()
          }
      *)
      Definition into_vec (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_trait_method (|
                "core::convert::Into",
                Ty.apply (Ty.path "alloc::collections::binary_heap::BinaryHeap") [ T; A ],
                [ Ty.apply (Ty.path "alloc::vec::Vec") [ T; A ] ],
                "into",
                []
              |),
              [ M.read (| self |) ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_into_vec :
        forall (T A : Ty.t),
        M.IsAssociatedFunction (Self T A) "into_vec" (into_vec T A).
      
      (*
          pub fn allocator(&self) -> &A {
              self.data.allocator()
          }
      *)
      Definition allocator (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply (Ty.path "alloc::vec::Vec") [ T; A ],
                "allocator",
                []
              |),
              [
                M.SubPointer.get_struct_record_field (|
                  M.read (| self |),
                  "alloc::collections::binary_heap::BinaryHeap",
                  "data"
                |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_allocator :
        forall (T A : Ty.t),
        M.IsAssociatedFunction (Self T A) "allocator" (allocator T A).
      
      (*
          pub fn len(&self) -> usize {
              self.data.len()
          }
      *)
      Definition len (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply (Ty.path "alloc::vec::Vec") [ T; A ],
                "len",
                []
              |),
              [
                M.SubPointer.get_struct_record_field (|
                  M.read (| self |),
                  "alloc::collections::binary_heap::BinaryHeap",
                  "data"
                |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_len :
        forall (T A : Ty.t),
        M.IsAssociatedFunction (Self T A) "len" (len T A).
      
      (*
          pub fn is_empty(&self) -> bool {
              self.len() == 0
          }
      *)
      Definition is_empty (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            BinOp.Pure.eq
              (M.call_closure (|
                M.get_associated_function (|
                  Ty.apply (Ty.path "alloc::collections::binary_heap::BinaryHeap") [ T; A ],
                  "len",
                  []
                |),
                [ M.read (| self |) ]
              |))
              (Value.Integer 0)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_is_empty :
        forall (T A : Ty.t),
        M.IsAssociatedFunction (Self T A) "is_empty" (is_empty T A).
      
      (*
          pub fn drain(&mut self) -> Drain<'_, T, A> {
              Drain { iter: self.data.drain(..) }
          }
      *)
      Definition drain (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructRecord
              "alloc::collections::binary_heap::Drain"
              [
                ("iter",
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply (Ty.path "alloc::vec::Vec") [ T; A ],
                      "drain",
                      [ Ty.path "core::ops::range::RangeFull" ]
                    |),
                    [
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "alloc::collections::binary_heap::BinaryHeap",
                        "data"
                      |);
                      Value.StructTuple "core::ops::range::RangeFull" []
                    ]
                  |))
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_drain :
        forall (T A : Ty.t),
        M.IsAssociatedFunction (Self T A) "drain" (drain T A).
      
      (*
          pub fn clear(&mut self) {
              self.drain();
          }
      *)
      Definition clear (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              let~ _ :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply (Ty.path "alloc::collections::binary_heap::BinaryHeap") [ T; A ],
                      "drain",
                      []
                    |),
                    [ M.read (| self |) ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_clear :
        forall (T A : Ty.t),
        M.IsAssociatedFunction (Self T A) "clear" (clear T A).
    End Impl_alloc_collections_binary_heap_BinaryHeap_T_A.
    
    
    (* StructRecord
      {
        name := "Hole";
        ty_params := [ "T" ];
        fields :=
          [
            ("data", Ty.apply (Ty.path "&mut") [ Ty.apply (Ty.path "slice") [ T ] ]);
            ("elt", Ty.apply (Ty.path "core::mem::manually_drop::ManuallyDrop") [ T ]);
            ("pos", Ty.path "usize")
          ];
      } *)
    
    Module Impl_alloc_collections_binary_heap_Hole_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "alloc::collections::binary_heap::Hole") [ T ].
      
      (*
          unsafe fn new(data: &'a mut [T], pos: usize) -> Self {
              debug_assert!(pos < data.len());
              // SAFE: pos should be inside the slice
              let elt = unsafe { ptr::read(data.get_unchecked(pos)) };
              Hole { data, elt: ManuallyDrop::new(elt), pos }
          }
      *)
      Definition new (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ data; pos ] =>
          ltac:(M.monadic
            (let data := M.alloc (| data |) in
            let pos := M.alloc (| pos |) in
            M.read (|
              let~ _ :=
                M.match_operator (|
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.use (M.alloc (| Value.Bool true |)) in
                        let _ :=
                          M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        let~ _ :=
                          M.match_operator (|
                            M.alloc (| Value.Tuple [] |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ :=
                                    M.use
                                      (M.alloc (|
                                        UnOp.Pure.not
                                          (BinOp.Pure.lt
                                            (M.read (| pos |))
                                            (M.call_closure (|
                                              M.get_associated_function (|
                                                Ty.apply (Ty.path "slice") [ T ],
                                                "len",
                                                []
                                              |),
                                              [ M.read (| data |) ]
                                            |)))
                                      |)) in
                                  let _ :=
                                    M.is_constant_or_break_match (|
                                      M.read (| γ |),
                                      Value.Bool true
                                    |) in
                                  M.alloc (|
                                    M.never_to_any (|
                                      M.call_closure (|
                                        M.get_function (| "core::panicking::panic", [] |),
                                        [
                                          M.read (|
                                            Value.String "assertion failed: pos < data.len()"
                                          |)
                                        ]
                                      |)
                                    |)
                                  |)));
                              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                            ]
                          |) in
                        M.alloc (| Value.Tuple [] |)));
                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                  ]
                |) in
              let~ elt :=
                M.alloc (|
                  M.call_closure (|
                    M.get_function (| "core::ptr::read", [ T ] |),
                    [
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "slice") [ T ],
                          "get_unchecked",
                          [ Ty.path "usize" ]
                        |),
                        [ M.read (| data |); M.read (| pos |) ]
                      |)
                    ]
                  |)
                |) in
              M.alloc (|
                Value.StructRecord
                  "alloc::collections::binary_heap::Hole"
                  [
                    ("data", M.read (| data |));
                    ("elt",
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "core::mem::manually_drop::ManuallyDrop") [ T ],
                          "new",
                          []
                        |),
                        [ M.read (| elt |) ]
                      |));
                    ("pos", M.read (| pos |))
                  ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_new :
        forall (T : Ty.t),
        M.IsAssociatedFunction (Self T) "new" (new T).
      
      (*
          fn pos(&self) -> usize {
              self.pos
          }
      *)
      Definition pos (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.SubPointer.get_struct_record_field (|
                M.read (| self |),
                "alloc::collections::binary_heap::Hole",
                "pos"
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_pos :
        forall (T : Ty.t),
        M.IsAssociatedFunction (Self T) "pos" (pos T).
      
      (*
          fn element(&self) -> &T {
              &self.elt
          }
      *)
      Definition element (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_trait_method (|
                "core::ops::deref::Deref",
                Ty.apply (Ty.path "core::mem::manually_drop::ManuallyDrop") [ T ],
                [],
                "deref",
                []
              |),
              [
                M.SubPointer.get_struct_record_field (|
                  M.read (| self |),
                  "alloc::collections::binary_heap::Hole",
                  "elt"
                |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_element :
        forall (T : Ty.t),
        M.IsAssociatedFunction (Self T) "element" (element T).
      
      (*
          unsafe fn get(&self, index: usize) -> &T {
              debug_assert!(index != self.pos);
              debug_assert!(index < self.data.len());
              unsafe { self.data.get_unchecked(index) }
          }
      *)
      Definition get (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ self; index ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let index := M.alloc (| index |) in
            M.read (|
              let~ _ :=
                M.match_operator (|
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.use (M.alloc (| Value.Bool true |)) in
                        let _ :=
                          M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        let~ _ :=
                          M.match_operator (|
                            M.alloc (| Value.Tuple [] |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ :=
                                    M.use
                                      (M.alloc (|
                                        UnOp.Pure.not
                                          (BinOp.Pure.ne
                                            (M.read (| index |))
                                            (M.read (|
                                              M.SubPointer.get_struct_record_field (|
                                                M.read (| self |),
                                                "alloc::collections::binary_heap::Hole",
                                                "pos"
                                              |)
                                            |)))
                                      |)) in
                                  let _ :=
                                    M.is_constant_or_break_match (|
                                      M.read (| γ |),
                                      Value.Bool true
                                    |) in
                                  M.alloc (|
                                    M.never_to_any (|
                                      M.call_closure (|
                                        M.get_function (| "core::panicking::panic", [] |),
                                        [
                                          M.read (|
                                            Value.String "assertion failed: index != self.pos"
                                          |)
                                        ]
                                      |)
                                    |)
                                  |)));
                              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                            ]
                          |) in
                        M.alloc (| Value.Tuple [] |)));
                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                  ]
                |) in
              let~ _ :=
                M.match_operator (|
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.use (M.alloc (| Value.Bool true |)) in
                        let _ :=
                          M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        let~ _ :=
                          M.match_operator (|
                            M.alloc (| Value.Tuple [] |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ :=
                                    M.use
                                      (M.alloc (|
                                        UnOp.Pure.not
                                          (BinOp.Pure.lt
                                            (M.read (| index |))
                                            (M.call_closure (|
                                              M.get_associated_function (|
                                                Ty.apply (Ty.path "slice") [ T ],
                                                "len",
                                                []
                                              |),
                                              [
                                                M.read (|
                                                  M.SubPointer.get_struct_record_field (|
                                                    M.read (| self |),
                                                    "alloc::collections::binary_heap::Hole",
                                                    "data"
                                                  |)
                                                |)
                                              ]
                                            |)))
                                      |)) in
                                  let _ :=
                                    M.is_constant_or_break_match (|
                                      M.read (| γ |),
                                      Value.Bool true
                                    |) in
                                  M.alloc (|
                                    M.never_to_any (|
                                      M.call_closure (|
                                        M.get_function (| "core::panicking::panic", [] |),
                                        [
                                          M.read (|
                                            Value.String "assertion failed: index < self.data.len()"
                                          |)
                                        ]
                                      |)
                                    |)
                                  |)));
                              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                            ]
                          |) in
                        M.alloc (| Value.Tuple [] |)));
                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                  ]
                |) in
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "slice") [ T ],
                    "get_unchecked",
                    [ Ty.path "usize" ]
                  |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "alloc::collections::binary_heap::Hole",
                        "data"
                      |)
                    |);
                    M.read (| index |)
                  ]
                |)
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_get :
        forall (T : Ty.t),
        M.IsAssociatedFunction (Self T) "get" (get T).
      
      (*
          unsafe fn move_to(&mut self, index: usize) {
              debug_assert!(index != self.pos);
              debug_assert!(index < self.data.len());
              unsafe {
                  let ptr = self.data.as_mut_ptr();
                  let index_ptr: *const _ = ptr.add(index);
                  let hole_ptr = ptr.add(self.pos);
                  ptr::copy_nonoverlapping(index_ptr, hole_ptr, 1);
              }
              self.pos = index;
          }
      *)
      Definition move_to (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ self; index ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let index := M.alloc (| index |) in
            M.read (|
              let~ _ :=
                M.match_operator (|
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.use (M.alloc (| Value.Bool true |)) in
                        let _ :=
                          M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        let~ _ :=
                          M.match_operator (|
                            M.alloc (| Value.Tuple [] |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ :=
                                    M.use
                                      (M.alloc (|
                                        UnOp.Pure.not
                                          (BinOp.Pure.ne
                                            (M.read (| index |))
                                            (M.read (|
                                              M.SubPointer.get_struct_record_field (|
                                                M.read (| self |),
                                                "alloc::collections::binary_heap::Hole",
                                                "pos"
                                              |)
                                            |)))
                                      |)) in
                                  let _ :=
                                    M.is_constant_or_break_match (|
                                      M.read (| γ |),
                                      Value.Bool true
                                    |) in
                                  M.alloc (|
                                    M.never_to_any (|
                                      M.call_closure (|
                                        M.get_function (| "core::panicking::panic", [] |),
                                        [
                                          M.read (|
                                            Value.String "assertion failed: index != self.pos"
                                          |)
                                        ]
                                      |)
                                    |)
                                  |)));
                              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                            ]
                          |) in
                        M.alloc (| Value.Tuple [] |)));
                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                  ]
                |) in
              let~ _ :=
                M.match_operator (|
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.use (M.alloc (| Value.Bool true |)) in
                        let _ :=
                          M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        let~ _ :=
                          M.match_operator (|
                            M.alloc (| Value.Tuple [] |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ :=
                                    M.use
                                      (M.alloc (|
                                        UnOp.Pure.not
                                          (BinOp.Pure.lt
                                            (M.read (| index |))
                                            (M.call_closure (|
                                              M.get_associated_function (|
                                                Ty.apply (Ty.path "slice") [ T ],
                                                "len",
                                                []
                                              |),
                                              [
                                                M.read (|
                                                  M.SubPointer.get_struct_record_field (|
                                                    M.read (| self |),
                                                    "alloc::collections::binary_heap::Hole",
                                                    "data"
                                                  |)
                                                |)
                                              ]
                                            |)))
                                      |)) in
                                  let _ :=
                                    M.is_constant_or_break_match (|
                                      M.read (| γ |),
                                      Value.Bool true
                                    |) in
                                  M.alloc (|
                                    M.never_to_any (|
                                      M.call_closure (|
                                        M.get_function (| "core::panicking::panic", [] |),
                                        [
                                          M.read (|
                                            Value.String "assertion failed: index < self.data.len()"
                                          |)
                                        ]
                                      |)
                                    |)
                                  |)));
                              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                            ]
                          |) in
                        M.alloc (| Value.Tuple [] |)));
                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                  ]
                |) in
              let~ _ :=
                let~ ptr :=
                  M.alloc (|
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "slice") [ T ],
                        "as_mut_ptr",
                        []
                      |),
                      [
                        M.read (|
                          M.SubPointer.get_struct_record_field (|
                            M.read (| self |),
                            "alloc::collections::binary_heap::Hole",
                            "data"
                          |)
                        |)
                      ]
                    |)
                  |) in
                let~ index_ptr :=
                  M.alloc (|
                    (* MutToConstPointer *)
                    M.pointer_coercion
                      (M.call_closure (|
                        M.get_associated_function (| Ty.apply (Ty.path "*mut") [ T ], "add", [] |),
                        [ M.read (| ptr |); M.read (| index |) ]
                      |))
                  |) in
                let~ hole_ptr :=
                  M.alloc (|
                    M.call_closure (|
                      M.get_associated_function (| Ty.apply (Ty.path "*mut") [ T ], "add", [] |),
                      [
                        M.read (| ptr |);
                        M.read (|
                          M.SubPointer.get_struct_record_field (|
                            M.read (| self |),
                            "alloc::collections::binary_heap::Hole",
                            "pos"
                          |)
                        |)
                      ]
                    |)
                  |) in
                let~ _ :=
                  M.alloc (|
                    M.call_closure (|
                      M.get_function (| "core::intrinsics::copy_nonoverlapping", [ T ] |),
                      [ M.read (| index_ptr |); M.read (| hole_ptr |); Value.Integer 1 ]
                    |)
                  |) in
                M.alloc (| Value.Tuple [] |) in
              let~ _ :=
                M.write (|
                  M.SubPointer.get_struct_record_field (|
                    M.read (| self |),
                    "alloc::collections::binary_heap::Hole",
                    "pos"
                  |),
                  M.read (| index |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_move_to :
        forall (T : Ty.t),
        M.IsAssociatedFunction (Self T) "move_to" (move_to T).
    End Impl_alloc_collections_binary_heap_Hole_T.
    
    Module Impl_core_ops_drop_Drop_for_alloc_collections_binary_heap_Hole_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "alloc::collections::binary_heap::Hole") [ T ].
      
      (*
          fn drop(&mut self) {
              // fill the hole again
              unsafe {
                  let pos = self.pos;
                  ptr::copy_nonoverlapping(&*self.elt, self.data.get_unchecked_mut(pos), 1);
              }
          }
      *)
      Definition drop (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              let~ pos :=
                M.copy (|
                  M.SubPointer.get_struct_record_field (|
                    M.read (| self |),
                    "alloc::collections::binary_heap::Hole",
                    "pos"
                  |)
                |) in
              let~ _ :=
                M.alloc (|
                  M.call_closure (|
                    M.get_function (| "core::intrinsics::copy_nonoverlapping", [ T ] |),
                    [
                      M.call_closure (|
                        M.get_trait_method (|
                          "core::ops::deref::Deref",
                          Ty.apply (Ty.path "core::mem::manually_drop::ManuallyDrop") [ T ],
                          [],
                          "deref",
                          []
                        |),
                        [
                          M.SubPointer.get_struct_record_field (|
                            M.read (| self |),
                            "alloc::collections::binary_heap::Hole",
                            "elt"
                          |)
                        ]
                      |);
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "slice") [ T ],
                          "get_unchecked_mut",
                          [ Ty.path "usize" ]
                        |),
                        [
                          M.read (|
                            M.SubPointer.get_struct_record_field (|
                              M.read (| self |),
                              "alloc::collections::binary_heap::Hole",
                              "data"
                            |)
                          |);
                          M.read (| pos |)
                        ]
                      |);
                      Value.Integer 1
                    ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::ops::drop::Drop"
          (Self T)
          (* Trait polymorphic types *) []
          (* Instance *) [ ("drop", InstanceField.Method (drop T)) ].
    End Impl_core_ops_drop_Drop_for_alloc_collections_binary_heap_Hole_T.
    
    (* StructRecord
      {
        name := "Iter";
        ty_params := [ "T" ];
        fields := [ ("iter", Ty.apply (Ty.path "core::slice::iter::Iter") [ T ]) ];
      } *)
    
    Module Impl_core_fmt_Debug_where_core_fmt_Debug_T_for_alloc_collections_binary_heap_Iter_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "alloc::collections::binary_heap::Iter") [ T ].
      
      (*
          fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
              f.debug_tuple("Iter").field(&self.iter.as_slice()).finish()
          }
      *)
      Definition fmt (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "core::fmt::builders::DebugTuple",
                "finish",
                []
              |),
              [
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.path "core::fmt::builders::DebugTuple",
                    "field",
                    []
                  |),
                  [
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "debug_tuple",
                          []
                        |),
                        [ M.read (| f |); M.read (| Value.String "Iter" |) ]
                      |)
                    |);
                    (* Unsize *)
                    M.pointer_coercion
                      (M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.apply (Ty.path "core::slice::iter::Iter") [ T ],
                            "as_slice",
                            []
                          |),
                          [
                            M.SubPointer.get_struct_record_field (|
                              M.read (| self |),
                              "alloc::collections::binary_heap::Iter",
                              "iter"
                            |)
                          ]
                        |)
                      |))
                  ]
                |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::fmt::Debug"
          (Self T)
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method (fmt T)) ].
    End Impl_core_fmt_Debug_where_core_fmt_Debug_T_for_alloc_collections_binary_heap_Iter_T.
    
    Module Impl_core_clone_Clone_for_alloc_collections_binary_heap_Iter_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "alloc::collections::binary_heap::Iter") [ T ].
      
      (*
          fn clone(&self) -> Self {
              Iter { iter: self.iter.clone() }
          }
      *)
      Definition clone (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructRecord
              "alloc::collections::binary_heap::Iter"
              [
                ("iter",
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::clone::Clone",
                      Ty.apply (Ty.path "core::slice::iter::Iter") [ T ],
                      [],
                      "clone",
                      []
                    |),
                    [
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "alloc::collections::binary_heap::Iter",
                        "iter"
                      |)
                    ]
                  |))
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::clone::Clone"
          (Self T)
          (* Trait polymorphic types *) []
          (* Instance *) [ ("clone", InstanceField.Method (clone T)) ].
    End Impl_core_clone_Clone_for_alloc_collections_binary_heap_Iter_T.
    
    Module Impl_core_iter_traits_iterator_Iterator_for_alloc_collections_binary_heap_Iter_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "alloc::collections::binary_heap::Iter") [ T ].
      
      (*     type Item = &'a T; *)
      Definition _Item (T : Ty.t) : Ty.t := Ty.apply (Ty.path "&") [ T ].
      
      (*
          fn next(&mut self) -> Option<&'a T> {
              self.iter.next()
          }
      *)
      Definition next (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_trait_method (|
                "core::iter::traits::iterator::Iterator",
                Ty.apply (Ty.path "core::slice::iter::Iter") [ T ],
                [],
                "next",
                []
              |),
              [
                M.SubPointer.get_struct_record_field (|
                  M.read (| self |),
                  "alloc::collections::binary_heap::Iter",
                  "iter"
                |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      (*
          fn size_hint(&self) -> (usize, Option<usize>) {
              self.iter.size_hint()
          }
      *)
      Definition size_hint (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_trait_method (|
                "core::iter::traits::iterator::Iterator",
                Ty.apply (Ty.path "core::slice::iter::Iter") [ T ],
                [],
                "size_hint",
                []
              |),
              [
                M.SubPointer.get_struct_record_field (|
                  M.read (| self |),
                  "alloc::collections::binary_heap::Iter",
                  "iter"
                |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      (*
          fn last(self) -> Option<&'a T> {
              self.iter.last()
          }
      *)
      Definition last (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_trait_method (|
                "core::iter::traits::iterator::Iterator",
                Ty.apply (Ty.path "core::slice::iter::Iter") [ T ],
                [],
                "last",
                []
              |),
              [
                M.read (|
                  M.SubPointer.get_struct_record_field (|
                    self,
                    "alloc::collections::binary_heap::Iter",
                    "iter"
                  |)
                |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::iterator::Iterator"
          (Self T)
          (* Trait polymorphic types *) []
          (* Instance *)
          [
            ("Item", InstanceField.Ty (_Item T));
            ("next", InstanceField.Method (next T));
            ("size_hint", InstanceField.Method (size_hint T));
            ("last", InstanceField.Method (last T))
          ].
    End Impl_core_iter_traits_iterator_Iterator_for_alloc_collections_binary_heap_Iter_T.
    
    Module Impl_core_iter_traits_double_ended_DoubleEndedIterator_for_alloc_collections_binary_heap_Iter_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "alloc::collections::binary_heap::Iter") [ T ].
      
      (*
          fn next_back(&mut self) -> Option<&'a T> {
              self.iter.next_back()
          }
      *)
      Definition next_back (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_trait_method (|
                "core::iter::traits::double_ended::DoubleEndedIterator",
                Ty.apply (Ty.path "core::slice::iter::Iter") [ T ],
                [],
                "next_back",
                []
              |),
              [
                M.SubPointer.get_struct_record_field (|
                  M.read (| self |),
                  "alloc::collections::binary_heap::Iter",
                  "iter"
                |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::double_ended::DoubleEndedIterator"
          (Self T)
          (* Trait polymorphic types *) []
          (* Instance *) [ ("next_back", InstanceField.Method (next_back T)) ].
    End Impl_core_iter_traits_double_ended_DoubleEndedIterator_for_alloc_collections_binary_heap_Iter_T.
    
    Module Impl_core_iter_traits_exact_size_ExactSizeIterator_for_alloc_collections_binary_heap_Iter_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "alloc::collections::binary_heap::Iter") [ T ].
      
      (*
          fn is_empty(&self) -> bool {
              self.iter.is_empty()
          }
      *)
      Definition is_empty (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_trait_method (|
                "core::iter::traits::exact_size::ExactSizeIterator",
                Ty.apply (Ty.path "core::slice::iter::Iter") [ T ],
                [],
                "is_empty",
                []
              |),
              [
                M.SubPointer.get_struct_record_field (|
                  M.read (| self |),
                  "alloc::collections::binary_heap::Iter",
                  "iter"
                |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::exact_size::ExactSizeIterator"
          (Self T)
          (* Trait polymorphic types *) []
          (* Instance *) [ ("is_empty", InstanceField.Method (is_empty T)) ].
    End Impl_core_iter_traits_exact_size_ExactSizeIterator_for_alloc_collections_binary_heap_Iter_T.
    
    Module Impl_core_iter_traits_marker_FusedIterator_for_alloc_collections_binary_heap_Iter_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "alloc::collections::binary_heap::Iter") [ T ].
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::marker::FusedIterator"
          (Self T)
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_iter_traits_marker_FusedIterator_for_alloc_collections_binary_heap_Iter_T.
    
    (* StructRecord
      {
        name := "IntoIter";
        ty_params := [ "T"; "A" ];
        fields := [ ("iter", Ty.apply (Ty.path "alloc::vec::into_iter::IntoIter") [ T; A ]) ];
      } *)
    
    Module Impl_core_clone_Clone_where_core_clone_Clone_T_where_core_clone_Clone_A_where_core_alloc_Allocator_A_for_alloc_collections_binary_heap_IntoIter_T_A.
      Definition Self (T A : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "alloc::collections::binary_heap::IntoIter") [ T; A ].
      
      (* Clone *)
      Definition clone (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructRecord
              "alloc::collections::binary_heap::IntoIter"
              [
                ("iter",
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::clone::Clone",
                      Ty.apply (Ty.path "alloc::vec::into_iter::IntoIter") [ T; A ],
                      [],
                      "clone",
                      []
                    |),
                    [
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "alloc::collections::binary_heap::IntoIter",
                        "iter"
                      |)
                    ]
                  |))
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (T A : Ty.t),
        M.IsTraitInstance
          "core::clone::Clone"
          (Self T A)
          (* Trait polymorphic types *) []
          (* Instance *) [ ("clone", InstanceField.Method (clone T A)) ].
    End Impl_core_clone_Clone_where_core_clone_Clone_T_where_core_clone_Clone_A_where_core_alloc_Allocator_A_for_alloc_collections_binary_heap_IntoIter_T_A.
    
    Module Impl_alloc_collections_binary_heap_IntoIter_T_A.
      Definition Self (T A : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "alloc::collections::binary_heap::IntoIter") [ T; A ].
      
      (*
          pub fn allocator(&self) -> &A {
              self.iter.allocator()
          }
      *)
      Definition allocator (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply (Ty.path "alloc::vec::into_iter::IntoIter") [ T; A ],
                "allocator",
                []
              |),
              [
                M.SubPointer.get_struct_record_field (|
                  M.read (| self |),
                  "alloc::collections::binary_heap::IntoIter",
                  "iter"
                |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_allocator :
        forall (T A : Ty.t),
        M.IsAssociatedFunction (Self T A) "allocator" (allocator T A).
    End Impl_alloc_collections_binary_heap_IntoIter_T_A.
    
    Module Impl_core_fmt_Debug_where_core_fmt_Debug_T_where_core_alloc_Allocator_A_for_alloc_collections_binary_heap_IntoIter_T_A.
      Definition Self (T A : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "alloc::collections::binary_heap::IntoIter") [ T; A ].
      
      (*
          fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
              f.debug_tuple("IntoIter").field(&self.iter.as_slice()).finish()
          }
      *)
      Definition fmt (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "core::fmt::builders::DebugTuple",
                "finish",
                []
              |),
              [
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.path "core::fmt::builders::DebugTuple",
                    "field",
                    []
                  |),
                  [
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "debug_tuple",
                          []
                        |),
                        [ M.read (| f |); M.read (| Value.String "IntoIter" |) ]
                      |)
                    |);
                    (* Unsize *)
                    M.pointer_coercion
                      (M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.apply (Ty.path "alloc::vec::into_iter::IntoIter") [ T; A ],
                            "as_slice",
                            []
                          |),
                          [
                            M.SubPointer.get_struct_record_field (|
                              M.read (| self |),
                              "alloc::collections::binary_heap::IntoIter",
                              "iter"
                            |)
                          ]
                        |)
                      |))
                  ]
                |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (T A : Ty.t),
        M.IsTraitInstance
          "core::fmt::Debug"
          (Self T A)
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method (fmt T A)) ].
    End Impl_core_fmt_Debug_where_core_fmt_Debug_T_where_core_alloc_Allocator_A_for_alloc_collections_binary_heap_IntoIter_T_A.
    
    Module Impl_core_iter_traits_iterator_Iterator_where_core_alloc_Allocator_A_for_alloc_collections_binary_heap_IntoIter_T_A.
      Definition Self (T A : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "alloc::collections::binary_heap::IntoIter") [ T; A ].
      
      (*     type Item = T; *)
      Definition _Item (T A : Ty.t) : Ty.t := T.
      
      (*
          fn next(&mut self) -> Option<T> {
              self.iter.next()
          }
      *)
      Definition next (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_trait_method (|
                "core::iter::traits::iterator::Iterator",
                Ty.apply (Ty.path "alloc::vec::into_iter::IntoIter") [ T; A ],
                [],
                "next",
                []
              |),
              [
                M.SubPointer.get_struct_record_field (|
                  M.read (| self |),
                  "alloc::collections::binary_heap::IntoIter",
                  "iter"
                |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      (*
          fn size_hint(&self) -> (usize, Option<usize>) {
              self.iter.size_hint()
          }
      *)
      Definition size_hint (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_trait_method (|
                "core::iter::traits::iterator::Iterator",
                Ty.apply (Ty.path "alloc::vec::into_iter::IntoIter") [ T; A ],
                [],
                "size_hint",
                []
              |),
              [
                M.SubPointer.get_struct_record_field (|
                  M.read (| self |),
                  "alloc::collections::binary_heap::IntoIter",
                  "iter"
                |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (T A : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::iterator::Iterator"
          (Self T A)
          (* Trait polymorphic types *) []
          (* Instance *)
          [
            ("Item", InstanceField.Ty (_Item T A));
            ("next", InstanceField.Method (next T A));
            ("size_hint", InstanceField.Method (size_hint T A))
          ].
    End Impl_core_iter_traits_iterator_Iterator_where_core_alloc_Allocator_A_for_alloc_collections_binary_heap_IntoIter_T_A.
    
    Module Impl_core_iter_traits_double_ended_DoubleEndedIterator_where_core_alloc_Allocator_A_for_alloc_collections_binary_heap_IntoIter_T_A.
      Definition Self (T A : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "alloc::collections::binary_heap::IntoIter") [ T; A ].
      
      (*
          fn next_back(&mut self) -> Option<T> {
              self.iter.next_back()
          }
      *)
      Definition next_back (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_trait_method (|
                "core::iter::traits::double_ended::DoubleEndedIterator",
                Ty.apply (Ty.path "alloc::vec::into_iter::IntoIter") [ T; A ],
                [],
                "next_back",
                []
              |),
              [
                M.SubPointer.get_struct_record_field (|
                  M.read (| self |),
                  "alloc::collections::binary_heap::IntoIter",
                  "iter"
                |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (T A : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::double_ended::DoubleEndedIterator"
          (Self T A)
          (* Trait polymorphic types *) []
          (* Instance *) [ ("next_back", InstanceField.Method (next_back T A)) ].
    End Impl_core_iter_traits_double_ended_DoubleEndedIterator_where_core_alloc_Allocator_A_for_alloc_collections_binary_heap_IntoIter_T_A.
    
    Module Impl_core_iter_traits_exact_size_ExactSizeIterator_where_core_alloc_Allocator_A_for_alloc_collections_binary_heap_IntoIter_T_A.
      Definition Self (T A : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "alloc::collections::binary_heap::IntoIter") [ T; A ].
      
      (*
          fn is_empty(&self) -> bool {
              self.iter.is_empty()
          }
      *)
      Definition is_empty (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_trait_method (|
                "core::iter::traits::exact_size::ExactSizeIterator",
                Ty.apply (Ty.path "alloc::vec::into_iter::IntoIter") [ T; A ],
                [],
                "is_empty",
                []
              |),
              [
                M.SubPointer.get_struct_record_field (|
                  M.read (| self |),
                  "alloc::collections::binary_heap::IntoIter",
                  "iter"
                |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (T A : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::exact_size::ExactSizeIterator"
          (Self T A)
          (* Trait polymorphic types *) []
          (* Instance *) [ ("is_empty", InstanceField.Method (is_empty T A)) ].
    End Impl_core_iter_traits_exact_size_ExactSizeIterator_where_core_alloc_Allocator_A_for_alloc_collections_binary_heap_IntoIter_T_A.
    
    Module Impl_core_iter_traits_marker_FusedIterator_where_core_alloc_Allocator_A_for_alloc_collections_binary_heap_IntoIter_T_A.
      Definition Self (T A : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "alloc::collections::binary_heap::IntoIter") [ T; A ].
      
      Axiom Implements :
        forall (T A : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::marker::FusedIterator"
          (Self T A)
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_iter_traits_marker_FusedIterator_where_core_alloc_Allocator_A_for_alloc_collections_binary_heap_IntoIter_T_A.
    
    Module Impl_core_iter_traits_marker_TrustedFused_where_core_alloc_Allocator_A_for_alloc_collections_binary_heap_IntoIter_T_A.
      Definition Self (T A : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "alloc::collections::binary_heap::IntoIter") [ T; A ].
      
      Axiom Implements :
        forall (T A : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::marker::TrustedFused"
          (Self T A)
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_iter_traits_marker_TrustedFused_where_core_alloc_Allocator_A_for_alloc_collections_binary_heap_IntoIter_T_A.
    
    Module Impl_core_default_Default_for_alloc_collections_binary_heap_IntoIter_T_alloc_alloc_Global.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply
          (Ty.path "alloc::collections::binary_heap::IntoIter")
          [ T; Ty.path "alloc::alloc::Global" ].
      
      (*
          fn default() -> Self {
              IntoIter { iter: Default::default() }
          }
      *)
      Definition default (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [] =>
          ltac:(M.monadic
            (Value.StructRecord
              "alloc::collections::binary_heap::IntoIter"
              [
                ("iter",
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::default::Default",
                      Ty.apply
                        (Ty.path "alloc::vec::into_iter::IntoIter")
                        [ T; Ty.path "alloc::alloc::Global" ],
                      [],
                      "default",
                      []
                    |),
                    []
                  |))
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::default::Default"
          (Self T)
          (* Trait polymorphic types *) []
          (* Instance *) [ ("default", InstanceField.Method (default T)) ].
    End Impl_core_default_Default_for_alloc_collections_binary_heap_IntoIter_T_alloc_alloc_Global.
    
    Module Impl_core_iter_adapters_SourceIter_where_core_alloc_Allocator_A_for_alloc_collections_binary_heap_IntoIter_T_A.
      Definition Self (T A : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "alloc::collections::binary_heap::IntoIter") [ T; A ].
      
      (*     type Source = IntoIter<T, A>; *)
      Definition _Source (T A : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "alloc::collections::binary_heap::IntoIter") [ T; A ].
      
      (*
          unsafe fn as_inner(&mut self) -> &mut Self::Source {
              self
          }
      *)
      Definition as_inner (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (| self |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (T A : Ty.t),
        M.IsTraitInstance
          "core::iter::adapters::SourceIter"
          (Self T A)
          (* Trait polymorphic types *) []
          (* Instance *)
          [
            ("Source", InstanceField.Ty (_Source T A));
            ("as_inner", InstanceField.Method (as_inner T A))
          ].
    End Impl_core_iter_adapters_SourceIter_where_core_alloc_Allocator_A_for_alloc_collections_binary_heap_IntoIter_T_A.
    
    Module Impl_core_iter_traits_marker_InPlaceIterable_where_core_alloc_Allocator_A_for_alloc_collections_binary_heap_IntoIter_I_A.
      Definition Self (I A : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "alloc::collections::binary_heap::IntoIter") [ I; A ].
      
      (*     const EXPAND_BY: Option<NonZeroUsize> = NonZeroUsize::new(1); *)
      (* Ty.apply (Ty.path "core::option::Option") [ Ty.path "core::num::nonzero::NonZeroUsize" ] *)
      Definition value_EXPAND_BY (I A : Ty.t) : Value.t :=
        let Self : Ty.t := Self I A in
        M.run
          ltac:(M.monadic
            (M.alloc (|
              M.call_closure (|
                M.get_associated_function (|
                  Ty.path "core::num::nonzero::NonZeroUsize",
                  "new",
                  []
                |),
                [ Value.Integer 1 ]
              |)
            |))).
      
      (*     const MERGE_BY: Option<NonZeroUsize> = NonZeroUsize::new(1); *)
      (* Ty.apply (Ty.path "core::option::Option") [ Ty.path "core::num::nonzero::NonZeroUsize" ] *)
      Definition value_MERGE_BY (I A : Ty.t) : Value.t :=
        let Self : Ty.t := Self I A in
        M.run
          ltac:(M.monadic
            (M.alloc (|
              M.call_closure (|
                M.get_associated_function (|
                  Ty.path "core::num::nonzero::NonZeroUsize",
                  "new",
                  []
                |),
                [ Value.Integer 1 ]
              |)
            |))).
      
      Axiom Implements :
        forall (I A : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::marker::InPlaceIterable"
          (Self I A)
          (* Trait polymorphic types *) []
          (* Instance *)
          [
            ("value_EXPAND_BY", InstanceField.Constant (value_EXPAND_BY I A));
            ("value_MERGE_BY", InstanceField.Constant (value_MERGE_BY I A))
          ].
    End Impl_core_iter_traits_marker_InPlaceIterable_where_core_alloc_Allocator_A_for_alloc_collections_binary_heap_IntoIter_I_A.
    
    Module Impl_alloc_vec_in_place_collect_AsVecIntoIter_for_alloc_collections_binary_heap_IntoIter_I_alloc_alloc_Global.
      Definition Self (I : Ty.t) : Ty.t :=
        Ty.apply
          (Ty.path "alloc::collections::binary_heap::IntoIter")
          [ I; Ty.path "alloc::alloc::Global" ].
      
      (*     type Item = I; *)
      Definition _Item (I : Ty.t) : Ty.t := I.
      
      (*
          fn as_into_iter(&mut self) -> &mut vec::IntoIter<Self::Item> {
              &mut self.iter
          }
      *)
      Definition as_into_iter (I : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self I in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.SubPointer.get_struct_record_field (|
              M.read (| self |),
              "alloc::collections::binary_heap::IntoIter",
              "iter"
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (I : Ty.t),
        M.IsTraitInstance
          "alloc::vec::in_place_collect::AsVecIntoIter"
          (Self I)
          (* Trait polymorphic types *) []
          (* Instance *)
          [
            ("Item", InstanceField.Ty (_Item I));
            ("as_into_iter", InstanceField.Method (as_into_iter I))
          ].
    End Impl_alloc_vec_in_place_collect_AsVecIntoIter_for_alloc_collections_binary_heap_IntoIter_I_alloc_alloc_Global.
    
    (* StructRecord
      {
        name := "IntoIterSorted";
        ty_params := [ "T"; "A" ];
        fields :=
          [ ("inner", Ty.apply (Ty.path "alloc::collections::binary_heap::BinaryHeap") [ T; A ]) ];
      } *)
    
    Module Impl_core_clone_Clone_where_core_clone_Clone_T_where_core_clone_Clone_A_where_core_alloc_Allocator_A_for_alloc_collections_binary_heap_IntoIterSorted_T_A.
      Definition Self (T A : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "alloc::collections::binary_heap::IntoIterSorted") [ T; A ].
      
      (* Clone *)
      Definition clone (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructRecord
              "alloc::collections::binary_heap::IntoIterSorted"
              [
                ("inner",
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::clone::Clone",
                      Ty.apply (Ty.path "alloc::collections::binary_heap::BinaryHeap") [ T; A ],
                      [],
                      "clone",
                      []
                    |),
                    [
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "alloc::collections::binary_heap::IntoIterSorted",
                        "inner"
                      |)
                    ]
                  |))
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (T A : Ty.t),
        M.IsTraitInstance
          "core::clone::Clone"
          (Self T A)
          (* Trait polymorphic types *) []
          (* Instance *) [ ("clone", InstanceField.Method (clone T A)) ].
    End Impl_core_clone_Clone_where_core_clone_Clone_T_where_core_clone_Clone_A_where_core_alloc_Allocator_A_for_alloc_collections_binary_heap_IntoIterSorted_T_A.
    
    Module Impl_core_fmt_Debug_where_core_fmt_Debug_T_where_core_fmt_Debug_A_where_core_alloc_Allocator_A_for_alloc_collections_binary_heap_IntoIterSorted_T_A.
      Definition Self (T A : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "alloc::collections::binary_heap::IntoIterSorted") [ T; A ].
      
      (* Debug *)
      Definition fmt (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "core::fmt::Formatter",
                "debug_struct_field1_finish",
                []
              |),
              [
                M.read (| f |);
                M.read (| Value.String "IntoIterSorted" |);
                M.read (| Value.String "inner" |);
                (* Unsize *)
                M.pointer_coercion
                  (M.alloc (|
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "alloc::collections::binary_heap::IntoIterSorted",
                      "inner"
                    |)
                  |))
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (T A : Ty.t),
        M.IsTraitInstance
          "core::fmt::Debug"
          (Self T A)
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method (fmt T A)) ].
    End Impl_core_fmt_Debug_where_core_fmt_Debug_T_where_core_fmt_Debug_A_where_core_alloc_Allocator_A_for_alloc_collections_binary_heap_IntoIterSorted_T_A.
    
    Module Impl_alloc_collections_binary_heap_IntoIterSorted_T_A.
      Definition Self (T A : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "alloc::collections::binary_heap::IntoIterSorted") [ T; A ].
      
      (*
          pub fn allocator(&self) -> &A {
              self.inner.allocator()
          }
      *)
      Definition allocator (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply (Ty.path "alloc::collections::binary_heap::BinaryHeap") [ T; A ],
                "allocator",
                []
              |),
              [
                M.SubPointer.get_struct_record_field (|
                  M.read (| self |),
                  "alloc::collections::binary_heap::IntoIterSorted",
                  "inner"
                |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_allocator :
        forall (T A : Ty.t),
        M.IsAssociatedFunction (Self T A) "allocator" (allocator T A).
    End Impl_alloc_collections_binary_heap_IntoIterSorted_T_A.
    
    Module Impl_core_iter_traits_iterator_Iterator_where_core_cmp_Ord_T_where_core_alloc_Allocator_A_for_alloc_collections_binary_heap_IntoIterSorted_T_A.
      Definition Self (T A : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "alloc::collections::binary_heap::IntoIterSorted") [ T; A ].
      
      (*     type Item = T; *)
      Definition _Item (T A : Ty.t) : Ty.t := T.
      
      (*
          fn next(&mut self) -> Option<T> {
              self.inner.pop()
          }
      *)
      Definition next (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply (Ty.path "alloc::collections::binary_heap::BinaryHeap") [ T; A ],
                "pop",
                []
              |),
              [
                M.SubPointer.get_struct_record_field (|
                  M.read (| self |),
                  "alloc::collections::binary_heap::IntoIterSorted",
                  "inner"
                |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      (*
          fn size_hint(&self) -> (usize, Option<usize>) {
              let exact = self.inner.len();
              (exact, Some(exact))
          }
      *)
      Definition size_hint (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              let~ exact :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply (Ty.path "alloc::collections::binary_heap::BinaryHeap") [ T; A ],
                      "len",
                      []
                    |),
                    [
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "alloc::collections::binary_heap::IntoIterSorted",
                        "inner"
                      |)
                    ]
                  |)
                |) in
              M.alloc (|
                Value.Tuple
                  [
                    M.read (| exact |);
                    Value.StructTuple "core::option::Option::Some" [ M.read (| exact |) ]
                  ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (T A : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::iterator::Iterator"
          (Self T A)
          (* Trait polymorphic types *) []
          (* Instance *)
          [
            ("Item", InstanceField.Ty (_Item T A));
            ("next", InstanceField.Method (next T A));
            ("size_hint", InstanceField.Method (size_hint T A))
          ].
    End Impl_core_iter_traits_iterator_Iterator_where_core_cmp_Ord_T_where_core_alloc_Allocator_A_for_alloc_collections_binary_heap_IntoIterSorted_T_A.
    
    Module Impl_core_iter_traits_exact_size_ExactSizeIterator_where_core_cmp_Ord_T_where_core_alloc_Allocator_A_for_alloc_collections_binary_heap_IntoIterSorted_T_A.
      Definition Self (T A : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "alloc::collections::binary_heap::IntoIterSorted") [ T; A ].
      
      Axiom Implements :
        forall (T A : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::exact_size::ExactSizeIterator"
          (Self T A)
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_iter_traits_exact_size_ExactSizeIterator_where_core_cmp_Ord_T_where_core_alloc_Allocator_A_for_alloc_collections_binary_heap_IntoIterSorted_T_A.
    
    Module Impl_core_iter_traits_marker_FusedIterator_where_core_cmp_Ord_T_where_core_alloc_Allocator_A_for_alloc_collections_binary_heap_IntoIterSorted_T_A.
      Definition Self (T A : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "alloc::collections::binary_heap::IntoIterSorted") [ T; A ].
      
      Axiom Implements :
        forall (T A : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::marker::FusedIterator"
          (Self T A)
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_iter_traits_marker_FusedIterator_where_core_cmp_Ord_T_where_core_alloc_Allocator_A_for_alloc_collections_binary_heap_IntoIterSorted_T_A.
    
    Module Impl_core_iter_traits_marker_TrustedLen_where_core_cmp_Ord_T_where_core_alloc_Allocator_A_for_alloc_collections_binary_heap_IntoIterSorted_T_A.
      Definition Self (T A : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "alloc::collections::binary_heap::IntoIterSorted") [ T; A ].
      
      Axiom Implements :
        forall (T A : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::marker::TrustedLen"
          (Self T A)
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_iter_traits_marker_TrustedLen_where_core_cmp_Ord_T_where_core_alloc_Allocator_A_for_alloc_collections_binary_heap_IntoIterSorted_T_A.
    
    (* StructRecord
      {
        name := "Drain";
        ty_params := [ "T"; "A" ];
        fields := [ ("iter", Ty.apply (Ty.path "alloc::vec::drain::Drain") [ T; A ]) ];
      } *)
    
    Module Impl_core_fmt_Debug_where_core_fmt_Debug_T_where_core_fmt_Debug_A_where_core_alloc_Allocator_A_for_alloc_collections_binary_heap_Drain_T_A.
      Definition Self (T A : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "alloc::collections::binary_heap::Drain") [ T; A ].
      
      (* Debug *)
      Definition fmt (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "core::fmt::Formatter",
                "debug_struct_field1_finish",
                []
              |),
              [
                M.read (| f |);
                M.read (| Value.String "Drain" |);
                M.read (| Value.String "iter" |);
                (* Unsize *)
                M.pointer_coercion
                  (M.alloc (|
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "alloc::collections::binary_heap::Drain",
                      "iter"
                    |)
                  |))
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (T A : Ty.t),
        M.IsTraitInstance
          "core::fmt::Debug"
          (Self T A)
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method (fmt T A)) ].
    End Impl_core_fmt_Debug_where_core_fmt_Debug_T_where_core_fmt_Debug_A_where_core_alloc_Allocator_A_for_alloc_collections_binary_heap_Drain_T_A.
    
    Module Impl_alloc_collections_binary_heap_Drain_T_A.
      Definition Self (T A : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "alloc::collections::binary_heap::Drain") [ T; A ].
      
      (*
          pub fn allocator(&self) -> &A {
              self.iter.allocator()
          }
      *)
      Definition allocator (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply (Ty.path "alloc::vec::drain::Drain") [ T; A ],
                "allocator",
                []
              |),
              [
                M.SubPointer.get_struct_record_field (|
                  M.read (| self |),
                  "alloc::collections::binary_heap::Drain",
                  "iter"
                |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_allocator :
        forall (T A : Ty.t),
        M.IsAssociatedFunction (Self T A) "allocator" (allocator T A).
    End Impl_alloc_collections_binary_heap_Drain_T_A.
    
    Module Impl_core_iter_traits_iterator_Iterator_where_core_alloc_Allocator_A_for_alloc_collections_binary_heap_Drain_T_A.
      Definition Self (T A : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "alloc::collections::binary_heap::Drain") [ T; A ].
      
      (*     type Item = T; *)
      Definition _Item (T A : Ty.t) : Ty.t := T.
      
      (*
          fn next(&mut self) -> Option<T> {
              self.iter.next()
          }
      *)
      Definition next (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_trait_method (|
                "core::iter::traits::iterator::Iterator",
                Ty.apply (Ty.path "alloc::vec::drain::Drain") [ T; A ],
                [],
                "next",
                []
              |),
              [
                M.SubPointer.get_struct_record_field (|
                  M.read (| self |),
                  "alloc::collections::binary_heap::Drain",
                  "iter"
                |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      (*
          fn size_hint(&self) -> (usize, Option<usize>) {
              self.iter.size_hint()
          }
      *)
      Definition size_hint (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_trait_method (|
                "core::iter::traits::iterator::Iterator",
                Ty.apply (Ty.path "alloc::vec::drain::Drain") [ T; A ],
                [],
                "size_hint",
                []
              |),
              [
                M.SubPointer.get_struct_record_field (|
                  M.read (| self |),
                  "alloc::collections::binary_heap::Drain",
                  "iter"
                |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (T A : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::iterator::Iterator"
          (Self T A)
          (* Trait polymorphic types *) []
          (* Instance *)
          [
            ("Item", InstanceField.Ty (_Item T A));
            ("next", InstanceField.Method (next T A));
            ("size_hint", InstanceField.Method (size_hint T A))
          ].
    End Impl_core_iter_traits_iterator_Iterator_where_core_alloc_Allocator_A_for_alloc_collections_binary_heap_Drain_T_A.
    
    Module Impl_core_iter_traits_double_ended_DoubleEndedIterator_where_core_alloc_Allocator_A_for_alloc_collections_binary_heap_Drain_T_A.
      Definition Self (T A : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "alloc::collections::binary_heap::Drain") [ T; A ].
      
      (*
          fn next_back(&mut self) -> Option<T> {
              self.iter.next_back()
          }
      *)
      Definition next_back (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_trait_method (|
                "core::iter::traits::double_ended::DoubleEndedIterator",
                Ty.apply (Ty.path "alloc::vec::drain::Drain") [ T; A ],
                [],
                "next_back",
                []
              |),
              [
                M.SubPointer.get_struct_record_field (|
                  M.read (| self |),
                  "alloc::collections::binary_heap::Drain",
                  "iter"
                |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (T A : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::double_ended::DoubleEndedIterator"
          (Self T A)
          (* Trait polymorphic types *) []
          (* Instance *) [ ("next_back", InstanceField.Method (next_back T A)) ].
    End Impl_core_iter_traits_double_ended_DoubleEndedIterator_where_core_alloc_Allocator_A_for_alloc_collections_binary_heap_Drain_T_A.
    
    Module Impl_core_iter_traits_exact_size_ExactSizeIterator_where_core_alloc_Allocator_A_for_alloc_collections_binary_heap_Drain_T_A.
      Definition Self (T A : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "alloc::collections::binary_heap::Drain") [ T; A ].
      
      (*
          fn is_empty(&self) -> bool {
              self.iter.is_empty()
          }
      *)
      Definition is_empty (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_trait_method (|
                "core::iter::traits::exact_size::ExactSizeIterator",
                Ty.apply (Ty.path "alloc::vec::drain::Drain") [ T; A ],
                [],
                "is_empty",
                []
              |),
              [
                M.SubPointer.get_struct_record_field (|
                  M.read (| self |),
                  "alloc::collections::binary_heap::Drain",
                  "iter"
                |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (T A : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::exact_size::ExactSizeIterator"
          (Self T A)
          (* Trait polymorphic types *) []
          (* Instance *) [ ("is_empty", InstanceField.Method (is_empty T A)) ].
    End Impl_core_iter_traits_exact_size_ExactSizeIterator_where_core_alloc_Allocator_A_for_alloc_collections_binary_heap_Drain_T_A.
    
    Module Impl_core_iter_traits_marker_FusedIterator_where_core_alloc_Allocator_A_for_alloc_collections_binary_heap_Drain_T_A.
      Definition Self (T A : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "alloc::collections::binary_heap::Drain") [ T; A ].
      
      Axiom Implements :
        forall (T A : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::marker::FusedIterator"
          (Self T A)
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_iter_traits_marker_FusedIterator_where_core_alloc_Allocator_A_for_alloc_collections_binary_heap_Drain_T_A.
    
    (* StructRecord
      {
        name := "DrainSorted";
        ty_params := [ "T"; "A" ];
        fields :=
          [
            ("inner",
              Ty.apply
                (Ty.path "&mut")
                [ Ty.apply (Ty.path "alloc::collections::binary_heap::BinaryHeap") [ T; A ] ])
          ];
      } *)
    
    Module Impl_core_fmt_Debug_where_core_fmt_Debug_T_where_core_cmp_Ord_T_where_core_fmt_Debug_A_where_core_alloc_Allocator_A_for_alloc_collections_binary_heap_DrainSorted_T_A.
      Definition Self (T A : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "alloc::collections::binary_heap::DrainSorted") [ T; A ].
      
      (* Debug *)
      Definition fmt (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "core::fmt::Formatter",
                "debug_struct_field1_finish",
                []
              |),
              [
                M.read (| f |);
                M.read (| Value.String "DrainSorted" |);
                M.read (| Value.String "inner" |);
                (* Unsize *)
                M.pointer_coercion
                  (M.alloc (|
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "alloc::collections::binary_heap::DrainSorted",
                      "inner"
                    |)
                  |))
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (T A : Ty.t),
        M.IsTraitInstance
          "core::fmt::Debug"
          (Self T A)
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method (fmt T A)) ].
    End Impl_core_fmt_Debug_where_core_fmt_Debug_T_where_core_cmp_Ord_T_where_core_fmt_Debug_A_where_core_alloc_Allocator_A_for_alloc_collections_binary_heap_DrainSorted_T_A.
    
    Module Impl_alloc_collections_binary_heap_DrainSorted_T_A.
      Definition Self (T A : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "alloc::collections::binary_heap::DrainSorted") [ T; A ].
      
      (*
          pub fn allocator(&self) -> &A {
              self.inner.allocator()
          }
      *)
      Definition allocator (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply (Ty.path "alloc::collections::binary_heap::BinaryHeap") [ T; A ],
                "allocator",
                []
              |),
              [
                M.read (|
                  M.SubPointer.get_struct_record_field (|
                    M.read (| self |),
                    "alloc::collections::binary_heap::DrainSorted",
                    "inner"
                  |)
                |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_allocator :
        forall (T A : Ty.t),
        M.IsAssociatedFunction (Self T A) "allocator" (allocator T A).
    End Impl_alloc_collections_binary_heap_DrainSorted_T_A.
    
    Module Impl_core_ops_drop_Drop_where_core_cmp_Ord_T_where_core_alloc_Allocator_A_for_alloc_collections_binary_heap_DrainSorted_T_A.
      Definition Self (T A : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "alloc::collections::binary_heap::DrainSorted") [ T; A ].
      
      (*
          fn drop(&mut self) {
              struct DropGuard<'r, 'a, T: Ord, A: Allocator>(&'r mut DrainSorted<'a, T, A>);
      
              impl<'r, 'a, T: Ord, A: Allocator> Drop for DropGuard<'r, 'a, T, A> {
                  fn drop(&mut self) {
                      while self.0.inner.pop().is_some() {}
                  }
              }
      
              while let Some(item) = self.inner.pop() {
                  let guard = DropGuard(self);
                  drop(item);
                  mem::forget(guard);
              }
          }
      *)
      Definition drop (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.loop (|
                ltac:(M.monadic
                  (M.match_operator (|
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.alloc (|
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "alloc::collections::binary_heap::BinaryHeap")
                                    [ T; A ],
                                  "pop",
                                  []
                                |),
                                [
                                  M.read (|
                                    M.SubPointer.get_struct_record_field (|
                                      M.read (| self |),
                                      "alloc::collections::binary_heap::DrainSorted",
                                      "inner"
                                    |)
                                  |)
                                ]
                              |)
                            |) in
                          let γ0_0 :=
                            M.SubPointer.get_struct_tuple_field (|
                              γ,
                              "core::option::Option::Some",
                              0
                            |) in
                          let item := M.copy (| γ0_0 |) in
                          let~ guard :=
                            M.alloc (|
                              Value.StructTuple
                                "alloc::collections::binary_heap::drop::DropGuard"
                                [ M.read (| self |) ]
                            |) in
                          let~ _ :=
                            M.alloc (|
                              M.call_closure (|
                                M.get_function (| "core::mem::drop", [ T ] |),
                                [ M.read (| item |) ]
                              |)
                            |) in
                          let~ _ :=
                            M.alloc (|
                              M.call_closure (|
                                M.get_function (|
                                  "core::mem::forget",
                                  [
                                    Ty.apply
                                      (Ty.path "alloc::collections::binary_heap::drop::DropGuard")
                                      [ T; A ]
                                  ]
                                |),
                                [ M.read (| guard |) ]
                              |)
                            |) in
                          M.alloc (| Value.Tuple [] |)));
                      fun γ =>
                        ltac:(M.monadic
                          (M.alloc (|
                            M.never_to_any (|
                              M.read (|
                                let~ _ :=
                                  M.alloc (| M.never_to_any (| M.read (| M.break (||) |) |) |) in
                                M.alloc (| Value.Tuple [] |)
                              |)
                            |)
                          |)))
                    ]
                  |)))
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (T A : Ty.t),
        M.IsTraitInstance
          "core::ops::drop::Drop"
          (Self T A)
          (* Trait polymorphic types *) []
          (* Instance *) [ ("drop", InstanceField.Method (drop T A)) ].
    End Impl_core_ops_drop_Drop_where_core_cmp_Ord_T_where_core_alloc_Allocator_A_for_alloc_collections_binary_heap_DrainSorted_T_A.
    
    Module Impl_core_iter_traits_iterator_Iterator_where_core_cmp_Ord_T_where_core_alloc_Allocator_A_for_alloc_collections_binary_heap_DrainSorted_T_A.
      Definition Self (T A : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "alloc::collections::binary_heap::DrainSorted") [ T; A ].
      
      (*     type Item = T; *)
      Definition _Item (T A : Ty.t) : Ty.t := T.
      
      (*
          fn next(&mut self) -> Option<T> {
              self.inner.pop()
          }
      *)
      Definition next (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply (Ty.path "alloc::collections::binary_heap::BinaryHeap") [ T; A ],
                "pop",
                []
              |),
              [
                M.read (|
                  M.SubPointer.get_struct_record_field (|
                    M.read (| self |),
                    "alloc::collections::binary_heap::DrainSorted",
                    "inner"
                  |)
                |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      (*
          fn size_hint(&self) -> (usize, Option<usize>) {
              let exact = self.inner.len();
              (exact, Some(exact))
          }
      *)
      Definition size_hint (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              let~ exact :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply (Ty.path "alloc::collections::binary_heap::BinaryHeap") [ T; A ],
                      "len",
                      []
                    |),
                    [
                      M.read (|
                        M.SubPointer.get_struct_record_field (|
                          M.read (| self |),
                          "alloc::collections::binary_heap::DrainSorted",
                          "inner"
                        |)
                      |)
                    ]
                  |)
                |) in
              M.alloc (|
                Value.Tuple
                  [
                    M.read (| exact |);
                    Value.StructTuple "core::option::Option::Some" [ M.read (| exact |) ]
                  ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (T A : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::iterator::Iterator"
          (Self T A)
          (* Trait polymorphic types *) []
          (* Instance *)
          [
            ("Item", InstanceField.Ty (_Item T A));
            ("next", InstanceField.Method (next T A));
            ("size_hint", InstanceField.Method (size_hint T A))
          ].
    End Impl_core_iter_traits_iterator_Iterator_where_core_cmp_Ord_T_where_core_alloc_Allocator_A_for_alloc_collections_binary_heap_DrainSorted_T_A.
    
    Module Impl_core_iter_traits_exact_size_ExactSizeIterator_where_core_cmp_Ord_T_where_core_alloc_Allocator_A_for_alloc_collections_binary_heap_DrainSorted_T_A.
      Definition Self (T A : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "alloc::collections::binary_heap::DrainSorted") [ T; A ].
      
      Axiom Implements :
        forall (T A : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::exact_size::ExactSizeIterator"
          (Self T A)
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_iter_traits_exact_size_ExactSizeIterator_where_core_cmp_Ord_T_where_core_alloc_Allocator_A_for_alloc_collections_binary_heap_DrainSorted_T_A.
    
    Module Impl_core_iter_traits_marker_FusedIterator_where_core_cmp_Ord_T_where_core_alloc_Allocator_A_for_alloc_collections_binary_heap_DrainSorted_T_A.
      Definition Self (T A : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "alloc::collections::binary_heap::DrainSorted") [ T; A ].
      
      Axiom Implements :
        forall (T A : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::marker::FusedIterator"
          (Self T A)
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_iter_traits_marker_FusedIterator_where_core_cmp_Ord_T_where_core_alloc_Allocator_A_for_alloc_collections_binary_heap_DrainSorted_T_A.
    
    Module Impl_core_iter_traits_marker_TrustedLen_where_core_cmp_Ord_T_where_core_alloc_Allocator_A_for_alloc_collections_binary_heap_DrainSorted_T_A.
      Definition Self (T A : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "alloc::collections::binary_heap::DrainSorted") [ T; A ].
      
      Axiom Implements :
        forall (T A : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::marker::TrustedLen"
          (Self T A)
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_iter_traits_marker_TrustedLen_where_core_cmp_Ord_T_where_core_alloc_Allocator_A_for_alloc_collections_binary_heap_DrainSorted_T_A.
    
    Module Impl_core_convert_From_where_core_cmp_Ord_T_where_core_alloc_Allocator_A_alloc_vec_Vec_T_A_for_alloc_collections_binary_heap_BinaryHeap_T_A.
      Definition Self (T A : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "alloc::collections::binary_heap::BinaryHeap") [ T; A ].
      
      (*
          fn from(vec: Vec<T, A>) -> BinaryHeap<T, A> {
              let mut heap = BinaryHeap { data: vec };
              heap.rebuild();
              heap
          }
      *)
      Definition from (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match τ, α with
        | [], [ vec ] =>
          ltac:(M.monadic
            (let vec := M.alloc (| vec |) in
            M.read (|
              let~ heap :=
                M.alloc (|
                  Value.StructRecord
                    "alloc::collections::binary_heap::BinaryHeap"
                    [ ("data", M.read (| vec |)) ]
                |) in
              let~ _ :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply (Ty.path "alloc::collections::binary_heap::BinaryHeap") [ T; A ],
                      "rebuild",
                      []
                    |),
                    [ heap ]
                  |)
                |) in
              heap
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (T A : Ty.t),
        M.IsTraitInstance
          "core::convert::From"
          (Self T A)
          (* Trait polymorphic types *) [ (* T *) Ty.apply (Ty.path "alloc::vec::Vec") [ T; A ] ]
          (* Instance *) [ ("from", InstanceField.Method (from T A)) ].
    End Impl_core_convert_From_where_core_cmp_Ord_T_where_core_alloc_Allocator_A_alloc_vec_Vec_T_A_for_alloc_collections_binary_heap_BinaryHeap_T_A.
    
    Module Impl_core_convert_From_where_core_cmp_Ord_T_array_T_for_alloc_collections_binary_heap_BinaryHeap_T_alloc_alloc_Global.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply
          (Ty.path "alloc::collections::binary_heap::BinaryHeap")
          [ T; Ty.path "alloc::alloc::Global" ].
      
      (*
          fn from(arr: [T; N]) -> Self {
              Self::from_iter(arr)
          }
      *)
      Definition from (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ arr ] =>
          ltac:(M.monadic
            (let arr := M.alloc (| arr |) in
            M.call_closure (|
              M.get_trait_method (|
                "core::iter::traits::collect::FromIterator",
                Ty.apply
                  (Ty.path "alloc::collections::binary_heap::BinaryHeap")
                  [ T; Ty.path "alloc::alloc::Global" ],
                [ T ],
                "from_iter",
                [ Ty.apply (Ty.path "array") [ T ] ]
              |),
              [ M.read (| arr |) ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::convert::From"
          (Self T)
          (* Trait polymorphic types *) [ (* T *) Ty.apply (Ty.path "array") [ T ] ]
          (* Instance *) [ ("from", InstanceField.Method (from T)) ].
    End Impl_core_convert_From_where_core_cmp_Ord_T_array_T_for_alloc_collections_binary_heap_BinaryHeap_T_alloc_alloc_Global.
    
    Module Impl_core_convert_From_where_core_alloc_Allocator_A_alloc_collections_binary_heap_BinaryHeap_T_A_for_alloc_vec_Vec_T_A.
      Definition Self (T A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::vec::Vec") [ T; A ].
      
      (*
          fn from(heap: BinaryHeap<T, A>) -> Vec<T, A> {
              heap.data
          }
      *)
      Definition from (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match τ, α with
        | [], [ heap ] =>
          ltac:(M.monadic
            (let heap := M.alloc (| heap |) in
            M.read (|
              M.SubPointer.get_struct_record_field (|
                heap,
                "alloc::collections::binary_heap::BinaryHeap",
                "data"
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (T A : Ty.t),
        M.IsTraitInstance
          "core::convert::From"
          (Self T A)
          (* Trait polymorphic types *)
          [ (* T *) Ty.apply (Ty.path "alloc::collections::binary_heap::BinaryHeap") [ T; A ] ]
          (* Instance *) [ ("from", InstanceField.Method (from T A)) ].
    End Impl_core_convert_From_where_core_alloc_Allocator_A_alloc_collections_binary_heap_BinaryHeap_T_A_for_alloc_vec_Vec_T_A.
    
    Module Impl_core_iter_traits_collect_FromIterator_where_core_cmp_Ord_T_T_for_alloc_collections_binary_heap_BinaryHeap_T_alloc_alloc_Global.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply
          (Ty.path "alloc::collections::binary_heap::BinaryHeap")
          [ T; Ty.path "alloc::alloc::Global" ].
      
      (*
          fn from_iter<I: IntoIterator<Item = T>>(iter: I) -> BinaryHeap<T> {
              BinaryHeap::from(iter.into_iter().collect::<Vec<_>>())
          }
      *)
      Definition from_iter (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [ _ as I ], [ iter ] =>
          ltac:(M.monadic
            (let iter := M.alloc (| iter |) in
            M.call_closure (|
              M.get_trait_method (|
                "core::convert::From",
                Ty.apply
                  (Ty.path "alloc::collections::binary_heap::BinaryHeap")
                  [ T; Ty.path "alloc::alloc::Global" ],
                [ Ty.apply (Ty.path "alloc::vec::Vec") [ T; Ty.path "alloc::alloc::Global" ] ],
                "from",
                []
              |),
              [
                M.call_closure (|
                  M.get_trait_method (|
                    "core::iter::traits::iterator::Iterator",
                    Ty.associated,
                    [],
                    "collect",
                    [ Ty.apply (Ty.path "alloc::vec::Vec") [ T; Ty.path "alloc::alloc::Global" ] ]
                  |),
                  [
                    M.call_closure (|
                      M.get_trait_method (|
                        "core::iter::traits::collect::IntoIterator",
                        I,
                        [],
                        "into_iter",
                        []
                      |),
                      [ M.read (| iter |) ]
                    |)
                  ]
                |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::collect::FromIterator"
          (Self T)
          (* Trait polymorphic types *) [ (* A *) T ]
          (* Instance *) [ ("from_iter", InstanceField.Method (from_iter T)) ].
    End Impl_core_iter_traits_collect_FromIterator_where_core_cmp_Ord_T_T_for_alloc_collections_binary_heap_BinaryHeap_T_alloc_alloc_Global.
    
    Module Impl_core_iter_traits_collect_IntoIterator_where_core_alloc_Allocator_A_for_alloc_collections_binary_heap_BinaryHeap_T_A.
      Definition Self (T A : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "alloc::collections::binary_heap::BinaryHeap") [ T; A ].
      
      (*     type Item = T; *)
      Definition _Item (T A : Ty.t) : Ty.t := T.
      
      (*     type IntoIter = IntoIter<T, A>; *)
      Definition _IntoIter (T A : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "alloc::collections::binary_heap::IntoIter") [ T; A ].
      
      (*
          fn into_iter(self) -> IntoIter<T, A> {
              IntoIter { iter: self.data.into_iter() }
          }
      *)
      Definition into_iter (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructRecord
              "alloc::collections::binary_heap::IntoIter"
              [
                ("iter",
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::iter::traits::collect::IntoIterator",
                      Ty.apply (Ty.path "alloc::vec::Vec") [ T; A ],
                      [],
                      "into_iter",
                      []
                    |),
                    [
                      M.read (|
                        M.SubPointer.get_struct_record_field (|
                          self,
                          "alloc::collections::binary_heap::BinaryHeap",
                          "data"
                        |)
                      |)
                    ]
                  |))
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (T A : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::collect::IntoIterator"
          (Self T A)
          (* Trait polymorphic types *) []
          (* Instance *)
          [
            ("Item", InstanceField.Ty (_Item T A));
            ("IntoIter", InstanceField.Ty (_IntoIter T A));
            ("into_iter", InstanceField.Method (into_iter T A))
          ].
    End Impl_core_iter_traits_collect_IntoIterator_where_core_alloc_Allocator_A_for_alloc_collections_binary_heap_BinaryHeap_T_A.
    
    Module Impl_core_iter_traits_collect_IntoIterator_where_core_alloc_Allocator_A_for_ref__alloc_collections_binary_heap_BinaryHeap_T_A.
      Definition Self (T A : Ty.t) : Ty.t :=
        Ty.apply
          (Ty.path "&")
          [ Ty.apply (Ty.path "alloc::collections::binary_heap::BinaryHeap") [ T; A ] ].
      
      (*     type Item = &'a T; *)
      Definition _Item (T A : Ty.t) : Ty.t := Ty.apply (Ty.path "&") [ T ].
      
      (*     type IntoIter = Iter<'a, T>; *)
      Definition _IntoIter (T A : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "alloc::collections::binary_heap::Iter") [ T ].
      
      (*
          fn into_iter(self) -> Iter<'a, T> {
              self.iter()
          }
      *)
      Definition into_iter (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply (Ty.path "alloc::collections::binary_heap::BinaryHeap") [ T; A ],
                "iter",
                []
              |),
              [ M.read (| self |) ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (T A : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::collect::IntoIterator"
          (Self T A)
          (* Trait polymorphic types *) []
          (* Instance *)
          [
            ("Item", InstanceField.Ty (_Item T A));
            ("IntoIter", InstanceField.Ty (_IntoIter T A));
            ("into_iter", InstanceField.Method (into_iter T A))
          ].
    End Impl_core_iter_traits_collect_IntoIterator_where_core_alloc_Allocator_A_for_ref__alloc_collections_binary_heap_BinaryHeap_T_A.
    
    Module Impl_core_iter_traits_collect_Extend_where_core_cmp_Ord_T_where_core_alloc_Allocator_A_T_for_alloc_collections_binary_heap_BinaryHeap_T_A.
      Definition Self (T A : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "alloc::collections::binary_heap::BinaryHeap") [ T; A ].
      
      (*
          fn extend<I: IntoIterator<Item = T>>(&mut self, iter: I) {
              let guard = RebuildOnDrop { rebuild_from: self.len(), heap: self };
              guard.heap.data.extend(iter);
          }
      *)
      Definition extend (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match τ, α with
        | [ _ as I ], [ self; iter ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let iter := M.alloc (| iter |) in
            M.read (|
              let~ guard :=
                M.alloc (|
                  Value.StructRecord
                    "alloc::collections::binary_heap::RebuildOnDrop"
                    [
                      ("rebuild_from",
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.apply
                              (Ty.path "alloc::collections::binary_heap::BinaryHeap")
                              [ T; A ],
                            "len",
                            []
                          |),
                          [ M.read (| self |) ]
                        |));
                      ("heap", M.read (| self |))
                    ]
                |) in
              let~ _ :=
                M.alloc (|
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::iter::traits::collect::Extend",
                      Ty.apply (Ty.path "alloc::vec::Vec") [ T; A ],
                      [ T ],
                      "extend",
                      [ I ]
                    |),
                    [
                      M.SubPointer.get_struct_record_field (|
                        M.read (|
                          M.SubPointer.get_struct_record_field (|
                            guard,
                            "alloc::collections::binary_heap::RebuildOnDrop",
                            "heap"
                          |)
                        |),
                        "alloc::collections::binary_heap::BinaryHeap",
                        "data"
                      |);
                      M.read (| iter |)
                    ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      (*
          fn extend_one(&mut self, item: T) {
              self.push(item);
          }
      *)
      Definition extend_one (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match τ, α with
        | [], [ self; item ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let item := M.alloc (| item |) in
            M.read (|
              let~ _ :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply (Ty.path "alloc::collections::binary_heap::BinaryHeap") [ T; A ],
                      "push",
                      []
                    |),
                    [ M.read (| self |); M.read (| item |) ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      (*
          fn extend_reserve(&mut self, additional: usize) {
              self.reserve(additional);
          }
      *)
      Definition extend_reserve (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match τ, α with
        | [], [ self; additional ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let additional := M.alloc (| additional |) in
            M.read (|
              let~ _ :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply (Ty.path "alloc::collections::binary_heap::BinaryHeap") [ T; A ],
                      "reserve",
                      []
                    |),
                    [ M.read (| self |); M.read (| additional |) ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (T A : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::collect::Extend"
          (Self T A)
          (* Trait polymorphic types *) [ (* A *) T ]
          (* Instance *)
          [
            ("extend", InstanceField.Method (extend T A));
            ("extend_one", InstanceField.Method (extend_one T A));
            ("extend_reserve", InstanceField.Method (extend_reserve T A))
          ].
    End Impl_core_iter_traits_collect_Extend_where_core_cmp_Ord_T_where_core_alloc_Allocator_A_T_for_alloc_collections_binary_heap_BinaryHeap_T_A.
    
    Module Impl_core_iter_traits_collect_Extend_where_core_cmp_Ord_T_where_core_marker_Copy_T_where_core_alloc_Allocator_A_ref__T_for_alloc_collections_binary_heap_BinaryHeap_T_A.
      Definition Self (T A : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "alloc::collections::binary_heap::BinaryHeap") [ T; A ].
      
      (*
          fn extend<I: IntoIterator<Item = &'a T>>(&mut self, iter: I) {
              self.extend(iter.into_iter().cloned());
          }
      *)
      Definition extend (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match τ, α with
        | [ _ as I ], [ self; iter ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let iter := M.alloc (| iter |) in
            M.read (|
              let~ _ :=
                M.alloc (|
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::iter::traits::collect::Extend",
                      Ty.apply (Ty.path "alloc::collections::binary_heap::BinaryHeap") [ T; A ],
                      [ T ],
                      "extend",
                      [ Ty.apply (Ty.path "core::iter::adapters::cloned::Cloned") [ Ty.associated ]
                      ]
                    |),
                    [
                      M.read (| self |);
                      M.call_closure (|
                        M.get_trait_method (|
                          "core::iter::traits::iterator::Iterator",
                          Ty.associated,
                          [],
                          "cloned",
                          [ T ]
                        |),
                        [
                          M.call_closure (|
                            M.get_trait_method (|
                              "core::iter::traits::collect::IntoIterator",
                              I,
                              [],
                              "into_iter",
                              []
                            |),
                            [ M.read (| iter |) ]
                          |)
                        ]
                      |)
                    ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      (*
          fn extend_one(&mut self, &item: &'a T) {
              self.push(item);
          }
      *)
      Definition extend_one (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match τ, α with
        | [], [ self; β1 ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let β1 := M.alloc (| β1 |) in
            M.match_operator (|
              β1,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let item := M.copy (| γ |) in
                    M.read (|
                      let~ _ :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply
                                (Ty.path "alloc::collections::binary_heap::BinaryHeap")
                                [ T; A ],
                              "push",
                              []
                            |),
                            [ M.read (| self |); M.read (| item |) ]
                          |)
                        |) in
                      M.alloc (| Value.Tuple [] |)
                    |)))
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      (*
          fn extend_reserve(&mut self, additional: usize) {
              self.reserve(additional);
          }
      *)
      Definition extend_reserve (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match τ, α with
        | [], [ self; additional ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let additional := M.alloc (| additional |) in
            M.read (|
              let~ _ :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply (Ty.path "alloc::collections::binary_heap::BinaryHeap") [ T; A ],
                      "reserve",
                      []
                    |),
                    [ M.read (| self |); M.read (| additional |) ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (T A : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::collect::Extend"
          (Self T A)
          (* Trait polymorphic types *) [ (* A *) Ty.apply (Ty.path "&") [ T ] ]
          (* Instance *)
          [
            ("extend", InstanceField.Method (extend T A));
            ("extend_one", InstanceField.Method (extend_one T A));
            ("extend_reserve", InstanceField.Method (extend_reserve T A))
          ].
    End Impl_core_iter_traits_collect_Extend_where_core_cmp_Ord_T_where_core_marker_Copy_T_where_core_alloc_Allocator_A_ref__T_for_alloc_collections_binary_heap_BinaryHeap_T_A.
  End binary_heap.
End collections.
