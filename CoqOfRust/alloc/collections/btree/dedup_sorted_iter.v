(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module collections.
  Module btree.
    Module dedup_sorted_iter.
      (* StructRecord
        {
          name := "DedupSortedIter";
          const_params := [];
          ty_params := [ "K"; "V"; "I" ];
          fields :=
            [ ("iter", Ty.apply (Ty.path "core::iter::adapters::peekable::Peekable") [] [ I ]) ];
        } *)
      
      Module Impl_alloc_collections_btree_dedup_sorted_iter_DedupSortedIter_K_V_I.
        Definition Self (K V I : Ty.t) : Ty.t :=
          Ty.apply
            (Ty.path "alloc::collections::btree::dedup_sorted_iter::DedupSortedIter")
            []
            [ K; V; I ].
        
        (*
            pub fn new(iter: I) -> Self {
                Self { iter: iter.peekable() }
            }
        *)
        Definition new (K V I : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self K V I in
          match ε, τ, α with
          | [], [], [ iter ] =>
            ltac:(M.monadic
              (let iter := M.alloc (| iter |) in
              Value.StructRecord
                "alloc::collections::btree::dedup_sorted_iter::DedupSortedIter"
                []
                [ K; V; I ]
                [
                  ("iter",
                    M.call_closure (|
                      Ty.apply (Ty.path "core::iter::adapters::peekable::Peekable") [] [ I ],
                      M.get_trait_method (|
                        "core::iter::traits::iterator::Iterator",
                        I,
                        [],
                        [],
                        "peekable",
                        [],
                        []
                      |),
                      [ M.read (| iter |) ]
                    |))
                ]))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Global Instance AssociatedFunction_new :
          forall (K V I : Ty.t),
          M.IsAssociatedFunction.C (Self K V I) "new" (new K V I).
        Admitted.
        Global Typeclasses Opaque new.
      End Impl_alloc_collections_btree_dedup_sorted_iter_DedupSortedIter_K_V_I.
      
      Module Impl_core_iter_traits_iterator_Iterator_where_core_cmp_Eq_K_where_core_iter_traits_iterator_Iterator_I_for_alloc_collections_btree_dedup_sorted_iter_DedupSortedIter_K_V_I.
        Definition Self (K V I : Ty.t) : Ty.t :=
          Ty.apply
            (Ty.path "alloc::collections::btree::dedup_sorted_iter::DedupSortedIter")
            []
            [ K; V; I ].
        
        (*     type Item = (K, V); *)
        Definition _Item (K V I : Ty.t) : Ty.t := Ty.tuple [ K; V ].
        
        (*
            fn next(&mut self) -> Option<(K, V)> {
                loop {
                    let next = match self.iter.next() {
                        Some(next) => next,
                        None => return None,
                    };
        
                    let peeked = match self.iter.peek() {
                        Some(peeked) => peeked,
                        None => return Some(next),
                    };
        
                    if next.0 != peeked.0 {
                        return Some(next);
                    }
                }
            }
        *)
        Definition next (K V I : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self K V I in
          match ε, τ, α with
          | [], [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              M.read (|
                M.catch_return
                  (Ty.apply (Ty.path "core::option::Option") [] [ Ty.tuple [ K; V ] ]) (|
                  ltac:(M.monadic
                    (M.alloc (|
                      M.never_to_any (|
                        M.read (|
                          M.loop (|
                            Ty.path "never",
                            ltac:(M.monadic
                              (let~ next : Ty.tuple [ K; V ] :=
                                M.read (|
                                  M.match_operator (|
                                    Ty.tuple [ K; V ],
                                    M.alloc (|
                                      M.call_closure (|
                                        Ty.apply
                                          (Ty.path "core::option::Option")
                                          []
                                          [ Ty.tuple [ K; V ] ],
                                        M.get_trait_method (|
                                          "core::iter::traits::iterator::Iterator",
                                          Ty.apply
                                            (Ty.path "core::iter::adapters::peekable::Peekable")
                                            []
                                            [ I ],
                                          [],
                                          [],
                                          "next",
                                          [],
                                          []
                                        |),
                                        [
                                          M.borrow (|
                                            Pointer.Kind.MutRef,
                                            M.SubPointer.get_struct_record_field (|
                                              M.deref (| M.read (| self |) |),
                                              "alloc::collections::btree::dedup_sorted_iter::DedupSortedIter",
                                              "iter"
                                            |)
                                          |)
                                        ]
                                      |)
                                    |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let γ0_0 :=
                                            M.SubPointer.get_struct_tuple_field (|
                                              γ,
                                              "core::option::Option::Some",
                                              0
                                            |) in
                                          let next := M.copy (| γ0_0 |) in
                                          next));
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let _ :=
                                            M.is_struct_tuple (|
                                              γ,
                                              "core::option::Option::None"
                                            |) in
                                          M.alloc (|
                                            M.never_to_any (|
                                              M.read (|
                                                M.return_ (|
                                                  Value.StructTuple
                                                    "core::option::Option::None"
                                                    []
                                                    [ Ty.tuple [ K; V ] ]
                                                    []
                                                |)
                                              |)
                                            |)
                                          |)))
                                    ]
                                  |)
                                |) in
                              let~ peeked : Ty.apply (Ty.path "&") [] [ Ty.tuple [ K; V ] ] :=
                                M.read (|
                                  M.match_operator (|
                                    Ty.apply (Ty.path "&") [] [ Ty.tuple [ K; V ] ],
                                    M.alloc (|
                                      M.call_closure (|
                                        Ty.apply
                                          (Ty.path "core::option::Option")
                                          []
                                          [ Ty.apply (Ty.path "&") [] [ Ty.tuple [ K; V ] ] ],
                                        M.get_associated_function (|
                                          Ty.apply
                                            (Ty.path "core::iter::adapters::peekable::Peekable")
                                            []
                                            [ I ],
                                          "peek",
                                          [],
                                          []
                                        |),
                                        [
                                          M.borrow (|
                                            Pointer.Kind.MutRef,
                                            M.SubPointer.get_struct_record_field (|
                                              M.deref (| M.read (| self |) |),
                                              "alloc::collections::btree::dedup_sorted_iter::DedupSortedIter",
                                              "iter"
                                            |)
                                          |)
                                        ]
                                      |)
                                    |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let γ0_0 :=
                                            M.SubPointer.get_struct_tuple_field (|
                                              γ,
                                              "core::option::Option::Some",
                                              0
                                            |) in
                                          let peeked := M.copy (| γ0_0 |) in
                                          peeked));
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let _ :=
                                            M.is_struct_tuple (|
                                              γ,
                                              "core::option::Option::None"
                                            |) in
                                          M.alloc (|
                                            M.never_to_any (|
                                              M.read (|
                                                M.return_ (|
                                                  Value.StructTuple
                                                    "core::option::Option::Some"
                                                    []
                                                    [ Ty.tuple [ K; V ] ]
                                                    [ M.read (| next |) ]
                                                |)
                                              |)
                                            |)
                                          |)))
                                    ]
                                  |)
                                |) in
                              M.match_operator (|
                                Ty.tuple [],
                                M.alloc (| Value.Tuple [] |),
                                [
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let γ :=
                                        M.use
                                          (M.alloc (|
                                            M.call_closure (|
                                              Ty.path "bool",
                                              M.get_trait_method (|
                                                "core::cmp::PartialEq",
                                                K,
                                                [],
                                                [ K ],
                                                "ne",
                                                [],
                                                []
                                              |),
                                              [
                                                M.borrow (|
                                                  Pointer.Kind.Ref,
                                                  M.SubPointer.get_tuple_field (| next, 0 |)
                                                |);
                                                M.borrow (|
                                                  Pointer.Kind.Ref,
                                                  M.SubPointer.get_tuple_field (|
                                                    M.deref (| M.read (| peeked |) |),
                                                    0
                                                  |)
                                                |)
                                              ]
                                            |)
                                          |)) in
                                      let _ :=
                                        is_constant_or_break_match (|
                                          M.read (| γ |),
                                          Value.Bool true
                                        |) in
                                      M.alloc (|
                                        M.never_to_any (|
                                          M.read (|
                                            M.return_ (|
                                              Value.StructTuple
                                                "core::option::Option::Some"
                                                []
                                                [ Ty.tuple [ K; V ] ]
                                                [ M.read (| next |) ]
                                            |)
                                          |)
                                        |)
                                      |)));
                                  fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                                ]
                              |)))
                          |)
                        |)
                      |)
                    |)))
                |)
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Axiom Implements :
          forall (K V I : Ty.t),
          M.IsTraitInstance
            "core::iter::traits::iterator::Iterator"
            (* Trait polymorphic consts *) []
            (* Trait polymorphic types *) []
            (Self K V I)
            (* Instance *)
            [ ("Item", InstanceField.Ty (_Item K V I)); ("next", InstanceField.Method (next K V I))
            ].
      End Impl_core_iter_traits_iterator_Iterator_where_core_cmp_Eq_K_where_core_iter_traits_iterator_Iterator_I_for_alloc_collections_btree_dedup_sorted_iter_DedupSortedIter_K_V_I.
    End dedup_sorted_iter.
  End btree.
End collections.
