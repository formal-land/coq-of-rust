(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module collections.
  Module btree.
    Module map.
      Module entry.
        (*
        Enum Entry
        {
          const_params := [];
          ty_params := [ "K"; "V"; "A" ];
          variants :=
            [
              {
                name := "Vacant";
                item :=
                  StructTuple
                    [
                      Ty.apply
                        (Ty.path "alloc::collections::btree::map::entry::VacantEntry")
                        []
                        [ K; V; A ]
                    ];
              };
              {
                name := "Occupied";
                item :=
                  StructTuple
                    [
                      Ty.apply
                        (Ty.path "alloc::collections::btree::map::entry::OccupiedEntry")
                        []
                        [ K; V; A ]
                    ];
              }
            ];
        }
        *)
        
        Axiom IsDiscriminant_Entry_Vacant :
          M.IsDiscriminant "alloc::collections::btree::map::entry::Entry::Vacant" 0.
        Axiom IsDiscriminant_Entry_Occupied :
          M.IsDiscriminant "alloc::collections::btree::map::entry::Entry::Occupied" 1.
        
        Module Impl_core_fmt_Debug_where_core_fmt_Debug_K_where_core_cmp_Ord_K_where_core_fmt_Debug_V_where_core_alloc_Allocator_A_where_core_clone_Clone_A_for_alloc_collections_btree_map_entry_Entry_K_V_A.
          Definition Self (K V A : Ty.t) : Ty.t :=
            Ty.apply (Ty.path "alloc::collections::btree::map::entry::Entry") [] [ K; V; A ].
          
          (*
              fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                  match *self {
                      Vacant(ref v) => f.debug_tuple("Entry").field(v).finish(),
                      Occupied(ref o) => f.debug_tuple("Entry").field(o).finish(),
                  }
              }
          *)
          Definition fmt (K V A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
            let Self : Ty.t := Self K V A in
            match ε, τ, α with
            | [], [], [ self; f ] =>
              ltac:(M.monadic
                (let self := M.alloc (| self |) in
                let f := M.alloc (| f |) in
                M.read (|
                  M.match_operator (|
                    Ty.apply
                      (Ty.path "*")
                      []
                      [
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ]
                      ],
                    M.deref (| M.read (| self |) |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ0_0 :=
                            M.SubPointer.get_struct_tuple_field (|
                              γ,
                              "alloc::collections::btree::map::entry::Entry::Vacant",
                              0
                            |) in
                          let v := M.alloc (| γ0_0 |) in
                          M.alloc (|
                            M.call_closure (|
                              Ty.apply
                                (Ty.path "core::result::Result")
                                []
                                [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                              M.get_associated_function (|
                                Ty.path "core::fmt::builders::DebugTuple",
                                "finish",
                                [],
                                []
                              |),
                              [
                                M.borrow (|
                                  Pointer.Kind.MutRef,
                                  M.deref (|
                                    M.call_closure (|
                                      Ty.apply
                                        (Ty.path "&mut")
                                        []
                                        [ Ty.path "core::fmt::builders::DebugTuple" ],
                                      M.get_associated_function (|
                                        Ty.path "core::fmt::builders::DebugTuple",
                                        "field",
                                        [],
                                        []
                                      |),
                                      [
                                        M.borrow (|
                                          Pointer.Kind.MutRef,
                                          M.alloc (|
                                            M.call_closure (|
                                              Ty.path "core::fmt::builders::DebugTuple",
                                              M.get_associated_function (|
                                                Ty.path "core::fmt::Formatter",
                                                "debug_tuple",
                                                [],
                                                []
                                              |),
                                              [
                                                M.borrow (|
                                                  Pointer.Kind.MutRef,
                                                  M.deref (| M.read (| f |) |)
                                                |);
                                                M.borrow (|
                                                  Pointer.Kind.Ref,
                                                  M.deref (| mk_str (| "Entry" |) |)
                                                |)
                                              ]
                                            |)
                                          |)
                                        |);
                                        (* Unsize *)
                                        M.pointer_coercion
                                          (M.borrow (|
                                            Pointer.Kind.Ref,
                                            M.deref (| M.read (| v |) |)
                                          |))
                                      ]
                                    |)
                                  |)
                                |)
                              ]
                            |)
                          |)));
                      fun γ =>
                        ltac:(M.monadic
                          (let γ0_0 :=
                            M.SubPointer.get_struct_tuple_field (|
                              γ,
                              "alloc::collections::btree::map::entry::Entry::Occupied",
                              0
                            |) in
                          let o := M.alloc (| γ0_0 |) in
                          M.alloc (|
                            M.call_closure (|
                              Ty.apply
                                (Ty.path "core::result::Result")
                                []
                                [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                              M.get_associated_function (|
                                Ty.path "core::fmt::builders::DebugTuple",
                                "finish",
                                [],
                                []
                              |),
                              [
                                M.borrow (|
                                  Pointer.Kind.MutRef,
                                  M.deref (|
                                    M.call_closure (|
                                      Ty.apply
                                        (Ty.path "&mut")
                                        []
                                        [ Ty.path "core::fmt::builders::DebugTuple" ],
                                      M.get_associated_function (|
                                        Ty.path "core::fmt::builders::DebugTuple",
                                        "field",
                                        [],
                                        []
                                      |),
                                      [
                                        M.borrow (|
                                          Pointer.Kind.MutRef,
                                          M.alloc (|
                                            M.call_closure (|
                                              Ty.path "core::fmt::builders::DebugTuple",
                                              M.get_associated_function (|
                                                Ty.path "core::fmt::Formatter",
                                                "debug_tuple",
                                                [],
                                                []
                                              |),
                                              [
                                                M.borrow (|
                                                  Pointer.Kind.MutRef,
                                                  M.deref (| M.read (| f |) |)
                                                |);
                                                M.borrow (|
                                                  Pointer.Kind.Ref,
                                                  M.deref (| mk_str (| "Entry" |) |)
                                                |)
                                              ]
                                            |)
                                          |)
                                        |);
                                        (* Unsize *)
                                        M.pointer_coercion
                                          (M.borrow (|
                                            Pointer.Kind.Ref,
                                            M.deref (| M.read (| o |) |)
                                          |))
                                      ]
                                    |)
                                  |)
                                |)
                              ]
                            |)
                          |)))
                    ]
                  |)
                |)))
            | _, _, _ => M.impossible "wrong number of arguments"
            end.
          
          Axiom Implements :
            forall (K V A : Ty.t),
            M.IsTraitInstance
              "core::fmt::Debug"
              (* Trait polymorphic consts *) []
              (* Trait polymorphic types *) []
              (Self K V A)
              (* Instance *) [ ("fmt", InstanceField.Method (fmt K V A)) ].
        End Impl_core_fmt_Debug_where_core_fmt_Debug_K_where_core_cmp_Ord_K_where_core_fmt_Debug_V_where_core_alloc_Allocator_A_where_core_clone_Clone_A_for_alloc_collections_btree_map_entry_Entry_K_V_A.
        
        (* StructRecord
          {
            name := "VacantEntry";
            const_params := [];
            ty_params := [ "K"; "V"; "A" ];
            fields :=
              [
                ("key", K);
                ("handle",
                  Ty.apply
                    (Ty.path "core::option::Option")
                    []
                    [
                      Ty.apply
                        (Ty.path "alloc::collections::btree::node::Handle")
                        []
                        [
                          Ty.apply
                            (Ty.path "alloc::collections::btree::node::NodeRef")
                            []
                            [
                              Ty.path "alloc::collections::btree::node::marker::Mut";
                              K;
                              V;
                              Ty.path "alloc::collections::btree::node::marker::Leaf"
                            ];
                          Ty.path "alloc::collections::btree::node::marker::Edge"
                        ]
                    ]);
                ("dormant_map",
                  Ty.apply
                    (Ty.path "alloc::collections::btree::borrow::DormantMutRef")
                    []
                    [ Ty.apply (Ty.path "alloc::collections::btree::map::BTreeMap") [] [ K; V; A ]
                    ]);
                ("alloc", A);
                ("_marker",
                  Ty.apply
                    (Ty.path "core::marker::PhantomData")
                    []
                    [ Ty.apply (Ty.path "&mut") [] [ Ty.tuple [ K; V ] ] ])
              ];
          } *)
        
        Module Impl_core_fmt_Debug_where_core_fmt_Debug_K_where_core_cmp_Ord_K_where_core_alloc_Allocator_A_where_core_clone_Clone_A_for_alloc_collections_btree_map_entry_VacantEntry_K_V_A.
          Definition Self (K V A : Ty.t) : Ty.t :=
            Ty.apply (Ty.path "alloc::collections::btree::map::entry::VacantEntry") [] [ K; V; A ].
          
          (*
              fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                  f.debug_tuple("VacantEntry").field(self.key()).finish()
              }
          *)
          Definition fmt (K V A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
            let Self : Ty.t := Self K V A in
            match ε, τ, α with
            | [], [], [ self; f ] =>
              ltac:(M.monadic
                (let self := M.alloc (| self |) in
                let f := M.alloc (| f |) in
                M.call_closure (|
                  Ty.apply
                    (Ty.path "core::result::Result")
                    []
                    [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                  M.get_associated_function (|
                    Ty.path "core::fmt::builders::DebugTuple",
                    "finish",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.MutRef,
                      M.deref (|
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "&mut")
                            []
                            [ Ty.path "core::fmt::builders::DebugTuple" ],
                          M.get_associated_function (|
                            Ty.path "core::fmt::builders::DebugTuple",
                            "field",
                            [],
                            []
                          |),
                          [
                            M.borrow (|
                              Pointer.Kind.MutRef,
                              M.alloc (|
                                M.call_closure (|
                                  Ty.path "core::fmt::builders::DebugTuple",
                                  M.get_associated_function (|
                                    Ty.path "core::fmt::Formatter",
                                    "debug_tuple",
                                    [],
                                    []
                                  |),
                                  [
                                    M.borrow (|
                                      Pointer.Kind.MutRef,
                                      M.deref (| M.read (| f |) |)
                                    |);
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.deref (| mk_str (| "VacantEntry" |) |)
                                    |)
                                  ]
                                |)
                              |)
                            |);
                            (* Unsize *)
                            M.pointer_coercion
                              (M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.call_closure (|
                                    Ty.apply (Ty.path "&") [] [ K ],
                                    M.get_associated_function (|
                                      Ty.apply
                                        (Ty.path
                                          "alloc::collections::btree::map::entry::VacantEntry")
                                        []
                                        [ K; V; A ],
                                      "key",
                                      [],
                                      []
                                    |),
                                    [
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.deref (| M.read (| self |) |)
                                      |)
                                    ]
                                  |)
                                |)
                              |))
                          ]
                        |)
                      |)
                    |)
                  ]
                |)))
            | _, _, _ => M.impossible "wrong number of arguments"
            end.
          
          Axiom Implements :
            forall (K V A : Ty.t),
            M.IsTraitInstance
              "core::fmt::Debug"
              (* Trait polymorphic consts *) []
              (* Trait polymorphic types *) []
              (Self K V A)
              (* Instance *) [ ("fmt", InstanceField.Method (fmt K V A)) ].
        End Impl_core_fmt_Debug_where_core_fmt_Debug_K_where_core_cmp_Ord_K_where_core_alloc_Allocator_A_where_core_clone_Clone_A_for_alloc_collections_btree_map_entry_VacantEntry_K_V_A.
        
        (* StructRecord
          {
            name := "OccupiedEntry";
            const_params := [];
            ty_params := [ "K"; "V"; "A" ];
            fields :=
              [
                ("handle",
                  Ty.apply
                    (Ty.path "alloc::collections::btree::node::Handle")
                    []
                    [
                      Ty.apply
                        (Ty.path "alloc::collections::btree::node::NodeRef")
                        []
                        [
                          Ty.path "alloc::collections::btree::node::marker::Mut";
                          K;
                          V;
                          Ty.path "alloc::collections::btree::node::marker::LeafOrInternal"
                        ];
                      Ty.path "alloc::collections::btree::node::marker::KV"
                    ]);
                ("dormant_map",
                  Ty.apply
                    (Ty.path "alloc::collections::btree::borrow::DormantMutRef")
                    []
                    [ Ty.apply (Ty.path "alloc::collections::btree::map::BTreeMap") [] [ K; V; A ]
                    ]);
                ("alloc", A);
                ("_marker",
                  Ty.apply
                    (Ty.path "core::marker::PhantomData")
                    []
                    [ Ty.apply (Ty.path "&mut") [] [ Ty.tuple [ K; V ] ] ])
              ];
          } *)
        
        Module Impl_core_fmt_Debug_where_core_fmt_Debug_K_where_core_cmp_Ord_K_where_core_fmt_Debug_V_where_core_alloc_Allocator_A_where_core_clone_Clone_A_for_alloc_collections_btree_map_entry_OccupiedEntry_K_V_A.
          Definition Self (K V A : Ty.t) : Ty.t :=
            Ty.apply
              (Ty.path "alloc::collections::btree::map::entry::OccupiedEntry")
              []
              [ K; V; A ].
          
          (*
              fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                  f.debug_struct("OccupiedEntry").field("key", self.key()).field("value", self.get()).finish()
              }
          *)
          Definition fmt (K V A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
            let Self : Ty.t := Self K V A in
            match ε, τ, α with
            | [], [], [ self; f ] =>
              ltac:(M.monadic
                (let self := M.alloc (| self |) in
                let f := M.alloc (| f |) in
                M.call_closure (|
                  Ty.apply
                    (Ty.path "core::result::Result")
                    []
                    [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                  M.get_associated_function (|
                    Ty.path "core::fmt::builders::DebugStruct",
                    "finish",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.MutRef,
                      M.deref (|
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "&mut")
                            []
                            [ Ty.path "core::fmt::builders::DebugStruct" ],
                          M.get_associated_function (|
                            Ty.path "core::fmt::builders::DebugStruct",
                            "field",
                            [],
                            []
                          |),
                          [
                            M.borrow (|
                              Pointer.Kind.MutRef,
                              M.deref (|
                                M.call_closure (|
                                  Ty.apply
                                    (Ty.path "&mut")
                                    []
                                    [ Ty.path "core::fmt::builders::DebugStruct" ],
                                  M.get_associated_function (|
                                    Ty.path "core::fmt::builders::DebugStruct",
                                    "field",
                                    [],
                                    []
                                  |),
                                  [
                                    M.borrow (|
                                      Pointer.Kind.MutRef,
                                      M.alloc (|
                                        M.call_closure (|
                                          Ty.path "core::fmt::builders::DebugStruct",
                                          M.get_associated_function (|
                                            Ty.path "core::fmt::Formatter",
                                            "debug_struct",
                                            [],
                                            []
                                          |),
                                          [
                                            M.borrow (|
                                              Pointer.Kind.MutRef,
                                              M.deref (| M.read (| f |) |)
                                            |);
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.deref (| mk_str (| "OccupiedEntry" |) |)
                                            |)
                                          ]
                                        |)
                                      |)
                                    |);
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.deref (| mk_str (| "key" |) |)
                                    |);
                                    (* Unsize *)
                                    M.pointer_coercion
                                      (M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.deref (|
                                          M.call_closure (|
                                            Ty.apply (Ty.path "&") [] [ K ],
                                            M.get_associated_function (|
                                              Ty.apply
                                                (Ty.path
                                                  "alloc::collections::btree::map::entry::OccupiedEntry")
                                                []
                                                [ K; V; A ],
                                              "key",
                                              [],
                                              []
                                            |),
                                            [
                                              M.borrow (|
                                                Pointer.Kind.Ref,
                                                M.deref (| M.read (| self |) |)
                                              |)
                                            ]
                                          |)
                                        |)
                                      |))
                                  ]
                                |)
                              |)
                            |);
                            M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "value" |) |) |);
                            (* Unsize *)
                            M.pointer_coercion
                              (M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.call_closure (|
                                    Ty.apply (Ty.path "&") [] [ V ],
                                    M.get_associated_function (|
                                      Ty.apply
                                        (Ty.path
                                          "alloc::collections::btree::map::entry::OccupiedEntry")
                                        []
                                        [ K; V; A ],
                                      "get",
                                      [],
                                      []
                                    |),
                                    [
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.deref (| M.read (| self |) |)
                                      |)
                                    ]
                                  |)
                                |)
                              |))
                          ]
                        |)
                      |)
                    |)
                  ]
                |)))
            | _, _, _ => M.impossible "wrong number of arguments"
            end.
          
          Axiom Implements :
            forall (K V A : Ty.t),
            M.IsTraitInstance
              "core::fmt::Debug"
              (* Trait polymorphic consts *) []
              (* Trait polymorphic types *) []
              (Self K V A)
              (* Instance *) [ ("fmt", InstanceField.Method (fmt K V A)) ].
        End Impl_core_fmt_Debug_where_core_fmt_Debug_K_where_core_cmp_Ord_K_where_core_fmt_Debug_V_where_core_alloc_Allocator_A_where_core_clone_Clone_A_for_alloc_collections_btree_map_entry_OccupiedEntry_K_V_A.
        
        (* StructRecord
          {
            name := "OccupiedError";
            const_params := [];
            ty_params := [ "K"; "V"; "A" ];
            fields :=
              [
                ("entry",
                  Ty.apply
                    (Ty.path "alloc::collections::btree::map::entry::OccupiedEntry")
                    []
                    [ K; V; A ]);
                ("value", V)
              ];
          } *)
        
        Module Impl_core_fmt_Debug_where_core_fmt_Debug_K_where_core_cmp_Ord_K_where_core_fmt_Debug_V_where_core_alloc_Allocator_A_where_core_clone_Clone_A_for_alloc_collections_btree_map_entry_OccupiedError_K_V_A.
          Definition Self (K V A : Ty.t) : Ty.t :=
            Ty.apply
              (Ty.path "alloc::collections::btree::map::entry::OccupiedError")
              []
              [ K; V; A ].
          
          (*
              fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                  f.debug_struct("OccupiedError")
                      .field("key", self.entry.key())
                      .field("old_value", self.entry.get())
                      .field("new_value", &self.value)
                      .finish()
              }
          *)
          Definition fmt (K V A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
            let Self : Ty.t := Self K V A in
            match ε, τ, α with
            | [], [], [ self; f ] =>
              ltac:(M.monadic
                (let self := M.alloc (| self |) in
                let f := M.alloc (| f |) in
                M.call_closure (|
                  Ty.apply
                    (Ty.path "core::result::Result")
                    []
                    [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                  M.get_associated_function (|
                    Ty.path "core::fmt::builders::DebugStruct",
                    "finish",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.MutRef,
                      M.deref (|
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "&mut")
                            []
                            [ Ty.path "core::fmt::builders::DebugStruct" ],
                          M.get_associated_function (|
                            Ty.path "core::fmt::builders::DebugStruct",
                            "field",
                            [],
                            []
                          |),
                          [
                            M.borrow (|
                              Pointer.Kind.MutRef,
                              M.deref (|
                                M.call_closure (|
                                  Ty.apply
                                    (Ty.path "&mut")
                                    []
                                    [ Ty.path "core::fmt::builders::DebugStruct" ],
                                  M.get_associated_function (|
                                    Ty.path "core::fmt::builders::DebugStruct",
                                    "field",
                                    [],
                                    []
                                  |),
                                  [
                                    M.borrow (|
                                      Pointer.Kind.MutRef,
                                      M.deref (|
                                        M.call_closure (|
                                          Ty.apply
                                            (Ty.path "&mut")
                                            []
                                            [ Ty.path "core::fmt::builders::DebugStruct" ],
                                          M.get_associated_function (|
                                            Ty.path "core::fmt::builders::DebugStruct",
                                            "field",
                                            [],
                                            []
                                          |),
                                          [
                                            M.borrow (|
                                              Pointer.Kind.MutRef,
                                              M.alloc (|
                                                M.call_closure (|
                                                  Ty.path "core::fmt::builders::DebugStruct",
                                                  M.get_associated_function (|
                                                    Ty.path "core::fmt::Formatter",
                                                    "debug_struct",
                                                    [],
                                                    []
                                                  |),
                                                  [
                                                    M.borrow (|
                                                      Pointer.Kind.MutRef,
                                                      M.deref (| M.read (| f |) |)
                                                    |);
                                                    M.borrow (|
                                                      Pointer.Kind.Ref,
                                                      M.deref (| mk_str (| "OccupiedError" |) |)
                                                    |)
                                                  ]
                                                |)
                                              |)
                                            |);
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.deref (| mk_str (| "key" |) |)
                                            |);
                                            (* Unsize *)
                                            M.pointer_coercion
                                              (M.borrow (|
                                                Pointer.Kind.Ref,
                                                M.deref (|
                                                  M.call_closure (|
                                                    Ty.apply (Ty.path "&") [] [ K ],
                                                    M.get_associated_function (|
                                                      Ty.apply
                                                        (Ty.path
                                                          "alloc::collections::btree::map::entry::OccupiedEntry")
                                                        []
                                                        [ K; V; A ],
                                                      "key",
                                                      [],
                                                      []
                                                    |),
                                                    [
                                                      M.borrow (|
                                                        Pointer.Kind.Ref,
                                                        M.SubPointer.get_struct_record_field (|
                                                          M.deref (| M.read (| self |) |),
                                                          "alloc::collections::btree::map::entry::OccupiedError",
                                                          "entry"
                                                        |)
                                                      |)
                                                    ]
                                                  |)
                                                |)
                                              |))
                                          ]
                                        |)
                                      |)
                                    |);
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.deref (| mk_str (| "old_value" |) |)
                                    |);
                                    (* Unsize *)
                                    M.pointer_coercion
                                      (M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.deref (|
                                          M.call_closure (|
                                            Ty.apply (Ty.path "&") [] [ V ],
                                            M.get_associated_function (|
                                              Ty.apply
                                                (Ty.path
                                                  "alloc::collections::btree::map::entry::OccupiedEntry")
                                                []
                                                [ K; V; A ],
                                              "get",
                                              [],
                                              []
                                            |),
                                            [
                                              M.borrow (|
                                                Pointer.Kind.Ref,
                                                M.SubPointer.get_struct_record_field (|
                                                  M.deref (| M.read (| self |) |),
                                                  "alloc::collections::btree::map::entry::OccupiedError",
                                                  "entry"
                                                |)
                                              |)
                                            ]
                                          |)
                                        |)
                                      |))
                                  ]
                                |)
                              |)
                            |);
                            M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "new_value" |) |) |);
                            (* Unsize *)
                            M.pointer_coercion
                              (M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.SubPointer.get_struct_record_field (|
                                      M.deref (| M.read (| self |) |),
                                      "alloc::collections::btree::map::entry::OccupiedError",
                                      "value"
                                    |)
                                  |)
                                |)
                              |))
                          ]
                        |)
                      |)
                    |)
                  ]
                |)))
            | _, _, _ => M.impossible "wrong number of arguments"
            end.
          
          Axiom Implements :
            forall (K V A : Ty.t),
            M.IsTraitInstance
              "core::fmt::Debug"
              (* Trait polymorphic consts *) []
              (* Trait polymorphic types *) []
              (Self K V A)
              (* Instance *) [ ("fmt", InstanceField.Method (fmt K V A)) ].
        End Impl_core_fmt_Debug_where_core_fmt_Debug_K_where_core_cmp_Ord_K_where_core_fmt_Debug_V_where_core_alloc_Allocator_A_where_core_clone_Clone_A_for_alloc_collections_btree_map_entry_OccupiedError_K_V_A.
        
        Module Impl_core_fmt_Display_where_core_fmt_Debug_K_where_core_cmp_Ord_K_where_core_fmt_Debug_V_where_core_alloc_Allocator_A_where_core_clone_Clone_A_for_alloc_collections_btree_map_entry_OccupiedError_K_V_A.
          Definition Self (K V A : Ty.t) : Ty.t :=
            Ty.apply
              (Ty.path "alloc::collections::btree::map::entry::OccupiedError")
              []
              [ K; V; A ].
          
          (*
              fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                  write!(
                      f,
                      "failed to insert {:?}, key {:?} already exists with value {:?}",
                      self.value,
                      self.entry.key(),
                      self.entry.get(),
                  )
              }
          *)
          Definition fmt (K V A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
            let Self : Ty.t := Self K V A in
            match ε, τ, α with
            | [], [], [ self; f ] =>
              ltac:(M.monadic
                (let self := M.alloc (| self |) in
                let f := M.alloc (| f |) in
                M.call_closure (|
                  Ty.apply
                    (Ty.path "core::result::Result")
                    []
                    [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                  M.get_associated_function (|
                    Ty.path "core::fmt::Formatter",
                    "write_fmt",
                    [],
                    []
                  |),
                  [
                    M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                    M.call_closure (|
                      Ty.path "core::fmt::Arguments",
                      M.get_associated_function (|
                        Ty.path "core::fmt::Arguments",
                        "new_v1",
                        [ Value.Integer IntegerKind.Usize 3; Value.Integer IntegerKind.Usize 3 ],
                        []
                      |),
                      [
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.deref (|
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.alloc (|
                                Value.Array
                                  [
                                    mk_str (| "failed to insert " |);
                                    mk_str (| ", key " |);
                                    mk_str (| " already exists with value " |)
                                  ]
                              |)
                            |)
                          |)
                        |);
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.deref (|
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.alloc (|
                                Value.Array
                                  [
                                    M.call_closure (|
                                      Ty.path "core::fmt::rt::Argument",
                                      M.get_associated_function (|
                                        Ty.path "core::fmt::rt::Argument",
                                        "new_debug",
                                        [],
                                        [ V ]
                                      |),
                                      [
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.deref (|
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.SubPointer.get_struct_record_field (|
                                                M.deref (| M.read (| self |) |),
                                                "alloc::collections::btree::map::entry::OccupiedError",
                                                "value"
                                              |)
                                            |)
                                          |)
                                        |)
                                      ]
                                    |);
                                    M.call_closure (|
                                      Ty.path "core::fmt::rt::Argument",
                                      M.get_associated_function (|
                                        Ty.path "core::fmt::rt::Argument",
                                        "new_debug",
                                        [],
                                        [ Ty.apply (Ty.path "&") [] [ K ] ]
                                      |),
                                      [
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.deref (|
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.alloc (|
                                                M.call_closure (|
                                                  Ty.apply (Ty.path "&") [] [ K ],
                                                  M.get_associated_function (|
                                                    Ty.apply
                                                      (Ty.path
                                                        "alloc::collections::btree::map::entry::OccupiedEntry")
                                                      []
                                                      [ K; V; A ],
                                                    "key",
                                                    [],
                                                    []
                                                  |),
                                                  [
                                                    M.borrow (|
                                                      Pointer.Kind.Ref,
                                                      M.SubPointer.get_struct_record_field (|
                                                        M.deref (| M.read (| self |) |),
                                                        "alloc::collections::btree::map::entry::OccupiedError",
                                                        "entry"
                                                      |)
                                                    |)
                                                  ]
                                                |)
                                              |)
                                            |)
                                          |)
                                        |)
                                      ]
                                    |);
                                    M.call_closure (|
                                      Ty.path "core::fmt::rt::Argument",
                                      M.get_associated_function (|
                                        Ty.path "core::fmt::rt::Argument",
                                        "new_debug",
                                        [],
                                        [ Ty.apply (Ty.path "&") [] [ V ] ]
                                      |),
                                      [
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.deref (|
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.alloc (|
                                                M.call_closure (|
                                                  Ty.apply (Ty.path "&") [] [ V ],
                                                  M.get_associated_function (|
                                                    Ty.apply
                                                      (Ty.path
                                                        "alloc::collections::btree::map::entry::OccupiedEntry")
                                                      []
                                                      [ K; V; A ],
                                                    "get",
                                                    [],
                                                    []
                                                  |),
                                                  [
                                                    M.borrow (|
                                                      Pointer.Kind.Ref,
                                                      M.SubPointer.get_struct_record_field (|
                                                        M.deref (| M.read (| self |) |),
                                                        "alloc::collections::btree::map::entry::OccupiedError",
                                                        "entry"
                                                      |)
                                                    |)
                                                  ]
                                                |)
                                              |)
                                            |)
                                          |)
                                        |)
                                      ]
                                    |)
                                  ]
                              |)
                            |)
                          |)
                        |)
                      ]
                    |)
                  ]
                |)))
            | _, _, _ => M.impossible "wrong number of arguments"
            end.
          
          Axiom Implements :
            forall (K V A : Ty.t),
            M.IsTraitInstance
              "core::fmt::Display"
              (* Trait polymorphic consts *) []
              (* Trait polymorphic types *) []
              (Self K V A)
              (* Instance *) [ ("fmt", InstanceField.Method (fmt K V A)) ].
        End Impl_core_fmt_Display_where_core_fmt_Debug_K_where_core_cmp_Ord_K_where_core_fmt_Debug_V_where_core_alloc_Allocator_A_where_core_clone_Clone_A_for_alloc_collections_btree_map_entry_OccupiedError_K_V_A.
        
        Module Impl_core_error_Error_where_core_fmt_Debug_K_where_core_cmp_Ord_K_where_core_fmt_Debug_V_for_alloc_collections_btree_map_entry_OccupiedError_K_V_alloc_alloc_Global.
          Definition Self (K V : Ty.t) : Ty.t :=
            Ty.apply
              (Ty.path "alloc::collections::btree::map::entry::OccupiedError")
              []
              [ K; V; Ty.path "alloc::alloc::Global" ].
          
          (*
              fn description(&self) -> &str {
                  "key already exists"
              }
          *)
          Definition description
              (K V : Ty.t)
              (ε : list Value.t)
              (τ : list Ty.t)
              (α : list Value.t)
              : M :=
            let Self : Ty.t := Self K V in
            match ε, τ, α with
            | [], [], [ self ] =>
              ltac:(M.monadic
                (let self := M.alloc (| self |) in
                M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "key already exists" |) |) |)))
            | _, _, _ => M.impossible "wrong number of arguments"
            end.
          
          Axiom Implements :
            forall (K V : Ty.t),
            M.IsTraitInstance
              "core::error::Error"
              (* Trait polymorphic consts *) []
              (* Trait polymorphic types *) []
              (Self K V)
              (* Instance *) [ ("description", InstanceField.Method (description K V)) ].
        End Impl_core_error_Error_where_core_fmt_Debug_K_where_core_cmp_Ord_K_where_core_fmt_Debug_V_for_alloc_collections_btree_map_entry_OccupiedError_K_V_alloc_alloc_Global.
        
        Module Impl_alloc_collections_btree_map_entry_Entry_K_V_A.
          Definition Self (K V A : Ty.t) : Ty.t :=
            Ty.apply (Ty.path "alloc::collections::btree::map::entry::Entry") [] [ K; V; A ].
          
          (*
              pub fn or_insert(self, default: V) -> &'a mut V {
                  match self {
                      Occupied(entry) => entry.into_mut(),
                      Vacant(entry) => entry.insert(default),
                  }
              }
          *)
          Definition or_insert
              (K V A : Ty.t)
              (ε : list Value.t)
              (τ : list Ty.t)
              (α : list Value.t)
              : M :=
            let Self : Ty.t := Self K V A in
            match ε, τ, α with
            | [], [], [ self; default ] =>
              ltac:(M.monadic
                (let self := M.alloc (| self |) in
                let default := M.alloc (| default |) in
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.MutRef,
                      M.deref (|
                        M.read (|
                          M.match_operator (|
                            Ty.apply (Ty.path "*") [] [ Ty.apply (Ty.path "&mut") [] [ V ] ],
                            self,
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "alloc::collections::btree::map::entry::Entry::Occupied",
                                      0
                                    |) in
                                  let entry := M.copy (| γ0_0 |) in
                                  M.alloc (|
                                    M.borrow (|
                                      Pointer.Kind.MutRef,
                                      M.deref (|
                                        M.call_closure (|
                                          Ty.apply (Ty.path "&mut") [] [ V ],
                                          M.get_associated_function (|
                                            Ty.apply
                                              (Ty.path
                                                "alloc::collections::btree::map::entry::OccupiedEntry")
                                              []
                                              [ K; V; A ],
                                            "into_mut",
                                            [],
                                            []
                                          |),
                                          [ M.read (| entry |) ]
                                        |)
                                      |)
                                    |)
                                  |)));
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "alloc::collections::btree::map::entry::Entry::Vacant",
                                      0
                                    |) in
                                  let entry := M.copy (| γ0_0 |) in
                                  M.alloc (|
                                    M.borrow (|
                                      Pointer.Kind.MutRef,
                                      M.deref (|
                                        M.call_closure (|
                                          Ty.apply (Ty.path "&mut") [] [ V ],
                                          M.get_associated_function (|
                                            Ty.apply
                                              (Ty.path
                                                "alloc::collections::btree::map::entry::VacantEntry")
                                              []
                                              [ K; V; A ],
                                            "insert",
                                            [],
                                            []
                                          |),
                                          [ M.read (| entry |); M.read (| default |) ]
                                        |)
                                      |)
                                    |)
                                  |)))
                            ]
                          |)
                        |)
                      |)
                    |)
                  |)
                |)))
            | _, _, _ => M.impossible "wrong number of arguments"
            end.
          
          Global Instance AssociatedFunction_or_insert :
            forall (K V A : Ty.t),
            M.IsAssociatedFunction.C (Self K V A) "or_insert" (or_insert K V A).
          Admitted.
          Global Typeclasses Opaque or_insert.
          
          (*
              pub fn or_insert_with<F: FnOnce() -> V>(self, default: F) -> &'a mut V {
                  match self {
                      Occupied(entry) => entry.into_mut(),
                      Vacant(entry) => entry.insert(default()),
                  }
              }
          *)
          Definition or_insert_with
              (K V A : Ty.t)
              (ε : list Value.t)
              (τ : list Ty.t)
              (α : list Value.t)
              : M :=
            let Self : Ty.t := Self K V A in
            match ε, τ, α with
            | [], [ F ], [ self; default ] =>
              ltac:(M.monadic
                (let self := M.alloc (| self |) in
                let default := M.alloc (| default |) in
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.MutRef,
                      M.deref (|
                        M.read (|
                          M.match_operator (|
                            Ty.apply (Ty.path "*") [] [ Ty.apply (Ty.path "&mut") [] [ V ] ],
                            self,
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "alloc::collections::btree::map::entry::Entry::Occupied",
                                      0
                                    |) in
                                  let entry := M.copy (| γ0_0 |) in
                                  M.alloc (|
                                    M.borrow (|
                                      Pointer.Kind.MutRef,
                                      M.deref (|
                                        M.call_closure (|
                                          Ty.apply (Ty.path "&mut") [] [ V ],
                                          M.get_associated_function (|
                                            Ty.apply
                                              (Ty.path
                                                "alloc::collections::btree::map::entry::OccupiedEntry")
                                              []
                                              [ K; V; A ],
                                            "into_mut",
                                            [],
                                            []
                                          |),
                                          [ M.read (| entry |) ]
                                        |)
                                      |)
                                    |)
                                  |)));
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "alloc::collections::btree::map::entry::Entry::Vacant",
                                      0
                                    |) in
                                  let entry := M.copy (| γ0_0 |) in
                                  M.alloc (|
                                    M.borrow (|
                                      Pointer.Kind.MutRef,
                                      M.deref (|
                                        M.call_closure (|
                                          Ty.apply (Ty.path "&mut") [] [ V ],
                                          M.get_associated_function (|
                                            Ty.apply
                                              (Ty.path
                                                "alloc::collections::btree::map::entry::VacantEntry")
                                              []
                                              [ K; V; A ],
                                            "insert",
                                            [],
                                            []
                                          |),
                                          [
                                            M.read (| entry |);
                                            M.call_closure (|
                                              V,
                                              M.get_trait_method (|
                                                "core::ops::function::FnOnce",
                                                F,
                                                [],
                                                [ Ty.tuple [] ],
                                                "call_once",
                                                [],
                                                []
                                              |),
                                              [ M.read (| default |); Value.Tuple [] ]
                                            |)
                                          ]
                                        |)
                                      |)
                                    |)
                                  |)))
                            ]
                          |)
                        |)
                      |)
                    |)
                  |)
                |)))
            | _, _, _ => M.impossible "wrong number of arguments"
            end.
          
          Global Instance AssociatedFunction_or_insert_with :
            forall (K V A : Ty.t),
            M.IsAssociatedFunction.C (Self K V A) "or_insert_with" (or_insert_with K V A).
          Admitted.
          Global Typeclasses Opaque or_insert_with.
          
          (*
              pub fn or_insert_with_key<F: FnOnce(&K) -> V>(self, default: F) -> &'a mut V {
                  match self {
                      Occupied(entry) => entry.into_mut(),
                      Vacant(entry) => {
                          let value = default(entry.key());
                          entry.insert(value)
                      }
                  }
              }
          *)
          Definition or_insert_with_key
              (K V A : Ty.t)
              (ε : list Value.t)
              (τ : list Ty.t)
              (α : list Value.t)
              : M :=
            let Self : Ty.t := Self K V A in
            match ε, τ, α with
            | [], [ F ], [ self; default ] =>
              ltac:(M.monadic
                (let self := M.alloc (| self |) in
                let default := M.alloc (| default |) in
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.MutRef,
                      M.deref (|
                        M.read (|
                          M.match_operator (|
                            Ty.apply (Ty.path "*") [] [ Ty.apply (Ty.path "&mut") [] [ V ] ],
                            self,
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "alloc::collections::btree::map::entry::Entry::Occupied",
                                      0
                                    |) in
                                  let entry := M.copy (| γ0_0 |) in
                                  M.alloc (|
                                    M.borrow (|
                                      Pointer.Kind.MutRef,
                                      M.deref (|
                                        M.call_closure (|
                                          Ty.apply (Ty.path "&mut") [] [ V ],
                                          M.get_associated_function (|
                                            Ty.apply
                                              (Ty.path
                                                "alloc::collections::btree::map::entry::OccupiedEntry")
                                              []
                                              [ K; V; A ],
                                            "into_mut",
                                            [],
                                            []
                                          |),
                                          [ M.read (| entry |) ]
                                        |)
                                      |)
                                    |)
                                  |)));
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "alloc::collections::btree::map::entry::Entry::Vacant",
                                      0
                                    |) in
                                  let entry := M.copy (| γ0_0 |) in
                                  let~ value : Ty.apply (Ty.path "*") [] [ V ] :=
                                    M.alloc (|
                                      M.call_closure (|
                                        V,
                                        M.get_trait_method (|
                                          "core::ops::function::FnOnce",
                                          F,
                                          [],
                                          [ Ty.tuple [ Ty.apply (Ty.path "&") [] [ K ] ] ],
                                          "call_once",
                                          [],
                                          []
                                        |),
                                        [
                                          M.read (| default |);
                                          Value.Tuple
                                            [
                                              M.borrow (|
                                                Pointer.Kind.Ref,
                                                M.deref (|
                                                  M.call_closure (|
                                                    Ty.apply (Ty.path "&") [] [ K ],
                                                    M.get_associated_function (|
                                                      Ty.apply
                                                        (Ty.path
                                                          "alloc::collections::btree::map::entry::VacantEntry")
                                                        []
                                                        [ K; V; A ],
                                                      "key",
                                                      [],
                                                      []
                                                    |),
                                                    [ M.borrow (| Pointer.Kind.Ref, entry |) ]
                                                  |)
                                                |)
                                              |)
                                            ]
                                        ]
                                      |)
                                    |) in
                                  M.alloc (|
                                    M.borrow (|
                                      Pointer.Kind.MutRef,
                                      M.deref (|
                                        M.call_closure (|
                                          Ty.apply (Ty.path "&mut") [] [ V ],
                                          M.get_associated_function (|
                                            Ty.apply
                                              (Ty.path
                                                "alloc::collections::btree::map::entry::VacantEntry")
                                              []
                                              [ K; V; A ],
                                            "insert",
                                            [],
                                            []
                                          |),
                                          [ M.read (| entry |); M.read (| value |) ]
                                        |)
                                      |)
                                    |)
                                  |)))
                            ]
                          |)
                        |)
                      |)
                    |)
                  |)
                |)))
            | _, _, _ => M.impossible "wrong number of arguments"
            end.
          
          Global Instance AssociatedFunction_or_insert_with_key :
            forall (K V A : Ty.t),
            M.IsAssociatedFunction.C (Self K V A) "or_insert_with_key" (or_insert_with_key K V A).
          Admitted.
          Global Typeclasses Opaque or_insert_with_key.
          
          (*
              pub fn key(&self) -> &K {
                  match *self {
                      Occupied(ref entry) => entry.key(),
                      Vacant(ref entry) => entry.key(),
                  }
              }
          *)
          Definition key (K V A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
            let Self : Ty.t := Self K V A in
            match ε, τ, α with
            | [], [], [ self ] =>
              ltac:(M.monadic
                (let self := M.alloc (| self |) in
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.read (|
                      M.match_operator (|
                        Ty.apply (Ty.path "*") [] [ Ty.apply (Ty.path "&") [] [ K ] ],
                        M.deref (| M.read (| self |) |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 :=
                                M.SubPointer.get_struct_tuple_field (|
                                  γ,
                                  "alloc::collections::btree::map::entry::Entry::Occupied",
                                  0
                                |) in
                              let entry := M.alloc (| γ0_0 |) in
                              M.alloc (|
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.deref (|
                                    M.call_closure (|
                                      Ty.apply (Ty.path "&") [] [ K ],
                                      M.get_associated_function (|
                                        Ty.apply
                                          (Ty.path
                                            "alloc::collections::btree::map::entry::OccupiedEntry")
                                          []
                                          [ K; V; A ],
                                        "key",
                                        [],
                                        []
                                      |),
                                      [
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.deref (| M.read (| entry |) |)
                                        |)
                                      ]
                                    |)
                                  |)
                                |)
                              |)));
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 :=
                                M.SubPointer.get_struct_tuple_field (|
                                  γ,
                                  "alloc::collections::btree::map::entry::Entry::Vacant",
                                  0
                                |) in
                              let entry := M.alloc (| γ0_0 |) in
                              M.alloc (|
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.deref (|
                                    M.call_closure (|
                                      Ty.apply (Ty.path "&") [] [ K ],
                                      M.get_associated_function (|
                                        Ty.apply
                                          (Ty.path
                                            "alloc::collections::btree::map::entry::VacantEntry")
                                          []
                                          [ K; V; A ],
                                        "key",
                                        [],
                                        []
                                      |),
                                      [
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.deref (| M.read (| entry |) |)
                                        |)
                                      ]
                                    |)
                                  |)
                                |)
                              |)))
                        ]
                      |)
                    |)
                  |)
                |)))
            | _, _, _ => M.impossible "wrong number of arguments"
            end.
          
          Global Instance AssociatedFunction_key :
            forall (K V A : Ty.t),
            M.IsAssociatedFunction.C (Self K V A) "key" (key K V A).
          Admitted.
          Global Typeclasses Opaque key.
          
          (*
              pub fn and_modify<F>(self, f: F) -> Self
              where
                  F: FnOnce(&mut V),
              {
                  match self {
                      Occupied(mut entry) => {
                          f(entry.get_mut());
                          Occupied(entry)
                      }
                      Vacant(entry) => Vacant(entry),
                  }
              }
          *)
          Definition and_modify
              (K V A : Ty.t)
              (ε : list Value.t)
              (τ : list Ty.t)
              (α : list Value.t)
              : M :=
            let Self : Ty.t := Self K V A in
            match ε, τ, α with
            | [], [ F ], [ self; f ] =>
              ltac:(M.monadic
                (let self := M.alloc (| self |) in
                let f := M.alloc (| f |) in
                M.read (|
                  M.match_operator (|
                    Ty.apply
                      (Ty.path "*")
                      []
                      [
                        Ty.apply
                          (Ty.path "alloc::collections::btree::map::entry::Entry")
                          []
                          [ K; V; A ]
                      ],
                    self,
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ0_0 :=
                            M.SubPointer.get_struct_tuple_field (|
                              γ,
                              "alloc::collections::btree::map::entry::Entry::Occupied",
                              0
                            |) in
                          let entry := M.copy (| γ0_0 |) in
                          let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                            M.alloc (|
                              M.call_closure (|
                                Ty.tuple [],
                                M.get_trait_method (|
                                  "core::ops::function::FnOnce",
                                  F,
                                  [],
                                  [ Ty.tuple [ Ty.apply (Ty.path "&mut") [] [ V ] ] ],
                                  "call_once",
                                  [],
                                  []
                                |),
                                [
                                  M.read (| f |);
                                  Value.Tuple
                                    [
                                      M.borrow (|
                                        Pointer.Kind.MutRef,
                                        M.deref (|
                                          M.call_closure (|
                                            Ty.apply (Ty.path "&mut") [] [ V ],
                                            M.get_associated_function (|
                                              Ty.apply
                                                (Ty.path
                                                  "alloc::collections::btree::map::entry::OccupiedEntry")
                                                []
                                                [ K; V; A ],
                                              "get_mut",
                                              [],
                                              []
                                            |),
                                            [ M.borrow (| Pointer.Kind.MutRef, entry |) ]
                                          |)
                                        |)
                                      |)
                                    ]
                                ]
                              |)
                            |) in
                          M.alloc (|
                            Value.StructTuple
                              "alloc::collections::btree::map::entry::Entry::Occupied"
                              []
                              [ K; V; A ]
                              [ M.read (| entry |) ]
                          |)));
                      fun γ =>
                        ltac:(M.monadic
                          (let γ0_0 :=
                            M.SubPointer.get_struct_tuple_field (|
                              γ,
                              "alloc::collections::btree::map::entry::Entry::Vacant",
                              0
                            |) in
                          let entry := M.copy (| γ0_0 |) in
                          M.alloc (|
                            Value.StructTuple
                              "alloc::collections::btree::map::entry::Entry::Vacant"
                              []
                              [ K; V; A ]
                              [ M.read (| entry |) ]
                          |)))
                    ]
                  |)
                |)))
            | _, _, _ => M.impossible "wrong number of arguments"
            end.
          
          Global Instance AssociatedFunction_and_modify :
            forall (K V A : Ty.t),
            M.IsAssociatedFunction.C (Self K V A) "and_modify" (and_modify K V A).
          Admitted.
          Global Typeclasses Opaque and_modify.
          
          (*
              pub fn insert_entry(self, value: V) -> OccupiedEntry<'a, K, V, A> {
                  match self {
                      Occupied(mut entry) => {
                          entry.insert(value);
                          entry
                      }
                      Vacant(entry) => entry.insert_entry(value),
                  }
              }
          *)
          Definition insert_entry
              (K V A : Ty.t)
              (ε : list Value.t)
              (τ : list Ty.t)
              (α : list Value.t)
              : M :=
            let Self : Ty.t := Self K V A in
            match ε, τ, α with
            | [], [], [ self; value ] =>
              ltac:(M.monadic
                (let self := M.alloc (| self |) in
                let value := M.alloc (| value |) in
                M.read (|
                  M.match_operator (|
                    Ty.apply
                      (Ty.path "*")
                      []
                      [
                        Ty.apply
                          (Ty.path "alloc::collections::btree::map::entry::OccupiedEntry")
                          []
                          [ K; V; A ]
                      ],
                    self,
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ0_0 :=
                            M.SubPointer.get_struct_tuple_field (|
                              γ,
                              "alloc::collections::btree::map::entry::Entry::Occupied",
                              0
                            |) in
                          let entry := M.copy (| γ0_0 |) in
                          let~ _ : Ty.apply (Ty.path "*") [] [ V ] :=
                            M.alloc (|
                              M.call_closure (|
                                V,
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "alloc::collections::btree::map::entry::OccupiedEntry")
                                    []
                                    [ K; V; A ],
                                  "insert",
                                  [],
                                  []
                                |),
                                [ M.borrow (| Pointer.Kind.MutRef, entry |); M.read (| value |) ]
                              |)
                            |) in
                          entry));
                      fun γ =>
                        ltac:(M.monadic
                          (let γ0_0 :=
                            M.SubPointer.get_struct_tuple_field (|
                              γ,
                              "alloc::collections::btree::map::entry::Entry::Vacant",
                              0
                            |) in
                          let entry := M.copy (| γ0_0 |) in
                          M.alloc (|
                            M.call_closure (|
                              Ty.apply
                                (Ty.path "alloc::collections::btree::map::entry::OccupiedEntry")
                                []
                                [ K; V; A ],
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "alloc::collections::btree::map::entry::VacantEntry")
                                  []
                                  [ K; V; A ],
                                "insert_entry",
                                [],
                                []
                              |),
                              [ M.read (| entry |); M.read (| value |) ]
                            |)
                          |)))
                    ]
                  |)
                |)))
            | _, _, _ => M.impossible "wrong number of arguments"
            end.
          
          Global Instance AssociatedFunction_insert_entry :
            forall (K V A : Ty.t),
            M.IsAssociatedFunction.C (Self K V A) "insert_entry" (insert_entry K V A).
          Admitted.
          Global Typeclasses Opaque insert_entry.
          (*
              pub fn or_default(self) -> &'a mut V {
                  match self {
                      Occupied(entry) => entry.into_mut(),
                      Vacant(entry) => entry.insert(Default::default()),
                  }
              }
          *)
          Definition or_default
              (K V A : Ty.t)
              (ε : list Value.t)
              (τ : list Ty.t)
              (α : list Value.t)
              : M :=
            let Self : Ty.t := Self K V A in
            match ε, τ, α with
            | [], [], [ self ] =>
              ltac:(M.monadic
                (let self := M.alloc (| self |) in
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.MutRef,
                      M.deref (|
                        M.read (|
                          M.match_operator (|
                            Ty.apply (Ty.path "*") [] [ Ty.apply (Ty.path "&mut") [] [ V ] ],
                            self,
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "alloc::collections::btree::map::entry::Entry::Occupied",
                                      0
                                    |) in
                                  let entry := M.copy (| γ0_0 |) in
                                  M.alloc (|
                                    M.borrow (|
                                      Pointer.Kind.MutRef,
                                      M.deref (|
                                        M.call_closure (|
                                          Ty.apply (Ty.path "&mut") [] [ V ],
                                          M.get_associated_function (|
                                            Ty.apply
                                              (Ty.path
                                                "alloc::collections::btree::map::entry::OccupiedEntry")
                                              []
                                              [ K; V; A ],
                                            "into_mut",
                                            [],
                                            []
                                          |),
                                          [ M.read (| entry |) ]
                                        |)
                                      |)
                                    |)
                                  |)));
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "alloc::collections::btree::map::entry::Entry::Vacant",
                                      0
                                    |) in
                                  let entry := M.copy (| γ0_0 |) in
                                  M.alloc (|
                                    M.borrow (|
                                      Pointer.Kind.MutRef,
                                      M.deref (|
                                        M.call_closure (|
                                          Ty.apply (Ty.path "&mut") [] [ V ],
                                          M.get_associated_function (|
                                            Ty.apply
                                              (Ty.path
                                                "alloc::collections::btree::map::entry::VacantEntry")
                                              []
                                              [ K; V; A ],
                                            "insert",
                                            [],
                                            []
                                          |),
                                          [
                                            M.read (| entry |);
                                            M.call_closure (|
                                              V,
                                              M.get_trait_method (|
                                                "core::default::Default",
                                                V,
                                                [],
                                                [],
                                                "default",
                                                [],
                                                []
                                              |),
                                              []
                                            |)
                                          ]
                                        |)
                                      |)
                                    |)
                                  |)))
                            ]
                          |)
                        |)
                      |)
                    |)
                  |)
                |)))
            | _, _, _ => M.impossible "wrong number of arguments"
            end.
          
          Global Instance AssociatedFunction_or_default :
            forall (K V A : Ty.t),
            M.IsAssociatedFunction.C (Self K V A) "or_default" (or_default K V A).
          Admitted.
          Global Typeclasses Opaque or_default.
        End Impl_alloc_collections_btree_map_entry_Entry_K_V_A.
        
        
        Module Impl_alloc_collections_btree_map_entry_VacantEntry_K_V_A.
          Definition Self (K V A : Ty.t) : Ty.t :=
            Ty.apply (Ty.path "alloc::collections::btree::map::entry::VacantEntry") [] [ K; V; A ].
          
          (*
              pub fn key(&self) -> &K {
                  &self.key
              }
          *)
          Definition key (K V A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
            let Self : Ty.t := Self K V A in
            match ε, τ, α with
            | [], [], [ self ] =>
              ltac:(M.monadic
                (let self := M.alloc (| self |) in
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "alloc::collections::btree::map::entry::VacantEntry",
                        "key"
                      |)
                    |)
                  |)
                |)))
            | _, _, _ => M.impossible "wrong number of arguments"
            end.
          
          Global Instance AssociatedFunction_key :
            forall (K V A : Ty.t),
            M.IsAssociatedFunction.C (Self K V A) "key" (key K V A).
          Admitted.
          Global Typeclasses Opaque key.
          
          (*
              pub fn into_key(self) -> K {
                  self.key
              }
          *)
          Definition into_key
              (K V A : Ty.t)
              (ε : list Value.t)
              (τ : list Ty.t)
              (α : list Value.t)
              : M :=
            let Self : Ty.t := Self K V A in
            match ε, τ, α with
            | [], [], [ self ] =>
              ltac:(M.monadic
                (let self := M.alloc (| self |) in
                M.read (|
                  M.SubPointer.get_struct_record_field (|
                    self,
                    "alloc::collections::btree::map::entry::VacantEntry",
                    "key"
                  |)
                |)))
            | _, _, _ => M.impossible "wrong number of arguments"
            end.
          
          Global Instance AssociatedFunction_into_key :
            forall (K V A : Ty.t),
            M.IsAssociatedFunction.C (Self K V A) "into_key" (into_key K V A).
          Admitted.
          Global Typeclasses Opaque into_key.
          
          (*
              pub fn insert(self, value: V) -> &'a mut V {
                  self.insert_entry(value).into_mut()
              }
          *)
          Definition insert
              (K V A : Ty.t)
              (ε : list Value.t)
              (τ : list Ty.t)
              (α : list Value.t)
              : M :=
            let Self : Ty.t := Self K V A in
            match ε, τ, α with
            | [], [], [ self; value ] =>
              ltac:(M.monadic
                (let self := M.alloc (| self |) in
                let value := M.alloc (| value |) in
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.MutRef,
                      M.deref (|
                        M.call_closure (|
                          Ty.apply (Ty.path "&mut") [] [ V ],
                          M.get_associated_function (|
                            Ty.apply
                              (Ty.path "alloc::collections::btree::map::entry::OccupiedEntry")
                              []
                              [ K; V; A ],
                            "into_mut",
                            [],
                            []
                          |),
                          [
                            M.call_closure (|
                              Ty.apply
                                (Ty.path "alloc::collections::btree::map::entry::OccupiedEntry")
                                []
                                [ K; V; A ],
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "alloc::collections::btree::map::entry::VacantEntry")
                                  []
                                  [ K; V; A ],
                                "insert_entry",
                                [],
                                []
                              |),
                              [ M.read (| self |); M.read (| value |) ]
                            |)
                          ]
                        |)
                      |)
                    |)
                  |)
                |)))
            | _, _, _ => M.impossible "wrong number of arguments"
            end.
          
          Global Instance AssociatedFunction_insert :
            forall (K V A : Ty.t),
            M.IsAssociatedFunction.C (Self K V A) "insert" (insert K V A).
          Admitted.
          Global Typeclasses Opaque insert.
          
          (*
              pub fn insert_entry(mut self, value: V) -> OccupiedEntry<'a, K, V, A> {
                  let handle = match self.handle {
                      None => {
                          // SAFETY: There is no tree yet so no reference to it exists.
                          let map = unsafe { self.dormant_map.reborrow() };
                          let root = map.root.insert(NodeRef::new_leaf(self.alloc.clone()).forget_type());
                          // SAFETY: We *just* created the root as a leaf, and we're
                          // stacking the new handle on the original borrow lifetime.
                          unsafe {
                              let mut leaf = root.borrow_mut().cast_to_leaf_unchecked();
                              leaf.push_with_handle(self.key, value)
                          }
                      }
                      Some(handle) => handle.insert_recursing(self.key, value, self.alloc.clone(), |ins| {
                          drop(ins.left);
                          // SAFETY: Pushing a new root node doesn't invalidate
                          // handles to existing nodes.
                          let map = unsafe { self.dormant_map.reborrow() };
                          let root = map.root.as_mut().unwrap(); // same as ins.left
                          root.push_internal_level(self.alloc.clone()).push(ins.kv.0, ins.kv.1, ins.right)
                      }),
                  };
          
                  // SAFETY: modifying the length doesn't invalidate handles to existing nodes.
                  unsafe { self.dormant_map.reborrow().length += 1 };
          
                  OccupiedEntry {
                      handle: handle.forget_node_type(),
                      dormant_map: self.dormant_map,
                      alloc: self.alloc,
                      _marker: PhantomData,
                  }
              }
          *)
          Definition insert_entry
              (K V A : Ty.t)
              (ε : list Value.t)
              (τ : list Ty.t)
              (α : list Value.t)
              : M :=
            let Self : Ty.t := Self K V A in
            match ε, τ, α with
            | [], [], [ self; value ] =>
              ltac:(M.monadic
                (let self := M.alloc (| self |) in
                let value := M.alloc (| value |) in
                M.read (|
                  let~ handle :
                      Ty.apply
                        (Ty.path "*")
                        []
                        [
                          Ty.apply
                            (Ty.path "alloc::collections::btree::node::Handle")
                            []
                            [
                              Ty.apply
                                (Ty.path "alloc::collections::btree::node::NodeRef")
                                []
                                [
                                  Ty.path "alloc::collections::btree::node::marker::Mut";
                                  K;
                                  V;
                                  Ty.path "alloc::collections::btree::node::marker::Leaf"
                                ];
                              Ty.path "alloc::collections::btree::node::marker::KV"
                            ]
                        ] :=
                    M.copy (|
                      M.match_operator (|
                        Ty.apply
                          (Ty.path "*")
                          []
                          [
                            Ty.apply
                              (Ty.path "alloc::collections::btree::node::Handle")
                              []
                              [
                                Ty.apply
                                  (Ty.path "alloc::collections::btree::node::NodeRef")
                                  []
                                  [
                                    Ty.path "alloc::collections::btree::node::marker::Mut";
                                    K;
                                    V;
                                    Ty.path "alloc::collections::btree::node::marker::Leaf"
                                  ];
                                Ty.path "alloc::collections::btree::node::marker::KV"
                              ]
                          ],
                        M.SubPointer.get_struct_record_field (|
                          self,
                          "alloc::collections::btree::map::entry::VacantEntry",
                          "handle"
                        |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let _ := M.is_struct_tuple (| γ, "core::option::Option::None" |) in
                              let~ map :
                                  Ty.apply
                                    (Ty.path "*")
                                    []
                                    [
                                      Ty.apply
                                        (Ty.path "&mut")
                                        []
                                        [
                                          Ty.apply
                                            (Ty.path "alloc::collections::btree::map::BTreeMap")
                                            []
                                            [ K; V; A ]
                                        ]
                                    ] :=
                                M.alloc (|
                                  M.borrow (|
                                    Pointer.Kind.MutRef,
                                    M.deref (|
                                      M.call_closure (|
                                        Ty.apply
                                          (Ty.path "&mut")
                                          []
                                          [
                                            Ty.apply
                                              (Ty.path "alloc::collections::btree::map::BTreeMap")
                                              []
                                              [ K; V; A ]
                                          ],
                                        M.get_associated_function (|
                                          Ty.apply
                                            (Ty.path
                                              "alloc::collections::btree::borrow::DormantMutRef")
                                            []
                                            [
                                              Ty.apply
                                                (Ty.path "alloc::collections::btree::map::BTreeMap")
                                                []
                                                [ K; V; A ]
                                            ],
                                          "reborrow",
                                          [],
                                          []
                                        |),
                                        [
                                          M.borrow (|
                                            Pointer.Kind.MutRef,
                                            M.SubPointer.get_struct_record_field (|
                                              self,
                                              "alloc::collections::btree::map::entry::VacantEntry",
                                              "dormant_map"
                                            |)
                                          |)
                                        ]
                                      |)
                                    |)
                                  |)
                                |) in
                              let~ root :
                                  Ty.apply
                                    (Ty.path "*")
                                    []
                                    [
                                      Ty.apply
                                        (Ty.path "&mut")
                                        []
                                        [
                                          Ty.apply
                                            (Ty.path "alloc::collections::btree::node::NodeRef")
                                            []
                                            [
                                              Ty.path
                                                "alloc::collections::btree::node::marker::Owned";
                                              K;
                                              V;
                                              Ty.path
                                                "alloc::collections::btree::node::marker::LeafOrInternal"
                                            ]
                                        ]
                                    ] :=
                                M.alloc (|
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "&mut")
                                      []
                                      [
                                        Ty.apply
                                          (Ty.path "alloc::collections::btree::node::NodeRef")
                                          []
                                          [
                                            Ty.path
                                              "alloc::collections::btree::node::marker::Owned";
                                            K;
                                            V;
                                            Ty.path
                                              "alloc::collections::btree::node::marker::LeafOrInternal"
                                          ]
                                      ],
                                    M.get_associated_function (|
                                      Ty.apply
                                        (Ty.path "core::option::Option")
                                        []
                                        [
                                          Ty.apply
                                            (Ty.path "alloc::collections::btree::node::NodeRef")
                                            []
                                            [
                                              Ty.path
                                                "alloc::collections::btree::node::marker::Owned";
                                              K;
                                              V;
                                              Ty.path
                                                "alloc::collections::btree::node::marker::LeafOrInternal"
                                            ]
                                        ],
                                      "insert",
                                      [],
                                      []
                                    |),
                                    [
                                      M.borrow (|
                                        Pointer.Kind.MutRef,
                                        M.SubPointer.get_struct_record_field (|
                                          M.deref (| M.read (| map |) |),
                                          "alloc::collections::btree::map::BTreeMap",
                                          "root"
                                        |)
                                      |);
                                      M.call_closure (|
                                        Ty.apply
                                          (Ty.path "alloc::collections::btree::node::NodeRef")
                                          []
                                          [
                                            Ty.path
                                              "alloc::collections::btree::node::marker::Owned";
                                            K;
                                            V;
                                            Ty.path
                                              "alloc::collections::btree::node::marker::LeafOrInternal"
                                          ],
                                        M.get_associated_function (|
                                          Ty.apply
                                            (Ty.path "alloc::collections::btree::node::NodeRef")
                                            []
                                            [
                                              Ty.path
                                                "alloc::collections::btree::node::marker::Owned";
                                              K;
                                              V;
                                              Ty.path
                                                "alloc::collections::btree::node::marker::Leaf"
                                            ],
                                          "forget_type",
                                          [],
                                          []
                                        |),
                                        [
                                          M.call_closure (|
                                            Ty.apply
                                              (Ty.path "alloc::collections::btree::node::NodeRef")
                                              []
                                              [
                                                Ty.path
                                                  "alloc::collections::btree::node::marker::Owned";
                                                K;
                                                V;
                                                Ty.path
                                                  "alloc::collections::btree::node::marker::Leaf"
                                              ],
                                            M.get_associated_function (|
                                              Ty.apply
                                                (Ty.path "alloc::collections::btree::node::NodeRef")
                                                []
                                                [
                                                  Ty.path
                                                    "alloc::collections::btree::node::marker::Owned";
                                                  K;
                                                  V;
                                                  Ty.path
                                                    "alloc::collections::btree::node::marker::Leaf"
                                                ],
                                              "new_leaf",
                                              [],
                                              [ A ]
                                            |),
                                            [
                                              M.call_closure (|
                                                A,
                                                M.get_trait_method (|
                                                  "core::clone::Clone",
                                                  A,
                                                  [],
                                                  [],
                                                  "clone",
                                                  [],
                                                  []
                                                |),
                                                [
                                                  M.borrow (|
                                                    Pointer.Kind.Ref,
                                                    M.SubPointer.get_struct_record_field (|
                                                      self,
                                                      "alloc::collections::btree::map::entry::VacantEntry",
                                                      "alloc"
                                                    |)
                                                  |)
                                                ]
                                              |)
                                            ]
                                          |)
                                        ]
                                      |)
                                    ]
                                  |)
                                |) in
                              let~ leaf :
                                  Ty.apply
                                    (Ty.path "*")
                                    []
                                    [
                                      Ty.apply
                                        (Ty.path "alloc::collections::btree::node::NodeRef")
                                        []
                                        [
                                          Ty.path "alloc::collections::btree::node::marker::Mut";
                                          K;
                                          V;
                                          Ty.path "alloc::collections::btree::node::marker::Leaf"
                                        ]
                                    ] :=
                                M.alloc (|
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "alloc::collections::btree::node::NodeRef")
                                      []
                                      [
                                        Ty.path "alloc::collections::btree::node::marker::Mut";
                                        K;
                                        V;
                                        Ty.path "alloc::collections::btree::node::marker::Leaf"
                                      ],
                                    M.get_associated_function (|
                                      Ty.apply
                                        (Ty.path "alloc::collections::btree::node::NodeRef")
                                        []
                                        [
                                          Ty.path "alloc::collections::btree::node::marker::Mut";
                                          K;
                                          V;
                                          Ty.path
                                            "alloc::collections::btree::node::marker::LeafOrInternal"
                                        ],
                                      "cast_to_leaf_unchecked",
                                      [],
                                      []
                                    |),
                                    [
                                      M.call_closure (|
                                        Ty.apply
                                          (Ty.path "alloc::collections::btree::node::NodeRef")
                                          []
                                          [
                                            Ty.path "alloc::collections::btree::node::marker::Mut";
                                            K;
                                            V;
                                            Ty.path
                                              "alloc::collections::btree::node::marker::LeafOrInternal"
                                          ],
                                        M.get_associated_function (|
                                          Ty.apply
                                            (Ty.path "alloc::collections::btree::node::NodeRef")
                                            []
                                            [
                                              Ty.path
                                                "alloc::collections::btree::node::marker::Owned";
                                              K;
                                              V;
                                              Ty.path
                                                "alloc::collections::btree::node::marker::LeafOrInternal"
                                            ],
                                          "borrow_mut",
                                          [],
                                          []
                                        |),
                                        [
                                          M.borrow (|
                                            Pointer.Kind.MutRef,
                                            M.deref (| M.read (| root |) |)
                                          |)
                                        ]
                                      |)
                                    ]
                                  |)
                                |) in
                              M.alloc (|
                                M.call_closure (|
                                  Ty.apply
                                    (Ty.path "alloc::collections::btree::node::Handle")
                                    []
                                    [
                                      Ty.apply
                                        (Ty.path "alloc::collections::btree::node::NodeRef")
                                        []
                                        [
                                          Ty.path "alloc::collections::btree::node::marker::Mut";
                                          K;
                                          V;
                                          Ty.path "alloc::collections::btree::node::marker::Leaf"
                                        ];
                                      Ty.path "alloc::collections::btree::node::marker::KV"
                                    ],
                                  M.get_associated_function (|
                                    Ty.apply
                                      (Ty.path "alloc::collections::btree::node::NodeRef")
                                      []
                                      [
                                        Ty.path "alloc::collections::btree::node::marker::Mut";
                                        K;
                                        V;
                                        Ty.path "alloc::collections::btree::node::marker::Leaf"
                                      ],
                                    "push_with_handle",
                                    [],
                                    []
                                  |),
                                  [
                                    M.borrow (| Pointer.Kind.MutRef, leaf |);
                                    M.read (|
                                      M.SubPointer.get_struct_record_field (|
                                        self,
                                        "alloc::collections::btree::map::entry::VacantEntry",
                                        "key"
                                      |)
                                    |);
                                    M.read (| value |)
                                  ]
                                |)
                              |)));
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 :=
                                M.SubPointer.get_struct_tuple_field (|
                                  γ,
                                  "core::option::Option::Some",
                                  0
                                |) in
                              let handle := M.copy (| γ0_0 |) in
                              M.alloc (|
                                M.call_closure (|
                                  Ty.apply
                                    (Ty.path "alloc::collections::btree::node::Handle")
                                    []
                                    [
                                      Ty.apply
                                        (Ty.path "alloc::collections::btree::node::NodeRef")
                                        []
                                        [
                                          Ty.path "alloc::collections::btree::node::marker::Mut";
                                          K;
                                          V;
                                          Ty.path "alloc::collections::btree::node::marker::Leaf"
                                        ];
                                      Ty.path "alloc::collections::btree::node::marker::KV"
                                    ],
                                  M.get_associated_function (|
                                    Ty.apply
                                      (Ty.path "alloc::collections::btree::node::Handle")
                                      []
                                      [
                                        Ty.apply
                                          (Ty.path "alloc::collections::btree::node::NodeRef")
                                          []
                                          [
                                            Ty.path "alloc::collections::btree::node::marker::Mut";
                                            K;
                                            V;
                                            Ty.path "alloc::collections::btree::node::marker::Leaf"
                                          ];
                                        Ty.path "alloc::collections::btree::node::marker::Edge"
                                      ],
                                    "insert_recursing",
                                    [],
                                    [
                                      A;
                                      Ty.function
                                        [
                                          Ty.tuple
                                            [
                                              Ty.apply
                                                (Ty.path
                                                  "alloc::collections::btree::node::SplitResult")
                                                []
                                                [
                                                  K;
                                                  V;
                                                  Ty.path
                                                    "alloc::collections::btree::node::marker::LeafOrInternal"
                                                ]
                                            ]
                                        ]
                                        (Ty.tuple [])
                                    ]
                                  |),
                                  [
                                    M.read (| handle |);
                                    M.read (|
                                      M.SubPointer.get_struct_record_field (|
                                        self,
                                        "alloc::collections::btree::map::entry::VacantEntry",
                                        "key"
                                      |)
                                    |);
                                    M.read (| value |);
                                    M.call_closure (|
                                      A,
                                      M.get_trait_method (|
                                        "core::clone::Clone",
                                        A,
                                        [],
                                        [],
                                        "clone",
                                        [],
                                        []
                                      |),
                                      [
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.SubPointer.get_struct_record_field (|
                                            self,
                                            "alloc::collections::btree::map::entry::VacantEntry",
                                            "alloc"
                                          |)
                                        |)
                                      ]
                                    |);
                                    M.closure
                                      (fun γ =>
                                        ltac:(M.monadic
                                          match γ with
                                          | [ α0 ] =>
                                            ltac:(M.monadic
                                              (M.match_operator (|
                                                Ty.apply
                                                  (Ty.path "*")
                                                  []
                                                  [
                                                    Ty.function
                                                      [
                                                        Ty.tuple
                                                          [
                                                            Ty.apply
                                                              (Ty.path
                                                                "alloc::collections::btree::node::SplitResult")
                                                              []
                                                              [
                                                                K;
                                                                V;
                                                                Ty.path
                                                                  "alloc::collections::btree::node::marker::LeafOrInternal"
                                                              ]
                                                          ]
                                                      ]
                                                      (Ty.tuple [])
                                                  ],
                                                M.alloc (| α0 |),
                                                [
                                                  fun γ =>
                                                    ltac:(M.monadic
                                                      (let ins := M.copy (| γ |) in
                                                      M.read (|
                                                        let~ _ :
                                                            Ty.apply
                                                              (Ty.path "*")
                                                              []
                                                              [ Ty.tuple [] ] :=
                                                          M.alloc (|
                                                            M.call_closure (|
                                                              Ty.tuple [],
                                                              M.get_function (|
                                                                "core::mem::drop",
                                                                [],
                                                                [
                                                                  Ty.apply
                                                                    (Ty.path
                                                                      "alloc::collections::btree::node::NodeRef")
                                                                    []
                                                                    [
                                                                      Ty.path
                                                                        "alloc::collections::btree::node::marker::Mut";
                                                                      K;
                                                                      V;
                                                                      Ty.path
                                                                        "alloc::collections::btree::node::marker::LeafOrInternal"
                                                                    ]
                                                                ]
                                                              |),
                                                              [
                                                                M.read (|
                                                                  M.SubPointer.get_struct_record_field (|
                                                                    ins,
                                                                    "alloc::collections::btree::node::SplitResult",
                                                                    "left"
                                                                  |)
                                                                |)
                                                              ]
                                                            |)
                                                          |) in
                                                        let~ map :
                                                            Ty.apply
                                                              (Ty.path "*")
                                                              []
                                                              [
                                                                Ty.apply
                                                                  (Ty.path "&mut")
                                                                  []
                                                                  [
                                                                    Ty.apply
                                                                      (Ty.path
                                                                        "alloc::collections::btree::map::BTreeMap")
                                                                      []
                                                                      [ K; V; A ]
                                                                  ]
                                                              ] :=
                                                          M.alloc (|
                                                            M.borrow (|
                                                              Pointer.Kind.MutRef,
                                                              M.deref (|
                                                                M.call_closure (|
                                                                  Ty.apply
                                                                    (Ty.path "&mut")
                                                                    []
                                                                    [
                                                                      Ty.apply
                                                                        (Ty.path
                                                                          "alloc::collections::btree::map::BTreeMap")
                                                                        []
                                                                        [ K; V; A ]
                                                                    ],
                                                                  M.get_associated_function (|
                                                                    Ty.apply
                                                                      (Ty.path
                                                                        "alloc::collections::btree::borrow::DormantMutRef")
                                                                      []
                                                                      [
                                                                        Ty.apply
                                                                          (Ty.path
                                                                            "alloc::collections::btree::map::BTreeMap")
                                                                          []
                                                                          [ K; V; A ]
                                                                      ],
                                                                    "reborrow",
                                                                    [],
                                                                    []
                                                                  |),
                                                                  [
                                                                    M.borrow (|
                                                                      Pointer.Kind.MutRef,
                                                                      M.SubPointer.get_struct_record_field (|
                                                                        self,
                                                                        "alloc::collections::btree::map::entry::VacantEntry",
                                                                        "dormant_map"
                                                                      |)
                                                                    |)
                                                                  ]
                                                                |)
                                                              |)
                                                            |)
                                                          |) in
                                                        let~ root :
                                                            Ty.apply
                                                              (Ty.path "*")
                                                              []
                                                              [
                                                                Ty.apply
                                                                  (Ty.path "&mut")
                                                                  []
                                                                  [
                                                                    Ty.apply
                                                                      (Ty.path
                                                                        "alloc::collections::btree::node::NodeRef")
                                                                      []
                                                                      [
                                                                        Ty.path
                                                                          "alloc::collections::btree::node::marker::Owned";
                                                                        K;
                                                                        V;
                                                                        Ty.path
                                                                          "alloc::collections::btree::node::marker::LeafOrInternal"
                                                                      ]
                                                                  ]
                                                              ] :=
                                                          M.alloc (|
                                                            M.call_closure (|
                                                              Ty.apply
                                                                (Ty.path "&mut")
                                                                []
                                                                [
                                                                  Ty.apply
                                                                    (Ty.path
                                                                      "alloc::collections::btree::node::NodeRef")
                                                                    []
                                                                    [
                                                                      Ty.path
                                                                        "alloc::collections::btree::node::marker::Owned";
                                                                      K;
                                                                      V;
                                                                      Ty.path
                                                                        "alloc::collections::btree::node::marker::LeafOrInternal"
                                                                    ]
                                                                ],
                                                              M.get_associated_function (|
                                                                Ty.apply
                                                                  (Ty.path "core::option::Option")
                                                                  []
                                                                  [
                                                                    Ty.apply
                                                                      (Ty.path "&mut")
                                                                      []
                                                                      [
                                                                        Ty.apply
                                                                          (Ty.path
                                                                            "alloc::collections::btree::node::NodeRef")
                                                                          []
                                                                          [
                                                                            Ty.path
                                                                              "alloc::collections::btree::node::marker::Owned";
                                                                            K;
                                                                            V;
                                                                            Ty.path
                                                                              "alloc::collections::btree::node::marker::LeafOrInternal"
                                                                          ]
                                                                      ]
                                                                  ],
                                                                "unwrap",
                                                                [],
                                                                []
                                                              |),
                                                              [
                                                                M.call_closure (|
                                                                  Ty.apply
                                                                    (Ty.path "core::option::Option")
                                                                    []
                                                                    [
                                                                      Ty.apply
                                                                        (Ty.path "&mut")
                                                                        []
                                                                        [
                                                                          Ty.apply
                                                                            (Ty.path
                                                                              "alloc::collections::btree::node::NodeRef")
                                                                            []
                                                                            [
                                                                              Ty.path
                                                                                "alloc::collections::btree::node::marker::Owned";
                                                                              K;
                                                                              V;
                                                                              Ty.path
                                                                                "alloc::collections::btree::node::marker::LeafOrInternal"
                                                                            ]
                                                                        ]
                                                                    ],
                                                                  M.get_associated_function (|
                                                                    Ty.apply
                                                                      (Ty.path
                                                                        "core::option::Option")
                                                                      []
                                                                      [
                                                                        Ty.apply
                                                                          (Ty.path
                                                                            "alloc::collections::btree::node::NodeRef")
                                                                          []
                                                                          [
                                                                            Ty.path
                                                                              "alloc::collections::btree::node::marker::Owned";
                                                                            K;
                                                                            V;
                                                                            Ty.path
                                                                              "alloc::collections::btree::node::marker::LeafOrInternal"
                                                                          ]
                                                                      ],
                                                                    "as_mut",
                                                                    [],
                                                                    []
                                                                  |),
                                                                  [
                                                                    M.borrow (|
                                                                      Pointer.Kind.MutRef,
                                                                      M.SubPointer.get_struct_record_field (|
                                                                        M.deref (|
                                                                          M.read (| map |)
                                                                        |),
                                                                        "alloc::collections::btree::map::BTreeMap",
                                                                        "root"
                                                                      |)
                                                                    |)
                                                                  ]
                                                                |)
                                                              ]
                                                            |)
                                                          |) in
                                                        M.alloc (|
                                                          M.call_closure (|
                                                            Ty.tuple [],
                                                            M.get_associated_function (|
                                                              Ty.apply
                                                                (Ty.path
                                                                  "alloc::collections::btree::node::NodeRef")
                                                                []
                                                                [
                                                                  Ty.path
                                                                    "alloc::collections::btree::node::marker::Mut";
                                                                  K;
                                                                  V;
                                                                  Ty.path
                                                                    "alloc::collections::btree::node::marker::Internal"
                                                                ],
                                                              "push",
                                                              [],
                                                              []
                                                            |),
                                                            [
                                                              M.borrow (|
                                                                Pointer.Kind.MutRef,
                                                                M.alloc (|
                                                                  M.call_closure (|
                                                                    Ty.apply
                                                                      (Ty.path
                                                                        "alloc::collections::btree::node::NodeRef")
                                                                      []
                                                                      [
                                                                        Ty.path
                                                                          "alloc::collections::btree::node::marker::Mut";
                                                                        K;
                                                                        V;
                                                                        Ty.path
                                                                          "alloc::collections::btree::node::marker::Internal"
                                                                      ],
                                                                    M.get_associated_function (|
                                                                      Ty.apply
                                                                        (Ty.path
                                                                          "alloc::collections::btree::node::NodeRef")
                                                                        []
                                                                        [
                                                                          Ty.path
                                                                            "alloc::collections::btree::node::marker::Owned";
                                                                          K;
                                                                          V;
                                                                          Ty.path
                                                                            "alloc::collections::btree::node::marker::LeafOrInternal"
                                                                        ],
                                                                      "push_internal_level",
                                                                      [],
                                                                      [ A ]
                                                                    |),
                                                                    [
                                                                      M.borrow (|
                                                                        Pointer.Kind.MutRef,
                                                                        M.deref (|
                                                                          M.read (| root |)
                                                                        |)
                                                                      |);
                                                                      M.call_closure (|
                                                                        A,
                                                                        M.get_trait_method (|
                                                                          "core::clone::Clone",
                                                                          A,
                                                                          [],
                                                                          [],
                                                                          "clone",
                                                                          [],
                                                                          []
                                                                        |),
                                                                        [
                                                                          M.borrow (|
                                                                            Pointer.Kind.Ref,
                                                                            M.SubPointer.get_struct_record_field (|
                                                                              self,
                                                                              "alloc::collections::btree::map::entry::VacantEntry",
                                                                              "alloc"
                                                                            |)
                                                                          |)
                                                                        ]
                                                                      |)
                                                                    ]
                                                                  |)
                                                                |)
                                                              |);
                                                              M.read (|
                                                                M.SubPointer.get_tuple_field (|
                                                                  M.SubPointer.get_struct_record_field (|
                                                                    ins,
                                                                    "alloc::collections::btree::node::SplitResult",
                                                                    "kv"
                                                                  |),
                                                                  0
                                                                |)
                                                              |);
                                                              M.read (|
                                                                M.SubPointer.get_tuple_field (|
                                                                  M.SubPointer.get_struct_record_field (|
                                                                    ins,
                                                                    "alloc::collections::btree::node::SplitResult",
                                                                    "kv"
                                                                  |),
                                                                  1
                                                                |)
                                                              |);
                                                              M.read (|
                                                                M.SubPointer.get_struct_record_field (|
                                                                  ins,
                                                                  "alloc::collections::btree::node::SplitResult",
                                                                  "right"
                                                                |)
                                                              |)
                                                            ]
                                                          |)
                                                        |)
                                                      |)))
                                                ]
                                              |)))
                                          | _ => M.impossible "wrong number of arguments"
                                          end))
                                  ]
                                |)
                              |)))
                        ]
                      |)
                    |) in
                  let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                    M.alloc (|
                      let β :=
                        M.SubPointer.get_struct_record_field (|
                          M.deref (|
                            M.call_closure (|
                              Ty.apply
                                (Ty.path "&mut")
                                []
                                [
                                  Ty.apply
                                    (Ty.path "alloc::collections::btree::map::BTreeMap")
                                    []
                                    [ K; V; A ]
                                ],
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "alloc::collections::btree::borrow::DormantMutRef")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "alloc::collections::btree::map::BTreeMap")
                                      []
                                      [ K; V; A ]
                                  ],
                                "reborrow",
                                [],
                                []
                              |),
                              [
                                M.borrow (|
                                  Pointer.Kind.MutRef,
                                  M.SubPointer.get_struct_record_field (|
                                    self,
                                    "alloc::collections::btree::map::entry::VacantEntry",
                                    "dormant_map"
                                  |)
                                |)
                              ]
                            |)
                          |),
                          "alloc::collections::btree::map::BTreeMap",
                          "length"
                        |) in
                      M.write (|
                        β,
                        M.call_closure (|
                          Ty.path "usize",
                          BinOp.Wrap.add,
                          [ M.read (| β |); Value.Integer IntegerKind.Usize 1 ]
                        |)
                      |)
                    |) in
                  M.alloc (|
                    Value.StructRecord
                      "alloc::collections::btree::map::entry::OccupiedEntry"
                      []
                      [ K; V; A ]
                      [
                        ("handle",
                          M.call_closure (|
                            Ty.apply
                              (Ty.path "alloc::collections::btree::node::Handle")
                              []
                              [
                                Ty.apply
                                  (Ty.path "alloc::collections::btree::node::NodeRef")
                                  []
                                  [
                                    Ty.path "alloc::collections::btree::node::marker::Mut";
                                    K;
                                    V;
                                    Ty.path
                                      "alloc::collections::btree::node::marker::LeafOrInternal"
                                  ];
                                Ty.path "alloc::collections::btree::node::marker::KV"
                              ],
                            M.get_associated_function (|
                              Ty.apply
                                (Ty.path "alloc::collections::btree::node::Handle")
                                []
                                [
                                  Ty.apply
                                    (Ty.path "alloc::collections::btree::node::NodeRef")
                                    []
                                    [
                                      Ty.path "alloc::collections::btree::node::marker::Mut";
                                      K;
                                      V;
                                      Ty.path "alloc::collections::btree::node::marker::Leaf"
                                    ];
                                  Ty.path "alloc::collections::btree::node::marker::KV"
                                ],
                              "forget_node_type",
                              [],
                              []
                            |),
                            [ M.read (| handle |) ]
                          |));
                        ("dormant_map",
                          M.read (|
                            M.SubPointer.get_struct_record_field (|
                              self,
                              "alloc::collections::btree::map::entry::VacantEntry",
                              "dormant_map"
                            |)
                          |));
                        ("alloc",
                          M.read (|
                            M.SubPointer.get_struct_record_field (|
                              self,
                              "alloc::collections::btree::map::entry::VacantEntry",
                              "alloc"
                            |)
                          |));
                        ("_marker",
                          Value.StructTuple
                            "core::marker::PhantomData"
                            []
                            [ Ty.apply (Ty.path "&mut") [] [ Ty.tuple [ K; V ] ] ]
                            [])
                      ]
                  |)
                |)))
            | _, _, _ => M.impossible "wrong number of arguments"
            end.
          
          Global Instance AssociatedFunction_insert_entry :
            forall (K V A : Ty.t),
            M.IsAssociatedFunction.C (Self K V A) "insert_entry" (insert_entry K V A).
          Admitted.
          Global Typeclasses Opaque insert_entry.
        End Impl_alloc_collections_btree_map_entry_VacantEntry_K_V_A.
        
        Module Impl_alloc_collections_btree_map_entry_OccupiedEntry_K_V_A.
          Definition Self (K V A : Ty.t) : Ty.t :=
            Ty.apply
              (Ty.path "alloc::collections::btree::map::entry::OccupiedEntry")
              []
              [ K; V; A ].
          
          (*
              pub fn key(&self) -> &K {
                  self.handle.reborrow().into_kv().0
              }
          *)
          Definition key (K V A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
            let Self : Ty.t := Self K V A in
            match ε, τ, α with
            | [], [], [ self ] =>
              ltac:(M.monadic
                (let self := M.alloc (| self |) in
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.read (|
                      M.SubPointer.get_tuple_field (|
                        M.alloc (|
                          M.call_closure (|
                            Ty.tuple
                              [ Ty.apply (Ty.path "&") [] [ K ]; Ty.apply (Ty.path "&") [] [ V ] ],
                            M.get_associated_function (|
                              Ty.apply
                                (Ty.path "alloc::collections::btree::node::Handle")
                                []
                                [
                                  Ty.apply
                                    (Ty.path "alloc::collections::btree::node::NodeRef")
                                    []
                                    [
                                      Ty.path "alloc::collections::btree::node::marker::Immut";
                                      K;
                                      V;
                                      Ty.path
                                        "alloc::collections::btree::node::marker::LeafOrInternal"
                                    ];
                                  Ty.path "alloc::collections::btree::node::marker::KV"
                                ],
                              "into_kv",
                              [],
                              []
                            |),
                            [
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "alloc::collections::btree::node::Handle")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "alloc::collections::btree::node::NodeRef")
                                      []
                                      [
                                        Ty.path "alloc::collections::btree::node::marker::Immut";
                                        K;
                                        V;
                                        Ty.path
                                          "alloc::collections::btree::node::marker::LeafOrInternal"
                                      ];
                                    Ty.path "alloc::collections::btree::node::marker::KV"
                                  ],
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "alloc::collections::btree::node::Handle")
                                    []
                                    [
                                      Ty.apply
                                        (Ty.path "alloc::collections::btree::node::NodeRef")
                                        []
                                        [
                                          Ty.path "alloc::collections::btree::node::marker::Mut";
                                          K;
                                          V;
                                          Ty.path
                                            "alloc::collections::btree::node::marker::LeafOrInternal"
                                        ];
                                      Ty.path "alloc::collections::btree::node::marker::KV"
                                    ],
                                  "reborrow",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.SubPointer.get_struct_record_field (|
                                      M.deref (| M.read (| self |) |),
                                      "alloc::collections::btree::map::entry::OccupiedEntry",
                                      "handle"
                                    |)
                                  |)
                                ]
                              |)
                            ]
                          |)
                        |),
                        0
                      |)
                    |)
                  |)
                |)))
            | _, _, _ => M.impossible "wrong number of arguments"
            end.
          
          Global Instance AssociatedFunction_key :
            forall (K V A : Ty.t),
            M.IsAssociatedFunction.C (Self K V A) "key" (key K V A).
          Admitted.
          Global Typeclasses Opaque key.
          
          (*
              pub(crate) fn into_key(self) -> &'a K {
                  self.handle.into_kv_mut().0
              }
          *)
          Definition into_key
              (K V A : Ty.t)
              (ε : list Value.t)
              (τ : list Ty.t)
              (α : list Value.t)
              : M :=
            let Self : Ty.t := Self K V A in
            match ε, τ, α with
            | [], [], [ self ] =>
              ltac:(M.monadic
                (let self := M.alloc (| self |) in
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.read (|
                      M.SubPointer.get_tuple_field (|
                        M.alloc (|
                          M.call_closure (|
                            Ty.tuple
                              [
                                Ty.apply (Ty.path "&mut") [] [ K ];
                                Ty.apply (Ty.path "&mut") [] [ V ]
                              ],
                            M.get_associated_function (|
                              Ty.apply
                                (Ty.path "alloc::collections::btree::node::Handle")
                                []
                                [
                                  Ty.apply
                                    (Ty.path "alloc::collections::btree::node::NodeRef")
                                    []
                                    [
                                      Ty.path "alloc::collections::btree::node::marker::Mut";
                                      K;
                                      V;
                                      Ty.path
                                        "alloc::collections::btree::node::marker::LeafOrInternal"
                                    ];
                                  Ty.path "alloc::collections::btree::node::marker::KV"
                                ],
                              "into_kv_mut",
                              [],
                              []
                            |),
                            [
                              M.read (|
                                M.SubPointer.get_struct_record_field (|
                                  self,
                                  "alloc::collections::btree::map::entry::OccupiedEntry",
                                  "handle"
                                |)
                              |)
                            ]
                          |)
                        |),
                        0
                      |)
                    |)
                  |)
                |)))
            | _, _, _ => M.impossible "wrong number of arguments"
            end.
          
          Global Instance AssociatedFunction_into_key :
            forall (K V A : Ty.t),
            M.IsAssociatedFunction.C (Self K V A) "into_key" (into_key K V A).
          Admitted.
          Global Typeclasses Opaque into_key.
          
          (*
              pub fn remove_entry(self) -> (K, V) {
                  self.remove_kv()
              }
          *)
          Definition remove_entry
              (K V A : Ty.t)
              (ε : list Value.t)
              (τ : list Ty.t)
              (α : list Value.t)
              : M :=
            let Self : Ty.t := Self K V A in
            match ε, τ, α with
            | [], [], [ self ] =>
              ltac:(M.monadic
                (let self := M.alloc (| self |) in
                M.call_closure (|
                  Ty.tuple [ K; V ],
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "alloc::collections::btree::map::entry::OccupiedEntry")
                      []
                      [ K; V; A ],
                    "remove_kv",
                    [],
                    []
                  |),
                  [ M.read (| self |) ]
                |)))
            | _, _, _ => M.impossible "wrong number of arguments"
            end.
          
          Global Instance AssociatedFunction_remove_entry :
            forall (K V A : Ty.t),
            M.IsAssociatedFunction.C (Self K V A) "remove_entry" (remove_entry K V A).
          Admitted.
          Global Typeclasses Opaque remove_entry.
          
          (*
              pub fn get(&self) -> &V {
                  self.handle.reborrow().into_kv().1
              }
          *)
          Definition get (K V A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
            let Self : Ty.t := Self K V A in
            match ε, τ, α with
            | [], [], [ self ] =>
              ltac:(M.monadic
                (let self := M.alloc (| self |) in
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.read (|
                      M.SubPointer.get_tuple_field (|
                        M.alloc (|
                          M.call_closure (|
                            Ty.tuple
                              [ Ty.apply (Ty.path "&") [] [ K ]; Ty.apply (Ty.path "&") [] [ V ] ],
                            M.get_associated_function (|
                              Ty.apply
                                (Ty.path "alloc::collections::btree::node::Handle")
                                []
                                [
                                  Ty.apply
                                    (Ty.path "alloc::collections::btree::node::NodeRef")
                                    []
                                    [
                                      Ty.path "alloc::collections::btree::node::marker::Immut";
                                      K;
                                      V;
                                      Ty.path
                                        "alloc::collections::btree::node::marker::LeafOrInternal"
                                    ];
                                  Ty.path "alloc::collections::btree::node::marker::KV"
                                ],
                              "into_kv",
                              [],
                              []
                            |),
                            [
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "alloc::collections::btree::node::Handle")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "alloc::collections::btree::node::NodeRef")
                                      []
                                      [
                                        Ty.path "alloc::collections::btree::node::marker::Immut";
                                        K;
                                        V;
                                        Ty.path
                                          "alloc::collections::btree::node::marker::LeafOrInternal"
                                      ];
                                    Ty.path "alloc::collections::btree::node::marker::KV"
                                  ],
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "alloc::collections::btree::node::Handle")
                                    []
                                    [
                                      Ty.apply
                                        (Ty.path "alloc::collections::btree::node::NodeRef")
                                        []
                                        [
                                          Ty.path "alloc::collections::btree::node::marker::Mut";
                                          K;
                                          V;
                                          Ty.path
                                            "alloc::collections::btree::node::marker::LeafOrInternal"
                                        ];
                                      Ty.path "alloc::collections::btree::node::marker::KV"
                                    ],
                                  "reborrow",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.SubPointer.get_struct_record_field (|
                                      M.deref (| M.read (| self |) |),
                                      "alloc::collections::btree::map::entry::OccupiedEntry",
                                      "handle"
                                    |)
                                  |)
                                ]
                              |)
                            ]
                          |)
                        |),
                        1
                      |)
                    |)
                  |)
                |)))
            | _, _, _ => M.impossible "wrong number of arguments"
            end.
          
          Global Instance AssociatedFunction_get :
            forall (K V A : Ty.t),
            M.IsAssociatedFunction.C (Self K V A) "get" (get K V A).
          Admitted.
          Global Typeclasses Opaque get.
          
          (*
              pub fn get_mut(&mut self) -> &mut V {
                  self.handle.kv_mut().1
              }
          *)
          Definition get_mut
              (K V A : Ty.t)
              (ε : list Value.t)
              (τ : list Ty.t)
              (α : list Value.t)
              : M :=
            let Self : Ty.t := Self K V A in
            match ε, τ, α with
            | [], [], [ self ] =>
              ltac:(M.monadic
                (let self := M.alloc (| self |) in
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.MutRef,
                      M.deref (|
                        M.read (|
                          M.SubPointer.get_tuple_field (|
                            M.alloc (|
                              M.call_closure (|
                                Ty.tuple
                                  [
                                    Ty.apply (Ty.path "&mut") [] [ K ];
                                    Ty.apply (Ty.path "&mut") [] [ V ]
                                  ],
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "alloc::collections::btree::node::Handle")
                                    []
                                    [
                                      Ty.apply
                                        (Ty.path "alloc::collections::btree::node::NodeRef")
                                        []
                                        [
                                          Ty.path "alloc::collections::btree::node::marker::Mut";
                                          K;
                                          V;
                                          Ty.path
                                            "alloc::collections::btree::node::marker::LeafOrInternal"
                                        ];
                                      Ty.path "alloc::collections::btree::node::marker::KV"
                                    ],
                                  "kv_mut",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (|
                                    Pointer.Kind.MutRef,
                                    M.SubPointer.get_struct_record_field (|
                                      M.deref (| M.read (| self |) |),
                                      "alloc::collections::btree::map::entry::OccupiedEntry",
                                      "handle"
                                    |)
                                  |)
                                ]
                              |)
                            |),
                            1
                          |)
                        |)
                      |)
                    |)
                  |)
                |)))
            | _, _, _ => M.impossible "wrong number of arguments"
            end.
          
          Global Instance AssociatedFunction_get_mut :
            forall (K V A : Ty.t),
            M.IsAssociatedFunction.C (Self K V A) "get_mut" (get_mut K V A).
          Admitted.
          Global Typeclasses Opaque get_mut.
          
          (*
              pub fn into_mut(self) -> &'a mut V {
                  self.handle.into_val_mut()
              }
          *)
          Definition into_mut
              (K V A : Ty.t)
              (ε : list Value.t)
              (τ : list Ty.t)
              (α : list Value.t)
              : M :=
            let Self : Ty.t := Self K V A in
            match ε, τ, α with
            | [], [], [ self ] =>
              ltac:(M.monadic
                (let self := M.alloc (| self |) in
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.MutRef,
                      M.deref (|
                        M.call_closure (|
                          Ty.apply (Ty.path "&mut") [] [ V ],
                          M.get_associated_function (|
                            Ty.apply
                              (Ty.path "alloc::collections::btree::node::Handle")
                              []
                              [
                                Ty.apply
                                  (Ty.path "alloc::collections::btree::node::NodeRef")
                                  []
                                  [
                                    Ty.path "alloc::collections::btree::node::marker::Mut";
                                    K;
                                    V;
                                    Ty.path
                                      "alloc::collections::btree::node::marker::LeafOrInternal"
                                  ];
                                Ty.path "alloc::collections::btree::node::marker::KV"
                              ],
                            "into_val_mut",
                            [],
                            []
                          |),
                          [
                            M.read (|
                              M.SubPointer.get_struct_record_field (|
                                self,
                                "alloc::collections::btree::map::entry::OccupiedEntry",
                                "handle"
                              |)
                            |)
                          ]
                        |)
                      |)
                    |)
                  |)
                |)))
            | _, _, _ => M.impossible "wrong number of arguments"
            end.
          
          Global Instance AssociatedFunction_into_mut :
            forall (K V A : Ty.t),
            M.IsAssociatedFunction.C (Self K V A) "into_mut" (into_mut K V A).
          Admitted.
          Global Typeclasses Opaque into_mut.
          
          (*
              pub fn insert(&mut self, value: V) -> V {
                  mem::replace(self.get_mut(), value)
              }
          *)
          Definition insert
              (K V A : Ty.t)
              (ε : list Value.t)
              (τ : list Ty.t)
              (α : list Value.t)
              : M :=
            let Self : Ty.t := Self K V A in
            match ε, τ, α with
            | [], [], [ self; value ] =>
              ltac:(M.monadic
                (let self := M.alloc (| self |) in
                let value := M.alloc (| value |) in
                M.call_closure (|
                  V,
                  M.get_function (| "core::mem::replace", [], [ V ] |),
                  [
                    M.borrow (|
                      Pointer.Kind.MutRef,
                      M.deref (|
                        M.call_closure (|
                          Ty.apply (Ty.path "&mut") [] [ V ],
                          M.get_associated_function (|
                            Ty.apply
                              (Ty.path "alloc::collections::btree::map::entry::OccupiedEntry")
                              []
                              [ K; V; A ],
                            "get_mut",
                            [],
                            []
                          |),
                          [ M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |) ]
                        |)
                      |)
                    |);
                    M.read (| value |)
                  ]
                |)))
            | _, _, _ => M.impossible "wrong number of arguments"
            end.
          
          Global Instance AssociatedFunction_insert :
            forall (K V A : Ty.t),
            M.IsAssociatedFunction.C (Self K V A) "insert" (insert K V A).
          Admitted.
          Global Typeclasses Opaque insert.
          
          (*
              pub fn remove(self) -> V {
                  self.remove_kv().1
              }
          *)
          Definition remove
              (K V A : Ty.t)
              (ε : list Value.t)
              (τ : list Ty.t)
              (α : list Value.t)
              : M :=
            let Self : Ty.t := Self K V A in
            match ε, τ, α with
            | [], [], [ self ] =>
              ltac:(M.monadic
                (let self := M.alloc (| self |) in
                M.read (|
                  M.SubPointer.get_tuple_field (|
                    M.alloc (|
                      M.call_closure (|
                        Ty.tuple [ K; V ],
                        M.get_associated_function (|
                          Ty.apply
                            (Ty.path "alloc::collections::btree::map::entry::OccupiedEntry")
                            []
                            [ K; V; A ],
                          "remove_kv",
                          [],
                          []
                        |),
                        [ M.read (| self |) ]
                      |)
                    |),
                    1
                  |)
                |)))
            | _, _, _ => M.impossible "wrong number of arguments"
            end.
          
          Global Instance AssociatedFunction_remove :
            forall (K V A : Ty.t),
            M.IsAssociatedFunction.C (Self K V A) "remove" (remove K V A).
          Admitted.
          Global Typeclasses Opaque remove.
          
          (*
              pub(super) fn remove_kv(self) -> (K, V) {
                  let mut emptied_internal_root = false;
                  let (old_kv, _) =
                      self.handle.remove_kv_tracking(|| emptied_internal_root = true, self.alloc.clone());
                  // SAFETY: we consumed the intermediate root borrow, `self.handle`.
                  let map = unsafe { self.dormant_map.awaken() };
                  map.length -= 1;
                  if emptied_internal_root {
                      let root = map.root.as_mut().unwrap();
                      root.pop_internal_level(self.alloc);
                  }
                  old_kv
              }
          *)
          Definition remove_kv
              (K V A : Ty.t)
              (ε : list Value.t)
              (τ : list Ty.t)
              (α : list Value.t)
              : M :=
            let Self : Ty.t := Self K V A in
            match ε, τ, α with
            | [], [], [ self ] =>
              ltac:(M.monadic
                (let self := M.alloc (| self |) in
                M.read (|
                  let~ emptied_internal_root : Ty.apply (Ty.path "*") [] [ Ty.path "bool" ] :=
                    M.alloc (| Value.Bool false |) in
                  M.match_operator (|
                    Ty.apply (Ty.path "*") [] [ Ty.tuple [ K; V ] ],
                    M.alloc (|
                      M.call_closure (|
                        Ty.tuple
                          [
                            Ty.tuple [ K; V ];
                            Ty.apply
                              (Ty.path "alloc::collections::btree::node::Handle")
                              []
                              [
                                Ty.apply
                                  (Ty.path "alloc::collections::btree::node::NodeRef")
                                  []
                                  [
                                    Ty.path "alloc::collections::btree::node::marker::Mut";
                                    K;
                                    V;
                                    Ty.path "alloc::collections::btree::node::marker::Leaf"
                                  ];
                                Ty.path "alloc::collections::btree::node::marker::Edge"
                              ]
                          ],
                        M.get_associated_function (|
                          Ty.apply
                            (Ty.path "alloc::collections::btree::node::Handle")
                            []
                            [
                              Ty.apply
                                (Ty.path "alloc::collections::btree::node::NodeRef")
                                []
                                [
                                  Ty.path "alloc::collections::btree::node::marker::Mut";
                                  K;
                                  V;
                                  Ty.path "alloc::collections::btree::node::marker::LeafOrInternal"
                                ];
                              Ty.path "alloc::collections::btree::node::marker::KV"
                            ],
                          "remove_kv_tracking",
                          [],
                          [ Ty.function [ Ty.tuple [] ] (Ty.tuple []); A ]
                        |),
                        [
                          M.read (|
                            M.SubPointer.get_struct_record_field (|
                              self,
                              "alloc::collections::btree::map::entry::OccupiedEntry",
                              "handle"
                            |)
                          |);
                          M.closure
                            (fun γ =>
                              ltac:(M.monadic
                                match γ with
                                | [ α0 ] =>
                                  ltac:(M.monadic
                                    (M.match_operator (|
                                      Ty.apply
                                        (Ty.path "*")
                                        []
                                        [ Ty.function [ Ty.tuple [] ] (Ty.tuple []) ],
                                      M.alloc (| α0 |),
                                      [
                                        fun γ =>
                                          ltac:(M.monadic
                                            (M.write (| emptied_internal_root, Value.Bool true |)))
                                      ]
                                    |)))
                                | _ => M.impossible "wrong number of arguments"
                                end));
                          M.call_closure (|
                            A,
                            M.get_trait_method (|
                              "core::clone::Clone",
                              A,
                              [],
                              [],
                              "clone",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.SubPointer.get_struct_record_field (|
                                  self,
                                  "alloc::collections::btree::map::entry::OccupiedEntry",
                                  "alloc"
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                          let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                          let old_kv := M.copy (| γ0_0 |) in
                          let~ map :
                              Ty.apply
                                (Ty.path "*")
                                []
                                [
                                  Ty.apply
                                    (Ty.path "&mut")
                                    []
                                    [
                                      Ty.apply
                                        (Ty.path "alloc::collections::btree::map::BTreeMap")
                                        []
                                        [ K; V; A ]
                                    ]
                                ] :=
                            M.alloc (|
                              M.borrow (|
                                Pointer.Kind.MutRef,
                                M.deref (|
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "&mut")
                                      []
                                      [
                                        Ty.apply
                                          (Ty.path "alloc::collections::btree::map::BTreeMap")
                                          []
                                          [ K; V; A ]
                                      ],
                                    M.get_associated_function (|
                                      Ty.apply
                                        (Ty.path "alloc::collections::btree::borrow::DormantMutRef")
                                        []
                                        [
                                          Ty.apply
                                            (Ty.path "alloc::collections::btree::map::BTreeMap")
                                            []
                                            [ K; V; A ]
                                        ],
                                      "awaken",
                                      [],
                                      []
                                    |),
                                    [
                                      M.read (|
                                        M.SubPointer.get_struct_record_field (|
                                          self,
                                          "alloc::collections::btree::map::entry::OccupiedEntry",
                                          "dormant_map"
                                        |)
                                      |)
                                    ]
                                  |)
                                |)
                              |)
                            |) in
                          let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                            M.alloc (|
                              let β :=
                                M.SubPointer.get_struct_record_field (|
                                  M.deref (| M.read (| map |) |),
                                  "alloc::collections::btree::map::BTreeMap",
                                  "length"
                                |) in
                              M.write (|
                                β,
                                M.call_closure (|
                                  Ty.path "usize",
                                  BinOp.Wrap.sub,
                                  [ M.read (| β |); Value.Integer IntegerKind.Usize 1 ]
                                |)
                              |)
                            |) in
                          let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                            M.match_operator (|
                              Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                              M.alloc (| Value.Tuple [] |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let γ := M.use emptied_internal_root in
                                    let _ :=
                                      is_constant_or_break_match (|
                                        M.read (| γ |),
                                        Value.Bool true
                                      |) in
                                    let~ root :
                                        Ty.apply
                                          (Ty.path "*")
                                          []
                                          [
                                            Ty.apply
                                              (Ty.path "&mut")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path
                                                    "alloc::collections::btree::node::NodeRef")
                                                  []
                                                  [
                                                    Ty.path
                                                      "alloc::collections::btree::node::marker::Owned";
                                                    K;
                                                    V;
                                                    Ty.path
                                                      "alloc::collections::btree::node::marker::LeafOrInternal"
                                                  ]
                                              ]
                                          ] :=
                                      M.alloc (|
                                        M.call_closure (|
                                          Ty.apply
                                            (Ty.path "&mut")
                                            []
                                            [
                                              Ty.apply
                                                (Ty.path "alloc::collections::btree::node::NodeRef")
                                                []
                                                [
                                                  Ty.path
                                                    "alloc::collections::btree::node::marker::Owned";
                                                  K;
                                                  V;
                                                  Ty.path
                                                    "alloc::collections::btree::node::marker::LeafOrInternal"
                                                ]
                                            ],
                                          M.get_associated_function (|
                                            Ty.apply
                                              (Ty.path "core::option::Option")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "&mut")
                                                  []
                                                  [
                                                    Ty.apply
                                                      (Ty.path
                                                        "alloc::collections::btree::node::NodeRef")
                                                      []
                                                      [
                                                        Ty.path
                                                          "alloc::collections::btree::node::marker::Owned";
                                                        K;
                                                        V;
                                                        Ty.path
                                                          "alloc::collections::btree::node::marker::LeafOrInternal"
                                                      ]
                                                  ]
                                              ],
                                            "unwrap",
                                            [],
                                            []
                                          |),
                                          [
                                            M.call_closure (|
                                              Ty.apply
                                                (Ty.path "core::option::Option")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path "&mut")
                                                    []
                                                    [
                                                      Ty.apply
                                                        (Ty.path
                                                          "alloc::collections::btree::node::NodeRef")
                                                        []
                                                        [
                                                          Ty.path
                                                            "alloc::collections::btree::node::marker::Owned";
                                                          K;
                                                          V;
                                                          Ty.path
                                                            "alloc::collections::btree::node::marker::LeafOrInternal"
                                                        ]
                                                    ]
                                                ],
                                              M.get_associated_function (|
                                                Ty.apply
                                                  (Ty.path "core::option::Option")
                                                  []
                                                  [
                                                    Ty.apply
                                                      (Ty.path
                                                        "alloc::collections::btree::node::NodeRef")
                                                      []
                                                      [
                                                        Ty.path
                                                          "alloc::collections::btree::node::marker::Owned";
                                                        K;
                                                        V;
                                                        Ty.path
                                                          "alloc::collections::btree::node::marker::LeafOrInternal"
                                                      ]
                                                  ],
                                                "as_mut",
                                                [],
                                                []
                                              |),
                                              [
                                                M.borrow (|
                                                  Pointer.Kind.MutRef,
                                                  M.SubPointer.get_struct_record_field (|
                                                    M.deref (| M.read (| map |) |),
                                                    "alloc::collections::btree::map::BTreeMap",
                                                    "root"
                                                  |)
                                                |)
                                              ]
                                            |)
                                          ]
                                        |)
                                      |) in
                                    let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                                      M.alloc (|
                                        M.call_closure (|
                                          Ty.tuple [],
                                          M.get_associated_function (|
                                            Ty.apply
                                              (Ty.path "alloc::collections::btree::node::NodeRef")
                                              []
                                              [
                                                Ty.path
                                                  "alloc::collections::btree::node::marker::Owned";
                                                K;
                                                V;
                                                Ty.path
                                                  "alloc::collections::btree::node::marker::LeafOrInternal"
                                              ],
                                            "pop_internal_level",
                                            [],
                                            [ A ]
                                          |),
                                          [
                                            M.borrow (|
                                              Pointer.Kind.MutRef,
                                              M.deref (| M.read (| root |) |)
                                            |);
                                            M.read (|
                                              M.SubPointer.get_struct_record_field (|
                                                self,
                                                "alloc::collections::btree::map::entry::OccupiedEntry",
                                                "alloc"
                                              |)
                                            |)
                                          ]
                                        |)
                                      |) in
                                    M.alloc (| Value.Tuple [] |)));
                                fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                              ]
                            |) in
                          old_kv))
                    ]
                  |)
                |)))
            | _, _, _ => M.impossible "wrong number of arguments"
            end.
          
          Global Instance AssociatedFunction_remove_kv :
            forall (K V A : Ty.t),
            M.IsAssociatedFunction.C (Self K V A) "remove_kv" (remove_kv K V A).
          Admitted.
          Global Typeclasses Opaque remove_kv.
        End Impl_alloc_collections_btree_map_entry_OccupiedEntry_K_V_A.
      End entry.
    End map.
  End btree.
End collections.
