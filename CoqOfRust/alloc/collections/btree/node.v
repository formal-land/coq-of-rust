(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module collections.
  Module btree.
    Module node.
      Definition value_B : Value.t := M.run ltac:(M.monadic (M.alloc (| Value.Integer 6 |))).
      
      Definition value_CAPACITY : Value.t :=
        M.run
          ltac:(M.monadic
            (M.alloc (|
              BinOp.Wrap.sub
                Integer.Usize
                (BinOp.Wrap.mul
                  Integer.Usize
                  (Value.Integer 2)
                  (M.read (| M.get_constant (| "alloc::collections::btree::node::B" |) |)))
                (Value.Integer 1)
            |))).
      
      Definition value_MIN_LEN_AFTER_SPLIT : Value.t :=
        M.run
          ltac:(M.monadic
            (M.alloc (|
              BinOp.Wrap.sub
                Integer.Usize
                (M.read (| M.get_constant (| "alloc::collections::btree::node::B" |) |))
                (Value.Integer 1)
            |))).
      
      Definition value_KV_IDX_CENTER : Value.t :=
        M.run
          ltac:(M.monadic
            (M.alloc (|
              BinOp.Wrap.sub
                Integer.Usize
                (M.read (| M.get_constant (| "alloc::collections::btree::node::B" |) |))
                (Value.Integer 1)
            |))).
      
      Definition value_EDGE_IDX_LEFT_OF_CENTER : Value.t :=
        M.run
          ltac:(M.monadic
            (M.alloc (|
              BinOp.Wrap.sub
                Integer.Usize
                (M.read (| M.get_constant (| "alloc::collections::btree::node::B" |) |))
                (Value.Integer 1)
            |))).
      
      Definition value_EDGE_IDX_RIGHT_OF_CENTER : Value.t :=
        M.run ltac:(M.monadic (M.get_constant (| "alloc::collections::btree::node::B" |))).
      
      (* StructRecord
        {
          name := "LeafNode";
          ty_params := [ "K"; "V" ];
          fields :=
            [
              ("parent",
                Ty.apply
                  (Ty.path "core::option::Option")
                  [
                    Ty.apply
                      (Ty.path "core::ptr::non_null::NonNull")
                      [ Ty.apply (Ty.path "alloc::collections::btree::node::InternalNode") [ K; V ]
                      ]
                  ]);
              ("parent_idx",
                Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ Ty.path "u16" ]);
              ("len", Ty.path "u16");
              ("keys",
                Ty.apply
                  (Ty.path "array")
                  [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ K ] ]);
              ("vals",
                Ty.apply
                  (Ty.path "array")
                  [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ V ] ])
            ];
        } *)
      
      Module Impl_alloc_collections_btree_node_LeafNode_K_V.
        Definition Self (K V : Ty.t) : Ty.t :=
          Ty.apply (Ty.path "alloc::collections::btree::node::LeafNode") [ K; V ].
        
        (*
            unsafe fn init(this: *mut Self) {
                // As a general policy, we leave fields uninitialized if they can be, as this should
                // be both slightly faster and easier to track in Valgrind.
                unsafe {
                    // parent_idx, keys, and vals are all MaybeUninit
                    ptr::addr_of_mut!(( *this).parent).write(None);
                    ptr::addr_of_mut!(( *this).len).write(0);
                }
            }
        *)
        Definition init (K V : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self K V in
          match τ, α with
          | [], [ this ] =>
            ltac:(M.monadic
              (let this := M.alloc (| this |) in
              M.read (|
                let~ _ :=
                  M.alloc (|
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "*mut")
                          [
                            Ty.apply
                              (Ty.path "core::option::Option")
                              [
                                Ty.apply
                                  (Ty.path "core::ptr::non_null::NonNull")
                                  [
                                    Ty.apply
                                      (Ty.path "alloc::collections::btree::node::InternalNode")
                                      [ K; V ]
                                  ]
                              ]
                          ],
                        "write",
                        []
                      |),
                      [
                        M.SubPointer.get_struct_record_field (|
                          M.read (| this |),
                          "alloc::collections::btree::node::LeafNode",
                          "parent"
                        |);
                        Value.StructTuple "core::option::Option::None" []
                      ]
                    |)
                  |) in
                let~ _ :=
                  M.alloc (|
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "*mut") [ Ty.path "u16" ],
                        "write",
                        []
                      |),
                      [
                        M.SubPointer.get_struct_record_field (|
                          M.read (| this |),
                          "alloc::collections::btree::node::LeafNode",
                          "len"
                        |);
                        Value.Integer 0
                      ]
                    |)
                  |) in
                M.alloc (| Value.Tuple [] |)
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom AssociatedFunction_init :
          forall (K V : Ty.t),
          M.IsAssociatedFunction (Self K V) "init" (init K V).
        
        (*
            fn new<A: Allocator + Clone>(alloc: A) -> Box<Self, A> {
                unsafe {
                    let mut leaf = Box::new_uninit_in(alloc);
                    LeafNode::init(leaf.as_mut_ptr());
                    leaf.assume_init()
                }
            }
        *)
        Definition new (K V : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self K V in
          match τ, α with
          | [ A ], [ alloc ] =>
            ltac:(M.monadic
              (let alloc := M.alloc (| alloc |) in
              M.read (|
                let~ leaf :=
                  M.alloc (|
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "alloc::boxed::Box")
                          [
                            Ty.apply (Ty.path "alloc::collections::btree::node::LeafNode") [ K; V ];
                            A
                          ],
                        "new_uninit_in",
                        []
                      |),
                      [ M.read (| alloc |) ]
                    |)
                  |) in
                let~ _ :=
                  M.alloc (|
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "alloc::collections::btree::node::LeafNode") [ K; V ],
                        "init",
                        []
                      |),
                      [
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.apply
                              (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                              [
                                Ty.apply
                                  (Ty.path "alloc::collections::btree::node::LeafNode")
                                  [ K; V ]
                              ],
                            "as_mut_ptr",
                            []
                          |),
                          [ M.read (| leaf |) ]
                        |)
                      ]
                    |)
                  |) in
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "alloc::boxed::Box")
                        [
                          Ty.apply
                            (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                            [
                              Ty.apply
                                (Ty.path "alloc::collections::btree::node::LeafNode")
                                [ K; V ]
                            ];
                          A
                        ],
                      "assume_init",
                      []
                    |),
                    [ M.read (| leaf |) ]
                  |)
                |)
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom AssociatedFunction_new :
          forall (K V : Ty.t),
          M.IsAssociatedFunction (Self K V) "new" (new K V).
      End Impl_alloc_collections_btree_node_LeafNode_K_V.
      
      (* StructRecord
        {
          name := "InternalNode";
          ty_params := [ "K"; "V" ];
          fields :=
            [
              ("data", Ty.apply (Ty.path "alloc::collections::btree::node::LeafNode") [ K; V ]);
              ("edges",
                Ty.apply
                  (Ty.path "array")
                  [
                    Ty.apply
                      (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                      [
                        Ty.apply
                          (Ty.path "core::ptr::non_null::NonNull")
                          [ Ty.apply (Ty.path "alloc::collections::btree::node::LeafNode") [ K; V ]
                          ]
                      ]
                  ])
            ];
        } *)
      
      Module Impl_alloc_collections_btree_node_InternalNode_K_V.
        Definition Self (K V : Ty.t) : Ty.t :=
          Ty.apply (Ty.path "alloc::collections::btree::node::InternalNode") [ K; V ].
        
        (*
            unsafe fn new<A: Allocator + Clone>(alloc: A) -> Box<Self, A> {
                unsafe {
                    let mut node = Box::<Self, _>::new_uninit_in(alloc);
                    // We only need to initialize the data; the edges are MaybeUninit.
                    LeafNode::init(ptr::addr_of_mut!(( *node.as_mut_ptr()).data));
                    node.assume_init()
                }
            }
        *)
        Definition new (K V : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self K V in
          match τ, α with
          | [ A ], [ alloc ] =>
            ltac:(M.monadic
              (let alloc := M.alloc (| alloc |) in
              M.read (|
                let~ node :=
                  M.alloc (|
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "alloc::boxed::Box")
                          [
                            Ty.apply
                              (Ty.path "alloc::collections::btree::node::InternalNode")
                              [ K; V ];
                            A
                          ],
                        "new_uninit_in",
                        []
                      |),
                      [ M.read (| alloc |) ]
                    |)
                  |) in
                let~ _ :=
                  M.alloc (|
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "alloc::collections::btree::node::LeafNode") [ K; V ],
                        "init",
                        []
                      |),
                      [
                        M.SubPointer.get_struct_record_field (|
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply
                                (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                [
                                  Ty.apply
                                    (Ty.path "alloc::collections::btree::node::InternalNode")
                                    [ K; V ]
                                ],
                              "as_mut_ptr",
                              []
                            |),
                            [ M.read (| node |) ]
                          |),
                          "alloc::collections::btree::node::InternalNode",
                          "data"
                        |)
                      ]
                    |)
                  |) in
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "alloc::boxed::Box")
                        [
                          Ty.apply
                            (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                            [
                              Ty.apply
                                (Ty.path "alloc::collections::btree::node::InternalNode")
                                [ K; V ]
                            ];
                          A
                        ],
                      "assume_init",
                      []
                    |),
                    [ M.read (| node |) ]
                  |)
                |)
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom AssociatedFunction_new :
          forall (K V : Ty.t),
          M.IsAssociatedFunction (Self K V) "new" (new K V).
      End Impl_alloc_collections_btree_node_InternalNode_K_V.
      
      Axiom BoxedNode :
        forall (K V : Ty.t),
        (Ty.apply (Ty.path "alloc::collections::btree::node::BoxedNode") [ K; V ]) =
          (Ty.apply
            (Ty.path "core::ptr::non_null::NonNull")
            [ Ty.apply (Ty.path "alloc::collections::btree::node::LeafNode") [ K; V ] ]).
      
      (* StructRecord
        {
          name := "NodeRef";
          ty_params := [ "BorrowType"; "K"; "V"; "Type_" ];
          fields :=
            [
              ("height", Ty.path "usize");
              ("node",
                Ty.apply
                  (Ty.path "core::ptr::non_null::NonNull")
                  [ Ty.apply (Ty.path "alloc::collections::btree::node::LeafNode") [ K; V ] ]);
              ("_marker",
                Ty.apply (Ty.path "core::marker::PhantomData") [ Ty.tuple [ BorrowType; Type_ ] ])
            ];
        } *)
      
      Axiom Root :
        forall (K V : Ty.t),
        (Ty.apply (Ty.path "alloc::collections::btree::node::Root") [ K; V ]) =
          (Ty.apply
            (Ty.path "alloc::collections::btree::node::NodeRef")
            [
              Ty.path "alloc::collections::btree::node::marker::Owned";
              K;
              V;
              Ty.path "alloc::collections::btree::node::marker::LeafOrInternal"
            ]).
      
      Module Impl_core_marker_Copy_for_alloc_collections_btree_node_NodeRef_alloc_collections_btree_node_marker_Immut_K_V_Type_.
        Definition Self (K V Type_ : Ty.t) : Ty.t :=
          Ty.apply
            (Ty.path "alloc::collections::btree::node::NodeRef")
            [ Ty.path "alloc::collections::btree::node::marker::Immut"; K; V; Type_ ].
        
        Axiom Implements :
          forall (K V Type_ : Ty.t),
          M.IsTraitInstance
            "core::marker::Copy"
            (Self K V Type_)
            (* Trait polymorphic types *) []
            (* Instance *) [].
      End Impl_core_marker_Copy_for_alloc_collections_btree_node_NodeRef_alloc_collections_btree_node_marker_Immut_K_V_Type_.
      
      Module Impl_core_clone_Clone_for_alloc_collections_btree_node_NodeRef_alloc_collections_btree_node_marker_Immut_K_V_Type_.
        Definition Self (K V Type_ : Ty.t) : Ty.t :=
          Ty.apply
            (Ty.path "alloc::collections::btree::node::NodeRef")
            [ Ty.path "alloc::collections::btree::node::marker::Immut"; K; V; Type_ ].
        
        (*
            fn clone(&self) -> Self {
                *self
            }
        *)
        Definition clone (K V Type_ : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self K V Type_ in
          match τ, α with
          | [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              M.read (| M.read (| self |) |)))
          | _, _ => M.impossible
          end.
        
        Axiom Implements :
          forall (K V Type_ : Ty.t),
          M.IsTraitInstance
            "core::clone::Clone"
            (Self K V Type_)
            (* Trait polymorphic types *) []
            (* Instance *) [ ("clone", InstanceField.Method (clone K V Type_)) ].
      End Impl_core_clone_Clone_for_alloc_collections_btree_node_NodeRef_alloc_collections_btree_node_marker_Immut_K_V_Type_.
      
      Module Impl_core_marker_Sync_where_core_marker_Sync_K_where_core_marker_Sync_V_for_alloc_collections_btree_node_NodeRef_BorrowType_K_V_Type_.
        Definition Self (BorrowType K V Type_ : Ty.t) : Ty.t :=
          Ty.apply (Ty.path "alloc::collections::btree::node::NodeRef") [ BorrowType; K; V; Type_ ].
        
        Axiom Implements :
          forall (BorrowType K V Type_ : Ty.t),
          M.IsTraitInstance
            "core::marker::Sync"
            (Self BorrowType K V Type_)
            (* Trait polymorphic types *) []
            (* Instance *) [].
      End Impl_core_marker_Sync_where_core_marker_Sync_K_where_core_marker_Sync_V_for_alloc_collections_btree_node_NodeRef_BorrowType_K_V_Type_.
      
      Module Impl_core_marker_Send_where_core_marker_Sync_K_where_core_marker_Sync_V_for_alloc_collections_btree_node_NodeRef_alloc_collections_btree_node_marker_Immut_K_V_Type_.
        Definition Self (K V Type_ : Ty.t) : Ty.t :=
          Ty.apply
            (Ty.path "alloc::collections::btree::node::NodeRef")
            [ Ty.path "alloc::collections::btree::node::marker::Immut"; K; V; Type_ ].
        
        Axiom Implements :
          forall (K V Type_ : Ty.t),
          M.IsTraitInstance
            "core::marker::Send"
            (Self K V Type_)
            (* Trait polymorphic types *) []
            (* Instance *) [].
      End Impl_core_marker_Send_where_core_marker_Sync_K_where_core_marker_Sync_V_for_alloc_collections_btree_node_NodeRef_alloc_collections_btree_node_marker_Immut_K_V_Type_.
      
      Module Impl_core_marker_Send_where_core_marker_Send_K_where_core_marker_Send_V_for_alloc_collections_btree_node_NodeRef_alloc_collections_btree_node_marker_Mut_K_V_Type_.
        Definition Self (K V Type_ : Ty.t) : Ty.t :=
          Ty.apply
            (Ty.path "alloc::collections::btree::node::NodeRef")
            [ Ty.path "alloc::collections::btree::node::marker::Mut"; K; V; Type_ ].
        
        Axiom Implements :
          forall (K V Type_ : Ty.t),
          M.IsTraitInstance
            "core::marker::Send"
            (Self K V Type_)
            (* Trait polymorphic types *) []
            (* Instance *) [].
      End Impl_core_marker_Send_where_core_marker_Send_K_where_core_marker_Send_V_for_alloc_collections_btree_node_NodeRef_alloc_collections_btree_node_marker_Mut_K_V_Type_.
      
      Module Impl_core_marker_Send_where_core_marker_Send_K_where_core_marker_Send_V_for_alloc_collections_btree_node_NodeRef_alloc_collections_btree_node_marker_ValMut_K_V_Type_.
        Definition Self (K V Type_ : Ty.t) : Ty.t :=
          Ty.apply
            (Ty.path "alloc::collections::btree::node::NodeRef")
            [ Ty.path "alloc::collections::btree::node::marker::ValMut"; K; V; Type_ ].
        
        Axiom Implements :
          forall (K V Type_ : Ty.t),
          M.IsTraitInstance
            "core::marker::Send"
            (Self K V Type_)
            (* Trait polymorphic types *) []
            (* Instance *) [].
      End Impl_core_marker_Send_where_core_marker_Send_K_where_core_marker_Send_V_for_alloc_collections_btree_node_NodeRef_alloc_collections_btree_node_marker_ValMut_K_V_Type_.
      
      Module Impl_core_marker_Send_where_core_marker_Send_K_where_core_marker_Send_V_for_alloc_collections_btree_node_NodeRef_alloc_collections_btree_node_marker_Owned_K_V_Type_.
        Definition Self (K V Type_ : Ty.t) : Ty.t :=
          Ty.apply
            (Ty.path "alloc::collections::btree::node::NodeRef")
            [ Ty.path "alloc::collections::btree::node::marker::Owned"; K; V; Type_ ].
        
        Axiom Implements :
          forall (K V Type_ : Ty.t),
          M.IsTraitInstance
            "core::marker::Send"
            (Self K V Type_)
            (* Trait polymorphic types *) []
            (* Instance *) [].
      End Impl_core_marker_Send_where_core_marker_Send_K_where_core_marker_Send_V_for_alloc_collections_btree_node_NodeRef_alloc_collections_btree_node_marker_Owned_K_V_Type_.
      
      Module Impl_core_marker_Send_where_core_marker_Send_K_where_core_marker_Send_V_for_alloc_collections_btree_node_NodeRef_alloc_collections_btree_node_marker_Dying_K_V_Type_.
        Definition Self (K V Type_ : Ty.t) : Ty.t :=
          Ty.apply
            (Ty.path "alloc::collections::btree::node::NodeRef")
            [ Ty.path "alloc::collections::btree::node::marker::Dying"; K; V; Type_ ].
        
        Axiom Implements :
          forall (K V Type_ : Ty.t),
          M.IsTraitInstance
            "core::marker::Send"
            (Self K V Type_)
            (* Trait polymorphic types *) []
            (* Instance *) [].
      End Impl_core_marker_Send_where_core_marker_Send_K_where_core_marker_Send_V_for_alloc_collections_btree_node_NodeRef_alloc_collections_btree_node_marker_Dying_K_V_Type_.
      
      Module Impl_alloc_collections_btree_node_NodeRef_alloc_collections_btree_node_marker_Owned_K_V_alloc_collections_btree_node_marker_Leaf.
        Definition Self (K V : Ty.t) : Ty.t :=
          Ty.apply
            (Ty.path "alloc::collections::btree::node::NodeRef")
            [
              Ty.path "alloc::collections::btree::node::marker::Owned";
              K;
              V;
              Ty.path "alloc::collections::btree::node::marker::Leaf"
            ].
        
        (*
            pub fn new_leaf<A: Allocator + Clone>(alloc: A) -> Self {
                Self::from_new_leaf(LeafNode::new(alloc))
            }
        *)
        Definition new_leaf (K V : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self K V in
          match τ, α with
          | [ A ], [ alloc ] =>
            ltac:(M.monadic
              (let alloc := M.alloc (| alloc |) in
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "alloc::collections::btree::node::NodeRef")
                    [
                      Ty.path "alloc::collections::btree::node::marker::Owned";
                      K;
                      V;
                      Ty.path "alloc::collections::btree::node::marker::Leaf"
                    ],
                  "from_new_leaf",
                  [ A ]
                |),
                [
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply (Ty.path "alloc::collections::btree::node::LeafNode") [ K; V ],
                      "new",
                      [ A ]
                    |),
                    [ M.read (| alloc |) ]
                  |)
                ]
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom AssociatedFunction_new_leaf :
          forall (K V : Ty.t),
          M.IsAssociatedFunction (Self K V) "new_leaf" (new_leaf K V).
        
        (*
            fn from_new_leaf<A: Allocator + Clone>(leaf: Box<LeafNode<K, V>, A>) -> Self {
                NodeRef { height: 0, node: NonNull::from(Box::leak(leaf)), _marker: PhantomData }
            }
        *)
        Definition from_new_leaf (K V : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self K V in
          match τ, α with
          | [ A ], [ leaf ] =>
            ltac:(M.monadic
              (let leaf := M.alloc (| leaf |) in
              Value.StructRecord
                "alloc::collections::btree::node::NodeRef"
                [
                  ("height", Value.Integer 0);
                  ("node",
                    M.call_closure (|
                      M.get_trait_method (|
                        "core::convert::From",
                        Ty.apply
                          (Ty.path "core::ptr::non_null::NonNull")
                          [ Ty.apply (Ty.path "alloc::collections::btree::node::LeafNode") [ K; V ]
                          ],
                        [
                          Ty.apply
                            (Ty.path "&mut")
                            [
                              Ty.apply
                                (Ty.path "alloc::collections::btree::node::LeafNode")
                                [ K; V ]
                            ]
                        ],
                        "from",
                        []
                      |),
                      [
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.apply
                              (Ty.path "alloc::boxed::Box")
                              [
                                Ty.apply
                                  (Ty.path "alloc::collections::btree::node::LeafNode")
                                  [ K; V ];
                                A
                              ],
                            "leak",
                            []
                          |),
                          [ M.read (| leaf |) ]
                        |)
                      ]
                    |));
                  ("_marker", Value.StructTuple "core::marker::PhantomData" [])
                ]))
          | _, _ => M.impossible
          end.
        
        Axiom AssociatedFunction_from_new_leaf :
          forall (K V : Ty.t),
          M.IsAssociatedFunction (Self K V) "from_new_leaf" (from_new_leaf K V).
      End Impl_alloc_collections_btree_node_NodeRef_alloc_collections_btree_node_marker_Owned_K_V_alloc_collections_btree_node_marker_Leaf.
      
      Module Impl_alloc_collections_btree_node_NodeRef_alloc_collections_btree_node_marker_Owned_K_V_alloc_collections_btree_node_marker_Internal.
        Definition Self (K V : Ty.t) : Ty.t :=
          Ty.apply
            (Ty.path "alloc::collections::btree::node::NodeRef")
            [
              Ty.path "alloc::collections::btree::node::marker::Owned";
              K;
              V;
              Ty.path "alloc::collections::btree::node::marker::Internal"
            ].
        
        (*
            fn new_internal<A: Allocator + Clone>(child: Root<K, V>, alloc: A) -> Self {
                let mut new_node = unsafe { InternalNode::new(alloc) };
                new_node.edges[0].write(child.node);
                unsafe { NodeRef::from_new_internal(new_node, child.height + 1) }
            }
        *)
        Definition new_internal (K V : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self K V in
          match τ, α with
          | [ A ], [ child; alloc ] =>
            ltac:(M.monadic
              (let child := M.alloc (| child |) in
              let alloc := M.alloc (| alloc |) in
              M.read (|
                let~ new_node :=
                  M.alloc (|
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "alloc::collections::btree::node::InternalNode") [ K; V ],
                        "new",
                        [ A ]
                      |),
                      [ M.read (| alloc |) ]
                    |)
                  |) in
                let~ _ :=
                  M.alloc (|
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                          [
                            Ty.apply
                              (Ty.path "core::ptr::non_null::NonNull")
                              [
                                Ty.apply
                                  (Ty.path "alloc::collections::btree::node::LeafNode")
                                  [ K; V ]
                              ]
                          ],
                        "write",
                        []
                      |),
                      [
                        M.SubPointer.get_array_field (|
                          M.SubPointer.get_struct_record_field (|
                            M.read (| new_node |),
                            "alloc::collections::btree::node::InternalNode",
                            "edges"
                          |),
                          M.alloc (| Value.Integer 0 |)
                        |);
                        M.read (|
                          M.SubPointer.get_struct_record_field (|
                            child,
                            "alloc::collections::btree::node::NodeRef",
                            "node"
                          |)
                        |)
                      ]
                    |)
                  |) in
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "alloc::collections::btree::node::NodeRef")
                        [
                          Ty.path "alloc::collections::btree::node::marker::Owned";
                          K;
                          V;
                          Ty.path "alloc::collections::btree::node::marker::Internal"
                        ],
                      "from_new_internal",
                      [ A ]
                    |),
                    [
                      M.read (| new_node |);
                      BinOp.Wrap.add
                        Integer.Usize
                        (M.read (|
                          M.SubPointer.get_struct_record_field (|
                            child,
                            "alloc::collections::btree::node::NodeRef",
                            "height"
                          |)
                        |))
                        (Value.Integer 1)
                    ]
                  |)
                |)
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom AssociatedFunction_new_internal :
          forall (K V : Ty.t),
          M.IsAssociatedFunction (Self K V) "new_internal" (new_internal K V).
        
        (*
            unsafe fn from_new_internal<A: Allocator + Clone>(
                internal: Box<InternalNode<K, V>, A>,
                height: usize,
            ) -> Self {
                debug_assert!(height > 0);
                let node = NonNull::from(Box::leak(internal)).cast();
                let mut this = NodeRef { height, node, _marker: PhantomData };
                this.borrow_mut().correct_all_childrens_parent_links();
                this
            }
        *)
        Definition from_new_internal (K V : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self K V in
          match τ, α with
          | [ A ], [ internal; height ] =>
            ltac:(M.monadic
              (let internal := M.alloc (| internal |) in
              let height := M.alloc (| height |) in
              M.read (|
                let~ _ :=
                  M.match_operator (|
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ := M.use (M.alloc (| Value.Bool true |)) in
                          let _ :=
                            M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          let~ _ :=
                            M.match_operator (|
                              M.alloc (| Value.Tuple [] |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let γ :=
                                      M.use
                                        (M.alloc (|
                                          UnOp.Pure.not
                                            (BinOp.Pure.gt (M.read (| height |)) (Value.Integer 0))
                                        |)) in
                                    let _ :=
                                      M.is_constant_or_break_match (|
                                        M.read (| γ |),
                                        Value.Bool true
                                      |) in
                                    M.alloc (|
                                      M.never_to_any (|
                                        M.call_closure (|
                                          M.get_function (| "core::panicking::panic", [] |),
                                          [ M.read (| Value.String "assertion failed: height > 0" |)
                                          ]
                                        |)
                                      |)
                                    |)));
                                fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                              ]
                            |) in
                          M.alloc (| Value.Tuple [] |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                let~ node :=
                  M.alloc (|
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "core::ptr::non_null::NonNull")
                          [
                            Ty.apply
                              (Ty.path "alloc::collections::btree::node::InternalNode")
                              [ K; V ]
                          ],
                        "cast",
                        [ Ty.apply (Ty.path "alloc::collections::btree::node::LeafNode") [ K; V ] ]
                      |),
                      [
                        M.call_closure (|
                          M.get_trait_method (|
                            "core::convert::From",
                            Ty.apply
                              (Ty.path "core::ptr::non_null::NonNull")
                              [
                                Ty.apply
                                  (Ty.path "alloc::collections::btree::node::InternalNode")
                                  [ K; V ]
                              ],
                            [
                              Ty.apply
                                (Ty.path "&mut")
                                [
                                  Ty.apply
                                    (Ty.path "alloc::collections::btree::node::InternalNode")
                                    [ K; V ]
                                ]
                            ],
                            "from",
                            []
                          |),
                          [
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "alloc::boxed::Box")
                                  [
                                    Ty.apply
                                      (Ty.path "alloc::collections::btree::node::InternalNode")
                                      [ K; V ];
                                    A
                                  ],
                                "leak",
                                []
                              |),
                              [ M.read (| internal |) ]
                            |)
                          ]
                        |)
                      ]
                    |)
                  |) in
                let~ this :=
                  M.alloc (|
                    Value.StructRecord
                      "alloc::collections::btree::node::NodeRef"
                      [
                        ("height", M.read (| height |));
                        ("node", M.read (| node |));
                        ("_marker", Value.StructTuple "core::marker::PhantomData" [])
                      ]
                  |) in
                let~ _ :=
                  M.alloc (|
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "alloc::collections::btree::node::NodeRef")
                          [
                            Ty.path "alloc::collections::btree::node::marker::Mut";
                            K;
                            V;
                            Ty.path "alloc::collections::btree::node::marker::Internal"
                          ],
                        "correct_all_childrens_parent_links",
                        []
                      |),
                      [
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply
                                (Ty.path "alloc::collections::btree::node::NodeRef")
                                [
                                  Ty.path "alloc::collections::btree::node::marker::Owned";
                                  K;
                                  V;
                                  Ty.path "alloc::collections::btree::node::marker::Internal"
                                ],
                              "borrow_mut",
                              []
                            |),
                            [ this ]
                          |)
                        |)
                      ]
                    |)
                  |) in
                this
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom AssociatedFunction_from_new_internal :
          forall (K V : Ty.t),
          M.IsAssociatedFunction (Self K V) "from_new_internal" (from_new_internal K V).
      End Impl_alloc_collections_btree_node_NodeRef_alloc_collections_btree_node_marker_Owned_K_V_alloc_collections_btree_node_marker_Internal.
      
      Module Impl_alloc_collections_btree_node_NodeRef_BorrowType_K_V_alloc_collections_btree_node_marker_Internal.
        Definition Self (BorrowType K V : Ty.t) : Ty.t :=
          Ty.apply
            (Ty.path "alloc::collections::btree::node::NodeRef")
            [ BorrowType; K; V; Ty.path "alloc::collections::btree::node::marker::Internal" ].
        
        (*
            fn from_internal(node: NonNull<InternalNode<K, V>>, height: usize) -> Self {
                debug_assert!(height > 0);
                NodeRef { height, node: node.cast(), _marker: PhantomData }
            }
        *)
        Definition from_internal (BorrowType K V : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self BorrowType K V in
          match τ, α with
          | [], [ node; height ] =>
            ltac:(M.monadic
              (let node := M.alloc (| node |) in
              let height := M.alloc (| height |) in
              M.read (|
                let~ _ :=
                  M.match_operator (|
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ := M.use (M.alloc (| Value.Bool true |)) in
                          let _ :=
                            M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          let~ _ :=
                            M.match_operator (|
                              M.alloc (| Value.Tuple [] |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let γ :=
                                      M.use
                                        (M.alloc (|
                                          UnOp.Pure.not
                                            (BinOp.Pure.gt (M.read (| height |)) (Value.Integer 0))
                                        |)) in
                                    let _ :=
                                      M.is_constant_or_break_match (|
                                        M.read (| γ |),
                                        Value.Bool true
                                      |) in
                                    M.alloc (|
                                      M.never_to_any (|
                                        M.call_closure (|
                                          M.get_function (| "core::panicking::panic", [] |),
                                          [ M.read (| Value.String "assertion failed: height > 0" |)
                                          ]
                                        |)
                                      |)
                                    |)));
                                fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                              ]
                            |) in
                          M.alloc (| Value.Tuple [] |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                M.alloc (|
                  Value.StructRecord
                    "alloc::collections::btree::node::NodeRef"
                    [
                      ("height", M.read (| height |));
                      ("node",
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.apply
                              (Ty.path "core::ptr::non_null::NonNull")
                              [
                                Ty.apply
                                  (Ty.path "alloc::collections::btree::node::InternalNode")
                                  [ K; V ]
                              ],
                            "cast",
                            [
                              Ty.apply
                                (Ty.path "alloc::collections::btree::node::LeafNode")
                                [ K; V ]
                            ]
                          |),
                          [ M.read (| node |) ]
                        |));
                      ("_marker", Value.StructTuple "core::marker::PhantomData" [])
                    ]
                |)
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom AssociatedFunction_from_internal :
          forall (BorrowType K V : Ty.t),
          M.IsAssociatedFunction
            (Self BorrowType K V)
            "from_internal"
            (from_internal BorrowType K V).
        (*
            fn as_internal_ptr(this: &Self) -> *mut InternalNode<K, V> {
                // SAFETY: the static node type is `Internal`.
                this.node.as_ptr() as *mut InternalNode<K, V>
            }
        *)
        Definition as_internal_ptr (BorrowType K V : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self BorrowType K V in
          match τ, α with
          | [], [ this ] =>
            ltac:(M.monadic
              (let this := M.alloc (| this |) in
              M.rust_cast
                (M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "core::ptr::non_null::NonNull")
                      [ Ty.apply (Ty.path "alloc::collections::btree::node::LeafNode") [ K; V ] ],
                    "as_ptr",
                    []
                  |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_record_field (|
                        M.read (| this |),
                        "alloc::collections::btree::node::NodeRef",
                        "node"
                      |)
                    |)
                  ]
                |))))
          | _, _ => M.impossible
          end.
        
        Axiom AssociatedFunction_as_internal_ptr :
          forall (BorrowType K V : Ty.t),
          M.IsAssociatedFunction
            (Self BorrowType K V)
            "as_internal_ptr"
            (as_internal_ptr BorrowType K V).
        (*
            pub fn forget_type(self) -> NodeRef<BorrowType, K, V, marker::LeafOrInternal> {
                NodeRef { height: self.height, node: self.node, _marker: PhantomData }
            }
        *)
        Definition forget_type (BorrowType K V : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self BorrowType K V in
          match τ, α with
          | [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              Value.StructRecord
                "alloc::collections::btree::node::NodeRef"
                [
                  ("height",
                    M.read (|
                      M.SubPointer.get_struct_record_field (|
                        self,
                        "alloc::collections::btree::node::NodeRef",
                        "height"
                      |)
                    |));
                  ("node",
                    M.read (|
                      M.SubPointer.get_struct_record_field (|
                        self,
                        "alloc::collections::btree::node::NodeRef",
                        "node"
                      |)
                    |));
                  ("_marker", Value.StructTuple "core::marker::PhantomData" [])
                ]))
          | _, _ => M.impossible
          end.
        
        Axiom AssociatedFunction_forget_type :
          forall (BorrowType K V : Ty.t),
          M.IsAssociatedFunction (Self BorrowType K V) "forget_type" (forget_type BorrowType K V).
      End Impl_alloc_collections_btree_node_NodeRef_BorrowType_K_V_alloc_collections_btree_node_marker_Internal.
      
      
      Module Impl_alloc_collections_btree_node_NodeRef_alloc_collections_btree_node_marker_Mut_K_V_alloc_collections_btree_node_marker_Internal.
        Definition Self (K V : Ty.t) : Ty.t :=
          Ty.apply
            (Ty.path "alloc::collections::btree::node::NodeRef")
            [
              Ty.path "alloc::collections::btree::node::marker::Mut";
              K;
              V;
              Ty.path "alloc::collections::btree::node::marker::Internal"
            ].
        
        (*
            fn as_internal_mut(&mut self) -> &mut InternalNode<K, V> {
                let ptr = Self::as_internal_ptr(self);
                unsafe { &mut *ptr }
            }
        *)
        Definition as_internal_mut (K V : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self K V in
          match τ, α with
          | [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              M.read (|
                let~ ptr :=
                  M.alloc (|
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "alloc::collections::btree::node::NodeRef")
                          [
                            Ty.path "alloc::collections::btree::node::marker::Mut";
                            K;
                            V;
                            Ty.path "alloc::collections::btree::node::marker::Internal"
                          ],
                        "as_internal_ptr",
                        []
                      |),
                      [ M.read (| self |) ]
                    |)
                  |) in
                M.alloc (| M.read (| ptr |) |)
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom AssociatedFunction_as_internal_mut :
          forall (K V : Ty.t),
          M.IsAssociatedFunction (Self K V) "as_internal_mut" (as_internal_mut K V).
        (*
            unsafe fn edge_area_mut<I, Output: ?Sized>(&mut self, index: I) -> &mut Output
            where
                I: SliceIndex<[MaybeUninit<BoxedNode<K, V>>], Output = Output>,
            {
                // SAFETY: the caller will not be able to call further methods on self
                // until the edge slice reference is dropped, as we have unique access
                // for the lifetime of the borrow.
                unsafe { self.as_internal_mut().edges.as_mut_slice().get_unchecked_mut(index) }
            }
        *)
        Definition edge_area_mut (K V : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self K V in
          match τ, α with
          | [ _ as I; Output ], [ self; index ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let index := M.alloc (| index |) in
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "slice")
                    [
                      Ty.apply
                        (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                        [
                          Ty.apply
                            (Ty.path "core::ptr::non_null::NonNull")
                            [
                              Ty.apply
                                (Ty.path "alloc::collections::btree::node::LeafNode")
                                [ K; V ]
                            ]
                        ]
                    ],
                  "get_unchecked_mut",
                  [ I ]
                |),
                [
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "array")
                        [
                          Ty.apply
                            (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                            [
                              Ty.apply
                                (Ty.path "core::ptr::non_null::NonNull")
                                [
                                  Ty.apply
                                    (Ty.path "alloc::collections::btree::node::LeafNode")
                                    [ K; V ]
                                ]
                            ]
                        ],
                      "as_mut_slice",
                      []
                    |),
                    [
                      M.SubPointer.get_struct_record_field (|
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.apply
                              (Ty.path "alloc::collections::btree::node::NodeRef")
                              [
                                Ty.path "alloc::collections::btree::node::marker::Mut";
                                K;
                                V;
                                Ty.path "alloc::collections::btree::node::marker::Internal"
                              ],
                            "as_internal_mut",
                            []
                          |),
                          [ M.read (| self |) ]
                        |),
                        "alloc::collections::btree::node::InternalNode",
                        "edges"
                      |)
                    ]
                  |);
                  M.read (| index |)
                ]
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom AssociatedFunction_edge_area_mut :
          forall (K V : Ty.t),
          M.IsAssociatedFunction (Self K V) "edge_area_mut" (edge_area_mut K V).
        (*
            unsafe fn correct_childrens_parent_links<R: Iterator<Item = usize>>(&mut self, range: R) {
                for i in range {
                    debug_assert!(i <= self.len());
                    unsafe { Handle::new_edge(self.reborrow_mut(), i) }.correct_parent_link();
                }
            }
        *)
        Definition correct_childrens_parent_links
            (K V : Ty.t)
            (τ : list Ty.t)
            (α : list Value.t)
            : M :=
          let Self : Ty.t := Self K V in
          match τ, α with
          | [ R ], [ self; range ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let range := M.alloc (| range |) in
              M.read (|
                M.use
                  (M.match_operator (|
                    M.alloc (|
                      M.call_closure (|
                        M.get_trait_method (|
                          "core::iter::traits::collect::IntoIterator",
                          R,
                          [],
                          "into_iter",
                          []
                        |),
                        [ M.read (| range |) ]
                      |)
                    |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let iter := M.copy (| γ |) in
                          M.loop (|
                            ltac:(M.monadic
                              (let~ _ :=
                                M.match_operator (|
                                  M.alloc (|
                                    M.call_closure (|
                                      M.get_trait_method (|
                                        "core::iter::traits::iterator::Iterator",
                                        R,
                                        [],
                                        "next",
                                        []
                                      |),
                                      [ iter ]
                                    |)
                                  |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let _ :=
                                          M.is_struct_tuple (| γ, "core::option::Option::None" |) in
                                        M.alloc (|
                                          M.never_to_any (| M.read (| M.break (||) |) |)
                                        |)));
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ0_0 :=
                                          M.SubPointer.get_struct_tuple_field (|
                                            γ,
                                            "core::option::Option::Some",
                                            0
                                          |) in
                                        let i := M.copy (| γ0_0 |) in
                                        let~ _ :=
                                          M.match_operator (|
                                            M.alloc (| Value.Tuple [] |),
                                            [
                                              fun γ =>
                                                ltac:(M.monadic
                                                  (let γ := M.use (M.alloc (| Value.Bool true |)) in
                                                  let _ :=
                                                    M.is_constant_or_break_match (|
                                                      M.read (| γ |),
                                                      Value.Bool true
                                                    |) in
                                                  let~ _ :=
                                                    M.match_operator (|
                                                      M.alloc (| Value.Tuple [] |),
                                                      [
                                                        fun γ =>
                                                          ltac:(M.monadic
                                                            (let γ :=
                                                              M.use
                                                                (M.alloc (|
                                                                  UnOp.Pure.not
                                                                    (BinOp.Pure.le
                                                                      (M.read (| i |))
                                                                      (M.call_closure (|
                                                                        M.get_associated_function (|
                                                                          Ty.apply
                                                                            (Ty.path
                                                                              "alloc::collections::btree::node::NodeRef")
                                                                            [
                                                                              Ty.path
                                                                                "alloc::collections::btree::node::marker::Mut";
                                                                              K;
                                                                              V;
                                                                              Ty.path
                                                                                "alloc::collections::btree::node::marker::Internal"
                                                                            ],
                                                                          "len",
                                                                          []
                                                                        |),
                                                                        [ M.read (| self |) ]
                                                                      |)))
                                                                |)) in
                                                            let _ :=
                                                              M.is_constant_or_break_match (|
                                                                M.read (| γ |),
                                                                Value.Bool true
                                                              |) in
                                                            M.alloc (|
                                                              M.never_to_any (|
                                                                M.call_closure (|
                                                                  M.get_function (|
                                                                    "core::panicking::panic",
                                                                    []
                                                                  |),
                                                                  [
                                                                    M.read (|
                                                                      Value.String
                                                                        "assertion failed: i <= self.len()"
                                                                    |)
                                                                  ]
                                                                |)
                                                              |)
                                                            |)));
                                                        fun γ =>
                                                          ltac:(M.monadic
                                                            (M.alloc (| Value.Tuple [] |)))
                                                      ]
                                                    |) in
                                                  M.alloc (| Value.Tuple [] |)));
                                              fun γ =>
                                                ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                                            ]
                                          |) in
                                        let~ _ :=
                                          M.alloc (|
                                            M.call_closure (|
                                              M.get_associated_function (|
                                                Ty.apply
                                                  (Ty.path
                                                    "alloc::collections::btree::node::Handle")
                                                  [
                                                    Ty.apply
                                                      (Ty.path
                                                        "alloc::collections::btree::node::NodeRef")
                                                      [
                                                        Ty.path
                                                          "alloc::collections::btree::node::marker::Mut";
                                                        K;
                                                        V;
                                                        Ty.path
                                                          "alloc::collections::btree::node::marker::Internal"
                                                      ];
                                                    Ty.path
                                                      "alloc::collections::btree::node::marker::Edge"
                                                  ],
                                                "correct_parent_link",
                                                []
                                              |),
                                              [
                                                M.call_closure (|
                                                  M.get_associated_function (|
                                                    Ty.apply
                                                      (Ty.path
                                                        "alloc::collections::btree::node::Handle")
                                                      [
                                                        Ty.apply
                                                          (Ty.path
                                                            "alloc::collections::btree::node::NodeRef")
                                                          [
                                                            Ty.path
                                                              "alloc::collections::btree::node::marker::Mut";
                                                            K;
                                                            V;
                                                            Ty.path
                                                              "alloc::collections::btree::node::marker::Internal"
                                                          ];
                                                        Ty.path
                                                          "alloc::collections::btree::node::marker::Edge"
                                                      ],
                                                    "new_edge",
                                                    []
                                                  |),
                                                  [
                                                    M.call_closure (|
                                                      M.get_associated_function (|
                                                        Ty.apply
                                                          (Ty.path
                                                            "alloc::collections::btree::node::NodeRef")
                                                          [
                                                            Ty.path
                                                              "alloc::collections::btree::node::marker::Mut";
                                                            K;
                                                            V;
                                                            Ty.path
                                                              "alloc::collections::btree::node::marker::Internal"
                                                          ],
                                                        "reborrow_mut",
                                                        []
                                                      |),
                                                      [ M.read (| self |) ]
                                                    |);
                                                    M.read (| i |)
                                                  ]
                                                |)
                                              ]
                                            |)
                                          |) in
                                        M.alloc (| Value.Tuple [] |)))
                                  ]
                                |) in
                              M.alloc (| Value.Tuple [] |)))
                          |)))
                    ]
                  |))
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom AssociatedFunction_correct_childrens_parent_links :
          forall (K V : Ty.t),
          M.IsAssociatedFunction
            (Self K V)
            "correct_childrens_parent_links"
            (correct_childrens_parent_links K V).
        
        (*
            fn correct_all_childrens_parent_links(&mut self) {
                let len = self.len();
                unsafe { self.correct_childrens_parent_links(0..=len) };
            }
        *)
        Definition correct_all_childrens_parent_links
            (K V : Ty.t)
            (τ : list Ty.t)
            (α : list Value.t)
            : M :=
          let Self : Ty.t := Self K V in
          match τ, α with
          | [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              M.read (|
                let~ len :=
                  M.alloc (|
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "alloc::collections::btree::node::NodeRef")
                          [
                            Ty.path "alloc::collections::btree::node::marker::Mut";
                            K;
                            V;
                            Ty.path "alloc::collections::btree::node::marker::Internal"
                          ],
                        "len",
                        []
                      |),
                      [ M.read (| self |) ]
                    |)
                  |) in
                let~ _ :=
                  M.alloc (|
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "alloc::collections::btree::node::NodeRef")
                          [
                            Ty.path "alloc::collections::btree::node::marker::Mut";
                            K;
                            V;
                            Ty.path "alloc::collections::btree::node::marker::Internal"
                          ],
                        "correct_childrens_parent_links",
                        [ Ty.apply (Ty.path "core::ops::range::RangeInclusive") [ Ty.path "usize" ]
                        ]
                      |),
                      [
                        M.read (| self |);
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.apply
                              (Ty.path "core::ops::range::RangeInclusive")
                              [ Ty.path "usize" ],
                            "new",
                            []
                          |),
                          [ Value.Integer 0; M.read (| len |) ]
                        |)
                      ]
                    |)
                  |) in
                M.alloc (| Value.Tuple [] |)
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom AssociatedFunction_correct_all_childrens_parent_links :
          forall (K V : Ty.t),
          M.IsAssociatedFunction
            (Self K V)
            "correct_all_childrens_parent_links"
            (correct_all_childrens_parent_links K V).
        (*
            pub fn push(&mut self, key: K, val: V, edge: Root<K, V>) {
                assert!(edge.height == self.height - 1);
        
                let len = self.len_mut();
                let idx = usize::from( *len);
                assert!(idx < CAPACITY);
                *len += 1;
                unsafe {
                    self.key_area_mut(idx).write(key);
                    self.val_area_mut(idx).write(val);
                    self.edge_area_mut(idx + 1).write(edge.node);
                    Handle::new_edge(self.reborrow_mut(), idx + 1).correct_parent_link();
                }
            }
        *)
        Definition push (K V : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self K V in
          match τ, α with
          | [], [ self; key; val; edge ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let key := M.alloc (| key |) in
              let val := M.alloc (| val |) in
              let edge := M.alloc (| edge |) in
              M.read (|
                let~ _ :=
                  M.match_operator (|
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                UnOp.Pure.not
                                  (BinOp.Pure.eq
                                    (M.read (|
                                      M.SubPointer.get_struct_record_field (|
                                        edge,
                                        "alloc::collections::btree::node::NodeRef",
                                        "height"
                                      |)
                                    |))
                                    (BinOp.Wrap.sub
                                      Integer.Usize
                                      (M.read (|
                                        M.SubPointer.get_struct_record_field (|
                                          M.read (| self |),
                                          "alloc::collections::btree::node::NodeRef",
                                          "height"
                                        |)
                                      |))
                                      (Value.Integer 1)))
                              |)) in
                          let _ :=
                            M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (|
                            M.never_to_any (|
                              M.call_closure (|
                                M.get_function (| "core::panicking::panic", [] |),
                                [
                                  M.read (|
                                    Value.String "assertion failed: edge.height == self.height - 1"
                                  |)
                                ]
                              |)
                            |)
                          |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                let~ len :=
                  M.alloc (|
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "alloc::collections::btree::node::NodeRef")
                          [
                            Ty.path "alloc::collections::btree::node::marker::Mut";
                            K;
                            V;
                            Ty.path "alloc::collections::btree::node::marker::Internal"
                          ],
                        "len_mut",
                        []
                      |),
                      [ M.read (| self |) ]
                    |)
                  |) in
                let~ idx :=
                  M.alloc (|
                    M.call_closure (|
                      M.get_trait_method (|
                        "core::convert::From",
                        Ty.path "usize",
                        [ Ty.path "u16" ],
                        "from",
                        []
                      |),
                      [ M.read (| M.read (| len |) |) ]
                    |)
                  |) in
                let~ _ :=
                  M.match_operator (|
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                UnOp.Pure.not
                                  (BinOp.Pure.lt
                                    (M.read (| idx |))
                                    (M.read (|
                                      M.get_constant (|
                                        "alloc::collections::btree::node::CAPACITY"
                                      |)
                                    |)))
                              |)) in
                          let _ :=
                            M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (|
                            M.never_to_any (|
                              M.call_closure (|
                                M.get_function (| "core::panicking::panic", [] |),
                                [ M.read (| Value.String "assertion failed: idx < CAPACITY" |) ]
                              |)
                            |)
                          |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                let~ _ :=
                  let β := M.read (| len |) in
                  M.write (| β, BinOp.Wrap.add Integer.U16 (M.read (| β |)) (Value.Integer 1) |) in
                let~ _ :=
                  M.alloc (|
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ K ],
                        "write",
                        []
                      |),
                      [
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.apply
                              (Ty.path "alloc::collections::btree::node::NodeRef")
                              [
                                Ty.path "alloc::collections::btree::node::marker::Mut";
                                K;
                                V;
                                Ty.path "alloc::collections::btree::node::marker::Internal"
                              ],
                            "key_area_mut",
                            [
                              Ty.path "usize";
                              Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ K ]
                            ]
                          |),
                          [ M.read (| self |); M.read (| idx |) ]
                        |);
                        M.read (| key |)
                      ]
                    |)
                  |) in
                let~ _ :=
                  M.alloc (|
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ V ],
                        "write",
                        []
                      |),
                      [
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.apply
                              (Ty.path "alloc::collections::btree::node::NodeRef")
                              [
                                Ty.path "alloc::collections::btree::node::marker::Mut";
                                K;
                                V;
                                Ty.path "alloc::collections::btree::node::marker::Internal"
                              ],
                            "val_area_mut",
                            [
                              Ty.path "usize";
                              Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ V ]
                            ]
                          |),
                          [ M.read (| self |); M.read (| idx |) ]
                        |);
                        M.read (| val |)
                      ]
                    |)
                  |) in
                let~ _ :=
                  M.alloc (|
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                          [
                            Ty.apply
                              (Ty.path "core::ptr::non_null::NonNull")
                              [
                                Ty.apply
                                  (Ty.path "alloc::collections::btree::node::LeafNode")
                                  [ K; V ]
                              ]
                          ],
                        "write",
                        []
                      |),
                      [
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.apply
                              (Ty.path "alloc::collections::btree::node::NodeRef")
                              [
                                Ty.path "alloc::collections::btree::node::marker::Mut";
                                K;
                                V;
                                Ty.path "alloc::collections::btree::node::marker::Internal"
                              ],
                            "edge_area_mut",
                            [
                              Ty.path "usize";
                              Ty.apply
                                (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                [
                                  Ty.apply
                                    (Ty.path "core::ptr::non_null::NonNull")
                                    [
                                      Ty.apply
                                        (Ty.path "alloc::collections::btree::node::LeafNode")
                                        [ K; V ]
                                    ]
                                ]
                            ]
                          |),
                          [
                            M.read (| self |);
                            BinOp.Wrap.add Integer.Usize (M.read (| idx |)) (Value.Integer 1)
                          ]
                        |);
                        M.read (|
                          M.SubPointer.get_struct_record_field (|
                            edge,
                            "alloc::collections::btree::node::NodeRef",
                            "node"
                          |)
                        |)
                      ]
                    |)
                  |) in
                let~ _ :=
                  M.alloc (|
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "alloc::collections::btree::node::Handle")
                          [
                            Ty.apply
                              (Ty.path "alloc::collections::btree::node::NodeRef")
                              [
                                Ty.path "alloc::collections::btree::node::marker::Mut";
                                K;
                                V;
                                Ty.path "alloc::collections::btree::node::marker::Internal"
                              ];
                            Ty.path "alloc::collections::btree::node::marker::Edge"
                          ],
                        "correct_parent_link",
                        []
                      |),
                      [
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.apply
                              (Ty.path "alloc::collections::btree::node::Handle")
                              [
                                Ty.apply
                                  (Ty.path "alloc::collections::btree::node::NodeRef")
                                  [
                                    Ty.path "alloc::collections::btree::node::marker::Mut";
                                    K;
                                    V;
                                    Ty.path "alloc::collections::btree::node::marker::Internal"
                                  ];
                                Ty.path "alloc::collections::btree::node::marker::Edge"
                              ],
                            "new_edge",
                            []
                          |),
                          [
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "alloc::collections::btree::node::NodeRef")
                                  [
                                    Ty.path "alloc::collections::btree::node::marker::Mut";
                                    K;
                                    V;
                                    Ty.path "alloc::collections::btree::node::marker::Internal"
                                  ],
                                "reborrow_mut",
                                []
                              |),
                              [ M.read (| self |) ]
                            |);
                            BinOp.Wrap.add Integer.Usize (M.read (| idx |)) (Value.Integer 1)
                          ]
                        |)
                      ]
                    |)
                  |) in
                M.alloc (| Value.Tuple [] |)
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom AssociatedFunction_push :
          forall (K V : Ty.t),
          M.IsAssociatedFunction (Self K V) "push" (push K V).
      End Impl_alloc_collections_btree_node_NodeRef_alloc_collections_btree_node_marker_Mut_K_V_alloc_collections_btree_node_marker_Internal.
      
      Module Impl_alloc_collections_btree_node_NodeRef_BorrowType_K_V_Type_.
        Definition Self (BorrowType K V Type_ : Ty.t) : Ty.t :=
          Ty.apply (Ty.path "alloc::collections::btree::node::NodeRef") [ BorrowType; K; V; Type_ ].
        
        (*
            pub fn len(&self) -> usize {
                // Crucially, we only access the `len` field here. If BorrowType is marker::ValMut,
                // there might be outstanding mutable references to values that we must not invalidate.
                unsafe { usize::from(( *Self::as_leaf_ptr(self)).len) }
            }
        *)
        Definition len (BorrowType K V Type_ : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self BorrowType K V Type_ in
          match τ, α with
          | [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              M.call_closure (|
                M.get_trait_method (|
                  "core::convert::From",
                  Ty.path "usize",
                  [ Ty.path "u16" ],
                  "from",
                  []
                |),
                [
                  M.read (|
                    M.SubPointer.get_struct_record_field (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply
                            (Ty.path "alloc::collections::btree::node::NodeRef")
                            [ BorrowType; K; V; Type_ ],
                          "as_leaf_ptr",
                          []
                        |),
                        [ M.read (| self |) ]
                      |),
                      "alloc::collections::btree::node::LeafNode",
                      "len"
                    |)
                  |)
                ]
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom AssociatedFunction_len :
          forall (BorrowType K V Type_ : Ty.t),
          M.IsAssociatedFunction (Self BorrowType K V Type_) "len" (len BorrowType K V Type_).
        
        (*
            pub fn height(&self) -> usize {
                self.height
            }
        *)
        Definition height (BorrowType K V Type_ : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self BorrowType K V Type_ in
          match τ, α with
          | [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              M.read (|
                M.SubPointer.get_struct_record_field (|
                  M.read (| self |),
                  "alloc::collections::btree::node::NodeRef",
                  "height"
                |)
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom AssociatedFunction_height :
          forall (BorrowType K V Type_ : Ty.t),
          M.IsAssociatedFunction (Self BorrowType K V Type_) "height" (height BorrowType K V Type_).
        
        (*
            pub fn reborrow(&self) -> NodeRef<marker::Immut<'_>, K, V, Type> {
                NodeRef { height: self.height, node: self.node, _marker: PhantomData }
            }
        *)
        Definition reborrow (BorrowType K V Type_ : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self BorrowType K V Type_ in
          match τ, α with
          | [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              Value.StructRecord
                "alloc::collections::btree::node::NodeRef"
                [
                  ("height",
                    M.read (|
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "alloc::collections::btree::node::NodeRef",
                        "height"
                      |)
                    |));
                  ("node",
                    M.read (|
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "alloc::collections::btree::node::NodeRef",
                        "node"
                      |)
                    |));
                  ("_marker", Value.StructTuple "core::marker::PhantomData" [])
                ]))
          | _, _ => M.impossible
          end.
        
        Axiom AssociatedFunction_reborrow :
          forall (BorrowType K V Type_ : Ty.t),
          M.IsAssociatedFunction
            (Self BorrowType K V Type_)
            "reborrow"
            (reborrow BorrowType K V Type_).
        
        (*
            fn as_leaf_ptr(this: &Self) -> *mut LeafNode<K, V> {
                // The node must be valid for at least the LeafNode portion.
                // This is not a reference in the NodeRef type because we don't know if
                // it should be unique or shared.
                this.node.as_ptr()
            }
        *)
        Definition as_leaf_ptr
            (BorrowType K V Type_ : Ty.t)
            (τ : list Ty.t)
            (α : list Value.t)
            : M :=
          let Self : Ty.t := Self BorrowType K V Type_ in
          match τ, α with
          | [], [ this ] =>
            ltac:(M.monadic
              (let this := M.alloc (| this |) in
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "core::ptr::non_null::NonNull")
                    [ Ty.apply (Ty.path "alloc::collections::btree::node::LeafNode") [ K; V ] ],
                  "as_ptr",
                  []
                |),
                [
                  M.read (|
                    M.SubPointer.get_struct_record_field (|
                      M.read (| this |),
                      "alloc::collections::btree::node::NodeRef",
                      "node"
                    |)
                  |)
                ]
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom AssociatedFunction_as_leaf_ptr :
          forall (BorrowType K V Type_ : Ty.t),
          M.IsAssociatedFunction
            (Self BorrowType K V Type_)
            "as_leaf_ptr"
            (as_leaf_ptr BorrowType K V Type_).
        (*
            pub fn ascend(
                self,
            ) -> Result<Handle<NodeRef<BorrowType, K, V, marker::Internal>, marker::Edge>, Self> {
                const {
                    assert!(BorrowType::TRAVERSAL_PERMIT);
                }
        
                // We need to use raw pointers to nodes because, if BorrowType is marker::ValMut,
                // there might be outstanding mutable references to values that we must not invalidate.
                let leaf_ptr: *const _ = Self::as_leaf_ptr(&self);
                unsafe { ( *leaf_ptr).parent }
                    .as_ref()
                    .map(|parent| Handle {
                        node: NodeRef::from_internal( *parent, self.height + 1),
                        idx: unsafe { usize::from(( *leaf_ptr).parent_idx.assume_init()) },
                        _marker: PhantomData,
                    })
                    .ok_or(self)
            }
        *)
        Definition ascend (BorrowType K V Type_ : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self BorrowType K V Type_ in
          match τ, α with
          | [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              M.read (|
                let~ _ :=
                  M.get_constant (| "alloc::collections::btree::node::ascend_discriminant" |) in
                let~ leaf_ptr :=
                  M.alloc (|
                    (* MutToConstPointer *)
                    M.pointer_coercion
                      (M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply
                            (Ty.path "alloc::collections::btree::node::NodeRef")
                            [ BorrowType; K; V; Type_ ],
                          "as_leaf_ptr",
                          []
                        |),
                        [ self ]
                      |))
                  |) in
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "core::option::Option")
                        [
                          Ty.apply
                            (Ty.path "alloc::collections::btree::node::Handle")
                            [
                              Ty.apply
                                (Ty.path "alloc::collections::btree::node::NodeRef")
                                [
                                  BorrowType;
                                  K;
                                  V;
                                  Ty.path "alloc::collections::btree::node::marker::Internal"
                                ];
                              Ty.path "alloc::collections::btree::node::marker::Edge"
                            ]
                        ],
                      "ok_or",
                      [
                        Ty.apply
                          (Ty.path "alloc::collections::btree::node::NodeRef")
                          [ BorrowType; K; V; Type_ ]
                      ]
                    |),
                    [
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply
                            (Ty.path "core::option::Option")
                            [
                              Ty.apply
                                (Ty.path "&")
                                [
                                  Ty.apply
                                    (Ty.path "core::ptr::non_null::NonNull")
                                    [
                                      Ty.apply
                                        (Ty.path "alloc::collections::btree::node::InternalNode")
                                        [ K; V ]
                                    ]
                                ]
                            ],
                          "map",
                          [
                            Ty.apply
                              (Ty.path "alloc::collections::btree::node::Handle")
                              [
                                Ty.apply
                                  (Ty.path "alloc::collections::btree::node::NodeRef")
                                  [
                                    BorrowType;
                                    K;
                                    V;
                                    Ty.path "alloc::collections::btree::node::marker::Internal"
                                  ];
                                Ty.path "alloc::collections::btree::node::marker::Edge"
                              ];
                            Ty.function
                              [
                                Ty.tuple
                                  [
                                    Ty.apply
                                      (Ty.path "&")
                                      [
                                        Ty.apply
                                          (Ty.path "core::ptr::non_null::NonNull")
                                          [
                                            Ty.apply
                                              (Ty.path
                                                "alloc::collections::btree::node::InternalNode")
                                              [ K; V ]
                                          ]
                                      ]
                                  ]
                              ]
                              (Ty.apply
                                (Ty.path "alloc::collections::btree::node::Handle")
                                [
                                  Ty.apply
                                    (Ty.path "alloc::collections::btree::node::NodeRef")
                                    [
                                      BorrowType;
                                      K;
                                      V;
                                      Ty.path "alloc::collections::btree::node::marker::Internal"
                                    ];
                                  Ty.path "alloc::collections::btree::node::marker::Edge"
                                ])
                          ]
                        |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply
                                (Ty.path "core::option::Option")
                                [
                                  Ty.apply
                                    (Ty.path "core::ptr::non_null::NonNull")
                                    [
                                      Ty.apply
                                        (Ty.path "alloc::collections::btree::node::InternalNode")
                                        [ K; V ]
                                    ]
                                ],
                              "as_ref",
                              []
                            |),
                            [
                              M.SubPointer.get_struct_record_field (|
                                M.read (| leaf_ptr |),
                                "alloc::collections::btree::node::LeafNode",
                                "parent"
                              |)
                            ]
                          |);
                          M.closure
                            (fun γ =>
                              ltac:(M.monadic
                                match γ with
                                | [ α0 ] =>
                                  M.match_operator (|
                                    M.alloc (| α0 |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let parent := M.copy (| γ |) in
                                          Value.StructRecord
                                            "alloc::collections::btree::node::Handle"
                                            [
                                              ("node",
                                                M.call_closure (|
                                                  M.get_associated_function (|
                                                    Ty.apply
                                                      (Ty.path
                                                        "alloc::collections::btree::node::NodeRef")
                                                      [
                                                        BorrowType;
                                                        K;
                                                        V;
                                                        Ty.path
                                                          "alloc::collections::btree::node::marker::Internal"
                                                      ],
                                                    "from_internal",
                                                    []
                                                  |),
                                                  [
                                                    M.read (| M.read (| parent |) |);
                                                    BinOp.Wrap.add
                                                      Integer.Usize
                                                      (M.read (|
                                                        M.SubPointer.get_struct_record_field (|
                                                          self,
                                                          "alloc::collections::btree::node::NodeRef",
                                                          "height"
                                                        |)
                                                      |))
                                                      (Value.Integer 1)
                                                  ]
                                                |));
                                              ("idx",
                                                M.call_closure (|
                                                  M.get_trait_method (|
                                                    "core::convert::From",
                                                    Ty.path "usize",
                                                    [ Ty.path "u16" ],
                                                    "from",
                                                    []
                                                  |),
                                                  [
                                                    M.call_closure (|
                                                      M.get_associated_function (|
                                                        Ty.apply
                                                          (Ty.path
                                                            "core::mem::maybe_uninit::MaybeUninit")
                                                          [ Ty.path "u16" ],
                                                        "assume_init",
                                                        []
                                                      |),
                                                      [
                                                        M.read (|
                                                          M.SubPointer.get_struct_record_field (|
                                                            M.read (| leaf_ptr |),
                                                            "alloc::collections::btree::node::LeafNode",
                                                            "parent_idx"
                                                          |)
                                                        |)
                                                      ]
                                                    |)
                                                  ]
                                                |));
                                              ("_marker",
                                                Value.StructTuple "core::marker::PhantomData" [])
                                            ]))
                                    ]
                                  |)
                                | _ => M.impossible (||)
                                end))
                        ]
                      |);
                      M.read (| self |)
                    ]
                  |)
                |)
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom AssociatedFunction_ascend :
          forall (BorrowType K V Type_ : Ty.t),
          M.IsAssociatedFunction (Self BorrowType K V Type_) "ascend" (ascend BorrowType K V Type_).
        
        (*
            pub fn first_edge(self) -> Handle<Self, marker::Edge> {
                unsafe { Handle::new_edge(self, 0) }
            }
        *)
        Definition first_edge
            (BorrowType K V Type_ : Ty.t)
            (τ : list Ty.t)
            (α : list Value.t)
            : M :=
          let Self : Ty.t := Self BorrowType K V Type_ in
          match τ, α with
          | [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "alloc::collections::btree::node::Handle")
                    [
                      Ty.apply
                        (Ty.path "alloc::collections::btree::node::NodeRef")
                        [ BorrowType; K; V; Type_ ];
                      Ty.path "alloc::collections::btree::node::marker::Edge"
                    ],
                  "new_edge",
                  []
                |),
                [ M.read (| self |); Value.Integer 0 ]
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom AssociatedFunction_first_edge :
          forall (BorrowType K V Type_ : Ty.t),
          M.IsAssociatedFunction
            (Self BorrowType K V Type_)
            "first_edge"
            (first_edge BorrowType K V Type_).
        
        (*
            pub fn last_edge(self) -> Handle<Self, marker::Edge> {
                let len = self.len();
                unsafe { Handle::new_edge(self, len) }
            }
        *)
        Definition last_edge (BorrowType K V Type_ : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self BorrowType K V Type_ in
          match τ, α with
          | [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              M.read (|
                let~ len :=
                  M.alloc (|
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "alloc::collections::btree::node::NodeRef")
                          [ BorrowType; K; V; Type_ ],
                        "len",
                        []
                      |),
                      [ self ]
                    |)
                  |) in
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "alloc::collections::btree::node::Handle")
                        [
                          Ty.apply
                            (Ty.path "alloc::collections::btree::node::NodeRef")
                            [ BorrowType; K; V; Type_ ];
                          Ty.path "alloc::collections::btree::node::marker::Edge"
                        ],
                      "new_edge",
                      []
                    |),
                    [ M.read (| self |); M.read (| len |) ]
                  |)
                |)
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom AssociatedFunction_last_edge :
          forall (BorrowType K V Type_ : Ty.t),
          M.IsAssociatedFunction
            (Self BorrowType K V Type_)
            "last_edge"
            (last_edge BorrowType K V Type_).
        
        (*
            pub fn first_kv(self) -> Handle<Self, marker::KV> {
                let len = self.len();
                assert!(len > 0);
                unsafe { Handle::new_kv(self, 0) }
            }
        *)
        Definition first_kv (BorrowType K V Type_ : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self BorrowType K V Type_ in
          match τ, α with
          | [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              M.read (|
                let~ len :=
                  M.alloc (|
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "alloc::collections::btree::node::NodeRef")
                          [ BorrowType; K; V; Type_ ],
                        "len",
                        []
                      |),
                      [ self ]
                    |)
                  |) in
                let~ _ :=
                  M.match_operator (|
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                UnOp.Pure.not (BinOp.Pure.gt (M.read (| len |)) (Value.Integer 0))
                              |)) in
                          let _ :=
                            M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (|
                            M.never_to_any (|
                              M.call_closure (|
                                M.get_function (| "core::panicking::panic", [] |),
                                [ M.read (| Value.String "assertion failed: len > 0" |) ]
                              |)
                            |)
                          |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "alloc::collections::btree::node::Handle")
                        [
                          Ty.apply
                            (Ty.path "alloc::collections::btree::node::NodeRef")
                            [ BorrowType; K; V; Type_ ];
                          Ty.path "alloc::collections::btree::node::marker::KV"
                        ],
                      "new_kv",
                      []
                    |),
                    [ M.read (| self |); Value.Integer 0 ]
                  |)
                |)
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom AssociatedFunction_first_kv :
          forall (BorrowType K V Type_ : Ty.t),
          M.IsAssociatedFunction
            (Self BorrowType K V Type_)
            "first_kv"
            (first_kv BorrowType K V Type_).
        
        (*
            pub fn last_kv(self) -> Handle<Self, marker::KV> {
                let len = self.len();
                assert!(len > 0);
                unsafe { Handle::new_kv(self, len - 1) }
            }
        *)
        Definition last_kv (BorrowType K V Type_ : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self BorrowType K V Type_ in
          match τ, α with
          | [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              M.read (|
                let~ len :=
                  M.alloc (|
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "alloc::collections::btree::node::NodeRef")
                          [ BorrowType; K; V; Type_ ],
                        "len",
                        []
                      |),
                      [ self ]
                    |)
                  |) in
                let~ _ :=
                  M.match_operator (|
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                UnOp.Pure.not (BinOp.Pure.gt (M.read (| len |)) (Value.Integer 0))
                              |)) in
                          let _ :=
                            M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (|
                            M.never_to_any (|
                              M.call_closure (|
                                M.get_function (| "core::panicking::panic", [] |),
                                [ M.read (| Value.String "assertion failed: len > 0" |) ]
                              |)
                            |)
                          |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "alloc::collections::btree::node::Handle")
                        [
                          Ty.apply
                            (Ty.path "alloc::collections::btree::node::NodeRef")
                            [ BorrowType; K; V; Type_ ];
                          Ty.path "alloc::collections::btree::node::marker::KV"
                        ],
                      "new_kv",
                      []
                    |),
                    [
                      M.read (| self |);
                      BinOp.Wrap.sub Integer.Usize (M.read (| len |)) (Value.Integer 1)
                    ]
                  |)
                |)
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom AssociatedFunction_last_kv :
          forall (BorrowType K V Type_ : Ty.t),
          M.IsAssociatedFunction
            (Self BorrowType K V Type_)
            "last_kv"
            (last_kv BorrowType K V Type_).
        (*
            fn eq(&self, other: &Self) -> bool {
                let Self { node, height, _marker } = self;
                if node.eq(&other.node) {
                    debug_assert_eq!( *height, other.height);
                    true
                } else {
                    false
                }
            }
        *)
        Definition eq (BorrowType K V Type_ : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self BorrowType K V Type_ in
          match τ, α with
          | [], [ self; other ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let other := M.alloc (| other |) in
              M.read (|
                M.match_operator (|
                  self,
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        let γ1_0 :=
                          M.SubPointer.get_struct_record_field (|
                            γ,
                            "alloc::collections::btree::node::NodeRef",
                            "node"
                          |) in
                        let γ1_1 :=
                          M.SubPointer.get_struct_record_field (|
                            γ,
                            "alloc::collections::btree::node::NodeRef",
                            "height"
                          |) in
                        let γ1_2 :=
                          M.SubPointer.get_struct_record_field (|
                            γ,
                            "alloc::collections::btree::node::NodeRef",
                            "_marker"
                          |) in
                        let node := M.alloc (| γ1_0 |) in
                        let height := M.alloc (| γ1_1 |) in
                        let _marker := M.alloc (| γ1_2 |) in
                        M.match_operator (|
                          M.alloc (| Value.Tuple [] |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ :=
                                  M.use
                                    (M.alloc (|
                                      M.call_closure (|
                                        M.get_trait_method (|
                                          "core::cmp::PartialEq",
                                          Ty.apply
                                            (Ty.path "core::ptr::non_null::NonNull")
                                            [
                                              Ty.apply
                                                (Ty.path
                                                  "alloc::collections::btree::node::LeafNode")
                                                [ K; V ]
                                            ],
                                          [
                                            Ty.apply
                                              (Ty.path "core::ptr::non_null::NonNull")
                                              [
                                                Ty.apply
                                                  (Ty.path
                                                    "alloc::collections::btree::node::LeafNode")
                                                  [ K; V ]
                                              ]
                                          ],
                                          "eq",
                                          []
                                        |),
                                        [
                                          M.read (| node |);
                                          M.SubPointer.get_struct_record_field (|
                                            M.read (| other |),
                                            "alloc::collections::btree::node::NodeRef",
                                            "node"
                                          |)
                                        ]
                                      |)
                                    |)) in
                                let _ :=
                                  M.is_constant_or_break_match (|
                                    M.read (| γ |),
                                    Value.Bool true
                                  |) in
                                let~ _ :=
                                  M.match_operator (|
                                    M.alloc (| Value.Tuple [] |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let γ := M.use (M.alloc (| Value.Bool true |)) in
                                          let _ :=
                                            M.is_constant_or_break_match (|
                                              M.read (| γ |),
                                              Value.Bool true
                                            |) in
                                          let~ _ :=
                                            M.match_operator (|
                                              M.alloc (|
                                                Value.Tuple
                                                  [
                                                    M.read (| height |);
                                                    M.SubPointer.get_struct_record_field (|
                                                      M.read (| other |),
                                                      "alloc::collections::btree::node::NodeRef",
                                                      "height"
                                                    |)
                                                  ]
                                              |),
                                              [
                                                fun γ =>
                                                  ltac:(M.monadic
                                                    (let γ0_0 :=
                                                      M.SubPointer.get_tuple_field (| γ, 0 |) in
                                                    let γ0_1 :=
                                                      M.SubPointer.get_tuple_field (| γ, 1 |) in
                                                    let left_val := M.copy (| γ0_0 |) in
                                                    let right_val := M.copy (| γ0_1 |) in
                                                    M.match_operator (|
                                                      M.alloc (| Value.Tuple [] |),
                                                      [
                                                        fun γ =>
                                                          ltac:(M.monadic
                                                            (let γ :=
                                                              M.use
                                                                (M.alloc (|
                                                                  UnOp.Pure.not
                                                                    (BinOp.Pure.eq
                                                                      (M.read (|
                                                                        M.read (| left_val |)
                                                                      |))
                                                                      (M.read (|
                                                                        M.read (| right_val |)
                                                                      |)))
                                                                |)) in
                                                            let _ :=
                                                              M.is_constant_or_break_match (|
                                                                M.read (| γ |),
                                                                Value.Bool true
                                                              |) in
                                                            M.alloc (|
                                                              M.never_to_any (|
                                                                M.read (|
                                                                  let~ kind :=
                                                                    M.alloc (|
                                                                      Value.StructTuple
                                                                        "core::panicking::AssertKind::Eq"
                                                                        []
                                                                    |) in
                                                                  M.alloc (|
                                                                    M.call_closure (|
                                                                      M.get_function (|
                                                                        "core::panicking::assert_failed",
                                                                        [
                                                                          Ty.path "usize";
                                                                          Ty.path "usize"
                                                                        ]
                                                                      |),
                                                                      [
                                                                        M.read (| kind |);
                                                                        M.read (| left_val |);
                                                                        M.read (| right_val |);
                                                                        Value.StructTuple
                                                                          "core::option::Option::None"
                                                                          []
                                                                      ]
                                                                    |)
                                                                  |)
                                                                |)
                                                              |)
                                                            |)));
                                                        fun γ =>
                                                          ltac:(M.monadic
                                                            (M.alloc (| Value.Tuple [] |)))
                                                      ]
                                                    |)))
                                              ]
                                            |) in
                                          M.alloc (| Value.Tuple [] |)));
                                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                                    ]
                                  |) in
                                M.alloc (| Value.Bool true |)));
                            fun γ => ltac:(M.monadic (M.alloc (| Value.Bool false |)))
                          ]
                        |)))
                  ]
                |)
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom AssociatedFunction_eq :
          forall (BorrowType K V Type_ : Ty.t),
          M.IsAssociatedFunction (Self BorrowType K V Type_) "eq" (eq BorrowType K V Type_).
      End Impl_alloc_collections_btree_node_NodeRef_BorrowType_K_V_Type_.
      
      
      
      Module Impl_alloc_collections_btree_node_NodeRef_alloc_collections_btree_node_marker_Immut_K_V_Type_.
        Definition Self (K V Type_ : Ty.t) : Ty.t :=
          Ty.apply
            (Ty.path "alloc::collections::btree::node::NodeRef")
            [ Ty.path "alloc::collections::btree::node::marker::Immut"; K; V; Type_ ].
        
        (*
            fn into_leaf(self) -> &'a LeafNode<K, V> {
                let ptr = Self::as_leaf_ptr(&self);
                // SAFETY: there can be no mutable references into this tree borrowed as `Immut`.
                unsafe { &*ptr }
            }
        *)
        Definition into_leaf (K V Type_ : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self K V Type_ in
          match τ, α with
          | [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              M.read (|
                let~ ptr :=
                  M.alloc (|
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "alloc::collections::btree::node::NodeRef")
                          [ Ty.path "alloc::collections::btree::node::marker::Immut"; K; V; Type_ ],
                        "as_leaf_ptr",
                        []
                      |),
                      [ self ]
                    |)
                  |) in
                M.alloc (| M.read (| ptr |) |)
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom AssociatedFunction_into_leaf :
          forall (K V Type_ : Ty.t),
          M.IsAssociatedFunction (Self K V Type_) "into_leaf" (into_leaf K V Type_).
        
        (*
            pub fn keys(&self) -> &[K] {
                let leaf = self.into_leaf();
                unsafe {
                    MaybeUninit::slice_assume_init_ref(leaf.keys.get_unchecked(..usize::from(leaf.len)))
                }
            }
        *)
        Definition keys (K V Type_ : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self K V Type_ in
          match τ, α with
          | [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              M.read (|
                let~ leaf :=
                  M.alloc (|
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "alloc::collections::btree::node::NodeRef")
                          [ Ty.path "alloc::collections::btree::node::marker::Immut"; K; V; Type_ ],
                        "into_leaf",
                        []
                      |),
                      [ M.read (| M.read (| self |) |) ]
                    |)
                  |) in
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ K ],
                      "slice_assume_init_ref",
                      []
                    |),
                    [
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply
                            (Ty.path "slice")
                            [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ K ] ],
                          "get_unchecked",
                          [ Ty.apply (Ty.path "core::ops::range::RangeTo") [ Ty.path "usize" ] ]
                        |),
                        [
                          (* Unsize *)
                          M.pointer_coercion
                            (M.SubPointer.get_struct_record_field (|
                              M.read (| leaf |),
                              "alloc::collections::btree::node::LeafNode",
                              "keys"
                            |));
                          Value.StructRecord
                            "core::ops::range::RangeTo"
                            [
                              ("end_",
                                M.call_closure (|
                                  M.get_trait_method (|
                                    "core::convert::From",
                                    Ty.path "usize",
                                    [ Ty.path "u16" ],
                                    "from",
                                    []
                                  |),
                                  [
                                    M.read (|
                                      M.SubPointer.get_struct_record_field (|
                                        M.read (| leaf |),
                                        "alloc::collections::btree::node::LeafNode",
                                        "len"
                                      |)
                                    |)
                                  ]
                                |))
                            ]
                        ]
                      |)
                    ]
                  |)
                |)
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom AssociatedFunction_keys :
          forall (K V Type_ : Ty.t),
          M.IsAssociatedFunction (Self K V Type_) "keys" (keys K V Type_).
      End Impl_alloc_collections_btree_node_NodeRef_alloc_collections_btree_node_marker_Immut_K_V_Type_.
      
      Module Impl_alloc_collections_btree_node_NodeRef_alloc_collections_btree_node_marker_Dying_K_V_alloc_collections_btree_node_marker_LeafOrInternal.
        Definition Self (K V : Ty.t) : Ty.t :=
          Ty.apply
            (Ty.path "alloc::collections::btree::node::NodeRef")
            [
              Ty.path "alloc::collections::btree::node::marker::Dying";
              K;
              V;
              Ty.path "alloc::collections::btree::node::marker::LeafOrInternal"
            ].
        
        (*
            pub unsafe fn deallocate_and_ascend<A: Allocator + Clone>(
                self,
                alloc: A,
            ) -> Option<Handle<NodeRef<marker::Dying, K, V, marker::Internal>, marker::Edge>> {
                let height = self.height;
                let node = self.node;
                let ret = self.ascend().ok();
                unsafe {
                    alloc.deallocate(
                        node.cast(),
                        if height > 0 {
                            Layout::new::<InternalNode<K, V>>()
                        } else {
                            Layout::new::<LeafNode<K, V>>()
                        },
                    );
                }
                ret
            }
        *)
        Definition deallocate_and_ascend (K V : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self K V in
          match τ, α with
          | [ A ], [ self; alloc ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let alloc := M.alloc (| alloc |) in
              M.read (|
                let~ height :=
                  M.copy (|
                    M.SubPointer.get_struct_record_field (|
                      self,
                      "alloc::collections::btree::node::NodeRef",
                      "height"
                    |)
                  |) in
                let~ node :=
                  M.copy (|
                    M.SubPointer.get_struct_record_field (|
                      self,
                      "alloc::collections::btree::node::NodeRef",
                      "node"
                    |)
                  |) in
                let~ ret :=
                  M.alloc (|
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          [
                            Ty.apply
                              (Ty.path "alloc::collections::btree::node::Handle")
                              [
                                Ty.apply
                                  (Ty.path "alloc::collections::btree::node::NodeRef")
                                  [
                                    Ty.path "alloc::collections::btree::node::marker::Dying";
                                    K;
                                    V;
                                    Ty.path "alloc::collections::btree::node::marker::Internal"
                                  ];
                                Ty.path "alloc::collections::btree::node::marker::Edge"
                              ];
                            Ty.apply
                              (Ty.path "alloc::collections::btree::node::NodeRef")
                              [
                                Ty.path "alloc::collections::btree::node::marker::Dying";
                                K;
                                V;
                                Ty.path "alloc::collections::btree::node::marker::LeafOrInternal"
                              ]
                          ],
                        "ok",
                        []
                      |),
                      [
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.apply
                              (Ty.path "alloc::collections::btree::node::NodeRef")
                              [
                                Ty.path "alloc::collections::btree::node::marker::Dying";
                                K;
                                V;
                                Ty.path "alloc::collections::btree::node::marker::LeafOrInternal"
                              ],
                            "ascend",
                            []
                          |),
                          [ M.read (| self |) ]
                        |)
                      ]
                    |)
                  |) in
                let~ _ :=
                  let~ _ :=
                    M.alloc (|
                      M.call_closure (|
                        M.get_trait_method (| "core::alloc::Allocator", A, [], "deallocate", [] |),
                        [
                          alloc;
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply
                                (Ty.path "core::ptr::non_null::NonNull")
                                [
                                  Ty.apply
                                    (Ty.path "alloc::collections::btree::node::LeafNode")
                                    [ K; V ]
                                ],
                              "cast",
                              [ Ty.path "u8" ]
                            |),
                            [ M.read (| node |) ]
                          |);
                          M.read (|
                            M.match_operator (|
                              M.alloc (| Value.Tuple [] |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let γ :=
                                      M.use
                                        (M.alloc (|
                                          BinOp.Pure.gt (M.read (| height |)) (Value.Integer 0)
                                        |)) in
                                    let _ :=
                                      M.is_constant_or_break_match (|
                                        M.read (| γ |),
                                        Value.Bool true
                                      |) in
                                    M.alloc (|
                                      M.call_closure (|
                                        M.get_associated_function (|
                                          Ty.path "core::alloc::layout::Layout",
                                          "new",
                                          [
                                            Ty.apply
                                              (Ty.path
                                                "alloc::collections::btree::node::InternalNode")
                                              [ K; V ]
                                          ]
                                        |),
                                        []
                                      |)
                                    |)));
                                fun γ =>
                                  ltac:(M.monadic
                                    (M.alloc (|
                                      M.call_closure (|
                                        M.get_associated_function (|
                                          Ty.path "core::alloc::layout::Layout",
                                          "new",
                                          [
                                            Ty.apply
                                              (Ty.path "alloc::collections::btree::node::LeafNode")
                                              [ K; V ]
                                          ]
                                        |),
                                        []
                                      |)
                                    |)))
                              ]
                            |)
                          |)
                        ]
                      |)
                    |) in
                  M.alloc (| Value.Tuple [] |) in
                ret
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom AssociatedFunction_deallocate_and_ascend :
          forall (K V : Ty.t),
          M.IsAssociatedFunction (Self K V) "deallocate_and_ascend" (deallocate_and_ascend K V).
      End Impl_alloc_collections_btree_node_NodeRef_alloc_collections_btree_node_marker_Dying_K_V_alloc_collections_btree_node_marker_LeafOrInternal.
      
      Module Impl_alloc_collections_btree_node_NodeRef_alloc_collections_btree_node_marker_Mut_K_V_Type_.
        Definition Self (K V Type_ : Ty.t) : Ty.t :=
          Ty.apply
            (Ty.path "alloc::collections::btree::node::NodeRef")
            [ Ty.path "alloc::collections::btree::node::marker::Mut"; K; V; Type_ ].
        
        (*
            unsafe fn reborrow_mut(&mut self) -> NodeRef<marker::Mut<'_>, K, V, Type> {
                NodeRef { height: self.height, node: self.node, _marker: PhantomData }
            }
        *)
        Definition reborrow_mut (K V Type_ : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self K V Type_ in
          match τ, α with
          | [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              Value.StructRecord
                "alloc::collections::btree::node::NodeRef"
                [
                  ("height",
                    M.read (|
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "alloc::collections::btree::node::NodeRef",
                        "height"
                      |)
                    |));
                  ("node",
                    M.read (|
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "alloc::collections::btree::node::NodeRef",
                        "node"
                      |)
                    |));
                  ("_marker", Value.StructTuple "core::marker::PhantomData" [])
                ]))
          | _, _ => M.impossible
          end.
        
        Axiom AssociatedFunction_reborrow_mut :
          forall (K V Type_ : Ty.t),
          M.IsAssociatedFunction (Self K V Type_) "reborrow_mut" (reborrow_mut K V Type_).
        
        (*
            fn as_leaf_mut(&mut self) -> &mut LeafNode<K, V> {
                let ptr = Self::as_leaf_ptr(self);
                // SAFETY: we have exclusive access to the entire node.
                unsafe { &mut *ptr }
            }
        *)
        Definition as_leaf_mut (K V Type_ : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self K V Type_ in
          match τ, α with
          | [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              M.read (|
                let~ ptr :=
                  M.alloc (|
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "alloc::collections::btree::node::NodeRef")
                          [ Ty.path "alloc::collections::btree::node::marker::Mut"; K; V; Type_ ],
                        "as_leaf_ptr",
                        []
                      |),
                      [ M.read (| self |) ]
                    |)
                  |) in
                M.alloc (| M.read (| ptr |) |)
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom AssociatedFunction_as_leaf_mut :
          forall (K V Type_ : Ty.t),
          M.IsAssociatedFunction (Self K V Type_) "as_leaf_mut" (as_leaf_mut K V Type_).
        
        (*
            fn into_leaf_mut(mut self) -> &'a mut LeafNode<K, V> {
                let ptr = Self::as_leaf_ptr(&mut self);
                // SAFETY: we have exclusive access to the entire node.
                unsafe { &mut *ptr }
            }
        *)
        Definition into_leaf_mut (K V Type_ : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self K V Type_ in
          match τ, α with
          | [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              M.read (|
                let~ ptr :=
                  M.alloc (|
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "alloc::collections::btree::node::NodeRef")
                          [ Ty.path "alloc::collections::btree::node::marker::Mut"; K; V; Type_ ],
                        "as_leaf_ptr",
                        []
                      |),
                      [ self ]
                    |)
                  |) in
                M.alloc (| M.read (| ptr |) |)
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom AssociatedFunction_into_leaf_mut :
          forall (K V Type_ : Ty.t),
          M.IsAssociatedFunction (Self K V Type_) "into_leaf_mut" (into_leaf_mut K V Type_).
        
        (*
            pub fn dormant(&self) -> NodeRef<marker::DormantMut, K, V, Type> {
                NodeRef { height: self.height, node: self.node, _marker: PhantomData }
            }
        *)
        Definition dormant (K V Type_ : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self K V Type_ in
          match τ, α with
          | [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              Value.StructRecord
                "alloc::collections::btree::node::NodeRef"
                [
                  ("height",
                    M.read (|
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "alloc::collections::btree::node::NodeRef",
                        "height"
                      |)
                    |));
                  ("node",
                    M.read (|
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "alloc::collections::btree::node::NodeRef",
                        "node"
                      |)
                    |));
                  ("_marker", Value.StructTuple "core::marker::PhantomData" [])
                ]))
          | _, _ => M.impossible
          end.
        
        Axiom AssociatedFunction_dormant :
          forall (K V Type_ : Ty.t),
          M.IsAssociatedFunction (Self K V Type_) "dormant" (dormant K V Type_).
        (*
            unsafe fn key_area_mut<I, Output: ?Sized>(&mut self, index: I) -> &mut Output
            where
                I: SliceIndex<[MaybeUninit<K>], Output = Output>,
            {
                // SAFETY: the caller will not be able to call further methods on self
                // until the key slice reference is dropped, as we have unique access
                // for the lifetime of the borrow.
                unsafe { self.as_leaf_mut().keys.as_mut_slice().get_unchecked_mut(index) }
            }
        *)
        Definition key_area_mut (K V Type_ : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self K V Type_ in
          match τ, α with
          | [ _ as I; Output ], [ self; index ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let index := M.alloc (| index |) in
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "slice")
                    [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ K ] ],
                  "get_unchecked_mut",
                  [ I ]
                |),
                [
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "array")
                        [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ K ] ],
                      "as_mut_slice",
                      []
                    |),
                    [
                      M.SubPointer.get_struct_record_field (|
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.apply
                              (Ty.path "alloc::collections::btree::node::NodeRef")
                              [ Ty.path "alloc::collections::btree::node::marker::Mut"; K; V; Type_
                              ],
                            "as_leaf_mut",
                            []
                          |),
                          [ M.read (| self |) ]
                        |),
                        "alloc::collections::btree::node::LeafNode",
                        "keys"
                      |)
                    ]
                  |);
                  M.read (| index |)
                ]
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom AssociatedFunction_key_area_mut :
          forall (K V Type_ : Ty.t),
          M.IsAssociatedFunction (Self K V Type_) "key_area_mut" (key_area_mut K V Type_).
        
        (*
            unsafe fn val_area_mut<I, Output: ?Sized>(&mut self, index: I) -> &mut Output
            where
                I: SliceIndex<[MaybeUninit<V>], Output = Output>,
            {
                // SAFETY: the caller will not be able to call further methods on self
                // until the value slice reference is dropped, as we have unique access
                // for the lifetime of the borrow.
                unsafe { self.as_leaf_mut().vals.as_mut_slice().get_unchecked_mut(index) }
            }
        *)
        Definition val_area_mut (K V Type_ : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self K V Type_ in
          match τ, α with
          | [ _ as I; Output ], [ self; index ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let index := M.alloc (| index |) in
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "slice")
                    [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ V ] ],
                  "get_unchecked_mut",
                  [ I ]
                |),
                [
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "array")
                        [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ V ] ],
                      "as_mut_slice",
                      []
                    |),
                    [
                      M.SubPointer.get_struct_record_field (|
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.apply
                              (Ty.path "alloc::collections::btree::node::NodeRef")
                              [ Ty.path "alloc::collections::btree::node::marker::Mut"; K; V; Type_
                              ],
                            "as_leaf_mut",
                            []
                          |),
                          [ M.read (| self |) ]
                        |),
                        "alloc::collections::btree::node::LeafNode",
                        "vals"
                      |)
                    ]
                  |);
                  M.read (| index |)
                ]
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom AssociatedFunction_val_area_mut :
          forall (K V Type_ : Ty.t),
          M.IsAssociatedFunction (Self K V Type_) "val_area_mut" (val_area_mut K V Type_).
        (*
            pub fn len_mut(&mut self) -> &mut u16 {
                &mut self.as_leaf_mut().len
            }
        *)
        Definition len_mut (K V Type_ : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self K V Type_ in
          match τ, α with
          | [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              M.SubPointer.get_struct_record_field (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "alloc::collections::btree::node::NodeRef")
                      [ Ty.path "alloc::collections::btree::node::marker::Mut"; K; V; Type_ ],
                    "as_leaf_mut",
                    []
                  |),
                  [ M.read (| self |) ]
                |),
                "alloc::collections::btree::node::LeafNode",
                "len"
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom AssociatedFunction_len_mut :
          forall (K V Type_ : Ty.t),
          M.IsAssociatedFunction (Self K V Type_) "len_mut" (len_mut K V Type_).
      End Impl_alloc_collections_btree_node_NodeRef_alloc_collections_btree_node_marker_Mut_K_V_Type_.
      
      Module Impl_alloc_collections_btree_node_NodeRef_alloc_collections_btree_node_marker_DormantMut_K_V_Type_.
        Definition Self (K V Type_ : Ty.t) : Ty.t :=
          Ty.apply
            (Ty.path "alloc::collections::btree::node::NodeRef")
            [ Ty.path "alloc::collections::btree::node::marker::DormantMut"; K; V; Type_ ].
        
        (*
            pub unsafe fn awaken<'a>(self) -> NodeRef<marker::Mut<'a>, K, V, Type> {
                NodeRef { height: self.height, node: self.node, _marker: PhantomData }
            }
        *)
        Definition awaken (K V Type_ : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self K V Type_ in
          match τ, α with
          | [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              Value.StructRecord
                "alloc::collections::btree::node::NodeRef"
                [
                  ("height",
                    M.read (|
                      M.SubPointer.get_struct_record_field (|
                        self,
                        "alloc::collections::btree::node::NodeRef",
                        "height"
                      |)
                    |));
                  ("node",
                    M.read (|
                      M.SubPointer.get_struct_record_field (|
                        self,
                        "alloc::collections::btree::node::NodeRef",
                        "node"
                      |)
                    |));
                  ("_marker", Value.StructTuple "core::marker::PhantomData" [])
                ]))
          | _, _ => M.impossible
          end.
        
        Axiom AssociatedFunction_awaken :
          forall (K V Type_ : Ty.t),
          M.IsAssociatedFunction (Self K V Type_) "awaken" (awaken K V Type_).
      End Impl_alloc_collections_btree_node_NodeRef_alloc_collections_btree_node_marker_DormantMut_K_V_Type_.
      
      Module Impl_alloc_collections_btree_node_NodeRef_alloc_collections_btree_node_marker_Dying_K_V_Type_.
        Definition Self (K V Type_ : Ty.t) : Ty.t :=
          Ty.apply
            (Ty.path "alloc::collections::btree::node::NodeRef")
            [ Ty.path "alloc::collections::btree::node::marker::Dying"; K; V; Type_ ].
        
        (*
            fn as_leaf_dying(&mut self) -> &mut LeafNode<K, V> {
                let ptr = Self::as_leaf_ptr(self);
                // SAFETY: we have exclusive access to the entire node.
                unsafe { &mut *ptr }
            }
        *)
        Definition as_leaf_dying (K V Type_ : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self K V Type_ in
          match τ, α with
          | [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              M.read (|
                let~ ptr :=
                  M.alloc (|
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "alloc::collections::btree::node::NodeRef")
                          [ Ty.path "alloc::collections::btree::node::marker::Dying"; K; V; Type_ ],
                        "as_leaf_ptr",
                        []
                      |),
                      [ M.read (| self |) ]
                    |)
                  |) in
                M.alloc (| M.read (| ptr |) |)
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom AssociatedFunction_as_leaf_dying :
          forall (K V Type_ : Ty.t),
          M.IsAssociatedFunction (Self K V Type_) "as_leaf_dying" (as_leaf_dying K V Type_).
      End Impl_alloc_collections_btree_node_NodeRef_alloc_collections_btree_node_marker_Dying_K_V_Type_.
      
      
      
      Module Impl_alloc_collections_btree_node_NodeRef_alloc_collections_btree_node_marker_ValMut_K_V_Type_.
        Definition Self (K V Type_ : Ty.t) : Ty.t :=
          Ty.apply
            (Ty.path "alloc::collections::btree::node::NodeRef")
            [ Ty.path "alloc::collections::btree::node::marker::ValMut"; K; V; Type_ ].
        
        (*
            unsafe fn into_key_val_mut_at(mut self, idx: usize) -> (&'a K, &'a mut V) {
                // We only create a reference to the one element we are interested in,
                // to avoid aliasing with outstanding references to other elements,
                // in particular, those returned to the caller in earlier iterations.
                let leaf = Self::as_leaf_ptr(&mut self);
                let keys = unsafe { ptr::addr_of!(( *leaf).keys) };
                let vals = unsafe { ptr::addr_of_mut!(( *leaf).vals) };
                // We must coerce to unsized array pointers because of Rust issue #74679.
                let keys: *const [_] = keys;
                let vals: *mut [_] = vals;
                let key = unsafe { (&*keys.get_unchecked(idx)).assume_init_ref() };
                let val = unsafe { (&mut *vals.get_unchecked_mut(idx)).assume_init_mut() };
                (key, val)
            }
        *)
        Definition into_key_val_mut_at (K V Type_ : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self K V Type_ in
          match τ, α with
          | [], [ self; idx ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let idx := M.alloc (| idx |) in
              M.read (|
                let~ leaf :=
                  M.alloc (|
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "alloc::collections::btree::node::NodeRef")
                          [ Ty.path "alloc::collections::btree::node::marker::ValMut"; K; V; Type_
                          ],
                        "as_leaf_ptr",
                        []
                      |),
                      [ self ]
                    |)
                  |) in
                let~ keys :=
                  M.alloc (|
                    M.SubPointer.get_struct_record_field (|
                      M.read (| leaf |),
                      "alloc::collections::btree::node::LeafNode",
                      "keys"
                    |)
                  |) in
                let~ vals :=
                  M.alloc (|
                    M.SubPointer.get_struct_record_field (|
                      M.read (| leaf |),
                      "alloc::collections::btree::node::LeafNode",
                      "vals"
                    |)
                  |) in
                let~ keys := M.alloc (| (* Unsize *) M.pointer_coercion (M.read (| keys |)) |) in
                let~ vals := M.alloc (| (* Unsize *) M.pointer_coercion (M.read (| vals |)) |) in
                let~ key :=
                  M.alloc (|
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ K ],
                        "assume_init_ref",
                        []
                      |),
                      [
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.apply
                              (Ty.path "*const")
                              [
                                Ty.apply
                                  (Ty.path "slice")
                                  [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ K ]
                                  ]
                              ],
                            "get_unchecked",
                            [ Ty.path "usize" ]
                          |),
                          [ M.read (| keys |); M.read (| idx |) ]
                        |)
                      ]
                    |)
                  |) in
                let~ val :=
                  M.alloc (|
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ V ],
                        "assume_init_mut",
                        []
                      |),
                      [
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.apply
                              (Ty.path "*mut")
                              [
                                Ty.apply
                                  (Ty.path "slice")
                                  [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ V ]
                                  ]
                              ],
                            "get_unchecked_mut",
                            [ Ty.path "usize" ]
                          |),
                          [ M.read (| vals |); M.read (| idx |) ]
                        |)
                      ]
                    |)
                  |) in
                M.alloc (| Value.Tuple [ M.read (| key |); M.read (| val |) ] |)
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom AssociatedFunction_into_key_val_mut_at :
          forall (K V Type_ : Ty.t),
          M.IsAssociatedFunction
            (Self K V Type_)
            "into_key_val_mut_at"
            (into_key_val_mut_at K V Type_).
      End Impl_alloc_collections_btree_node_NodeRef_alloc_collections_btree_node_marker_ValMut_K_V_Type_.
      
      
      
      Module Impl_alloc_collections_btree_node_NodeRef_alloc_collections_btree_node_marker_Mut_K_V_alloc_collections_btree_node_marker_LeafOrInternal.
        Definition Self (K V : Ty.t) : Ty.t :=
          Ty.apply
            (Ty.path "alloc::collections::btree::node::NodeRef")
            [
              Ty.path "alloc::collections::btree::node::marker::Mut";
              K;
              V;
              Ty.path "alloc::collections::btree::node::marker::LeafOrInternal"
            ].
        
        (*
            fn set_parent_link(&mut self, parent: NonNull<InternalNode<K, V>>, parent_idx: usize) {
                let leaf = Self::as_leaf_ptr(self);
                unsafe { ( *leaf).parent = Some(parent) };
                unsafe { ( *leaf).parent_idx.write(parent_idx as u16) };
            }
        *)
        Definition set_parent_link (K V : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self K V in
          match τ, α with
          | [], [ self; parent; parent_idx ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let parent := M.alloc (| parent |) in
              let parent_idx := M.alloc (| parent_idx |) in
              M.read (|
                let~ leaf :=
                  M.alloc (|
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "alloc::collections::btree::node::NodeRef")
                          [
                            Ty.path "alloc::collections::btree::node::marker::Mut";
                            K;
                            V;
                            Ty.path "alloc::collections::btree::node::marker::LeafOrInternal"
                          ],
                        "as_leaf_ptr",
                        []
                      |),
                      [ M.read (| self |) ]
                    |)
                  |) in
                let~ _ :=
                  M.write (|
                    M.SubPointer.get_struct_record_field (|
                      M.read (| leaf |),
                      "alloc::collections::btree::node::LeafNode",
                      "parent"
                    |),
                    Value.StructTuple "core::option::Option::Some" [ M.read (| parent |) ]
                  |) in
                let~ _ :=
                  M.alloc (|
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ Ty.path "u16" ],
                        "write",
                        []
                      |),
                      [
                        M.SubPointer.get_struct_record_field (|
                          M.read (| leaf |),
                          "alloc::collections::btree::node::LeafNode",
                          "parent_idx"
                        |);
                        M.rust_cast (M.read (| parent_idx |))
                      ]
                    |)
                  |) in
                M.alloc (| Value.Tuple [] |)
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom AssociatedFunction_set_parent_link :
          forall (K V : Ty.t),
          M.IsAssociatedFunction (Self K V) "set_parent_link" (set_parent_link K V).
        (*
            unsafe fn cast_to_leaf_unchecked(self) -> NodeRef<marker::Mut<'a>, K, V, marker::Leaf> {
                debug_assert!(self.height == 0);
                NodeRef { height: self.height, node: self.node, _marker: PhantomData }
            }
        *)
        Definition cast_to_leaf_unchecked (K V : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self K V in
          match τ, α with
          | [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              M.read (|
                let~ _ :=
                  M.match_operator (|
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ := M.use (M.alloc (| Value.Bool true |)) in
                          let _ :=
                            M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          let~ _ :=
                            M.match_operator (|
                              M.alloc (| Value.Tuple [] |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let γ :=
                                      M.use
                                        (M.alloc (|
                                          UnOp.Pure.not
                                            (BinOp.Pure.eq
                                              (M.read (|
                                                M.SubPointer.get_struct_record_field (|
                                                  self,
                                                  "alloc::collections::btree::node::NodeRef",
                                                  "height"
                                                |)
                                              |))
                                              (Value.Integer 0))
                                        |)) in
                                    let _ :=
                                      M.is_constant_or_break_match (|
                                        M.read (| γ |),
                                        Value.Bool true
                                      |) in
                                    M.alloc (|
                                      M.never_to_any (|
                                        M.call_closure (|
                                          M.get_function (| "core::panicking::panic", [] |),
                                          [
                                            M.read (|
                                              Value.String "assertion failed: self.height == 0"
                                            |)
                                          ]
                                        |)
                                      |)
                                    |)));
                                fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                              ]
                            |) in
                          M.alloc (| Value.Tuple [] |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                M.alloc (|
                  Value.StructRecord
                    "alloc::collections::btree::node::NodeRef"
                    [
                      ("height",
                        M.read (|
                          M.SubPointer.get_struct_record_field (|
                            self,
                            "alloc::collections::btree::node::NodeRef",
                            "height"
                          |)
                        |));
                      ("node",
                        M.read (|
                          M.SubPointer.get_struct_record_field (|
                            self,
                            "alloc::collections::btree::node::NodeRef",
                            "node"
                          |)
                        |));
                      ("_marker", Value.StructTuple "core::marker::PhantomData" [])
                    ]
                |)
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom AssociatedFunction_cast_to_leaf_unchecked :
          forall (K V : Ty.t),
          M.IsAssociatedFunction (Self K V) "cast_to_leaf_unchecked" (cast_to_leaf_unchecked K V).
        
        (*
            unsafe fn cast_to_internal_unchecked(self) -> NodeRef<marker::Mut<'a>, K, V, marker::Internal> {
                debug_assert!(self.height > 0);
                NodeRef { height: self.height, node: self.node, _marker: PhantomData }
            }
        *)
        Definition cast_to_internal_unchecked (K V : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self K V in
          match τ, α with
          | [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              M.read (|
                let~ _ :=
                  M.match_operator (|
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ := M.use (M.alloc (| Value.Bool true |)) in
                          let _ :=
                            M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          let~ _ :=
                            M.match_operator (|
                              M.alloc (| Value.Tuple [] |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let γ :=
                                      M.use
                                        (M.alloc (|
                                          UnOp.Pure.not
                                            (BinOp.Pure.gt
                                              (M.read (|
                                                M.SubPointer.get_struct_record_field (|
                                                  self,
                                                  "alloc::collections::btree::node::NodeRef",
                                                  "height"
                                                |)
                                              |))
                                              (Value.Integer 0))
                                        |)) in
                                    let _ :=
                                      M.is_constant_or_break_match (|
                                        M.read (| γ |),
                                        Value.Bool true
                                      |) in
                                    M.alloc (|
                                      M.never_to_any (|
                                        M.call_closure (|
                                          M.get_function (| "core::panicking::panic", [] |),
                                          [
                                            M.read (|
                                              Value.String "assertion failed: self.height > 0"
                                            |)
                                          ]
                                        |)
                                      |)
                                    |)));
                                fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                              ]
                            |) in
                          M.alloc (| Value.Tuple [] |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                M.alloc (|
                  Value.StructRecord
                    "alloc::collections::btree::node::NodeRef"
                    [
                      ("height",
                        M.read (|
                          M.SubPointer.get_struct_record_field (|
                            self,
                            "alloc::collections::btree::node::NodeRef",
                            "height"
                          |)
                        |));
                      ("node",
                        M.read (|
                          M.SubPointer.get_struct_record_field (|
                            self,
                            "alloc::collections::btree::node::NodeRef",
                            "node"
                          |)
                        |));
                      ("_marker", Value.StructTuple "core::marker::PhantomData" [])
                    ]
                |)
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom AssociatedFunction_cast_to_internal_unchecked :
          forall (K V : Ty.t),
          M.IsAssociatedFunction
            (Self K V)
            "cast_to_internal_unchecked"
            (cast_to_internal_unchecked K V).
        (*
            pub fn choose_parent_kv(self) -> Result<LeftOrRight<BalancingContext<'a, K, V>>, Self> {
                match unsafe { ptr::read(&self) }.ascend() {
                    Ok(parent_edge) => match parent_edge.left_kv() {
                        Ok(left_parent_kv) => Ok(LeftOrRight::Left(BalancingContext {
                            parent: unsafe { ptr::read(&left_parent_kv) },
                            left_child: left_parent_kv.left_edge().descend(),
                            right_child: self,
                        })),
                        Err(parent_edge) => match parent_edge.right_kv() {
                            Ok(right_parent_kv) => Ok(LeftOrRight::Right(BalancingContext {
                                parent: unsafe { ptr::read(&right_parent_kv) },
                                left_child: self,
                                right_child: right_parent_kv.right_edge().descend(),
                            })),
                            Err(_) => unreachable!("empty internal node"),
                        },
                    },
                    Err(root) => Err(root),
                }
            }
        *)
        Definition choose_parent_kv (K V : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self K V in
          match τ, α with
          | [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              M.read (|
                M.match_operator (|
                  M.alloc (|
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "alloc::collections::btree::node::NodeRef")
                          [
                            Ty.path "alloc::collections::btree::node::marker::Mut";
                            K;
                            V;
                            Ty.path "alloc::collections::btree::node::marker::LeafOrInternal"
                          ],
                        "ascend",
                        []
                      |),
                      [
                        M.call_closure (|
                          M.get_function (|
                            "core::ptr::read",
                            [
                              Ty.apply
                                (Ty.path "alloc::collections::btree::node::NodeRef")
                                [
                                  Ty.path "alloc::collections::btree::node::marker::Mut";
                                  K;
                                  V;
                                  Ty.path "alloc::collections::btree::node::marker::LeafOrInternal"
                                ]
                            ]
                          |),
                          [ self ]
                        |)
                      ]
                    |)
                  |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ0_0 :=
                          M.SubPointer.get_struct_tuple_field (|
                            γ,
                            "core::result::Result::Ok",
                            0
                          |) in
                        let parent_edge := M.copy (| γ0_0 |) in
                        M.match_operator (|
                          M.alloc (|
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "alloc::collections::btree::node::Handle")
                                  [
                                    Ty.apply
                                      (Ty.path "alloc::collections::btree::node::NodeRef")
                                      [
                                        Ty.path "alloc::collections::btree::node::marker::Mut";
                                        K;
                                        V;
                                        Ty.path "alloc::collections::btree::node::marker::Internal"
                                      ];
                                    Ty.path "alloc::collections::btree::node::marker::Edge"
                                  ],
                                "left_kv",
                                []
                              |),
                              [ M.read (| parent_edge |) ]
                            |)
                          |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ0_0 :=
                                  M.SubPointer.get_struct_tuple_field (|
                                    γ,
                                    "core::result::Result::Ok",
                                    0
                                  |) in
                                let left_parent_kv := M.copy (| γ0_0 |) in
                                M.alloc (|
                                  Value.StructTuple
                                    "core::result::Result::Ok"
                                    [
                                      Value.StructTuple
                                        "alloc::collections::btree::node::LeftOrRight::Left"
                                        [
                                          Value.StructRecord
                                            "alloc::collections::btree::node::BalancingContext"
                                            [
                                              ("parent",
                                                M.call_closure (|
                                                  M.get_function (|
                                                    "core::ptr::read",
                                                    [
                                                      Ty.apply
                                                        (Ty.path
                                                          "alloc::collections::btree::node::Handle")
                                                        [
                                                          Ty.apply
                                                            (Ty.path
                                                              "alloc::collections::btree::node::NodeRef")
                                                            [
                                                              Ty.path
                                                                "alloc::collections::btree::node::marker::Mut";
                                                              K;
                                                              V;
                                                              Ty.path
                                                                "alloc::collections::btree::node::marker::Internal"
                                                            ];
                                                          Ty.path
                                                            "alloc::collections::btree::node::marker::KV"
                                                        ]
                                                    ]
                                                  |),
                                                  [ left_parent_kv ]
                                                |));
                                              ("left_child",
                                                M.call_closure (|
                                                  M.get_associated_function (|
                                                    Ty.apply
                                                      (Ty.path
                                                        "alloc::collections::btree::node::Handle")
                                                      [
                                                        Ty.apply
                                                          (Ty.path
                                                            "alloc::collections::btree::node::NodeRef")
                                                          [
                                                            Ty.path
                                                              "alloc::collections::btree::node::marker::Mut";
                                                            K;
                                                            V;
                                                            Ty.path
                                                              "alloc::collections::btree::node::marker::Internal"
                                                          ];
                                                        Ty.path
                                                          "alloc::collections::btree::node::marker::Edge"
                                                      ],
                                                    "descend",
                                                    []
                                                  |),
                                                  [
                                                    M.call_closure (|
                                                      M.get_associated_function (|
                                                        Ty.apply
                                                          (Ty.path
                                                            "alloc::collections::btree::node::Handle")
                                                          [
                                                            Ty.apply
                                                              (Ty.path
                                                                "alloc::collections::btree::node::NodeRef")
                                                              [
                                                                Ty.path
                                                                  "alloc::collections::btree::node::marker::Mut";
                                                                K;
                                                                V;
                                                                Ty.path
                                                                  "alloc::collections::btree::node::marker::Internal"
                                                              ];
                                                            Ty.path
                                                              "alloc::collections::btree::node::marker::KV"
                                                          ],
                                                        "left_edge",
                                                        []
                                                      |),
                                                      [ M.read (| left_parent_kv |) ]
                                                    |)
                                                  ]
                                                |));
                                              ("right_child", M.read (| self |))
                                            ]
                                        ]
                                    ]
                                |)));
                            fun γ =>
                              ltac:(M.monadic
                                (let γ0_0 :=
                                  M.SubPointer.get_struct_tuple_field (|
                                    γ,
                                    "core::result::Result::Err",
                                    0
                                  |) in
                                let parent_edge := M.copy (| γ0_0 |) in
                                M.match_operator (|
                                  M.alloc (|
                                    M.call_closure (|
                                      M.get_associated_function (|
                                        Ty.apply
                                          (Ty.path "alloc::collections::btree::node::Handle")
                                          [
                                            Ty.apply
                                              (Ty.path "alloc::collections::btree::node::NodeRef")
                                              [
                                                Ty.path
                                                  "alloc::collections::btree::node::marker::Mut";
                                                K;
                                                V;
                                                Ty.path
                                                  "alloc::collections::btree::node::marker::Internal"
                                              ];
                                            Ty.path "alloc::collections::btree::node::marker::Edge"
                                          ],
                                        "right_kv",
                                        []
                                      |),
                                      [ M.read (| parent_edge |) ]
                                    |)
                                  |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ0_0 :=
                                          M.SubPointer.get_struct_tuple_field (|
                                            γ,
                                            "core::result::Result::Ok",
                                            0
                                          |) in
                                        let right_parent_kv := M.copy (| γ0_0 |) in
                                        M.alloc (|
                                          Value.StructTuple
                                            "core::result::Result::Ok"
                                            [
                                              Value.StructTuple
                                                "alloc::collections::btree::node::LeftOrRight::Right"
                                                [
                                                  Value.StructRecord
                                                    "alloc::collections::btree::node::BalancingContext"
                                                    [
                                                      ("parent",
                                                        M.call_closure (|
                                                          M.get_function (|
                                                            "core::ptr::read",
                                                            [
                                                              Ty.apply
                                                                (Ty.path
                                                                  "alloc::collections::btree::node::Handle")
                                                                [
                                                                  Ty.apply
                                                                    (Ty.path
                                                                      "alloc::collections::btree::node::NodeRef")
                                                                    [
                                                                      Ty.path
                                                                        "alloc::collections::btree::node::marker::Mut";
                                                                      K;
                                                                      V;
                                                                      Ty.path
                                                                        "alloc::collections::btree::node::marker::Internal"
                                                                    ];
                                                                  Ty.path
                                                                    "alloc::collections::btree::node::marker::KV"
                                                                ]
                                                            ]
                                                          |),
                                                          [ right_parent_kv ]
                                                        |));
                                                      ("left_child", M.read (| self |));
                                                      ("right_child",
                                                        M.call_closure (|
                                                          M.get_associated_function (|
                                                            Ty.apply
                                                              (Ty.path
                                                                "alloc::collections::btree::node::Handle")
                                                              [
                                                                Ty.apply
                                                                  (Ty.path
                                                                    "alloc::collections::btree::node::NodeRef")
                                                                  [
                                                                    Ty.path
                                                                      "alloc::collections::btree::node::marker::Mut";
                                                                    K;
                                                                    V;
                                                                    Ty.path
                                                                      "alloc::collections::btree::node::marker::Internal"
                                                                  ];
                                                                Ty.path
                                                                  "alloc::collections::btree::node::marker::Edge"
                                                              ],
                                                            "descend",
                                                            []
                                                          |),
                                                          [
                                                            M.call_closure (|
                                                              M.get_associated_function (|
                                                                Ty.apply
                                                                  (Ty.path
                                                                    "alloc::collections::btree::node::Handle")
                                                                  [
                                                                    Ty.apply
                                                                      (Ty.path
                                                                        "alloc::collections::btree::node::NodeRef")
                                                                      [
                                                                        Ty.path
                                                                          "alloc::collections::btree::node::marker::Mut";
                                                                        K;
                                                                        V;
                                                                        Ty.path
                                                                          "alloc::collections::btree::node::marker::Internal"
                                                                      ];
                                                                    Ty.path
                                                                      "alloc::collections::btree::node::marker::KV"
                                                                  ],
                                                                "right_edge",
                                                                []
                                                              |),
                                                              [ M.read (| right_parent_kv |) ]
                                                            |)
                                                          ]
                                                        |))
                                                    ]
                                                ]
                                            ]
                                        |)));
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ0_0 :=
                                          M.SubPointer.get_struct_tuple_field (|
                                            γ,
                                            "core::result::Result::Err",
                                            0
                                          |) in
                                        M.alloc (|
                                          M.never_to_any (|
                                            M.call_closure (|
                                              M.get_function (| "core::panicking::panic_fmt", [] |),
                                              [
                                                M.call_closure (|
                                                  M.get_associated_function (|
                                                    Ty.path "core::fmt::Arguments",
                                                    "new_v1",
                                                    []
                                                  |),
                                                  [
                                                    (* Unsize *)
                                                    M.pointer_coercion
                                                      (M.alloc (|
                                                        Value.Array
                                                          [
                                                            M.read (|
                                                              Value.String
                                                                "internal error: entered unreachable code: empty internal node"
                                                            |)
                                                          ]
                                                      |));
                                                    (* Unsize *)
                                                    M.pointer_coercion
                                                      (M.alloc (|
                                                        M.call_closure (|
                                                          M.get_associated_function (|
                                                            Ty.path "core::fmt::rt::Argument",
                                                            "none",
                                                            []
                                                          |),
                                                          []
                                                        |)
                                                      |))
                                                  ]
                                                |)
                                              ]
                                            |)
                                          |)
                                        |)))
                                  ]
                                |)))
                          ]
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ0_0 :=
                          M.SubPointer.get_struct_tuple_field (|
                            γ,
                            "core::result::Result::Err",
                            0
                          |) in
                        let root := M.copy (| γ0_0 |) in
                        M.alloc (|
                          Value.StructTuple "core::result::Result::Err" [ M.read (| root |) ]
                        |)))
                  ]
                |)
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom AssociatedFunction_choose_parent_kv :
          forall (K V : Ty.t),
          M.IsAssociatedFunction (Self K V) "choose_parent_kv" (choose_parent_kv K V).
      End Impl_alloc_collections_btree_node_NodeRef_alloc_collections_btree_node_marker_Mut_K_V_alloc_collections_btree_node_marker_LeafOrInternal.
      
      Module Impl_alloc_collections_btree_node_NodeRef_alloc_collections_btree_node_marker_Owned_K_V_alloc_collections_btree_node_marker_LeafOrInternal.
        Definition Self (K V : Ty.t) : Ty.t :=
          Ty.apply
            (Ty.path "alloc::collections::btree::node::NodeRef")
            [
              Ty.path "alloc::collections::btree::node::marker::Owned";
              K;
              V;
              Ty.path "alloc::collections::btree::node::marker::LeafOrInternal"
            ].
        
        (*
            fn clear_parent_link(&mut self) {
                let mut root_node = self.borrow_mut();
                let leaf = root_node.as_leaf_mut();
                leaf.parent = None;
            }
        *)
        Definition clear_parent_link (K V : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self K V in
          match τ, α with
          | [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              M.read (|
                let~ root_node :=
                  M.alloc (|
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "alloc::collections::btree::node::NodeRef")
                          [
                            Ty.path "alloc::collections::btree::node::marker::Owned";
                            K;
                            V;
                            Ty.path "alloc::collections::btree::node::marker::LeafOrInternal"
                          ],
                        "borrow_mut",
                        []
                      |),
                      [ M.read (| self |) ]
                    |)
                  |) in
                let~ leaf :=
                  M.alloc (|
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "alloc::collections::btree::node::NodeRef")
                          [
                            Ty.path "alloc::collections::btree::node::marker::Mut";
                            K;
                            V;
                            Ty.path "alloc::collections::btree::node::marker::LeafOrInternal"
                          ],
                        "as_leaf_mut",
                        []
                      |),
                      [ root_node ]
                    |)
                  |) in
                let~ _ :=
                  M.write (|
                    M.SubPointer.get_struct_record_field (|
                      M.read (| leaf |),
                      "alloc::collections::btree::node::LeafNode",
                      "parent"
                    |),
                    Value.StructTuple "core::option::Option::None" []
                  |) in
                M.alloc (| Value.Tuple [] |)
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom AssociatedFunction_clear_parent_link :
          forall (K V : Ty.t),
          M.IsAssociatedFunction (Self K V) "clear_parent_link" (clear_parent_link K V).
        (*
            pub fn new<A: Allocator + Clone>(alloc: A) -> Self {
                NodeRef::new_leaf(alloc).forget_type()
            }
        *)
        Definition new (K V : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self K V in
          match τ, α with
          | [ A ], [ alloc ] =>
            ltac:(M.monadic
              (let alloc := M.alloc (| alloc |) in
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "alloc::collections::btree::node::NodeRef")
                    [
                      Ty.path "alloc::collections::btree::node::marker::Owned";
                      K;
                      V;
                      Ty.path "alloc::collections::btree::node::marker::Leaf"
                    ],
                  "forget_type",
                  []
                |),
                [
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "alloc::collections::btree::node::NodeRef")
                        [
                          Ty.path "alloc::collections::btree::node::marker::Owned";
                          K;
                          V;
                          Ty.path "alloc::collections::btree::node::marker::Leaf"
                        ],
                      "new_leaf",
                      [ A ]
                    |),
                    [ M.read (| alloc |) ]
                  |)
                ]
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom AssociatedFunction_new :
          forall (K V : Ty.t),
          M.IsAssociatedFunction (Self K V) "new" (new K V).
        
        (*
            pub fn push_internal_level<A: Allocator + Clone>(
                &mut self,
                alloc: A,
            ) -> NodeRef<marker::Mut<'_>, K, V, marker::Internal> {
                super::mem::take_mut(self, |old_root| NodeRef::new_internal(old_root, alloc).forget_type());
        
                // `self.borrow_mut()`, except that we just forgot we're internal now:
                NodeRef { height: self.height, node: self.node, _marker: PhantomData }
            }
        *)
        Definition push_internal_level (K V : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self K V in
          match τ, α with
          | [ A ], [ self; alloc ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let alloc := M.alloc (| alloc |) in
              M.read (|
                let~ _ :=
                  M.alloc (|
                    M.call_closure (|
                      M.get_function (|
                        "alloc::collections::btree::mem::take_mut",
                        [
                          Ty.apply
                            (Ty.path "alloc::collections::btree::node::NodeRef")
                            [
                              Ty.path "alloc::collections::btree::node::marker::Owned";
                              K;
                              V;
                              Ty.path "alloc::collections::btree::node::marker::LeafOrInternal"
                            ];
                          Ty.function
                            [
                              Ty.tuple
                                [
                                  Ty.apply
                                    (Ty.path "alloc::collections::btree::node::NodeRef")
                                    [
                                      Ty.path "alloc::collections::btree::node::marker::Owned";
                                      K;
                                      V;
                                      Ty.path
                                        "alloc::collections::btree::node::marker::LeafOrInternal"
                                    ]
                                ]
                            ]
                            (Ty.apply
                              (Ty.path "alloc::collections::btree::node::NodeRef")
                              [
                                Ty.path "alloc::collections::btree::node::marker::Owned";
                                K;
                                V;
                                Ty.path "alloc::collections::btree::node::marker::LeafOrInternal"
                              ])
                        ]
                      |),
                      [
                        M.read (| self |);
                        M.closure
                          (fun γ =>
                            ltac:(M.monadic
                              match γ with
                              | [ α0 ] =>
                                M.match_operator (|
                                  M.alloc (| α0 |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let old_root := M.copy (| γ |) in
                                        M.call_closure (|
                                          M.get_associated_function (|
                                            Ty.apply
                                              (Ty.path "alloc::collections::btree::node::NodeRef")
                                              [
                                                Ty.path
                                                  "alloc::collections::btree::node::marker::Owned";
                                                K;
                                                V;
                                                Ty.path
                                                  "alloc::collections::btree::node::marker::Internal"
                                              ],
                                            "forget_type",
                                            []
                                          |),
                                          [
                                            M.call_closure (|
                                              M.get_associated_function (|
                                                Ty.apply
                                                  (Ty.path
                                                    "alloc::collections::btree::node::NodeRef")
                                                  [
                                                    Ty.path
                                                      "alloc::collections::btree::node::marker::Owned";
                                                    K;
                                                    V;
                                                    Ty.path
                                                      "alloc::collections::btree::node::marker::Internal"
                                                  ],
                                                "new_internal",
                                                [ A ]
                                              |),
                                              [ M.read (| old_root |); M.read (| alloc |) ]
                                            |)
                                          ]
                                        |)))
                                  ]
                                |)
                              | _ => M.impossible (||)
                              end))
                      ]
                    |)
                  |) in
                M.alloc (|
                  Value.StructRecord
                    "alloc::collections::btree::node::NodeRef"
                    [
                      ("height",
                        M.read (|
                          M.SubPointer.get_struct_record_field (|
                            M.read (| self |),
                            "alloc::collections::btree::node::NodeRef",
                            "height"
                          |)
                        |));
                      ("node",
                        M.read (|
                          M.SubPointer.get_struct_record_field (|
                            M.read (| self |),
                            "alloc::collections::btree::node::NodeRef",
                            "node"
                          |)
                        |));
                      ("_marker", Value.StructTuple "core::marker::PhantomData" [])
                    ]
                |)
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom AssociatedFunction_push_internal_level :
          forall (K V : Ty.t),
          M.IsAssociatedFunction (Self K V) "push_internal_level" (push_internal_level K V).
        
        (*
            pub fn pop_internal_level<A: Allocator + Clone>(&mut self, alloc: A) {
                assert!(self.height > 0);
        
                let top = self.node;
        
                // SAFETY: we asserted to be internal.
                let internal_self = unsafe { self.borrow_mut().cast_to_internal_unchecked() };
                // SAFETY: we borrowed `self` exclusively and its borrow type is exclusive.
                let internal_node = unsafe { &mut *NodeRef::as_internal_ptr(&internal_self) };
                // SAFETY: the first edge is always initialized.
                self.node = unsafe { internal_node.edges[0].assume_init_read() };
                self.height -= 1;
                self.clear_parent_link();
        
                unsafe {
                    alloc.deallocate(top.cast(), Layout::new::<InternalNode<K, V>>());
                }
            }
        *)
        Definition pop_internal_level (K V : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self K V in
          match τ, α with
          | [ A ], [ self; alloc ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let alloc := M.alloc (| alloc |) in
              M.read (|
                let~ _ :=
                  M.match_operator (|
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                UnOp.Pure.not
                                  (BinOp.Pure.gt
                                    (M.read (|
                                      M.SubPointer.get_struct_record_field (|
                                        M.read (| self |),
                                        "alloc::collections::btree::node::NodeRef",
                                        "height"
                                      |)
                                    |))
                                    (Value.Integer 0))
                              |)) in
                          let _ :=
                            M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (|
                            M.never_to_any (|
                              M.call_closure (|
                                M.get_function (| "core::panicking::panic", [] |),
                                [ M.read (| Value.String "assertion failed: self.height > 0" |) ]
                              |)
                            |)
                          |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                let~ top :=
                  M.copy (|
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "alloc::collections::btree::node::NodeRef",
                      "node"
                    |)
                  |) in
                let~ internal_self :=
                  M.alloc (|
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "alloc::collections::btree::node::NodeRef")
                          [
                            Ty.path "alloc::collections::btree::node::marker::Mut";
                            K;
                            V;
                            Ty.path "alloc::collections::btree::node::marker::LeafOrInternal"
                          ],
                        "cast_to_internal_unchecked",
                        []
                      |),
                      [
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.apply
                              (Ty.path "alloc::collections::btree::node::NodeRef")
                              [
                                Ty.path "alloc::collections::btree::node::marker::Owned";
                                K;
                                V;
                                Ty.path "alloc::collections::btree::node::marker::LeafOrInternal"
                              ],
                            "borrow_mut",
                            []
                          |),
                          [ M.read (| self |) ]
                        |)
                      ]
                    |)
                  |) in
                let~ internal_node :=
                  M.alloc (|
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "alloc::collections::btree::node::NodeRef")
                          [
                            Ty.path "alloc::collections::btree::node::marker::Mut";
                            K;
                            V;
                            Ty.path "alloc::collections::btree::node::marker::Internal"
                          ],
                        "as_internal_ptr",
                        []
                      |),
                      [ internal_self ]
                    |)
                  |) in
                let~ _ :=
                  M.write (|
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "alloc::collections::btree::node::NodeRef",
                      "node"
                    |),
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                          [
                            Ty.apply
                              (Ty.path "core::ptr::non_null::NonNull")
                              [
                                Ty.apply
                                  (Ty.path "alloc::collections::btree::node::LeafNode")
                                  [ K; V ]
                              ]
                          ],
                        "assume_init_read",
                        []
                      |),
                      [
                        M.SubPointer.get_array_field (|
                          M.SubPointer.get_struct_record_field (|
                            M.read (| internal_node |),
                            "alloc::collections::btree::node::InternalNode",
                            "edges"
                          |),
                          M.alloc (| Value.Integer 0 |)
                        |)
                      ]
                    |)
                  |) in
                let~ _ :=
                  let β :=
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "alloc::collections::btree::node::NodeRef",
                      "height"
                    |) in
                  M.write (|
                    β,
                    BinOp.Wrap.sub Integer.Usize (M.read (| β |)) (Value.Integer 1)
                  |) in
                let~ _ :=
                  M.alloc (|
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "alloc::collections::btree::node::NodeRef")
                          [
                            Ty.path "alloc::collections::btree::node::marker::Owned";
                            K;
                            V;
                            Ty.path "alloc::collections::btree::node::marker::LeafOrInternal"
                          ],
                        "clear_parent_link",
                        []
                      |),
                      [ M.read (| self |) ]
                    |)
                  |) in
                let~ _ :=
                  M.alloc (|
                    M.call_closure (|
                      M.get_trait_method (| "core::alloc::Allocator", A, [], "deallocate", [] |),
                      [
                        alloc;
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.apply
                              (Ty.path "core::ptr::non_null::NonNull")
                              [
                                Ty.apply
                                  (Ty.path "alloc::collections::btree::node::LeafNode")
                                  [ K; V ]
                              ],
                            "cast",
                            [ Ty.path "u8" ]
                          |),
                          [ M.read (| top |) ]
                        |);
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.path "core::alloc::layout::Layout",
                            "new",
                            [
                              Ty.apply
                                (Ty.path "alloc::collections::btree::node::InternalNode")
                                [ K; V ]
                            ]
                          |),
                          []
                        |)
                      ]
                    |)
                  |) in
                M.alloc (| Value.Tuple [] |)
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom AssociatedFunction_pop_internal_level :
          forall (K V : Ty.t),
          M.IsAssociatedFunction (Self K V) "pop_internal_level" (pop_internal_level K V).
      End Impl_alloc_collections_btree_node_NodeRef_alloc_collections_btree_node_marker_Owned_K_V_alloc_collections_btree_node_marker_LeafOrInternal.
      
      
      Module Impl_alloc_collections_btree_node_NodeRef_alloc_collections_btree_node_marker_Owned_K_V_Type_.
        Definition Self (K V Type_ : Ty.t) : Ty.t :=
          Ty.apply
            (Ty.path "alloc::collections::btree::node::NodeRef")
            [ Ty.path "alloc::collections::btree::node::marker::Owned"; K; V; Type_ ].
        
        (*
            pub fn borrow_mut(&mut self) -> NodeRef<marker::Mut<'_>, K, V, Type> {
                NodeRef { height: self.height, node: self.node, _marker: PhantomData }
            }
        *)
        Definition borrow_mut (K V Type_ : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self K V Type_ in
          match τ, α with
          | [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              Value.StructRecord
                "alloc::collections::btree::node::NodeRef"
                [
                  ("height",
                    M.read (|
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "alloc::collections::btree::node::NodeRef",
                        "height"
                      |)
                    |));
                  ("node",
                    M.read (|
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "alloc::collections::btree::node::NodeRef",
                        "node"
                      |)
                    |));
                  ("_marker", Value.StructTuple "core::marker::PhantomData" [])
                ]))
          | _, _ => M.impossible
          end.
        
        Axiom AssociatedFunction_borrow_mut :
          forall (K V Type_ : Ty.t),
          M.IsAssociatedFunction (Self K V Type_) "borrow_mut" (borrow_mut K V Type_).
        
        (*
            pub fn borrow_valmut(&mut self) -> NodeRef<marker::ValMut<'_>, K, V, Type> {
                NodeRef { height: self.height, node: self.node, _marker: PhantomData }
            }
        *)
        Definition borrow_valmut (K V Type_ : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self K V Type_ in
          match τ, α with
          | [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              Value.StructRecord
                "alloc::collections::btree::node::NodeRef"
                [
                  ("height",
                    M.read (|
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "alloc::collections::btree::node::NodeRef",
                        "height"
                      |)
                    |));
                  ("node",
                    M.read (|
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "alloc::collections::btree::node::NodeRef",
                        "node"
                      |)
                    |));
                  ("_marker", Value.StructTuple "core::marker::PhantomData" [])
                ]))
          | _, _ => M.impossible
          end.
        
        Axiom AssociatedFunction_borrow_valmut :
          forall (K V Type_ : Ty.t),
          M.IsAssociatedFunction (Self K V Type_) "borrow_valmut" (borrow_valmut K V Type_).
        
        (*
            pub fn into_dying(self) -> NodeRef<marker::Dying, K, V, Type> {
                NodeRef { height: self.height, node: self.node, _marker: PhantomData }
            }
        *)
        Definition into_dying (K V Type_ : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self K V Type_ in
          match τ, α with
          | [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              Value.StructRecord
                "alloc::collections::btree::node::NodeRef"
                [
                  ("height",
                    M.read (|
                      M.SubPointer.get_struct_record_field (|
                        self,
                        "alloc::collections::btree::node::NodeRef",
                        "height"
                      |)
                    |));
                  ("node",
                    M.read (|
                      M.SubPointer.get_struct_record_field (|
                        self,
                        "alloc::collections::btree::node::NodeRef",
                        "node"
                      |)
                    |));
                  ("_marker", Value.StructTuple "core::marker::PhantomData" [])
                ]))
          | _, _ => M.impossible
          end.
        
        Axiom AssociatedFunction_into_dying :
          forall (K V Type_ : Ty.t),
          M.IsAssociatedFunction (Self K V Type_) "into_dying" (into_dying K V Type_).
      End Impl_alloc_collections_btree_node_NodeRef_alloc_collections_btree_node_marker_Owned_K_V_Type_.
      
      Module Impl_alloc_collections_btree_node_NodeRef_alloc_collections_btree_node_marker_Mut_K_V_alloc_collections_btree_node_marker_Leaf.
        Definition Self (K V : Ty.t) : Ty.t :=
          Ty.apply
            (Ty.path "alloc::collections::btree::node::NodeRef")
            [
              Ty.path "alloc::collections::btree::node::marker::Mut";
              K;
              V;
              Ty.path "alloc::collections::btree::node::marker::Leaf"
            ].
        
        (*
            pub fn push(&mut self, key: K, val: V) -> &mut V {
                let len = self.len_mut();
                let idx = usize::from( *len);
                assert!(idx < CAPACITY);
                *len += 1;
                unsafe {
                    self.key_area_mut(idx).write(key);
                    self.val_area_mut(idx).write(val)
                }
            }
        *)
        Definition push (K V : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self K V in
          match τ, α with
          | [], [ self; key; val ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let key := M.alloc (| key |) in
              let val := M.alloc (| val |) in
              M.read (|
                let~ len :=
                  M.alloc (|
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "alloc::collections::btree::node::NodeRef")
                          [
                            Ty.path "alloc::collections::btree::node::marker::Mut";
                            K;
                            V;
                            Ty.path "alloc::collections::btree::node::marker::Leaf"
                          ],
                        "len_mut",
                        []
                      |),
                      [ M.read (| self |) ]
                    |)
                  |) in
                let~ idx :=
                  M.alloc (|
                    M.call_closure (|
                      M.get_trait_method (|
                        "core::convert::From",
                        Ty.path "usize",
                        [ Ty.path "u16" ],
                        "from",
                        []
                      |),
                      [ M.read (| M.read (| len |) |) ]
                    |)
                  |) in
                let~ _ :=
                  M.match_operator (|
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                UnOp.Pure.not
                                  (BinOp.Pure.lt
                                    (M.read (| idx |))
                                    (M.read (|
                                      M.get_constant (|
                                        "alloc::collections::btree::node::CAPACITY"
                                      |)
                                    |)))
                              |)) in
                          let _ :=
                            M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (|
                            M.never_to_any (|
                              M.call_closure (|
                                M.get_function (| "core::panicking::panic", [] |),
                                [ M.read (| Value.String "assertion failed: idx < CAPACITY" |) ]
                              |)
                            |)
                          |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                let~ _ :=
                  let β := M.read (| len |) in
                  M.write (| β, BinOp.Wrap.add Integer.U16 (M.read (| β |)) (Value.Integer 1) |) in
                M.alloc (|
                  M.read (|
                    let~ _ :=
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ K ],
                            "write",
                            []
                          |),
                          [
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "alloc::collections::btree::node::NodeRef")
                                  [
                                    Ty.path "alloc::collections::btree::node::marker::Mut";
                                    K;
                                    V;
                                    Ty.path "alloc::collections::btree::node::marker::Leaf"
                                  ],
                                "key_area_mut",
                                [
                                  Ty.path "usize";
                                  Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ K ]
                                ]
                              |),
                              [ M.read (| self |); M.read (| idx |) ]
                            |);
                            M.read (| key |)
                          ]
                        |)
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ V ],
                          "write",
                          []
                        |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply
                                (Ty.path "alloc::collections::btree::node::NodeRef")
                                [
                                  Ty.path "alloc::collections::btree::node::marker::Mut";
                                  K;
                                  V;
                                  Ty.path "alloc::collections::btree::node::marker::Leaf"
                                ],
                              "val_area_mut",
                              [
                                Ty.path "usize";
                                Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ V ]
                              ]
                            |),
                            [ M.read (| self |); M.read (| idx |) ]
                          |);
                          M.read (| val |)
                        ]
                      |)
                    |)
                  |)
                |)
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom AssociatedFunction_push :
          forall (K V : Ty.t),
          M.IsAssociatedFunction (Self K V) "push" (push K V).
      End Impl_alloc_collections_btree_node_NodeRef_alloc_collections_btree_node_marker_Mut_K_V_alloc_collections_btree_node_marker_Leaf.
      
      
      Module Impl_alloc_collections_btree_node_NodeRef_BorrowType_K_V_alloc_collections_btree_node_marker_Leaf.
        Definition Self (BorrowType K V : Ty.t) : Ty.t :=
          Ty.apply
            (Ty.path "alloc::collections::btree::node::NodeRef")
            [ BorrowType; K; V; Ty.path "alloc::collections::btree::node::marker::Leaf" ].
        
        (*
            pub fn forget_type(self) -> NodeRef<BorrowType, K, V, marker::LeafOrInternal> {
                NodeRef { height: self.height, node: self.node, _marker: PhantomData }
            }
        *)
        Definition forget_type (BorrowType K V : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self BorrowType K V in
          match τ, α with
          | [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              Value.StructRecord
                "alloc::collections::btree::node::NodeRef"
                [
                  ("height",
                    M.read (|
                      M.SubPointer.get_struct_record_field (|
                        self,
                        "alloc::collections::btree::node::NodeRef",
                        "height"
                      |)
                    |));
                  ("node",
                    M.read (|
                      M.SubPointer.get_struct_record_field (|
                        self,
                        "alloc::collections::btree::node::NodeRef",
                        "node"
                      |)
                    |));
                  ("_marker", Value.StructTuple "core::marker::PhantomData" [])
                ]))
          | _, _ => M.impossible
          end.
        
        Axiom AssociatedFunction_forget_type :
          forall (BorrowType K V : Ty.t),
          M.IsAssociatedFunction (Self BorrowType K V) "forget_type" (forget_type BorrowType K V).
      End Impl_alloc_collections_btree_node_NodeRef_BorrowType_K_V_alloc_collections_btree_node_marker_Leaf.
      
      
      Module Impl_alloc_collections_btree_node_NodeRef_BorrowType_K_V_alloc_collections_btree_node_marker_LeafOrInternal.
        Definition Self (BorrowType K V : Ty.t) : Ty.t :=
          Ty.apply
            (Ty.path "alloc::collections::btree::node::NodeRef")
            [ BorrowType; K; V; Ty.path "alloc::collections::btree::node::marker::LeafOrInternal" ].
        
        (*
            pub fn force(
                self,
            ) -> ForceResult<
                NodeRef<BorrowType, K, V, marker::Leaf>,
                NodeRef<BorrowType, K, V, marker::Internal>,
            > {
                if self.height == 0 {
                    ForceResult::Leaf(NodeRef {
                        height: self.height,
                        node: self.node,
                        _marker: PhantomData,
                    })
                } else {
                    ForceResult::Internal(NodeRef {
                        height: self.height,
                        node: self.node,
                        _marker: PhantomData,
                    })
                }
            }
        *)
        Definition force (BorrowType K V : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self BorrowType K V in
          match τ, α with
          | [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              M.read (|
                M.match_operator (|
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ :=
                          M.use
                            (M.alloc (|
                              BinOp.Pure.eq
                                (M.read (|
                                  M.SubPointer.get_struct_record_field (|
                                    self,
                                    "alloc::collections::btree::node::NodeRef",
                                    "height"
                                  |)
                                |))
                                (Value.Integer 0)
                            |)) in
                        let _ :=
                          M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        M.alloc (|
                          Value.StructTuple
                            "alloc::collections::btree::node::ForceResult::Leaf'1"
                            [
                              Value.StructRecord
                                "alloc::collections::btree::node::NodeRef"
                                [
                                  ("height",
                                    M.read (|
                                      M.SubPointer.get_struct_record_field (|
                                        self,
                                        "alloc::collections::btree::node::NodeRef",
                                        "height"
                                      |)
                                    |));
                                  ("node",
                                    M.read (|
                                      M.SubPointer.get_struct_record_field (|
                                        self,
                                        "alloc::collections::btree::node::NodeRef",
                                        "node"
                                      |)
                                    |));
                                  ("_marker", Value.StructTuple "core::marker::PhantomData" [])
                                ]
                            ]
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (M.alloc (|
                          Value.StructTuple
                            "alloc::collections::btree::node::ForceResult::Internal'1"
                            [
                              Value.StructRecord
                                "alloc::collections::btree::node::NodeRef"
                                [
                                  ("height",
                                    M.read (|
                                      M.SubPointer.get_struct_record_field (|
                                        self,
                                        "alloc::collections::btree::node::NodeRef",
                                        "height"
                                      |)
                                    |));
                                  ("node",
                                    M.read (|
                                      M.SubPointer.get_struct_record_field (|
                                        self,
                                        "alloc::collections::btree::node::NodeRef",
                                        "node"
                                      |)
                                    |));
                                  ("_marker", Value.StructTuple "core::marker::PhantomData" [])
                                ]
                            ]
                        |)))
                  ]
                |)
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom AssociatedFunction_force :
          forall (BorrowType K V : Ty.t),
          M.IsAssociatedFunction (Self BorrowType K V) "force" (force BorrowType K V).
      End Impl_alloc_collections_btree_node_NodeRef_BorrowType_K_V_alloc_collections_btree_node_marker_LeafOrInternal.
      
      
      (* StructRecord
        {
          name := "Handle";
          ty_params := [ "Node"; "Type_" ];
          fields :=
            [
              ("node", Node);
              ("idx", Ty.path "usize");
              ("_marker", Ty.apply (Ty.path "core::marker::PhantomData") [ Type_ ])
            ];
        } *)
      
      Module Impl_core_marker_Copy_where_core_marker_Copy_Node_for_alloc_collections_btree_node_Handle_Node_Type_.
        Definition Self (Node Type_ : Ty.t) : Ty.t :=
          Ty.apply (Ty.path "alloc::collections::btree::node::Handle") [ Node; Type_ ].
        
        Axiom Implements :
          forall (Node Type_ : Ty.t),
          M.IsTraitInstance
            "core::marker::Copy"
            (Self Node Type_)
            (* Trait polymorphic types *) []
            (* Instance *) [].
      End Impl_core_marker_Copy_where_core_marker_Copy_Node_for_alloc_collections_btree_node_Handle_Node_Type_.
      
      Module Impl_core_clone_Clone_where_core_marker_Copy_Node_for_alloc_collections_btree_node_Handle_Node_Type_.
        Definition Self (Node Type_ : Ty.t) : Ty.t :=
          Ty.apply (Ty.path "alloc::collections::btree::node::Handle") [ Node; Type_ ].
        
        (*
            fn clone(&self) -> Self {
                *self
            }
        *)
        Definition clone (Node Type_ : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self Node Type_ in
          match τ, α with
          | [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              M.read (| M.read (| self |) |)))
          | _, _ => M.impossible
          end.
        
        Axiom Implements :
          forall (Node Type_ : Ty.t),
          M.IsTraitInstance
            "core::clone::Clone"
            (Self Node Type_)
            (* Trait polymorphic types *) []
            (* Instance *) [ ("clone", InstanceField.Method (clone Node Type_)) ].
      End Impl_core_clone_Clone_where_core_marker_Copy_Node_for_alloc_collections_btree_node_Handle_Node_Type_.
      
      Module Impl_alloc_collections_btree_node_Handle_Node_Type_.
        Definition Self (Node Type_ : Ty.t) : Ty.t :=
          Ty.apply (Ty.path "alloc::collections::btree::node::Handle") [ Node; Type_ ].
        
        (*
            pub fn into_node(self) -> Node {
                self.node
            }
        *)
        Definition into_node (Node Type_ : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self Node Type_ in
          match τ, α with
          | [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              M.read (|
                M.SubPointer.get_struct_record_field (|
                  self,
                  "alloc::collections::btree::node::Handle",
                  "node"
                |)
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom AssociatedFunction_into_node :
          forall (Node Type_ : Ty.t),
          M.IsAssociatedFunction (Self Node Type_) "into_node" (into_node Node Type_).
        
        (*
            pub fn idx(&self) -> usize {
                self.idx
            }
        *)
        Definition idx (Node Type_ : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self Node Type_ in
          match τ, α with
          | [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              M.read (|
                M.SubPointer.get_struct_record_field (|
                  M.read (| self |),
                  "alloc::collections::btree::node::Handle",
                  "idx"
                |)
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom AssociatedFunction_idx :
          forall (Node Type_ : Ty.t),
          M.IsAssociatedFunction (Self Node Type_) "idx" (idx Node Type_).
      End Impl_alloc_collections_btree_node_Handle_Node_Type_.
      
      Module Impl_alloc_collections_btree_node_Handle_alloc_collections_btree_node_NodeRef_BorrowType_K_V_NodeType_alloc_collections_btree_node_marker_KV.
        Definition Self (BorrowType K V NodeType : Ty.t) : Ty.t :=
          Ty.apply
            (Ty.path "alloc::collections::btree::node::Handle")
            [
              Ty.apply
                (Ty.path "alloc::collections::btree::node::NodeRef")
                [ BorrowType; K; V; NodeType ];
              Ty.path "alloc::collections::btree::node::marker::KV"
            ].
        
        (*
            pub unsafe fn new_kv(node: NodeRef<BorrowType, K, V, NodeType>, idx: usize) -> Self {
                debug_assert!(idx < node.len());
        
                Handle { node, idx, _marker: PhantomData }
            }
        *)
        Definition new_kv (BorrowType K V NodeType : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self BorrowType K V NodeType in
          match τ, α with
          | [], [ node; idx ] =>
            ltac:(M.monadic
              (let node := M.alloc (| node |) in
              let idx := M.alloc (| idx |) in
              M.read (|
                let~ _ :=
                  M.match_operator (|
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ := M.use (M.alloc (| Value.Bool true |)) in
                          let _ :=
                            M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          let~ _ :=
                            M.match_operator (|
                              M.alloc (| Value.Tuple [] |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let γ :=
                                      M.use
                                        (M.alloc (|
                                          UnOp.Pure.not
                                            (BinOp.Pure.lt
                                              (M.read (| idx |))
                                              (M.call_closure (|
                                                M.get_associated_function (|
                                                  Ty.apply
                                                    (Ty.path
                                                      "alloc::collections::btree::node::NodeRef")
                                                    [ BorrowType; K; V; NodeType ],
                                                  "len",
                                                  []
                                                |),
                                                [ node ]
                                              |)))
                                        |)) in
                                    let _ :=
                                      M.is_constant_or_break_match (|
                                        M.read (| γ |),
                                        Value.Bool true
                                      |) in
                                    M.alloc (|
                                      M.never_to_any (|
                                        M.call_closure (|
                                          M.get_function (| "core::panicking::panic", [] |),
                                          [
                                            M.read (|
                                              Value.String "assertion failed: idx < node.len()"
                                            |)
                                          ]
                                        |)
                                      |)
                                    |)));
                                fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                              ]
                            |) in
                          M.alloc (| Value.Tuple [] |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                M.alloc (|
                  Value.StructRecord
                    "alloc::collections::btree::node::Handle"
                    [
                      ("node", M.read (| node |));
                      ("idx", M.read (| idx |));
                      ("_marker", Value.StructTuple "core::marker::PhantomData" [])
                    ]
                |)
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom AssociatedFunction_new_kv :
          forall (BorrowType K V NodeType : Ty.t),
          M.IsAssociatedFunction
            (Self BorrowType K V NodeType)
            "new_kv"
            (new_kv BorrowType K V NodeType).
        
        (*
            pub fn left_edge(self) -> Handle<NodeRef<BorrowType, K, V, NodeType>, marker::Edge> {
                unsafe { Handle::new_edge(self.node, self.idx) }
            }
        *)
        Definition left_edge
            (BorrowType K V NodeType : Ty.t)
            (τ : list Ty.t)
            (α : list Value.t)
            : M :=
          let Self : Ty.t := Self BorrowType K V NodeType in
          match τ, α with
          | [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "alloc::collections::btree::node::Handle")
                    [
                      Ty.apply
                        (Ty.path "alloc::collections::btree::node::NodeRef")
                        [ BorrowType; K; V; NodeType ];
                      Ty.path "alloc::collections::btree::node::marker::Edge"
                    ],
                  "new_edge",
                  []
                |),
                [
                  M.read (|
                    M.SubPointer.get_struct_record_field (|
                      self,
                      "alloc::collections::btree::node::Handle",
                      "node"
                    |)
                  |);
                  M.read (|
                    M.SubPointer.get_struct_record_field (|
                      self,
                      "alloc::collections::btree::node::Handle",
                      "idx"
                    |)
                  |)
                ]
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom AssociatedFunction_left_edge :
          forall (BorrowType K V NodeType : Ty.t),
          M.IsAssociatedFunction
            (Self BorrowType K V NodeType)
            "left_edge"
            (left_edge BorrowType K V NodeType).
        
        (*
            pub fn right_edge(self) -> Handle<NodeRef<BorrowType, K, V, NodeType>, marker::Edge> {
                unsafe { Handle::new_edge(self.node, self.idx + 1) }
            }
        *)
        Definition right_edge
            (BorrowType K V NodeType : Ty.t)
            (τ : list Ty.t)
            (α : list Value.t)
            : M :=
          let Self : Ty.t := Self BorrowType K V NodeType in
          match τ, α with
          | [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "alloc::collections::btree::node::Handle")
                    [
                      Ty.apply
                        (Ty.path "alloc::collections::btree::node::NodeRef")
                        [ BorrowType; K; V; NodeType ];
                      Ty.path "alloc::collections::btree::node::marker::Edge"
                    ],
                  "new_edge",
                  []
                |),
                [
                  M.read (|
                    M.SubPointer.get_struct_record_field (|
                      self,
                      "alloc::collections::btree::node::Handle",
                      "node"
                    |)
                  |);
                  BinOp.Wrap.add
                    Integer.Usize
                    (M.read (|
                      M.SubPointer.get_struct_record_field (|
                        self,
                        "alloc::collections::btree::node::Handle",
                        "idx"
                      |)
                    |))
                    (Value.Integer 1)
                ]
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom AssociatedFunction_right_edge :
          forall (BorrowType K V NodeType : Ty.t),
          M.IsAssociatedFunction
            (Self BorrowType K V NodeType)
            "right_edge"
            (right_edge BorrowType K V NodeType).
      End Impl_alloc_collections_btree_node_Handle_alloc_collections_btree_node_NodeRef_BorrowType_K_V_NodeType_alloc_collections_btree_node_marker_KV.
      
      Module Impl_core_cmp_PartialEq_for_alloc_collections_btree_node_Handle_alloc_collections_btree_node_NodeRef_BorrowType_K_V_NodeType_HandleType.
        Definition Self (BorrowType K V NodeType HandleType : Ty.t) : Ty.t :=
          Ty.apply
            (Ty.path "alloc::collections::btree::node::Handle")
            [
              Ty.apply
                (Ty.path "alloc::collections::btree::node::NodeRef")
                [ BorrowType; K; V; NodeType ];
              HandleType
            ].
        
        (*
            fn eq(&self, other: &Self) -> bool {
                let Self { node, idx, _marker } = self;
                node.eq(&other.node) && *idx == other.idx
            }
        *)
        Definition eq
            (BorrowType K V NodeType HandleType : Ty.t)
            (τ : list Ty.t)
            (α : list Value.t)
            : M :=
          let Self : Ty.t := Self BorrowType K V NodeType HandleType in
          match τ, α with
          | [], [ self; other ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let other := M.alloc (| other |) in
              M.read (|
                M.match_operator (|
                  self,
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        let γ1_0 :=
                          M.SubPointer.get_struct_record_field (|
                            γ,
                            "alloc::collections::btree::node::Handle",
                            "node"
                          |) in
                        let γ1_1 :=
                          M.SubPointer.get_struct_record_field (|
                            γ,
                            "alloc::collections::btree::node::Handle",
                            "idx"
                          |) in
                        let γ1_2 :=
                          M.SubPointer.get_struct_record_field (|
                            γ,
                            "alloc::collections::btree::node::Handle",
                            "_marker"
                          |) in
                        let node := M.alloc (| γ1_0 |) in
                        let idx := M.alloc (| γ1_1 |) in
                        let _marker := M.alloc (| γ1_2 |) in
                        M.alloc (|
                          LogicalOp.and (|
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "alloc::collections::btree::node::NodeRef")
                                  [ BorrowType; K; V; NodeType ],
                                "eq",
                                []
                              |),
                              [
                                M.read (| node |);
                                M.SubPointer.get_struct_record_field (|
                                  M.read (| other |),
                                  "alloc::collections::btree::node::Handle",
                                  "node"
                                |)
                              ]
                            |),
                            ltac:(M.monadic
                              (BinOp.Pure.eq
                                (M.read (| M.read (| idx |) |))
                                (M.read (|
                                  M.SubPointer.get_struct_record_field (|
                                    M.read (| other |),
                                    "alloc::collections::btree::node::Handle",
                                    "idx"
                                  |)
                                |))))
                          |)
                        |)))
                  ]
                |)
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom Implements :
          forall (BorrowType K V NodeType HandleType : Ty.t),
          M.IsTraitInstance
            "core::cmp::PartialEq"
            (Self BorrowType K V NodeType HandleType)
            (* Trait polymorphic types *) []
            (* Instance *) [ ("eq", InstanceField.Method (eq BorrowType K V NodeType HandleType)) ].
      End Impl_core_cmp_PartialEq_for_alloc_collections_btree_node_Handle_alloc_collections_btree_node_NodeRef_BorrowType_K_V_NodeType_HandleType.
      
      Module Impl_alloc_collections_btree_node_Handle_alloc_collections_btree_node_NodeRef_BorrowType_K_V_NodeType_HandleType.
        Definition Self (BorrowType K V NodeType HandleType : Ty.t) : Ty.t :=
          Ty.apply
            (Ty.path "alloc::collections::btree::node::Handle")
            [
              Ty.apply
                (Ty.path "alloc::collections::btree::node::NodeRef")
                [ BorrowType; K; V; NodeType ];
              HandleType
            ].
        
        (*
            pub fn reborrow(&self) -> Handle<NodeRef<marker::Immut<'_>, K, V, NodeType>, HandleType> {
                // We can't use Handle::new_kv or Handle::new_edge because we don't know our type
                Handle { node: self.node.reborrow(), idx: self.idx, _marker: PhantomData }
            }
        *)
        Definition reborrow
            (BorrowType K V NodeType HandleType : Ty.t)
            (τ : list Ty.t)
            (α : list Value.t)
            : M :=
          let Self : Ty.t := Self BorrowType K V NodeType HandleType in
          match τ, α with
          | [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              Value.StructRecord
                "alloc::collections::btree::node::Handle"
                [
                  ("node",
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "alloc::collections::btree::node::NodeRef")
                          [ BorrowType; K; V; NodeType ],
                        "reborrow",
                        []
                      |),
                      [
                        M.SubPointer.get_struct_record_field (|
                          M.read (| self |),
                          "alloc::collections::btree::node::Handle",
                          "node"
                        |)
                      ]
                    |));
                  ("idx",
                    M.read (|
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "alloc::collections::btree::node::Handle",
                        "idx"
                      |)
                    |));
                  ("_marker", Value.StructTuple "core::marker::PhantomData" [])
                ]))
          | _, _ => M.impossible
          end.
        
        Axiom AssociatedFunction_reborrow :
          forall (BorrowType K V NodeType HandleType : Ty.t),
          M.IsAssociatedFunction
            (Self BorrowType K V NodeType HandleType)
            "reborrow"
            (reborrow BorrowType K V NodeType HandleType).
      End Impl_alloc_collections_btree_node_Handle_alloc_collections_btree_node_NodeRef_BorrowType_K_V_NodeType_HandleType.
      
      Module Impl_alloc_collections_btree_node_Handle_alloc_collections_btree_node_NodeRef_alloc_collections_btree_node_marker_Mut_K_V_NodeType_HandleType.
        Definition Self (K V NodeType HandleType : Ty.t) : Ty.t :=
          Ty.apply
            (Ty.path "alloc::collections::btree::node::Handle")
            [
              Ty.apply
                (Ty.path "alloc::collections::btree::node::NodeRef")
                [ Ty.path "alloc::collections::btree::node::marker::Mut"; K; V; NodeType ];
              HandleType
            ].
        
        (*
            pub unsafe fn reborrow_mut(
                &mut self,
            ) -> Handle<NodeRef<marker::Mut<'_>, K, V, NodeType>, HandleType> {
                // We can't use Handle::new_kv or Handle::new_edge because we don't know our type
                Handle { node: unsafe { self.node.reborrow_mut() }, idx: self.idx, _marker: PhantomData }
            }
        *)
        Definition reborrow_mut
            (K V NodeType HandleType : Ty.t)
            (τ : list Ty.t)
            (α : list Value.t)
            : M :=
          let Self : Ty.t := Self K V NodeType HandleType in
          match τ, α with
          | [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              Value.StructRecord
                "alloc::collections::btree::node::Handle"
                [
                  ("node",
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "alloc::collections::btree::node::NodeRef")
                          [ Ty.path "alloc::collections::btree::node::marker::Mut"; K; V; NodeType
                          ],
                        "reborrow_mut",
                        []
                      |),
                      [
                        M.SubPointer.get_struct_record_field (|
                          M.read (| self |),
                          "alloc::collections::btree::node::Handle",
                          "node"
                        |)
                      ]
                    |));
                  ("idx",
                    M.read (|
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "alloc::collections::btree::node::Handle",
                        "idx"
                      |)
                    |));
                  ("_marker", Value.StructTuple "core::marker::PhantomData" [])
                ]))
          | _, _ => M.impossible
          end.
        
        Axiom AssociatedFunction_reborrow_mut :
          forall (K V NodeType HandleType : Ty.t),
          M.IsAssociatedFunction
            (Self K V NodeType HandleType)
            "reborrow_mut"
            (reborrow_mut K V NodeType HandleType).
        
        (*
            pub fn dormant(&self) -> Handle<NodeRef<marker::DormantMut, K, V, NodeType>, HandleType> {
                Handle { node: self.node.dormant(), idx: self.idx, _marker: PhantomData }
            }
        *)
        Definition dormant
            (K V NodeType HandleType : Ty.t)
            (τ : list Ty.t)
            (α : list Value.t)
            : M :=
          let Self : Ty.t := Self K V NodeType HandleType in
          match τ, α with
          | [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              Value.StructRecord
                "alloc::collections::btree::node::Handle"
                [
                  ("node",
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "alloc::collections::btree::node::NodeRef")
                          [ Ty.path "alloc::collections::btree::node::marker::Mut"; K; V; NodeType
                          ],
                        "dormant",
                        []
                      |),
                      [
                        M.SubPointer.get_struct_record_field (|
                          M.read (| self |),
                          "alloc::collections::btree::node::Handle",
                          "node"
                        |)
                      ]
                    |));
                  ("idx",
                    M.read (|
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "alloc::collections::btree::node::Handle",
                        "idx"
                      |)
                    |));
                  ("_marker", Value.StructTuple "core::marker::PhantomData" [])
                ]))
          | _, _ => M.impossible
          end.
        
        Axiom AssociatedFunction_dormant :
          forall (K V NodeType HandleType : Ty.t),
          M.IsAssociatedFunction
            (Self K V NodeType HandleType)
            "dormant"
            (dormant K V NodeType HandleType).
      End Impl_alloc_collections_btree_node_Handle_alloc_collections_btree_node_NodeRef_alloc_collections_btree_node_marker_Mut_K_V_NodeType_HandleType.
      
      Module Impl_alloc_collections_btree_node_Handle_alloc_collections_btree_node_NodeRef_alloc_collections_btree_node_marker_DormantMut_K_V_NodeType_HandleType.
        Definition Self (K V NodeType HandleType : Ty.t) : Ty.t :=
          Ty.apply
            (Ty.path "alloc::collections::btree::node::Handle")
            [
              Ty.apply
                (Ty.path "alloc::collections::btree::node::NodeRef")
                [ Ty.path "alloc::collections::btree::node::marker::DormantMut"; K; V; NodeType ];
              HandleType
            ].
        
        (*
            pub unsafe fn awaken<'a>(self) -> Handle<NodeRef<marker::Mut<'a>, K, V, NodeType>, HandleType> {
                Handle { node: unsafe { self.node.awaken() }, idx: self.idx, _marker: PhantomData }
            }
        *)
        Definition awaken (K V NodeType HandleType : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self K V NodeType HandleType in
          match τ, α with
          | [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              Value.StructRecord
                "alloc::collections::btree::node::Handle"
                [
                  ("node",
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "alloc::collections::btree::node::NodeRef")
                          [
                            Ty.path "alloc::collections::btree::node::marker::DormantMut";
                            K;
                            V;
                            NodeType
                          ],
                        "awaken",
                        []
                      |),
                      [
                        M.read (|
                          M.SubPointer.get_struct_record_field (|
                            self,
                            "alloc::collections::btree::node::Handle",
                            "node"
                          |)
                        |)
                      ]
                    |));
                  ("idx",
                    M.read (|
                      M.SubPointer.get_struct_record_field (|
                        self,
                        "alloc::collections::btree::node::Handle",
                        "idx"
                      |)
                    |));
                  ("_marker", Value.StructTuple "core::marker::PhantomData" [])
                ]))
          | _, _ => M.impossible
          end.
        
        Axiom AssociatedFunction_awaken :
          forall (K V NodeType HandleType : Ty.t),
          M.IsAssociatedFunction
            (Self K V NodeType HandleType)
            "awaken"
            (awaken K V NodeType HandleType).
      End Impl_alloc_collections_btree_node_Handle_alloc_collections_btree_node_NodeRef_alloc_collections_btree_node_marker_DormantMut_K_V_NodeType_HandleType.
      
      Module Impl_alloc_collections_btree_node_Handle_alloc_collections_btree_node_NodeRef_BorrowType_K_V_NodeType_alloc_collections_btree_node_marker_Edge.
        Definition Self (BorrowType K V NodeType : Ty.t) : Ty.t :=
          Ty.apply
            (Ty.path "alloc::collections::btree::node::Handle")
            [
              Ty.apply
                (Ty.path "alloc::collections::btree::node::NodeRef")
                [ BorrowType; K; V; NodeType ];
              Ty.path "alloc::collections::btree::node::marker::Edge"
            ].
        
        (*
            pub unsafe fn new_edge(node: NodeRef<BorrowType, K, V, NodeType>, idx: usize) -> Self {
                debug_assert!(idx <= node.len());
        
                Handle { node, idx, _marker: PhantomData }
            }
        *)
        Definition new_edge
            (BorrowType K V NodeType : Ty.t)
            (τ : list Ty.t)
            (α : list Value.t)
            : M :=
          let Self : Ty.t := Self BorrowType K V NodeType in
          match τ, α with
          | [], [ node; idx ] =>
            ltac:(M.monadic
              (let node := M.alloc (| node |) in
              let idx := M.alloc (| idx |) in
              M.read (|
                let~ _ :=
                  M.match_operator (|
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ := M.use (M.alloc (| Value.Bool true |)) in
                          let _ :=
                            M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          let~ _ :=
                            M.match_operator (|
                              M.alloc (| Value.Tuple [] |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let γ :=
                                      M.use
                                        (M.alloc (|
                                          UnOp.Pure.not
                                            (BinOp.Pure.le
                                              (M.read (| idx |))
                                              (M.call_closure (|
                                                M.get_associated_function (|
                                                  Ty.apply
                                                    (Ty.path
                                                      "alloc::collections::btree::node::NodeRef")
                                                    [ BorrowType; K; V; NodeType ],
                                                  "len",
                                                  []
                                                |),
                                                [ node ]
                                              |)))
                                        |)) in
                                    let _ :=
                                      M.is_constant_or_break_match (|
                                        M.read (| γ |),
                                        Value.Bool true
                                      |) in
                                    M.alloc (|
                                      M.never_to_any (|
                                        M.call_closure (|
                                          M.get_function (| "core::panicking::panic", [] |),
                                          [
                                            M.read (|
                                              Value.String "assertion failed: idx <= node.len()"
                                            |)
                                          ]
                                        |)
                                      |)
                                    |)));
                                fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                              ]
                            |) in
                          M.alloc (| Value.Tuple [] |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                M.alloc (|
                  Value.StructRecord
                    "alloc::collections::btree::node::Handle"
                    [
                      ("node", M.read (| node |));
                      ("idx", M.read (| idx |));
                      ("_marker", Value.StructTuple "core::marker::PhantomData" [])
                    ]
                |)
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom AssociatedFunction_new_edge :
          forall (BorrowType K V NodeType : Ty.t),
          M.IsAssociatedFunction
            (Self BorrowType K V NodeType)
            "new_edge"
            (new_edge BorrowType K V NodeType).
        
        (*
            pub fn left_kv(self) -> Result<Handle<NodeRef<BorrowType, K, V, NodeType>, marker::KV>, Self> {
                if self.idx > 0 {
                    Ok(unsafe { Handle::new_kv(self.node, self.idx - 1) })
                } else {
                    Err(self)
                }
            }
        *)
        Definition left_kv
            (BorrowType K V NodeType : Ty.t)
            (τ : list Ty.t)
            (α : list Value.t)
            : M :=
          let Self : Ty.t := Self BorrowType K V NodeType in
          match τ, α with
          | [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              M.read (|
                M.match_operator (|
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ :=
                          M.use
                            (M.alloc (|
                              BinOp.Pure.gt
                                (M.read (|
                                  M.SubPointer.get_struct_record_field (|
                                    self,
                                    "alloc::collections::btree::node::Handle",
                                    "idx"
                                  |)
                                |))
                                (Value.Integer 0)
                            |)) in
                        let _ :=
                          M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        M.alloc (|
                          Value.StructTuple
                            "core::result::Result::Ok"
                            [
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "alloc::collections::btree::node::Handle")
                                    [
                                      Ty.apply
                                        (Ty.path "alloc::collections::btree::node::NodeRef")
                                        [ BorrowType; K; V; NodeType ];
                                      Ty.path "alloc::collections::btree::node::marker::KV"
                                    ],
                                  "new_kv",
                                  []
                                |),
                                [
                                  M.read (|
                                    M.SubPointer.get_struct_record_field (|
                                      self,
                                      "alloc::collections::btree::node::Handle",
                                      "node"
                                    |)
                                  |);
                                  BinOp.Wrap.sub
                                    Integer.Usize
                                    (M.read (|
                                      M.SubPointer.get_struct_record_field (|
                                        self,
                                        "alloc::collections::btree::node::Handle",
                                        "idx"
                                      |)
                                    |))
                                    (Value.Integer 1)
                                ]
                              |)
                            ]
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (M.alloc (|
                          Value.StructTuple "core::result::Result::Err" [ M.read (| self |) ]
                        |)))
                  ]
                |)
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom AssociatedFunction_left_kv :
          forall (BorrowType K V NodeType : Ty.t),
          M.IsAssociatedFunction
            (Self BorrowType K V NodeType)
            "left_kv"
            (left_kv BorrowType K V NodeType).
        
        (*
            pub fn right_kv(self) -> Result<Handle<NodeRef<BorrowType, K, V, NodeType>, marker::KV>, Self> {
                if self.idx < self.node.len() {
                    Ok(unsafe { Handle::new_kv(self.node, self.idx) })
                } else {
                    Err(self)
                }
            }
        *)
        Definition right_kv
            (BorrowType K V NodeType : Ty.t)
            (τ : list Ty.t)
            (α : list Value.t)
            : M :=
          let Self : Ty.t := Self BorrowType K V NodeType in
          match τ, α with
          | [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              M.read (|
                M.match_operator (|
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ :=
                          M.use
                            (M.alloc (|
                              BinOp.Pure.lt
                                (M.read (|
                                  M.SubPointer.get_struct_record_field (|
                                    self,
                                    "alloc::collections::btree::node::Handle",
                                    "idx"
                                  |)
                                |))
                                (M.call_closure (|
                                  M.get_associated_function (|
                                    Ty.apply
                                      (Ty.path "alloc::collections::btree::node::NodeRef")
                                      [ BorrowType; K; V; NodeType ],
                                    "len",
                                    []
                                  |),
                                  [
                                    M.SubPointer.get_struct_record_field (|
                                      self,
                                      "alloc::collections::btree::node::Handle",
                                      "node"
                                    |)
                                  ]
                                |))
                            |)) in
                        let _ :=
                          M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        M.alloc (|
                          Value.StructTuple
                            "core::result::Result::Ok"
                            [
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "alloc::collections::btree::node::Handle")
                                    [
                                      Ty.apply
                                        (Ty.path "alloc::collections::btree::node::NodeRef")
                                        [ BorrowType; K; V; NodeType ];
                                      Ty.path "alloc::collections::btree::node::marker::KV"
                                    ],
                                  "new_kv",
                                  []
                                |),
                                [
                                  M.read (|
                                    M.SubPointer.get_struct_record_field (|
                                      self,
                                      "alloc::collections::btree::node::Handle",
                                      "node"
                                    |)
                                  |);
                                  M.read (|
                                    M.SubPointer.get_struct_record_field (|
                                      self,
                                      "alloc::collections::btree::node::Handle",
                                      "idx"
                                    |)
                                  |)
                                ]
                              |)
                            ]
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (M.alloc (|
                          Value.StructTuple "core::result::Result::Err" [ M.read (| self |) ]
                        |)))
                  ]
                |)
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom AssociatedFunction_right_kv :
          forall (BorrowType K V NodeType : Ty.t),
          M.IsAssociatedFunction
            (Self BorrowType K V NodeType)
            "right_kv"
            (right_kv BorrowType K V NodeType).
      End Impl_alloc_collections_btree_node_Handle_alloc_collections_btree_node_NodeRef_BorrowType_K_V_NodeType_alloc_collections_btree_node_marker_Edge.
      
      (*
      Enum LeftOrRight
      {
        ty_params := [ "T" ];
        variants :=
          [
            {
              name := "Left";
              item := StructTuple [ T ];
              discriminant := None;
            };
            {
              name := "Right";
              item := StructTuple [ T ];
              discriminant := None;
            }
          ];
      }
      *)
      
      (*
      fn splitpoint(edge_idx: usize) -> (usize, LeftOrRight<usize>) {
          debug_assert!(edge_idx <= CAPACITY);
          // Rust issue #74834 tries to explain these symmetric rules.
          match edge_idx {
              0..EDGE_IDX_LEFT_OF_CENTER => (KV_IDX_CENTER - 1, LeftOrRight::Left(edge_idx)),
              EDGE_IDX_LEFT_OF_CENTER => (KV_IDX_CENTER, LeftOrRight::Left(edge_idx)),
              EDGE_IDX_RIGHT_OF_CENTER => (KV_IDX_CENTER, LeftOrRight::Right(0)),
              _ => (KV_IDX_CENTER + 1, LeftOrRight::Right(edge_idx - (KV_IDX_CENTER + 1 + 1))),
          }
      }
      *)
      Definition splitpoint (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ edge_idx ] =>
          ltac:(M.monadic
            (let edge_idx := M.alloc (| edge_idx |) in
            M.read (|
              let~ _ :=
                M.match_operator (|
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.use (M.alloc (| Value.Bool true |)) in
                        let _ :=
                          M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        let~ _ :=
                          M.match_operator (|
                            M.alloc (| Value.Tuple [] |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ :=
                                    M.use
                                      (M.alloc (|
                                        UnOp.Pure.not
                                          (BinOp.Pure.le
                                            (M.read (| edge_idx |))
                                            (M.read (|
                                              M.get_constant (|
                                                "alloc::collections::btree::node::CAPACITY"
                                              |)
                                            |)))
                                      |)) in
                                  let _ :=
                                    M.is_constant_or_break_match (|
                                      M.read (| γ |),
                                      Value.Bool true
                                    |) in
                                  M.alloc (|
                                    M.never_to_any (|
                                      M.call_closure (|
                                        M.get_function (| "core::panicking::panic", [] |),
                                        [
                                          M.read (|
                                            Value.String "assertion failed: edge_idx <= CAPACITY"
                                          |)
                                        ]
                                      |)
                                    |)
                                  |)));
                              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                            ]
                          |) in
                        M.alloc (| Value.Tuple [] |)));
                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                  ]
                |) in
              M.match_operator (|
                edge_idx,
                [
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (|
                        Value.Tuple
                          [
                            BinOp.Wrap.sub
                              Integer.Usize
                              (M.read (|
                                M.get_constant (|
                                  "alloc::collections::btree::node::KV_IDX_CENTER"
                                |)
                              |))
                              (Value.Integer 1);
                            Value.StructTuple
                              "alloc::collections::btree::node::LeftOrRight::Left"
                              [ M.read (| edge_idx |) ]
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let _ :=
                        M.is_constant_or_break_match (| M.read (| γ |), Value.Integer 5 |) in
                      M.alloc (|
                        Value.Tuple
                          [
                            M.read (|
                              M.get_constant (| "alloc::collections::btree::node::KV_IDX_CENTER" |)
                            |);
                            Value.StructTuple
                              "alloc::collections::btree::node::LeftOrRight::Left"
                              [ M.read (| edge_idx |) ]
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let _ :=
                        M.is_constant_or_break_match (| M.read (| γ |), Value.Integer 6 |) in
                      M.alloc (|
                        Value.Tuple
                          [
                            M.read (|
                              M.get_constant (| "alloc::collections::btree::node::KV_IDX_CENTER" |)
                            |);
                            Value.StructTuple
                              "alloc::collections::btree::node::LeftOrRight::Right"
                              [ Value.Integer 0 ]
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (|
                        Value.Tuple
                          [
                            BinOp.Wrap.add
                              Integer.Usize
                              (M.read (|
                                M.get_constant (|
                                  "alloc::collections::btree::node::KV_IDX_CENTER"
                                |)
                              |))
                              (Value.Integer 1);
                            Value.StructTuple
                              "alloc::collections::btree::node::LeftOrRight::Right"
                              [
                                BinOp.Wrap.sub
                                  Integer.Usize
                                  (M.read (| edge_idx |))
                                  (BinOp.Wrap.add
                                    Integer.Usize
                                    (BinOp.Wrap.add
                                      Integer.Usize
                                      (M.read (|
                                        M.get_constant (|
                                          "alloc::collections::btree::node::KV_IDX_CENTER"
                                        |)
                                      |))
                                      (Value.Integer 1))
                                    (Value.Integer 1))
                              ]
                          ]
                      |)))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Function_splitpoint :
        M.IsFunction "alloc::collections::btree::node::splitpoint" splitpoint.
      
      Module Impl_alloc_collections_btree_node_Handle_alloc_collections_btree_node_NodeRef_alloc_collections_btree_node_marker_Mut_K_V_alloc_collections_btree_node_marker_Leaf_alloc_collections_btree_node_marker_Edge.
        Definition Self (K V : Ty.t) : Ty.t :=
          Ty.apply
            (Ty.path "alloc::collections::btree::node::Handle")
            [
              Ty.apply
                (Ty.path "alloc::collections::btree::node::NodeRef")
                [
                  Ty.path "alloc::collections::btree::node::marker::Mut";
                  K;
                  V;
                  Ty.path "alloc::collections::btree::node::marker::Leaf"
                ];
              Ty.path "alloc::collections::btree::node::marker::Edge"
            ].
        
        (*
            unsafe fn insert_fit(
                mut self,
                key: K,
                val: V,
            ) -> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::KV> {
                debug_assert!(self.node.len() < CAPACITY);
                let new_len = self.node.len() + 1;
        
                unsafe {
                    slice_insert(self.node.key_area_mut(..new_len), self.idx, key);
                    slice_insert(self.node.val_area_mut(..new_len), self.idx, val);
                    *self.node.len_mut() = new_len as u16;
        
                    Handle::new_kv(self.node, self.idx)
                }
            }
        *)
        Definition insert_fit (K V : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self K V in
          match τ, α with
          | [], [ self; key; val ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let key := M.alloc (| key |) in
              let val := M.alloc (| val |) in
              M.read (|
                let~ _ :=
                  M.match_operator (|
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ := M.use (M.alloc (| Value.Bool true |)) in
                          let _ :=
                            M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          let~ _ :=
                            M.match_operator (|
                              M.alloc (| Value.Tuple [] |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let γ :=
                                      M.use
                                        (M.alloc (|
                                          UnOp.Pure.not
                                            (BinOp.Pure.lt
                                              (M.call_closure (|
                                                M.get_associated_function (|
                                                  Ty.apply
                                                    (Ty.path
                                                      "alloc::collections::btree::node::NodeRef")
                                                    [
                                                      Ty.path
                                                        "alloc::collections::btree::node::marker::Mut";
                                                      K;
                                                      V;
                                                      Ty.path
                                                        "alloc::collections::btree::node::marker::Leaf"
                                                    ],
                                                  "len",
                                                  []
                                                |),
                                                [
                                                  M.SubPointer.get_struct_record_field (|
                                                    self,
                                                    "alloc::collections::btree::node::Handle",
                                                    "node"
                                                  |)
                                                ]
                                              |))
                                              (M.read (|
                                                M.get_constant (|
                                                  "alloc::collections::btree::node::CAPACITY"
                                                |)
                                              |)))
                                        |)) in
                                    let _ :=
                                      M.is_constant_or_break_match (|
                                        M.read (| γ |),
                                        Value.Bool true
                                      |) in
                                    M.alloc (|
                                      M.never_to_any (|
                                        M.call_closure (|
                                          M.get_function (| "core::panicking::panic", [] |),
                                          [
                                            M.read (|
                                              Value.String
                                                "assertion failed: self.node.len() < CAPACITY"
                                            |)
                                          ]
                                        |)
                                      |)
                                    |)));
                                fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                              ]
                            |) in
                          M.alloc (| Value.Tuple [] |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                let~ new_len :=
                  M.alloc (|
                    BinOp.Wrap.add
                      Integer.Usize
                      (M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply
                            (Ty.path "alloc::collections::btree::node::NodeRef")
                            [
                              Ty.path "alloc::collections::btree::node::marker::Mut";
                              K;
                              V;
                              Ty.path "alloc::collections::btree::node::marker::Leaf"
                            ],
                          "len",
                          []
                        |),
                        [
                          M.SubPointer.get_struct_record_field (|
                            self,
                            "alloc::collections::btree::node::Handle",
                            "node"
                          |)
                        ]
                      |))
                      (Value.Integer 1)
                  |) in
                let~ _ :=
                  M.alloc (|
                    M.call_closure (|
                      M.get_function (| "alloc::collections::btree::node::slice_insert", [ K ] |),
                      [
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.apply
                              (Ty.path "alloc::collections::btree::node::NodeRef")
                              [
                                Ty.path "alloc::collections::btree::node::marker::Mut";
                                K;
                                V;
                                Ty.path "alloc::collections::btree::node::marker::Leaf"
                              ],
                            "key_area_mut",
                            [
                              Ty.apply (Ty.path "core::ops::range::RangeTo") [ Ty.path "usize" ];
                              Ty.apply
                                (Ty.path "slice")
                                [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ K ] ]
                            ]
                          |),
                          [
                            M.SubPointer.get_struct_record_field (|
                              self,
                              "alloc::collections::btree::node::Handle",
                              "node"
                            |);
                            Value.StructRecord
                              "core::ops::range::RangeTo"
                              [ ("end_", M.read (| new_len |)) ]
                          ]
                        |);
                        M.read (|
                          M.SubPointer.get_struct_record_field (|
                            self,
                            "alloc::collections::btree::node::Handle",
                            "idx"
                          |)
                        |);
                        M.read (| key |)
                      ]
                    |)
                  |) in
                let~ _ :=
                  M.alloc (|
                    M.call_closure (|
                      M.get_function (| "alloc::collections::btree::node::slice_insert", [ V ] |),
                      [
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.apply
                              (Ty.path "alloc::collections::btree::node::NodeRef")
                              [
                                Ty.path "alloc::collections::btree::node::marker::Mut";
                                K;
                                V;
                                Ty.path "alloc::collections::btree::node::marker::Leaf"
                              ],
                            "val_area_mut",
                            [
                              Ty.apply (Ty.path "core::ops::range::RangeTo") [ Ty.path "usize" ];
                              Ty.apply
                                (Ty.path "slice")
                                [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ V ] ]
                            ]
                          |),
                          [
                            M.SubPointer.get_struct_record_field (|
                              self,
                              "alloc::collections::btree::node::Handle",
                              "node"
                            |);
                            Value.StructRecord
                              "core::ops::range::RangeTo"
                              [ ("end_", M.read (| new_len |)) ]
                          ]
                        |);
                        M.read (|
                          M.SubPointer.get_struct_record_field (|
                            self,
                            "alloc::collections::btree::node::Handle",
                            "idx"
                          |)
                        |);
                        M.read (| val |)
                      ]
                    |)
                  |) in
                let~ _ :=
                  M.write (|
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "alloc::collections::btree::node::NodeRef")
                          [
                            Ty.path "alloc::collections::btree::node::marker::Mut";
                            K;
                            V;
                            Ty.path "alloc::collections::btree::node::marker::Leaf"
                          ],
                        "len_mut",
                        []
                      |),
                      [
                        M.SubPointer.get_struct_record_field (|
                          self,
                          "alloc::collections::btree::node::Handle",
                          "node"
                        |)
                      ]
                    |),
                    M.rust_cast (M.read (| new_len |))
                  |) in
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "alloc::collections::btree::node::Handle")
                        [
                          Ty.apply
                            (Ty.path "alloc::collections::btree::node::NodeRef")
                            [
                              Ty.path "alloc::collections::btree::node::marker::Mut";
                              K;
                              V;
                              Ty.path "alloc::collections::btree::node::marker::Leaf"
                            ];
                          Ty.path "alloc::collections::btree::node::marker::KV"
                        ],
                      "new_kv",
                      []
                    |),
                    [
                      M.read (|
                        M.SubPointer.get_struct_record_field (|
                          self,
                          "alloc::collections::btree::node::Handle",
                          "node"
                        |)
                      |);
                      M.read (|
                        M.SubPointer.get_struct_record_field (|
                          self,
                          "alloc::collections::btree::node::Handle",
                          "idx"
                        |)
                      |)
                    ]
                  |)
                |)
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom AssociatedFunction_insert_fit :
          forall (K V : Ty.t),
          M.IsAssociatedFunction (Self K V) "insert_fit" (insert_fit K V).
        (*
            fn insert<A: Allocator + Clone>(
                self,
                key: K,
                val: V,
                alloc: A,
            ) -> (
                Option<SplitResult<'a, K, V, marker::Leaf>>,
                Handle<NodeRef<marker::DormantMut, K, V, marker::Leaf>, marker::KV>,
            ) {
                if self.node.len() < CAPACITY {
                    // SAFETY: There is enough space in the node for insertion.
                    let handle = unsafe { self.insert_fit(key, val) };
                    (None, handle.dormant())
                } else {
                    let (middle_kv_idx, insertion) = splitpoint(self.idx);
                    let middle = unsafe { Handle::new_kv(self.node, middle_kv_idx) };
                    let mut result = middle.split(alloc);
                    let insertion_edge = match insertion {
                        LeftOrRight::Left(insert_idx) => unsafe {
                            Handle::new_edge(result.left.reborrow_mut(), insert_idx)
                        },
                        LeftOrRight::Right(insert_idx) => unsafe {
                            Handle::new_edge(result.right.borrow_mut(), insert_idx)
                        },
                    };
                    // SAFETY: We just split the node, so there is enough space for
                    // insertion.
                    let handle = unsafe { insertion_edge.insert_fit(key, val).dormant() };
                    (Some(result), handle)
                }
            }
        *)
        Definition insert (K V : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self K V in
          match τ, α with
          | [ A ], [ self; key; val; alloc ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let key := M.alloc (| key |) in
              let val := M.alloc (| val |) in
              let alloc := M.alloc (| alloc |) in
              M.read (|
                M.match_operator (|
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ :=
                          M.use
                            (M.alloc (|
                              BinOp.Pure.lt
                                (M.call_closure (|
                                  M.get_associated_function (|
                                    Ty.apply
                                      (Ty.path "alloc::collections::btree::node::NodeRef")
                                      [
                                        Ty.path "alloc::collections::btree::node::marker::Mut";
                                        K;
                                        V;
                                        Ty.path "alloc::collections::btree::node::marker::Leaf"
                                      ],
                                    "len",
                                    []
                                  |),
                                  [
                                    M.SubPointer.get_struct_record_field (|
                                      self,
                                      "alloc::collections::btree::node::Handle",
                                      "node"
                                    |)
                                  ]
                                |))
                                (M.read (|
                                  M.get_constant (| "alloc::collections::btree::node::CAPACITY" |)
                                |))
                            |)) in
                        let _ :=
                          M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        let~ handle :=
                          M.alloc (|
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "alloc::collections::btree::node::Handle")
                                  [
                                    Ty.apply
                                      (Ty.path "alloc::collections::btree::node::NodeRef")
                                      [
                                        Ty.path "alloc::collections::btree::node::marker::Mut";
                                        K;
                                        V;
                                        Ty.path "alloc::collections::btree::node::marker::Leaf"
                                      ];
                                    Ty.path "alloc::collections::btree::node::marker::Edge"
                                  ],
                                "insert_fit",
                                []
                              |),
                              [ M.read (| self |); M.read (| key |); M.read (| val |) ]
                            |)
                          |) in
                        M.alloc (|
                          Value.Tuple
                            [
                              Value.StructTuple "core::option::Option::None" [];
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "alloc::collections::btree::node::Handle")
                                    [
                                      Ty.apply
                                        (Ty.path "alloc::collections::btree::node::NodeRef")
                                        [
                                          Ty.path "alloc::collections::btree::node::marker::Mut";
                                          K;
                                          V;
                                          Ty.path "alloc::collections::btree::node::marker::Leaf"
                                        ];
                                      Ty.path "alloc::collections::btree::node::marker::KV"
                                    ],
                                  "dormant",
                                  []
                                |),
                                [ handle ]
                              |)
                            ]
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (M.match_operator (|
                          M.alloc (|
                            M.call_closure (|
                              M.get_function (|
                                "alloc::collections::btree::node::splitpoint",
                                []
                              |),
                              [
                                M.read (|
                                  M.SubPointer.get_struct_record_field (|
                                    self,
                                    "alloc::collections::btree::node::Handle",
                                    "idx"
                                  |)
                                |)
                              ]
                            |)
                          |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                                let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                let middle_kv_idx := M.copy (| γ0_0 |) in
                                let insertion := M.copy (| γ0_1 |) in
                                let~ middle :=
                                  M.alloc (|
                                    M.call_closure (|
                                      M.get_associated_function (|
                                        Ty.apply
                                          (Ty.path "alloc::collections::btree::node::Handle")
                                          [
                                            Ty.apply
                                              (Ty.path "alloc::collections::btree::node::NodeRef")
                                              [
                                                Ty.path
                                                  "alloc::collections::btree::node::marker::Mut";
                                                K;
                                                V;
                                                Ty.path
                                                  "alloc::collections::btree::node::marker::Leaf"
                                              ];
                                            Ty.path "alloc::collections::btree::node::marker::KV"
                                          ],
                                        "new_kv",
                                        []
                                      |),
                                      [
                                        M.read (|
                                          M.SubPointer.get_struct_record_field (|
                                            self,
                                            "alloc::collections::btree::node::Handle",
                                            "node"
                                          |)
                                        |);
                                        M.read (| middle_kv_idx |)
                                      ]
                                    |)
                                  |) in
                                let~ result :=
                                  M.alloc (|
                                    M.call_closure (|
                                      M.get_associated_function (|
                                        Ty.apply
                                          (Ty.path "alloc::collections::btree::node::Handle")
                                          [
                                            Ty.apply
                                              (Ty.path "alloc::collections::btree::node::NodeRef")
                                              [
                                                Ty.path
                                                  "alloc::collections::btree::node::marker::Mut";
                                                K;
                                                V;
                                                Ty.path
                                                  "alloc::collections::btree::node::marker::Leaf"
                                              ];
                                            Ty.path "alloc::collections::btree::node::marker::KV"
                                          ],
                                        "split",
                                        [ A ]
                                      |),
                                      [ M.read (| middle |); M.read (| alloc |) ]
                                    |)
                                  |) in
                                let~ insertion_edge :=
                                  M.copy (|
                                    M.match_operator (|
                                      insertion,
                                      [
                                        fun γ =>
                                          ltac:(M.monadic
                                            (let γ0_0 :=
                                              M.SubPointer.get_struct_tuple_field (|
                                                γ,
                                                "alloc::collections::btree::node::LeftOrRight::Left",
                                                0
                                              |) in
                                            let insert_idx := M.copy (| γ0_0 |) in
                                            M.alloc (|
                                              M.call_closure (|
                                                M.get_associated_function (|
                                                  Ty.apply
                                                    (Ty.path
                                                      "alloc::collections::btree::node::Handle")
                                                    [
                                                      Ty.apply
                                                        (Ty.path
                                                          "alloc::collections::btree::node::NodeRef")
                                                        [
                                                          Ty.path
                                                            "alloc::collections::btree::node::marker::Mut";
                                                          K;
                                                          V;
                                                          Ty.path
                                                            "alloc::collections::btree::node::marker::Leaf"
                                                        ];
                                                      Ty.path
                                                        "alloc::collections::btree::node::marker::Edge"
                                                    ],
                                                  "new_edge",
                                                  []
                                                |),
                                                [
                                                  M.call_closure (|
                                                    M.get_associated_function (|
                                                      Ty.apply
                                                        (Ty.path
                                                          "alloc::collections::btree::node::NodeRef")
                                                        [
                                                          Ty.path
                                                            "alloc::collections::btree::node::marker::Mut";
                                                          K;
                                                          V;
                                                          Ty.path
                                                            "alloc::collections::btree::node::marker::Leaf"
                                                        ],
                                                      "reborrow_mut",
                                                      []
                                                    |),
                                                    [
                                                      M.SubPointer.get_struct_record_field (|
                                                        result,
                                                        "alloc::collections::btree::node::SplitResult",
                                                        "left"
                                                      |)
                                                    ]
                                                  |);
                                                  M.read (| insert_idx |)
                                                ]
                                              |)
                                            |)));
                                        fun γ =>
                                          ltac:(M.monadic
                                            (let γ0_0 :=
                                              M.SubPointer.get_struct_tuple_field (|
                                                γ,
                                                "alloc::collections::btree::node::LeftOrRight::Right",
                                                0
                                              |) in
                                            let insert_idx := M.copy (| γ0_0 |) in
                                            M.alloc (|
                                              M.call_closure (|
                                                M.get_associated_function (|
                                                  Ty.apply
                                                    (Ty.path
                                                      "alloc::collections::btree::node::Handle")
                                                    [
                                                      Ty.apply
                                                        (Ty.path
                                                          "alloc::collections::btree::node::NodeRef")
                                                        [
                                                          Ty.path
                                                            "alloc::collections::btree::node::marker::Mut";
                                                          K;
                                                          V;
                                                          Ty.path
                                                            "alloc::collections::btree::node::marker::Leaf"
                                                        ];
                                                      Ty.path
                                                        "alloc::collections::btree::node::marker::Edge"
                                                    ],
                                                  "new_edge",
                                                  []
                                                |),
                                                [
                                                  M.call_closure (|
                                                    M.get_associated_function (|
                                                      Ty.apply
                                                        (Ty.path
                                                          "alloc::collections::btree::node::NodeRef")
                                                        [
                                                          Ty.path
                                                            "alloc::collections::btree::node::marker::Owned";
                                                          K;
                                                          V;
                                                          Ty.path
                                                            "alloc::collections::btree::node::marker::Leaf"
                                                        ],
                                                      "borrow_mut",
                                                      []
                                                    |),
                                                    [
                                                      M.SubPointer.get_struct_record_field (|
                                                        result,
                                                        "alloc::collections::btree::node::SplitResult",
                                                        "right"
                                                      |)
                                                    ]
                                                  |);
                                                  M.read (| insert_idx |)
                                                ]
                                              |)
                                            |)))
                                      ]
                                    |)
                                  |) in
                                let~ handle :=
                                  M.alloc (|
                                    M.call_closure (|
                                      M.get_associated_function (|
                                        Ty.apply
                                          (Ty.path "alloc::collections::btree::node::Handle")
                                          [
                                            Ty.apply
                                              (Ty.path "alloc::collections::btree::node::NodeRef")
                                              [
                                                Ty.path
                                                  "alloc::collections::btree::node::marker::Mut";
                                                K;
                                                V;
                                                Ty.path
                                                  "alloc::collections::btree::node::marker::Leaf"
                                              ];
                                            Ty.path "alloc::collections::btree::node::marker::KV"
                                          ],
                                        "dormant",
                                        []
                                      |),
                                      [
                                        M.alloc (|
                                          M.call_closure (|
                                            M.get_associated_function (|
                                              Ty.apply
                                                (Ty.path "alloc::collections::btree::node::Handle")
                                                [
                                                  Ty.apply
                                                    (Ty.path
                                                      "alloc::collections::btree::node::NodeRef")
                                                    [
                                                      Ty.path
                                                        "alloc::collections::btree::node::marker::Mut";
                                                      K;
                                                      V;
                                                      Ty.path
                                                        "alloc::collections::btree::node::marker::Leaf"
                                                    ];
                                                  Ty.path
                                                    "alloc::collections::btree::node::marker::Edge"
                                                ],
                                              "insert_fit",
                                              []
                                            |),
                                            [
                                              M.read (| insertion_edge |);
                                              M.read (| key |);
                                              M.read (| val |)
                                            ]
                                          |)
                                        |)
                                      ]
                                    |)
                                  |) in
                                M.alloc (|
                                  Value.Tuple
                                    [
                                      Value.StructTuple
                                        "core::option::Option::Some"
                                        [ M.read (| result |) ];
                                      M.read (| handle |)
                                    ]
                                |)))
                          ]
                        |)))
                  ]
                |)
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom AssociatedFunction_insert :
          forall (K V : Ty.t),
          M.IsAssociatedFunction (Self K V) "insert" (insert K V).
        (*
            pub fn insert_recursing<A: Allocator + Clone>(
                self,
                key: K,
                value: V,
                alloc: A,
                split_root: impl FnOnce(SplitResult<'a, K, V, marker::LeafOrInternal>),
            ) -> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::KV> {
                let (mut split, handle) = match self.insert(key, value, alloc.clone()) {
                    // SAFETY: we have finished splitting and can now re-awaken the
                    // handle to the inserted element.
                    (None, handle) => return unsafe { handle.awaken() },
                    (Some(split), handle) => (split.forget_node_type(), handle),
                };
        
                loop {
                    split = match split.left.ascend() {
                        Ok(parent) => {
                            match parent.insert(split.kv.0, split.kv.1, split.right, alloc.clone()) {
                                // SAFETY: we have finished splitting and can now re-awaken the
                                // handle to the inserted element.
                                None => return unsafe { handle.awaken() },
                                Some(split) => split.forget_node_type(),
                            }
                        }
                        Err(root) => {
                            split_root(SplitResult { left: root, ..split });
                            // SAFETY: we have finished splitting and can now re-awaken the
                            // handle to the inserted element.
                            return unsafe { handle.awaken() };
                        }
                    };
                }
            }
        *)
        Definition insert_recursing (K V : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self K V in
          match τ, α with
          | [ A; impl_FnOnce_SplitResult_'a__K__V__marker_LeafOrInternal__ ],
              [ self; key; value; alloc; split_root ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let key := M.alloc (| key |) in
              let value := M.alloc (| value |) in
              let alloc := M.alloc (| alloc |) in
              let split_root := M.alloc (| split_root |) in
              M.catch_return (|
                ltac:(M.monadic
                  (M.read (|
                    M.match_operator (|
                      M.match_operator (|
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply
                                (Ty.path "alloc::collections::btree::node::Handle")
                                [
                                  Ty.apply
                                    (Ty.path "alloc::collections::btree::node::NodeRef")
                                    [
                                      Ty.path "alloc::collections::btree::node::marker::Mut";
                                      K;
                                      V;
                                      Ty.path "alloc::collections::btree::node::marker::Leaf"
                                    ];
                                  Ty.path "alloc::collections::btree::node::marker::Edge"
                                ],
                              "insert",
                              [ A ]
                            |),
                            [
                              M.read (| self |);
                              M.read (| key |);
                              M.read (| value |);
                              M.call_closure (|
                                M.get_trait_method (| "core::clone::Clone", A, [], "clone", [] |),
                                [ alloc ]
                              |)
                            ]
                          |)
                        |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                              let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                              let _ := M.is_struct_tuple (| γ0_0, "core::option::Option::None" |) in
                              let handle := M.copy (| γ0_1 |) in
                              M.alloc (|
                                M.never_to_any (|
                                  M.read (|
                                    M.return_ (|
                                      M.call_closure (|
                                        M.get_associated_function (|
                                          Ty.apply
                                            (Ty.path "alloc::collections::btree::node::Handle")
                                            [
                                              Ty.apply
                                                (Ty.path "alloc::collections::btree::node::NodeRef")
                                                [
                                                  Ty.path
                                                    "alloc::collections::btree::node::marker::DormantMut";
                                                  K;
                                                  V;
                                                  Ty.path
                                                    "alloc::collections::btree::node::marker::Leaf"
                                                ];
                                              Ty.path "alloc::collections::btree::node::marker::KV"
                                            ],
                                          "awaken",
                                          []
                                        |),
                                        [ M.read (| handle |) ]
                                      |)
                                    |)
                                  |)
                                |)
                              |)));
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                              let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                              let γ1_0 :=
                                M.SubPointer.get_struct_tuple_field (|
                                  γ0_0,
                                  "core::option::Option::Some",
                                  0
                                |) in
                              let split := M.copy (| γ1_0 |) in
                              let handle := M.copy (| γ0_1 |) in
                              M.alloc (|
                                Value.Tuple
                                  [
                                    M.call_closure (|
                                      M.get_associated_function (|
                                        Ty.apply
                                          (Ty.path "alloc::collections::btree::node::SplitResult")
                                          [
                                            K;
                                            V;
                                            Ty.path "alloc::collections::btree::node::marker::Leaf"
                                          ],
                                        "forget_node_type",
                                        []
                                      |),
                                      [ M.read (| split |) ]
                                    |);
                                    M.read (| handle |)
                                  ]
                              |)))
                        ]
                      |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                            let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                            let split := M.copy (| γ0_0 |) in
                            let handle := M.copy (| γ0_1 |) in
                            M.alloc (|
                              M.never_to_any (|
                                M.read (|
                                  M.loop (|
                                    ltac:(M.monadic
                                      (let~ _ :=
                                        M.write (|
                                          split,
                                          M.read (|
                                            M.match_operator (|
                                              M.alloc (|
                                                M.call_closure (|
                                                  M.get_associated_function (|
                                                    Ty.apply
                                                      (Ty.path
                                                        "alloc::collections::btree::node::NodeRef")
                                                      [
                                                        Ty.path
                                                          "alloc::collections::btree::node::marker::Mut";
                                                        K;
                                                        V;
                                                        Ty.path
                                                          "alloc::collections::btree::node::marker::LeafOrInternal"
                                                      ],
                                                    "ascend",
                                                    []
                                                  |),
                                                  [
                                                    M.read (|
                                                      M.SubPointer.get_struct_record_field (|
                                                        split,
                                                        "alloc::collections::btree::node::SplitResult",
                                                        "left"
                                                      |)
                                                    |)
                                                  ]
                                                |)
                                              |),
                                              [
                                                fun γ =>
                                                  ltac:(M.monadic
                                                    (let γ0_0 :=
                                                      M.SubPointer.get_struct_tuple_field (|
                                                        γ,
                                                        "core::result::Result::Ok",
                                                        0
                                                      |) in
                                                    let parent := M.copy (| γ0_0 |) in
                                                    M.match_operator (|
                                                      M.alloc (|
                                                        M.call_closure (|
                                                          M.get_associated_function (|
                                                            Ty.apply
                                                              (Ty.path
                                                                "alloc::collections::btree::node::Handle")
                                                              [
                                                                Ty.apply
                                                                  (Ty.path
                                                                    "alloc::collections::btree::node::NodeRef")
                                                                  [
                                                                    Ty.path
                                                                      "alloc::collections::btree::node::marker::Mut";
                                                                    K;
                                                                    V;
                                                                    Ty.path
                                                                      "alloc::collections::btree::node::marker::Internal"
                                                                  ];
                                                                Ty.path
                                                                  "alloc::collections::btree::node::marker::Edge"
                                                              ],
                                                            "insert",
                                                            [ A ]
                                                          |),
                                                          [
                                                            M.read (| parent |);
                                                            M.read (|
                                                              M.SubPointer.get_tuple_field (|
                                                                M.SubPointer.get_struct_record_field (|
                                                                  split,
                                                                  "alloc::collections::btree::node::SplitResult",
                                                                  "kv"
                                                                |),
                                                                0
                                                              |)
                                                            |);
                                                            M.read (|
                                                              M.SubPointer.get_tuple_field (|
                                                                M.SubPointer.get_struct_record_field (|
                                                                  split,
                                                                  "alloc::collections::btree::node::SplitResult",
                                                                  "kv"
                                                                |),
                                                                1
                                                              |)
                                                            |);
                                                            M.read (|
                                                              M.SubPointer.get_struct_record_field (|
                                                                split,
                                                                "alloc::collections::btree::node::SplitResult",
                                                                "right"
                                                              |)
                                                            |);
                                                            M.call_closure (|
                                                              M.get_trait_method (|
                                                                "core::clone::Clone",
                                                                A,
                                                                [],
                                                                "clone",
                                                                []
                                                              |),
                                                              [ alloc ]
                                                            |)
                                                          ]
                                                        |)
                                                      |),
                                                      [
                                                        fun γ =>
                                                          ltac:(M.monadic
                                                            (let _ :=
                                                              M.is_struct_tuple (|
                                                                γ,
                                                                "core::option::Option::None"
                                                              |) in
                                                            M.alloc (|
                                                              M.never_to_any (|
                                                                M.read (|
                                                                  M.return_ (|
                                                                    M.call_closure (|
                                                                      M.get_associated_function (|
                                                                        Ty.apply
                                                                          (Ty.path
                                                                            "alloc::collections::btree::node::Handle")
                                                                          [
                                                                            Ty.apply
                                                                              (Ty.path
                                                                                "alloc::collections::btree::node::NodeRef")
                                                                              [
                                                                                Ty.path
                                                                                  "alloc::collections::btree::node::marker::DormantMut";
                                                                                K;
                                                                                V;
                                                                                Ty.path
                                                                                  "alloc::collections::btree::node::marker::Leaf"
                                                                              ];
                                                                            Ty.path
                                                                              "alloc::collections::btree::node::marker::KV"
                                                                          ],
                                                                        "awaken",
                                                                        []
                                                                      |),
                                                                      [ M.read (| handle |) ]
                                                                    |)
                                                                  |)
                                                                |)
                                                              |)
                                                            |)));
                                                        fun γ =>
                                                          ltac:(M.monadic
                                                            (let γ0_0 :=
                                                              M.SubPointer.get_struct_tuple_field (|
                                                                γ,
                                                                "core::option::Option::Some",
                                                                0
                                                              |) in
                                                            let split := M.copy (| γ0_0 |) in
                                                            M.alloc (|
                                                              M.call_closure (|
                                                                M.get_associated_function (|
                                                                  Ty.apply
                                                                    (Ty.path
                                                                      "alloc::collections::btree::node::SplitResult")
                                                                    [
                                                                      K;
                                                                      V;
                                                                      Ty.path
                                                                        "alloc::collections::btree::node::marker::Internal"
                                                                    ],
                                                                  "forget_node_type",
                                                                  []
                                                                |),
                                                                [ M.read (| split |) ]
                                                              |)
                                                            |)))
                                                      ]
                                                    |)));
                                                fun γ =>
                                                  ltac:(M.monadic
                                                    (let γ0_0 :=
                                                      M.SubPointer.get_struct_tuple_field (|
                                                        γ,
                                                        "core::result::Result::Err",
                                                        0
                                                      |) in
                                                    let root := M.copy (| γ0_0 |) in
                                                    M.alloc (|
                                                      M.never_to_any (|
                                                        M.read (|
                                                          let~ _ :=
                                                            M.alloc (|
                                                              M.call_closure (|
                                                                M.get_trait_method (|
                                                                  "core::ops::function::FnOnce",
                                                                  impl_FnOnce_SplitResult_'a__K__V__marker_LeafOrInternal__,
                                                                  [
                                                                    Ty.tuple
                                                                      [
                                                                        Ty.apply
                                                                          (Ty.path
                                                                            "alloc::collections::btree::node::SplitResult")
                                                                          [
                                                                            K;
                                                                            V;
                                                                            Ty.path
                                                                              "alloc::collections::btree::node::marker::LeafOrInternal"
                                                                          ]
                                                                      ]
                                                                  ],
                                                                  "call_once",
                                                                  []
                                                                |),
                                                                [
                                                                  M.read (| split_root |);
                                                                  Value.Tuple
                                                                    [
                                                                      M.struct_record_update
                                                                        (M.read (| split |))
                                                                        [
                                                                          ("left",
                                                                            M.read (| root |))
                                                                        ]
                                                                    ]
                                                                ]
                                                              |)
                                                            |) in
                                                          M.return_ (|
                                                            M.call_closure (|
                                                              M.get_associated_function (|
                                                                Ty.apply
                                                                  (Ty.path
                                                                    "alloc::collections::btree::node::Handle")
                                                                  [
                                                                    Ty.apply
                                                                      (Ty.path
                                                                        "alloc::collections::btree::node::NodeRef")
                                                                      [
                                                                        Ty.path
                                                                          "alloc::collections::btree::node::marker::DormantMut";
                                                                        K;
                                                                        V;
                                                                        Ty.path
                                                                          "alloc::collections::btree::node::marker::Leaf"
                                                                      ];
                                                                    Ty.path
                                                                      "alloc::collections::btree::node::marker::KV"
                                                                  ],
                                                                "awaken",
                                                                []
                                                              |),
                                                              [ M.read (| handle |) ]
                                                            |)
                                                          |)
                                                        |)
                                                      |)
                                                    |)))
                                              ]
                                            |)
                                          |)
                                        |) in
                                      M.alloc (| Value.Tuple [] |)))
                                  |)
                                |)
                              |)
                            |)))
                      ]
                    |)
                  |)))
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom AssociatedFunction_insert_recursing :
          forall (K V : Ty.t),
          M.IsAssociatedFunction (Self K V) "insert_recursing" (insert_recursing K V).
      End Impl_alloc_collections_btree_node_Handle_alloc_collections_btree_node_NodeRef_alloc_collections_btree_node_marker_Mut_K_V_alloc_collections_btree_node_marker_Leaf_alloc_collections_btree_node_marker_Edge.
      
      
      Module Impl_alloc_collections_btree_node_Handle_alloc_collections_btree_node_NodeRef_alloc_collections_btree_node_marker_Mut_K_V_alloc_collections_btree_node_marker_Internal_alloc_collections_btree_node_marker_Edge.
        Definition Self (K V : Ty.t) : Ty.t :=
          Ty.apply
            (Ty.path "alloc::collections::btree::node::Handle")
            [
              Ty.apply
                (Ty.path "alloc::collections::btree::node::NodeRef")
                [
                  Ty.path "alloc::collections::btree::node::marker::Mut";
                  K;
                  V;
                  Ty.path "alloc::collections::btree::node::marker::Internal"
                ];
              Ty.path "alloc::collections::btree::node::marker::Edge"
            ].
        
        (*
            fn correct_parent_link(self) {
                // Create backpointer without invalidating other references to the node.
                let ptr = unsafe { NonNull::new_unchecked(NodeRef::as_internal_ptr(&self.node)) };
                let idx = self.idx;
                let mut child = self.descend();
                child.set_parent_link(ptr, idx);
            }
        *)
        Definition correct_parent_link (K V : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self K V in
          match τ, α with
          | [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              M.read (|
                let~ ptr :=
                  M.alloc (|
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "core::ptr::non_null::NonNull")
                          [
                            Ty.apply
                              (Ty.path "alloc::collections::btree::node::InternalNode")
                              [ K; V ]
                          ],
                        "new_unchecked",
                        []
                      |),
                      [
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.apply
                              (Ty.path "alloc::collections::btree::node::NodeRef")
                              [
                                Ty.path "alloc::collections::btree::node::marker::Mut";
                                K;
                                V;
                                Ty.path "alloc::collections::btree::node::marker::Internal"
                              ],
                            "as_internal_ptr",
                            []
                          |),
                          [
                            M.SubPointer.get_struct_record_field (|
                              self,
                              "alloc::collections::btree::node::Handle",
                              "node"
                            |)
                          ]
                        |)
                      ]
                    |)
                  |) in
                let~ idx :=
                  M.copy (|
                    M.SubPointer.get_struct_record_field (|
                      self,
                      "alloc::collections::btree::node::Handle",
                      "idx"
                    |)
                  |) in
                let~ child :=
                  M.alloc (|
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "alloc::collections::btree::node::Handle")
                          [
                            Ty.apply
                              (Ty.path "alloc::collections::btree::node::NodeRef")
                              [
                                Ty.path "alloc::collections::btree::node::marker::Mut";
                                K;
                                V;
                                Ty.path "alloc::collections::btree::node::marker::Internal"
                              ];
                            Ty.path "alloc::collections::btree::node::marker::Edge"
                          ],
                        "descend",
                        []
                      |),
                      [ M.read (| self |) ]
                    |)
                  |) in
                let~ _ :=
                  M.alloc (|
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "alloc::collections::btree::node::NodeRef")
                          [
                            Ty.path "alloc::collections::btree::node::marker::Mut";
                            K;
                            V;
                            Ty.path "alloc::collections::btree::node::marker::LeafOrInternal"
                          ],
                        "set_parent_link",
                        []
                      |),
                      [ child; M.read (| ptr |); M.read (| idx |) ]
                    |)
                  |) in
                M.alloc (| Value.Tuple [] |)
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom AssociatedFunction_correct_parent_link :
          forall (K V : Ty.t),
          M.IsAssociatedFunction (Self K V) "correct_parent_link" (correct_parent_link K V).
        (*
            fn insert_fit(&mut self, key: K, val: V, edge: Root<K, V>) {
                debug_assert!(self.node.len() < CAPACITY);
                debug_assert!(edge.height == self.node.height - 1);
                let new_len = self.node.len() + 1;
        
                unsafe {
                    slice_insert(self.node.key_area_mut(..new_len), self.idx, key);
                    slice_insert(self.node.val_area_mut(..new_len), self.idx, val);
                    slice_insert(self.node.edge_area_mut(..new_len + 1), self.idx + 1, edge.node);
                    *self.node.len_mut() = new_len as u16;
        
                    self.node.correct_childrens_parent_links(self.idx + 1..new_len + 1);
                }
            }
        *)
        Definition insert_fit (K V : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self K V in
          match τ, α with
          | [], [ self; key; val; edge ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let key := M.alloc (| key |) in
              let val := M.alloc (| val |) in
              let edge := M.alloc (| edge |) in
              M.read (|
                let~ _ :=
                  M.match_operator (|
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ := M.use (M.alloc (| Value.Bool true |)) in
                          let _ :=
                            M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          let~ _ :=
                            M.match_operator (|
                              M.alloc (| Value.Tuple [] |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let γ :=
                                      M.use
                                        (M.alloc (|
                                          UnOp.Pure.not
                                            (BinOp.Pure.lt
                                              (M.call_closure (|
                                                M.get_associated_function (|
                                                  Ty.apply
                                                    (Ty.path
                                                      "alloc::collections::btree::node::NodeRef")
                                                    [
                                                      Ty.path
                                                        "alloc::collections::btree::node::marker::Mut";
                                                      K;
                                                      V;
                                                      Ty.path
                                                        "alloc::collections::btree::node::marker::Internal"
                                                    ],
                                                  "len",
                                                  []
                                                |),
                                                [
                                                  M.SubPointer.get_struct_record_field (|
                                                    M.read (| self |),
                                                    "alloc::collections::btree::node::Handle",
                                                    "node"
                                                  |)
                                                ]
                                              |))
                                              (M.read (|
                                                M.get_constant (|
                                                  "alloc::collections::btree::node::CAPACITY"
                                                |)
                                              |)))
                                        |)) in
                                    let _ :=
                                      M.is_constant_or_break_match (|
                                        M.read (| γ |),
                                        Value.Bool true
                                      |) in
                                    M.alloc (|
                                      M.never_to_any (|
                                        M.call_closure (|
                                          M.get_function (| "core::panicking::panic", [] |),
                                          [
                                            M.read (|
                                              Value.String
                                                "assertion failed: self.node.len() < CAPACITY"
                                            |)
                                          ]
                                        |)
                                      |)
                                    |)));
                                fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                              ]
                            |) in
                          M.alloc (| Value.Tuple [] |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                let~ _ :=
                  M.match_operator (|
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ := M.use (M.alloc (| Value.Bool true |)) in
                          let _ :=
                            M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          let~ _ :=
                            M.match_operator (|
                              M.alloc (| Value.Tuple [] |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let γ :=
                                      M.use
                                        (M.alloc (|
                                          UnOp.Pure.not
                                            (BinOp.Pure.eq
                                              (M.read (|
                                                M.SubPointer.get_struct_record_field (|
                                                  edge,
                                                  "alloc::collections::btree::node::NodeRef",
                                                  "height"
                                                |)
                                              |))
                                              (BinOp.Wrap.sub
                                                Integer.Usize
                                                (M.read (|
                                                  M.SubPointer.get_struct_record_field (|
                                                    M.SubPointer.get_struct_record_field (|
                                                      M.read (| self |),
                                                      "alloc::collections::btree::node::Handle",
                                                      "node"
                                                    |),
                                                    "alloc::collections::btree::node::NodeRef",
                                                    "height"
                                                  |)
                                                |))
                                                (Value.Integer 1)))
                                        |)) in
                                    let _ :=
                                      M.is_constant_or_break_match (|
                                        M.read (| γ |),
                                        Value.Bool true
                                      |) in
                                    M.alloc (|
                                      M.never_to_any (|
                                        M.call_closure (|
                                          M.get_function (| "core::panicking::panic", [] |),
                                          [
                                            M.read (|
                                              Value.String
                                                "assertion failed: edge.height == self.node.height - 1"
                                            |)
                                          ]
                                        |)
                                      |)
                                    |)));
                                fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                              ]
                            |) in
                          M.alloc (| Value.Tuple [] |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                let~ new_len :=
                  M.alloc (|
                    BinOp.Wrap.add
                      Integer.Usize
                      (M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply
                            (Ty.path "alloc::collections::btree::node::NodeRef")
                            [
                              Ty.path "alloc::collections::btree::node::marker::Mut";
                              K;
                              V;
                              Ty.path "alloc::collections::btree::node::marker::Internal"
                            ],
                          "len",
                          []
                        |),
                        [
                          M.SubPointer.get_struct_record_field (|
                            M.read (| self |),
                            "alloc::collections::btree::node::Handle",
                            "node"
                          |)
                        ]
                      |))
                      (Value.Integer 1)
                  |) in
                let~ _ :=
                  M.alloc (|
                    M.call_closure (|
                      M.get_function (| "alloc::collections::btree::node::slice_insert", [ K ] |),
                      [
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.apply
                              (Ty.path "alloc::collections::btree::node::NodeRef")
                              [
                                Ty.path "alloc::collections::btree::node::marker::Mut";
                                K;
                                V;
                                Ty.path "alloc::collections::btree::node::marker::Internal"
                              ],
                            "key_area_mut",
                            [
                              Ty.apply (Ty.path "core::ops::range::RangeTo") [ Ty.path "usize" ];
                              Ty.apply
                                (Ty.path "slice")
                                [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ K ] ]
                            ]
                          |),
                          [
                            M.SubPointer.get_struct_record_field (|
                              M.read (| self |),
                              "alloc::collections::btree::node::Handle",
                              "node"
                            |);
                            Value.StructRecord
                              "core::ops::range::RangeTo"
                              [ ("end_", M.read (| new_len |)) ]
                          ]
                        |);
                        M.read (|
                          M.SubPointer.get_struct_record_field (|
                            M.read (| self |),
                            "alloc::collections::btree::node::Handle",
                            "idx"
                          |)
                        |);
                        M.read (| key |)
                      ]
                    |)
                  |) in
                let~ _ :=
                  M.alloc (|
                    M.call_closure (|
                      M.get_function (| "alloc::collections::btree::node::slice_insert", [ V ] |),
                      [
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.apply
                              (Ty.path "alloc::collections::btree::node::NodeRef")
                              [
                                Ty.path "alloc::collections::btree::node::marker::Mut";
                                K;
                                V;
                                Ty.path "alloc::collections::btree::node::marker::Internal"
                              ],
                            "val_area_mut",
                            [
                              Ty.apply (Ty.path "core::ops::range::RangeTo") [ Ty.path "usize" ];
                              Ty.apply
                                (Ty.path "slice")
                                [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ V ] ]
                            ]
                          |),
                          [
                            M.SubPointer.get_struct_record_field (|
                              M.read (| self |),
                              "alloc::collections::btree::node::Handle",
                              "node"
                            |);
                            Value.StructRecord
                              "core::ops::range::RangeTo"
                              [ ("end_", M.read (| new_len |)) ]
                          ]
                        |);
                        M.read (|
                          M.SubPointer.get_struct_record_field (|
                            M.read (| self |),
                            "alloc::collections::btree::node::Handle",
                            "idx"
                          |)
                        |);
                        M.read (| val |)
                      ]
                    |)
                  |) in
                let~ _ :=
                  M.alloc (|
                    M.call_closure (|
                      M.get_function (|
                        "alloc::collections::btree::node::slice_insert",
                        [
                          Ty.apply
                            (Ty.path "core::ptr::non_null::NonNull")
                            [
                              Ty.apply
                                (Ty.path "alloc::collections::btree::node::LeafNode")
                                [ K; V ]
                            ]
                        ]
                      |),
                      [
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.apply
                              (Ty.path "alloc::collections::btree::node::NodeRef")
                              [
                                Ty.path "alloc::collections::btree::node::marker::Mut";
                                K;
                                V;
                                Ty.path "alloc::collections::btree::node::marker::Internal"
                              ],
                            "edge_area_mut",
                            [
                              Ty.apply (Ty.path "core::ops::range::RangeTo") [ Ty.path "usize" ];
                              Ty.apply
                                (Ty.path "slice")
                                [
                                  Ty.apply
                                    (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                    [
                                      Ty.apply
                                        (Ty.path "core::ptr::non_null::NonNull")
                                        [
                                          Ty.apply
                                            (Ty.path "alloc::collections::btree::node::LeafNode")
                                            [ K; V ]
                                        ]
                                    ]
                                ]
                            ]
                          |),
                          [
                            M.SubPointer.get_struct_record_field (|
                              M.read (| self |),
                              "alloc::collections::btree::node::Handle",
                              "node"
                            |);
                            Value.StructRecord
                              "core::ops::range::RangeTo"
                              [
                                ("end_",
                                  BinOp.Wrap.add
                                    Integer.Usize
                                    (M.read (| new_len |))
                                    (Value.Integer 1))
                              ]
                          ]
                        |);
                        BinOp.Wrap.add
                          Integer.Usize
                          (M.read (|
                            M.SubPointer.get_struct_record_field (|
                              M.read (| self |),
                              "alloc::collections::btree::node::Handle",
                              "idx"
                            |)
                          |))
                          (Value.Integer 1);
                        M.read (|
                          M.SubPointer.get_struct_record_field (|
                            edge,
                            "alloc::collections::btree::node::NodeRef",
                            "node"
                          |)
                        |)
                      ]
                    |)
                  |) in
                let~ _ :=
                  M.write (|
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "alloc::collections::btree::node::NodeRef")
                          [
                            Ty.path "alloc::collections::btree::node::marker::Mut";
                            K;
                            V;
                            Ty.path "alloc::collections::btree::node::marker::Internal"
                          ],
                        "len_mut",
                        []
                      |),
                      [
                        M.SubPointer.get_struct_record_field (|
                          M.read (| self |),
                          "alloc::collections::btree::node::Handle",
                          "node"
                        |)
                      ]
                    |),
                    M.rust_cast (M.read (| new_len |))
                  |) in
                let~ _ :=
                  M.alloc (|
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "alloc::collections::btree::node::NodeRef")
                          [
                            Ty.path "alloc::collections::btree::node::marker::Mut";
                            K;
                            V;
                            Ty.path "alloc::collections::btree::node::marker::Internal"
                          ],
                        "correct_childrens_parent_links",
                        [ Ty.apply (Ty.path "core::ops::range::Range") [ Ty.path "usize" ] ]
                      |),
                      [
                        M.SubPointer.get_struct_record_field (|
                          M.read (| self |),
                          "alloc::collections::btree::node::Handle",
                          "node"
                        |);
                        Value.StructRecord
                          "core::ops::range::Range"
                          [
                            ("start",
                              BinOp.Wrap.add
                                Integer.Usize
                                (M.read (|
                                  M.SubPointer.get_struct_record_field (|
                                    M.read (| self |),
                                    "alloc::collections::btree::node::Handle",
                                    "idx"
                                  |)
                                |))
                                (Value.Integer 1));
                            ("end_",
                              BinOp.Wrap.add Integer.Usize (M.read (| new_len |)) (Value.Integer 1))
                          ]
                      ]
                    |)
                  |) in
                M.alloc (| Value.Tuple [] |)
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom AssociatedFunction_insert_fit :
          forall (K V : Ty.t),
          M.IsAssociatedFunction (Self K V) "insert_fit" (insert_fit K V).
        
        (*
            fn insert<A: Allocator + Clone>(
                mut self,
                key: K,
                val: V,
                edge: Root<K, V>,
                alloc: A,
            ) -> Option<SplitResult<'a, K, V, marker::Internal>> {
                assert!(edge.height == self.node.height - 1);
        
                if self.node.len() < CAPACITY {
                    self.insert_fit(key, val, edge);
                    None
                } else {
                    let (middle_kv_idx, insertion) = splitpoint(self.idx);
                    let middle = unsafe { Handle::new_kv(self.node, middle_kv_idx) };
                    let mut result = middle.split(alloc);
                    let mut insertion_edge = match insertion {
                        LeftOrRight::Left(insert_idx) => unsafe {
                            Handle::new_edge(result.left.reborrow_mut(), insert_idx)
                        },
                        LeftOrRight::Right(insert_idx) => unsafe {
                            Handle::new_edge(result.right.borrow_mut(), insert_idx)
                        },
                    };
                    insertion_edge.insert_fit(key, val, edge);
                    Some(result)
                }
            }
        *)
        Definition insert (K V : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self K V in
          match τ, α with
          | [ A ], [ self; key; val; edge; alloc ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let key := M.alloc (| key |) in
              let val := M.alloc (| val |) in
              let edge := M.alloc (| edge |) in
              let alloc := M.alloc (| alloc |) in
              M.read (|
                let~ _ :=
                  M.match_operator (|
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                UnOp.Pure.not
                                  (BinOp.Pure.eq
                                    (M.read (|
                                      M.SubPointer.get_struct_record_field (|
                                        edge,
                                        "alloc::collections::btree::node::NodeRef",
                                        "height"
                                      |)
                                    |))
                                    (BinOp.Wrap.sub
                                      Integer.Usize
                                      (M.read (|
                                        M.SubPointer.get_struct_record_field (|
                                          M.SubPointer.get_struct_record_field (|
                                            self,
                                            "alloc::collections::btree::node::Handle",
                                            "node"
                                          |),
                                          "alloc::collections::btree::node::NodeRef",
                                          "height"
                                        |)
                                      |))
                                      (Value.Integer 1)))
                              |)) in
                          let _ :=
                            M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (|
                            M.never_to_any (|
                              M.call_closure (|
                                M.get_function (| "core::panicking::panic", [] |),
                                [
                                  M.read (|
                                    Value.String
                                      "assertion failed: edge.height == self.node.height - 1"
                                  |)
                                ]
                              |)
                            |)
                          |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                M.match_operator (|
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ :=
                          M.use
                            (M.alloc (|
                              BinOp.Pure.lt
                                (M.call_closure (|
                                  M.get_associated_function (|
                                    Ty.apply
                                      (Ty.path "alloc::collections::btree::node::NodeRef")
                                      [
                                        Ty.path "alloc::collections::btree::node::marker::Mut";
                                        K;
                                        V;
                                        Ty.path "alloc::collections::btree::node::marker::Internal"
                                      ],
                                    "len",
                                    []
                                  |),
                                  [
                                    M.SubPointer.get_struct_record_field (|
                                      self,
                                      "alloc::collections::btree::node::Handle",
                                      "node"
                                    |)
                                  ]
                                |))
                                (M.read (|
                                  M.get_constant (| "alloc::collections::btree::node::CAPACITY" |)
                                |))
                            |)) in
                        let _ :=
                          M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        let~ _ :=
                          M.alloc (|
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "alloc::collections::btree::node::Handle")
                                  [
                                    Ty.apply
                                      (Ty.path "alloc::collections::btree::node::NodeRef")
                                      [
                                        Ty.path "alloc::collections::btree::node::marker::Mut";
                                        K;
                                        V;
                                        Ty.path "alloc::collections::btree::node::marker::Internal"
                                      ];
                                    Ty.path "alloc::collections::btree::node::marker::Edge"
                                  ],
                                "insert_fit",
                                []
                              |),
                              [ self; M.read (| key |); M.read (| val |); M.read (| edge |) ]
                            |)
                          |) in
                        M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                    fun γ =>
                      ltac:(M.monadic
                        (M.match_operator (|
                          M.alloc (|
                            M.call_closure (|
                              M.get_function (|
                                "alloc::collections::btree::node::splitpoint",
                                []
                              |),
                              [
                                M.read (|
                                  M.SubPointer.get_struct_record_field (|
                                    self,
                                    "alloc::collections::btree::node::Handle",
                                    "idx"
                                  |)
                                |)
                              ]
                            |)
                          |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                                let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                let middle_kv_idx := M.copy (| γ0_0 |) in
                                let insertion := M.copy (| γ0_1 |) in
                                let~ middle :=
                                  M.alloc (|
                                    M.call_closure (|
                                      M.get_associated_function (|
                                        Ty.apply
                                          (Ty.path "alloc::collections::btree::node::Handle")
                                          [
                                            Ty.apply
                                              (Ty.path "alloc::collections::btree::node::NodeRef")
                                              [
                                                Ty.path
                                                  "alloc::collections::btree::node::marker::Mut";
                                                K;
                                                V;
                                                Ty.path
                                                  "alloc::collections::btree::node::marker::Internal"
                                              ];
                                            Ty.path "alloc::collections::btree::node::marker::KV"
                                          ],
                                        "new_kv",
                                        []
                                      |),
                                      [
                                        M.read (|
                                          M.SubPointer.get_struct_record_field (|
                                            self,
                                            "alloc::collections::btree::node::Handle",
                                            "node"
                                          |)
                                        |);
                                        M.read (| middle_kv_idx |)
                                      ]
                                    |)
                                  |) in
                                let~ result :=
                                  M.alloc (|
                                    M.call_closure (|
                                      M.get_associated_function (|
                                        Ty.apply
                                          (Ty.path "alloc::collections::btree::node::Handle")
                                          [
                                            Ty.apply
                                              (Ty.path "alloc::collections::btree::node::NodeRef")
                                              [
                                                Ty.path
                                                  "alloc::collections::btree::node::marker::Mut";
                                                K;
                                                V;
                                                Ty.path
                                                  "alloc::collections::btree::node::marker::Internal"
                                              ];
                                            Ty.path "alloc::collections::btree::node::marker::KV"
                                          ],
                                        "split",
                                        [ A ]
                                      |),
                                      [ M.read (| middle |); M.read (| alloc |) ]
                                    |)
                                  |) in
                                let~ insertion_edge :=
                                  M.copy (|
                                    M.match_operator (|
                                      insertion,
                                      [
                                        fun γ =>
                                          ltac:(M.monadic
                                            (let γ0_0 :=
                                              M.SubPointer.get_struct_tuple_field (|
                                                γ,
                                                "alloc::collections::btree::node::LeftOrRight::Left",
                                                0
                                              |) in
                                            let insert_idx := M.copy (| γ0_0 |) in
                                            M.alloc (|
                                              M.call_closure (|
                                                M.get_associated_function (|
                                                  Ty.apply
                                                    (Ty.path
                                                      "alloc::collections::btree::node::Handle")
                                                    [
                                                      Ty.apply
                                                        (Ty.path
                                                          "alloc::collections::btree::node::NodeRef")
                                                        [
                                                          Ty.path
                                                            "alloc::collections::btree::node::marker::Mut";
                                                          K;
                                                          V;
                                                          Ty.path
                                                            "alloc::collections::btree::node::marker::Internal"
                                                        ];
                                                      Ty.path
                                                        "alloc::collections::btree::node::marker::Edge"
                                                    ],
                                                  "new_edge",
                                                  []
                                                |),
                                                [
                                                  M.call_closure (|
                                                    M.get_associated_function (|
                                                      Ty.apply
                                                        (Ty.path
                                                          "alloc::collections::btree::node::NodeRef")
                                                        [
                                                          Ty.path
                                                            "alloc::collections::btree::node::marker::Mut";
                                                          K;
                                                          V;
                                                          Ty.path
                                                            "alloc::collections::btree::node::marker::Internal"
                                                        ],
                                                      "reborrow_mut",
                                                      []
                                                    |),
                                                    [
                                                      M.SubPointer.get_struct_record_field (|
                                                        result,
                                                        "alloc::collections::btree::node::SplitResult",
                                                        "left"
                                                      |)
                                                    ]
                                                  |);
                                                  M.read (| insert_idx |)
                                                ]
                                              |)
                                            |)));
                                        fun γ =>
                                          ltac:(M.monadic
                                            (let γ0_0 :=
                                              M.SubPointer.get_struct_tuple_field (|
                                                γ,
                                                "alloc::collections::btree::node::LeftOrRight::Right",
                                                0
                                              |) in
                                            let insert_idx := M.copy (| γ0_0 |) in
                                            M.alloc (|
                                              M.call_closure (|
                                                M.get_associated_function (|
                                                  Ty.apply
                                                    (Ty.path
                                                      "alloc::collections::btree::node::Handle")
                                                    [
                                                      Ty.apply
                                                        (Ty.path
                                                          "alloc::collections::btree::node::NodeRef")
                                                        [
                                                          Ty.path
                                                            "alloc::collections::btree::node::marker::Mut";
                                                          K;
                                                          V;
                                                          Ty.path
                                                            "alloc::collections::btree::node::marker::Internal"
                                                        ];
                                                      Ty.path
                                                        "alloc::collections::btree::node::marker::Edge"
                                                    ],
                                                  "new_edge",
                                                  []
                                                |),
                                                [
                                                  M.call_closure (|
                                                    M.get_associated_function (|
                                                      Ty.apply
                                                        (Ty.path
                                                          "alloc::collections::btree::node::NodeRef")
                                                        [
                                                          Ty.path
                                                            "alloc::collections::btree::node::marker::Owned";
                                                          K;
                                                          V;
                                                          Ty.path
                                                            "alloc::collections::btree::node::marker::Internal"
                                                        ],
                                                      "borrow_mut",
                                                      []
                                                    |),
                                                    [
                                                      M.SubPointer.get_struct_record_field (|
                                                        result,
                                                        "alloc::collections::btree::node::SplitResult",
                                                        "right"
                                                      |)
                                                    ]
                                                  |);
                                                  M.read (| insert_idx |)
                                                ]
                                              |)
                                            |)))
                                      ]
                                    |)
                                  |) in
                                let~ _ :=
                                  M.alloc (|
                                    M.call_closure (|
                                      M.get_associated_function (|
                                        Ty.apply
                                          (Ty.path "alloc::collections::btree::node::Handle")
                                          [
                                            Ty.apply
                                              (Ty.path "alloc::collections::btree::node::NodeRef")
                                              [
                                                Ty.path
                                                  "alloc::collections::btree::node::marker::Mut";
                                                K;
                                                V;
                                                Ty.path
                                                  "alloc::collections::btree::node::marker::Internal"
                                              ];
                                            Ty.path "alloc::collections::btree::node::marker::Edge"
                                          ],
                                        "insert_fit",
                                        []
                                      |),
                                      [
                                        insertion_edge;
                                        M.read (| key |);
                                        M.read (| val |);
                                        M.read (| edge |)
                                      ]
                                    |)
                                  |) in
                                M.alloc (|
                                  Value.StructTuple
                                    "core::option::Option::Some"
                                    [ M.read (| result |) ]
                                |)))
                          ]
                        |)))
                  ]
                |)
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom AssociatedFunction_insert :
          forall (K V : Ty.t),
          M.IsAssociatedFunction (Self K V) "insert" (insert K V).
      End Impl_alloc_collections_btree_node_Handle_alloc_collections_btree_node_NodeRef_alloc_collections_btree_node_marker_Mut_K_V_alloc_collections_btree_node_marker_Internal_alloc_collections_btree_node_marker_Edge.
      
      
      
      Module Impl_alloc_collections_btree_node_Handle_alloc_collections_btree_node_NodeRef_BorrowType_K_V_alloc_collections_btree_node_marker_Internal_alloc_collections_btree_node_marker_Edge.
        Definition Self (BorrowType K V : Ty.t) : Ty.t :=
          Ty.apply
            (Ty.path "alloc::collections::btree::node::Handle")
            [
              Ty.apply
                (Ty.path "alloc::collections::btree::node::NodeRef")
                [ BorrowType; K; V; Ty.path "alloc::collections::btree::node::marker::Internal" ];
              Ty.path "alloc::collections::btree::node::marker::Edge"
            ].
        
        (*
            pub fn descend(self) -> NodeRef<BorrowType, K, V, marker::LeafOrInternal> {
                const {
                    assert!(BorrowType::TRAVERSAL_PERMIT);
                }
        
                // We need to use raw pointers to nodes because, if BorrowType is
                // marker::ValMut, there might be outstanding mutable references to
                // values that we must not invalidate. There's no worry accessing the
                // height field because that value is copied. Beware that, once the
                // node pointer is dereferenced, we access the edges array with a
                // reference (Rust issue #73987) and invalidate any other references
                // to or inside the array, should any be around.
                let parent_ptr = NodeRef::as_internal_ptr(&self.node);
                let node = unsafe { ( *parent_ptr).edges.get_unchecked(self.idx).assume_init_read() };
                NodeRef { node, height: self.node.height - 1, _marker: PhantomData }
            }
        *)
        Definition descend (BorrowType K V : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self BorrowType K V in
          match τ, α with
          | [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              M.read (|
                let~ _ :=
                  M.get_constant (| "alloc::collections::btree::node::descend_discriminant" |) in
                let~ parent_ptr :=
                  M.alloc (|
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "alloc::collections::btree::node::NodeRef")
                          [
                            BorrowType;
                            K;
                            V;
                            Ty.path "alloc::collections::btree::node::marker::Internal"
                          ],
                        "as_internal_ptr",
                        []
                      |),
                      [
                        M.SubPointer.get_struct_record_field (|
                          self,
                          "alloc::collections::btree::node::Handle",
                          "node"
                        |)
                      ]
                    |)
                  |) in
                let~ node :=
                  M.alloc (|
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                          [
                            Ty.apply
                              (Ty.path "core::ptr::non_null::NonNull")
                              [
                                Ty.apply
                                  (Ty.path "alloc::collections::btree::node::LeafNode")
                                  [ K; V ]
                              ]
                          ],
                        "assume_init_read",
                        []
                      |),
                      [
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.apply
                              (Ty.path "slice")
                              [
                                Ty.apply
                                  (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                  [
                                    Ty.apply
                                      (Ty.path "core::ptr::non_null::NonNull")
                                      [
                                        Ty.apply
                                          (Ty.path "alloc::collections::btree::node::LeafNode")
                                          [ K; V ]
                                      ]
                                  ]
                              ],
                            "get_unchecked",
                            [ Ty.path "usize" ]
                          |),
                          [
                            (* Unsize *)
                            M.pointer_coercion
                              (M.SubPointer.get_struct_record_field (|
                                M.read (| parent_ptr |),
                                "alloc::collections::btree::node::InternalNode",
                                "edges"
                              |));
                            M.read (|
                              M.SubPointer.get_struct_record_field (|
                                self,
                                "alloc::collections::btree::node::Handle",
                                "idx"
                              |)
                            |)
                          ]
                        |)
                      ]
                    |)
                  |) in
                M.alloc (|
                  Value.StructRecord
                    "alloc::collections::btree::node::NodeRef"
                    [
                      ("node", M.read (| node |));
                      ("height",
                        BinOp.Wrap.sub
                          Integer.Usize
                          (M.read (|
                            M.SubPointer.get_struct_record_field (|
                              M.SubPointer.get_struct_record_field (|
                                self,
                                "alloc::collections::btree::node::Handle",
                                "node"
                              |),
                              "alloc::collections::btree::node::NodeRef",
                              "height"
                            |)
                          |))
                          (Value.Integer 1));
                      ("_marker", Value.StructTuple "core::marker::PhantomData" [])
                    ]
                |)
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom AssociatedFunction_descend :
          forall (BorrowType K V : Ty.t),
          M.IsAssociatedFunction (Self BorrowType K V) "descend" (descend BorrowType K V).
        (*
            pub fn forget_node_type(
                self,
            ) -> Handle<NodeRef<BorrowType, K, V, marker::LeafOrInternal>, marker::Edge> {
                unsafe { Handle::new_edge(self.node.forget_type(), self.idx) }
            }
        *)
        Definition forget_node_type
            (BorrowType K V : Ty.t)
            (τ : list Ty.t)
            (α : list Value.t)
            : M :=
          let Self : Ty.t := Self BorrowType K V in
          match τ, α with
          | [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "alloc::collections::btree::node::Handle")
                    [
                      Ty.apply
                        (Ty.path "alloc::collections::btree::node::NodeRef")
                        [
                          BorrowType;
                          K;
                          V;
                          Ty.path "alloc::collections::btree::node::marker::LeafOrInternal"
                        ];
                      Ty.path "alloc::collections::btree::node::marker::Edge"
                    ],
                  "new_edge",
                  []
                |),
                [
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "alloc::collections::btree::node::NodeRef")
                        [
                          BorrowType;
                          K;
                          V;
                          Ty.path "alloc::collections::btree::node::marker::Internal"
                        ],
                      "forget_type",
                      []
                    |),
                    [
                      M.read (|
                        M.SubPointer.get_struct_record_field (|
                          self,
                          "alloc::collections::btree::node::Handle",
                          "node"
                        |)
                      |)
                    ]
                  |);
                  M.read (|
                    M.SubPointer.get_struct_record_field (|
                      self,
                      "alloc::collections::btree::node::Handle",
                      "idx"
                    |)
                  |)
                ]
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom AssociatedFunction_forget_node_type :
          forall (BorrowType K V : Ty.t),
          M.IsAssociatedFunction
            (Self BorrowType K V)
            "forget_node_type"
            (forget_node_type BorrowType K V).
      End Impl_alloc_collections_btree_node_Handle_alloc_collections_btree_node_NodeRef_BorrowType_K_V_alloc_collections_btree_node_marker_Internal_alloc_collections_btree_node_marker_Edge.
      
      Module Impl_alloc_collections_btree_node_Handle_alloc_collections_btree_node_NodeRef_alloc_collections_btree_node_marker_Immut_K_V_NodeType_alloc_collections_btree_node_marker_KV.
        Definition Self (K V NodeType : Ty.t) : Ty.t :=
          Ty.apply
            (Ty.path "alloc::collections::btree::node::Handle")
            [
              Ty.apply
                (Ty.path "alloc::collections::btree::node::NodeRef")
                [ Ty.path "alloc::collections::btree::node::marker::Immut"; K; V; NodeType ];
              Ty.path "alloc::collections::btree::node::marker::KV"
            ].
        
        (*
            pub fn into_kv(self) -> (&'a K, &'a V) {
                debug_assert!(self.idx < self.node.len());
                let leaf = self.node.into_leaf();
                let k = unsafe { leaf.keys.get_unchecked(self.idx).assume_init_ref() };
                let v = unsafe { leaf.vals.get_unchecked(self.idx).assume_init_ref() };
                (k, v)
            }
        *)
        Definition into_kv (K V NodeType : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self K V NodeType in
          match τ, α with
          | [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              M.read (|
                let~ _ :=
                  M.match_operator (|
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ := M.use (M.alloc (| Value.Bool true |)) in
                          let _ :=
                            M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          let~ _ :=
                            M.match_operator (|
                              M.alloc (| Value.Tuple [] |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let γ :=
                                      M.use
                                        (M.alloc (|
                                          UnOp.Pure.not
                                            (BinOp.Pure.lt
                                              (M.read (|
                                                M.SubPointer.get_struct_record_field (|
                                                  self,
                                                  "alloc::collections::btree::node::Handle",
                                                  "idx"
                                                |)
                                              |))
                                              (M.call_closure (|
                                                M.get_associated_function (|
                                                  Ty.apply
                                                    (Ty.path
                                                      "alloc::collections::btree::node::NodeRef")
                                                    [
                                                      Ty.path
                                                        "alloc::collections::btree::node::marker::Immut";
                                                      K;
                                                      V;
                                                      NodeType
                                                    ],
                                                  "len",
                                                  []
                                                |),
                                                [
                                                  M.SubPointer.get_struct_record_field (|
                                                    self,
                                                    "alloc::collections::btree::node::Handle",
                                                    "node"
                                                  |)
                                                ]
                                              |)))
                                        |)) in
                                    let _ :=
                                      M.is_constant_or_break_match (|
                                        M.read (| γ |),
                                        Value.Bool true
                                      |) in
                                    M.alloc (|
                                      M.never_to_any (|
                                        M.call_closure (|
                                          M.get_function (| "core::panicking::panic", [] |),
                                          [
                                            M.read (|
                                              Value.String
                                                "assertion failed: self.idx < self.node.len()"
                                            |)
                                          ]
                                        |)
                                      |)
                                    |)));
                                fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                              ]
                            |) in
                          M.alloc (| Value.Tuple [] |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                let~ leaf :=
                  M.alloc (|
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "alloc::collections::btree::node::NodeRef")
                          [ Ty.path "alloc::collections::btree::node::marker::Immut"; K; V; NodeType
                          ],
                        "into_leaf",
                        []
                      |),
                      [
                        M.read (|
                          M.SubPointer.get_struct_record_field (|
                            self,
                            "alloc::collections::btree::node::Handle",
                            "node"
                          |)
                        |)
                      ]
                    |)
                  |) in
                let~ k :=
                  M.alloc (|
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ K ],
                        "assume_init_ref",
                        []
                      |),
                      [
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.apply
                              (Ty.path "slice")
                              [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ K ] ],
                            "get_unchecked",
                            [ Ty.path "usize" ]
                          |),
                          [
                            (* Unsize *)
                            M.pointer_coercion
                              (M.SubPointer.get_struct_record_field (|
                                M.read (| leaf |),
                                "alloc::collections::btree::node::LeafNode",
                                "keys"
                              |));
                            M.read (|
                              M.SubPointer.get_struct_record_field (|
                                self,
                                "alloc::collections::btree::node::Handle",
                                "idx"
                              |)
                            |)
                          ]
                        |)
                      ]
                    |)
                  |) in
                let~ v :=
                  M.alloc (|
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ V ],
                        "assume_init_ref",
                        []
                      |),
                      [
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.apply
                              (Ty.path "slice")
                              [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ V ] ],
                            "get_unchecked",
                            [ Ty.path "usize" ]
                          |),
                          [
                            (* Unsize *)
                            M.pointer_coercion
                              (M.SubPointer.get_struct_record_field (|
                                M.read (| leaf |),
                                "alloc::collections::btree::node::LeafNode",
                                "vals"
                              |));
                            M.read (|
                              M.SubPointer.get_struct_record_field (|
                                self,
                                "alloc::collections::btree::node::Handle",
                                "idx"
                              |)
                            |)
                          ]
                        |)
                      ]
                    |)
                  |) in
                M.alloc (| Value.Tuple [ M.read (| k |); M.read (| v |) ] |)
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom AssociatedFunction_into_kv :
          forall (K V NodeType : Ty.t),
          M.IsAssociatedFunction (Self K V NodeType) "into_kv" (into_kv K V NodeType).
      End Impl_alloc_collections_btree_node_Handle_alloc_collections_btree_node_NodeRef_alloc_collections_btree_node_marker_Immut_K_V_NodeType_alloc_collections_btree_node_marker_KV.
      
      Module Impl_alloc_collections_btree_node_Handle_alloc_collections_btree_node_NodeRef_alloc_collections_btree_node_marker_Mut_K_V_NodeType_alloc_collections_btree_node_marker_KV.
        Definition Self (K V NodeType : Ty.t) : Ty.t :=
          Ty.apply
            (Ty.path "alloc::collections::btree::node::Handle")
            [
              Ty.apply
                (Ty.path "alloc::collections::btree::node::NodeRef")
                [ Ty.path "alloc::collections::btree::node::marker::Mut"; K; V; NodeType ];
              Ty.path "alloc::collections::btree::node::marker::KV"
            ].
        
        (*
            pub fn key_mut(&mut self) -> &mut K {
                unsafe { self.node.key_area_mut(self.idx).assume_init_mut() }
            }
        *)
        Definition key_mut (K V NodeType : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self K V NodeType in
          match τ, α with
          | [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ K ],
                  "assume_init_mut",
                  []
                |),
                [
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "alloc::collections::btree::node::NodeRef")
                        [ Ty.path "alloc::collections::btree::node::marker::Mut"; K; V; NodeType ],
                      "key_area_mut",
                      [
                        Ty.path "usize";
                        Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ K ]
                      ]
                    |),
                    [
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "alloc::collections::btree::node::Handle",
                        "node"
                      |);
                      M.read (|
                        M.SubPointer.get_struct_record_field (|
                          M.read (| self |),
                          "alloc::collections::btree::node::Handle",
                          "idx"
                        |)
                      |)
                    ]
                  |)
                ]
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom AssociatedFunction_key_mut :
          forall (K V NodeType : Ty.t),
          M.IsAssociatedFunction (Self K V NodeType) "key_mut" (key_mut K V NodeType).
        
        (*
            pub fn into_val_mut(self) -> &'a mut V {
                debug_assert!(self.idx < self.node.len());
                let leaf = self.node.into_leaf_mut();
                unsafe { leaf.vals.get_unchecked_mut(self.idx).assume_init_mut() }
            }
        *)
        Definition into_val_mut (K V NodeType : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self K V NodeType in
          match τ, α with
          | [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              M.read (|
                let~ _ :=
                  M.match_operator (|
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ := M.use (M.alloc (| Value.Bool true |)) in
                          let _ :=
                            M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          let~ _ :=
                            M.match_operator (|
                              M.alloc (| Value.Tuple [] |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let γ :=
                                      M.use
                                        (M.alloc (|
                                          UnOp.Pure.not
                                            (BinOp.Pure.lt
                                              (M.read (|
                                                M.SubPointer.get_struct_record_field (|
                                                  self,
                                                  "alloc::collections::btree::node::Handle",
                                                  "idx"
                                                |)
                                              |))
                                              (M.call_closure (|
                                                M.get_associated_function (|
                                                  Ty.apply
                                                    (Ty.path
                                                      "alloc::collections::btree::node::NodeRef")
                                                    [
                                                      Ty.path
                                                        "alloc::collections::btree::node::marker::Mut";
                                                      K;
                                                      V;
                                                      NodeType
                                                    ],
                                                  "len",
                                                  []
                                                |),
                                                [
                                                  M.SubPointer.get_struct_record_field (|
                                                    self,
                                                    "alloc::collections::btree::node::Handle",
                                                    "node"
                                                  |)
                                                ]
                                              |)))
                                        |)) in
                                    let _ :=
                                      M.is_constant_or_break_match (|
                                        M.read (| γ |),
                                        Value.Bool true
                                      |) in
                                    M.alloc (|
                                      M.never_to_any (|
                                        M.call_closure (|
                                          M.get_function (| "core::panicking::panic", [] |),
                                          [
                                            M.read (|
                                              Value.String
                                                "assertion failed: self.idx < self.node.len()"
                                            |)
                                          ]
                                        |)
                                      |)
                                    |)));
                                fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                              ]
                            |) in
                          M.alloc (| Value.Tuple [] |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                let~ leaf :=
                  M.alloc (|
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "alloc::collections::btree::node::NodeRef")
                          [ Ty.path "alloc::collections::btree::node::marker::Mut"; K; V; NodeType
                          ],
                        "into_leaf_mut",
                        []
                      |),
                      [
                        M.read (|
                          M.SubPointer.get_struct_record_field (|
                            self,
                            "alloc::collections::btree::node::Handle",
                            "node"
                          |)
                        |)
                      ]
                    |)
                  |) in
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ V ],
                      "assume_init_mut",
                      []
                    |),
                    [
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply
                            (Ty.path "slice")
                            [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ V ] ],
                          "get_unchecked_mut",
                          [ Ty.path "usize" ]
                        |),
                        [
                          (* Unsize *)
                          M.pointer_coercion
                            (M.SubPointer.get_struct_record_field (|
                              M.read (| leaf |),
                              "alloc::collections::btree::node::LeafNode",
                              "vals"
                            |));
                          M.read (|
                            M.SubPointer.get_struct_record_field (|
                              self,
                              "alloc::collections::btree::node::Handle",
                              "idx"
                            |)
                          |)
                        ]
                      |)
                    ]
                  |)
                |)
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom AssociatedFunction_into_val_mut :
          forall (K V NodeType : Ty.t),
          M.IsAssociatedFunction (Self K V NodeType) "into_val_mut" (into_val_mut K V NodeType).
        
        (*
            pub fn into_kv_valmut(self) -> (&'a K, &'a mut V) {
                debug_assert!(self.idx < self.node.len());
                let leaf = self.node.into_leaf_mut();
                let k = unsafe { leaf.keys.get_unchecked(self.idx).assume_init_ref() };
                let v = unsafe { leaf.vals.get_unchecked_mut(self.idx).assume_init_mut() };
                (k, v)
            }
        *)
        Definition into_kv_valmut (K V NodeType : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self K V NodeType in
          match τ, α with
          | [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              M.read (|
                let~ _ :=
                  M.match_operator (|
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ := M.use (M.alloc (| Value.Bool true |)) in
                          let _ :=
                            M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          let~ _ :=
                            M.match_operator (|
                              M.alloc (| Value.Tuple [] |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let γ :=
                                      M.use
                                        (M.alloc (|
                                          UnOp.Pure.not
                                            (BinOp.Pure.lt
                                              (M.read (|
                                                M.SubPointer.get_struct_record_field (|
                                                  self,
                                                  "alloc::collections::btree::node::Handle",
                                                  "idx"
                                                |)
                                              |))
                                              (M.call_closure (|
                                                M.get_associated_function (|
                                                  Ty.apply
                                                    (Ty.path
                                                      "alloc::collections::btree::node::NodeRef")
                                                    [
                                                      Ty.path
                                                        "alloc::collections::btree::node::marker::Mut";
                                                      K;
                                                      V;
                                                      NodeType
                                                    ],
                                                  "len",
                                                  []
                                                |),
                                                [
                                                  M.SubPointer.get_struct_record_field (|
                                                    self,
                                                    "alloc::collections::btree::node::Handle",
                                                    "node"
                                                  |)
                                                ]
                                              |)))
                                        |)) in
                                    let _ :=
                                      M.is_constant_or_break_match (|
                                        M.read (| γ |),
                                        Value.Bool true
                                      |) in
                                    M.alloc (|
                                      M.never_to_any (|
                                        M.call_closure (|
                                          M.get_function (| "core::panicking::panic", [] |),
                                          [
                                            M.read (|
                                              Value.String
                                                "assertion failed: self.idx < self.node.len()"
                                            |)
                                          ]
                                        |)
                                      |)
                                    |)));
                                fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                              ]
                            |) in
                          M.alloc (| Value.Tuple [] |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                let~ leaf :=
                  M.alloc (|
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "alloc::collections::btree::node::NodeRef")
                          [ Ty.path "alloc::collections::btree::node::marker::Mut"; K; V; NodeType
                          ],
                        "into_leaf_mut",
                        []
                      |),
                      [
                        M.read (|
                          M.SubPointer.get_struct_record_field (|
                            self,
                            "alloc::collections::btree::node::Handle",
                            "node"
                          |)
                        |)
                      ]
                    |)
                  |) in
                let~ k :=
                  M.alloc (|
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ K ],
                        "assume_init_ref",
                        []
                      |),
                      [
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.apply
                              (Ty.path "slice")
                              [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ K ] ],
                            "get_unchecked",
                            [ Ty.path "usize" ]
                          |),
                          [
                            (* Unsize *)
                            M.pointer_coercion
                              (M.SubPointer.get_struct_record_field (|
                                M.read (| leaf |),
                                "alloc::collections::btree::node::LeafNode",
                                "keys"
                              |));
                            M.read (|
                              M.SubPointer.get_struct_record_field (|
                                self,
                                "alloc::collections::btree::node::Handle",
                                "idx"
                              |)
                            |)
                          ]
                        |)
                      ]
                    |)
                  |) in
                let~ v :=
                  M.alloc (|
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ V ],
                        "assume_init_mut",
                        []
                      |),
                      [
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.apply
                              (Ty.path "slice")
                              [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ V ] ],
                            "get_unchecked_mut",
                            [ Ty.path "usize" ]
                          |),
                          [
                            (* Unsize *)
                            M.pointer_coercion
                              (M.SubPointer.get_struct_record_field (|
                                M.read (| leaf |),
                                "alloc::collections::btree::node::LeafNode",
                                "vals"
                              |));
                            M.read (|
                              M.SubPointer.get_struct_record_field (|
                                self,
                                "alloc::collections::btree::node::Handle",
                                "idx"
                              |)
                            |)
                          ]
                        |)
                      ]
                    |)
                  |) in
                M.alloc (| Value.Tuple [ M.read (| k |); M.read (| v |) ] |)
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom AssociatedFunction_into_kv_valmut :
          forall (K V NodeType : Ty.t),
          M.IsAssociatedFunction (Self K V NodeType) "into_kv_valmut" (into_kv_valmut K V NodeType).
        (*
            pub fn kv_mut(&mut self) -> (&mut K, &mut V) {
                debug_assert!(self.idx < self.node.len());
                // We cannot call separate key and value methods, because calling the second one
                // invalidates the reference returned by the first.
                unsafe {
                    let leaf = self.node.as_leaf_mut();
                    let key = leaf.keys.get_unchecked_mut(self.idx).assume_init_mut();
                    let val = leaf.vals.get_unchecked_mut(self.idx).assume_init_mut();
                    (key, val)
                }
            }
        *)
        Definition kv_mut (K V NodeType : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self K V NodeType in
          match τ, α with
          | [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              M.read (|
                let~ _ :=
                  M.match_operator (|
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ := M.use (M.alloc (| Value.Bool true |)) in
                          let _ :=
                            M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          let~ _ :=
                            M.match_operator (|
                              M.alloc (| Value.Tuple [] |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let γ :=
                                      M.use
                                        (M.alloc (|
                                          UnOp.Pure.not
                                            (BinOp.Pure.lt
                                              (M.read (|
                                                M.SubPointer.get_struct_record_field (|
                                                  M.read (| self |),
                                                  "alloc::collections::btree::node::Handle",
                                                  "idx"
                                                |)
                                              |))
                                              (M.call_closure (|
                                                M.get_associated_function (|
                                                  Ty.apply
                                                    (Ty.path
                                                      "alloc::collections::btree::node::NodeRef")
                                                    [
                                                      Ty.path
                                                        "alloc::collections::btree::node::marker::Mut";
                                                      K;
                                                      V;
                                                      NodeType
                                                    ],
                                                  "len",
                                                  []
                                                |),
                                                [
                                                  M.SubPointer.get_struct_record_field (|
                                                    M.read (| self |),
                                                    "alloc::collections::btree::node::Handle",
                                                    "node"
                                                  |)
                                                ]
                                              |)))
                                        |)) in
                                    let _ :=
                                      M.is_constant_or_break_match (|
                                        M.read (| γ |),
                                        Value.Bool true
                                      |) in
                                    M.alloc (|
                                      M.never_to_any (|
                                        M.call_closure (|
                                          M.get_function (| "core::panicking::panic", [] |),
                                          [
                                            M.read (|
                                              Value.String
                                                "assertion failed: self.idx < self.node.len()"
                                            |)
                                          ]
                                        |)
                                      |)
                                    |)));
                                fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                              ]
                            |) in
                          M.alloc (| Value.Tuple [] |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                let~ leaf :=
                  M.alloc (|
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "alloc::collections::btree::node::NodeRef")
                          [ Ty.path "alloc::collections::btree::node::marker::Mut"; K; V; NodeType
                          ],
                        "as_leaf_mut",
                        []
                      |),
                      [
                        M.SubPointer.get_struct_record_field (|
                          M.read (| self |),
                          "alloc::collections::btree::node::Handle",
                          "node"
                        |)
                      ]
                    |)
                  |) in
                let~ key :=
                  M.alloc (|
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ K ],
                        "assume_init_mut",
                        []
                      |),
                      [
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.apply
                              (Ty.path "slice")
                              [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ K ] ],
                            "get_unchecked_mut",
                            [ Ty.path "usize" ]
                          |),
                          [
                            (* Unsize *)
                            M.pointer_coercion
                              (M.SubPointer.get_struct_record_field (|
                                M.read (| leaf |),
                                "alloc::collections::btree::node::LeafNode",
                                "keys"
                              |));
                            M.read (|
                              M.SubPointer.get_struct_record_field (|
                                M.read (| self |),
                                "alloc::collections::btree::node::Handle",
                                "idx"
                              |)
                            |)
                          ]
                        |)
                      ]
                    |)
                  |) in
                let~ val :=
                  M.alloc (|
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ V ],
                        "assume_init_mut",
                        []
                      |),
                      [
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.apply
                              (Ty.path "slice")
                              [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ V ] ],
                            "get_unchecked_mut",
                            [ Ty.path "usize" ]
                          |),
                          [
                            (* Unsize *)
                            M.pointer_coercion
                              (M.SubPointer.get_struct_record_field (|
                                M.read (| leaf |),
                                "alloc::collections::btree::node::LeafNode",
                                "vals"
                              |));
                            M.read (|
                              M.SubPointer.get_struct_record_field (|
                                M.read (| self |),
                                "alloc::collections::btree::node::Handle",
                                "idx"
                              |)
                            |)
                          ]
                        |)
                      ]
                    |)
                  |) in
                M.alloc (| Value.Tuple [ M.read (| key |); M.read (| val |) ] |)
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom AssociatedFunction_kv_mut :
          forall (K V NodeType : Ty.t),
          M.IsAssociatedFunction (Self K V NodeType) "kv_mut" (kv_mut K V NodeType).
        
        (*
            pub fn replace_kv(&mut self, k: K, v: V) -> (K, V) {
                let (key, val) = self.kv_mut();
                (mem::replace(key, k), mem::replace(val, v))
            }
        *)
        Definition replace_kv (K V NodeType : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self K V NodeType in
          match τ, α with
          | [], [ self; k; v ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let k := M.alloc (| k |) in
              let v := M.alloc (| v |) in
              M.read (|
                M.match_operator (|
                  M.alloc (|
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "alloc::collections::btree::node::Handle")
                          [
                            Ty.apply
                              (Ty.path "alloc::collections::btree::node::NodeRef")
                              [
                                Ty.path "alloc::collections::btree::node::marker::Mut";
                                K;
                                V;
                                NodeType
                              ];
                            Ty.path "alloc::collections::btree::node::marker::KV"
                          ],
                        "kv_mut",
                        []
                      |),
                      [ M.read (| self |) ]
                    |)
                  |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                        let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                        let key := M.copy (| γ0_0 |) in
                        let val := M.copy (| γ0_1 |) in
                        M.alloc (|
                          Value.Tuple
                            [
                              M.call_closure (|
                                M.get_function (| "core::mem::replace", [ K ] |),
                                [ M.read (| key |); M.read (| k |) ]
                              |);
                              M.call_closure (|
                                M.get_function (| "core::mem::replace", [ V ] |),
                                [ M.read (| val |); M.read (| v |) ]
                              |)
                            ]
                        |)))
                  ]
                |)
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom AssociatedFunction_replace_kv :
          forall (K V NodeType : Ty.t),
          M.IsAssociatedFunction (Self K V NodeType) "replace_kv" (replace_kv K V NodeType).
        (*
            fn split_leaf_data(&mut self, new_node: &mut LeafNode<K, V>) -> (K, V) {
                debug_assert!(self.idx < self.node.len());
                let old_len = self.node.len();
                let new_len = old_len - self.idx - 1;
                new_node.len = new_len as u16;
                unsafe {
                    let k = self.node.key_area_mut(self.idx).assume_init_read();
                    let v = self.node.val_area_mut(self.idx).assume_init_read();
        
                    move_to_slice(
                        self.node.key_area_mut(self.idx + 1..old_len),
                        &mut new_node.keys[..new_len],
                    );
                    move_to_slice(
                        self.node.val_area_mut(self.idx + 1..old_len),
                        &mut new_node.vals[..new_len],
                    );
        
                    *self.node.len_mut() = self.idx as u16;
                    (k, v)
                }
            }
        *)
        Definition split_leaf_data (K V NodeType : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self K V NodeType in
          match τ, α with
          | [], [ self; new_node ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let new_node := M.alloc (| new_node |) in
              M.read (|
                let~ _ :=
                  M.match_operator (|
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ := M.use (M.alloc (| Value.Bool true |)) in
                          let _ :=
                            M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          let~ _ :=
                            M.match_operator (|
                              M.alloc (| Value.Tuple [] |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let γ :=
                                      M.use
                                        (M.alloc (|
                                          UnOp.Pure.not
                                            (BinOp.Pure.lt
                                              (M.read (|
                                                M.SubPointer.get_struct_record_field (|
                                                  M.read (| self |),
                                                  "alloc::collections::btree::node::Handle",
                                                  "idx"
                                                |)
                                              |))
                                              (M.call_closure (|
                                                M.get_associated_function (|
                                                  Ty.apply
                                                    (Ty.path
                                                      "alloc::collections::btree::node::NodeRef")
                                                    [
                                                      Ty.path
                                                        "alloc::collections::btree::node::marker::Mut";
                                                      K;
                                                      V;
                                                      NodeType
                                                    ],
                                                  "len",
                                                  []
                                                |),
                                                [
                                                  M.SubPointer.get_struct_record_field (|
                                                    M.read (| self |),
                                                    "alloc::collections::btree::node::Handle",
                                                    "node"
                                                  |)
                                                ]
                                              |)))
                                        |)) in
                                    let _ :=
                                      M.is_constant_or_break_match (|
                                        M.read (| γ |),
                                        Value.Bool true
                                      |) in
                                    M.alloc (|
                                      M.never_to_any (|
                                        M.call_closure (|
                                          M.get_function (| "core::panicking::panic", [] |),
                                          [
                                            M.read (|
                                              Value.String
                                                "assertion failed: self.idx < self.node.len()"
                                            |)
                                          ]
                                        |)
                                      |)
                                    |)));
                                fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                              ]
                            |) in
                          M.alloc (| Value.Tuple [] |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                let~ old_len :=
                  M.alloc (|
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "alloc::collections::btree::node::NodeRef")
                          [ Ty.path "alloc::collections::btree::node::marker::Mut"; K; V; NodeType
                          ],
                        "len",
                        []
                      |),
                      [
                        M.SubPointer.get_struct_record_field (|
                          M.read (| self |),
                          "alloc::collections::btree::node::Handle",
                          "node"
                        |)
                      ]
                    |)
                  |) in
                let~ new_len :=
                  M.alloc (|
                    BinOp.Wrap.sub
                      Integer.Usize
                      (BinOp.Wrap.sub
                        Integer.Usize
                        (M.read (| old_len |))
                        (M.read (|
                          M.SubPointer.get_struct_record_field (|
                            M.read (| self |),
                            "alloc::collections::btree::node::Handle",
                            "idx"
                          |)
                        |)))
                      (Value.Integer 1)
                  |) in
                let~ _ :=
                  M.write (|
                    M.SubPointer.get_struct_record_field (|
                      M.read (| new_node |),
                      "alloc::collections::btree::node::LeafNode",
                      "len"
                    |),
                    M.rust_cast (M.read (| new_len |))
                  |) in
                let~ k :=
                  M.alloc (|
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ K ],
                        "assume_init_read",
                        []
                      |),
                      [
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.apply
                              (Ty.path "alloc::collections::btree::node::NodeRef")
                              [
                                Ty.path "alloc::collections::btree::node::marker::Mut";
                                K;
                                V;
                                NodeType
                              ],
                            "key_area_mut",
                            [
                              Ty.path "usize";
                              Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ K ]
                            ]
                          |),
                          [
                            M.SubPointer.get_struct_record_field (|
                              M.read (| self |),
                              "alloc::collections::btree::node::Handle",
                              "node"
                            |);
                            M.read (|
                              M.SubPointer.get_struct_record_field (|
                                M.read (| self |),
                                "alloc::collections::btree::node::Handle",
                                "idx"
                              |)
                            |)
                          ]
                        |)
                      ]
                    |)
                  |) in
                let~ v :=
                  M.alloc (|
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ V ],
                        "assume_init_read",
                        []
                      |),
                      [
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.apply
                              (Ty.path "alloc::collections::btree::node::NodeRef")
                              [
                                Ty.path "alloc::collections::btree::node::marker::Mut";
                                K;
                                V;
                                NodeType
                              ],
                            "val_area_mut",
                            [
                              Ty.path "usize";
                              Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ V ]
                            ]
                          |),
                          [
                            M.SubPointer.get_struct_record_field (|
                              M.read (| self |),
                              "alloc::collections::btree::node::Handle",
                              "node"
                            |);
                            M.read (|
                              M.SubPointer.get_struct_record_field (|
                                M.read (| self |),
                                "alloc::collections::btree::node::Handle",
                                "idx"
                              |)
                            |)
                          ]
                        |)
                      ]
                    |)
                  |) in
                let~ _ :=
                  M.alloc (|
                    M.call_closure (|
                      M.get_function (| "alloc::collections::btree::node::move_to_slice", [ K ] |),
                      [
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.apply
                              (Ty.path "alloc::collections::btree::node::NodeRef")
                              [
                                Ty.path "alloc::collections::btree::node::marker::Mut";
                                K;
                                V;
                                NodeType
                              ],
                            "key_area_mut",
                            [
                              Ty.apply (Ty.path "core::ops::range::Range") [ Ty.path "usize" ];
                              Ty.apply
                                (Ty.path "slice")
                                [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ K ] ]
                            ]
                          |),
                          [
                            M.SubPointer.get_struct_record_field (|
                              M.read (| self |),
                              "alloc::collections::btree::node::Handle",
                              "node"
                            |);
                            Value.StructRecord
                              "core::ops::range::Range"
                              [
                                ("start",
                                  BinOp.Wrap.add
                                    Integer.Usize
                                    (M.read (|
                                      M.SubPointer.get_struct_record_field (|
                                        M.read (| self |),
                                        "alloc::collections::btree::node::Handle",
                                        "idx"
                                      |)
                                    |))
                                    (Value.Integer 1));
                                ("end_", M.read (| old_len |))
                              ]
                          ]
                        |);
                        M.call_closure (|
                          M.get_trait_method (|
                            "core::ops::index::IndexMut",
                            Ty.apply
                              (Ty.path "array")
                              [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ K ] ],
                            [ Ty.apply (Ty.path "core::ops::range::RangeTo") [ Ty.path "usize" ] ],
                            "index_mut",
                            []
                          |),
                          [
                            M.SubPointer.get_struct_record_field (|
                              M.read (| new_node |),
                              "alloc::collections::btree::node::LeafNode",
                              "keys"
                            |);
                            Value.StructRecord
                              "core::ops::range::RangeTo"
                              [ ("end_", M.read (| new_len |)) ]
                          ]
                        |)
                      ]
                    |)
                  |) in
                let~ _ :=
                  M.alloc (|
                    M.call_closure (|
                      M.get_function (| "alloc::collections::btree::node::move_to_slice", [ V ] |),
                      [
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.apply
                              (Ty.path "alloc::collections::btree::node::NodeRef")
                              [
                                Ty.path "alloc::collections::btree::node::marker::Mut";
                                K;
                                V;
                                NodeType
                              ],
                            "val_area_mut",
                            [
                              Ty.apply (Ty.path "core::ops::range::Range") [ Ty.path "usize" ];
                              Ty.apply
                                (Ty.path "slice")
                                [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ V ] ]
                            ]
                          |),
                          [
                            M.SubPointer.get_struct_record_field (|
                              M.read (| self |),
                              "alloc::collections::btree::node::Handle",
                              "node"
                            |);
                            Value.StructRecord
                              "core::ops::range::Range"
                              [
                                ("start",
                                  BinOp.Wrap.add
                                    Integer.Usize
                                    (M.read (|
                                      M.SubPointer.get_struct_record_field (|
                                        M.read (| self |),
                                        "alloc::collections::btree::node::Handle",
                                        "idx"
                                      |)
                                    |))
                                    (Value.Integer 1));
                                ("end_", M.read (| old_len |))
                              ]
                          ]
                        |);
                        M.call_closure (|
                          M.get_trait_method (|
                            "core::ops::index::IndexMut",
                            Ty.apply
                              (Ty.path "array")
                              [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ V ] ],
                            [ Ty.apply (Ty.path "core::ops::range::RangeTo") [ Ty.path "usize" ] ],
                            "index_mut",
                            []
                          |),
                          [
                            M.SubPointer.get_struct_record_field (|
                              M.read (| new_node |),
                              "alloc::collections::btree::node::LeafNode",
                              "vals"
                            |);
                            Value.StructRecord
                              "core::ops::range::RangeTo"
                              [ ("end_", M.read (| new_len |)) ]
                          ]
                        |)
                      ]
                    |)
                  |) in
                let~ _ :=
                  M.write (|
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "alloc::collections::btree::node::NodeRef")
                          [ Ty.path "alloc::collections::btree::node::marker::Mut"; K; V; NodeType
                          ],
                        "len_mut",
                        []
                      |),
                      [
                        M.SubPointer.get_struct_record_field (|
                          M.read (| self |),
                          "alloc::collections::btree::node::Handle",
                          "node"
                        |)
                      ]
                    |),
                    M.rust_cast
                      (M.read (|
                        M.SubPointer.get_struct_record_field (|
                          M.read (| self |),
                          "alloc::collections::btree::node::Handle",
                          "idx"
                        |)
                      |))
                  |) in
                M.alloc (| Value.Tuple [ M.read (| k |); M.read (| v |) ] |)
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom AssociatedFunction_split_leaf_data :
          forall (K V NodeType : Ty.t),
          M.IsAssociatedFunction
            (Self K V NodeType)
            "split_leaf_data"
            (split_leaf_data K V NodeType).
      End Impl_alloc_collections_btree_node_Handle_alloc_collections_btree_node_NodeRef_alloc_collections_btree_node_marker_Mut_K_V_NodeType_alloc_collections_btree_node_marker_KV.
      
      Module Impl_alloc_collections_btree_node_Handle_alloc_collections_btree_node_NodeRef_alloc_collections_btree_node_marker_ValMut_K_V_NodeType_alloc_collections_btree_node_marker_KV.
        Definition Self (K V NodeType : Ty.t) : Ty.t :=
          Ty.apply
            (Ty.path "alloc::collections::btree::node::Handle")
            [
              Ty.apply
                (Ty.path "alloc::collections::btree::node::NodeRef")
                [ Ty.path "alloc::collections::btree::node::marker::ValMut"; K; V; NodeType ];
              Ty.path "alloc::collections::btree::node::marker::KV"
            ].
        
        (*
            pub fn into_kv_valmut(self) -> (&'a K, &'a mut V) {
                unsafe { self.node.into_key_val_mut_at(self.idx) }
            }
        *)
        Definition into_kv_valmut (K V NodeType : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self K V NodeType in
          match τ, α with
          | [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "alloc::collections::btree::node::NodeRef")
                    [ Ty.path "alloc::collections::btree::node::marker::ValMut"; K; V; NodeType ],
                  "into_key_val_mut_at",
                  []
                |),
                [
                  M.read (|
                    M.SubPointer.get_struct_record_field (|
                      self,
                      "alloc::collections::btree::node::Handle",
                      "node"
                    |)
                  |);
                  M.read (|
                    M.SubPointer.get_struct_record_field (|
                      self,
                      "alloc::collections::btree::node::Handle",
                      "idx"
                    |)
                  |)
                ]
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom AssociatedFunction_into_kv_valmut :
          forall (K V NodeType : Ty.t),
          M.IsAssociatedFunction (Self K V NodeType) "into_kv_valmut" (into_kv_valmut K V NodeType).
      End Impl_alloc_collections_btree_node_Handle_alloc_collections_btree_node_NodeRef_alloc_collections_btree_node_marker_ValMut_K_V_NodeType_alloc_collections_btree_node_marker_KV.
      
      
      Module Impl_alloc_collections_btree_node_Handle_alloc_collections_btree_node_NodeRef_alloc_collections_btree_node_marker_Dying_K_V_NodeType_alloc_collections_btree_node_marker_KV.
        Definition Self (K V NodeType : Ty.t) : Ty.t :=
          Ty.apply
            (Ty.path "alloc::collections::btree::node::Handle")
            [
              Ty.apply
                (Ty.path "alloc::collections::btree::node::NodeRef")
                [ Ty.path "alloc::collections::btree::node::marker::Dying"; K; V; NodeType ];
              Ty.path "alloc::collections::btree::node::marker::KV"
            ].
        
        (*
            pub unsafe fn into_key_val(mut self) -> (K, V) {
                debug_assert!(self.idx < self.node.len());
                let leaf = self.node.as_leaf_dying();
                unsafe {
                    let key = leaf.keys.get_unchecked_mut(self.idx).assume_init_read();
                    let val = leaf.vals.get_unchecked_mut(self.idx).assume_init_read();
                    (key, val)
                }
            }
        *)
        Definition into_key_val (K V NodeType : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self K V NodeType in
          match τ, α with
          | [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              M.read (|
                let~ _ :=
                  M.match_operator (|
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ := M.use (M.alloc (| Value.Bool true |)) in
                          let _ :=
                            M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          let~ _ :=
                            M.match_operator (|
                              M.alloc (| Value.Tuple [] |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let γ :=
                                      M.use
                                        (M.alloc (|
                                          UnOp.Pure.not
                                            (BinOp.Pure.lt
                                              (M.read (|
                                                M.SubPointer.get_struct_record_field (|
                                                  self,
                                                  "alloc::collections::btree::node::Handle",
                                                  "idx"
                                                |)
                                              |))
                                              (M.call_closure (|
                                                M.get_associated_function (|
                                                  Ty.apply
                                                    (Ty.path
                                                      "alloc::collections::btree::node::NodeRef")
                                                    [
                                                      Ty.path
                                                        "alloc::collections::btree::node::marker::Dying";
                                                      K;
                                                      V;
                                                      NodeType
                                                    ],
                                                  "len",
                                                  []
                                                |),
                                                [
                                                  M.SubPointer.get_struct_record_field (|
                                                    self,
                                                    "alloc::collections::btree::node::Handle",
                                                    "node"
                                                  |)
                                                ]
                                              |)))
                                        |)) in
                                    let _ :=
                                      M.is_constant_or_break_match (|
                                        M.read (| γ |),
                                        Value.Bool true
                                      |) in
                                    M.alloc (|
                                      M.never_to_any (|
                                        M.call_closure (|
                                          M.get_function (| "core::panicking::panic", [] |),
                                          [
                                            M.read (|
                                              Value.String
                                                "assertion failed: self.idx < self.node.len()"
                                            |)
                                          ]
                                        |)
                                      |)
                                    |)));
                                fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                              ]
                            |) in
                          M.alloc (| Value.Tuple [] |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                let~ leaf :=
                  M.alloc (|
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "alloc::collections::btree::node::NodeRef")
                          [ Ty.path "alloc::collections::btree::node::marker::Dying"; K; V; NodeType
                          ],
                        "as_leaf_dying",
                        []
                      |),
                      [
                        M.SubPointer.get_struct_record_field (|
                          self,
                          "alloc::collections::btree::node::Handle",
                          "node"
                        |)
                      ]
                    |)
                  |) in
                let~ key :=
                  M.alloc (|
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ K ],
                        "assume_init_read",
                        []
                      |),
                      [
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.apply
                              (Ty.path "slice")
                              [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ K ] ],
                            "get_unchecked_mut",
                            [ Ty.path "usize" ]
                          |),
                          [
                            (* Unsize *)
                            M.pointer_coercion
                              (M.SubPointer.get_struct_record_field (|
                                M.read (| leaf |),
                                "alloc::collections::btree::node::LeafNode",
                                "keys"
                              |));
                            M.read (|
                              M.SubPointer.get_struct_record_field (|
                                self,
                                "alloc::collections::btree::node::Handle",
                                "idx"
                              |)
                            |)
                          ]
                        |)
                      ]
                    |)
                  |) in
                let~ val :=
                  M.alloc (|
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ V ],
                        "assume_init_read",
                        []
                      |),
                      [
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.apply
                              (Ty.path "slice")
                              [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ V ] ],
                            "get_unchecked_mut",
                            [ Ty.path "usize" ]
                          |),
                          [
                            (* Unsize *)
                            M.pointer_coercion
                              (M.SubPointer.get_struct_record_field (|
                                M.read (| leaf |),
                                "alloc::collections::btree::node::LeafNode",
                                "vals"
                              |));
                            M.read (|
                              M.SubPointer.get_struct_record_field (|
                                self,
                                "alloc::collections::btree::node::Handle",
                                "idx"
                              |)
                            |)
                          ]
                        |)
                      ]
                    |)
                  |) in
                M.alloc (| Value.Tuple [ M.read (| key |); M.read (| val |) ] |)
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom AssociatedFunction_into_key_val :
          forall (K V NodeType : Ty.t),
          M.IsAssociatedFunction (Self K V NodeType) "into_key_val" (into_key_val K V NodeType).
        
        (*
            pub unsafe fn drop_key_val(mut self) {
                debug_assert!(self.idx < self.node.len());
                let leaf = self.node.as_leaf_dying();
                unsafe {
                    leaf.keys.get_unchecked_mut(self.idx).assume_init_drop();
                    leaf.vals.get_unchecked_mut(self.idx).assume_init_drop();
                }
            }
        *)
        Definition drop_key_val (K V NodeType : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self K V NodeType in
          match τ, α with
          | [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              M.read (|
                let~ _ :=
                  M.match_operator (|
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ := M.use (M.alloc (| Value.Bool true |)) in
                          let _ :=
                            M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          let~ _ :=
                            M.match_operator (|
                              M.alloc (| Value.Tuple [] |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let γ :=
                                      M.use
                                        (M.alloc (|
                                          UnOp.Pure.not
                                            (BinOp.Pure.lt
                                              (M.read (|
                                                M.SubPointer.get_struct_record_field (|
                                                  self,
                                                  "alloc::collections::btree::node::Handle",
                                                  "idx"
                                                |)
                                              |))
                                              (M.call_closure (|
                                                M.get_associated_function (|
                                                  Ty.apply
                                                    (Ty.path
                                                      "alloc::collections::btree::node::NodeRef")
                                                    [
                                                      Ty.path
                                                        "alloc::collections::btree::node::marker::Dying";
                                                      K;
                                                      V;
                                                      NodeType
                                                    ],
                                                  "len",
                                                  []
                                                |),
                                                [
                                                  M.SubPointer.get_struct_record_field (|
                                                    self,
                                                    "alloc::collections::btree::node::Handle",
                                                    "node"
                                                  |)
                                                ]
                                              |)))
                                        |)) in
                                    let _ :=
                                      M.is_constant_or_break_match (|
                                        M.read (| γ |),
                                        Value.Bool true
                                      |) in
                                    M.alloc (|
                                      M.never_to_any (|
                                        M.call_closure (|
                                          M.get_function (| "core::panicking::panic", [] |),
                                          [
                                            M.read (|
                                              Value.String
                                                "assertion failed: self.idx < self.node.len()"
                                            |)
                                          ]
                                        |)
                                      |)
                                    |)));
                                fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                              ]
                            |) in
                          M.alloc (| Value.Tuple [] |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                let~ leaf :=
                  M.alloc (|
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "alloc::collections::btree::node::NodeRef")
                          [ Ty.path "alloc::collections::btree::node::marker::Dying"; K; V; NodeType
                          ],
                        "as_leaf_dying",
                        []
                      |),
                      [
                        M.SubPointer.get_struct_record_field (|
                          self,
                          "alloc::collections::btree::node::Handle",
                          "node"
                        |)
                      ]
                    |)
                  |) in
                let~ _ :=
                  M.alloc (|
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ K ],
                        "assume_init_drop",
                        []
                      |),
                      [
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.apply
                              (Ty.path "slice")
                              [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ K ] ],
                            "get_unchecked_mut",
                            [ Ty.path "usize" ]
                          |),
                          [
                            (* Unsize *)
                            M.pointer_coercion
                              (M.SubPointer.get_struct_record_field (|
                                M.read (| leaf |),
                                "alloc::collections::btree::node::LeafNode",
                                "keys"
                              |));
                            M.read (|
                              M.SubPointer.get_struct_record_field (|
                                self,
                                "alloc::collections::btree::node::Handle",
                                "idx"
                              |)
                            |)
                          ]
                        |)
                      ]
                    |)
                  |) in
                let~ _ :=
                  M.alloc (|
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ V ],
                        "assume_init_drop",
                        []
                      |),
                      [
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.apply
                              (Ty.path "slice")
                              [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ V ] ],
                            "get_unchecked_mut",
                            [ Ty.path "usize" ]
                          |),
                          [
                            (* Unsize *)
                            M.pointer_coercion
                              (M.SubPointer.get_struct_record_field (|
                                M.read (| leaf |),
                                "alloc::collections::btree::node::LeafNode",
                                "vals"
                              |));
                            M.read (|
                              M.SubPointer.get_struct_record_field (|
                                self,
                                "alloc::collections::btree::node::Handle",
                                "idx"
                              |)
                            |)
                          ]
                        |)
                      ]
                    |)
                  |) in
                M.alloc (| Value.Tuple [] |)
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom AssociatedFunction_drop_key_val :
          forall (K V NodeType : Ty.t),
          M.IsAssociatedFunction (Self K V NodeType) "drop_key_val" (drop_key_val K V NodeType).
      End Impl_alloc_collections_btree_node_Handle_alloc_collections_btree_node_NodeRef_alloc_collections_btree_node_marker_Dying_K_V_NodeType_alloc_collections_btree_node_marker_KV.
      
      
      Module Impl_alloc_collections_btree_node_Handle_alloc_collections_btree_node_NodeRef_alloc_collections_btree_node_marker_Mut_K_V_alloc_collections_btree_node_marker_Leaf_alloc_collections_btree_node_marker_KV.
        Definition Self (K V : Ty.t) : Ty.t :=
          Ty.apply
            (Ty.path "alloc::collections::btree::node::Handle")
            [
              Ty.apply
                (Ty.path "alloc::collections::btree::node::NodeRef")
                [
                  Ty.path "alloc::collections::btree::node::marker::Mut";
                  K;
                  V;
                  Ty.path "alloc::collections::btree::node::marker::Leaf"
                ];
              Ty.path "alloc::collections::btree::node::marker::KV"
            ].
        
        (*
            pub fn split<A: Allocator + Clone>(mut self, alloc: A) -> SplitResult<'a, K, V, marker::Leaf> {
                let mut new_node = LeafNode::new(alloc);
        
                let kv = self.split_leaf_data(&mut new_node);
        
                let right = NodeRef::from_new_leaf(new_node);
                SplitResult { left: self.node, kv, right }
            }
        *)
        Definition split (K V : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self K V in
          match τ, α with
          | [ A ], [ self; alloc ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let alloc := M.alloc (| alloc |) in
              M.read (|
                let~ new_node :=
                  M.alloc (|
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "alloc::collections::btree::node::LeafNode") [ K; V ],
                        "new",
                        [ A ]
                      |),
                      [ M.read (| alloc |) ]
                    |)
                  |) in
                let~ kv :=
                  M.alloc (|
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "alloc::collections::btree::node::Handle")
                          [
                            Ty.apply
                              (Ty.path "alloc::collections::btree::node::NodeRef")
                              [
                                Ty.path "alloc::collections::btree::node::marker::Mut";
                                K;
                                V;
                                Ty.path "alloc::collections::btree::node::marker::Leaf"
                              ];
                            Ty.path "alloc::collections::btree::node::marker::KV"
                          ],
                        "split_leaf_data",
                        []
                      |),
                      [ self; M.read (| new_node |) ]
                    |)
                  |) in
                let~ right :=
                  M.alloc (|
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "alloc::collections::btree::node::NodeRef")
                          [
                            Ty.path "alloc::collections::btree::node::marker::Owned";
                            K;
                            V;
                            Ty.path "alloc::collections::btree::node::marker::Leaf"
                          ],
                        "from_new_leaf",
                        [ A ]
                      |),
                      [ M.read (| new_node |) ]
                    |)
                  |) in
                M.alloc (|
                  Value.StructRecord
                    "alloc::collections::btree::node::SplitResult"
                    [
                      ("left",
                        M.read (|
                          M.SubPointer.get_struct_record_field (|
                            self,
                            "alloc::collections::btree::node::Handle",
                            "node"
                          |)
                        |));
                      ("kv", M.read (| kv |));
                      ("right", M.read (| right |))
                    ]
                |)
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom AssociatedFunction_split :
          forall (K V : Ty.t),
          M.IsAssociatedFunction (Self K V) "split" (split K V).
        
        (*
            pub fn remove(
                mut self,
            ) -> ((K, V), Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::Edge>) {
                let old_len = self.node.len();
                unsafe {
                    let k = slice_remove(self.node.key_area_mut(..old_len), self.idx);
                    let v = slice_remove(self.node.val_area_mut(..old_len), self.idx);
                    *self.node.len_mut() = (old_len - 1) as u16;
                    ((k, v), self.left_edge())
                }
            }
        *)
        Definition remove (K V : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self K V in
          match τ, α with
          | [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              M.read (|
                let~ old_len :=
                  M.alloc (|
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "alloc::collections::btree::node::NodeRef")
                          [
                            Ty.path "alloc::collections::btree::node::marker::Mut";
                            K;
                            V;
                            Ty.path "alloc::collections::btree::node::marker::Leaf"
                          ],
                        "len",
                        []
                      |),
                      [
                        M.SubPointer.get_struct_record_field (|
                          self,
                          "alloc::collections::btree::node::Handle",
                          "node"
                        |)
                      ]
                    |)
                  |) in
                let~ k :=
                  M.alloc (|
                    M.call_closure (|
                      M.get_function (| "alloc::collections::btree::node::slice_remove", [ K ] |),
                      [
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.apply
                              (Ty.path "alloc::collections::btree::node::NodeRef")
                              [
                                Ty.path "alloc::collections::btree::node::marker::Mut";
                                K;
                                V;
                                Ty.path "alloc::collections::btree::node::marker::Leaf"
                              ],
                            "key_area_mut",
                            [
                              Ty.apply (Ty.path "core::ops::range::RangeTo") [ Ty.path "usize" ];
                              Ty.apply
                                (Ty.path "slice")
                                [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ K ] ]
                            ]
                          |),
                          [
                            M.SubPointer.get_struct_record_field (|
                              self,
                              "alloc::collections::btree::node::Handle",
                              "node"
                            |);
                            Value.StructRecord
                              "core::ops::range::RangeTo"
                              [ ("end_", M.read (| old_len |)) ]
                          ]
                        |);
                        M.read (|
                          M.SubPointer.get_struct_record_field (|
                            self,
                            "alloc::collections::btree::node::Handle",
                            "idx"
                          |)
                        |)
                      ]
                    |)
                  |) in
                let~ v :=
                  M.alloc (|
                    M.call_closure (|
                      M.get_function (| "alloc::collections::btree::node::slice_remove", [ V ] |),
                      [
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.apply
                              (Ty.path "alloc::collections::btree::node::NodeRef")
                              [
                                Ty.path "alloc::collections::btree::node::marker::Mut";
                                K;
                                V;
                                Ty.path "alloc::collections::btree::node::marker::Leaf"
                              ],
                            "val_area_mut",
                            [
                              Ty.apply (Ty.path "core::ops::range::RangeTo") [ Ty.path "usize" ];
                              Ty.apply
                                (Ty.path "slice")
                                [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ V ] ]
                            ]
                          |),
                          [
                            M.SubPointer.get_struct_record_field (|
                              self,
                              "alloc::collections::btree::node::Handle",
                              "node"
                            |);
                            Value.StructRecord
                              "core::ops::range::RangeTo"
                              [ ("end_", M.read (| old_len |)) ]
                          ]
                        |);
                        M.read (|
                          M.SubPointer.get_struct_record_field (|
                            self,
                            "alloc::collections::btree::node::Handle",
                            "idx"
                          |)
                        |)
                      ]
                    |)
                  |) in
                let~ _ :=
                  M.write (|
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "alloc::collections::btree::node::NodeRef")
                          [
                            Ty.path "alloc::collections::btree::node::marker::Mut";
                            K;
                            V;
                            Ty.path "alloc::collections::btree::node::marker::Leaf"
                          ],
                        "len_mut",
                        []
                      |),
                      [
                        M.SubPointer.get_struct_record_field (|
                          self,
                          "alloc::collections::btree::node::Handle",
                          "node"
                        |)
                      ]
                    |),
                    M.rust_cast
                      (BinOp.Wrap.sub Integer.Usize (M.read (| old_len |)) (Value.Integer 1))
                  |) in
                M.alloc (|
                  Value.Tuple
                    [
                      Value.Tuple [ M.read (| k |); M.read (| v |) ];
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply
                            (Ty.path "alloc::collections::btree::node::Handle")
                            [
                              Ty.apply
                                (Ty.path "alloc::collections::btree::node::NodeRef")
                                [
                                  Ty.path "alloc::collections::btree::node::marker::Mut";
                                  K;
                                  V;
                                  Ty.path "alloc::collections::btree::node::marker::Leaf"
                                ];
                              Ty.path "alloc::collections::btree::node::marker::KV"
                            ],
                          "left_edge",
                          []
                        |),
                        [ M.read (| self |) ]
                      |)
                    ]
                |)
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom AssociatedFunction_remove :
          forall (K V : Ty.t),
          M.IsAssociatedFunction (Self K V) "remove" (remove K V).
      End Impl_alloc_collections_btree_node_Handle_alloc_collections_btree_node_NodeRef_alloc_collections_btree_node_marker_Mut_K_V_alloc_collections_btree_node_marker_Leaf_alloc_collections_btree_node_marker_KV.
      
      Module Impl_alloc_collections_btree_node_Handle_alloc_collections_btree_node_NodeRef_alloc_collections_btree_node_marker_Mut_K_V_alloc_collections_btree_node_marker_Internal_alloc_collections_btree_node_marker_KV.
        Definition Self (K V : Ty.t) : Ty.t :=
          Ty.apply
            (Ty.path "alloc::collections::btree::node::Handle")
            [
              Ty.apply
                (Ty.path "alloc::collections::btree::node::NodeRef")
                [
                  Ty.path "alloc::collections::btree::node::marker::Mut";
                  K;
                  V;
                  Ty.path "alloc::collections::btree::node::marker::Internal"
                ];
              Ty.path "alloc::collections::btree::node::marker::KV"
            ].
        
        (*
            pub fn split<A: Allocator + Clone>(
                mut self,
                alloc: A,
            ) -> SplitResult<'a, K, V, marker::Internal> {
                let old_len = self.node.len();
                unsafe {
                    let mut new_node = InternalNode::new(alloc);
                    let kv = self.split_leaf_data(&mut new_node.data);
                    let new_len = usize::from(new_node.data.len);
                    move_to_slice(
                        self.node.edge_area_mut(self.idx + 1..old_len + 1),
                        &mut new_node.edges[..new_len + 1],
                    );
        
                    let height = self.node.height;
                    let right = NodeRef::from_new_internal(new_node, height);
        
                    SplitResult { left: self.node, kv, right }
                }
            }
        *)
        Definition split (K V : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self K V in
          match τ, α with
          | [ A ], [ self; alloc ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let alloc := M.alloc (| alloc |) in
              M.read (|
                let~ old_len :=
                  M.alloc (|
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "alloc::collections::btree::node::NodeRef")
                          [
                            Ty.path "alloc::collections::btree::node::marker::Mut";
                            K;
                            V;
                            Ty.path "alloc::collections::btree::node::marker::Internal"
                          ],
                        "len",
                        []
                      |),
                      [
                        M.SubPointer.get_struct_record_field (|
                          self,
                          "alloc::collections::btree::node::Handle",
                          "node"
                        |)
                      ]
                    |)
                  |) in
                let~ new_node :=
                  M.alloc (|
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "alloc::collections::btree::node::InternalNode") [ K; V ],
                        "new",
                        [ A ]
                      |),
                      [ M.read (| alloc |) ]
                    |)
                  |) in
                let~ kv :=
                  M.alloc (|
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "alloc::collections::btree::node::Handle")
                          [
                            Ty.apply
                              (Ty.path "alloc::collections::btree::node::NodeRef")
                              [
                                Ty.path "alloc::collections::btree::node::marker::Mut";
                                K;
                                V;
                                Ty.path "alloc::collections::btree::node::marker::Internal"
                              ];
                            Ty.path "alloc::collections::btree::node::marker::KV"
                          ],
                        "split_leaf_data",
                        []
                      |),
                      [
                        self;
                        M.SubPointer.get_struct_record_field (|
                          M.read (| new_node |),
                          "alloc::collections::btree::node::InternalNode",
                          "data"
                        |)
                      ]
                    |)
                  |) in
                let~ new_len :=
                  M.alloc (|
                    M.call_closure (|
                      M.get_trait_method (|
                        "core::convert::From",
                        Ty.path "usize",
                        [ Ty.path "u16" ],
                        "from",
                        []
                      |),
                      [
                        M.read (|
                          M.SubPointer.get_struct_record_field (|
                            M.SubPointer.get_struct_record_field (|
                              M.read (| new_node |),
                              "alloc::collections::btree::node::InternalNode",
                              "data"
                            |),
                            "alloc::collections::btree::node::LeafNode",
                            "len"
                          |)
                        |)
                      ]
                    |)
                  |) in
                let~ _ :=
                  M.alloc (|
                    M.call_closure (|
                      M.get_function (|
                        "alloc::collections::btree::node::move_to_slice",
                        [
                          Ty.apply
                            (Ty.path "core::ptr::non_null::NonNull")
                            [
                              Ty.apply
                                (Ty.path "alloc::collections::btree::node::LeafNode")
                                [ K; V ]
                            ]
                        ]
                      |),
                      [
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.apply
                              (Ty.path "alloc::collections::btree::node::NodeRef")
                              [
                                Ty.path "alloc::collections::btree::node::marker::Mut";
                                K;
                                V;
                                Ty.path "alloc::collections::btree::node::marker::Internal"
                              ],
                            "edge_area_mut",
                            [
                              Ty.apply (Ty.path "core::ops::range::Range") [ Ty.path "usize" ];
                              Ty.apply
                                (Ty.path "slice")
                                [
                                  Ty.apply
                                    (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                    [
                                      Ty.apply
                                        (Ty.path "core::ptr::non_null::NonNull")
                                        [
                                          Ty.apply
                                            (Ty.path "alloc::collections::btree::node::LeafNode")
                                            [ K; V ]
                                        ]
                                    ]
                                ]
                            ]
                          |),
                          [
                            M.SubPointer.get_struct_record_field (|
                              self,
                              "alloc::collections::btree::node::Handle",
                              "node"
                            |);
                            Value.StructRecord
                              "core::ops::range::Range"
                              [
                                ("start",
                                  BinOp.Wrap.add
                                    Integer.Usize
                                    (M.read (|
                                      M.SubPointer.get_struct_record_field (|
                                        self,
                                        "alloc::collections::btree::node::Handle",
                                        "idx"
                                      |)
                                    |))
                                    (Value.Integer 1));
                                ("end_",
                                  BinOp.Wrap.add
                                    Integer.Usize
                                    (M.read (| old_len |))
                                    (Value.Integer 1))
                              ]
                          ]
                        |);
                        M.call_closure (|
                          M.get_trait_method (|
                            "core::ops::index::IndexMut",
                            Ty.apply
                              (Ty.path "array")
                              [
                                Ty.apply
                                  (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                  [
                                    Ty.apply
                                      (Ty.path "core::ptr::non_null::NonNull")
                                      [
                                        Ty.apply
                                          (Ty.path "alloc::collections::btree::node::LeafNode")
                                          [ K; V ]
                                      ]
                                  ]
                              ],
                            [ Ty.apply (Ty.path "core::ops::range::RangeTo") [ Ty.path "usize" ] ],
                            "index_mut",
                            []
                          |),
                          [
                            M.SubPointer.get_struct_record_field (|
                              M.read (| new_node |),
                              "alloc::collections::btree::node::InternalNode",
                              "edges"
                            |);
                            Value.StructRecord
                              "core::ops::range::RangeTo"
                              [
                                ("end_",
                                  BinOp.Wrap.add
                                    Integer.Usize
                                    (M.read (| new_len |))
                                    (Value.Integer 1))
                              ]
                          ]
                        |)
                      ]
                    |)
                  |) in
                let~ height :=
                  M.copy (|
                    M.SubPointer.get_struct_record_field (|
                      M.SubPointer.get_struct_record_field (|
                        self,
                        "alloc::collections::btree::node::Handle",
                        "node"
                      |),
                      "alloc::collections::btree::node::NodeRef",
                      "height"
                    |)
                  |) in
                let~ right :=
                  M.alloc (|
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "alloc::collections::btree::node::NodeRef")
                          [
                            Ty.path "alloc::collections::btree::node::marker::Owned";
                            K;
                            V;
                            Ty.path "alloc::collections::btree::node::marker::Internal"
                          ],
                        "from_new_internal",
                        [ A ]
                      |),
                      [ M.read (| new_node |); M.read (| height |) ]
                    |)
                  |) in
                M.alloc (|
                  Value.StructRecord
                    "alloc::collections::btree::node::SplitResult"
                    [
                      ("left",
                        M.read (|
                          M.SubPointer.get_struct_record_field (|
                            self,
                            "alloc::collections::btree::node::Handle",
                            "node"
                          |)
                        |));
                      ("kv", M.read (| kv |));
                      ("right", M.read (| right |))
                    ]
                |)
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom AssociatedFunction_split :
          forall (K V : Ty.t),
          M.IsAssociatedFunction (Self K V) "split" (split K V).
        (*
            pub fn consider_for_balancing(self) -> BalancingContext<'a, K, V> {
                let self1 = unsafe { ptr::read(&self) };
                let self2 = unsafe { ptr::read(&self) };
                BalancingContext {
                    parent: self,
                    left_child: self1.left_edge().descend(),
                    right_child: self2.right_edge().descend(),
                }
            }
        *)
        Definition consider_for_balancing (K V : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self K V in
          match τ, α with
          | [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              M.read (|
                let~ self1 :=
                  M.alloc (|
                    M.call_closure (|
                      M.get_function (|
                        "core::ptr::read",
                        [
                          Ty.apply
                            (Ty.path "alloc::collections::btree::node::Handle")
                            [
                              Ty.apply
                                (Ty.path "alloc::collections::btree::node::NodeRef")
                                [
                                  Ty.path "alloc::collections::btree::node::marker::Mut";
                                  K;
                                  V;
                                  Ty.path "alloc::collections::btree::node::marker::Internal"
                                ];
                              Ty.path "alloc::collections::btree::node::marker::KV"
                            ]
                        ]
                      |),
                      [ self ]
                    |)
                  |) in
                let~ self2 :=
                  M.alloc (|
                    M.call_closure (|
                      M.get_function (|
                        "core::ptr::read",
                        [
                          Ty.apply
                            (Ty.path "alloc::collections::btree::node::Handle")
                            [
                              Ty.apply
                                (Ty.path "alloc::collections::btree::node::NodeRef")
                                [
                                  Ty.path "alloc::collections::btree::node::marker::Mut";
                                  K;
                                  V;
                                  Ty.path "alloc::collections::btree::node::marker::Internal"
                                ];
                              Ty.path "alloc::collections::btree::node::marker::KV"
                            ]
                        ]
                      |),
                      [ self ]
                    |)
                  |) in
                M.alloc (|
                  Value.StructRecord
                    "alloc::collections::btree::node::BalancingContext"
                    [
                      ("parent", M.read (| self |));
                      ("left_child",
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.apply
                              (Ty.path "alloc::collections::btree::node::Handle")
                              [
                                Ty.apply
                                  (Ty.path "alloc::collections::btree::node::NodeRef")
                                  [
                                    Ty.path "alloc::collections::btree::node::marker::Mut";
                                    K;
                                    V;
                                    Ty.path "alloc::collections::btree::node::marker::Internal"
                                  ];
                                Ty.path "alloc::collections::btree::node::marker::Edge"
                              ],
                            "descend",
                            []
                          |),
                          [
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "alloc::collections::btree::node::Handle")
                                  [
                                    Ty.apply
                                      (Ty.path "alloc::collections::btree::node::NodeRef")
                                      [
                                        Ty.path "alloc::collections::btree::node::marker::Mut";
                                        K;
                                        V;
                                        Ty.path "alloc::collections::btree::node::marker::Internal"
                                      ];
                                    Ty.path "alloc::collections::btree::node::marker::KV"
                                  ],
                                "left_edge",
                                []
                              |),
                              [ M.read (| self1 |) ]
                            |)
                          ]
                        |));
                      ("right_child",
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.apply
                              (Ty.path "alloc::collections::btree::node::Handle")
                              [
                                Ty.apply
                                  (Ty.path "alloc::collections::btree::node::NodeRef")
                                  [
                                    Ty.path "alloc::collections::btree::node::marker::Mut";
                                    K;
                                    V;
                                    Ty.path "alloc::collections::btree::node::marker::Internal"
                                  ];
                                Ty.path "alloc::collections::btree::node::marker::Edge"
                              ],
                            "descend",
                            []
                          |),
                          [
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "alloc::collections::btree::node::Handle")
                                  [
                                    Ty.apply
                                      (Ty.path "alloc::collections::btree::node::NodeRef")
                                      [
                                        Ty.path "alloc::collections::btree::node::marker::Mut";
                                        K;
                                        V;
                                        Ty.path "alloc::collections::btree::node::marker::Internal"
                                      ];
                                    Ty.path "alloc::collections::btree::node::marker::KV"
                                  ],
                                "right_edge",
                                []
                              |),
                              [ M.read (| self2 |) ]
                            |)
                          ]
                        |))
                    ]
                |)
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom AssociatedFunction_consider_for_balancing :
          forall (K V : Ty.t),
          M.IsAssociatedFunction (Self K V) "consider_for_balancing" (consider_for_balancing K V).
      End Impl_alloc_collections_btree_node_Handle_alloc_collections_btree_node_NodeRef_alloc_collections_btree_node_marker_Mut_K_V_alloc_collections_btree_node_marker_Internal_alloc_collections_btree_node_marker_KV.
      
      (* StructRecord
        {
          name := "BalancingContext";
          ty_params := [ "K"; "V" ];
          fields :=
            [
              ("parent",
                Ty.apply
                  (Ty.path "alloc::collections::btree::node::Handle")
                  [
                    Ty.apply
                      (Ty.path "alloc::collections::btree::node::NodeRef")
                      [
                        Ty.path "alloc::collections::btree::node::marker::Mut";
                        K;
                        V;
                        Ty.path "alloc::collections::btree::node::marker::Internal"
                      ];
                    Ty.path "alloc::collections::btree::node::marker::KV"
                  ]);
              ("left_child",
                Ty.apply
                  (Ty.path "alloc::collections::btree::node::NodeRef")
                  [
                    Ty.path "alloc::collections::btree::node::marker::Mut";
                    K;
                    V;
                    Ty.path "alloc::collections::btree::node::marker::LeafOrInternal"
                  ]);
              ("right_child",
                Ty.apply
                  (Ty.path "alloc::collections::btree::node::NodeRef")
                  [
                    Ty.path "alloc::collections::btree::node::marker::Mut";
                    K;
                    V;
                    Ty.path "alloc::collections::btree::node::marker::LeafOrInternal"
                  ])
            ];
        } *)
      
      
      
      Module Impl_alloc_collections_btree_node_BalancingContext_K_V.
        Definition Self (K V : Ty.t) : Ty.t :=
          Ty.apply (Ty.path "alloc::collections::btree::node::BalancingContext") [ K; V ].
        
        (*
            pub fn left_child_len(&self) -> usize {
                self.left_child.len()
            }
        *)
        Definition left_child_len (K V : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self K V in
          match τ, α with
          | [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "alloc::collections::btree::node::NodeRef")
                    [
                      Ty.path "alloc::collections::btree::node::marker::Mut";
                      K;
                      V;
                      Ty.path "alloc::collections::btree::node::marker::LeafOrInternal"
                    ],
                  "len",
                  []
                |),
                [
                  M.SubPointer.get_struct_record_field (|
                    M.read (| self |),
                    "alloc::collections::btree::node::BalancingContext",
                    "left_child"
                  |)
                ]
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom AssociatedFunction_left_child_len :
          forall (K V : Ty.t),
          M.IsAssociatedFunction (Self K V) "left_child_len" (left_child_len K V).
        
        (*
            pub fn right_child_len(&self) -> usize {
                self.right_child.len()
            }
        *)
        Definition right_child_len (K V : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self K V in
          match τ, α with
          | [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "alloc::collections::btree::node::NodeRef")
                    [
                      Ty.path "alloc::collections::btree::node::marker::Mut";
                      K;
                      V;
                      Ty.path "alloc::collections::btree::node::marker::LeafOrInternal"
                    ],
                  "len",
                  []
                |),
                [
                  M.SubPointer.get_struct_record_field (|
                    M.read (| self |),
                    "alloc::collections::btree::node::BalancingContext",
                    "right_child"
                  |)
                ]
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom AssociatedFunction_right_child_len :
          forall (K V : Ty.t),
          M.IsAssociatedFunction (Self K V) "right_child_len" (right_child_len K V).
        
        (*
            pub fn into_left_child(self) -> NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal> {
                self.left_child
            }
        *)
        Definition into_left_child (K V : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self K V in
          match τ, α with
          | [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              M.read (|
                M.SubPointer.get_struct_record_field (|
                  self,
                  "alloc::collections::btree::node::BalancingContext",
                  "left_child"
                |)
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom AssociatedFunction_into_left_child :
          forall (K V : Ty.t),
          M.IsAssociatedFunction (Self K V) "into_left_child" (into_left_child K V).
        
        (*
            pub fn into_right_child(self) -> NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal> {
                self.right_child
            }
        *)
        Definition into_right_child (K V : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self K V in
          match τ, α with
          | [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              M.read (|
                M.SubPointer.get_struct_record_field (|
                  self,
                  "alloc::collections::btree::node::BalancingContext",
                  "right_child"
                |)
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom AssociatedFunction_into_right_child :
          forall (K V : Ty.t),
          M.IsAssociatedFunction (Self K V) "into_right_child" (into_right_child K V).
        
        (*
            pub fn can_merge(&self) -> bool {
                self.left_child.len() + 1 + self.right_child.len() <= CAPACITY
            }
        *)
        Definition can_merge (K V : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self K V in
          match τ, α with
          | [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              BinOp.Pure.le
                (BinOp.Wrap.add
                  Integer.Usize
                  (BinOp.Wrap.add
                    Integer.Usize
                    (M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "alloc::collections::btree::node::NodeRef")
                          [
                            Ty.path "alloc::collections::btree::node::marker::Mut";
                            K;
                            V;
                            Ty.path "alloc::collections::btree::node::marker::LeafOrInternal"
                          ],
                        "len",
                        []
                      |),
                      [
                        M.SubPointer.get_struct_record_field (|
                          M.read (| self |),
                          "alloc::collections::btree::node::BalancingContext",
                          "left_child"
                        |)
                      ]
                    |))
                    (Value.Integer 1))
                  (M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "alloc::collections::btree::node::NodeRef")
                        [
                          Ty.path "alloc::collections::btree::node::marker::Mut";
                          K;
                          V;
                          Ty.path "alloc::collections::btree::node::marker::LeafOrInternal"
                        ],
                      "len",
                      []
                    |),
                    [
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "alloc::collections::btree::node::BalancingContext",
                        "right_child"
                      |)
                    ]
                  |)))
                (M.read (| M.get_constant (| "alloc::collections::btree::node::CAPACITY" |) |))))
          | _, _ => M.impossible
          end.
        
        Axiom AssociatedFunction_can_merge :
          forall (K V : Ty.t),
          M.IsAssociatedFunction (Self K V) "can_merge" (can_merge K V).
        (*
            fn do_merge<
                F: FnOnce(
                    NodeRef<marker::Mut<'a>, K, V, marker::Internal>,
                    NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal>,
                ) -> R,
                R,
                A: Allocator,
            >(
                self,
                result: F,
                alloc: A,
            ) -> R {
                let Handle { node: mut parent_node, idx: parent_idx, _marker } = self.parent;
                let old_parent_len = parent_node.len();
                let mut left_node = self.left_child;
                let old_left_len = left_node.len();
                let mut right_node = self.right_child;
                let right_len = right_node.len();
                let new_left_len = old_left_len + 1 + right_len;
        
                assert!(new_left_len <= CAPACITY);
        
                unsafe {
                    *left_node.len_mut() = new_left_len as u16;
        
                    let parent_key = slice_remove(parent_node.key_area_mut(..old_parent_len), parent_idx);
                    left_node.key_area_mut(old_left_len).write(parent_key);
                    move_to_slice(
                        right_node.key_area_mut(..right_len),
                        left_node.key_area_mut(old_left_len + 1..new_left_len),
                    );
        
                    let parent_val = slice_remove(parent_node.val_area_mut(..old_parent_len), parent_idx);
                    left_node.val_area_mut(old_left_len).write(parent_val);
                    move_to_slice(
                        right_node.val_area_mut(..right_len),
                        left_node.val_area_mut(old_left_len + 1..new_left_len),
                    );
        
                    slice_remove(&mut parent_node.edge_area_mut(..old_parent_len + 1), parent_idx + 1);
                    parent_node.correct_childrens_parent_links(parent_idx + 1..old_parent_len);
                    *parent_node.len_mut() -= 1;
        
                    if parent_node.height > 1 {
                        // SAFETY: the height of the nodes being merged is one below the height
                        // of the node of this edge, thus above zero, so they are internal.
                        let mut left_node = left_node.reborrow_mut().cast_to_internal_unchecked();
                        let mut right_node = right_node.cast_to_internal_unchecked();
                        move_to_slice(
                            right_node.edge_area_mut(..right_len + 1),
                            left_node.edge_area_mut(old_left_len + 1..new_left_len + 1),
                        );
        
                        left_node.correct_childrens_parent_links(old_left_len + 1..new_left_len + 1);
        
                        alloc.deallocate(right_node.node.cast(), Layout::new::<InternalNode<K, V>>());
                    } else {
                        alloc.deallocate(right_node.node.cast(), Layout::new::<LeafNode<K, V>>());
                    }
                }
                result(parent_node, left_node)
            }
        *)
        Definition do_merge (K V : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self K V in
          match τ, α with
          | [ F; R; A ], [ self; result; alloc ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let result := M.alloc (| result |) in
              let alloc := M.alloc (| alloc |) in
              M.read (|
                M.match_operator (|
                  M.SubPointer.get_struct_record_field (|
                    self,
                    "alloc::collections::btree::node::BalancingContext",
                    "parent"
                  |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ0_0 :=
                          M.SubPointer.get_struct_record_field (|
                            γ,
                            "alloc::collections::btree::node::Handle",
                            "node"
                          |) in
                        let γ0_1 :=
                          M.SubPointer.get_struct_record_field (|
                            γ,
                            "alloc::collections::btree::node::Handle",
                            "idx"
                          |) in
                        let γ0_2 :=
                          M.SubPointer.get_struct_record_field (|
                            γ,
                            "alloc::collections::btree::node::Handle",
                            "_marker"
                          |) in
                        let parent_node := M.copy (| γ0_0 |) in
                        let parent_idx := M.copy (| γ0_1 |) in
                        let _marker := M.copy (| γ0_2 |) in
                        let~ old_parent_len :=
                          M.alloc (|
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "alloc::collections::btree::node::NodeRef")
                                  [
                                    Ty.path "alloc::collections::btree::node::marker::Mut";
                                    K;
                                    V;
                                    Ty.path "alloc::collections::btree::node::marker::Internal"
                                  ],
                                "len",
                                []
                              |),
                              [ parent_node ]
                            |)
                          |) in
                        let~ left_node :=
                          M.copy (|
                            M.SubPointer.get_struct_record_field (|
                              self,
                              "alloc::collections::btree::node::BalancingContext",
                              "left_child"
                            |)
                          |) in
                        let~ old_left_len :=
                          M.alloc (|
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "alloc::collections::btree::node::NodeRef")
                                  [
                                    Ty.path "alloc::collections::btree::node::marker::Mut";
                                    K;
                                    V;
                                    Ty.path
                                      "alloc::collections::btree::node::marker::LeafOrInternal"
                                  ],
                                "len",
                                []
                              |),
                              [ left_node ]
                            |)
                          |) in
                        let~ right_node :=
                          M.copy (|
                            M.SubPointer.get_struct_record_field (|
                              self,
                              "alloc::collections::btree::node::BalancingContext",
                              "right_child"
                            |)
                          |) in
                        let~ right_len :=
                          M.alloc (|
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "alloc::collections::btree::node::NodeRef")
                                  [
                                    Ty.path "alloc::collections::btree::node::marker::Mut";
                                    K;
                                    V;
                                    Ty.path
                                      "alloc::collections::btree::node::marker::LeafOrInternal"
                                  ],
                                "len",
                                []
                              |),
                              [ right_node ]
                            |)
                          |) in
                        let~ new_left_len :=
                          M.alloc (|
                            BinOp.Wrap.add
                              Integer.Usize
                              (BinOp.Wrap.add
                                Integer.Usize
                                (M.read (| old_left_len |))
                                (Value.Integer 1))
                              (M.read (| right_len |))
                          |) in
                        let~ _ :=
                          M.match_operator (|
                            M.alloc (| Value.Tuple [] |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ :=
                                    M.use
                                      (M.alloc (|
                                        UnOp.Pure.not
                                          (BinOp.Pure.le
                                            (M.read (| new_left_len |))
                                            (M.read (|
                                              M.get_constant (|
                                                "alloc::collections::btree::node::CAPACITY"
                                              |)
                                            |)))
                                      |)) in
                                  let _ :=
                                    M.is_constant_or_break_match (|
                                      M.read (| γ |),
                                      Value.Bool true
                                    |) in
                                  M.alloc (|
                                    M.never_to_any (|
                                      M.call_closure (|
                                        M.get_function (| "core::panicking::panic", [] |),
                                        [
                                          M.read (|
                                            Value.String
                                              "assertion failed: new_left_len <= CAPACITY"
                                          |)
                                        ]
                                      |)
                                    |)
                                  |)));
                              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                            ]
                          |) in
                        let~ _ :=
                          let~ _ :=
                            M.write (|
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "alloc::collections::btree::node::NodeRef")
                                    [
                                      Ty.path "alloc::collections::btree::node::marker::Mut";
                                      K;
                                      V;
                                      Ty.path
                                        "alloc::collections::btree::node::marker::LeafOrInternal"
                                    ],
                                  "len_mut",
                                  []
                                |),
                                [ left_node ]
                              |),
                              M.rust_cast (M.read (| new_left_len |))
                            |) in
                          let~ parent_key :=
                            M.alloc (|
                              M.call_closure (|
                                M.get_function (|
                                  "alloc::collections::btree::node::slice_remove",
                                  [ K ]
                                |),
                                [
                                  M.call_closure (|
                                    M.get_associated_function (|
                                      Ty.apply
                                        (Ty.path "alloc::collections::btree::node::NodeRef")
                                        [
                                          Ty.path "alloc::collections::btree::node::marker::Mut";
                                          K;
                                          V;
                                          Ty.path
                                            "alloc::collections::btree::node::marker::Internal"
                                        ],
                                      "key_area_mut",
                                      [
                                        Ty.apply
                                          (Ty.path "core::ops::range::RangeTo")
                                          [ Ty.path "usize" ];
                                        Ty.apply
                                          (Ty.path "slice")
                                          [
                                            Ty.apply
                                              (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                              [ K ]
                                          ]
                                      ]
                                    |),
                                    [
                                      parent_node;
                                      Value.StructRecord
                                        "core::ops::range::RangeTo"
                                        [ ("end_", M.read (| old_parent_len |)) ]
                                    ]
                                  |);
                                  M.read (| parent_idx |)
                                ]
                              |)
                            |) in
                          let~ _ :=
                            M.alloc (|
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ K ],
                                  "write",
                                  []
                                |),
                                [
                                  M.call_closure (|
                                    M.get_associated_function (|
                                      Ty.apply
                                        (Ty.path "alloc::collections::btree::node::NodeRef")
                                        [
                                          Ty.path "alloc::collections::btree::node::marker::Mut";
                                          K;
                                          V;
                                          Ty.path
                                            "alloc::collections::btree::node::marker::LeafOrInternal"
                                        ],
                                      "key_area_mut",
                                      [
                                        Ty.path "usize";
                                        Ty.apply
                                          (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                          [ K ]
                                      ]
                                    |),
                                    [ left_node; M.read (| old_left_len |) ]
                                  |);
                                  M.read (| parent_key |)
                                ]
                              |)
                            |) in
                          let~ _ :=
                            M.alloc (|
                              M.call_closure (|
                                M.get_function (|
                                  "alloc::collections::btree::node::move_to_slice",
                                  [ K ]
                                |),
                                [
                                  M.call_closure (|
                                    M.get_associated_function (|
                                      Ty.apply
                                        (Ty.path "alloc::collections::btree::node::NodeRef")
                                        [
                                          Ty.path "alloc::collections::btree::node::marker::Mut";
                                          K;
                                          V;
                                          Ty.path
                                            "alloc::collections::btree::node::marker::LeafOrInternal"
                                        ],
                                      "key_area_mut",
                                      [
                                        Ty.apply
                                          (Ty.path "core::ops::range::RangeTo")
                                          [ Ty.path "usize" ];
                                        Ty.apply
                                          (Ty.path "slice")
                                          [
                                            Ty.apply
                                              (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                              [ K ]
                                          ]
                                      ]
                                    |),
                                    [
                                      right_node;
                                      Value.StructRecord
                                        "core::ops::range::RangeTo"
                                        [ ("end_", M.read (| right_len |)) ]
                                    ]
                                  |);
                                  M.call_closure (|
                                    M.get_associated_function (|
                                      Ty.apply
                                        (Ty.path "alloc::collections::btree::node::NodeRef")
                                        [
                                          Ty.path "alloc::collections::btree::node::marker::Mut";
                                          K;
                                          V;
                                          Ty.path
                                            "alloc::collections::btree::node::marker::LeafOrInternal"
                                        ],
                                      "key_area_mut",
                                      [
                                        Ty.apply
                                          (Ty.path "core::ops::range::Range")
                                          [ Ty.path "usize" ];
                                        Ty.apply
                                          (Ty.path "slice")
                                          [
                                            Ty.apply
                                              (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                              [ K ]
                                          ]
                                      ]
                                    |),
                                    [
                                      left_node;
                                      Value.StructRecord
                                        "core::ops::range::Range"
                                        [
                                          ("start",
                                            BinOp.Wrap.add
                                              Integer.Usize
                                              (M.read (| old_left_len |))
                                              (Value.Integer 1));
                                          ("end_", M.read (| new_left_len |))
                                        ]
                                    ]
                                  |)
                                ]
                              |)
                            |) in
                          let~ parent_val :=
                            M.alloc (|
                              M.call_closure (|
                                M.get_function (|
                                  "alloc::collections::btree::node::slice_remove",
                                  [ V ]
                                |),
                                [
                                  M.call_closure (|
                                    M.get_associated_function (|
                                      Ty.apply
                                        (Ty.path "alloc::collections::btree::node::NodeRef")
                                        [
                                          Ty.path "alloc::collections::btree::node::marker::Mut";
                                          K;
                                          V;
                                          Ty.path
                                            "alloc::collections::btree::node::marker::Internal"
                                        ],
                                      "val_area_mut",
                                      [
                                        Ty.apply
                                          (Ty.path "core::ops::range::RangeTo")
                                          [ Ty.path "usize" ];
                                        Ty.apply
                                          (Ty.path "slice")
                                          [
                                            Ty.apply
                                              (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                              [ V ]
                                          ]
                                      ]
                                    |),
                                    [
                                      parent_node;
                                      Value.StructRecord
                                        "core::ops::range::RangeTo"
                                        [ ("end_", M.read (| old_parent_len |)) ]
                                    ]
                                  |);
                                  M.read (| parent_idx |)
                                ]
                              |)
                            |) in
                          let~ _ :=
                            M.alloc (|
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ V ],
                                  "write",
                                  []
                                |),
                                [
                                  M.call_closure (|
                                    M.get_associated_function (|
                                      Ty.apply
                                        (Ty.path "alloc::collections::btree::node::NodeRef")
                                        [
                                          Ty.path "alloc::collections::btree::node::marker::Mut";
                                          K;
                                          V;
                                          Ty.path
                                            "alloc::collections::btree::node::marker::LeafOrInternal"
                                        ],
                                      "val_area_mut",
                                      [
                                        Ty.path "usize";
                                        Ty.apply
                                          (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                          [ V ]
                                      ]
                                    |),
                                    [ left_node; M.read (| old_left_len |) ]
                                  |);
                                  M.read (| parent_val |)
                                ]
                              |)
                            |) in
                          let~ _ :=
                            M.alloc (|
                              M.call_closure (|
                                M.get_function (|
                                  "alloc::collections::btree::node::move_to_slice",
                                  [ V ]
                                |),
                                [
                                  M.call_closure (|
                                    M.get_associated_function (|
                                      Ty.apply
                                        (Ty.path "alloc::collections::btree::node::NodeRef")
                                        [
                                          Ty.path "alloc::collections::btree::node::marker::Mut";
                                          K;
                                          V;
                                          Ty.path
                                            "alloc::collections::btree::node::marker::LeafOrInternal"
                                        ],
                                      "val_area_mut",
                                      [
                                        Ty.apply
                                          (Ty.path "core::ops::range::RangeTo")
                                          [ Ty.path "usize" ];
                                        Ty.apply
                                          (Ty.path "slice")
                                          [
                                            Ty.apply
                                              (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                              [ V ]
                                          ]
                                      ]
                                    |),
                                    [
                                      right_node;
                                      Value.StructRecord
                                        "core::ops::range::RangeTo"
                                        [ ("end_", M.read (| right_len |)) ]
                                    ]
                                  |);
                                  M.call_closure (|
                                    M.get_associated_function (|
                                      Ty.apply
                                        (Ty.path "alloc::collections::btree::node::NodeRef")
                                        [
                                          Ty.path "alloc::collections::btree::node::marker::Mut";
                                          K;
                                          V;
                                          Ty.path
                                            "alloc::collections::btree::node::marker::LeafOrInternal"
                                        ],
                                      "val_area_mut",
                                      [
                                        Ty.apply
                                          (Ty.path "core::ops::range::Range")
                                          [ Ty.path "usize" ];
                                        Ty.apply
                                          (Ty.path "slice")
                                          [
                                            Ty.apply
                                              (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                              [ V ]
                                          ]
                                      ]
                                    |),
                                    [
                                      left_node;
                                      Value.StructRecord
                                        "core::ops::range::Range"
                                        [
                                          ("start",
                                            BinOp.Wrap.add
                                              Integer.Usize
                                              (M.read (| old_left_len |))
                                              (Value.Integer 1));
                                          ("end_", M.read (| new_left_len |))
                                        ]
                                    ]
                                  |)
                                ]
                              |)
                            |) in
                          let~ _ :=
                            M.alloc (|
                              M.call_closure (|
                                M.get_function (|
                                  "alloc::collections::btree::node::slice_remove",
                                  [
                                    Ty.apply
                                      (Ty.path "core::ptr::non_null::NonNull")
                                      [
                                        Ty.apply
                                          (Ty.path "alloc::collections::btree::node::LeafNode")
                                          [ K; V ]
                                      ]
                                  ]
                                |),
                                [
                                  M.call_closure (|
                                    M.get_associated_function (|
                                      Ty.apply
                                        (Ty.path "alloc::collections::btree::node::NodeRef")
                                        [
                                          Ty.path "alloc::collections::btree::node::marker::Mut";
                                          K;
                                          V;
                                          Ty.path
                                            "alloc::collections::btree::node::marker::Internal"
                                        ],
                                      "edge_area_mut",
                                      [
                                        Ty.apply
                                          (Ty.path "core::ops::range::RangeTo")
                                          [ Ty.path "usize" ];
                                        Ty.apply
                                          (Ty.path "slice")
                                          [
                                            Ty.apply
                                              (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                              [
                                                Ty.apply
                                                  (Ty.path "core::ptr::non_null::NonNull")
                                                  [
                                                    Ty.apply
                                                      (Ty.path
                                                        "alloc::collections::btree::node::LeafNode")
                                                      [ K; V ]
                                                  ]
                                              ]
                                          ]
                                      ]
                                    |),
                                    [
                                      parent_node;
                                      Value.StructRecord
                                        "core::ops::range::RangeTo"
                                        [
                                          ("end_",
                                            BinOp.Wrap.add
                                              Integer.Usize
                                              (M.read (| old_parent_len |))
                                              (Value.Integer 1))
                                        ]
                                    ]
                                  |);
                                  BinOp.Wrap.add
                                    Integer.Usize
                                    (M.read (| parent_idx |))
                                    (Value.Integer 1)
                                ]
                              |)
                            |) in
                          let~ _ :=
                            M.alloc (|
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "alloc::collections::btree::node::NodeRef")
                                    [
                                      Ty.path "alloc::collections::btree::node::marker::Mut";
                                      K;
                                      V;
                                      Ty.path "alloc::collections::btree::node::marker::Internal"
                                    ],
                                  "correct_childrens_parent_links",
                                  [ Ty.apply (Ty.path "core::ops::range::Range") [ Ty.path "usize" ]
                                  ]
                                |),
                                [
                                  parent_node;
                                  Value.StructRecord
                                    "core::ops::range::Range"
                                    [
                                      ("start",
                                        BinOp.Wrap.add
                                          Integer.Usize
                                          (M.read (| parent_idx |))
                                          (Value.Integer 1));
                                      ("end_", M.read (| old_parent_len |))
                                    ]
                                ]
                              |)
                            |) in
                          let~ _ :=
                            let β :=
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "alloc::collections::btree::node::NodeRef")
                                    [
                                      Ty.path "alloc::collections::btree::node::marker::Mut";
                                      K;
                                      V;
                                      Ty.path "alloc::collections::btree::node::marker::Internal"
                                    ],
                                  "len_mut",
                                  []
                                |),
                                [ parent_node ]
                              |) in
                            M.write (|
                              β,
                              BinOp.Wrap.sub Integer.U16 (M.read (| β |)) (Value.Integer 1)
                            |) in
                          M.match_operator (|
                            M.alloc (| Value.Tuple [] |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ :=
                                    M.use
                                      (M.alloc (|
                                        BinOp.Pure.gt
                                          (M.read (|
                                            M.SubPointer.get_struct_record_field (|
                                              parent_node,
                                              "alloc::collections::btree::node::NodeRef",
                                              "height"
                                            |)
                                          |))
                                          (Value.Integer 1)
                                      |)) in
                                  let _ :=
                                    M.is_constant_or_break_match (|
                                      M.read (| γ |),
                                      Value.Bool true
                                    |) in
                                  let~ left_node :=
                                    M.alloc (|
                                      M.call_closure (|
                                        M.get_associated_function (|
                                          Ty.apply
                                            (Ty.path "alloc::collections::btree::node::NodeRef")
                                            [
                                              Ty.path
                                                "alloc::collections::btree::node::marker::Mut";
                                              K;
                                              V;
                                              Ty.path
                                                "alloc::collections::btree::node::marker::LeafOrInternal"
                                            ],
                                          "cast_to_internal_unchecked",
                                          []
                                        |),
                                        [
                                          M.call_closure (|
                                            M.get_associated_function (|
                                              Ty.apply
                                                (Ty.path "alloc::collections::btree::node::NodeRef")
                                                [
                                                  Ty.path
                                                    "alloc::collections::btree::node::marker::Mut";
                                                  K;
                                                  V;
                                                  Ty.path
                                                    "alloc::collections::btree::node::marker::LeafOrInternal"
                                                ],
                                              "reborrow_mut",
                                              []
                                            |),
                                            [ left_node ]
                                          |)
                                        ]
                                      |)
                                    |) in
                                  let~ right_node :=
                                    M.alloc (|
                                      M.call_closure (|
                                        M.get_associated_function (|
                                          Ty.apply
                                            (Ty.path "alloc::collections::btree::node::NodeRef")
                                            [
                                              Ty.path
                                                "alloc::collections::btree::node::marker::Mut";
                                              K;
                                              V;
                                              Ty.path
                                                "alloc::collections::btree::node::marker::LeafOrInternal"
                                            ],
                                          "cast_to_internal_unchecked",
                                          []
                                        |),
                                        [ M.read (| right_node |) ]
                                      |)
                                    |) in
                                  let~ _ :=
                                    M.alloc (|
                                      M.call_closure (|
                                        M.get_function (|
                                          "alloc::collections::btree::node::move_to_slice",
                                          [
                                            Ty.apply
                                              (Ty.path "core::ptr::non_null::NonNull")
                                              [
                                                Ty.apply
                                                  (Ty.path
                                                    "alloc::collections::btree::node::LeafNode")
                                                  [ K; V ]
                                              ]
                                          ]
                                        |),
                                        [
                                          M.call_closure (|
                                            M.get_associated_function (|
                                              Ty.apply
                                                (Ty.path "alloc::collections::btree::node::NodeRef")
                                                [
                                                  Ty.path
                                                    "alloc::collections::btree::node::marker::Mut";
                                                  K;
                                                  V;
                                                  Ty.path
                                                    "alloc::collections::btree::node::marker::Internal"
                                                ],
                                              "edge_area_mut",
                                              [
                                                Ty.apply
                                                  (Ty.path "core::ops::range::RangeTo")
                                                  [ Ty.path "usize" ];
                                                Ty.apply
                                                  (Ty.path "slice")
                                                  [
                                                    Ty.apply
                                                      (Ty.path
                                                        "core::mem::maybe_uninit::MaybeUninit")
                                                      [
                                                        Ty.apply
                                                          (Ty.path "core::ptr::non_null::NonNull")
                                                          [
                                                            Ty.apply
                                                              (Ty.path
                                                                "alloc::collections::btree::node::LeafNode")
                                                              [ K; V ]
                                                          ]
                                                      ]
                                                  ]
                                              ]
                                            |),
                                            [
                                              right_node;
                                              Value.StructRecord
                                                "core::ops::range::RangeTo"
                                                [
                                                  ("end_",
                                                    BinOp.Wrap.add
                                                      Integer.Usize
                                                      (M.read (| right_len |))
                                                      (Value.Integer 1))
                                                ]
                                            ]
                                          |);
                                          M.call_closure (|
                                            M.get_associated_function (|
                                              Ty.apply
                                                (Ty.path "alloc::collections::btree::node::NodeRef")
                                                [
                                                  Ty.path
                                                    "alloc::collections::btree::node::marker::Mut";
                                                  K;
                                                  V;
                                                  Ty.path
                                                    "alloc::collections::btree::node::marker::Internal"
                                                ],
                                              "edge_area_mut",
                                              [
                                                Ty.apply
                                                  (Ty.path "core::ops::range::Range")
                                                  [ Ty.path "usize" ];
                                                Ty.apply
                                                  (Ty.path "slice")
                                                  [
                                                    Ty.apply
                                                      (Ty.path
                                                        "core::mem::maybe_uninit::MaybeUninit")
                                                      [
                                                        Ty.apply
                                                          (Ty.path "core::ptr::non_null::NonNull")
                                                          [
                                                            Ty.apply
                                                              (Ty.path
                                                                "alloc::collections::btree::node::LeafNode")
                                                              [ K; V ]
                                                          ]
                                                      ]
                                                  ]
                                              ]
                                            |),
                                            [
                                              left_node;
                                              Value.StructRecord
                                                "core::ops::range::Range"
                                                [
                                                  ("start",
                                                    BinOp.Wrap.add
                                                      Integer.Usize
                                                      (M.read (| old_left_len |))
                                                      (Value.Integer 1));
                                                  ("end_",
                                                    BinOp.Wrap.add
                                                      Integer.Usize
                                                      (M.read (| new_left_len |))
                                                      (Value.Integer 1))
                                                ]
                                            ]
                                          |)
                                        ]
                                      |)
                                    |) in
                                  let~ _ :=
                                    M.alloc (|
                                      M.call_closure (|
                                        M.get_associated_function (|
                                          Ty.apply
                                            (Ty.path "alloc::collections::btree::node::NodeRef")
                                            [
                                              Ty.path
                                                "alloc::collections::btree::node::marker::Mut";
                                              K;
                                              V;
                                              Ty.path
                                                "alloc::collections::btree::node::marker::Internal"
                                            ],
                                          "correct_childrens_parent_links",
                                          [
                                            Ty.apply
                                              (Ty.path "core::ops::range::Range")
                                              [ Ty.path "usize" ]
                                          ]
                                        |),
                                        [
                                          left_node;
                                          Value.StructRecord
                                            "core::ops::range::Range"
                                            [
                                              ("start",
                                                BinOp.Wrap.add
                                                  Integer.Usize
                                                  (M.read (| old_left_len |))
                                                  (Value.Integer 1));
                                              ("end_",
                                                BinOp.Wrap.add
                                                  Integer.Usize
                                                  (M.read (| new_left_len |))
                                                  (Value.Integer 1))
                                            ]
                                        ]
                                      |)
                                    |) in
                                  let~ _ :=
                                    M.alloc (|
                                      M.call_closure (|
                                        M.get_trait_method (|
                                          "core::alloc::Allocator",
                                          A,
                                          [],
                                          "deallocate",
                                          []
                                        |),
                                        [
                                          alloc;
                                          M.call_closure (|
                                            M.get_associated_function (|
                                              Ty.apply
                                                (Ty.path "core::ptr::non_null::NonNull")
                                                [
                                                  Ty.apply
                                                    (Ty.path
                                                      "alloc::collections::btree::node::LeafNode")
                                                    [ K; V ]
                                                ],
                                              "cast",
                                              [ Ty.path "u8" ]
                                            |),
                                            [
                                              M.read (|
                                                M.SubPointer.get_struct_record_field (|
                                                  right_node,
                                                  "alloc::collections::btree::node::NodeRef",
                                                  "node"
                                                |)
                                              |)
                                            ]
                                          |);
                                          M.call_closure (|
                                            M.get_associated_function (|
                                              Ty.path "core::alloc::layout::Layout",
                                              "new",
                                              [
                                                Ty.apply
                                                  (Ty.path
                                                    "alloc::collections::btree::node::InternalNode")
                                                  [ K; V ]
                                              ]
                                            |),
                                            []
                                          |)
                                        ]
                                      |)
                                    |) in
                                  M.alloc (| Value.Tuple [] |)));
                              fun γ =>
                                ltac:(M.monadic
                                  (let~ _ :=
                                    M.alloc (|
                                      M.call_closure (|
                                        M.get_trait_method (|
                                          "core::alloc::Allocator",
                                          A,
                                          [],
                                          "deallocate",
                                          []
                                        |),
                                        [
                                          alloc;
                                          M.call_closure (|
                                            M.get_associated_function (|
                                              Ty.apply
                                                (Ty.path "core::ptr::non_null::NonNull")
                                                [
                                                  Ty.apply
                                                    (Ty.path
                                                      "alloc::collections::btree::node::LeafNode")
                                                    [ K; V ]
                                                ],
                                              "cast",
                                              [ Ty.path "u8" ]
                                            |),
                                            [
                                              M.read (|
                                                M.SubPointer.get_struct_record_field (|
                                                  right_node,
                                                  "alloc::collections::btree::node::NodeRef",
                                                  "node"
                                                |)
                                              |)
                                            ]
                                          |);
                                          M.call_closure (|
                                            M.get_associated_function (|
                                              Ty.path "core::alloc::layout::Layout",
                                              "new",
                                              [
                                                Ty.apply
                                                  (Ty.path
                                                    "alloc::collections::btree::node::LeafNode")
                                                  [ K; V ]
                                              ]
                                            |),
                                            []
                                          |)
                                        ]
                                      |)
                                    |) in
                                  M.alloc (| Value.Tuple [] |)))
                            ]
                          |) in
                        M.alloc (|
                          M.call_closure (|
                            M.get_trait_method (|
                              "core::ops::function::FnOnce",
                              F,
                              [
                                Ty.tuple
                                  [
                                    Ty.apply
                                      (Ty.path "alloc::collections::btree::node::NodeRef")
                                      [
                                        Ty.path "alloc::collections::btree::node::marker::Mut";
                                        K;
                                        V;
                                        Ty.path "alloc::collections::btree::node::marker::Internal"
                                      ];
                                    Ty.apply
                                      (Ty.path "alloc::collections::btree::node::NodeRef")
                                      [
                                        Ty.path "alloc::collections::btree::node::marker::Mut";
                                        K;
                                        V;
                                        Ty.path
                                          "alloc::collections::btree::node::marker::LeafOrInternal"
                                      ]
                                  ]
                              ],
                              "call_once",
                              []
                            |),
                            [
                              M.read (| result |);
                              Value.Tuple [ M.read (| parent_node |); M.read (| left_node |) ]
                            ]
                          |)
                        |)))
                  ]
                |)
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom AssociatedFunction_do_merge :
          forall (K V : Ty.t),
          M.IsAssociatedFunction (Self K V) "do_merge" (do_merge K V).
        
        (*
            pub fn merge_tracking_parent<A: Allocator + Clone>(
                self,
                alloc: A,
            ) -> NodeRef<marker::Mut<'a>, K, V, marker::Internal> {
                self.do_merge(|parent, _child| parent, alloc)
            }
        *)
        Definition merge_tracking_parent (K V : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self K V in
          match τ, α with
          | [ A ], [ self; alloc ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let alloc := M.alloc (| alloc |) in
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply (Ty.path "alloc::collections::btree::node::BalancingContext") [ K; V ],
                  "do_merge",
                  [
                    Ty.function
                      [
                        Ty.tuple
                          [
                            Ty.apply
                              (Ty.path "alloc::collections::btree::node::NodeRef")
                              [
                                Ty.path "alloc::collections::btree::node::marker::Mut";
                                K;
                                V;
                                Ty.path "alloc::collections::btree::node::marker::Internal"
                              ];
                            Ty.apply
                              (Ty.path "alloc::collections::btree::node::NodeRef")
                              [
                                Ty.path "alloc::collections::btree::node::marker::Mut";
                                K;
                                V;
                                Ty.path "alloc::collections::btree::node::marker::LeafOrInternal"
                              ]
                          ]
                      ]
                      (Ty.apply
                        (Ty.path "alloc::collections::btree::node::NodeRef")
                        [
                          Ty.path "alloc::collections::btree::node::marker::Mut";
                          K;
                          V;
                          Ty.path "alloc::collections::btree::node::marker::Internal"
                        ]);
                    Ty.apply
                      (Ty.path "alloc::collections::btree::node::NodeRef")
                      [
                        Ty.path "alloc::collections::btree::node::marker::Mut";
                        K;
                        V;
                        Ty.path "alloc::collections::btree::node::marker::Internal"
                      ];
                    A
                  ]
                |),
                [
                  M.read (| self |);
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0; α1 ] =>
                          M.match_operator (|
                            M.alloc (| α0 |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let parent := M.copy (| γ |) in
                                  M.match_operator (|
                                    M.alloc (| α1 |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let _child := M.copy (| γ |) in
                                          M.read (| parent |)))
                                    ]
                                  |)))
                            ]
                          |)
                        | _ => M.impossible (||)
                        end));
                  M.read (| alloc |)
                ]
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom AssociatedFunction_merge_tracking_parent :
          forall (K V : Ty.t),
          M.IsAssociatedFunction (Self K V) "merge_tracking_parent" (merge_tracking_parent K V).
        
        (*
            pub fn merge_tracking_child<A: Allocator + Clone>(
                self,
                alloc: A,
            ) -> NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal> {
                self.do_merge(|_parent, child| child, alloc)
            }
        *)
        Definition merge_tracking_child (K V : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self K V in
          match τ, α with
          | [ A ], [ self; alloc ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let alloc := M.alloc (| alloc |) in
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply (Ty.path "alloc::collections::btree::node::BalancingContext") [ K; V ],
                  "do_merge",
                  [
                    Ty.function
                      [
                        Ty.tuple
                          [
                            Ty.apply
                              (Ty.path "alloc::collections::btree::node::NodeRef")
                              [
                                Ty.path "alloc::collections::btree::node::marker::Mut";
                                K;
                                V;
                                Ty.path "alloc::collections::btree::node::marker::Internal"
                              ];
                            Ty.apply
                              (Ty.path "alloc::collections::btree::node::NodeRef")
                              [
                                Ty.path "alloc::collections::btree::node::marker::Mut";
                                K;
                                V;
                                Ty.path "alloc::collections::btree::node::marker::LeafOrInternal"
                              ]
                          ]
                      ]
                      (Ty.apply
                        (Ty.path "alloc::collections::btree::node::NodeRef")
                        [
                          Ty.path "alloc::collections::btree::node::marker::Mut";
                          K;
                          V;
                          Ty.path "alloc::collections::btree::node::marker::LeafOrInternal"
                        ]);
                    Ty.apply
                      (Ty.path "alloc::collections::btree::node::NodeRef")
                      [
                        Ty.path "alloc::collections::btree::node::marker::Mut";
                        K;
                        V;
                        Ty.path "alloc::collections::btree::node::marker::LeafOrInternal"
                      ];
                    A
                  ]
                |),
                [
                  M.read (| self |);
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0; α1 ] =>
                          M.match_operator (|
                            M.alloc (| α0 |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let _parent := M.copy (| γ |) in
                                  M.match_operator (|
                                    M.alloc (| α1 |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let child := M.copy (| γ |) in
                                          M.read (| child |)))
                                    ]
                                  |)))
                            ]
                          |)
                        | _ => M.impossible (||)
                        end));
                  M.read (| alloc |)
                ]
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom AssociatedFunction_merge_tracking_child :
          forall (K V : Ty.t),
          M.IsAssociatedFunction (Self K V) "merge_tracking_child" (merge_tracking_child K V).
        
        (*
            pub fn merge_tracking_child_edge<A: Allocator + Clone>(
                self,
                track_edge_idx: LeftOrRight<usize>,
                alloc: A,
            ) -> Handle<NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal>, marker::Edge> {
                let old_left_len = self.left_child.len();
                let right_len = self.right_child.len();
                assert!(match track_edge_idx {
                    LeftOrRight::Left(idx) => idx <= old_left_len,
                    LeftOrRight::Right(idx) => idx <= right_len,
                });
                let child = self.merge_tracking_child(alloc);
                let new_idx = match track_edge_idx {
                    LeftOrRight::Left(idx) => idx,
                    LeftOrRight::Right(idx) => old_left_len + 1 + idx,
                };
                unsafe { Handle::new_edge(child, new_idx) }
            }
        *)
        Definition merge_tracking_child_edge (K V : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self K V in
          match τ, α with
          | [ A ], [ self; track_edge_idx; alloc ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let track_edge_idx := M.alloc (| track_edge_idx |) in
              let alloc := M.alloc (| alloc |) in
              M.read (|
                let~ old_left_len :=
                  M.alloc (|
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "alloc::collections::btree::node::NodeRef")
                          [
                            Ty.path "alloc::collections::btree::node::marker::Mut";
                            K;
                            V;
                            Ty.path "alloc::collections::btree::node::marker::LeafOrInternal"
                          ],
                        "len",
                        []
                      |),
                      [
                        M.SubPointer.get_struct_record_field (|
                          self,
                          "alloc::collections::btree::node::BalancingContext",
                          "left_child"
                        |)
                      ]
                    |)
                  |) in
                let~ right_len :=
                  M.alloc (|
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "alloc::collections::btree::node::NodeRef")
                          [
                            Ty.path "alloc::collections::btree::node::marker::Mut";
                            K;
                            V;
                            Ty.path "alloc::collections::btree::node::marker::LeafOrInternal"
                          ],
                        "len",
                        []
                      |),
                      [
                        M.SubPointer.get_struct_record_field (|
                          self,
                          "alloc::collections::btree::node::BalancingContext",
                          "right_child"
                        |)
                      ]
                    |)
                  |) in
                let~ _ :=
                  M.match_operator (|
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                UnOp.Pure.not
                                  (M.read (|
                                    M.match_operator (|
                                      track_edge_idx,
                                      [
                                        fun γ =>
                                          ltac:(M.monadic
                                            (let γ0_0 :=
                                              M.SubPointer.get_struct_tuple_field (|
                                                γ,
                                                "alloc::collections::btree::node::LeftOrRight::Left",
                                                0
                                              |) in
                                            let idx := M.copy (| γ0_0 |) in
                                            M.alloc (|
                                              BinOp.Pure.le
                                                (M.read (| idx |))
                                                (M.read (| old_left_len |))
                                            |)));
                                        fun γ =>
                                          ltac:(M.monadic
                                            (let γ0_0 :=
                                              M.SubPointer.get_struct_tuple_field (|
                                                γ,
                                                "alloc::collections::btree::node::LeftOrRight::Right",
                                                0
                                              |) in
                                            let idx := M.copy (| γ0_0 |) in
                                            M.alloc (|
                                              BinOp.Pure.le
                                                (M.read (| idx |))
                                                (M.read (| right_len |))
                                            |)))
                                      ]
                                    |)
                                  |))
                              |)) in
                          let _ :=
                            M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (|
                            M.never_to_any (|
                              M.call_closure (|
                                M.get_function (| "core::panicking::panic", [] |),
                                [
                                  M.read (|
                                    Value.String
                                      "assertion failed: match track_edge_idx {
    LeftOrRight::Left(idx) => idx <= old_left_len,
    LeftOrRight::Right(idx) => idx <= right_len,
}"
                                  |)
                                ]
                              |)
                            |)
                          |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                let~ child :=
                  M.alloc (|
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "alloc::collections::btree::node::BalancingContext")
                          [ K; V ],
                        "merge_tracking_child",
                        [ A ]
                      |),
                      [ M.read (| self |); M.read (| alloc |) ]
                    |)
                  |) in
                let~ new_idx :=
                  M.copy (|
                    M.match_operator (|
                      track_edge_idx,
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "alloc::collections::btree::node::LeftOrRight::Left",
                                0
                              |) in
                            let idx := M.copy (| γ0_0 |) in
                            idx));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "alloc::collections::btree::node::LeftOrRight::Right",
                                0
                              |) in
                            let idx := M.copy (| γ0_0 |) in
                            M.alloc (|
                              BinOp.Wrap.add
                                Integer.Usize
                                (BinOp.Wrap.add
                                  Integer.Usize
                                  (M.read (| old_left_len |))
                                  (Value.Integer 1))
                                (M.read (| idx |))
                            |)))
                      ]
                    |)
                  |) in
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "alloc::collections::btree::node::Handle")
                        [
                          Ty.apply
                            (Ty.path "alloc::collections::btree::node::NodeRef")
                            [
                              Ty.path "alloc::collections::btree::node::marker::Mut";
                              K;
                              V;
                              Ty.path "alloc::collections::btree::node::marker::LeafOrInternal"
                            ];
                          Ty.path "alloc::collections::btree::node::marker::Edge"
                        ],
                      "new_edge",
                      []
                    |),
                    [ M.read (| child |); M.read (| new_idx |) ]
                  |)
                |)
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom AssociatedFunction_merge_tracking_child_edge :
          forall (K V : Ty.t),
          M.IsAssociatedFunction
            (Self K V)
            "merge_tracking_child_edge"
            (merge_tracking_child_edge K V).
        
        (*
            pub fn steal_left(
                mut self,
                track_right_edge_idx: usize,
            ) -> Handle<NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal>, marker::Edge> {
                self.bulk_steal_left(1);
                unsafe { Handle::new_edge(self.right_child, 1 + track_right_edge_idx) }
            }
        *)
        Definition steal_left (K V : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self K V in
          match τ, α with
          | [], [ self; track_right_edge_idx ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let track_right_edge_idx := M.alloc (| track_right_edge_idx |) in
              M.read (|
                let~ _ :=
                  M.alloc (|
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "alloc::collections::btree::node::BalancingContext")
                          [ K; V ],
                        "bulk_steal_left",
                        []
                      |),
                      [ self; Value.Integer 1 ]
                    |)
                  |) in
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "alloc::collections::btree::node::Handle")
                        [
                          Ty.apply
                            (Ty.path "alloc::collections::btree::node::NodeRef")
                            [
                              Ty.path "alloc::collections::btree::node::marker::Mut";
                              K;
                              V;
                              Ty.path "alloc::collections::btree::node::marker::LeafOrInternal"
                            ];
                          Ty.path "alloc::collections::btree::node::marker::Edge"
                        ],
                      "new_edge",
                      []
                    |),
                    [
                      M.read (|
                        M.SubPointer.get_struct_record_field (|
                          self,
                          "alloc::collections::btree::node::BalancingContext",
                          "right_child"
                        |)
                      |);
                      BinOp.Wrap.add
                        Integer.Usize
                        (Value.Integer 1)
                        (M.read (| track_right_edge_idx |))
                    ]
                  |)
                |)
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom AssociatedFunction_steal_left :
          forall (K V : Ty.t),
          M.IsAssociatedFunction (Self K V) "steal_left" (steal_left K V).
        
        (*
            pub fn steal_right(
                mut self,
                track_left_edge_idx: usize,
            ) -> Handle<NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal>, marker::Edge> {
                self.bulk_steal_right(1);
                unsafe { Handle::new_edge(self.left_child, track_left_edge_idx) }
            }
        *)
        Definition steal_right (K V : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self K V in
          match τ, α with
          | [], [ self; track_left_edge_idx ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let track_left_edge_idx := M.alloc (| track_left_edge_idx |) in
              M.read (|
                let~ _ :=
                  M.alloc (|
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "alloc::collections::btree::node::BalancingContext")
                          [ K; V ],
                        "bulk_steal_right",
                        []
                      |),
                      [ self; Value.Integer 1 ]
                    |)
                  |) in
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "alloc::collections::btree::node::Handle")
                        [
                          Ty.apply
                            (Ty.path "alloc::collections::btree::node::NodeRef")
                            [
                              Ty.path "alloc::collections::btree::node::marker::Mut";
                              K;
                              V;
                              Ty.path "alloc::collections::btree::node::marker::LeafOrInternal"
                            ];
                          Ty.path "alloc::collections::btree::node::marker::Edge"
                        ],
                      "new_edge",
                      []
                    |),
                    [
                      M.read (|
                        M.SubPointer.get_struct_record_field (|
                          self,
                          "alloc::collections::btree::node::BalancingContext",
                          "left_child"
                        |)
                      |);
                      M.read (| track_left_edge_idx |)
                    ]
                  |)
                |)
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom AssociatedFunction_steal_right :
          forall (K V : Ty.t),
          M.IsAssociatedFunction (Self K V) "steal_right" (steal_right K V).
        
        (*
            pub fn bulk_steal_left(&mut self, count: usize) {
                assert!(count > 0);
                unsafe {
                    let left_node = &mut self.left_child;
                    let old_left_len = left_node.len();
                    let right_node = &mut self.right_child;
                    let old_right_len = right_node.len();
        
                    // Make sure that we may steal safely.
                    assert!(old_right_len + count <= CAPACITY);
                    assert!(old_left_len >= count);
        
                    let new_left_len = old_left_len - count;
                    let new_right_len = old_right_len + count;
                    *left_node.len_mut() = new_left_len as u16;
                    *right_node.len_mut() = new_right_len as u16;
        
                    // Move leaf data.
                    {
                        // Make room for stolen elements in the right child.
                        slice_shr(right_node.key_area_mut(..new_right_len), count);
                        slice_shr(right_node.val_area_mut(..new_right_len), count);
        
                        // Move elements from the left child to the right one.
                        move_to_slice(
                            left_node.key_area_mut(new_left_len + 1..old_left_len),
                            right_node.key_area_mut(..count - 1),
                        );
                        move_to_slice(
                            left_node.val_area_mut(new_left_len + 1..old_left_len),
                            right_node.val_area_mut(..count - 1),
                        );
        
                        // Move the left-most stolen pair to the parent.
                        let k = left_node.key_area_mut(new_left_len).assume_init_read();
                        let v = left_node.val_area_mut(new_left_len).assume_init_read();
                        let (k, v) = self.parent.replace_kv(k, v);
        
                        // Move parent's key-value pair to the right child.
                        right_node.key_area_mut(count - 1).write(k);
                        right_node.val_area_mut(count - 1).write(v);
                    }
        
                    match (left_node.reborrow_mut().force(), right_node.reborrow_mut().force()) {
                        (ForceResult::Internal(mut left), ForceResult::Internal(mut right)) => {
                            // Make room for stolen edges.
                            slice_shr(right.edge_area_mut(..new_right_len + 1), count);
        
                            // Steal edges.
                            move_to_slice(
                                left.edge_area_mut(new_left_len + 1..old_left_len + 1),
                                right.edge_area_mut(..count),
                            );
        
                            right.correct_childrens_parent_links(0..new_right_len + 1);
                        }
                        (ForceResult::Leaf(_), ForceResult::Leaf(_)) => {}
                        _ => unreachable!(),
                    }
                }
            }
        *)
        Definition bulk_steal_left (K V : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self K V in
          match τ, α with
          | [], [ self; count ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let count := M.alloc (| count |) in
              M.read (|
                let~ _ :=
                  M.match_operator (|
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                UnOp.Pure.not (BinOp.Pure.gt (M.read (| count |)) (Value.Integer 0))
                              |)) in
                          let _ :=
                            M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (|
                            M.never_to_any (|
                              M.call_closure (|
                                M.get_function (| "core::panicking::panic", [] |),
                                [ M.read (| Value.String "assertion failed: count > 0" |) ]
                              |)
                            |)
                          |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                let~ left_node :=
                  M.alloc (|
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "alloc::collections::btree::node::BalancingContext",
                      "left_child"
                    |)
                  |) in
                let~ old_left_len :=
                  M.alloc (|
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "alloc::collections::btree::node::NodeRef")
                          [
                            Ty.path "alloc::collections::btree::node::marker::Mut";
                            K;
                            V;
                            Ty.path "alloc::collections::btree::node::marker::LeafOrInternal"
                          ],
                        "len",
                        []
                      |),
                      [ M.read (| left_node |) ]
                    |)
                  |) in
                let~ right_node :=
                  M.alloc (|
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "alloc::collections::btree::node::BalancingContext",
                      "right_child"
                    |)
                  |) in
                let~ old_right_len :=
                  M.alloc (|
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "alloc::collections::btree::node::NodeRef")
                          [
                            Ty.path "alloc::collections::btree::node::marker::Mut";
                            K;
                            V;
                            Ty.path "alloc::collections::btree::node::marker::LeafOrInternal"
                          ],
                        "len",
                        []
                      |),
                      [ M.read (| right_node |) ]
                    |)
                  |) in
                let~ _ :=
                  M.match_operator (|
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                UnOp.Pure.not
                                  (BinOp.Pure.le
                                    (BinOp.Wrap.add
                                      Integer.Usize
                                      (M.read (| old_right_len |))
                                      (M.read (| count |)))
                                    (M.read (|
                                      M.get_constant (|
                                        "alloc::collections::btree::node::CAPACITY"
                                      |)
                                    |)))
                              |)) in
                          let _ :=
                            M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (|
                            M.never_to_any (|
                              M.call_closure (|
                                M.get_function (| "core::panicking::panic", [] |),
                                [
                                  M.read (|
                                    Value.String
                                      "assertion failed: old_right_len + count <= CAPACITY"
                                  |)
                                ]
                              |)
                            |)
                          |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                let~ _ :=
                  M.match_operator (|
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                UnOp.Pure.not
                                  (BinOp.Pure.ge (M.read (| old_left_len |)) (M.read (| count |)))
                              |)) in
                          let _ :=
                            M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (|
                            M.never_to_any (|
                              M.call_closure (|
                                M.get_function (| "core::panicking::panic", [] |),
                                [
                                  M.read (|
                                    Value.String "assertion failed: old_left_len >= count"
                                  |)
                                ]
                              |)
                            |)
                          |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                let~ new_left_len :=
                  M.alloc (|
                    BinOp.Wrap.sub Integer.Usize (M.read (| old_left_len |)) (M.read (| count |))
                  |) in
                let~ new_right_len :=
                  M.alloc (|
                    BinOp.Wrap.add Integer.Usize (M.read (| old_right_len |)) (M.read (| count |))
                  |) in
                let~ _ :=
                  M.write (|
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "alloc::collections::btree::node::NodeRef")
                          [
                            Ty.path "alloc::collections::btree::node::marker::Mut";
                            K;
                            V;
                            Ty.path "alloc::collections::btree::node::marker::LeafOrInternal"
                          ],
                        "len_mut",
                        []
                      |),
                      [ M.read (| left_node |) ]
                    |),
                    M.rust_cast (M.read (| new_left_len |))
                  |) in
                let~ _ :=
                  M.write (|
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "alloc::collections::btree::node::NodeRef")
                          [
                            Ty.path "alloc::collections::btree::node::marker::Mut";
                            K;
                            V;
                            Ty.path "alloc::collections::btree::node::marker::LeafOrInternal"
                          ],
                        "len_mut",
                        []
                      |),
                      [ M.read (| right_node |) ]
                    |),
                    M.rust_cast (M.read (| new_right_len |))
                  |) in
                let~ _ :=
                  let~ _ :=
                    M.alloc (|
                      M.call_closure (|
                        M.get_function (| "alloc::collections::btree::node::slice_shr", [ K ] |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply
                                (Ty.path "alloc::collections::btree::node::NodeRef")
                                [
                                  Ty.path "alloc::collections::btree::node::marker::Mut";
                                  K;
                                  V;
                                  Ty.path "alloc::collections::btree::node::marker::LeafOrInternal"
                                ],
                              "key_area_mut",
                              [
                                Ty.apply (Ty.path "core::ops::range::RangeTo") [ Ty.path "usize" ];
                                Ty.apply
                                  (Ty.path "slice")
                                  [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ K ]
                                  ]
                              ]
                            |),
                            [
                              M.read (| right_node |);
                              Value.StructRecord
                                "core::ops::range::RangeTo"
                                [ ("end_", M.read (| new_right_len |)) ]
                            ]
                          |);
                          M.read (| count |)
                        ]
                      |)
                    |) in
                  let~ _ :=
                    M.alloc (|
                      M.call_closure (|
                        M.get_function (| "alloc::collections::btree::node::slice_shr", [ V ] |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply
                                (Ty.path "alloc::collections::btree::node::NodeRef")
                                [
                                  Ty.path "alloc::collections::btree::node::marker::Mut";
                                  K;
                                  V;
                                  Ty.path "alloc::collections::btree::node::marker::LeafOrInternal"
                                ],
                              "val_area_mut",
                              [
                                Ty.apply (Ty.path "core::ops::range::RangeTo") [ Ty.path "usize" ];
                                Ty.apply
                                  (Ty.path "slice")
                                  [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ V ]
                                  ]
                              ]
                            |),
                            [
                              M.read (| right_node |);
                              Value.StructRecord
                                "core::ops::range::RangeTo"
                                [ ("end_", M.read (| new_right_len |)) ]
                            ]
                          |);
                          M.read (| count |)
                        ]
                      |)
                    |) in
                  let~ _ :=
                    M.alloc (|
                      M.call_closure (|
                        M.get_function (|
                          "alloc::collections::btree::node::move_to_slice",
                          [ K ]
                        |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply
                                (Ty.path "alloc::collections::btree::node::NodeRef")
                                [
                                  Ty.path "alloc::collections::btree::node::marker::Mut";
                                  K;
                                  V;
                                  Ty.path "alloc::collections::btree::node::marker::LeafOrInternal"
                                ],
                              "key_area_mut",
                              [
                                Ty.apply (Ty.path "core::ops::range::Range") [ Ty.path "usize" ];
                                Ty.apply
                                  (Ty.path "slice")
                                  [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ K ]
                                  ]
                              ]
                            |),
                            [
                              M.read (| left_node |);
                              Value.StructRecord
                                "core::ops::range::Range"
                                [
                                  ("start",
                                    BinOp.Wrap.add
                                      Integer.Usize
                                      (M.read (| new_left_len |))
                                      (Value.Integer 1));
                                  ("end_", M.read (| old_left_len |))
                                ]
                            ]
                          |);
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply
                                (Ty.path "alloc::collections::btree::node::NodeRef")
                                [
                                  Ty.path "alloc::collections::btree::node::marker::Mut";
                                  K;
                                  V;
                                  Ty.path "alloc::collections::btree::node::marker::LeafOrInternal"
                                ],
                              "key_area_mut",
                              [
                                Ty.apply (Ty.path "core::ops::range::RangeTo") [ Ty.path "usize" ];
                                Ty.apply
                                  (Ty.path "slice")
                                  [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ K ]
                                  ]
                              ]
                            |),
                            [
                              M.read (| right_node |);
                              Value.StructRecord
                                "core::ops::range::RangeTo"
                                [
                                  ("end_",
                                    BinOp.Wrap.sub
                                      Integer.Usize
                                      (M.read (| count |))
                                      (Value.Integer 1))
                                ]
                            ]
                          |)
                        ]
                      |)
                    |) in
                  let~ _ :=
                    M.alloc (|
                      M.call_closure (|
                        M.get_function (|
                          "alloc::collections::btree::node::move_to_slice",
                          [ V ]
                        |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply
                                (Ty.path "alloc::collections::btree::node::NodeRef")
                                [
                                  Ty.path "alloc::collections::btree::node::marker::Mut";
                                  K;
                                  V;
                                  Ty.path "alloc::collections::btree::node::marker::LeafOrInternal"
                                ],
                              "val_area_mut",
                              [
                                Ty.apply (Ty.path "core::ops::range::Range") [ Ty.path "usize" ];
                                Ty.apply
                                  (Ty.path "slice")
                                  [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ V ]
                                  ]
                              ]
                            |),
                            [
                              M.read (| left_node |);
                              Value.StructRecord
                                "core::ops::range::Range"
                                [
                                  ("start",
                                    BinOp.Wrap.add
                                      Integer.Usize
                                      (M.read (| new_left_len |))
                                      (Value.Integer 1));
                                  ("end_", M.read (| old_left_len |))
                                ]
                            ]
                          |);
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply
                                (Ty.path "alloc::collections::btree::node::NodeRef")
                                [
                                  Ty.path "alloc::collections::btree::node::marker::Mut";
                                  K;
                                  V;
                                  Ty.path "alloc::collections::btree::node::marker::LeafOrInternal"
                                ],
                              "val_area_mut",
                              [
                                Ty.apply (Ty.path "core::ops::range::RangeTo") [ Ty.path "usize" ];
                                Ty.apply
                                  (Ty.path "slice")
                                  [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ V ]
                                  ]
                              ]
                            |),
                            [
                              M.read (| right_node |);
                              Value.StructRecord
                                "core::ops::range::RangeTo"
                                [
                                  ("end_",
                                    BinOp.Wrap.sub
                                      Integer.Usize
                                      (M.read (| count |))
                                      (Value.Integer 1))
                                ]
                            ]
                          |)
                        ]
                      |)
                    |) in
                  let~ k :=
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ K ],
                          "assume_init_read",
                          []
                        |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply
                                (Ty.path "alloc::collections::btree::node::NodeRef")
                                [
                                  Ty.path "alloc::collections::btree::node::marker::Mut";
                                  K;
                                  V;
                                  Ty.path "alloc::collections::btree::node::marker::LeafOrInternal"
                                ],
                              "key_area_mut",
                              [
                                Ty.path "usize";
                                Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ K ]
                              ]
                            |),
                            [ M.read (| left_node |); M.read (| new_left_len |) ]
                          |)
                        ]
                      |)
                    |) in
                  let~ v :=
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ V ],
                          "assume_init_read",
                          []
                        |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply
                                (Ty.path "alloc::collections::btree::node::NodeRef")
                                [
                                  Ty.path "alloc::collections::btree::node::marker::Mut";
                                  K;
                                  V;
                                  Ty.path "alloc::collections::btree::node::marker::LeafOrInternal"
                                ],
                              "val_area_mut",
                              [
                                Ty.path "usize";
                                Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ V ]
                              ]
                            |),
                            [ M.read (| left_node |); M.read (| new_left_len |) ]
                          |)
                        ]
                      |)
                    |) in
                  M.match_operator (|
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply
                            (Ty.path "alloc::collections::btree::node::Handle")
                            [
                              Ty.apply
                                (Ty.path "alloc::collections::btree::node::NodeRef")
                                [
                                  Ty.path "alloc::collections::btree::node::marker::Mut";
                                  K;
                                  V;
                                  Ty.path "alloc::collections::btree::node::marker::Internal"
                                ];
                              Ty.path "alloc::collections::btree::node::marker::KV"
                            ],
                          "replace_kv",
                          []
                        |),
                        [
                          M.SubPointer.get_struct_record_field (|
                            M.read (| self |),
                            "alloc::collections::btree::node::BalancingContext",
                            "parent"
                          |);
                          M.read (| k |);
                          M.read (| v |)
                        ]
                      |)
                    |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                          let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                          let k := M.copy (| γ0_0 |) in
                          let v := M.copy (| γ0_1 |) in
                          let~ _ :=
                            M.alloc (|
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ K ],
                                  "write",
                                  []
                                |),
                                [
                                  M.call_closure (|
                                    M.get_associated_function (|
                                      Ty.apply
                                        (Ty.path "alloc::collections::btree::node::NodeRef")
                                        [
                                          Ty.path "alloc::collections::btree::node::marker::Mut";
                                          K;
                                          V;
                                          Ty.path
                                            "alloc::collections::btree::node::marker::LeafOrInternal"
                                        ],
                                      "key_area_mut",
                                      [
                                        Ty.path "usize";
                                        Ty.apply
                                          (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                          [ K ]
                                      ]
                                    |),
                                    [
                                      M.read (| right_node |);
                                      BinOp.Wrap.sub
                                        Integer.Usize
                                        (M.read (| count |))
                                        (Value.Integer 1)
                                    ]
                                  |);
                                  M.read (| k |)
                                ]
                              |)
                            |) in
                          let~ _ :=
                            M.alloc (|
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ V ],
                                  "write",
                                  []
                                |),
                                [
                                  M.call_closure (|
                                    M.get_associated_function (|
                                      Ty.apply
                                        (Ty.path "alloc::collections::btree::node::NodeRef")
                                        [
                                          Ty.path "alloc::collections::btree::node::marker::Mut";
                                          K;
                                          V;
                                          Ty.path
                                            "alloc::collections::btree::node::marker::LeafOrInternal"
                                        ],
                                      "val_area_mut",
                                      [
                                        Ty.path "usize";
                                        Ty.apply
                                          (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                          [ V ]
                                      ]
                                    |),
                                    [
                                      M.read (| right_node |);
                                      BinOp.Wrap.sub
                                        Integer.Usize
                                        (M.read (| count |))
                                        (Value.Integer 1)
                                    ]
                                  |);
                                  M.read (| v |)
                                ]
                              |)
                            |) in
                          M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                M.match_operator (|
                  M.alloc (|
                    Value.Tuple
                      [
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.apply
                              (Ty.path "alloc::collections::btree::node::NodeRef")
                              [
                                Ty.path "alloc::collections::btree::node::marker::Mut";
                                K;
                                V;
                                Ty.path "alloc::collections::btree::node::marker::LeafOrInternal"
                              ],
                            "force",
                            []
                          |),
                          [
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "alloc::collections::btree::node::NodeRef")
                                  [
                                    Ty.path "alloc::collections::btree::node::marker::Mut";
                                    K;
                                    V;
                                    Ty.path
                                      "alloc::collections::btree::node::marker::LeafOrInternal"
                                  ],
                                "reborrow_mut",
                                []
                              |),
                              [ M.read (| left_node |) ]
                            |)
                          ]
                        |);
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.apply
                              (Ty.path "alloc::collections::btree::node::NodeRef")
                              [
                                Ty.path "alloc::collections::btree::node::marker::Mut";
                                K;
                                V;
                                Ty.path "alloc::collections::btree::node::marker::LeafOrInternal"
                              ],
                            "force",
                            []
                          |),
                          [
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "alloc::collections::btree::node::NodeRef")
                                  [
                                    Ty.path "alloc::collections::btree::node::marker::Mut";
                                    K;
                                    V;
                                    Ty.path
                                      "alloc::collections::btree::node::marker::LeafOrInternal"
                                  ],
                                "reborrow_mut",
                                []
                              |),
                              [ M.read (| right_node |) ]
                            |)
                          ]
                        |)
                      ]
                  |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                        let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                        let γ1_0 :=
                          M.SubPointer.get_struct_tuple_field (|
                            γ0_0,
                            "alloc::collections::btree::node::ForceResult::Internal",
                            0
                          |) in
                        let left := M.copy (| γ1_0 |) in
                        let γ1_0 :=
                          M.SubPointer.get_struct_tuple_field (|
                            γ0_1,
                            "alloc::collections::btree::node::ForceResult::Internal",
                            0
                          |) in
                        let right := M.copy (| γ1_0 |) in
                        let~ _ :=
                          M.alloc (|
                            M.call_closure (|
                              M.get_function (|
                                "alloc::collections::btree::node::slice_shr",
                                [
                                  Ty.apply
                                    (Ty.path "core::ptr::non_null::NonNull")
                                    [
                                      Ty.apply
                                        (Ty.path "alloc::collections::btree::node::LeafNode")
                                        [ K; V ]
                                    ]
                                ]
                              |),
                              [
                                M.call_closure (|
                                  M.get_associated_function (|
                                    Ty.apply
                                      (Ty.path "alloc::collections::btree::node::NodeRef")
                                      [
                                        Ty.path "alloc::collections::btree::node::marker::Mut";
                                        K;
                                        V;
                                        Ty.path "alloc::collections::btree::node::marker::Internal"
                                      ],
                                    "edge_area_mut",
                                    [
                                      Ty.apply
                                        (Ty.path "core::ops::range::RangeTo")
                                        [ Ty.path "usize" ];
                                      Ty.apply
                                        (Ty.path "slice")
                                        [
                                          Ty.apply
                                            (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                            [
                                              Ty.apply
                                                (Ty.path "core::ptr::non_null::NonNull")
                                                [
                                                  Ty.apply
                                                    (Ty.path
                                                      "alloc::collections::btree::node::LeafNode")
                                                    [ K; V ]
                                                ]
                                            ]
                                        ]
                                    ]
                                  |),
                                  [
                                    right;
                                    Value.StructRecord
                                      "core::ops::range::RangeTo"
                                      [
                                        ("end_",
                                          BinOp.Wrap.add
                                            Integer.Usize
                                            (M.read (| new_right_len |))
                                            (Value.Integer 1))
                                      ]
                                  ]
                                |);
                                M.read (| count |)
                              ]
                            |)
                          |) in
                        let~ _ :=
                          M.alloc (|
                            M.call_closure (|
                              M.get_function (|
                                "alloc::collections::btree::node::move_to_slice",
                                [
                                  Ty.apply
                                    (Ty.path "core::ptr::non_null::NonNull")
                                    [
                                      Ty.apply
                                        (Ty.path "alloc::collections::btree::node::LeafNode")
                                        [ K; V ]
                                    ]
                                ]
                              |),
                              [
                                M.call_closure (|
                                  M.get_associated_function (|
                                    Ty.apply
                                      (Ty.path "alloc::collections::btree::node::NodeRef")
                                      [
                                        Ty.path "alloc::collections::btree::node::marker::Mut";
                                        K;
                                        V;
                                        Ty.path "alloc::collections::btree::node::marker::Internal"
                                      ],
                                    "edge_area_mut",
                                    [
                                      Ty.apply
                                        (Ty.path "core::ops::range::Range")
                                        [ Ty.path "usize" ];
                                      Ty.apply
                                        (Ty.path "slice")
                                        [
                                          Ty.apply
                                            (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                            [
                                              Ty.apply
                                                (Ty.path "core::ptr::non_null::NonNull")
                                                [
                                                  Ty.apply
                                                    (Ty.path
                                                      "alloc::collections::btree::node::LeafNode")
                                                    [ K; V ]
                                                ]
                                            ]
                                        ]
                                    ]
                                  |),
                                  [
                                    left;
                                    Value.StructRecord
                                      "core::ops::range::Range"
                                      [
                                        ("start",
                                          BinOp.Wrap.add
                                            Integer.Usize
                                            (M.read (| new_left_len |))
                                            (Value.Integer 1));
                                        ("end_",
                                          BinOp.Wrap.add
                                            Integer.Usize
                                            (M.read (| old_left_len |))
                                            (Value.Integer 1))
                                      ]
                                  ]
                                |);
                                M.call_closure (|
                                  M.get_associated_function (|
                                    Ty.apply
                                      (Ty.path "alloc::collections::btree::node::NodeRef")
                                      [
                                        Ty.path "alloc::collections::btree::node::marker::Mut";
                                        K;
                                        V;
                                        Ty.path "alloc::collections::btree::node::marker::Internal"
                                      ],
                                    "edge_area_mut",
                                    [
                                      Ty.apply
                                        (Ty.path "core::ops::range::RangeTo")
                                        [ Ty.path "usize" ];
                                      Ty.apply
                                        (Ty.path "slice")
                                        [
                                          Ty.apply
                                            (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                            [
                                              Ty.apply
                                                (Ty.path "core::ptr::non_null::NonNull")
                                                [
                                                  Ty.apply
                                                    (Ty.path
                                                      "alloc::collections::btree::node::LeafNode")
                                                    [ K; V ]
                                                ]
                                            ]
                                        ]
                                    ]
                                  |),
                                  [
                                    right;
                                    Value.StructRecord
                                      "core::ops::range::RangeTo"
                                      [ ("end_", M.read (| count |)) ]
                                  ]
                                |)
                              ]
                            |)
                          |) in
                        let~ _ :=
                          M.alloc (|
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "alloc::collections::btree::node::NodeRef")
                                  [
                                    Ty.path "alloc::collections::btree::node::marker::Mut";
                                    K;
                                    V;
                                    Ty.path "alloc::collections::btree::node::marker::Internal"
                                  ],
                                "correct_childrens_parent_links",
                                [ Ty.apply (Ty.path "core::ops::range::Range") [ Ty.path "usize" ] ]
                              |),
                              [
                                right;
                                Value.StructRecord
                                  "core::ops::range::Range"
                                  [
                                    ("start", Value.Integer 0);
                                    ("end_",
                                      BinOp.Wrap.add
                                        Integer.Usize
                                        (M.read (| new_right_len |))
                                        (Value.Integer 1))
                                  ]
                              ]
                            |)
                          |) in
                        M.alloc (| Value.Tuple [] |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                        let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                        let γ1_0 :=
                          M.SubPointer.get_struct_tuple_field (|
                            γ0_0,
                            "alloc::collections::btree::node::ForceResult::Leaf",
                            0
                          |) in
                        let γ1_0 :=
                          M.SubPointer.get_struct_tuple_field (|
                            γ0_1,
                            "alloc::collections::btree::node::ForceResult::Leaf",
                            0
                          |) in
                        M.alloc (| Value.Tuple [] |)));
                    fun γ =>
                      ltac:(M.monadic
                        (M.alloc (|
                          M.never_to_any (|
                            M.call_closure (|
                              M.get_function (| "core::panicking::panic", [] |),
                              [ M.read (| Value.String "internal error: entered unreachable code" |)
                              ]
                            |)
                          |)
                        |)))
                  ]
                |)
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom AssociatedFunction_bulk_steal_left :
          forall (K V : Ty.t),
          M.IsAssociatedFunction (Self K V) "bulk_steal_left" (bulk_steal_left K V).
        
        (*
            pub fn bulk_steal_right(&mut self, count: usize) {
                assert!(count > 0);
                unsafe {
                    let left_node = &mut self.left_child;
                    let old_left_len = left_node.len();
                    let right_node = &mut self.right_child;
                    let old_right_len = right_node.len();
        
                    // Make sure that we may steal safely.
                    assert!(old_left_len + count <= CAPACITY);
                    assert!(old_right_len >= count);
        
                    let new_left_len = old_left_len + count;
                    let new_right_len = old_right_len - count;
                    *left_node.len_mut() = new_left_len as u16;
                    *right_node.len_mut() = new_right_len as u16;
        
                    // Move leaf data.
                    {
                        // Move the right-most stolen pair to the parent.
                        let k = right_node.key_area_mut(count - 1).assume_init_read();
                        let v = right_node.val_area_mut(count - 1).assume_init_read();
                        let (k, v) = self.parent.replace_kv(k, v);
        
                        // Move parent's key-value pair to the left child.
                        left_node.key_area_mut(old_left_len).write(k);
                        left_node.val_area_mut(old_left_len).write(v);
        
                        // Move elements from the right child to the left one.
                        move_to_slice(
                            right_node.key_area_mut(..count - 1),
                            left_node.key_area_mut(old_left_len + 1..new_left_len),
                        );
                        move_to_slice(
                            right_node.val_area_mut(..count - 1),
                            left_node.val_area_mut(old_left_len + 1..new_left_len),
                        );
        
                        // Fill gap where stolen elements used to be.
                        slice_shl(right_node.key_area_mut(..old_right_len), count);
                        slice_shl(right_node.val_area_mut(..old_right_len), count);
                    }
        
                    match (left_node.reborrow_mut().force(), right_node.reborrow_mut().force()) {
                        (ForceResult::Internal(mut left), ForceResult::Internal(mut right)) => {
                            // Steal edges.
                            move_to_slice(
                                right.edge_area_mut(..count),
                                left.edge_area_mut(old_left_len + 1..new_left_len + 1),
                            );
        
                            // Fill gap where stolen edges used to be.
                            slice_shl(right.edge_area_mut(..old_right_len + 1), count);
        
                            left.correct_childrens_parent_links(old_left_len + 1..new_left_len + 1);
                            right.correct_childrens_parent_links(0..new_right_len + 1);
                        }
                        (ForceResult::Leaf(_), ForceResult::Leaf(_)) => {}
                        _ => unreachable!(),
                    }
                }
            }
        *)
        Definition bulk_steal_right (K V : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self K V in
          match τ, α with
          | [], [ self; count ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let count := M.alloc (| count |) in
              M.read (|
                let~ _ :=
                  M.match_operator (|
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                UnOp.Pure.not (BinOp.Pure.gt (M.read (| count |)) (Value.Integer 0))
                              |)) in
                          let _ :=
                            M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (|
                            M.never_to_any (|
                              M.call_closure (|
                                M.get_function (| "core::panicking::panic", [] |),
                                [ M.read (| Value.String "assertion failed: count > 0" |) ]
                              |)
                            |)
                          |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                let~ left_node :=
                  M.alloc (|
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "alloc::collections::btree::node::BalancingContext",
                      "left_child"
                    |)
                  |) in
                let~ old_left_len :=
                  M.alloc (|
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "alloc::collections::btree::node::NodeRef")
                          [
                            Ty.path "alloc::collections::btree::node::marker::Mut";
                            K;
                            V;
                            Ty.path "alloc::collections::btree::node::marker::LeafOrInternal"
                          ],
                        "len",
                        []
                      |),
                      [ M.read (| left_node |) ]
                    |)
                  |) in
                let~ right_node :=
                  M.alloc (|
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "alloc::collections::btree::node::BalancingContext",
                      "right_child"
                    |)
                  |) in
                let~ old_right_len :=
                  M.alloc (|
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "alloc::collections::btree::node::NodeRef")
                          [
                            Ty.path "alloc::collections::btree::node::marker::Mut";
                            K;
                            V;
                            Ty.path "alloc::collections::btree::node::marker::LeafOrInternal"
                          ],
                        "len",
                        []
                      |),
                      [ M.read (| right_node |) ]
                    |)
                  |) in
                let~ _ :=
                  M.match_operator (|
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                UnOp.Pure.not
                                  (BinOp.Pure.le
                                    (BinOp.Wrap.add
                                      Integer.Usize
                                      (M.read (| old_left_len |))
                                      (M.read (| count |)))
                                    (M.read (|
                                      M.get_constant (|
                                        "alloc::collections::btree::node::CAPACITY"
                                      |)
                                    |)))
                              |)) in
                          let _ :=
                            M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (|
                            M.never_to_any (|
                              M.call_closure (|
                                M.get_function (| "core::panicking::panic", [] |),
                                [
                                  M.read (|
                                    Value.String
                                      "assertion failed: old_left_len + count <= CAPACITY"
                                  |)
                                ]
                              |)
                            |)
                          |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                let~ _ :=
                  M.match_operator (|
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                UnOp.Pure.not
                                  (BinOp.Pure.ge (M.read (| old_right_len |)) (M.read (| count |)))
                              |)) in
                          let _ :=
                            M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (|
                            M.never_to_any (|
                              M.call_closure (|
                                M.get_function (| "core::panicking::panic", [] |),
                                [
                                  M.read (|
                                    Value.String "assertion failed: old_right_len >= count"
                                  |)
                                ]
                              |)
                            |)
                          |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                let~ new_left_len :=
                  M.alloc (|
                    BinOp.Wrap.add Integer.Usize (M.read (| old_left_len |)) (M.read (| count |))
                  |) in
                let~ new_right_len :=
                  M.alloc (|
                    BinOp.Wrap.sub Integer.Usize (M.read (| old_right_len |)) (M.read (| count |))
                  |) in
                let~ _ :=
                  M.write (|
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "alloc::collections::btree::node::NodeRef")
                          [
                            Ty.path "alloc::collections::btree::node::marker::Mut";
                            K;
                            V;
                            Ty.path "alloc::collections::btree::node::marker::LeafOrInternal"
                          ],
                        "len_mut",
                        []
                      |),
                      [ M.read (| left_node |) ]
                    |),
                    M.rust_cast (M.read (| new_left_len |))
                  |) in
                let~ _ :=
                  M.write (|
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "alloc::collections::btree::node::NodeRef")
                          [
                            Ty.path "alloc::collections::btree::node::marker::Mut";
                            K;
                            V;
                            Ty.path "alloc::collections::btree::node::marker::LeafOrInternal"
                          ],
                        "len_mut",
                        []
                      |),
                      [ M.read (| right_node |) ]
                    |),
                    M.rust_cast (M.read (| new_right_len |))
                  |) in
                let~ _ :=
                  let~ k :=
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ K ],
                          "assume_init_read",
                          []
                        |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply
                                (Ty.path "alloc::collections::btree::node::NodeRef")
                                [
                                  Ty.path "alloc::collections::btree::node::marker::Mut";
                                  K;
                                  V;
                                  Ty.path "alloc::collections::btree::node::marker::LeafOrInternal"
                                ],
                              "key_area_mut",
                              [
                                Ty.path "usize";
                                Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ K ]
                              ]
                            |),
                            [
                              M.read (| right_node |);
                              BinOp.Wrap.sub Integer.Usize (M.read (| count |)) (Value.Integer 1)
                            ]
                          |)
                        ]
                      |)
                    |) in
                  let~ v :=
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ V ],
                          "assume_init_read",
                          []
                        |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply
                                (Ty.path "alloc::collections::btree::node::NodeRef")
                                [
                                  Ty.path "alloc::collections::btree::node::marker::Mut";
                                  K;
                                  V;
                                  Ty.path "alloc::collections::btree::node::marker::LeafOrInternal"
                                ],
                              "val_area_mut",
                              [
                                Ty.path "usize";
                                Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ V ]
                              ]
                            |),
                            [
                              M.read (| right_node |);
                              BinOp.Wrap.sub Integer.Usize (M.read (| count |)) (Value.Integer 1)
                            ]
                          |)
                        ]
                      |)
                    |) in
                  M.match_operator (|
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply
                            (Ty.path "alloc::collections::btree::node::Handle")
                            [
                              Ty.apply
                                (Ty.path "alloc::collections::btree::node::NodeRef")
                                [
                                  Ty.path "alloc::collections::btree::node::marker::Mut";
                                  K;
                                  V;
                                  Ty.path "alloc::collections::btree::node::marker::Internal"
                                ];
                              Ty.path "alloc::collections::btree::node::marker::KV"
                            ],
                          "replace_kv",
                          []
                        |),
                        [
                          M.SubPointer.get_struct_record_field (|
                            M.read (| self |),
                            "alloc::collections::btree::node::BalancingContext",
                            "parent"
                          |);
                          M.read (| k |);
                          M.read (| v |)
                        ]
                      |)
                    |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                          let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                          let k := M.copy (| γ0_0 |) in
                          let v := M.copy (| γ0_1 |) in
                          let~ _ :=
                            M.alloc (|
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ K ],
                                  "write",
                                  []
                                |),
                                [
                                  M.call_closure (|
                                    M.get_associated_function (|
                                      Ty.apply
                                        (Ty.path "alloc::collections::btree::node::NodeRef")
                                        [
                                          Ty.path "alloc::collections::btree::node::marker::Mut";
                                          K;
                                          V;
                                          Ty.path
                                            "alloc::collections::btree::node::marker::LeafOrInternal"
                                        ],
                                      "key_area_mut",
                                      [
                                        Ty.path "usize";
                                        Ty.apply
                                          (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                          [ K ]
                                      ]
                                    |),
                                    [ M.read (| left_node |); M.read (| old_left_len |) ]
                                  |);
                                  M.read (| k |)
                                ]
                              |)
                            |) in
                          let~ _ :=
                            M.alloc (|
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ V ],
                                  "write",
                                  []
                                |),
                                [
                                  M.call_closure (|
                                    M.get_associated_function (|
                                      Ty.apply
                                        (Ty.path "alloc::collections::btree::node::NodeRef")
                                        [
                                          Ty.path "alloc::collections::btree::node::marker::Mut";
                                          K;
                                          V;
                                          Ty.path
                                            "alloc::collections::btree::node::marker::LeafOrInternal"
                                        ],
                                      "val_area_mut",
                                      [
                                        Ty.path "usize";
                                        Ty.apply
                                          (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                          [ V ]
                                      ]
                                    |),
                                    [ M.read (| left_node |); M.read (| old_left_len |) ]
                                  |);
                                  M.read (| v |)
                                ]
                              |)
                            |) in
                          let~ _ :=
                            M.alloc (|
                              M.call_closure (|
                                M.get_function (|
                                  "alloc::collections::btree::node::move_to_slice",
                                  [ K ]
                                |),
                                [
                                  M.call_closure (|
                                    M.get_associated_function (|
                                      Ty.apply
                                        (Ty.path "alloc::collections::btree::node::NodeRef")
                                        [
                                          Ty.path "alloc::collections::btree::node::marker::Mut";
                                          K;
                                          V;
                                          Ty.path
                                            "alloc::collections::btree::node::marker::LeafOrInternal"
                                        ],
                                      "key_area_mut",
                                      [
                                        Ty.apply
                                          (Ty.path "core::ops::range::RangeTo")
                                          [ Ty.path "usize" ];
                                        Ty.apply
                                          (Ty.path "slice")
                                          [
                                            Ty.apply
                                              (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                              [ K ]
                                          ]
                                      ]
                                    |),
                                    [
                                      M.read (| right_node |);
                                      Value.StructRecord
                                        "core::ops::range::RangeTo"
                                        [
                                          ("end_",
                                            BinOp.Wrap.sub
                                              Integer.Usize
                                              (M.read (| count |))
                                              (Value.Integer 1))
                                        ]
                                    ]
                                  |);
                                  M.call_closure (|
                                    M.get_associated_function (|
                                      Ty.apply
                                        (Ty.path "alloc::collections::btree::node::NodeRef")
                                        [
                                          Ty.path "alloc::collections::btree::node::marker::Mut";
                                          K;
                                          V;
                                          Ty.path
                                            "alloc::collections::btree::node::marker::LeafOrInternal"
                                        ],
                                      "key_area_mut",
                                      [
                                        Ty.apply
                                          (Ty.path "core::ops::range::Range")
                                          [ Ty.path "usize" ];
                                        Ty.apply
                                          (Ty.path "slice")
                                          [
                                            Ty.apply
                                              (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                              [ K ]
                                          ]
                                      ]
                                    |),
                                    [
                                      M.read (| left_node |);
                                      Value.StructRecord
                                        "core::ops::range::Range"
                                        [
                                          ("start",
                                            BinOp.Wrap.add
                                              Integer.Usize
                                              (M.read (| old_left_len |))
                                              (Value.Integer 1));
                                          ("end_", M.read (| new_left_len |))
                                        ]
                                    ]
                                  |)
                                ]
                              |)
                            |) in
                          let~ _ :=
                            M.alloc (|
                              M.call_closure (|
                                M.get_function (|
                                  "alloc::collections::btree::node::move_to_slice",
                                  [ V ]
                                |),
                                [
                                  M.call_closure (|
                                    M.get_associated_function (|
                                      Ty.apply
                                        (Ty.path "alloc::collections::btree::node::NodeRef")
                                        [
                                          Ty.path "alloc::collections::btree::node::marker::Mut";
                                          K;
                                          V;
                                          Ty.path
                                            "alloc::collections::btree::node::marker::LeafOrInternal"
                                        ],
                                      "val_area_mut",
                                      [
                                        Ty.apply
                                          (Ty.path "core::ops::range::RangeTo")
                                          [ Ty.path "usize" ];
                                        Ty.apply
                                          (Ty.path "slice")
                                          [
                                            Ty.apply
                                              (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                              [ V ]
                                          ]
                                      ]
                                    |),
                                    [
                                      M.read (| right_node |);
                                      Value.StructRecord
                                        "core::ops::range::RangeTo"
                                        [
                                          ("end_",
                                            BinOp.Wrap.sub
                                              Integer.Usize
                                              (M.read (| count |))
                                              (Value.Integer 1))
                                        ]
                                    ]
                                  |);
                                  M.call_closure (|
                                    M.get_associated_function (|
                                      Ty.apply
                                        (Ty.path "alloc::collections::btree::node::NodeRef")
                                        [
                                          Ty.path "alloc::collections::btree::node::marker::Mut";
                                          K;
                                          V;
                                          Ty.path
                                            "alloc::collections::btree::node::marker::LeafOrInternal"
                                        ],
                                      "val_area_mut",
                                      [
                                        Ty.apply
                                          (Ty.path "core::ops::range::Range")
                                          [ Ty.path "usize" ];
                                        Ty.apply
                                          (Ty.path "slice")
                                          [
                                            Ty.apply
                                              (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                              [ V ]
                                          ]
                                      ]
                                    |),
                                    [
                                      M.read (| left_node |);
                                      Value.StructRecord
                                        "core::ops::range::Range"
                                        [
                                          ("start",
                                            BinOp.Wrap.add
                                              Integer.Usize
                                              (M.read (| old_left_len |))
                                              (Value.Integer 1));
                                          ("end_", M.read (| new_left_len |))
                                        ]
                                    ]
                                  |)
                                ]
                              |)
                            |) in
                          let~ _ :=
                            M.alloc (|
                              M.call_closure (|
                                M.get_function (|
                                  "alloc::collections::btree::node::slice_shl",
                                  [ K ]
                                |),
                                [
                                  M.call_closure (|
                                    M.get_associated_function (|
                                      Ty.apply
                                        (Ty.path "alloc::collections::btree::node::NodeRef")
                                        [
                                          Ty.path "alloc::collections::btree::node::marker::Mut";
                                          K;
                                          V;
                                          Ty.path
                                            "alloc::collections::btree::node::marker::LeafOrInternal"
                                        ],
                                      "key_area_mut",
                                      [
                                        Ty.apply
                                          (Ty.path "core::ops::range::RangeTo")
                                          [ Ty.path "usize" ];
                                        Ty.apply
                                          (Ty.path "slice")
                                          [
                                            Ty.apply
                                              (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                              [ K ]
                                          ]
                                      ]
                                    |),
                                    [
                                      M.read (| right_node |);
                                      Value.StructRecord
                                        "core::ops::range::RangeTo"
                                        [ ("end_", M.read (| old_right_len |)) ]
                                    ]
                                  |);
                                  M.read (| count |)
                                ]
                              |)
                            |) in
                          let~ _ :=
                            M.alloc (|
                              M.call_closure (|
                                M.get_function (|
                                  "alloc::collections::btree::node::slice_shl",
                                  [ V ]
                                |),
                                [
                                  M.call_closure (|
                                    M.get_associated_function (|
                                      Ty.apply
                                        (Ty.path "alloc::collections::btree::node::NodeRef")
                                        [
                                          Ty.path "alloc::collections::btree::node::marker::Mut";
                                          K;
                                          V;
                                          Ty.path
                                            "alloc::collections::btree::node::marker::LeafOrInternal"
                                        ],
                                      "val_area_mut",
                                      [
                                        Ty.apply
                                          (Ty.path "core::ops::range::RangeTo")
                                          [ Ty.path "usize" ];
                                        Ty.apply
                                          (Ty.path "slice")
                                          [
                                            Ty.apply
                                              (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                              [ V ]
                                          ]
                                      ]
                                    |),
                                    [
                                      M.read (| right_node |);
                                      Value.StructRecord
                                        "core::ops::range::RangeTo"
                                        [ ("end_", M.read (| old_right_len |)) ]
                                    ]
                                  |);
                                  M.read (| count |)
                                ]
                              |)
                            |) in
                          M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                M.match_operator (|
                  M.alloc (|
                    Value.Tuple
                      [
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.apply
                              (Ty.path "alloc::collections::btree::node::NodeRef")
                              [
                                Ty.path "alloc::collections::btree::node::marker::Mut";
                                K;
                                V;
                                Ty.path "alloc::collections::btree::node::marker::LeafOrInternal"
                              ],
                            "force",
                            []
                          |),
                          [
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "alloc::collections::btree::node::NodeRef")
                                  [
                                    Ty.path "alloc::collections::btree::node::marker::Mut";
                                    K;
                                    V;
                                    Ty.path
                                      "alloc::collections::btree::node::marker::LeafOrInternal"
                                  ],
                                "reborrow_mut",
                                []
                              |),
                              [ M.read (| left_node |) ]
                            |)
                          ]
                        |);
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.apply
                              (Ty.path "alloc::collections::btree::node::NodeRef")
                              [
                                Ty.path "alloc::collections::btree::node::marker::Mut";
                                K;
                                V;
                                Ty.path "alloc::collections::btree::node::marker::LeafOrInternal"
                              ],
                            "force",
                            []
                          |),
                          [
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "alloc::collections::btree::node::NodeRef")
                                  [
                                    Ty.path "alloc::collections::btree::node::marker::Mut";
                                    K;
                                    V;
                                    Ty.path
                                      "alloc::collections::btree::node::marker::LeafOrInternal"
                                  ],
                                "reborrow_mut",
                                []
                              |),
                              [ M.read (| right_node |) ]
                            |)
                          ]
                        |)
                      ]
                  |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                        let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                        let γ1_0 :=
                          M.SubPointer.get_struct_tuple_field (|
                            γ0_0,
                            "alloc::collections::btree::node::ForceResult::Internal",
                            0
                          |) in
                        let left := M.copy (| γ1_0 |) in
                        let γ1_0 :=
                          M.SubPointer.get_struct_tuple_field (|
                            γ0_1,
                            "alloc::collections::btree::node::ForceResult::Internal",
                            0
                          |) in
                        let right := M.copy (| γ1_0 |) in
                        let~ _ :=
                          M.alloc (|
                            M.call_closure (|
                              M.get_function (|
                                "alloc::collections::btree::node::move_to_slice",
                                [
                                  Ty.apply
                                    (Ty.path "core::ptr::non_null::NonNull")
                                    [
                                      Ty.apply
                                        (Ty.path "alloc::collections::btree::node::LeafNode")
                                        [ K; V ]
                                    ]
                                ]
                              |),
                              [
                                M.call_closure (|
                                  M.get_associated_function (|
                                    Ty.apply
                                      (Ty.path "alloc::collections::btree::node::NodeRef")
                                      [
                                        Ty.path "alloc::collections::btree::node::marker::Mut";
                                        K;
                                        V;
                                        Ty.path "alloc::collections::btree::node::marker::Internal"
                                      ],
                                    "edge_area_mut",
                                    [
                                      Ty.apply
                                        (Ty.path "core::ops::range::RangeTo")
                                        [ Ty.path "usize" ];
                                      Ty.apply
                                        (Ty.path "slice")
                                        [
                                          Ty.apply
                                            (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                            [
                                              Ty.apply
                                                (Ty.path "core::ptr::non_null::NonNull")
                                                [
                                                  Ty.apply
                                                    (Ty.path
                                                      "alloc::collections::btree::node::LeafNode")
                                                    [ K; V ]
                                                ]
                                            ]
                                        ]
                                    ]
                                  |),
                                  [
                                    right;
                                    Value.StructRecord
                                      "core::ops::range::RangeTo"
                                      [ ("end_", M.read (| count |)) ]
                                  ]
                                |);
                                M.call_closure (|
                                  M.get_associated_function (|
                                    Ty.apply
                                      (Ty.path "alloc::collections::btree::node::NodeRef")
                                      [
                                        Ty.path "alloc::collections::btree::node::marker::Mut";
                                        K;
                                        V;
                                        Ty.path "alloc::collections::btree::node::marker::Internal"
                                      ],
                                    "edge_area_mut",
                                    [
                                      Ty.apply
                                        (Ty.path "core::ops::range::Range")
                                        [ Ty.path "usize" ];
                                      Ty.apply
                                        (Ty.path "slice")
                                        [
                                          Ty.apply
                                            (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                            [
                                              Ty.apply
                                                (Ty.path "core::ptr::non_null::NonNull")
                                                [
                                                  Ty.apply
                                                    (Ty.path
                                                      "alloc::collections::btree::node::LeafNode")
                                                    [ K; V ]
                                                ]
                                            ]
                                        ]
                                    ]
                                  |),
                                  [
                                    left;
                                    Value.StructRecord
                                      "core::ops::range::Range"
                                      [
                                        ("start",
                                          BinOp.Wrap.add
                                            Integer.Usize
                                            (M.read (| old_left_len |))
                                            (Value.Integer 1));
                                        ("end_",
                                          BinOp.Wrap.add
                                            Integer.Usize
                                            (M.read (| new_left_len |))
                                            (Value.Integer 1))
                                      ]
                                  ]
                                |)
                              ]
                            |)
                          |) in
                        let~ _ :=
                          M.alloc (|
                            M.call_closure (|
                              M.get_function (|
                                "alloc::collections::btree::node::slice_shl",
                                [
                                  Ty.apply
                                    (Ty.path "core::ptr::non_null::NonNull")
                                    [
                                      Ty.apply
                                        (Ty.path "alloc::collections::btree::node::LeafNode")
                                        [ K; V ]
                                    ]
                                ]
                              |),
                              [
                                M.call_closure (|
                                  M.get_associated_function (|
                                    Ty.apply
                                      (Ty.path "alloc::collections::btree::node::NodeRef")
                                      [
                                        Ty.path "alloc::collections::btree::node::marker::Mut";
                                        K;
                                        V;
                                        Ty.path "alloc::collections::btree::node::marker::Internal"
                                      ],
                                    "edge_area_mut",
                                    [
                                      Ty.apply
                                        (Ty.path "core::ops::range::RangeTo")
                                        [ Ty.path "usize" ];
                                      Ty.apply
                                        (Ty.path "slice")
                                        [
                                          Ty.apply
                                            (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                            [
                                              Ty.apply
                                                (Ty.path "core::ptr::non_null::NonNull")
                                                [
                                                  Ty.apply
                                                    (Ty.path
                                                      "alloc::collections::btree::node::LeafNode")
                                                    [ K; V ]
                                                ]
                                            ]
                                        ]
                                    ]
                                  |),
                                  [
                                    right;
                                    Value.StructRecord
                                      "core::ops::range::RangeTo"
                                      [
                                        ("end_",
                                          BinOp.Wrap.add
                                            Integer.Usize
                                            (M.read (| old_right_len |))
                                            (Value.Integer 1))
                                      ]
                                  ]
                                |);
                                M.read (| count |)
                              ]
                            |)
                          |) in
                        let~ _ :=
                          M.alloc (|
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "alloc::collections::btree::node::NodeRef")
                                  [
                                    Ty.path "alloc::collections::btree::node::marker::Mut";
                                    K;
                                    V;
                                    Ty.path "alloc::collections::btree::node::marker::Internal"
                                  ],
                                "correct_childrens_parent_links",
                                [ Ty.apply (Ty.path "core::ops::range::Range") [ Ty.path "usize" ] ]
                              |),
                              [
                                left;
                                Value.StructRecord
                                  "core::ops::range::Range"
                                  [
                                    ("start",
                                      BinOp.Wrap.add
                                        Integer.Usize
                                        (M.read (| old_left_len |))
                                        (Value.Integer 1));
                                    ("end_",
                                      BinOp.Wrap.add
                                        Integer.Usize
                                        (M.read (| new_left_len |))
                                        (Value.Integer 1))
                                  ]
                              ]
                            |)
                          |) in
                        let~ _ :=
                          M.alloc (|
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "alloc::collections::btree::node::NodeRef")
                                  [
                                    Ty.path "alloc::collections::btree::node::marker::Mut";
                                    K;
                                    V;
                                    Ty.path "alloc::collections::btree::node::marker::Internal"
                                  ],
                                "correct_childrens_parent_links",
                                [ Ty.apply (Ty.path "core::ops::range::Range") [ Ty.path "usize" ] ]
                              |),
                              [
                                right;
                                Value.StructRecord
                                  "core::ops::range::Range"
                                  [
                                    ("start", Value.Integer 0);
                                    ("end_",
                                      BinOp.Wrap.add
                                        Integer.Usize
                                        (M.read (| new_right_len |))
                                        (Value.Integer 1))
                                  ]
                              ]
                            |)
                          |) in
                        M.alloc (| Value.Tuple [] |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                        let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                        let γ1_0 :=
                          M.SubPointer.get_struct_tuple_field (|
                            γ0_0,
                            "alloc::collections::btree::node::ForceResult::Leaf",
                            0
                          |) in
                        let γ1_0 :=
                          M.SubPointer.get_struct_tuple_field (|
                            γ0_1,
                            "alloc::collections::btree::node::ForceResult::Leaf",
                            0
                          |) in
                        M.alloc (| Value.Tuple [] |)));
                    fun γ =>
                      ltac:(M.monadic
                        (M.alloc (|
                          M.never_to_any (|
                            M.call_closure (|
                              M.get_function (| "core::panicking::panic", [] |),
                              [ M.read (| Value.String "internal error: entered unreachable code" |)
                              ]
                            |)
                          |)
                        |)))
                  ]
                |)
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom AssociatedFunction_bulk_steal_right :
          forall (K V : Ty.t),
          M.IsAssociatedFunction (Self K V) "bulk_steal_right" (bulk_steal_right K V).
      End Impl_alloc_collections_btree_node_BalancingContext_K_V.
      
      
      Module Impl_alloc_collections_btree_node_Handle_alloc_collections_btree_node_NodeRef_BorrowType_K_V_alloc_collections_btree_node_marker_Leaf_alloc_collections_btree_node_marker_Edge.
        Definition Self (BorrowType K V : Ty.t) : Ty.t :=
          Ty.apply
            (Ty.path "alloc::collections::btree::node::Handle")
            [
              Ty.apply
                (Ty.path "alloc::collections::btree::node::NodeRef")
                [ BorrowType; K; V; Ty.path "alloc::collections::btree::node::marker::Leaf" ];
              Ty.path "alloc::collections::btree::node::marker::Edge"
            ].
        
        (*
            pub fn forget_node_type(
                self,
            ) -> Handle<NodeRef<BorrowType, K, V, marker::LeafOrInternal>, marker::Edge> {
                unsafe { Handle::new_edge(self.node.forget_type(), self.idx) }
            }
        *)
        Definition forget_node_type
            (BorrowType K V : Ty.t)
            (τ : list Ty.t)
            (α : list Value.t)
            : M :=
          let Self : Ty.t := Self BorrowType K V in
          match τ, α with
          | [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "alloc::collections::btree::node::Handle")
                    [
                      Ty.apply
                        (Ty.path "alloc::collections::btree::node::NodeRef")
                        [
                          BorrowType;
                          K;
                          V;
                          Ty.path "alloc::collections::btree::node::marker::LeafOrInternal"
                        ];
                      Ty.path "alloc::collections::btree::node::marker::Edge"
                    ],
                  "new_edge",
                  []
                |),
                [
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "alloc::collections::btree::node::NodeRef")
                        [ BorrowType; K; V; Ty.path "alloc::collections::btree::node::marker::Leaf"
                        ],
                      "forget_type",
                      []
                    |),
                    [
                      M.read (|
                        M.SubPointer.get_struct_record_field (|
                          self,
                          "alloc::collections::btree::node::Handle",
                          "node"
                        |)
                      |)
                    ]
                  |);
                  M.read (|
                    M.SubPointer.get_struct_record_field (|
                      self,
                      "alloc::collections::btree::node::Handle",
                      "idx"
                    |)
                  |)
                ]
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom AssociatedFunction_forget_node_type :
          forall (BorrowType K V : Ty.t),
          M.IsAssociatedFunction
            (Self BorrowType K V)
            "forget_node_type"
            (forget_node_type BorrowType K V).
      End Impl_alloc_collections_btree_node_Handle_alloc_collections_btree_node_NodeRef_BorrowType_K_V_alloc_collections_btree_node_marker_Leaf_alloc_collections_btree_node_marker_Edge.
      
      
      Module Impl_alloc_collections_btree_node_Handle_alloc_collections_btree_node_NodeRef_BorrowType_K_V_alloc_collections_btree_node_marker_Leaf_alloc_collections_btree_node_marker_KV.
        Definition Self (BorrowType K V : Ty.t) : Ty.t :=
          Ty.apply
            (Ty.path "alloc::collections::btree::node::Handle")
            [
              Ty.apply
                (Ty.path "alloc::collections::btree::node::NodeRef")
                [ BorrowType; K; V; Ty.path "alloc::collections::btree::node::marker::Leaf" ];
              Ty.path "alloc::collections::btree::node::marker::KV"
            ].
        
        (*
            pub fn forget_node_type(
                self,
            ) -> Handle<NodeRef<BorrowType, K, V, marker::LeafOrInternal>, marker::KV> {
                unsafe { Handle::new_kv(self.node.forget_type(), self.idx) }
            }
        *)
        Definition forget_node_type
            (BorrowType K V : Ty.t)
            (τ : list Ty.t)
            (α : list Value.t)
            : M :=
          let Self : Ty.t := Self BorrowType K V in
          match τ, α with
          | [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "alloc::collections::btree::node::Handle")
                    [
                      Ty.apply
                        (Ty.path "alloc::collections::btree::node::NodeRef")
                        [
                          BorrowType;
                          K;
                          V;
                          Ty.path "alloc::collections::btree::node::marker::LeafOrInternal"
                        ];
                      Ty.path "alloc::collections::btree::node::marker::KV"
                    ],
                  "new_kv",
                  []
                |),
                [
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "alloc::collections::btree::node::NodeRef")
                        [ BorrowType; K; V; Ty.path "alloc::collections::btree::node::marker::Leaf"
                        ],
                      "forget_type",
                      []
                    |),
                    [
                      M.read (|
                        M.SubPointer.get_struct_record_field (|
                          self,
                          "alloc::collections::btree::node::Handle",
                          "node"
                        |)
                      |)
                    ]
                  |);
                  M.read (|
                    M.SubPointer.get_struct_record_field (|
                      self,
                      "alloc::collections::btree::node::Handle",
                      "idx"
                    |)
                  |)
                ]
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom AssociatedFunction_forget_node_type :
          forall (BorrowType K V : Ty.t),
          M.IsAssociatedFunction
            (Self BorrowType K V)
            "forget_node_type"
            (forget_node_type BorrowType K V).
      End Impl_alloc_collections_btree_node_Handle_alloc_collections_btree_node_NodeRef_BorrowType_K_V_alloc_collections_btree_node_marker_Leaf_alloc_collections_btree_node_marker_KV.
      
      Module Impl_alloc_collections_btree_node_Handle_alloc_collections_btree_node_NodeRef_BorrowType_K_V_alloc_collections_btree_node_marker_LeafOrInternal_Type_.
        Definition Self (BorrowType K V Type_ : Ty.t) : Ty.t :=
          Ty.apply
            (Ty.path "alloc::collections::btree::node::Handle")
            [
              Ty.apply
                (Ty.path "alloc::collections::btree::node::NodeRef")
                [
                  BorrowType;
                  K;
                  V;
                  Ty.path "alloc::collections::btree::node::marker::LeafOrInternal"
                ];
              Type_
            ].
        
        (*
            pub fn force(
                self,
            ) -> ForceResult<
                Handle<NodeRef<BorrowType, K, V, marker::Leaf>, Type>,
                Handle<NodeRef<BorrowType, K, V, marker::Internal>, Type>,
            > {
                match self.node.force() {
                    ForceResult::Leaf(node) => {
                        ForceResult::Leaf(Handle { node, idx: self.idx, _marker: PhantomData })
                    }
                    ForceResult::Internal(node) => {
                        ForceResult::Internal(Handle { node, idx: self.idx, _marker: PhantomData })
                    }
                }
            }
        *)
        Definition force (BorrowType K V Type_ : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self BorrowType K V Type_ in
          match τ, α with
          | [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              M.read (|
                M.match_operator (|
                  M.alloc (|
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "alloc::collections::btree::node::NodeRef")
                          [
                            BorrowType;
                            K;
                            V;
                            Ty.path "alloc::collections::btree::node::marker::LeafOrInternal"
                          ],
                        "force",
                        []
                      |),
                      [
                        M.read (|
                          M.SubPointer.get_struct_record_field (|
                            self,
                            "alloc::collections::btree::node::Handle",
                            "node"
                          |)
                        |)
                      ]
                    |)
                  |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ0_0 :=
                          M.SubPointer.get_struct_tuple_field (|
                            γ,
                            "alloc::collections::btree::node::ForceResult::Leaf",
                            0
                          |) in
                        let node := M.copy (| γ0_0 |) in
                        M.alloc (|
                          Value.StructTuple
                            "alloc::collections::btree::node::ForceResult::Leaf'1"
                            [
                              Value.StructRecord
                                "alloc::collections::btree::node::Handle"
                                [
                                  ("node", M.read (| node |));
                                  ("idx",
                                    M.read (|
                                      M.SubPointer.get_struct_record_field (|
                                        self,
                                        "alloc::collections::btree::node::Handle",
                                        "idx"
                                      |)
                                    |));
                                  ("_marker", Value.StructTuple "core::marker::PhantomData" [])
                                ]
                            ]
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ0_0 :=
                          M.SubPointer.get_struct_tuple_field (|
                            γ,
                            "alloc::collections::btree::node::ForceResult::Internal",
                            0
                          |) in
                        let node := M.copy (| γ0_0 |) in
                        M.alloc (|
                          Value.StructTuple
                            "alloc::collections::btree::node::ForceResult::Internal'1"
                            [
                              Value.StructRecord
                                "alloc::collections::btree::node::Handle"
                                [
                                  ("node", M.read (| node |));
                                  ("idx",
                                    M.read (|
                                      M.SubPointer.get_struct_record_field (|
                                        self,
                                        "alloc::collections::btree::node::Handle",
                                        "idx"
                                      |)
                                    |));
                                  ("_marker", Value.StructTuple "core::marker::PhantomData" [])
                                ]
                            ]
                        |)))
                  ]
                |)
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom AssociatedFunction_force :
          forall (BorrowType K V Type_ : Ty.t),
          M.IsAssociatedFunction (Self BorrowType K V Type_) "force" (force BorrowType K V Type_).
      End Impl_alloc_collections_btree_node_Handle_alloc_collections_btree_node_NodeRef_BorrowType_K_V_alloc_collections_btree_node_marker_LeafOrInternal_Type_.
      
      Module Impl_alloc_collections_btree_node_Handle_alloc_collections_btree_node_NodeRef_alloc_collections_btree_node_marker_Mut_K_V_alloc_collections_btree_node_marker_LeafOrInternal_Type_.
        Definition Self (K V Type_ : Ty.t) : Ty.t :=
          Ty.apply
            (Ty.path "alloc::collections::btree::node::Handle")
            [
              Ty.apply
                (Ty.path "alloc::collections::btree::node::NodeRef")
                [
                  Ty.path "alloc::collections::btree::node::marker::Mut";
                  K;
                  V;
                  Ty.path "alloc::collections::btree::node::marker::LeafOrInternal"
                ];
              Type_
            ].
        
        (*
            pub unsafe fn cast_to_leaf_unchecked(
                self,
            ) -> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, Type> {
                let node = unsafe { self.node.cast_to_leaf_unchecked() };
                Handle { node, idx: self.idx, _marker: PhantomData }
            }
        *)
        Definition cast_to_leaf_unchecked
            (K V Type_ : Ty.t)
            (τ : list Ty.t)
            (α : list Value.t)
            : M :=
          let Self : Ty.t := Self K V Type_ in
          match τ, α with
          | [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              M.read (|
                let~ node :=
                  M.alloc (|
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "alloc::collections::btree::node::NodeRef")
                          [
                            Ty.path "alloc::collections::btree::node::marker::Mut";
                            K;
                            V;
                            Ty.path "alloc::collections::btree::node::marker::LeafOrInternal"
                          ],
                        "cast_to_leaf_unchecked",
                        []
                      |),
                      [
                        M.read (|
                          M.SubPointer.get_struct_record_field (|
                            self,
                            "alloc::collections::btree::node::Handle",
                            "node"
                          |)
                        |)
                      ]
                    |)
                  |) in
                M.alloc (|
                  Value.StructRecord
                    "alloc::collections::btree::node::Handle"
                    [
                      ("node", M.read (| node |));
                      ("idx",
                        M.read (|
                          M.SubPointer.get_struct_record_field (|
                            self,
                            "alloc::collections::btree::node::Handle",
                            "idx"
                          |)
                        |));
                      ("_marker", Value.StructTuple "core::marker::PhantomData" [])
                    ]
                |)
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom AssociatedFunction_cast_to_leaf_unchecked :
          forall (K V Type_ : Ty.t),
          M.IsAssociatedFunction
            (Self K V Type_)
            "cast_to_leaf_unchecked"
            (cast_to_leaf_unchecked K V Type_).
      End Impl_alloc_collections_btree_node_Handle_alloc_collections_btree_node_NodeRef_alloc_collections_btree_node_marker_Mut_K_V_alloc_collections_btree_node_marker_LeafOrInternal_Type_.
      
      Module Impl_alloc_collections_btree_node_Handle_alloc_collections_btree_node_NodeRef_alloc_collections_btree_node_marker_Mut_K_V_alloc_collections_btree_node_marker_LeafOrInternal_alloc_collections_btree_node_marker_Edge.
        Definition Self (K V : Ty.t) : Ty.t :=
          Ty.apply
            (Ty.path "alloc::collections::btree::node::Handle")
            [
              Ty.apply
                (Ty.path "alloc::collections::btree::node::NodeRef")
                [
                  Ty.path "alloc::collections::btree::node::marker::Mut";
                  K;
                  V;
                  Ty.path "alloc::collections::btree::node::marker::LeafOrInternal"
                ];
              Ty.path "alloc::collections::btree::node::marker::Edge"
            ].
        
        (*
            pub fn move_suffix(
                &mut self,
                right: &mut NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal>,
            ) {
                unsafe {
                    let new_left_len = self.idx;
                    let mut left_node = self.reborrow_mut().into_node();
                    let old_left_len = left_node.len();
        
                    let new_right_len = old_left_len - new_left_len;
                    let mut right_node = right.reborrow_mut();
        
                    assert!(right_node.len() == 0);
                    assert!(left_node.height == right_node.height);
        
                    if new_right_len > 0 {
                        *left_node.len_mut() = new_left_len as u16;
                        *right_node.len_mut() = new_right_len as u16;
        
                        move_to_slice(
                            left_node.key_area_mut(new_left_len..old_left_len),
                            right_node.key_area_mut(..new_right_len),
                        );
                        move_to_slice(
                            left_node.val_area_mut(new_left_len..old_left_len),
                            right_node.val_area_mut(..new_right_len),
                        );
                        match (left_node.force(), right_node.force()) {
                            (ForceResult::Internal(mut left), ForceResult::Internal(mut right)) => {
                                move_to_slice(
                                    left.edge_area_mut(new_left_len + 1..old_left_len + 1),
                                    right.edge_area_mut(1..new_right_len + 1),
                                );
                                right.correct_childrens_parent_links(1..new_right_len + 1);
                            }
                            (ForceResult::Leaf(_), ForceResult::Leaf(_)) => {}
                            _ => unreachable!(),
                        }
                    }
                }
            }
        *)
        Definition move_suffix (K V : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self K V in
          match τ, α with
          | [], [ self; _ as right ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let right := M.alloc (| right |) in
              M.read (|
                let~ new_left_len :=
                  M.copy (|
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "alloc::collections::btree::node::Handle",
                      "idx"
                    |)
                  |) in
                let~ left_node :=
                  M.alloc (|
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "alloc::collections::btree::node::Handle")
                          [
                            Ty.apply
                              (Ty.path "alloc::collections::btree::node::NodeRef")
                              [
                                Ty.path "alloc::collections::btree::node::marker::Mut";
                                K;
                                V;
                                Ty.path "alloc::collections::btree::node::marker::LeafOrInternal"
                              ];
                            Ty.path "alloc::collections::btree::node::marker::Edge"
                          ],
                        "into_node",
                        []
                      |),
                      [
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.apply
                              (Ty.path "alloc::collections::btree::node::Handle")
                              [
                                Ty.apply
                                  (Ty.path "alloc::collections::btree::node::NodeRef")
                                  [
                                    Ty.path "alloc::collections::btree::node::marker::Mut";
                                    K;
                                    V;
                                    Ty.path
                                      "alloc::collections::btree::node::marker::LeafOrInternal"
                                  ];
                                Ty.path "alloc::collections::btree::node::marker::Edge"
                              ],
                            "reborrow_mut",
                            []
                          |),
                          [ M.read (| self |) ]
                        |)
                      ]
                    |)
                  |) in
                let~ old_left_len :=
                  M.alloc (|
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "alloc::collections::btree::node::NodeRef")
                          [
                            Ty.path "alloc::collections::btree::node::marker::Mut";
                            K;
                            V;
                            Ty.path "alloc::collections::btree::node::marker::LeafOrInternal"
                          ],
                        "len",
                        []
                      |),
                      [ left_node ]
                    |)
                  |) in
                let~ new_right_len :=
                  M.alloc (|
                    BinOp.Wrap.sub
                      Integer.Usize
                      (M.read (| old_left_len |))
                      (M.read (| new_left_len |))
                  |) in
                let~ right_node :=
                  M.alloc (|
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "alloc::collections::btree::node::NodeRef")
                          [
                            Ty.path "alloc::collections::btree::node::marker::Mut";
                            K;
                            V;
                            Ty.path "alloc::collections::btree::node::marker::LeafOrInternal"
                          ],
                        "reborrow_mut",
                        []
                      |),
                      [ M.read (| right |) ]
                    |)
                  |) in
                let~ _ :=
                  M.match_operator (|
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                UnOp.Pure.not
                                  (BinOp.Pure.eq
                                    (M.call_closure (|
                                      M.get_associated_function (|
                                        Ty.apply
                                          (Ty.path "alloc::collections::btree::node::NodeRef")
                                          [
                                            Ty.path "alloc::collections::btree::node::marker::Mut";
                                            K;
                                            V;
                                            Ty.path
                                              "alloc::collections::btree::node::marker::LeafOrInternal"
                                          ],
                                        "len",
                                        []
                                      |),
                                      [ right_node ]
                                    |))
                                    (Value.Integer 0))
                              |)) in
                          let _ :=
                            M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (|
                            M.never_to_any (|
                              M.call_closure (|
                                M.get_function (| "core::panicking::panic", [] |),
                                [
                                  M.read (|
                                    Value.String "assertion failed: right_node.len() == 0"
                                  |)
                                ]
                              |)
                            |)
                          |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                let~ _ :=
                  M.match_operator (|
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                UnOp.Pure.not
                                  (BinOp.Pure.eq
                                    (M.read (|
                                      M.SubPointer.get_struct_record_field (|
                                        left_node,
                                        "alloc::collections::btree::node::NodeRef",
                                        "height"
                                      |)
                                    |))
                                    (M.read (|
                                      M.SubPointer.get_struct_record_field (|
                                        right_node,
                                        "alloc::collections::btree::node::NodeRef",
                                        "height"
                                      |)
                                    |)))
                              |)) in
                          let _ :=
                            M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (|
                            M.never_to_any (|
                              M.call_closure (|
                                M.get_function (| "core::panicking::panic", [] |),
                                [
                                  M.read (|
                                    Value.String
                                      "assertion failed: left_node.height == right_node.height"
                                  |)
                                ]
                              |)
                            |)
                          |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                M.match_operator (|
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ :=
                          M.use
                            (M.alloc (|
                              BinOp.Pure.gt (M.read (| new_right_len |)) (Value.Integer 0)
                            |)) in
                        let _ :=
                          M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        let~ _ :=
                          M.write (|
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "alloc::collections::btree::node::NodeRef")
                                  [
                                    Ty.path "alloc::collections::btree::node::marker::Mut";
                                    K;
                                    V;
                                    Ty.path
                                      "alloc::collections::btree::node::marker::LeafOrInternal"
                                  ],
                                "len_mut",
                                []
                              |),
                              [ left_node ]
                            |),
                            M.rust_cast (M.read (| new_left_len |))
                          |) in
                        let~ _ :=
                          M.write (|
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "alloc::collections::btree::node::NodeRef")
                                  [
                                    Ty.path "alloc::collections::btree::node::marker::Mut";
                                    K;
                                    V;
                                    Ty.path
                                      "alloc::collections::btree::node::marker::LeafOrInternal"
                                  ],
                                "len_mut",
                                []
                              |),
                              [ right_node ]
                            |),
                            M.rust_cast (M.read (| new_right_len |))
                          |) in
                        let~ _ :=
                          M.alloc (|
                            M.call_closure (|
                              M.get_function (|
                                "alloc::collections::btree::node::move_to_slice",
                                [ K ]
                              |),
                              [
                                M.call_closure (|
                                  M.get_associated_function (|
                                    Ty.apply
                                      (Ty.path "alloc::collections::btree::node::NodeRef")
                                      [
                                        Ty.path "alloc::collections::btree::node::marker::Mut";
                                        K;
                                        V;
                                        Ty.path
                                          "alloc::collections::btree::node::marker::LeafOrInternal"
                                      ],
                                    "key_area_mut",
                                    [
                                      Ty.apply
                                        (Ty.path "core::ops::range::Range")
                                        [ Ty.path "usize" ];
                                      Ty.apply
                                        (Ty.path "slice")
                                        [
                                          Ty.apply
                                            (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                            [ K ]
                                        ]
                                    ]
                                  |),
                                  [
                                    left_node;
                                    Value.StructRecord
                                      "core::ops::range::Range"
                                      [
                                        ("start", M.read (| new_left_len |));
                                        ("end_", M.read (| old_left_len |))
                                      ]
                                  ]
                                |);
                                M.call_closure (|
                                  M.get_associated_function (|
                                    Ty.apply
                                      (Ty.path "alloc::collections::btree::node::NodeRef")
                                      [
                                        Ty.path "alloc::collections::btree::node::marker::Mut";
                                        K;
                                        V;
                                        Ty.path
                                          "alloc::collections::btree::node::marker::LeafOrInternal"
                                      ],
                                    "key_area_mut",
                                    [
                                      Ty.apply
                                        (Ty.path "core::ops::range::RangeTo")
                                        [ Ty.path "usize" ];
                                      Ty.apply
                                        (Ty.path "slice")
                                        [
                                          Ty.apply
                                            (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                            [ K ]
                                        ]
                                    ]
                                  |),
                                  [
                                    right_node;
                                    Value.StructRecord
                                      "core::ops::range::RangeTo"
                                      [ ("end_", M.read (| new_right_len |)) ]
                                  ]
                                |)
                              ]
                            |)
                          |) in
                        let~ _ :=
                          M.alloc (|
                            M.call_closure (|
                              M.get_function (|
                                "alloc::collections::btree::node::move_to_slice",
                                [ V ]
                              |),
                              [
                                M.call_closure (|
                                  M.get_associated_function (|
                                    Ty.apply
                                      (Ty.path "alloc::collections::btree::node::NodeRef")
                                      [
                                        Ty.path "alloc::collections::btree::node::marker::Mut";
                                        K;
                                        V;
                                        Ty.path
                                          "alloc::collections::btree::node::marker::LeafOrInternal"
                                      ],
                                    "val_area_mut",
                                    [
                                      Ty.apply
                                        (Ty.path "core::ops::range::Range")
                                        [ Ty.path "usize" ];
                                      Ty.apply
                                        (Ty.path "slice")
                                        [
                                          Ty.apply
                                            (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                            [ V ]
                                        ]
                                    ]
                                  |),
                                  [
                                    left_node;
                                    Value.StructRecord
                                      "core::ops::range::Range"
                                      [
                                        ("start", M.read (| new_left_len |));
                                        ("end_", M.read (| old_left_len |))
                                      ]
                                  ]
                                |);
                                M.call_closure (|
                                  M.get_associated_function (|
                                    Ty.apply
                                      (Ty.path "alloc::collections::btree::node::NodeRef")
                                      [
                                        Ty.path "alloc::collections::btree::node::marker::Mut";
                                        K;
                                        V;
                                        Ty.path
                                          "alloc::collections::btree::node::marker::LeafOrInternal"
                                      ],
                                    "val_area_mut",
                                    [
                                      Ty.apply
                                        (Ty.path "core::ops::range::RangeTo")
                                        [ Ty.path "usize" ];
                                      Ty.apply
                                        (Ty.path "slice")
                                        [
                                          Ty.apply
                                            (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                            [ V ]
                                        ]
                                    ]
                                  |),
                                  [
                                    right_node;
                                    Value.StructRecord
                                      "core::ops::range::RangeTo"
                                      [ ("end_", M.read (| new_right_len |)) ]
                                  ]
                                |)
                              ]
                            |)
                          |) in
                        M.match_operator (|
                          M.alloc (|
                            Value.Tuple
                              [
                                M.call_closure (|
                                  M.get_associated_function (|
                                    Ty.apply
                                      (Ty.path "alloc::collections::btree::node::NodeRef")
                                      [
                                        Ty.path "alloc::collections::btree::node::marker::Mut";
                                        K;
                                        V;
                                        Ty.path
                                          "alloc::collections::btree::node::marker::LeafOrInternal"
                                      ],
                                    "force",
                                    []
                                  |),
                                  [ M.read (| left_node |) ]
                                |);
                                M.call_closure (|
                                  M.get_associated_function (|
                                    Ty.apply
                                      (Ty.path "alloc::collections::btree::node::NodeRef")
                                      [
                                        Ty.path "alloc::collections::btree::node::marker::Mut";
                                        K;
                                        V;
                                        Ty.path
                                          "alloc::collections::btree::node::marker::LeafOrInternal"
                                      ],
                                    "force",
                                    []
                                  |),
                                  [ M.read (| right_node |) ]
                                |)
                              ]
                          |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                                let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                let γ1_0 :=
                                  M.SubPointer.get_struct_tuple_field (|
                                    γ0_0,
                                    "alloc::collections::btree::node::ForceResult::Internal",
                                    0
                                  |) in
                                let left := M.copy (| γ1_0 |) in
                                let γ1_0 :=
                                  M.SubPointer.get_struct_tuple_field (|
                                    γ0_1,
                                    "alloc::collections::btree::node::ForceResult::Internal",
                                    0
                                  |) in
                                let right := M.copy (| γ1_0 |) in
                                let~ _ :=
                                  M.alloc (|
                                    M.call_closure (|
                                      M.get_function (|
                                        "alloc::collections::btree::node::move_to_slice",
                                        [
                                          Ty.apply
                                            (Ty.path "core::ptr::non_null::NonNull")
                                            [
                                              Ty.apply
                                                (Ty.path
                                                  "alloc::collections::btree::node::LeafNode")
                                                [ K; V ]
                                            ]
                                        ]
                                      |),
                                      [
                                        M.call_closure (|
                                          M.get_associated_function (|
                                            Ty.apply
                                              (Ty.path "alloc::collections::btree::node::NodeRef")
                                              [
                                                Ty.path
                                                  "alloc::collections::btree::node::marker::Mut";
                                                K;
                                                V;
                                                Ty.path
                                                  "alloc::collections::btree::node::marker::Internal"
                                              ],
                                            "edge_area_mut",
                                            [
                                              Ty.apply
                                                (Ty.path "core::ops::range::Range")
                                                [ Ty.path "usize" ];
                                              Ty.apply
                                                (Ty.path "slice")
                                                [
                                                  Ty.apply
                                                    (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                                    [
                                                      Ty.apply
                                                        (Ty.path "core::ptr::non_null::NonNull")
                                                        [
                                                          Ty.apply
                                                            (Ty.path
                                                              "alloc::collections::btree::node::LeafNode")
                                                            [ K; V ]
                                                        ]
                                                    ]
                                                ]
                                            ]
                                          |),
                                          [
                                            left;
                                            Value.StructRecord
                                              "core::ops::range::Range"
                                              [
                                                ("start",
                                                  BinOp.Wrap.add
                                                    Integer.Usize
                                                    (M.read (| new_left_len |))
                                                    (Value.Integer 1));
                                                ("end_",
                                                  BinOp.Wrap.add
                                                    Integer.Usize
                                                    (M.read (| old_left_len |))
                                                    (Value.Integer 1))
                                              ]
                                          ]
                                        |);
                                        M.call_closure (|
                                          M.get_associated_function (|
                                            Ty.apply
                                              (Ty.path "alloc::collections::btree::node::NodeRef")
                                              [
                                                Ty.path
                                                  "alloc::collections::btree::node::marker::Mut";
                                                K;
                                                V;
                                                Ty.path
                                                  "alloc::collections::btree::node::marker::Internal"
                                              ],
                                            "edge_area_mut",
                                            [
                                              Ty.apply
                                                (Ty.path "core::ops::range::Range")
                                                [ Ty.path "usize" ];
                                              Ty.apply
                                                (Ty.path "slice")
                                                [
                                                  Ty.apply
                                                    (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                                    [
                                                      Ty.apply
                                                        (Ty.path "core::ptr::non_null::NonNull")
                                                        [
                                                          Ty.apply
                                                            (Ty.path
                                                              "alloc::collections::btree::node::LeafNode")
                                                            [ K; V ]
                                                        ]
                                                    ]
                                                ]
                                            ]
                                          |),
                                          [
                                            right;
                                            Value.StructRecord
                                              "core::ops::range::Range"
                                              [
                                                ("start", Value.Integer 1);
                                                ("end_",
                                                  BinOp.Wrap.add
                                                    Integer.Usize
                                                    (M.read (| new_right_len |))
                                                    (Value.Integer 1))
                                              ]
                                          ]
                                        |)
                                      ]
                                    |)
                                  |) in
                                let~ _ :=
                                  M.alloc (|
                                    M.call_closure (|
                                      M.get_associated_function (|
                                        Ty.apply
                                          (Ty.path "alloc::collections::btree::node::NodeRef")
                                          [
                                            Ty.path "alloc::collections::btree::node::marker::Mut";
                                            K;
                                            V;
                                            Ty.path
                                              "alloc::collections::btree::node::marker::Internal"
                                          ],
                                        "correct_childrens_parent_links",
                                        [
                                          Ty.apply
                                            (Ty.path "core::ops::range::Range")
                                            [ Ty.path "usize" ]
                                        ]
                                      |),
                                      [
                                        right;
                                        Value.StructRecord
                                          "core::ops::range::Range"
                                          [
                                            ("start", Value.Integer 1);
                                            ("end_",
                                              BinOp.Wrap.add
                                                Integer.Usize
                                                (M.read (| new_right_len |))
                                                (Value.Integer 1))
                                          ]
                                      ]
                                    |)
                                  |) in
                                M.alloc (| Value.Tuple [] |)));
                            fun γ =>
                              ltac:(M.monadic
                                (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                                let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                let γ1_0 :=
                                  M.SubPointer.get_struct_tuple_field (|
                                    γ0_0,
                                    "alloc::collections::btree::node::ForceResult::Leaf",
                                    0
                                  |) in
                                let γ1_0 :=
                                  M.SubPointer.get_struct_tuple_field (|
                                    γ0_1,
                                    "alloc::collections::btree::node::ForceResult::Leaf",
                                    0
                                  |) in
                                M.alloc (| Value.Tuple [] |)));
                            fun γ =>
                              ltac:(M.monadic
                                (M.alloc (|
                                  M.never_to_any (|
                                    M.call_closure (|
                                      M.get_function (| "core::panicking::panic", [] |),
                                      [
                                        M.read (|
                                          Value.String "internal error: entered unreachable code"
                                        |)
                                      ]
                                    |)
                                  |)
                                |)))
                          ]
                        |)));
                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                  ]
                |)
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom AssociatedFunction_move_suffix :
          forall (K V : Ty.t),
          M.IsAssociatedFunction (Self K V) "move_suffix" (move_suffix K V).
      End Impl_alloc_collections_btree_node_Handle_alloc_collections_btree_node_NodeRef_alloc_collections_btree_node_marker_Mut_K_V_alloc_collections_btree_node_marker_LeafOrInternal_alloc_collections_btree_node_marker_Edge.
      
      (*
      Enum ForceResult
      {
        ty_params := [ "Leaf"; "Internal" ];
        variants :=
          [
            {
              name := "Leaf";
              item := StructTuple [ Leaf ];
              discriminant := None;
            };
            {
              name := "Internal";
              item := StructTuple [ Internal ];
              discriminant := None;
            }
          ];
      }
      *)
      
      (* StructRecord
        {
          name := "SplitResult";
          ty_params := [ "K"; "V"; "NodeType" ];
          fields :=
            [
              ("left",
                Ty.apply
                  (Ty.path "alloc::collections::btree::node::NodeRef")
                  [ Ty.path "alloc::collections::btree::node::marker::Mut"; K; V; NodeType ]);
              ("kv", Ty.tuple [ K; V ]);
              ("right",
                Ty.apply
                  (Ty.path "alloc::collections::btree::node::NodeRef")
                  [ Ty.path "alloc::collections::btree::node::marker::Owned"; K; V; NodeType ])
            ];
        } *)
      
      Module Impl_alloc_collections_btree_node_SplitResult_K_V_alloc_collections_btree_node_marker_Leaf.
        Definition Self (K V : Ty.t) : Ty.t :=
          Ty.apply
            (Ty.path "alloc::collections::btree::node::SplitResult")
            [ K; V; Ty.path "alloc::collections::btree::node::marker::Leaf" ].
        
        (*
            pub fn forget_node_type(self) -> SplitResult<'a, K, V, marker::LeafOrInternal> {
                SplitResult { left: self.left.forget_type(), kv: self.kv, right: self.right.forget_type() }
            }
        *)
        Definition forget_node_type (K V : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self K V in
          match τ, α with
          | [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              Value.StructRecord
                "alloc::collections::btree::node::SplitResult"
                [
                  ("left",
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "alloc::collections::btree::node::NodeRef")
                          [
                            Ty.path "alloc::collections::btree::node::marker::Mut";
                            K;
                            V;
                            Ty.path "alloc::collections::btree::node::marker::Leaf"
                          ],
                        "forget_type",
                        []
                      |),
                      [
                        M.read (|
                          M.SubPointer.get_struct_record_field (|
                            self,
                            "alloc::collections::btree::node::SplitResult",
                            "left"
                          |)
                        |)
                      ]
                    |));
                  ("kv",
                    M.read (|
                      M.SubPointer.get_struct_record_field (|
                        self,
                        "alloc::collections::btree::node::SplitResult",
                        "kv"
                      |)
                    |));
                  ("right",
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "alloc::collections::btree::node::NodeRef")
                          [
                            Ty.path "alloc::collections::btree::node::marker::Owned";
                            K;
                            V;
                            Ty.path "alloc::collections::btree::node::marker::Leaf"
                          ],
                        "forget_type",
                        []
                      |),
                      [
                        M.read (|
                          M.SubPointer.get_struct_record_field (|
                            self,
                            "alloc::collections::btree::node::SplitResult",
                            "right"
                          |)
                        |)
                      ]
                    |))
                ]))
          | _, _ => M.impossible
          end.
        
        Axiom AssociatedFunction_forget_node_type :
          forall (K V : Ty.t),
          M.IsAssociatedFunction (Self K V) "forget_node_type" (forget_node_type K V).
      End Impl_alloc_collections_btree_node_SplitResult_K_V_alloc_collections_btree_node_marker_Leaf.
      
      Module Impl_alloc_collections_btree_node_SplitResult_K_V_alloc_collections_btree_node_marker_Internal.
        Definition Self (K V : Ty.t) : Ty.t :=
          Ty.apply
            (Ty.path "alloc::collections::btree::node::SplitResult")
            [ K; V; Ty.path "alloc::collections::btree::node::marker::Internal" ].
        
        (*
            pub fn forget_node_type(self) -> SplitResult<'a, K, V, marker::LeafOrInternal> {
                SplitResult { left: self.left.forget_type(), kv: self.kv, right: self.right.forget_type() }
            }
        *)
        Definition forget_node_type (K V : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self K V in
          match τ, α with
          | [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              Value.StructRecord
                "alloc::collections::btree::node::SplitResult"
                [
                  ("left",
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "alloc::collections::btree::node::NodeRef")
                          [
                            Ty.path "alloc::collections::btree::node::marker::Mut";
                            K;
                            V;
                            Ty.path "alloc::collections::btree::node::marker::Internal"
                          ],
                        "forget_type",
                        []
                      |),
                      [
                        M.read (|
                          M.SubPointer.get_struct_record_field (|
                            self,
                            "alloc::collections::btree::node::SplitResult",
                            "left"
                          |)
                        |)
                      ]
                    |));
                  ("kv",
                    M.read (|
                      M.SubPointer.get_struct_record_field (|
                        self,
                        "alloc::collections::btree::node::SplitResult",
                        "kv"
                      |)
                    |));
                  ("right",
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "alloc::collections::btree::node::NodeRef")
                          [
                            Ty.path "alloc::collections::btree::node::marker::Owned";
                            K;
                            V;
                            Ty.path "alloc::collections::btree::node::marker::Internal"
                          ],
                        "forget_type",
                        []
                      |),
                      [
                        M.read (|
                          M.SubPointer.get_struct_record_field (|
                            self,
                            "alloc::collections::btree::node::SplitResult",
                            "right"
                          |)
                        |)
                      ]
                    |))
                ]))
          | _, _ => M.impossible
          end.
        
        Axiom AssociatedFunction_forget_node_type :
          forall (K V : Ty.t),
          M.IsAssociatedFunction (Self K V) "forget_node_type" (forget_node_type K V).
      End Impl_alloc_collections_btree_node_SplitResult_K_V_alloc_collections_btree_node_marker_Internal.
      
      Module marker.
        (*
        Enum Leaf
        {
          ty_params := [];
          variants := [];
        }
        *)
        
        (*
        Enum Internal
        {
          ty_params := [];
          variants := [];
        }
        *)
        
        (*
        Enum LeafOrInternal
        {
          ty_params := [];
          variants := [];
        }
        *)
        
        (*
        Enum Owned
        {
          ty_params := [];
          variants := [];
        }
        *)
        
        (*
        Enum Dying
        {
          ty_params := [];
          variants := [];
        }
        *)
        
        (*
        Enum DormantMut
        {
          ty_params := [];
          variants := [];
        }
        *)
        
        (* StructTuple
          {
            name := "Immut";
            ty_params := [];
            fields :=
              [
                Ty.apply
                  (Ty.path "core::marker::PhantomData")
                  [ Ty.apply (Ty.path "&") [ Ty.tuple [] ] ]
              ];
          } *)
        
        (* StructTuple
          {
            name := "Mut";
            ty_params := [];
            fields :=
              [
                Ty.apply
                  (Ty.path "core::marker::PhantomData")
                  [ Ty.apply (Ty.path "&mut") [ Ty.tuple [] ] ]
              ];
          } *)
        
        (* StructTuple
          {
            name := "ValMut";
            ty_params := [];
            fields :=
              [
                Ty.apply
                  (Ty.path "core::marker::PhantomData")
                  [ Ty.apply (Ty.path "&mut") [ Ty.tuple [] ] ]
              ];
          } *)
        
        (* Trait *)
        (* Empty module 'BorrowType' *)
        
        Module Impl_alloc_collections_btree_node_marker_BorrowType_for_alloc_collections_btree_node_marker_Owned.
          Definition Self : Ty.t := Ty.path "alloc::collections::btree::node::marker::Owned".
          
          (*         const TRAVERSAL_PERMIT: bool = false; *)
          (* Ty.path "bool" *)
          Definition value_TRAVERSAL_PERMIT : Value.t :=
            M.run ltac:(M.monadic (M.alloc (| Value.Bool false |))).
          
          Axiom Implements :
            M.IsTraitInstance
              "alloc::collections::btree::node::marker::BorrowType"
              Self
              (* Trait polymorphic types *) []
              (* Instance *)
              [ ("value_TRAVERSAL_PERMIT", InstanceField.Constant value_TRAVERSAL_PERMIT) ].
        End Impl_alloc_collections_btree_node_marker_BorrowType_for_alloc_collections_btree_node_marker_Owned.
        
        Module Impl_alloc_collections_btree_node_marker_BorrowType_for_alloc_collections_btree_node_marker_Dying.
          Definition Self : Ty.t := Ty.path "alloc::collections::btree::node::marker::Dying".
          
          Axiom Implements :
            M.IsTraitInstance
              "alloc::collections::btree::node::marker::BorrowType"
              Self
              (* Trait polymorphic types *) []
              (* Instance *) [].
        End Impl_alloc_collections_btree_node_marker_BorrowType_for_alloc_collections_btree_node_marker_Dying.
        
        Module Impl_alloc_collections_btree_node_marker_BorrowType_for_alloc_collections_btree_node_marker_Immut.
          Definition Self : Ty.t := Ty.path "alloc::collections::btree::node::marker::Immut".
          
          Axiom Implements :
            M.IsTraitInstance
              "alloc::collections::btree::node::marker::BorrowType"
              Self
              (* Trait polymorphic types *) []
              (* Instance *) [].
        End Impl_alloc_collections_btree_node_marker_BorrowType_for_alloc_collections_btree_node_marker_Immut.
        
        Module Impl_alloc_collections_btree_node_marker_BorrowType_for_alloc_collections_btree_node_marker_Mut.
          Definition Self : Ty.t := Ty.path "alloc::collections::btree::node::marker::Mut".
          
          Axiom Implements :
            M.IsTraitInstance
              "alloc::collections::btree::node::marker::BorrowType"
              Self
              (* Trait polymorphic types *) []
              (* Instance *) [].
        End Impl_alloc_collections_btree_node_marker_BorrowType_for_alloc_collections_btree_node_marker_Mut.
        
        Module Impl_alloc_collections_btree_node_marker_BorrowType_for_alloc_collections_btree_node_marker_ValMut.
          Definition Self : Ty.t := Ty.path "alloc::collections::btree::node::marker::ValMut".
          
          Axiom Implements :
            M.IsTraitInstance
              "alloc::collections::btree::node::marker::BorrowType"
              Self
              (* Trait polymorphic types *) []
              (* Instance *) [].
        End Impl_alloc_collections_btree_node_marker_BorrowType_for_alloc_collections_btree_node_marker_ValMut.
        
        Module Impl_alloc_collections_btree_node_marker_BorrowType_for_alloc_collections_btree_node_marker_DormantMut.
          Definition Self : Ty.t := Ty.path "alloc::collections::btree::node::marker::DormantMut".
          
          Axiom Implements :
            M.IsTraitInstance
              "alloc::collections::btree::node::marker::BorrowType"
              Self
              (* Trait polymorphic types *) []
              (* Instance *) [].
        End Impl_alloc_collections_btree_node_marker_BorrowType_for_alloc_collections_btree_node_marker_DormantMut.
        
        (*
        Enum KV
        {
          ty_params := [];
          variants := [];
        }
        *)
        
        (*
        Enum Edge
        {
          ty_params := [];
          variants := [];
        }
        *)
      End marker.
      
      (*
      unsafe fn slice_insert<T>(slice: &mut [MaybeUninit<T>], idx: usize, val: T) {
          unsafe {
              let len = slice.len();
              debug_assert!(len > idx);
              let slice_ptr = slice.as_mut_ptr();
              if len > idx + 1 {
                  ptr::copy(slice_ptr.add(idx), slice_ptr.add(idx + 1), len - idx - 1);
              }
              ( *slice_ptr.add(idx)).write(val);
          }
      }
      *)
      Definition slice_insert (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [ T ], [ slice; idx; val ] =>
          ltac:(M.monadic
            (let slice := M.alloc (| slice |) in
            let idx := M.alloc (| idx |) in
            let val := M.alloc (| val |) in
            M.read (|
              let~ len :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "slice")
                        [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ T ] ],
                      "len",
                      []
                    |),
                    [ M.read (| slice |) ]
                  |)
                |) in
              let~ _ :=
                M.match_operator (|
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.use (M.alloc (| Value.Bool true |)) in
                        let _ :=
                          M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        let~ _ :=
                          M.match_operator (|
                            M.alloc (| Value.Tuple [] |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ :=
                                    M.use
                                      (M.alloc (|
                                        UnOp.Pure.not
                                          (BinOp.Pure.gt (M.read (| len |)) (M.read (| idx |)))
                                      |)) in
                                  let _ :=
                                    M.is_constant_or_break_match (|
                                      M.read (| γ |),
                                      Value.Bool true
                                    |) in
                                  M.alloc (|
                                    M.never_to_any (|
                                      M.call_closure (|
                                        M.get_function (| "core::panicking::panic", [] |),
                                        [ M.read (| Value.String "assertion failed: len > idx" |) ]
                                      |)
                                    |)
                                  |)));
                              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                            ]
                          |) in
                        M.alloc (| Value.Tuple [] |)));
                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                  ]
                |) in
              let~ slice_ptr :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "slice")
                        [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ T ] ],
                      "as_mut_ptr",
                      []
                    |),
                    [ M.read (| slice |) ]
                  |)
                |) in
              let~ _ :=
                M.match_operator (|
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ :=
                          M.use
                            (M.alloc (|
                              BinOp.Pure.gt
                                (M.read (| len |))
                                (BinOp.Wrap.add Integer.Usize (M.read (| idx |)) (Value.Integer 1))
                            |)) in
                        let _ :=
                          M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        let~ _ :=
                          M.alloc (|
                            M.call_closure (|
                              M.get_function (|
                                "core::intrinsics::copy",
                                [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ T ] ]
                              |),
                              [
                                (* MutToConstPointer *)
                                M.pointer_coercion
                                  (M.call_closure (|
                                    M.get_associated_function (|
                                      Ty.apply
                                        (Ty.path "*mut")
                                        [
                                          Ty.apply
                                            (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                            [ T ]
                                        ],
                                      "add",
                                      []
                                    |),
                                    [ M.read (| slice_ptr |); M.read (| idx |) ]
                                  |));
                                M.call_closure (|
                                  M.get_associated_function (|
                                    Ty.apply
                                      (Ty.path "*mut")
                                      [
                                        Ty.apply
                                          (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                          [ T ]
                                      ],
                                    "add",
                                    []
                                  |),
                                  [
                                    M.read (| slice_ptr |);
                                    BinOp.Wrap.add
                                      Integer.Usize
                                      (M.read (| idx |))
                                      (Value.Integer 1)
                                  ]
                                |);
                                BinOp.Wrap.sub
                                  Integer.Usize
                                  (BinOp.Wrap.sub
                                    Integer.Usize
                                    (M.read (| len |))
                                    (M.read (| idx |)))
                                  (Value.Integer 1)
                              ]
                            |)
                          |) in
                        M.alloc (| Value.Tuple [] |)));
                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                  ]
                |) in
              let~ _ :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ T ],
                      "write",
                      []
                    |),
                    [
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply
                            (Ty.path "*mut")
                            [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ T ] ],
                          "add",
                          []
                        |),
                        [ M.read (| slice_ptr |); M.read (| idx |) ]
                      |);
                      M.read (| val |)
                    ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Function_slice_insert :
        M.IsFunction "alloc::collections::btree::node::slice_insert" slice_insert.
      
      (*
      unsafe fn slice_remove<T>(slice: &mut [MaybeUninit<T>], idx: usize) -> T {
          unsafe {
              let len = slice.len();
              debug_assert!(idx < len);
              let slice_ptr = slice.as_mut_ptr();
              let ret = ( *slice_ptr.add(idx)).assume_init_read();
              ptr::copy(slice_ptr.add(idx + 1), slice_ptr.add(idx), len - idx - 1);
              ret
          }
      }
      *)
      Definition slice_remove (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [ T ], [ slice; idx ] =>
          ltac:(M.monadic
            (let slice := M.alloc (| slice |) in
            let idx := M.alloc (| idx |) in
            M.read (|
              let~ len :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "slice")
                        [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ T ] ],
                      "len",
                      []
                    |),
                    [ M.read (| slice |) ]
                  |)
                |) in
              let~ _ :=
                M.match_operator (|
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.use (M.alloc (| Value.Bool true |)) in
                        let _ :=
                          M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        let~ _ :=
                          M.match_operator (|
                            M.alloc (| Value.Tuple [] |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ :=
                                    M.use
                                      (M.alloc (|
                                        UnOp.Pure.not
                                          (BinOp.Pure.lt (M.read (| idx |)) (M.read (| len |)))
                                      |)) in
                                  let _ :=
                                    M.is_constant_or_break_match (|
                                      M.read (| γ |),
                                      Value.Bool true
                                    |) in
                                  M.alloc (|
                                    M.never_to_any (|
                                      M.call_closure (|
                                        M.get_function (| "core::panicking::panic", [] |),
                                        [ M.read (| Value.String "assertion failed: idx < len" |) ]
                                      |)
                                    |)
                                  |)));
                              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                            ]
                          |) in
                        M.alloc (| Value.Tuple [] |)));
                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                  ]
                |) in
              let~ slice_ptr :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "slice")
                        [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ T ] ],
                      "as_mut_ptr",
                      []
                    |),
                    [ M.read (| slice |) ]
                  |)
                |) in
              let~ ret :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ T ],
                      "assume_init_read",
                      []
                    |),
                    [
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply
                            (Ty.path "*mut")
                            [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ T ] ],
                          "add",
                          []
                        |),
                        [ M.read (| slice_ptr |); M.read (| idx |) ]
                      |)
                    ]
                  |)
                |) in
              let~ _ :=
                M.alloc (|
                  M.call_closure (|
                    M.get_function (|
                      "core::intrinsics::copy",
                      [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ T ] ]
                    |),
                    [
                      (* MutToConstPointer *)
                      M.pointer_coercion
                        (M.call_closure (|
                          M.get_associated_function (|
                            Ty.apply
                              (Ty.path "*mut")
                              [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ T ] ],
                            "add",
                            []
                          |),
                          [
                            M.read (| slice_ptr |);
                            BinOp.Wrap.add Integer.Usize (M.read (| idx |)) (Value.Integer 1)
                          ]
                        |));
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply
                            (Ty.path "*mut")
                            [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ T ] ],
                          "add",
                          []
                        |),
                        [ M.read (| slice_ptr |); M.read (| idx |) ]
                      |);
                      BinOp.Wrap.sub
                        Integer.Usize
                        (BinOp.Wrap.sub Integer.Usize (M.read (| len |)) (M.read (| idx |)))
                        (Value.Integer 1)
                    ]
                  |)
                |) in
              ret
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Function_slice_remove :
        M.IsFunction "alloc::collections::btree::node::slice_remove" slice_remove.
      
      (*
      unsafe fn slice_shl<T>(slice: &mut [MaybeUninit<T>], distance: usize) {
          unsafe {
              let slice_ptr = slice.as_mut_ptr();
              ptr::copy(slice_ptr.add(distance), slice_ptr, slice.len() - distance);
          }
      }
      *)
      Definition slice_shl (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [ T ], [ slice; distance ] =>
          ltac:(M.monadic
            (let slice := M.alloc (| slice |) in
            let distance := M.alloc (| distance |) in
            M.read (|
              let~ slice_ptr :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "slice")
                        [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ T ] ],
                      "as_mut_ptr",
                      []
                    |),
                    [ M.read (| slice |) ]
                  |)
                |) in
              let~ _ :=
                M.alloc (|
                  M.call_closure (|
                    M.get_function (|
                      "core::intrinsics::copy",
                      [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ T ] ]
                    |),
                    [
                      (* MutToConstPointer *)
                      M.pointer_coercion
                        (M.call_closure (|
                          M.get_associated_function (|
                            Ty.apply
                              (Ty.path "*mut")
                              [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ T ] ],
                            "add",
                            []
                          |),
                          [ M.read (| slice_ptr |); M.read (| distance |) ]
                        |));
                      M.read (| slice_ptr |);
                      BinOp.Wrap.sub
                        Integer.Usize
                        (M.call_closure (|
                          M.get_associated_function (|
                            Ty.apply
                              (Ty.path "slice")
                              [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ T ] ],
                            "len",
                            []
                          |),
                          [ M.read (| slice |) ]
                        |))
                        (M.read (| distance |))
                    ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Function_slice_shl :
        M.IsFunction "alloc::collections::btree::node::slice_shl" slice_shl.
      
      (*
      unsafe fn slice_shr<T>(slice: &mut [MaybeUninit<T>], distance: usize) {
          unsafe {
              let slice_ptr = slice.as_mut_ptr();
              ptr::copy(slice_ptr, slice_ptr.add(distance), slice.len() - distance);
          }
      }
      *)
      Definition slice_shr (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [ T ], [ slice; distance ] =>
          ltac:(M.monadic
            (let slice := M.alloc (| slice |) in
            let distance := M.alloc (| distance |) in
            M.read (|
              let~ slice_ptr :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "slice")
                        [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ T ] ],
                      "as_mut_ptr",
                      []
                    |),
                    [ M.read (| slice |) ]
                  |)
                |) in
              let~ _ :=
                M.alloc (|
                  M.call_closure (|
                    M.get_function (|
                      "core::intrinsics::copy",
                      [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ T ] ]
                    |),
                    [
                      (* MutToConstPointer *) M.pointer_coercion (M.read (| slice_ptr |));
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply
                            (Ty.path "*mut")
                            [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ T ] ],
                          "add",
                          []
                        |),
                        [ M.read (| slice_ptr |); M.read (| distance |) ]
                      |);
                      BinOp.Wrap.sub
                        Integer.Usize
                        (M.call_closure (|
                          M.get_associated_function (|
                            Ty.apply
                              (Ty.path "slice")
                              [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ T ] ],
                            "len",
                            []
                          |),
                          [ M.read (| slice |) ]
                        |))
                        (M.read (| distance |))
                    ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Function_slice_shr :
        M.IsFunction "alloc::collections::btree::node::slice_shr" slice_shr.
      
      (*
      fn move_to_slice<T>(src: &mut [MaybeUninit<T>], dst: &mut [MaybeUninit<T>]) {
          assert!(src.len() == dst.len());
          unsafe {
              ptr::copy_nonoverlapping(src.as_ptr(), dst.as_mut_ptr(), src.len());
          }
      }
      *)
      Definition move_to_slice (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [ T ], [ src; dst ] =>
          ltac:(M.monadic
            (let src := M.alloc (| src |) in
            let dst := M.alloc (| dst |) in
            M.read (|
              let~ _ :=
                M.match_operator (|
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ :=
                          M.use
                            (M.alloc (|
                              UnOp.Pure.not
                                (BinOp.Pure.eq
                                  (M.call_closure (|
                                    M.get_associated_function (|
                                      Ty.apply
                                        (Ty.path "slice")
                                        [
                                          Ty.apply
                                            (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                            [ T ]
                                        ],
                                      "len",
                                      []
                                    |),
                                    [ M.read (| src |) ]
                                  |))
                                  (M.call_closure (|
                                    M.get_associated_function (|
                                      Ty.apply
                                        (Ty.path "slice")
                                        [
                                          Ty.apply
                                            (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                            [ T ]
                                        ],
                                      "len",
                                      []
                                    |),
                                    [ M.read (| dst |) ]
                                  |)))
                            |)) in
                        let _ :=
                          M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        M.alloc (|
                          M.never_to_any (|
                            M.call_closure (|
                              M.get_function (| "core::panicking::panic", [] |),
                              [ M.read (| Value.String "assertion failed: src.len() == dst.len()" |)
                              ]
                            |)
                          |)
                        |)));
                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                  ]
                |) in
              let~ _ :=
                M.alloc (|
                  M.call_closure (|
                    M.get_function (|
                      "core::intrinsics::copy_nonoverlapping",
                      [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ T ] ]
                    |),
                    [
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply
                            (Ty.path "slice")
                            [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ T ] ],
                          "as_ptr",
                          []
                        |),
                        [ M.read (| src |) ]
                      |);
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply
                            (Ty.path "slice")
                            [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ T ] ],
                          "as_mut_ptr",
                          []
                        |),
                        [ M.read (| dst |) ]
                      |);
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply
                            (Ty.path "slice")
                            [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ T ] ],
                          "len",
                          []
                        |),
                        [ M.read (| src |) ]
                      |)
                    ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Function_move_to_slice :
        M.IsFunction "alloc::collections::btree::node::move_to_slice" move_to_slice.
    End node.
  End btree.
End collections.
