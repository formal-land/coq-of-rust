(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module collections.
  Module btree.
    Module set.
      (* StructRecord
        {
          name := "BTreeSet";
          const_params := [];
          ty_params := [ "T"; "A" ];
          fields :=
            [
              ("map",
                Ty.apply
                  (Ty.path "alloc::collections::btree::map::BTreeMap")
                  []
                  [ T; Ty.path "alloc::collections::btree::set_val::SetValZST"; A ])
            ];
        } *)
      
      Module Impl_core_hash_Hash_where_core_hash_Hash_T_where_core_alloc_Allocator_A_where_core_clone_Clone_A_for_alloc_collections_btree_set_BTreeSet_T_A.
        Definition Self (T A : Ty.t) : Ty.t :=
          Ty.apply (Ty.path "alloc::collections::btree::set::BTreeSet") [] [ T; A ].
        
        (*
            fn hash<H: Hasher>(&self, state: &mut H) {
                self.map.hash(state)
            }
        *)
        Definition hash (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self T A in
          match ε, τ, α with
          | [], [ H ], [ self; state ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let state := M.alloc (| state |) in
              M.call_closure (|
                M.get_trait_method (|
                  "core::hash::Hash",
                  Ty.apply
                    (Ty.path "alloc::collections::btree::map::BTreeMap")
                    []
                    [ T; Ty.path "alloc::collections::btree::set_val::SetValZST"; A ],
                  [],
                  "hash",
                  [ H ]
                |),
                [
                  M.SubPointer.get_struct_record_field (|
                    M.read (| self |),
                    "alloc::collections::btree::set::BTreeSet",
                    "map"
                  |);
                  M.read (| state |)
                ]
              |)))
          | _, _, _ => M.impossible
          end.
        
        Axiom Implements :
          forall (T A : Ty.t),
          M.IsTraitInstance
            "core::hash::Hash"
            (Self T A)
            (* Trait polymorphic types *) []
            (* Instance *) [ ("hash", InstanceField.Method (hash T A)) ].
      End Impl_core_hash_Hash_where_core_hash_Hash_T_where_core_alloc_Allocator_A_where_core_clone_Clone_A_for_alloc_collections_btree_set_BTreeSet_T_A.
      
      Module Impl_core_cmp_PartialEq_where_core_cmp_PartialEq_T_where_core_alloc_Allocator_A_where_core_clone_Clone_A_for_alloc_collections_btree_set_BTreeSet_T_A.
        Definition Self (T A : Ty.t) : Ty.t :=
          Ty.apply (Ty.path "alloc::collections::btree::set::BTreeSet") [] [ T; A ].
        
        (*
            fn eq(&self, other: &BTreeSet<T, A>) -> bool {
                self.map.eq(&other.map)
            }
        *)
        Definition eq (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self T A in
          match ε, τ, α with
          | [], [], [ self; other ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let other := M.alloc (| other |) in
              M.call_closure (|
                M.get_trait_method (|
                  "core::cmp::PartialEq",
                  Ty.apply
                    (Ty.path "alloc::collections::btree::map::BTreeMap")
                    []
                    [ T; Ty.path "alloc::collections::btree::set_val::SetValZST"; A ],
                  [
                    Ty.apply
                      (Ty.path "alloc::collections::btree::map::BTreeMap")
                      []
                      [ T; Ty.path "alloc::collections::btree::set_val::SetValZST"; A ]
                  ],
                  "eq",
                  []
                |),
                [
                  M.SubPointer.get_struct_record_field (|
                    M.read (| self |),
                    "alloc::collections::btree::set::BTreeSet",
                    "map"
                  |);
                  M.SubPointer.get_struct_record_field (|
                    M.read (| other |),
                    "alloc::collections::btree::set::BTreeSet",
                    "map"
                  |)
                ]
              |)))
          | _, _, _ => M.impossible
          end.
        
        Axiom Implements :
          forall (T A : Ty.t),
          M.IsTraitInstance
            "core::cmp::PartialEq"
            (Self T A)
            (* Trait polymorphic types *) []
            (* Instance *) [ ("eq", InstanceField.Method (eq T A)) ].
      End Impl_core_cmp_PartialEq_where_core_cmp_PartialEq_T_where_core_alloc_Allocator_A_where_core_clone_Clone_A_for_alloc_collections_btree_set_BTreeSet_T_A.
      
      Module Impl_core_cmp_Eq_where_core_cmp_Eq_T_where_core_alloc_Allocator_A_where_core_clone_Clone_A_for_alloc_collections_btree_set_BTreeSet_T_A.
        Definition Self (T A : Ty.t) : Ty.t :=
          Ty.apply (Ty.path "alloc::collections::btree::set::BTreeSet") [] [ T; A ].
        
        Axiom Implements :
          forall (T A : Ty.t),
          M.IsTraitInstance
            "core::cmp::Eq"
            (Self T A)
            (* Trait polymorphic types *) []
            (* Instance *) [].
      End Impl_core_cmp_Eq_where_core_cmp_Eq_T_where_core_alloc_Allocator_A_where_core_clone_Clone_A_for_alloc_collections_btree_set_BTreeSet_T_A.
      
      Module Impl_core_cmp_PartialOrd_where_core_cmp_PartialOrd_T_where_core_alloc_Allocator_A_where_core_clone_Clone_A_for_alloc_collections_btree_set_BTreeSet_T_A.
        Definition Self (T A : Ty.t) : Ty.t :=
          Ty.apply (Ty.path "alloc::collections::btree::set::BTreeSet") [] [ T; A ].
        
        (*
            fn partial_cmp(&self, other: &BTreeSet<T, A>) -> Option<Ordering> {
                self.map.partial_cmp(&other.map)
            }
        *)
        Definition partial_cmp
            (T A : Ty.t)
            (ε : list Value.t)
            (τ : list Ty.t)
            (α : list Value.t)
            : M :=
          let Self : Ty.t := Self T A in
          match ε, τ, α with
          | [], [], [ self; other ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let other := M.alloc (| other |) in
              M.call_closure (|
                M.get_trait_method (|
                  "core::cmp::PartialOrd",
                  Ty.apply
                    (Ty.path "alloc::collections::btree::map::BTreeMap")
                    []
                    [ T; Ty.path "alloc::collections::btree::set_val::SetValZST"; A ],
                  [
                    Ty.apply
                      (Ty.path "alloc::collections::btree::map::BTreeMap")
                      []
                      [ T; Ty.path "alloc::collections::btree::set_val::SetValZST"; A ]
                  ],
                  "partial_cmp",
                  []
                |),
                [
                  M.SubPointer.get_struct_record_field (|
                    M.read (| self |),
                    "alloc::collections::btree::set::BTreeSet",
                    "map"
                  |);
                  M.SubPointer.get_struct_record_field (|
                    M.read (| other |),
                    "alloc::collections::btree::set::BTreeSet",
                    "map"
                  |)
                ]
              |)))
          | _, _, _ => M.impossible
          end.
        
        Axiom Implements :
          forall (T A : Ty.t),
          M.IsTraitInstance
            "core::cmp::PartialOrd"
            (Self T A)
            (* Trait polymorphic types *) []
            (* Instance *) [ ("partial_cmp", InstanceField.Method (partial_cmp T A)) ].
      End Impl_core_cmp_PartialOrd_where_core_cmp_PartialOrd_T_where_core_alloc_Allocator_A_where_core_clone_Clone_A_for_alloc_collections_btree_set_BTreeSet_T_A.
      
      Module Impl_core_cmp_Ord_where_core_cmp_Ord_T_where_core_alloc_Allocator_A_where_core_clone_Clone_A_for_alloc_collections_btree_set_BTreeSet_T_A.
        Definition Self (T A : Ty.t) : Ty.t :=
          Ty.apply (Ty.path "alloc::collections::btree::set::BTreeSet") [] [ T; A ].
        
        (*
            fn cmp(&self, other: &BTreeSet<T, A>) -> Ordering {
                self.map.cmp(&other.map)
            }
        *)
        Definition cmp (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self T A in
          match ε, τ, α with
          | [], [], [ self; other ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let other := M.alloc (| other |) in
              M.call_closure (|
                M.get_trait_method (|
                  "core::cmp::Ord",
                  Ty.apply
                    (Ty.path "alloc::collections::btree::map::BTreeMap")
                    []
                    [ T; Ty.path "alloc::collections::btree::set_val::SetValZST"; A ],
                  [],
                  "cmp",
                  []
                |),
                [
                  M.SubPointer.get_struct_record_field (|
                    M.read (| self |),
                    "alloc::collections::btree::set::BTreeSet",
                    "map"
                  |);
                  M.SubPointer.get_struct_record_field (|
                    M.read (| other |),
                    "alloc::collections::btree::set::BTreeSet",
                    "map"
                  |)
                ]
              |)))
          | _, _, _ => M.impossible
          end.
        
        Axiom Implements :
          forall (T A : Ty.t),
          M.IsTraitInstance
            "core::cmp::Ord"
            (Self T A)
            (* Trait polymorphic types *) []
            (* Instance *) [ ("cmp", InstanceField.Method (cmp T A)) ].
      End Impl_core_cmp_Ord_where_core_cmp_Ord_T_where_core_alloc_Allocator_A_where_core_clone_Clone_A_for_alloc_collections_btree_set_BTreeSet_T_A.
      
      Module Impl_core_clone_Clone_where_core_clone_Clone_T_where_core_alloc_Allocator_A_where_core_clone_Clone_A_for_alloc_collections_btree_set_BTreeSet_T_A.
        Definition Self (T A : Ty.t) : Ty.t :=
          Ty.apply (Ty.path "alloc::collections::btree::set::BTreeSet") [] [ T; A ].
        
        (*
            fn clone(&self) -> Self {
                BTreeSet { map: self.map.clone() }
            }
        *)
        Definition clone (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self T A in
          match ε, τ, α with
          | [], [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              Value.StructRecord
                "alloc::collections::btree::set::BTreeSet"
                [
                  ("map",
                    M.call_closure (|
                      M.get_trait_method (|
                        "core::clone::Clone",
                        Ty.apply
                          (Ty.path "alloc::collections::btree::map::BTreeMap")
                          []
                          [ T; Ty.path "alloc::collections::btree::set_val::SetValZST"; A ],
                        [],
                        "clone",
                        []
                      |),
                      [
                        M.SubPointer.get_struct_record_field (|
                          M.read (| self |),
                          "alloc::collections::btree::set::BTreeSet",
                          "map"
                        |)
                      ]
                    |))
                ]))
          | _, _, _ => M.impossible
          end.
        
        (*
            fn clone_from(&mut self, source: &Self) {
                self.map.clone_from(&source.map);
            }
        *)
        Definition clone_from
            (T A : Ty.t)
            (ε : list Value.t)
            (τ : list Ty.t)
            (α : list Value.t)
            : M :=
          let Self : Ty.t := Self T A in
          match ε, τ, α with
          | [], [], [ self; source ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let source := M.alloc (| source |) in
              M.read (|
                let~ _ :=
                  M.alloc (|
                    M.call_closure (|
                      M.get_trait_method (|
                        "core::clone::Clone",
                        Ty.apply
                          (Ty.path "alloc::collections::btree::map::BTreeMap")
                          []
                          [ T; Ty.path "alloc::collections::btree::set_val::SetValZST"; A ],
                        [],
                        "clone_from",
                        []
                      |),
                      [
                        M.SubPointer.get_struct_record_field (|
                          M.read (| self |),
                          "alloc::collections::btree::set::BTreeSet",
                          "map"
                        |);
                        M.SubPointer.get_struct_record_field (|
                          M.read (| source |),
                          "alloc::collections::btree::set::BTreeSet",
                          "map"
                        |)
                      ]
                    |)
                  |) in
                M.alloc (| Value.Tuple [] |)
              |)))
          | _, _, _ => M.impossible
          end.
        
        Axiom Implements :
          forall (T A : Ty.t),
          M.IsTraitInstance
            "core::clone::Clone"
            (Self T A)
            (* Trait polymorphic types *) []
            (* Instance *)
            [
              ("clone", InstanceField.Method (clone T A));
              ("clone_from", InstanceField.Method (clone_from T A))
            ].
      End Impl_core_clone_Clone_where_core_clone_Clone_T_where_core_alloc_Allocator_A_where_core_clone_Clone_A_for_alloc_collections_btree_set_BTreeSet_T_A.
      
      (* StructRecord
        {
          name := "Iter";
          const_params := [];
          ty_params := [ "T" ];
          fields :=
            [
              ("iter",
                Ty.apply
                  (Ty.path "alloc::collections::btree::map::Keys")
                  []
                  [ T; Ty.path "alloc::collections::btree::set_val::SetValZST" ])
            ];
        } *)
      
      Module Impl_core_fmt_Debug_where_core_fmt_Debug_T_for_alloc_collections_btree_set_Iter_T.
        Definition Self (T : Ty.t) : Ty.t :=
          Ty.apply (Ty.path "alloc::collections::btree::set::Iter") [] [ T ].
        
        (*
            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                f.debug_tuple("Iter").field(&self.iter.clone()).finish()
            }
        *)
        Definition fmt (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self T in
          match ε, τ, α with
          | [], [], [ self; f ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let f := M.alloc (| f |) in
              M.call_closure (|
                M.get_associated_function (|
                  Ty.path "core::fmt::builders::DebugTuple",
                  "finish",
                  []
                |),
                [
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.path "core::fmt::builders::DebugTuple",
                      "field",
                      []
                    |),
                    [
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.path "core::fmt::Formatter",
                            "debug_tuple",
                            []
                          |),
                          [ M.read (| f |); M.read (| Value.String "Iter" |) ]
                        |)
                      |);
                      M.alloc (|
                        M.call_closure (|
                          M.get_trait_method (|
                            "core::clone::Clone",
                            Ty.apply
                              (Ty.path "alloc::collections::btree::map::Keys")
                              []
                              [ T; Ty.path "alloc::collections::btree::set_val::SetValZST" ],
                            [],
                            "clone",
                            []
                          |),
                          [
                            M.SubPointer.get_struct_record_field (|
                              M.read (| self |),
                              "alloc::collections::btree::set::Iter",
                              "iter"
                            |)
                          ]
                        |)
                      |)
                    ]
                  |)
                ]
              |)))
          | _, _, _ => M.impossible
          end.
        
        Axiom Implements :
          forall (T : Ty.t),
          M.IsTraitInstance
            "core::fmt::Debug"
            (Self T)
            (* Trait polymorphic types *) []
            (* Instance *) [ ("fmt", InstanceField.Method (fmt T)) ].
      End Impl_core_fmt_Debug_where_core_fmt_Debug_T_for_alloc_collections_btree_set_Iter_T.
      
      (* StructRecord
        {
          name := "IntoIter";
          const_params := [];
          ty_params := [ "T"; "A" ];
          fields :=
            [
              ("iter",
                Ty.apply
                  (Ty.path "alloc::collections::btree::map::IntoIter")
                  []
                  [ T; Ty.path "alloc::collections::btree::set_val::SetValZST"; A ])
            ];
        } *)
      
      Module Impl_core_fmt_Debug_where_core_fmt_Debug_T_where_core_fmt_Debug_A_where_core_alloc_Allocator_A_where_core_clone_Clone_A_for_alloc_collections_btree_set_IntoIter_T_A.
        Definition Self (T A : Ty.t) : Ty.t :=
          Ty.apply (Ty.path "alloc::collections::btree::set::IntoIter") [] [ T; A ].
        
        (* Debug *)
        Definition fmt (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self T A in
          match ε, τ, α with
          | [], [], [ self; f ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let f := M.alloc (| f |) in
              M.call_closure (|
                M.get_associated_function (|
                  Ty.path "core::fmt::Formatter",
                  "debug_struct_field1_finish",
                  []
                |),
                [
                  M.read (| f |);
                  M.read (| Value.String "IntoIter" |);
                  M.read (| Value.String "iter" |);
                  M.alloc (|
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "alloc::collections::btree::set::IntoIter",
                      "iter"
                    |)
                  |)
                ]
              |)))
          | _, _, _ => M.impossible
          end.
        
        Axiom Implements :
          forall (T A : Ty.t),
          M.IsTraitInstance
            "core::fmt::Debug"
            (Self T A)
            (* Trait polymorphic types *) []
            (* Instance *) [ ("fmt", InstanceField.Method (fmt T A)) ].
      End Impl_core_fmt_Debug_where_core_fmt_Debug_T_where_core_fmt_Debug_A_where_core_alloc_Allocator_A_where_core_clone_Clone_A_for_alloc_collections_btree_set_IntoIter_T_A.
      
      (* StructRecord
        {
          name := "Range";
          const_params := [];
          ty_params := [ "T" ];
          fields :=
            [
              ("iter",
                Ty.apply
                  (Ty.path "alloc::collections::btree::map::Range")
                  []
                  [ T; Ty.path "alloc::collections::btree::set_val::SetValZST" ])
            ];
        } *)
      
      Module Impl_core_fmt_Debug_where_core_fmt_Debug_T_for_alloc_collections_btree_set_Range_T.
        Definition Self (T : Ty.t) : Ty.t :=
          Ty.apply (Ty.path "alloc::collections::btree::set::Range") [] [ T ].
        
        (* Debug *)
        Definition fmt (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self T in
          match ε, τ, α with
          | [], [], [ self; f ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let f := M.alloc (| f |) in
              M.call_closure (|
                M.get_associated_function (|
                  Ty.path "core::fmt::Formatter",
                  "debug_struct_field1_finish",
                  []
                |),
                [
                  M.read (| f |);
                  M.read (| Value.String "Range" |);
                  M.read (| Value.String "iter" |);
                  M.alloc (|
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "alloc::collections::btree::set::Range",
                      "iter"
                    |)
                  |)
                ]
              |)))
          | _, _, _ => M.impossible
          end.
        
        Axiom Implements :
          forall (T : Ty.t),
          M.IsTraitInstance
            "core::fmt::Debug"
            (Self T)
            (* Trait polymorphic types *) []
            (* Instance *) [ ("fmt", InstanceField.Method (fmt T)) ].
      End Impl_core_fmt_Debug_where_core_fmt_Debug_T_for_alloc_collections_btree_set_Range_T.
      
      (* StructRecord
        {
          name := "Difference";
          const_params := [];
          ty_params := [ "T"; "A" ];
          fields :=
            [
              ("inner",
                Ty.apply (Ty.path "alloc::collections::btree::set::DifferenceInner") [] [ T; A ])
            ];
        } *)
      
      (*
      Enum DifferenceInner
      {
        const_params := [];
        ty_params := [ "T"; "A" ];
        variants :=
          [
            {
              name := "Stitch";
              item :=
                StructRecord
                  [
                    ("self_iter",
                      Ty.apply (Ty.path "alloc::collections::btree::set::Iter") [] [ T ]);
                    ("other_iter",
                      Ty.apply
                        (Ty.path "core::iter::adapters::peekable::Peekable")
                        []
                        [ Ty.apply (Ty.path "alloc::collections::btree::set::Iter") [] [ T ] ])
                  ];
              discriminant := None;
            };
            {
              name := "Search";
              item :=
                StructRecord
                  [
                    ("self_iter",
                      Ty.apply (Ty.path "alloc::collections::btree::set::Iter") [] [ T ]);
                    ("other_set",
                      Ty.apply
                        (Ty.path "&")
                        []
                        [ Ty.apply (Ty.path "alloc::collections::btree::set::BTreeSet") [] [ T; A ]
                        ])
                  ];
              discriminant := None;
            };
            {
              name := "Iterate";
              item :=
                StructTuple [ Ty.apply (Ty.path "alloc::collections::btree::set::Iter") [] [ T ] ];
              discriminant := None;
            }
          ];
      }
      *)
      
      Module Impl_core_fmt_Debug_where_core_fmt_Debug_T_where_core_alloc_Allocator_A_where_core_clone_Clone_A_for_alloc_collections_btree_set_DifferenceInner_T_A.
        Definition Self (T A : Ty.t) : Ty.t :=
          Ty.apply (Ty.path "alloc::collections::btree::set::DifferenceInner") [] [ T; A ].
        
        (*
            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                match self {
                    DifferenceInner::Stitch { self_iter, other_iter } => f
                        .debug_struct("Stitch")
                        .field("self_iter", self_iter)
                        .field("other_iter", other_iter)
                        .finish(),
                    DifferenceInner::Search { self_iter, other_set } => f
                        .debug_struct("Search")
                        .field("self_iter", self_iter)
                        .field("other_iter", other_set)
                        .finish(),
                    DifferenceInner::Iterate(x) => f.debug_tuple("Iterate").field(x).finish(),
                }
            }
        *)
        Definition fmt (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self T A in
          match ε, τ, α with
          | [], [], [ self; f ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let f := M.alloc (| f |) in
              M.read (|
                M.match_operator (|
                  self,
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        let γ1_0 :=
                          M.SubPointer.get_struct_record_field (|
                            γ,
                            "alloc::collections::btree::set::DifferenceInner::Stitch",
                            "self_iter"
                          |) in
                        let γ1_1 :=
                          M.SubPointer.get_struct_record_field (|
                            γ,
                            "alloc::collections::btree::set::DifferenceInner::Stitch",
                            "other_iter"
                          |) in
                        let self_iter := M.alloc (| γ1_0 |) in
                        let other_iter := M.alloc (| γ1_1 |) in
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::builders::DebugStruct",
                              "finish",
                              []
                            |),
                            [
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.path "core::fmt::builders::DebugStruct",
                                  "field",
                                  []
                                |),
                                [
                                  M.call_closure (|
                                    M.get_associated_function (|
                                      Ty.path "core::fmt::builders::DebugStruct",
                                      "field",
                                      []
                                    |),
                                    [
                                      M.alloc (|
                                        M.call_closure (|
                                          M.get_associated_function (|
                                            Ty.path "core::fmt::Formatter",
                                            "debug_struct",
                                            []
                                          |),
                                          [ M.read (| f |); M.read (| Value.String "Stitch" |) ]
                                        |)
                                      |);
                                      M.read (| Value.String "self_iter" |);
                                      M.read (| self_iter |)
                                    ]
                                  |);
                                  M.read (| Value.String "other_iter" |);
                                  M.read (| other_iter |)
                                ]
                              |)
                            ]
                          |)
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        let γ1_0 :=
                          M.SubPointer.get_struct_record_field (|
                            γ,
                            "alloc::collections::btree::set::DifferenceInner::Search",
                            "self_iter"
                          |) in
                        let γ1_1 :=
                          M.SubPointer.get_struct_record_field (|
                            γ,
                            "alloc::collections::btree::set::DifferenceInner::Search",
                            "other_set"
                          |) in
                        let self_iter := M.alloc (| γ1_0 |) in
                        let other_set := M.alloc (| γ1_1 |) in
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::builders::DebugStruct",
                              "finish",
                              []
                            |),
                            [
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.path "core::fmt::builders::DebugStruct",
                                  "field",
                                  []
                                |),
                                [
                                  M.call_closure (|
                                    M.get_associated_function (|
                                      Ty.path "core::fmt::builders::DebugStruct",
                                      "field",
                                      []
                                    |),
                                    [
                                      M.alloc (|
                                        M.call_closure (|
                                          M.get_associated_function (|
                                            Ty.path "core::fmt::Formatter",
                                            "debug_struct",
                                            []
                                          |),
                                          [ M.read (| f |); M.read (| Value.String "Search" |) ]
                                        |)
                                      |);
                                      M.read (| Value.String "self_iter" |);
                                      M.read (| self_iter |)
                                    ]
                                  |);
                                  M.read (| Value.String "other_iter" |);
                                  M.read (| other_set |)
                                ]
                              |)
                            ]
                          |)
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        let γ1_0 :=
                          M.SubPointer.get_struct_tuple_field (|
                            γ,
                            "alloc::collections::btree::set::DifferenceInner::Iterate",
                            0
                          |) in
                        let x := M.alloc (| γ1_0 |) in
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::builders::DebugTuple",
                              "finish",
                              []
                            |),
                            [
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.path "core::fmt::builders::DebugTuple",
                                  "field",
                                  []
                                |),
                                [
                                  M.alloc (|
                                    M.call_closure (|
                                      M.get_associated_function (|
                                        Ty.path "core::fmt::Formatter",
                                        "debug_tuple",
                                        []
                                      |),
                                      [ M.read (| f |); M.read (| Value.String "Iterate" |) ]
                                    |)
                                  |);
                                  M.read (| x |)
                                ]
                              |)
                            ]
                          |)
                        |)))
                  ]
                |)
              |)))
          | _, _, _ => M.impossible
          end.
        
        Axiom Implements :
          forall (T A : Ty.t),
          M.IsTraitInstance
            "core::fmt::Debug"
            (Self T A)
            (* Trait polymorphic types *) []
            (* Instance *) [ ("fmt", InstanceField.Method (fmt T A)) ].
      End Impl_core_fmt_Debug_where_core_fmt_Debug_T_where_core_alloc_Allocator_A_where_core_clone_Clone_A_for_alloc_collections_btree_set_DifferenceInner_T_A.
      
      Module Impl_core_fmt_Debug_where_core_fmt_Debug_T_where_core_alloc_Allocator_A_where_core_clone_Clone_A_for_alloc_collections_btree_set_Difference_T_A.
        Definition Self (T A : Ty.t) : Ty.t :=
          Ty.apply (Ty.path "alloc::collections::btree::set::Difference") [] [ T; A ].
        
        (*
            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                f.debug_tuple("Difference").field(&self.inner).finish()
            }
        *)
        Definition fmt (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self T A in
          match ε, τ, α with
          | [], [], [ self; f ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let f := M.alloc (| f |) in
              M.call_closure (|
                M.get_associated_function (|
                  Ty.path "core::fmt::builders::DebugTuple",
                  "finish",
                  []
                |),
                [
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.path "core::fmt::builders::DebugTuple",
                      "field",
                      []
                    |),
                    [
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.path "core::fmt::Formatter",
                            "debug_tuple",
                            []
                          |),
                          [ M.read (| f |); M.read (| Value.String "Difference" |) ]
                        |)
                      |);
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "alloc::collections::btree::set::Difference",
                        "inner"
                      |)
                    ]
                  |)
                ]
              |)))
          | _, _, _ => M.impossible
          end.
        
        Axiom Implements :
          forall (T A : Ty.t),
          M.IsTraitInstance
            "core::fmt::Debug"
            (Self T A)
            (* Trait polymorphic types *) []
            (* Instance *) [ ("fmt", InstanceField.Method (fmt T A)) ].
      End Impl_core_fmt_Debug_where_core_fmt_Debug_T_where_core_alloc_Allocator_A_where_core_clone_Clone_A_for_alloc_collections_btree_set_Difference_T_A.
      
      (* StructTuple
        {
          name := "SymmetricDifference";
          const_params := [];
          ty_params := [ "T" ];
          fields :=
            [
              Ty.apply
                (Ty.path "alloc::collections::btree::merge_iter::MergeIterInner")
                []
                [ Ty.apply (Ty.path "alloc::collections::btree::set::Iter") [] [ T ] ]
            ];
        } *)
      
      Module Impl_core_fmt_Debug_where_core_fmt_Debug_T_for_alloc_collections_btree_set_SymmetricDifference_T.
        Definition Self (T : Ty.t) : Ty.t :=
          Ty.apply (Ty.path "alloc::collections::btree::set::SymmetricDifference") [] [ T ].
        
        (*
            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                f.debug_tuple("SymmetricDifference").field(&self.0).finish()
            }
        *)
        Definition fmt (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self T in
          match ε, τ, α with
          | [], [], [ self; f ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let f := M.alloc (| f |) in
              M.call_closure (|
                M.get_associated_function (|
                  Ty.path "core::fmt::builders::DebugTuple",
                  "finish",
                  []
                |),
                [
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.path "core::fmt::builders::DebugTuple",
                      "field",
                      []
                    |),
                    [
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.path "core::fmt::Formatter",
                            "debug_tuple",
                            []
                          |),
                          [ M.read (| f |); M.read (| Value.String "SymmetricDifference" |) ]
                        |)
                      |);
                      M.SubPointer.get_struct_tuple_field (|
                        M.read (| self |),
                        "alloc::collections::btree::set::SymmetricDifference",
                        0
                      |)
                    ]
                  |)
                ]
              |)))
          | _, _, _ => M.impossible
          end.
        
        Axiom Implements :
          forall (T : Ty.t),
          M.IsTraitInstance
            "core::fmt::Debug"
            (Self T)
            (* Trait polymorphic types *) []
            (* Instance *) [ ("fmt", InstanceField.Method (fmt T)) ].
      End Impl_core_fmt_Debug_where_core_fmt_Debug_T_for_alloc_collections_btree_set_SymmetricDifference_T.
      
      (* StructRecord
        {
          name := "Intersection";
          const_params := [];
          ty_params := [ "T"; "A" ];
          fields :=
            [
              ("inner",
                Ty.apply (Ty.path "alloc::collections::btree::set::IntersectionInner") [] [ T; A ])
            ];
        } *)
      
      (*
      Enum IntersectionInner
      {
        const_params := [];
        ty_params := [ "T"; "A" ];
        variants :=
          [
            {
              name := "Stitch";
              item :=
                StructRecord
                  [
                    ("a", Ty.apply (Ty.path "alloc::collections::btree::set::Iter") [] [ T ]);
                    ("b", Ty.apply (Ty.path "alloc::collections::btree::set::Iter") [] [ T ])
                  ];
              discriminant := None;
            };
            {
              name := "Search";
              item :=
                StructRecord
                  [
                    ("small_iter",
                      Ty.apply (Ty.path "alloc::collections::btree::set::Iter") [] [ T ]);
                    ("large_set",
                      Ty.apply
                        (Ty.path "&")
                        []
                        [ Ty.apply (Ty.path "alloc::collections::btree::set::BTreeSet") [] [ T; A ]
                        ])
                  ];
              discriminant := None;
            };
            {
              name := "Answer";
              item :=
                StructTuple
                  [ Ty.apply (Ty.path "core::option::Option") [] [ Ty.apply (Ty.path "&") [] [ T ] ]
                  ];
              discriminant := None;
            }
          ];
      }
      *)
      
      Module Impl_core_fmt_Debug_where_core_fmt_Debug_T_where_core_alloc_Allocator_A_where_core_clone_Clone_A_for_alloc_collections_btree_set_IntersectionInner_T_A.
        Definition Self (T A : Ty.t) : Ty.t :=
          Ty.apply (Ty.path "alloc::collections::btree::set::IntersectionInner") [] [ T; A ].
        
        (*
            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                match self {
                    IntersectionInner::Stitch { a, b } => {
                        f.debug_struct("Stitch").field("a", a).field("b", b).finish()
                    }
                    IntersectionInner::Search { small_iter, large_set } => f
                        .debug_struct("Search")
                        .field("small_iter", small_iter)
                        .field("large_set", large_set)
                        .finish(),
                    IntersectionInner::Answer(x) => f.debug_tuple("Answer").field(x).finish(),
                }
            }
        *)
        Definition fmt (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self T A in
          match ε, τ, α with
          | [], [], [ self; f ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let f := M.alloc (| f |) in
              M.read (|
                M.match_operator (|
                  self,
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        let γ1_0 :=
                          M.SubPointer.get_struct_record_field (|
                            γ,
                            "alloc::collections::btree::set::IntersectionInner::Stitch",
                            "a"
                          |) in
                        let γ1_1 :=
                          M.SubPointer.get_struct_record_field (|
                            γ,
                            "alloc::collections::btree::set::IntersectionInner::Stitch",
                            "b"
                          |) in
                        let a := M.alloc (| γ1_0 |) in
                        let b := M.alloc (| γ1_1 |) in
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::builders::DebugStruct",
                              "finish",
                              []
                            |),
                            [
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.path "core::fmt::builders::DebugStruct",
                                  "field",
                                  []
                                |),
                                [
                                  M.call_closure (|
                                    M.get_associated_function (|
                                      Ty.path "core::fmt::builders::DebugStruct",
                                      "field",
                                      []
                                    |),
                                    [
                                      M.alloc (|
                                        M.call_closure (|
                                          M.get_associated_function (|
                                            Ty.path "core::fmt::Formatter",
                                            "debug_struct",
                                            []
                                          |),
                                          [ M.read (| f |); M.read (| Value.String "Stitch" |) ]
                                        |)
                                      |);
                                      M.read (| Value.String "a" |);
                                      M.read (| a |)
                                    ]
                                  |);
                                  M.read (| Value.String "b" |);
                                  M.read (| b |)
                                ]
                              |)
                            ]
                          |)
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        let γ1_0 :=
                          M.SubPointer.get_struct_record_field (|
                            γ,
                            "alloc::collections::btree::set::IntersectionInner::Search",
                            "small_iter"
                          |) in
                        let γ1_1 :=
                          M.SubPointer.get_struct_record_field (|
                            γ,
                            "alloc::collections::btree::set::IntersectionInner::Search",
                            "large_set"
                          |) in
                        let small_iter := M.alloc (| γ1_0 |) in
                        let large_set := M.alloc (| γ1_1 |) in
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::builders::DebugStruct",
                              "finish",
                              []
                            |),
                            [
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.path "core::fmt::builders::DebugStruct",
                                  "field",
                                  []
                                |),
                                [
                                  M.call_closure (|
                                    M.get_associated_function (|
                                      Ty.path "core::fmt::builders::DebugStruct",
                                      "field",
                                      []
                                    |),
                                    [
                                      M.alloc (|
                                        M.call_closure (|
                                          M.get_associated_function (|
                                            Ty.path "core::fmt::Formatter",
                                            "debug_struct",
                                            []
                                          |),
                                          [ M.read (| f |); M.read (| Value.String "Search" |) ]
                                        |)
                                      |);
                                      M.read (| Value.String "small_iter" |);
                                      M.read (| small_iter |)
                                    ]
                                  |);
                                  M.read (| Value.String "large_set" |);
                                  M.read (| large_set |)
                                ]
                              |)
                            ]
                          |)
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        let γ1_0 :=
                          M.SubPointer.get_struct_tuple_field (|
                            γ,
                            "alloc::collections::btree::set::IntersectionInner::Answer",
                            0
                          |) in
                        let x := M.alloc (| γ1_0 |) in
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::builders::DebugTuple",
                              "finish",
                              []
                            |),
                            [
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.path "core::fmt::builders::DebugTuple",
                                  "field",
                                  []
                                |),
                                [
                                  M.alloc (|
                                    M.call_closure (|
                                      M.get_associated_function (|
                                        Ty.path "core::fmt::Formatter",
                                        "debug_tuple",
                                        []
                                      |),
                                      [ M.read (| f |); M.read (| Value.String "Answer" |) ]
                                    |)
                                  |);
                                  M.read (| x |)
                                ]
                              |)
                            ]
                          |)
                        |)))
                  ]
                |)
              |)))
          | _, _, _ => M.impossible
          end.
        
        Axiom Implements :
          forall (T A : Ty.t),
          M.IsTraitInstance
            "core::fmt::Debug"
            (Self T A)
            (* Trait polymorphic types *) []
            (* Instance *) [ ("fmt", InstanceField.Method (fmt T A)) ].
      End Impl_core_fmt_Debug_where_core_fmt_Debug_T_where_core_alloc_Allocator_A_where_core_clone_Clone_A_for_alloc_collections_btree_set_IntersectionInner_T_A.
      
      Module Impl_core_fmt_Debug_where_core_fmt_Debug_T_where_core_alloc_Allocator_A_where_core_clone_Clone_A_for_alloc_collections_btree_set_Intersection_T_A.
        Definition Self (T A : Ty.t) : Ty.t :=
          Ty.apply (Ty.path "alloc::collections::btree::set::Intersection") [] [ T; A ].
        
        (*
            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                f.debug_tuple("Intersection").field(&self.inner).finish()
            }
        *)
        Definition fmt (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self T A in
          match ε, τ, α with
          | [], [], [ self; f ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let f := M.alloc (| f |) in
              M.call_closure (|
                M.get_associated_function (|
                  Ty.path "core::fmt::builders::DebugTuple",
                  "finish",
                  []
                |),
                [
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.path "core::fmt::builders::DebugTuple",
                      "field",
                      []
                    |),
                    [
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.path "core::fmt::Formatter",
                            "debug_tuple",
                            []
                          |),
                          [ M.read (| f |); M.read (| Value.String "Intersection" |) ]
                        |)
                      |);
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "alloc::collections::btree::set::Intersection",
                        "inner"
                      |)
                    ]
                  |)
                ]
              |)))
          | _, _, _ => M.impossible
          end.
        
        Axiom Implements :
          forall (T A : Ty.t),
          M.IsTraitInstance
            "core::fmt::Debug"
            (Self T A)
            (* Trait polymorphic types *) []
            (* Instance *) [ ("fmt", InstanceField.Method (fmt T A)) ].
      End Impl_core_fmt_Debug_where_core_fmt_Debug_T_where_core_alloc_Allocator_A_where_core_clone_Clone_A_for_alloc_collections_btree_set_Intersection_T_A.
      
      (* StructTuple
        {
          name := "Union";
          const_params := [];
          ty_params := [ "T" ];
          fields :=
            [
              Ty.apply
                (Ty.path "alloc::collections::btree::merge_iter::MergeIterInner")
                []
                [ Ty.apply (Ty.path "alloc::collections::btree::set::Iter") [] [ T ] ]
            ];
        } *)
      
      Module Impl_core_fmt_Debug_where_core_fmt_Debug_T_for_alloc_collections_btree_set_Union_T.
        Definition Self (T : Ty.t) : Ty.t :=
          Ty.apply (Ty.path "alloc::collections::btree::set::Union") [] [ T ].
        
        (*
            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                f.debug_tuple("Union").field(&self.0).finish()
            }
        *)
        Definition fmt (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self T in
          match ε, τ, α with
          | [], [], [ self; f ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let f := M.alloc (| f |) in
              M.call_closure (|
                M.get_associated_function (|
                  Ty.path "core::fmt::builders::DebugTuple",
                  "finish",
                  []
                |),
                [
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.path "core::fmt::builders::DebugTuple",
                      "field",
                      []
                    |),
                    [
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.path "core::fmt::Formatter",
                            "debug_tuple",
                            []
                          |),
                          [ M.read (| f |); M.read (| Value.String "Union" |) ]
                        |)
                      |);
                      M.SubPointer.get_struct_tuple_field (|
                        M.read (| self |),
                        "alloc::collections::btree::set::Union",
                        0
                      |)
                    ]
                  |)
                ]
              |)))
          | _, _, _ => M.impossible
          end.
        
        Axiom Implements :
          forall (T : Ty.t),
          M.IsTraitInstance
            "core::fmt::Debug"
            (Self T)
            (* Trait polymorphic types *) []
            (* Instance *) [ ("fmt", InstanceField.Method (fmt T)) ].
      End Impl_core_fmt_Debug_where_core_fmt_Debug_T_for_alloc_collections_btree_set_Union_T.
      
      Definition value_ITER_PERFORMANCE_TIPPING_SIZE_DIFF : Value.t :=
        M.run ltac:(M.monadic (M.alloc (| Value.Integer 16 |))).
      
      Module Impl_alloc_collections_btree_set_BTreeSet_T_alloc_alloc_Global.
        Definition Self (T : Ty.t) : Ty.t :=
          Ty.apply
            (Ty.path "alloc::collections::btree::set::BTreeSet")
            []
            [ T; Ty.path "alloc::alloc::Global" ].
        
        (*
            pub const fn new() -> BTreeSet<T> {
                BTreeSet { map: BTreeMap::new() }
            }
        *)
        Definition new (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self T in
          match ε, τ, α with
          | [], [], [] =>
            ltac:(M.monadic
              (Value.StructRecord
                "alloc::collections::btree::set::BTreeSet"
                [
                  ("map",
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "alloc::collections::btree::map::BTreeMap")
                          []
                          [
                            T;
                            Ty.path "alloc::collections::btree::set_val::SetValZST";
                            Ty.path "alloc::alloc::Global"
                          ],
                        "new",
                        []
                      |),
                      []
                    |))
                ]))
          | _, _, _ => M.impossible
          end.
        
        Axiom AssociatedFunction_new :
          forall (T : Ty.t),
          M.IsAssociatedFunction (Self T) "new" (new T).
      End Impl_alloc_collections_btree_set_BTreeSet_T_alloc_alloc_Global.
      
      Module Impl_alloc_collections_btree_set_BTreeSet_T_A.
        Definition Self (T A : Ty.t) : Ty.t :=
          Ty.apply (Ty.path "alloc::collections::btree::set::BTreeSet") [] [ T; A ].
        
        (*
            pub const fn new_in(alloc: A) -> BTreeSet<T, A> {
                BTreeSet { map: BTreeMap::new_in(alloc) }
            }
        *)
        Definition new_in (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self T A in
          match ε, τ, α with
          | [], [], [ alloc ] =>
            ltac:(M.monadic
              (let alloc := M.alloc (| alloc |) in
              Value.StructRecord
                "alloc::collections::btree::set::BTreeSet"
                [
                  ("map",
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "alloc::collections::btree::map::BTreeMap")
                          []
                          [ T; Ty.path "alloc::collections::btree::set_val::SetValZST"; A ],
                        "new_in",
                        []
                      |),
                      [ M.read (| alloc |) ]
                    |))
                ]))
          | _, _, _ => M.impossible
          end.
        
        Axiom AssociatedFunction_new_in :
          forall (T A : Ty.t),
          M.IsAssociatedFunction (Self T A) "new_in" (new_in T A).
        
        (*
            pub fn range<K: ?Sized, R>(&self, range: R) -> Range<'_, T>
            where
                K: Ord,
                T: Borrow<K> + Ord,
                R: RangeBounds<K>,
            {
                Range { iter: self.map.range(range) }
            }
        *)
        Definition range (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self T A in
          match ε, τ, α with
          | [], [ K; R ], [ self; range ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let range := M.alloc (| range |) in
              Value.StructRecord
                "alloc::collections::btree::set::Range"
                [
                  ("iter",
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "alloc::collections::btree::map::BTreeMap")
                          []
                          [ T; Ty.path "alloc::collections::btree::set_val::SetValZST"; A ],
                        "range",
                        [ K; R ]
                      |),
                      [
                        M.SubPointer.get_struct_record_field (|
                          M.read (| self |),
                          "alloc::collections::btree::set::BTreeSet",
                          "map"
                        |);
                        M.read (| range |)
                      ]
                    |))
                ]))
          | _, _, _ => M.impossible
          end.
        
        Axiom AssociatedFunction_range :
          forall (T A : Ty.t),
          M.IsAssociatedFunction (Self T A) "range" (range T A).
        
        (*
            pub fn difference<'a>(&'a self, other: &'a BTreeSet<T, A>) -> Difference<'a, T, A>
            where
                T: Ord,
            {
                let (self_min, self_max) =
                    if let (Some(self_min), Some(self_max)) = (self.first(), self.last()) {
                        (self_min, self_max)
                    } else {
                        return Difference { inner: DifferenceInner::Iterate(self.iter()) };
                    };
                let (other_min, other_max) =
                    if let (Some(other_min), Some(other_max)) = (other.first(), other.last()) {
                        (other_min, other_max)
                    } else {
                        return Difference { inner: DifferenceInner::Iterate(self.iter()) };
                    };
                Difference {
                    inner: match (self_min.cmp(other_max), self_max.cmp(other_min)) {
                        (Greater, _) | (_, Less) => DifferenceInner::Iterate(self.iter()),
                        (Equal, _) => {
                            let mut self_iter = self.iter();
                            self_iter.next();
                            DifferenceInner::Iterate(self_iter)
                        }
                        (_, Equal) => {
                            let mut self_iter = self.iter();
                            self_iter.next_back();
                            DifferenceInner::Iterate(self_iter)
                        }
                        _ if self.len() <= other.len() / ITER_PERFORMANCE_TIPPING_SIZE_DIFF => {
                            DifferenceInner::Search { self_iter: self.iter(), other_set: other }
                        }
                        _ => DifferenceInner::Stitch {
                            self_iter: self.iter(),
                            other_iter: other.iter().peekable(),
                        },
                    },
                }
            }
        *)
        Definition difference
            (T A : Ty.t)
            (ε : list Value.t)
            (τ : list Ty.t)
            (α : list Value.t)
            : M :=
          let Self : Ty.t := Self T A in
          match ε, τ, α with
          | [], [], [ self; other ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let other := M.alloc (| other |) in
              M.catch_return (|
                ltac:(M.monadic
                  (M.read (|
                    M.match_operator (|
                      M.match_operator (|
                        M.alloc (| Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.alloc (|
                                  Value.Tuple
                                    [
                                      M.call_closure (|
                                        M.get_associated_function (|
                                          Ty.apply
                                            (Ty.path "alloc::collections::btree::set::BTreeSet")
                                            []
                                            [ T; A ],
                                          "first",
                                          []
                                        |),
                                        [ M.read (| self |) ]
                                      |);
                                      M.call_closure (|
                                        M.get_associated_function (|
                                          Ty.apply
                                            (Ty.path "alloc::collections::btree::set::BTreeSet")
                                            []
                                            [ T; A ],
                                          "last",
                                          []
                                        |),
                                        [ M.read (| self |) ]
                                      |)
                                    ]
                                |) in
                              let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                              let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                              let γ1_0 :=
                                M.SubPointer.get_struct_tuple_field (|
                                  γ0_0,
                                  "core::option::Option::Some",
                                  0
                                |) in
                              let self_min := M.copy (| γ1_0 |) in
                              let γ1_0 :=
                                M.SubPointer.get_struct_tuple_field (|
                                  γ0_1,
                                  "core::option::Option::Some",
                                  0
                                |) in
                              let self_max := M.copy (| γ1_0 |) in
                              M.alloc (|
                                Value.Tuple [ M.read (| self_min |); M.read (| self_max |) ]
                              |)));
                          fun γ =>
                            ltac:(M.monadic
                              (M.alloc (|
                                M.never_to_any (|
                                  M.read (|
                                    M.return_ (|
                                      Value.StructRecord
                                        "alloc::collections::btree::set::Difference"
                                        [
                                          ("inner",
                                            Value.StructTuple
                                              "alloc::collections::btree::set::DifferenceInner::Iterate"
                                              [
                                                M.call_closure (|
                                                  M.get_associated_function (|
                                                    Ty.apply
                                                      (Ty.path
                                                        "alloc::collections::btree::set::BTreeSet")
                                                      []
                                                      [ T; A ],
                                                    "iter",
                                                    []
                                                  |),
                                                  [ M.read (| self |) ]
                                                |)
                                              ])
                                        ]
                                    |)
                                  |)
                                |)
                              |)))
                        ]
                      |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                            let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                            let self_min := M.copy (| γ0_0 |) in
                            let self_max := M.copy (| γ0_1 |) in
                            M.match_operator (|
                              M.match_operator (|
                                M.alloc (| Value.Tuple [] |),
                                [
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let γ :=
                                        M.alloc (|
                                          Value.Tuple
                                            [
                                              M.call_closure (|
                                                M.get_associated_function (|
                                                  Ty.apply
                                                    (Ty.path
                                                      "alloc::collections::btree::set::BTreeSet")
                                                    []
                                                    [ T; A ],
                                                  "first",
                                                  []
                                                |),
                                                [ M.read (| other |) ]
                                              |);
                                              M.call_closure (|
                                                M.get_associated_function (|
                                                  Ty.apply
                                                    (Ty.path
                                                      "alloc::collections::btree::set::BTreeSet")
                                                    []
                                                    [ T; A ],
                                                  "last",
                                                  []
                                                |),
                                                [ M.read (| other |) ]
                                              |)
                                            ]
                                        |) in
                                      let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                      let γ1_0 :=
                                        M.SubPointer.get_struct_tuple_field (|
                                          γ0_0,
                                          "core::option::Option::Some",
                                          0
                                        |) in
                                      let other_min := M.copy (| γ1_0 |) in
                                      let γ1_0 :=
                                        M.SubPointer.get_struct_tuple_field (|
                                          γ0_1,
                                          "core::option::Option::Some",
                                          0
                                        |) in
                                      let other_max := M.copy (| γ1_0 |) in
                                      M.alloc (|
                                        Value.Tuple
                                          [ M.read (| other_min |); M.read (| other_max |) ]
                                      |)));
                                  fun γ =>
                                    ltac:(M.monadic
                                      (M.alloc (|
                                        M.never_to_any (|
                                          M.read (|
                                            M.return_ (|
                                              Value.StructRecord
                                                "alloc::collections::btree::set::Difference"
                                                [
                                                  ("inner",
                                                    Value.StructTuple
                                                      "alloc::collections::btree::set::DifferenceInner::Iterate"
                                                      [
                                                        M.call_closure (|
                                                          M.get_associated_function (|
                                                            Ty.apply
                                                              (Ty.path
                                                                "alloc::collections::btree::set::BTreeSet")
                                                              []
                                                              [ T; A ],
                                                            "iter",
                                                            []
                                                          |),
                                                          [ M.read (| self |) ]
                                                        |)
                                                      ])
                                                ]
                                            |)
                                          |)
                                        |)
                                      |)))
                                ]
                              |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                    let other_min := M.copy (| γ0_0 |) in
                                    let other_max := M.copy (| γ0_1 |) in
                                    M.alloc (|
                                      Value.StructRecord
                                        "alloc::collections::btree::set::Difference"
                                        [
                                          ("inner",
                                            M.read (|
                                              M.match_operator (|
                                                M.alloc (|
                                                  Value.Tuple
                                                    [
                                                      M.call_closure (|
                                                        M.get_trait_method (|
                                                          "core::cmp::Ord",
                                                          T,
                                                          [],
                                                          "cmp",
                                                          []
                                                        |),
                                                        [
                                                          M.read (| self_min |);
                                                          M.read (| other_max |)
                                                        ]
                                                      |);
                                                      M.call_closure (|
                                                        M.get_trait_method (|
                                                          "core::cmp::Ord",
                                                          T,
                                                          [],
                                                          "cmp",
                                                          []
                                                        |),
                                                        [
                                                          M.read (| self_max |);
                                                          M.read (| other_min |)
                                                        ]
                                                      |)
                                                    ]
                                                |),
                                                [
                                                  fun γ =>
                                                    ltac:(M.monadic
                                                      (M.find_or_pattern (|
                                                        γ,
                                                        [
                                                          fun γ =>
                                                            ltac:(M.monadic
                                                              (let γ0_0 :=
                                                                M.SubPointer.get_tuple_field (|
                                                                  γ,
                                                                  0
                                                                |) in
                                                              let γ0_1 :=
                                                                M.SubPointer.get_tuple_field (|
                                                                  γ,
                                                                  1
                                                                |) in
                                                              let _ :=
                                                                M.is_struct_tuple (|
                                                                  γ0_0,
                                                                  "core::cmp::Ordering::Greater"
                                                                |) in
                                                              Value.Tuple []));
                                                          fun γ =>
                                                            ltac:(M.monadic
                                                              (let γ0_0 :=
                                                                M.SubPointer.get_tuple_field (|
                                                                  γ,
                                                                  0
                                                                |) in
                                                              let γ0_1 :=
                                                                M.SubPointer.get_tuple_field (|
                                                                  γ,
                                                                  1
                                                                |) in
                                                              let _ :=
                                                                M.is_struct_tuple (|
                                                                  γ0_1,
                                                                  "core::cmp::Ordering::Less"
                                                                |) in
                                                              Value.Tuple []))
                                                        ],
                                                        M.closure
                                                          (fun γ =>
                                                            ltac:(M.monadic
                                                              match γ with
                                                              | [] =>
                                                                M.alloc (|
                                                                  Value.StructTuple
                                                                    "alloc::collections::btree::set::DifferenceInner::Iterate"
                                                                    [
                                                                      M.call_closure (|
                                                                        M.get_associated_function (|
                                                                          Ty.apply
                                                                            (Ty.path
                                                                              "alloc::collections::btree::set::BTreeSet")
                                                                            []
                                                                            [ T; A ],
                                                                          "iter",
                                                                          []
                                                                        |),
                                                                        [ M.read (| self |) ]
                                                                      |)
                                                                    ]
                                                                |)
                                                              | _ => M.impossible (||)
                                                              end))
                                                      |)));
                                                  fun γ =>
                                                    ltac:(M.monadic
                                                      (let γ0_0 :=
                                                        M.SubPointer.get_tuple_field (| γ, 0 |) in
                                                      let γ0_1 :=
                                                        M.SubPointer.get_tuple_field (| γ, 1 |) in
                                                      let _ :=
                                                        M.is_struct_tuple (|
                                                          γ0_0,
                                                          "core::cmp::Ordering::Equal"
                                                        |) in
                                                      let~ self_iter :=
                                                        M.alloc (|
                                                          M.call_closure (|
                                                            M.get_associated_function (|
                                                              Ty.apply
                                                                (Ty.path
                                                                  "alloc::collections::btree::set::BTreeSet")
                                                                []
                                                                [ T; A ],
                                                              "iter",
                                                              []
                                                            |),
                                                            [ M.read (| self |) ]
                                                          |)
                                                        |) in
                                                      let~ _ :=
                                                        M.alloc (|
                                                          M.call_closure (|
                                                            M.get_trait_method (|
                                                              "core::iter::traits::iterator::Iterator",
                                                              Ty.apply
                                                                (Ty.path
                                                                  "alloc::collections::btree::set::Iter")
                                                                []
                                                                [ T ],
                                                              [],
                                                              "next",
                                                              []
                                                            |),
                                                            [ self_iter ]
                                                          |)
                                                        |) in
                                                      M.alloc (|
                                                        Value.StructTuple
                                                          "alloc::collections::btree::set::DifferenceInner::Iterate"
                                                          [ M.read (| self_iter |) ]
                                                      |)));
                                                  fun γ =>
                                                    ltac:(M.monadic
                                                      (let γ0_0 :=
                                                        M.SubPointer.get_tuple_field (| γ, 0 |) in
                                                      let γ0_1 :=
                                                        M.SubPointer.get_tuple_field (| γ, 1 |) in
                                                      let _ :=
                                                        M.is_struct_tuple (|
                                                          γ0_1,
                                                          "core::cmp::Ordering::Equal"
                                                        |) in
                                                      let~ self_iter :=
                                                        M.alloc (|
                                                          M.call_closure (|
                                                            M.get_associated_function (|
                                                              Ty.apply
                                                                (Ty.path
                                                                  "alloc::collections::btree::set::BTreeSet")
                                                                []
                                                                [ T; A ],
                                                              "iter",
                                                              []
                                                            |),
                                                            [ M.read (| self |) ]
                                                          |)
                                                        |) in
                                                      let~ _ :=
                                                        M.alloc (|
                                                          M.call_closure (|
                                                            M.get_trait_method (|
                                                              "core::iter::traits::double_ended::DoubleEndedIterator",
                                                              Ty.apply
                                                                (Ty.path
                                                                  "alloc::collections::btree::set::Iter")
                                                                []
                                                                [ T ],
                                                              [],
                                                              "next_back",
                                                              []
                                                            |),
                                                            [ self_iter ]
                                                          |)
                                                        |) in
                                                      M.alloc (|
                                                        Value.StructTuple
                                                          "alloc::collections::btree::set::DifferenceInner::Iterate"
                                                          [ M.read (| self_iter |) ]
                                                      |)));
                                                  fun γ =>
                                                    ltac:(M.monadic
                                                      (let γ :=
                                                        M.alloc (|
                                                          BinOp.Pure.le
                                                            (M.call_closure (|
                                                              M.get_associated_function (|
                                                                Ty.apply
                                                                  (Ty.path
                                                                    "alloc::collections::btree::set::BTreeSet")
                                                                  []
                                                                  [ T; A ],
                                                                "len",
                                                                []
                                                              |),
                                                              [ M.read (| self |) ]
                                                            |))
                                                            (BinOp.Wrap.div
                                                              Integer.Usize
                                                              (M.call_closure (|
                                                                M.get_associated_function (|
                                                                  Ty.apply
                                                                    (Ty.path
                                                                      "alloc::collections::btree::set::BTreeSet")
                                                                    []
                                                                    [ T; A ],
                                                                  "len",
                                                                  []
                                                                |),
                                                                [ M.read (| other |) ]
                                                              |))
                                                              (M.read (|
                                                                M.get_constant (|
                                                                  "alloc::collections::btree::set::ITER_PERFORMANCE_TIPPING_SIZE_DIFF"
                                                                |)
                                                              |)))
                                                        |) in
                                                      let _ :=
                                                        M.is_constant_or_break_match (|
                                                          M.read (| γ |),
                                                          Value.Bool true
                                                        |) in
                                                      M.alloc (|
                                                        Value.StructRecord
                                                          "alloc::collections::btree::set::DifferenceInner::Search"
                                                          [
                                                            ("self_iter",
                                                              M.call_closure (|
                                                                M.get_associated_function (|
                                                                  Ty.apply
                                                                    (Ty.path
                                                                      "alloc::collections::btree::set::BTreeSet")
                                                                    []
                                                                    [ T; A ],
                                                                  "iter",
                                                                  []
                                                                |),
                                                                [ M.read (| self |) ]
                                                              |));
                                                            ("other_set", M.read (| other |))
                                                          ]
                                                      |)));
                                                  fun γ =>
                                                    ltac:(M.monadic
                                                      (M.alloc (|
                                                        Value.StructRecord
                                                          "alloc::collections::btree::set::DifferenceInner::Stitch"
                                                          [
                                                            ("self_iter",
                                                              M.call_closure (|
                                                                M.get_associated_function (|
                                                                  Ty.apply
                                                                    (Ty.path
                                                                      "alloc::collections::btree::set::BTreeSet")
                                                                    []
                                                                    [ T; A ],
                                                                  "iter",
                                                                  []
                                                                |),
                                                                [ M.read (| self |) ]
                                                              |));
                                                            ("other_iter",
                                                              M.call_closure (|
                                                                M.get_trait_method (|
                                                                  "core::iter::traits::iterator::Iterator",
                                                                  Ty.apply
                                                                    (Ty.path
                                                                      "alloc::collections::btree::set::Iter")
                                                                    []
                                                                    [ T ],
                                                                  [],
                                                                  "peekable",
                                                                  []
                                                                |),
                                                                [
                                                                  M.call_closure (|
                                                                    M.get_associated_function (|
                                                                      Ty.apply
                                                                        (Ty.path
                                                                          "alloc::collections::btree::set::BTreeSet")
                                                                        []
                                                                        [ T; A ],
                                                                      "iter",
                                                                      []
                                                                    |),
                                                                    [ M.read (| other |) ]
                                                                  |)
                                                                ]
                                                              |))
                                                          ]
                                                      |)))
                                                ]
                                              |)
                                            |))
                                        ]
                                    |)))
                              ]
                            |)))
                      ]
                    |)
                  |)))
              |)))
          | _, _, _ => M.impossible
          end.
        
        Axiom AssociatedFunction_difference :
          forall (T A : Ty.t),
          M.IsAssociatedFunction (Self T A) "difference" (difference T A).
        
        (*
            pub fn symmetric_difference<'a>(
                &'a self,
                other: &'a BTreeSet<T, A>,
            ) -> SymmetricDifference<'a, T>
            where
                T: Ord,
            {
                SymmetricDifference(MergeIterInner::new(self.iter(), other.iter()))
            }
        *)
        Definition symmetric_difference
            (T A : Ty.t)
            (ε : list Value.t)
            (τ : list Ty.t)
            (α : list Value.t)
            : M :=
          let Self : Ty.t := Self T A in
          match ε, τ, α with
          | [], [], [ self; other ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let other := M.alloc (| other |) in
              Value.StructTuple
                "alloc::collections::btree::set::SymmetricDifference"
                [
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "alloc::collections::btree::merge_iter::MergeIterInner")
                        []
                        [ Ty.apply (Ty.path "alloc::collections::btree::set::Iter") [] [ T ] ],
                      "new",
                      []
                    |),
                    [
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "alloc::collections::btree::set::BTreeSet") [] [ T; A ],
                          "iter",
                          []
                        |),
                        [ M.read (| self |) ]
                      |);
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "alloc::collections::btree::set::BTreeSet") [] [ T; A ],
                          "iter",
                          []
                        |),
                        [ M.read (| other |) ]
                      |)
                    ]
                  |)
                ]))
          | _, _, _ => M.impossible
          end.
        
        Axiom AssociatedFunction_symmetric_difference :
          forall (T A : Ty.t),
          M.IsAssociatedFunction (Self T A) "symmetric_difference" (symmetric_difference T A).
        
        (*
            pub fn intersection<'a>(&'a self, other: &'a BTreeSet<T, A>) -> Intersection<'a, T, A>
            where
                T: Ord,
            {
                let (self_min, self_max) =
                    if let (Some(self_min), Some(self_max)) = (self.first(), self.last()) {
                        (self_min, self_max)
                    } else {
                        return Intersection { inner: IntersectionInner::Answer(None) };
                    };
                let (other_min, other_max) =
                    if let (Some(other_min), Some(other_max)) = (other.first(), other.last()) {
                        (other_min, other_max)
                    } else {
                        return Intersection { inner: IntersectionInner::Answer(None) };
                    };
                Intersection {
                    inner: match (self_min.cmp(other_max), self_max.cmp(other_min)) {
                        (Greater, _) | (_, Less) => IntersectionInner::Answer(None),
                        (Equal, _) => IntersectionInner::Answer(Some(self_min)),
                        (_, Equal) => IntersectionInner::Answer(Some(self_max)),
                        _ if self.len() <= other.len() / ITER_PERFORMANCE_TIPPING_SIZE_DIFF => {
                            IntersectionInner::Search { small_iter: self.iter(), large_set: other }
                        }
                        _ if other.len() <= self.len() / ITER_PERFORMANCE_TIPPING_SIZE_DIFF => {
                            IntersectionInner::Search { small_iter: other.iter(), large_set: self }
                        }
                        _ => IntersectionInner::Stitch { a: self.iter(), b: other.iter() },
                    },
                }
            }
        *)
        Definition intersection
            (T A : Ty.t)
            (ε : list Value.t)
            (τ : list Ty.t)
            (α : list Value.t)
            : M :=
          let Self : Ty.t := Self T A in
          match ε, τ, α with
          | [], [], [ self; other ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let other := M.alloc (| other |) in
              M.catch_return (|
                ltac:(M.monadic
                  (M.read (|
                    M.match_operator (|
                      M.match_operator (|
                        M.alloc (| Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.alloc (|
                                  Value.Tuple
                                    [
                                      M.call_closure (|
                                        M.get_associated_function (|
                                          Ty.apply
                                            (Ty.path "alloc::collections::btree::set::BTreeSet")
                                            []
                                            [ T; A ],
                                          "first",
                                          []
                                        |),
                                        [ M.read (| self |) ]
                                      |);
                                      M.call_closure (|
                                        M.get_associated_function (|
                                          Ty.apply
                                            (Ty.path "alloc::collections::btree::set::BTreeSet")
                                            []
                                            [ T; A ],
                                          "last",
                                          []
                                        |),
                                        [ M.read (| self |) ]
                                      |)
                                    ]
                                |) in
                              let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                              let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                              let γ1_0 :=
                                M.SubPointer.get_struct_tuple_field (|
                                  γ0_0,
                                  "core::option::Option::Some",
                                  0
                                |) in
                              let self_min := M.copy (| γ1_0 |) in
                              let γ1_0 :=
                                M.SubPointer.get_struct_tuple_field (|
                                  γ0_1,
                                  "core::option::Option::Some",
                                  0
                                |) in
                              let self_max := M.copy (| γ1_0 |) in
                              M.alloc (|
                                Value.Tuple [ M.read (| self_min |); M.read (| self_max |) ]
                              |)));
                          fun γ =>
                            ltac:(M.monadic
                              (M.alloc (|
                                M.never_to_any (|
                                  M.read (|
                                    M.return_ (|
                                      Value.StructRecord
                                        "alloc::collections::btree::set::Intersection"
                                        [
                                          ("inner",
                                            Value.StructTuple
                                              "alloc::collections::btree::set::IntersectionInner::Answer"
                                              [ Value.StructTuple "core::option::Option::None" [] ])
                                        ]
                                    |)
                                  |)
                                |)
                              |)))
                        ]
                      |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                            let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                            let self_min := M.copy (| γ0_0 |) in
                            let self_max := M.copy (| γ0_1 |) in
                            M.match_operator (|
                              M.match_operator (|
                                M.alloc (| Value.Tuple [] |),
                                [
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let γ :=
                                        M.alloc (|
                                          Value.Tuple
                                            [
                                              M.call_closure (|
                                                M.get_associated_function (|
                                                  Ty.apply
                                                    (Ty.path
                                                      "alloc::collections::btree::set::BTreeSet")
                                                    []
                                                    [ T; A ],
                                                  "first",
                                                  []
                                                |),
                                                [ M.read (| other |) ]
                                              |);
                                              M.call_closure (|
                                                M.get_associated_function (|
                                                  Ty.apply
                                                    (Ty.path
                                                      "alloc::collections::btree::set::BTreeSet")
                                                    []
                                                    [ T; A ],
                                                  "last",
                                                  []
                                                |),
                                                [ M.read (| other |) ]
                                              |)
                                            ]
                                        |) in
                                      let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                      let γ1_0 :=
                                        M.SubPointer.get_struct_tuple_field (|
                                          γ0_0,
                                          "core::option::Option::Some",
                                          0
                                        |) in
                                      let other_min := M.copy (| γ1_0 |) in
                                      let γ1_0 :=
                                        M.SubPointer.get_struct_tuple_field (|
                                          γ0_1,
                                          "core::option::Option::Some",
                                          0
                                        |) in
                                      let other_max := M.copy (| γ1_0 |) in
                                      M.alloc (|
                                        Value.Tuple
                                          [ M.read (| other_min |); M.read (| other_max |) ]
                                      |)));
                                  fun γ =>
                                    ltac:(M.monadic
                                      (M.alloc (|
                                        M.never_to_any (|
                                          M.read (|
                                            M.return_ (|
                                              Value.StructRecord
                                                "alloc::collections::btree::set::Intersection"
                                                [
                                                  ("inner",
                                                    Value.StructTuple
                                                      "alloc::collections::btree::set::IntersectionInner::Answer"
                                                      [
                                                        Value.StructTuple
                                                          "core::option::Option::None"
                                                          []
                                                      ])
                                                ]
                                            |)
                                          |)
                                        |)
                                      |)))
                                ]
                              |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                    let other_min := M.copy (| γ0_0 |) in
                                    let other_max := M.copy (| γ0_1 |) in
                                    M.alloc (|
                                      Value.StructRecord
                                        "alloc::collections::btree::set::Intersection"
                                        [
                                          ("inner",
                                            M.read (|
                                              M.match_operator (|
                                                M.alloc (|
                                                  Value.Tuple
                                                    [
                                                      M.call_closure (|
                                                        M.get_trait_method (|
                                                          "core::cmp::Ord",
                                                          T,
                                                          [],
                                                          "cmp",
                                                          []
                                                        |),
                                                        [
                                                          M.read (| self_min |);
                                                          M.read (| other_max |)
                                                        ]
                                                      |);
                                                      M.call_closure (|
                                                        M.get_trait_method (|
                                                          "core::cmp::Ord",
                                                          T,
                                                          [],
                                                          "cmp",
                                                          []
                                                        |),
                                                        [
                                                          M.read (| self_max |);
                                                          M.read (| other_min |)
                                                        ]
                                                      |)
                                                    ]
                                                |),
                                                [
                                                  fun γ =>
                                                    ltac:(M.monadic
                                                      (M.find_or_pattern (|
                                                        γ,
                                                        [
                                                          fun γ =>
                                                            ltac:(M.monadic
                                                              (let γ0_0 :=
                                                                M.SubPointer.get_tuple_field (|
                                                                  γ,
                                                                  0
                                                                |) in
                                                              let γ0_1 :=
                                                                M.SubPointer.get_tuple_field (|
                                                                  γ,
                                                                  1
                                                                |) in
                                                              let _ :=
                                                                M.is_struct_tuple (|
                                                                  γ0_0,
                                                                  "core::cmp::Ordering::Greater"
                                                                |) in
                                                              Value.Tuple []));
                                                          fun γ =>
                                                            ltac:(M.monadic
                                                              (let γ0_0 :=
                                                                M.SubPointer.get_tuple_field (|
                                                                  γ,
                                                                  0
                                                                |) in
                                                              let γ0_1 :=
                                                                M.SubPointer.get_tuple_field (|
                                                                  γ,
                                                                  1
                                                                |) in
                                                              let _ :=
                                                                M.is_struct_tuple (|
                                                                  γ0_1,
                                                                  "core::cmp::Ordering::Less"
                                                                |) in
                                                              Value.Tuple []))
                                                        ],
                                                        M.closure
                                                          (fun γ =>
                                                            ltac:(M.monadic
                                                              match γ with
                                                              | [] =>
                                                                M.alloc (|
                                                                  Value.StructTuple
                                                                    "alloc::collections::btree::set::IntersectionInner::Answer"
                                                                    [
                                                                      Value.StructTuple
                                                                        "core::option::Option::None"
                                                                        []
                                                                    ]
                                                                |)
                                                              | _ => M.impossible (||)
                                                              end))
                                                      |)));
                                                  fun γ =>
                                                    ltac:(M.monadic
                                                      (let γ0_0 :=
                                                        M.SubPointer.get_tuple_field (| γ, 0 |) in
                                                      let γ0_1 :=
                                                        M.SubPointer.get_tuple_field (| γ, 1 |) in
                                                      let _ :=
                                                        M.is_struct_tuple (|
                                                          γ0_0,
                                                          "core::cmp::Ordering::Equal"
                                                        |) in
                                                      M.alloc (|
                                                        Value.StructTuple
                                                          "alloc::collections::btree::set::IntersectionInner::Answer"
                                                          [
                                                            Value.StructTuple
                                                              "core::option::Option::Some"
                                                              [ M.read (| self_min |) ]
                                                          ]
                                                      |)));
                                                  fun γ =>
                                                    ltac:(M.monadic
                                                      (let γ0_0 :=
                                                        M.SubPointer.get_tuple_field (| γ, 0 |) in
                                                      let γ0_1 :=
                                                        M.SubPointer.get_tuple_field (| γ, 1 |) in
                                                      let _ :=
                                                        M.is_struct_tuple (|
                                                          γ0_1,
                                                          "core::cmp::Ordering::Equal"
                                                        |) in
                                                      M.alloc (|
                                                        Value.StructTuple
                                                          "alloc::collections::btree::set::IntersectionInner::Answer"
                                                          [
                                                            Value.StructTuple
                                                              "core::option::Option::Some"
                                                              [ M.read (| self_max |) ]
                                                          ]
                                                      |)));
                                                  fun γ =>
                                                    ltac:(M.monadic
                                                      (let γ :=
                                                        M.alloc (|
                                                          BinOp.Pure.le
                                                            (M.call_closure (|
                                                              M.get_associated_function (|
                                                                Ty.apply
                                                                  (Ty.path
                                                                    "alloc::collections::btree::set::BTreeSet")
                                                                  []
                                                                  [ T; A ],
                                                                "len",
                                                                []
                                                              |),
                                                              [ M.read (| self |) ]
                                                            |))
                                                            (BinOp.Wrap.div
                                                              Integer.Usize
                                                              (M.call_closure (|
                                                                M.get_associated_function (|
                                                                  Ty.apply
                                                                    (Ty.path
                                                                      "alloc::collections::btree::set::BTreeSet")
                                                                    []
                                                                    [ T; A ],
                                                                  "len",
                                                                  []
                                                                |),
                                                                [ M.read (| other |) ]
                                                              |))
                                                              (M.read (|
                                                                M.get_constant (|
                                                                  "alloc::collections::btree::set::ITER_PERFORMANCE_TIPPING_SIZE_DIFF"
                                                                |)
                                                              |)))
                                                        |) in
                                                      let _ :=
                                                        M.is_constant_or_break_match (|
                                                          M.read (| γ |),
                                                          Value.Bool true
                                                        |) in
                                                      M.alloc (|
                                                        Value.StructRecord
                                                          "alloc::collections::btree::set::IntersectionInner::Search"
                                                          [
                                                            ("small_iter",
                                                              M.call_closure (|
                                                                M.get_associated_function (|
                                                                  Ty.apply
                                                                    (Ty.path
                                                                      "alloc::collections::btree::set::BTreeSet")
                                                                    []
                                                                    [ T; A ],
                                                                  "iter",
                                                                  []
                                                                |),
                                                                [ M.read (| self |) ]
                                                              |));
                                                            ("large_set", M.read (| other |))
                                                          ]
                                                      |)));
                                                  fun γ =>
                                                    ltac:(M.monadic
                                                      (let γ :=
                                                        M.alloc (|
                                                          BinOp.Pure.le
                                                            (M.call_closure (|
                                                              M.get_associated_function (|
                                                                Ty.apply
                                                                  (Ty.path
                                                                    "alloc::collections::btree::set::BTreeSet")
                                                                  []
                                                                  [ T; A ],
                                                                "len",
                                                                []
                                                              |),
                                                              [ M.read (| other |) ]
                                                            |))
                                                            (BinOp.Wrap.div
                                                              Integer.Usize
                                                              (M.call_closure (|
                                                                M.get_associated_function (|
                                                                  Ty.apply
                                                                    (Ty.path
                                                                      "alloc::collections::btree::set::BTreeSet")
                                                                    []
                                                                    [ T; A ],
                                                                  "len",
                                                                  []
                                                                |),
                                                                [ M.read (| self |) ]
                                                              |))
                                                              (M.read (|
                                                                M.get_constant (|
                                                                  "alloc::collections::btree::set::ITER_PERFORMANCE_TIPPING_SIZE_DIFF"
                                                                |)
                                                              |)))
                                                        |) in
                                                      let _ :=
                                                        M.is_constant_or_break_match (|
                                                          M.read (| γ |),
                                                          Value.Bool true
                                                        |) in
                                                      M.alloc (|
                                                        Value.StructRecord
                                                          "alloc::collections::btree::set::IntersectionInner::Search"
                                                          [
                                                            ("small_iter",
                                                              M.call_closure (|
                                                                M.get_associated_function (|
                                                                  Ty.apply
                                                                    (Ty.path
                                                                      "alloc::collections::btree::set::BTreeSet")
                                                                    []
                                                                    [ T; A ],
                                                                  "iter",
                                                                  []
                                                                |),
                                                                [ M.read (| other |) ]
                                                              |));
                                                            ("large_set", M.read (| self |))
                                                          ]
                                                      |)));
                                                  fun γ =>
                                                    ltac:(M.monadic
                                                      (M.alloc (|
                                                        Value.StructRecord
                                                          "alloc::collections::btree::set::IntersectionInner::Stitch"
                                                          [
                                                            ("a",
                                                              M.call_closure (|
                                                                M.get_associated_function (|
                                                                  Ty.apply
                                                                    (Ty.path
                                                                      "alloc::collections::btree::set::BTreeSet")
                                                                    []
                                                                    [ T; A ],
                                                                  "iter",
                                                                  []
                                                                |),
                                                                [ M.read (| self |) ]
                                                              |));
                                                            ("b",
                                                              M.call_closure (|
                                                                M.get_associated_function (|
                                                                  Ty.apply
                                                                    (Ty.path
                                                                      "alloc::collections::btree::set::BTreeSet")
                                                                    []
                                                                    [ T; A ],
                                                                  "iter",
                                                                  []
                                                                |),
                                                                [ M.read (| other |) ]
                                                              |))
                                                          ]
                                                      |)))
                                                ]
                                              |)
                                            |))
                                        ]
                                    |)))
                              ]
                            |)))
                      ]
                    |)
                  |)))
              |)))
          | _, _, _ => M.impossible
          end.
        
        Axiom AssociatedFunction_intersection :
          forall (T A : Ty.t),
          M.IsAssociatedFunction (Self T A) "intersection" (intersection T A).
        
        (*
            pub fn union<'a>(&'a self, other: &'a BTreeSet<T, A>) -> Union<'a, T>
            where
                T: Ord,
            {
                Union(MergeIterInner::new(self.iter(), other.iter()))
            }
        *)
        Definition union (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self T A in
          match ε, τ, α with
          | [], [], [ self; other ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let other := M.alloc (| other |) in
              Value.StructTuple
                "alloc::collections::btree::set::Union"
                [
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "alloc::collections::btree::merge_iter::MergeIterInner")
                        []
                        [ Ty.apply (Ty.path "alloc::collections::btree::set::Iter") [] [ T ] ],
                      "new",
                      []
                    |),
                    [
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "alloc::collections::btree::set::BTreeSet") [] [ T; A ],
                          "iter",
                          []
                        |),
                        [ M.read (| self |) ]
                      |);
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "alloc::collections::btree::set::BTreeSet") [] [ T; A ],
                          "iter",
                          []
                        |),
                        [ M.read (| other |) ]
                      |)
                    ]
                  |)
                ]))
          | _, _, _ => M.impossible
          end.
        
        Axiom AssociatedFunction_union :
          forall (T A : Ty.t),
          M.IsAssociatedFunction (Self T A) "union" (union T A).
        
        (*
            pub fn clear(&mut self)
            where
                A: Clone,
            {
                self.map.clear()
            }
        *)
        Definition clear (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self T A in
          match ε, τ, α with
          | [], [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "alloc::collections::btree::map::BTreeMap")
                    []
                    [ T; Ty.path "alloc::collections::btree::set_val::SetValZST"; A ],
                  "clear",
                  []
                |),
                [
                  M.SubPointer.get_struct_record_field (|
                    M.read (| self |),
                    "alloc::collections::btree::set::BTreeSet",
                    "map"
                  |)
                ]
              |)))
          | _, _, _ => M.impossible
          end.
        
        Axiom AssociatedFunction_clear :
          forall (T A : Ty.t),
          M.IsAssociatedFunction (Self T A) "clear" (clear T A).
        
        (*
            pub fn contains<Q: ?Sized>(&self, value: &Q) -> bool
            where
                T: Borrow<Q> + Ord,
                Q: Ord,
            {
                self.map.contains_key(value)
            }
        *)
        Definition contains
            (T A : Ty.t)
            (ε : list Value.t)
            (τ : list Ty.t)
            (α : list Value.t)
            : M :=
          let Self : Ty.t := Self T A in
          match ε, τ, α with
          | [], [ Q ], [ self; value ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let value := M.alloc (| value |) in
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "alloc::collections::btree::map::BTreeMap")
                    []
                    [ T; Ty.path "alloc::collections::btree::set_val::SetValZST"; A ],
                  "contains_key",
                  [ Q ]
                |),
                [
                  M.SubPointer.get_struct_record_field (|
                    M.read (| self |),
                    "alloc::collections::btree::set::BTreeSet",
                    "map"
                  |);
                  M.read (| value |)
                ]
              |)))
          | _, _, _ => M.impossible
          end.
        
        Axiom AssociatedFunction_contains :
          forall (T A : Ty.t),
          M.IsAssociatedFunction (Self T A) "contains" (contains T A).
        
        (*
            pub fn get<Q: ?Sized>(&self, value: &Q) -> Option<&T>
            where
                T: Borrow<Q> + Ord,
                Q: Ord,
            {
                Recover::get(&self.map, value)
            }
        *)
        Definition get (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self T A in
          match ε, τ, α with
          | [], [ Q ], [ self; value ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let value := M.alloc (| value |) in
              M.call_closure (|
                M.get_trait_method (|
                  "alloc::collections::btree::Recover",
                  Ty.apply
                    (Ty.path "alloc::collections::btree::map::BTreeMap")
                    []
                    [ T; Ty.path "alloc::collections::btree::set_val::SetValZST"; A ],
                  [ Q ],
                  "get",
                  []
                |),
                [
                  M.SubPointer.get_struct_record_field (|
                    M.read (| self |),
                    "alloc::collections::btree::set::BTreeSet",
                    "map"
                  |);
                  M.read (| value |)
                ]
              |)))
          | _, _, _ => M.impossible
          end.
        
        Axiom AssociatedFunction_get :
          forall (T A : Ty.t),
          M.IsAssociatedFunction (Self T A) "get" (get T A).
        
        (*
            pub fn is_disjoint(&self, other: &BTreeSet<T, A>) -> bool
            where
                T: Ord,
            {
                self.intersection(other).next().is_none()
            }
        *)
        Definition is_disjoint
            (T A : Ty.t)
            (ε : list Value.t)
            (τ : list Ty.t)
            (α : list Value.t)
            : M :=
          let Self : Ty.t := Self T A in
          match ε, τ, α with
          | [], [], [ self; other ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let other := M.alloc (| other |) in
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply (Ty.path "core::option::Option") [] [ Ty.apply (Ty.path "&") [] [ T ] ],
                  "is_none",
                  []
                |),
                [
                  M.alloc (|
                    M.call_closure (|
                      M.get_trait_method (|
                        "core::iter::traits::iterator::Iterator",
                        Ty.apply
                          (Ty.path "alloc::collections::btree::set::Intersection")
                          []
                          [ T; A ],
                        [],
                        "next",
                        []
                      |),
                      [
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply
                                (Ty.path "alloc::collections::btree::set::BTreeSet")
                                []
                                [ T; A ],
                              "intersection",
                              []
                            |),
                            [ M.read (| self |); M.read (| other |) ]
                          |)
                        |)
                      ]
                    |)
                  |)
                ]
              |)))
          | _, _, _ => M.impossible
          end.
        
        Axiom AssociatedFunction_is_disjoint :
          forall (T A : Ty.t),
          M.IsAssociatedFunction (Self T A) "is_disjoint" (is_disjoint T A).
        
        (*
            pub fn is_subset(&self, other: &BTreeSet<T, A>) -> bool
            where
                T: Ord,
            {
                // Same result as self.difference(other).next().is_none()
                // but the code below is faster (hugely in some cases).
                if self.len() > other.len() {
                    return false;
                }
                let (self_min, self_max) =
                    if let (Some(self_min), Some(self_max)) = (self.first(), self.last()) {
                        (self_min, self_max)
                    } else {
                        return true; // self is empty
                    };
                let (other_min, other_max) =
                    if let (Some(other_min), Some(other_max)) = (other.first(), other.last()) {
                        (other_min, other_max)
                    } else {
                        return false; // other is empty
                    };
                let mut self_iter = self.iter();
                match self_min.cmp(other_min) {
                    Less => return false,
                    Equal => {
                        self_iter.next();
                    }
                    Greater => (),
                }
                match self_max.cmp(other_max) {
                    Greater => return false,
                    Equal => {
                        self_iter.next_back();
                    }
                    Less => (),
                }
                if self_iter.len() <= other.len() / ITER_PERFORMANCE_TIPPING_SIZE_DIFF {
                    for next in self_iter {
                        if !other.contains(next) {
                            return false;
                        }
                    }
                } else {
                    let mut other_iter = other.iter();
                    other_iter.next();
                    other_iter.next_back();
                    let mut self_next = self_iter.next();
                    while let Some(self1) = self_next {
                        match other_iter.next().map_or(Less, |other1| self1.cmp(other1)) {
                            Less => return false,
                            Equal => self_next = self_iter.next(),
                            Greater => (),
                        }
                    }
                }
                true
            }
        *)
        Definition is_subset
            (T A : Ty.t)
            (ε : list Value.t)
            (τ : list Ty.t)
            (α : list Value.t)
            : M :=
          let Self : Ty.t := Self T A in
          match ε, τ, α with
          | [], [], [ self; other ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let other := M.alloc (| other |) in
              M.catch_return (|
                ltac:(M.monadic
                  (M.read (|
                    let~ _ :=
                      M.match_operator (|
                        M.alloc (| Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.use
                                  (M.alloc (|
                                    BinOp.Pure.gt
                                      (M.call_closure (|
                                        M.get_associated_function (|
                                          Ty.apply
                                            (Ty.path "alloc::collections::btree::set::BTreeSet")
                                            []
                                            [ T; A ],
                                          "len",
                                          []
                                        |),
                                        [ M.read (| self |) ]
                                      |))
                                      (M.call_closure (|
                                        M.get_associated_function (|
                                          Ty.apply
                                            (Ty.path "alloc::collections::btree::set::BTreeSet")
                                            []
                                            [ T; A ],
                                          "len",
                                          []
                                        |),
                                        [ M.read (| other |) ]
                                      |))
                                  |)) in
                              let _ :=
                                M.is_constant_or_break_match (|
                                  M.read (| γ |),
                                  Value.Bool true
                                |) in
                              M.alloc (|
                                M.never_to_any (| M.read (| M.return_ (| Value.Bool false |) |) |)
                              |)));
                          fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                        ]
                      |) in
                    M.match_operator (|
                      M.match_operator (|
                        M.alloc (| Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.alloc (|
                                  Value.Tuple
                                    [
                                      M.call_closure (|
                                        M.get_associated_function (|
                                          Ty.apply
                                            (Ty.path "alloc::collections::btree::set::BTreeSet")
                                            []
                                            [ T; A ],
                                          "first",
                                          []
                                        |),
                                        [ M.read (| self |) ]
                                      |);
                                      M.call_closure (|
                                        M.get_associated_function (|
                                          Ty.apply
                                            (Ty.path "alloc::collections::btree::set::BTreeSet")
                                            []
                                            [ T; A ],
                                          "last",
                                          []
                                        |),
                                        [ M.read (| self |) ]
                                      |)
                                    ]
                                |) in
                              let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                              let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                              let γ1_0 :=
                                M.SubPointer.get_struct_tuple_field (|
                                  γ0_0,
                                  "core::option::Option::Some",
                                  0
                                |) in
                              let self_min := M.copy (| γ1_0 |) in
                              let γ1_0 :=
                                M.SubPointer.get_struct_tuple_field (|
                                  γ0_1,
                                  "core::option::Option::Some",
                                  0
                                |) in
                              let self_max := M.copy (| γ1_0 |) in
                              M.alloc (|
                                Value.Tuple [ M.read (| self_min |); M.read (| self_max |) ]
                              |)));
                          fun γ =>
                            ltac:(M.monadic
                              (M.alloc (|
                                M.never_to_any (| M.read (| M.return_ (| Value.Bool true |) |) |)
                              |)))
                        ]
                      |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                            let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                            let self_min := M.copy (| γ0_0 |) in
                            let self_max := M.copy (| γ0_1 |) in
                            M.match_operator (|
                              M.match_operator (|
                                M.alloc (| Value.Tuple [] |),
                                [
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let γ :=
                                        M.alloc (|
                                          Value.Tuple
                                            [
                                              M.call_closure (|
                                                M.get_associated_function (|
                                                  Ty.apply
                                                    (Ty.path
                                                      "alloc::collections::btree::set::BTreeSet")
                                                    []
                                                    [ T; A ],
                                                  "first",
                                                  []
                                                |),
                                                [ M.read (| other |) ]
                                              |);
                                              M.call_closure (|
                                                M.get_associated_function (|
                                                  Ty.apply
                                                    (Ty.path
                                                      "alloc::collections::btree::set::BTreeSet")
                                                    []
                                                    [ T; A ],
                                                  "last",
                                                  []
                                                |),
                                                [ M.read (| other |) ]
                                              |)
                                            ]
                                        |) in
                                      let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                      let γ1_0 :=
                                        M.SubPointer.get_struct_tuple_field (|
                                          γ0_0,
                                          "core::option::Option::Some",
                                          0
                                        |) in
                                      let other_min := M.copy (| γ1_0 |) in
                                      let γ1_0 :=
                                        M.SubPointer.get_struct_tuple_field (|
                                          γ0_1,
                                          "core::option::Option::Some",
                                          0
                                        |) in
                                      let other_max := M.copy (| γ1_0 |) in
                                      M.alloc (|
                                        Value.Tuple
                                          [ M.read (| other_min |); M.read (| other_max |) ]
                                      |)));
                                  fun γ =>
                                    ltac:(M.monadic
                                      (M.alloc (|
                                        M.never_to_any (|
                                          M.read (| M.return_ (| Value.Bool false |) |)
                                        |)
                                      |)))
                                ]
                              |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                    let other_min := M.copy (| γ0_0 |) in
                                    let other_max := M.copy (| γ0_1 |) in
                                    let~ self_iter :=
                                      M.alloc (|
                                        M.call_closure (|
                                          M.get_associated_function (|
                                            Ty.apply
                                              (Ty.path "alloc::collections::btree::set::BTreeSet")
                                              []
                                              [ T; A ],
                                            "iter",
                                            []
                                          |),
                                          [ M.read (| self |) ]
                                        |)
                                      |) in
                                    let~ _ :=
                                      M.match_operator (|
                                        M.alloc (|
                                          M.call_closure (|
                                            M.get_trait_method (|
                                              "core::cmp::Ord",
                                              T,
                                              [],
                                              "cmp",
                                              []
                                            |),
                                            [ M.read (| self_min |); M.read (| other_min |) ]
                                          |)
                                        |),
                                        [
                                          fun γ =>
                                            ltac:(M.monadic
                                              (let _ :=
                                                M.is_struct_tuple (|
                                                  γ,
                                                  "core::cmp::Ordering::Less"
                                                |) in
                                              M.alloc (|
                                                M.never_to_any (|
                                                  M.read (| M.return_ (| Value.Bool false |) |)
                                                |)
                                              |)));
                                          fun γ =>
                                            ltac:(M.monadic
                                              (let _ :=
                                                M.is_struct_tuple (|
                                                  γ,
                                                  "core::cmp::Ordering::Equal"
                                                |) in
                                              let~ _ :=
                                                M.alloc (|
                                                  M.call_closure (|
                                                    M.get_trait_method (|
                                                      "core::iter::traits::iterator::Iterator",
                                                      Ty.apply
                                                        (Ty.path
                                                          "alloc::collections::btree::set::Iter")
                                                        []
                                                        [ T ],
                                                      [],
                                                      "next",
                                                      []
                                                    |),
                                                    [ self_iter ]
                                                  |)
                                                |) in
                                              M.alloc (| Value.Tuple [] |)));
                                          fun γ =>
                                            ltac:(M.monadic
                                              (let _ :=
                                                M.is_struct_tuple (|
                                                  γ,
                                                  "core::cmp::Ordering::Greater"
                                                |) in
                                              M.alloc (| Value.Tuple [] |)))
                                        ]
                                      |) in
                                    let~ _ :=
                                      M.match_operator (|
                                        M.alloc (|
                                          M.call_closure (|
                                            M.get_trait_method (|
                                              "core::cmp::Ord",
                                              T,
                                              [],
                                              "cmp",
                                              []
                                            |),
                                            [ M.read (| self_max |); M.read (| other_max |) ]
                                          |)
                                        |),
                                        [
                                          fun γ =>
                                            ltac:(M.monadic
                                              (let _ :=
                                                M.is_struct_tuple (|
                                                  γ,
                                                  "core::cmp::Ordering::Greater"
                                                |) in
                                              M.alloc (|
                                                M.never_to_any (|
                                                  M.read (| M.return_ (| Value.Bool false |) |)
                                                |)
                                              |)));
                                          fun γ =>
                                            ltac:(M.monadic
                                              (let _ :=
                                                M.is_struct_tuple (|
                                                  γ,
                                                  "core::cmp::Ordering::Equal"
                                                |) in
                                              let~ _ :=
                                                M.alloc (|
                                                  M.call_closure (|
                                                    M.get_trait_method (|
                                                      "core::iter::traits::double_ended::DoubleEndedIterator",
                                                      Ty.apply
                                                        (Ty.path
                                                          "alloc::collections::btree::set::Iter")
                                                        []
                                                        [ T ],
                                                      [],
                                                      "next_back",
                                                      []
                                                    |),
                                                    [ self_iter ]
                                                  |)
                                                |) in
                                              M.alloc (| Value.Tuple [] |)));
                                          fun γ =>
                                            ltac:(M.monadic
                                              (let _ :=
                                                M.is_struct_tuple (|
                                                  γ,
                                                  "core::cmp::Ordering::Less"
                                                |) in
                                              M.alloc (| Value.Tuple [] |)))
                                        ]
                                      |) in
                                    let~ _ :=
                                      M.match_operator (|
                                        M.alloc (| Value.Tuple [] |),
                                        [
                                          fun γ =>
                                            ltac:(M.monadic
                                              (let γ :=
                                                M.use
                                                  (M.alloc (|
                                                    BinOp.Pure.le
                                                      (M.call_closure (|
                                                        M.get_trait_method (|
                                                          "core::iter::traits::exact_size::ExactSizeIterator",
                                                          Ty.apply
                                                            (Ty.path
                                                              "alloc::collections::btree::set::Iter")
                                                            []
                                                            [ T ],
                                                          [],
                                                          "len",
                                                          []
                                                        |),
                                                        [ self_iter ]
                                                      |))
                                                      (BinOp.Wrap.div
                                                        Integer.Usize
                                                        (M.call_closure (|
                                                          M.get_associated_function (|
                                                            Ty.apply
                                                              (Ty.path
                                                                "alloc::collections::btree::set::BTreeSet")
                                                              []
                                                              [ T; A ],
                                                            "len",
                                                            []
                                                          |),
                                                          [ M.read (| other |) ]
                                                        |))
                                                        (M.read (|
                                                          M.get_constant (|
                                                            "alloc::collections::btree::set::ITER_PERFORMANCE_TIPPING_SIZE_DIFF"
                                                          |)
                                                        |)))
                                                  |)) in
                                              let _ :=
                                                M.is_constant_or_break_match (|
                                                  M.read (| γ |),
                                                  Value.Bool true
                                                |) in
                                              M.use
                                                (M.match_operator (|
                                                  M.alloc (|
                                                    M.call_closure (|
                                                      M.get_trait_method (|
                                                        "core::iter::traits::collect::IntoIterator",
                                                        Ty.apply
                                                          (Ty.path
                                                            "alloc::collections::btree::set::Iter")
                                                          []
                                                          [ T ],
                                                        [],
                                                        "into_iter",
                                                        []
                                                      |),
                                                      [ M.read (| self_iter |) ]
                                                    |)
                                                  |),
                                                  [
                                                    fun γ =>
                                                      ltac:(M.monadic
                                                        (let iter := M.copy (| γ |) in
                                                        M.loop (|
                                                          ltac:(M.monadic
                                                            (let~ _ :=
                                                              M.match_operator (|
                                                                M.alloc (|
                                                                  M.call_closure (|
                                                                    M.get_trait_method (|
                                                                      "core::iter::traits::iterator::Iterator",
                                                                      Ty.apply
                                                                        (Ty.path
                                                                          "alloc::collections::btree::set::Iter")
                                                                        []
                                                                        [ T ],
                                                                      [],
                                                                      "next",
                                                                      []
                                                                    |),
                                                                    [ iter ]
                                                                  |)
                                                                |),
                                                                [
                                                                  fun γ =>
                                                                    ltac:(M.monadic
                                                                      (let _ :=
                                                                        M.is_struct_tuple (|
                                                                          γ,
                                                                          "core::option::Option::None"
                                                                        |) in
                                                                      M.alloc (|
                                                                        M.never_to_any (|
                                                                          M.read (| M.break (||) |)
                                                                        |)
                                                                      |)));
                                                                  fun γ =>
                                                                    ltac:(M.monadic
                                                                      (let γ0_0 :=
                                                                        M.SubPointer.get_struct_tuple_field (|
                                                                          γ,
                                                                          "core::option::Option::Some",
                                                                          0
                                                                        |) in
                                                                      let next :=
                                                                        M.copy (| γ0_0 |) in
                                                                      M.match_operator (|
                                                                        M.alloc (|
                                                                          Value.Tuple []
                                                                        |),
                                                                        [
                                                                          fun γ =>
                                                                            ltac:(M.monadic
                                                                              (let γ :=
                                                                                M.use
                                                                                  (M.alloc (|
                                                                                    UnOp.Pure.not
                                                                                      (M.call_closure (|
                                                                                        M.get_associated_function (|
                                                                                          Ty.apply
                                                                                            (Ty.path
                                                                                              "alloc::collections::btree::set::BTreeSet")
                                                                                            []
                                                                                            [ T; A
                                                                                            ],
                                                                                          "contains",
                                                                                          [ T ]
                                                                                        |),
                                                                                        [
                                                                                          M.read (|
                                                                                            other
                                                                                          |);
                                                                                          M.read (|
                                                                                            next
                                                                                          |)
                                                                                        ]
                                                                                      |))
                                                                                  |)) in
                                                                              let _ :=
                                                                                M.is_constant_or_break_match (|
                                                                                  M.read (| γ |),
                                                                                  Value.Bool true
                                                                                |) in
                                                                              M.alloc (|
                                                                                M.never_to_any (|
                                                                                  M.read (|
                                                                                    M.return_ (|
                                                                                      Value.Bool
                                                                                        false
                                                                                    |)
                                                                                  |)
                                                                                |)
                                                                              |)));
                                                                          fun γ =>
                                                                            ltac:(M.monadic
                                                                              (M.alloc (|
                                                                                Value.Tuple []
                                                                              |)))
                                                                        ]
                                                                      |)))
                                                                ]
                                                              |) in
                                                            M.alloc (| Value.Tuple [] |)))
                                                        |)))
                                                  ]
                                                |))));
                                          fun γ =>
                                            ltac:(M.monadic
                                              (let~ other_iter :=
                                                M.alloc (|
                                                  M.call_closure (|
                                                    M.get_associated_function (|
                                                      Ty.apply
                                                        (Ty.path
                                                          "alloc::collections::btree::set::BTreeSet")
                                                        []
                                                        [ T; A ],
                                                      "iter",
                                                      []
                                                    |),
                                                    [ M.read (| other |) ]
                                                  |)
                                                |) in
                                              let~ _ :=
                                                M.alloc (|
                                                  M.call_closure (|
                                                    M.get_trait_method (|
                                                      "core::iter::traits::iterator::Iterator",
                                                      Ty.apply
                                                        (Ty.path
                                                          "alloc::collections::btree::set::Iter")
                                                        []
                                                        [ T ],
                                                      [],
                                                      "next",
                                                      []
                                                    |),
                                                    [ other_iter ]
                                                  |)
                                                |) in
                                              let~ _ :=
                                                M.alloc (|
                                                  M.call_closure (|
                                                    M.get_trait_method (|
                                                      "core::iter::traits::double_ended::DoubleEndedIterator",
                                                      Ty.apply
                                                        (Ty.path
                                                          "alloc::collections::btree::set::Iter")
                                                        []
                                                        [ T ],
                                                      [],
                                                      "next_back",
                                                      []
                                                    |),
                                                    [ other_iter ]
                                                  |)
                                                |) in
                                              let~ self_next :=
                                                M.alloc (|
                                                  M.call_closure (|
                                                    M.get_trait_method (|
                                                      "core::iter::traits::iterator::Iterator",
                                                      Ty.apply
                                                        (Ty.path
                                                          "alloc::collections::btree::set::Iter")
                                                        []
                                                        [ T ],
                                                      [],
                                                      "next",
                                                      []
                                                    |),
                                                    [ self_iter ]
                                                  |)
                                                |) in
                                              M.loop (|
                                                ltac:(M.monadic
                                                  (M.match_operator (|
                                                    M.alloc (| Value.Tuple [] |),
                                                    [
                                                      fun γ =>
                                                        ltac:(M.monadic
                                                          (let γ := self_next in
                                                          let γ0_0 :=
                                                            M.SubPointer.get_struct_tuple_field (|
                                                              γ,
                                                              "core::option::Option::Some",
                                                              0
                                                            |) in
                                                          let self1 := M.copy (| γ0_0 |) in
                                                          M.match_operator (|
                                                            M.alloc (|
                                                              M.call_closure (|
                                                                M.get_associated_function (|
                                                                  Ty.apply
                                                                    (Ty.path "core::option::Option")
                                                                    []
                                                                    [
                                                                      Ty.apply
                                                                        (Ty.path "&")
                                                                        []
                                                                        [ T ]
                                                                    ],
                                                                  "map_or",
                                                                  [
                                                                    Ty.path "core::cmp::Ordering";
                                                                    Ty.function
                                                                      [
                                                                        Ty.tuple
                                                                          [
                                                                            Ty.apply
                                                                              (Ty.path "&")
                                                                              []
                                                                              [ T ]
                                                                          ]
                                                                      ]
                                                                      (Ty.path
                                                                        "core::cmp::Ordering")
                                                                  ]
                                                                |),
                                                                [
                                                                  M.call_closure (|
                                                                    M.get_trait_method (|
                                                                      "core::iter::traits::iterator::Iterator",
                                                                      Ty.apply
                                                                        (Ty.path
                                                                          "alloc::collections::btree::set::Iter")
                                                                        []
                                                                        [ T ],
                                                                      [],
                                                                      "next",
                                                                      []
                                                                    |),
                                                                    [ other_iter ]
                                                                  |);
                                                                  Value.StructTuple
                                                                    "core::cmp::Ordering::Less"
                                                                    [];
                                                                  M.closure
                                                                    (fun γ =>
                                                                      ltac:(M.monadic
                                                                        match γ with
                                                                        | [ α0 ] =>
                                                                          M.match_operator (|
                                                                            M.alloc (| α0 |),
                                                                            [
                                                                              fun γ =>
                                                                                ltac:(M.monadic
                                                                                  (let other1 :=
                                                                                    M.copy (|
                                                                                      γ
                                                                                    |) in
                                                                                  M.call_closure (|
                                                                                    M.get_trait_method (|
                                                                                      "core::cmp::Ord",
                                                                                      T,
                                                                                      [],
                                                                                      "cmp",
                                                                                      []
                                                                                    |),
                                                                                    [
                                                                                      M.read (|
                                                                                        self1
                                                                                      |);
                                                                                      M.read (|
                                                                                        other1
                                                                                      |)
                                                                                    ]
                                                                                  |)))
                                                                            ]
                                                                          |)
                                                                        | _ => M.impossible (||)
                                                                        end))
                                                                ]
                                                              |)
                                                            |),
                                                            [
                                                              fun γ =>
                                                                ltac:(M.monadic
                                                                  (let _ :=
                                                                    M.is_struct_tuple (|
                                                                      γ,
                                                                      "core::cmp::Ordering::Less"
                                                                    |) in
                                                                  M.alloc (|
                                                                    M.never_to_any (|
                                                                      M.read (|
                                                                        M.return_ (|
                                                                          Value.Bool false
                                                                        |)
                                                                      |)
                                                                    |)
                                                                  |)));
                                                              fun γ =>
                                                                ltac:(M.monadic
                                                                  (let _ :=
                                                                    M.is_struct_tuple (|
                                                                      γ,
                                                                      "core::cmp::Ordering::Equal"
                                                                    |) in
                                                                  M.write (|
                                                                    self_next,
                                                                    M.call_closure (|
                                                                      M.get_trait_method (|
                                                                        "core::iter::traits::iterator::Iterator",
                                                                        Ty.apply
                                                                          (Ty.path
                                                                            "alloc::collections::btree::set::Iter")
                                                                          []
                                                                          [ T ],
                                                                        [],
                                                                        "next",
                                                                        []
                                                                      |),
                                                                      [ self_iter ]
                                                                    |)
                                                                  |)));
                                                              fun γ =>
                                                                ltac:(M.monadic
                                                                  (let _ :=
                                                                    M.is_struct_tuple (|
                                                                      γ,
                                                                      "core::cmp::Ordering::Greater"
                                                                    |) in
                                                                  M.alloc (| Value.Tuple [] |)))
                                                            ]
                                                          |)));
                                                      fun γ =>
                                                        ltac:(M.monadic
                                                          (M.alloc (|
                                                            M.never_to_any (|
                                                              M.read (|
                                                                let~ _ :=
                                                                  M.alloc (|
                                                                    M.never_to_any (|
                                                                      M.read (| M.break (||) |)
                                                                    |)
                                                                  |) in
                                                                M.alloc (| Value.Tuple [] |)
                                                              |)
                                                            |)
                                                          |)))
                                                    ]
                                                  |)))
                                              |)))
                                        ]
                                      |) in
                                    M.alloc (| Value.Bool true |)))
                              ]
                            |)))
                      ]
                    |)
                  |)))
              |)))
          | _, _, _ => M.impossible
          end.
        
        Axiom AssociatedFunction_is_subset :
          forall (T A : Ty.t),
          M.IsAssociatedFunction (Self T A) "is_subset" (is_subset T A).
        
        (*
            pub fn is_superset(&self, other: &BTreeSet<T, A>) -> bool
            where
                T: Ord,
            {
                other.is_subset(self)
            }
        *)
        Definition is_superset
            (T A : Ty.t)
            (ε : list Value.t)
            (τ : list Ty.t)
            (α : list Value.t)
            : M :=
          let Self : Ty.t := Self T A in
          match ε, τ, α with
          | [], [], [ self; other ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let other := M.alloc (| other |) in
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply (Ty.path "alloc::collections::btree::set::BTreeSet") [] [ T; A ],
                  "is_subset",
                  []
                |),
                [ M.read (| other |); M.read (| self |) ]
              |)))
          | _, _, _ => M.impossible
          end.
        
        Axiom AssociatedFunction_is_superset :
          forall (T A : Ty.t),
          M.IsAssociatedFunction (Self T A) "is_superset" (is_superset T A).
        
        (*
            pub fn first(&self) -> Option<&T>
            where
                T: Ord,
            {
                self.map.first_key_value().map(|(k, _)| k)
            }
        *)
        Definition first (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self T A in
          match ε, τ, α with
          | [], [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "core::option::Option")
                    []
                    [
                      Ty.tuple
                        [
                          Ty.apply (Ty.path "&") [] [ T ];
                          Ty.apply
                            (Ty.path "&")
                            []
                            [ Ty.path "alloc::collections::btree::set_val::SetValZST" ]
                        ]
                    ],
                  "map",
                  [
                    Ty.apply (Ty.path "&") [] [ T ];
                    Ty.function
                      [
                        Ty.tuple
                          [
                            Ty.tuple
                              [
                                Ty.apply (Ty.path "&") [] [ T ];
                                Ty.apply
                                  (Ty.path "&")
                                  []
                                  [ Ty.path "alloc::collections::btree::set_val::SetValZST" ]
                              ]
                          ]
                      ]
                      (Ty.apply (Ty.path "&") [] [ T ])
                  ]
                |),
                [
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "alloc::collections::btree::map::BTreeMap")
                        []
                        [ T; Ty.path "alloc::collections::btree::set_val::SetValZST"; A ],
                      "first_key_value",
                      []
                    |),
                    [
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "alloc::collections::btree::set::BTreeSet",
                        "map"
                      |)
                    ]
                  |);
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0 ] =>
                          M.match_operator (|
                            M.alloc (| α0 |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                                  let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                  let k := M.copy (| γ0_0 |) in
                                  M.read (| k |)))
                            ]
                          |)
                        | _ => M.impossible (||)
                        end))
                ]
              |)))
          | _, _, _ => M.impossible
          end.
        
        Axiom AssociatedFunction_first :
          forall (T A : Ty.t),
          M.IsAssociatedFunction (Self T A) "first" (first T A).
        
        (*
            pub fn last(&self) -> Option<&T>
            where
                T: Ord,
            {
                self.map.last_key_value().map(|(k, _)| k)
            }
        *)
        Definition last (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self T A in
          match ε, τ, α with
          | [], [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "core::option::Option")
                    []
                    [
                      Ty.tuple
                        [
                          Ty.apply (Ty.path "&") [] [ T ];
                          Ty.apply
                            (Ty.path "&")
                            []
                            [ Ty.path "alloc::collections::btree::set_val::SetValZST" ]
                        ]
                    ],
                  "map",
                  [
                    Ty.apply (Ty.path "&") [] [ T ];
                    Ty.function
                      [
                        Ty.tuple
                          [
                            Ty.tuple
                              [
                                Ty.apply (Ty.path "&") [] [ T ];
                                Ty.apply
                                  (Ty.path "&")
                                  []
                                  [ Ty.path "alloc::collections::btree::set_val::SetValZST" ]
                              ]
                          ]
                      ]
                      (Ty.apply (Ty.path "&") [] [ T ])
                  ]
                |),
                [
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "alloc::collections::btree::map::BTreeMap")
                        []
                        [ T; Ty.path "alloc::collections::btree::set_val::SetValZST"; A ],
                      "last_key_value",
                      []
                    |),
                    [
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "alloc::collections::btree::set::BTreeSet",
                        "map"
                      |)
                    ]
                  |);
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0 ] =>
                          M.match_operator (|
                            M.alloc (| α0 |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                                  let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                  let k := M.copy (| γ0_0 |) in
                                  M.read (| k |)))
                            ]
                          |)
                        | _ => M.impossible (||)
                        end))
                ]
              |)))
          | _, _, _ => M.impossible
          end.
        
        Axiom AssociatedFunction_last :
          forall (T A : Ty.t),
          M.IsAssociatedFunction (Self T A) "last" (last T A).
        
        (*
            pub fn pop_first(&mut self) -> Option<T>
            where
                T: Ord,
            {
                self.map.pop_first().map(|kv| kv.0)
            }
        *)
        Definition pop_first
            (T A : Ty.t)
            (ε : list Value.t)
            (τ : list Ty.t)
            (α : list Value.t)
            : M :=
          let Self : Ty.t := Self T A in
          match ε, τ, α with
          | [], [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "core::option::Option")
                    []
                    [ Ty.tuple [ T; Ty.path "alloc::collections::btree::set_val::SetValZST" ] ],
                  "map",
                  [
                    T;
                    Ty.function
                      [
                        Ty.tuple
                          [ Ty.tuple [ T; Ty.path "alloc::collections::btree::set_val::SetValZST" ]
                          ]
                      ]
                      T
                  ]
                |),
                [
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "alloc::collections::btree::map::BTreeMap")
                        []
                        [ T; Ty.path "alloc::collections::btree::set_val::SetValZST"; A ],
                      "pop_first",
                      []
                    |),
                    [
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "alloc::collections::btree::set::BTreeSet",
                        "map"
                      |)
                    ]
                  |);
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0 ] =>
                          M.match_operator (|
                            M.alloc (| α0 |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let kv := M.copy (| γ |) in
                                  M.read (| M.SubPointer.get_tuple_field (| kv, 0 |) |)))
                            ]
                          |)
                        | _ => M.impossible (||)
                        end))
                ]
              |)))
          | _, _, _ => M.impossible
          end.
        
        Axiom AssociatedFunction_pop_first :
          forall (T A : Ty.t),
          M.IsAssociatedFunction (Self T A) "pop_first" (pop_first T A).
        
        (*
            pub fn pop_last(&mut self) -> Option<T>
            where
                T: Ord,
            {
                self.map.pop_last().map(|kv| kv.0)
            }
        *)
        Definition pop_last
            (T A : Ty.t)
            (ε : list Value.t)
            (τ : list Ty.t)
            (α : list Value.t)
            : M :=
          let Self : Ty.t := Self T A in
          match ε, τ, α with
          | [], [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "core::option::Option")
                    []
                    [ Ty.tuple [ T; Ty.path "alloc::collections::btree::set_val::SetValZST" ] ],
                  "map",
                  [
                    T;
                    Ty.function
                      [
                        Ty.tuple
                          [ Ty.tuple [ T; Ty.path "alloc::collections::btree::set_val::SetValZST" ]
                          ]
                      ]
                      T
                  ]
                |),
                [
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "alloc::collections::btree::map::BTreeMap")
                        []
                        [ T; Ty.path "alloc::collections::btree::set_val::SetValZST"; A ],
                      "pop_last",
                      []
                    |),
                    [
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "alloc::collections::btree::set::BTreeSet",
                        "map"
                      |)
                    ]
                  |);
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0 ] =>
                          M.match_operator (|
                            M.alloc (| α0 |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let kv := M.copy (| γ |) in
                                  M.read (| M.SubPointer.get_tuple_field (| kv, 0 |) |)))
                            ]
                          |)
                        | _ => M.impossible (||)
                        end))
                ]
              |)))
          | _, _, _ => M.impossible
          end.
        
        Axiom AssociatedFunction_pop_last :
          forall (T A : Ty.t),
          M.IsAssociatedFunction (Self T A) "pop_last" (pop_last T A).
        
        (*
            pub fn insert(&mut self, value: T) -> bool
            where
                T: Ord,
            {
                self.map.insert(value, SetValZST::default()).is_none()
            }
        *)
        Definition insert (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self T A in
          match ε, τ, α with
          | [], [], [ self; value ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let value := M.alloc (| value |) in
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "core::option::Option")
                    []
                    [ Ty.path "alloc::collections::btree::set_val::SetValZST" ],
                  "is_none",
                  []
                |),
                [
                  M.alloc (|
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "alloc::collections::btree::map::BTreeMap")
                          []
                          [ T; Ty.path "alloc::collections::btree::set_val::SetValZST"; A ],
                        "insert",
                        []
                      |),
                      [
                        M.SubPointer.get_struct_record_field (|
                          M.read (| self |),
                          "alloc::collections::btree::set::BTreeSet",
                          "map"
                        |);
                        M.read (| value |);
                        M.call_closure (|
                          M.get_trait_method (|
                            "core::default::Default",
                            Ty.path "alloc::collections::btree::set_val::SetValZST",
                            [],
                            "default",
                            []
                          |),
                          []
                        |)
                      ]
                    |)
                  |)
                ]
              |)))
          | _, _, _ => M.impossible
          end.
        
        Axiom AssociatedFunction_insert :
          forall (T A : Ty.t),
          M.IsAssociatedFunction (Self T A) "insert" (insert T A).
        
        (*
            pub fn replace(&mut self, value: T) -> Option<T>
            where
                T: Ord,
            {
                Recover::replace(&mut self.map, value)
            }
        *)
        Definition replace (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self T A in
          match ε, τ, α with
          | [], [], [ self; value ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let value := M.alloc (| value |) in
              M.call_closure (|
                M.get_trait_method (|
                  "alloc::collections::btree::Recover",
                  Ty.apply
                    (Ty.path "alloc::collections::btree::map::BTreeMap")
                    []
                    [ T; Ty.path "alloc::collections::btree::set_val::SetValZST"; A ],
                  [ T ],
                  "replace",
                  []
                |),
                [
                  M.SubPointer.get_struct_record_field (|
                    M.read (| self |),
                    "alloc::collections::btree::set::BTreeSet",
                    "map"
                  |);
                  M.read (| value |)
                ]
              |)))
          | _, _, _ => M.impossible
          end.
        
        Axiom AssociatedFunction_replace :
          forall (T A : Ty.t),
          M.IsAssociatedFunction (Self T A) "replace" (replace T A).
        
        (*
            pub fn remove<Q: ?Sized>(&mut self, value: &Q) -> bool
            where
                T: Borrow<Q> + Ord,
                Q: Ord,
            {
                self.map.remove(value).is_some()
            }
        *)
        Definition remove (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self T A in
          match ε, τ, α with
          | [], [ Q ], [ self; value ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let value := M.alloc (| value |) in
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "core::option::Option")
                    []
                    [ Ty.path "alloc::collections::btree::set_val::SetValZST" ],
                  "is_some",
                  []
                |),
                [
                  M.alloc (|
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "alloc::collections::btree::map::BTreeMap")
                          []
                          [ T; Ty.path "alloc::collections::btree::set_val::SetValZST"; A ],
                        "remove",
                        [ Q ]
                      |),
                      [
                        M.SubPointer.get_struct_record_field (|
                          M.read (| self |),
                          "alloc::collections::btree::set::BTreeSet",
                          "map"
                        |);
                        M.read (| value |)
                      ]
                    |)
                  |)
                ]
              |)))
          | _, _, _ => M.impossible
          end.
        
        Axiom AssociatedFunction_remove :
          forall (T A : Ty.t),
          M.IsAssociatedFunction (Self T A) "remove" (remove T A).
        
        (*
            pub fn take<Q: ?Sized>(&mut self, value: &Q) -> Option<T>
            where
                T: Borrow<Q> + Ord,
                Q: Ord,
            {
                Recover::take(&mut self.map, value)
            }
        *)
        Definition take (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self T A in
          match ε, τ, α with
          | [], [ Q ], [ self; value ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let value := M.alloc (| value |) in
              M.call_closure (|
                M.get_trait_method (|
                  "alloc::collections::btree::Recover",
                  Ty.apply
                    (Ty.path "alloc::collections::btree::map::BTreeMap")
                    []
                    [ T; Ty.path "alloc::collections::btree::set_val::SetValZST"; A ],
                  [ Q ],
                  "take",
                  []
                |),
                [
                  M.SubPointer.get_struct_record_field (|
                    M.read (| self |),
                    "alloc::collections::btree::set::BTreeSet",
                    "map"
                  |);
                  M.read (| value |)
                ]
              |)))
          | _, _, _ => M.impossible
          end.
        
        Axiom AssociatedFunction_take :
          forall (T A : Ty.t),
          M.IsAssociatedFunction (Self T A) "take" (take T A).
        
        (*
            pub fn retain<F>(&mut self, mut f: F)
            where
                T: Ord,
                F: FnMut(&T) -> bool,
            {
                self.extract_if(|v| !f(v)).for_each(drop);
            }
        *)
        Definition retain (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self T A in
          match ε, τ, α with
          | [], [ F ], [ self; f ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let f := M.alloc (| f |) in
              M.read (|
                let~ _ :=
                  M.alloc (|
                    M.call_closure (|
                      M.get_trait_method (|
                        "core::iter::traits::iterator::Iterator",
                        Ty.apply
                          (Ty.path "alloc::collections::btree::set::ExtractIf")
                          []
                          [
                            T;
                            Ty.function
                              [ Ty.tuple [ Ty.apply (Ty.path "&") [] [ T ] ] ]
                              (Ty.path "bool");
                            A
                          ],
                        [],
                        "for_each",
                        [ Ty.function [ T ] (Ty.tuple []) ]
                      |),
                      [
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.apply
                              (Ty.path "alloc::collections::btree::set::BTreeSet")
                              []
                              [ T; A ],
                            "extract_if",
                            [
                              Ty.function
                                [ Ty.tuple [ Ty.apply (Ty.path "&") [] [ T ] ] ]
                                (Ty.path "bool")
                            ]
                          |),
                          [
                            M.read (| self |);
                            M.closure
                              (fun γ =>
                                ltac:(M.monadic
                                  match γ with
                                  | [ α0 ] =>
                                    M.match_operator (|
                                      M.alloc (| α0 |),
                                      [
                                        fun γ =>
                                          ltac:(M.monadic
                                            (let v := M.copy (| γ |) in
                                            UnOp.Pure.not
                                              (M.call_closure (|
                                                M.get_trait_method (|
                                                  "core::ops::function::FnMut",
                                                  F,
                                                  [ Ty.tuple [ Ty.apply (Ty.path "&") [] [ T ] ] ],
                                                  "call_mut",
                                                  []
                                                |),
                                                [ f; Value.Tuple [ M.read (| v |) ] ]
                                              |))))
                                      ]
                                    |)
                                  | _ => M.impossible (||)
                                  end))
                          ]
                        |);
                        M.get_function (| "core::mem::drop", [ T ] |)
                      ]
                    |)
                  |) in
                M.alloc (| Value.Tuple [] |)
              |)))
          | _, _, _ => M.impossible
          end.
        
        Axiom AssociatedFunction_retain :
          forall (T A : Ty.t),
          M.IsAssociatedFunction (Self T A) "retain" (retain T A).
        
        (*
            pub fn append(&mut self, other: &mut Self)
            where
                T: Ord,
                A: Clone,
            {
                self.map.append(&mut other.map);
            }
        *)
        Definition append (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self T A in
          match ε, τ, α with
          | [], [], [ self; other ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let other := M.alloc (| other |) in
              M.read (|
                let~ _ :=
                  M.alloc (|
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "alloc::collections::btree::map::BTreeMap")
                          []
                          [ T; Ty.path "alloc::collections::btree::set_val::SetValZST"; A ],
                        "append",
                        []
                      |),
                      [
                        M.SubPointer.get_struct_record_field (|
                          M.read (| self |),
                          "alloc::collections::btree::set::BTreeSet",
                          "map"
                        |);
                        M.SubPointer.get_struct_record_field (|
                          M.read (| other |),
                          "alloc::collections::btree::set::BTreeSet",
                          "map"
                        |)
                      ]
                    |)
                  |) in
                M.alloc (| Value.Tuple [] |)
              |)))
          | _, _, _ => M.impossible
          end.
        
        Axiom AssociatedFunction_append :
          forall (T A : Ty.t),
          M.IsAssociatedFunction (Self T A) "append" (append T A).
        
        (*
            pub fn split_off<Q: ?Sized + Ord>(&mut self, value: &Q) -> Self
            where
                T: Borrow<Q> + Ord,
                A: Clone,
            {
                BTreeSet { map: self.map.split_off(value) }
            }
        *)
        Definition split_off
            (T A : Ty.t)
            (ε : list Value.t)
            (τ : list Ty.t)
            (α : list Value.t)
            : M :=
          let Self : Ty.t := Self T A in
          match ε, τ, α with
          | [], [ Q ], [ self; value ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let value := M.alloc (| value |) in
              Value.StructRecord
                "alloc::collections::btree::set::BTreeSet"
                [
                  ("map",
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "alloc::collections::btree::map::BTreeMap")
                          []
                          [ T; Ty.path "alloc::collections::btree::set_val::SetValZST"; A ],
                        "split_off",
                        [ Q ]
                      |),
                      [
                        M.SubPointer.get_struct_record_field (|
                          M.read (| self |),
                          "alloc::collections::btree::set::BTreeSet",
                          "map"
                        |);
                        M.read (| value |)
                      ]
                    |))
                ]))
          | _, _, _ => M.impossible
          end.
        
        Axiom AssociatedFunction_split_off :
          forall (T A : Ty.t),
          M.IsAssociatedFunction (Self T A) "split_off" (split_off T A).
        
        (*
            pub fn extract_if<'a, F>(&'a mut self, pred: F) -> ExtractIf<'a, T, F, A>
            where
                T: Ord,
                F: 'a + FnMut(&T) -> bool,
            {
                let (inner, alloc) = self.map.extract_if_inner();
                ExtractIf { pred, inner, alloc }
            }
        *)
        Definition extract_if
            (T A : Ty.t)
            (ε : list Value.t)
            (τ : list Ty.t)
            (α : list Value.t)
            : M :=
          let Self : Ty.t := Self T A in
          match ε, τ, α with
          | [], [ F ], [ self; pred ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let pred := M.alloc (| pred |) in
              M.read (|
                M.match_operator (|
                  M.alloc (|
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "alloc::collections::btree::map::BTreeMap")
                          []
                          [ T; Ty.path "alloc::collections::btree::set_val::SetValZST"; A ],
                        "extract_if_inner",
                        []
                      |),
                      [
                        M.SubPointer.get_struct_record_field (|
                          M.read (| self |),
                          "alloc::collections::btree::set::BTreeSet",
                          "map"
                        |)
                      ]
                    |)
                  |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                        let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                        let inner := M.copy (| γ0_0 |) in
                        let alloc := M.copy (| γ0_1 |) in
                        M.alloc (|
                          Value.StructRecord
                            "alloc::collections::btree::set::ExtractIf"
                            [
                              ("pred", M.read (| pred |));
                              ("inner", M.read (| inner |));
                              ("alloc", M.read (| alloc |))
                            ]
                        |)))
                  ]
                |)
              |)))
          | _, _, _ => M.impossible
          end.
        
        Axiom AssociatedFunction_extract_if :
          forall (T A : Ty.t),
          M.IsAssociatedFunction (Self T A) "extract_if" (extract_if T A).
        
        (*
            pub fn iter(&self) -> Iter<'_, T> {
                Iter { iter: self.map.keys() }
            }
        *)
        Definition iter (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self T A in
          match ε, τ, α with
          | [], [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              Value.StructRecord
                "alloc::collections::btree::set::Iter"
                [
                  ("iter",
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "alloc::collections::btree::map::BTreeMap")
                          []
                          [ T; Ty.path "alloc::collections::btree::set_val::SetValZST"; A ],
                        "keys",
                        []
                      |),
                      [
                        M.SubPointer.get_struct_record_field (|
                          M.read (| self |),
                          "alloc::collections::btree::set::BTreeSet",
                          "map"
                        |)
                      ]
                    |))
                ]))
          | _, _, _ => M.impossible
          end.
        
        Axiom AssociatedFunction_iter :
          forall (T A : Ty.t),
          M.IsAssociatedFunction (Self T A) "iter" (iter T A).
        
        (*
            pub const fn len(&self) -> usize {
                self.map.len()
            }
        *)
        Definition len (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self T A in
          match ε, τ, α with
          | [], [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "alloc::collections::btree::map::BTreeMap")
                    []
                    [ T; Ty.path "alloc::collections::btree::set_val::SetValZST"; A ],
                  "len",
                  []
                |),
                [
                  M.SubPointer.get_struct_record_field (|
                    M.read (| self |),
                    "alloc::collections::btree::set::BTreeSet",
                    "map"
                  |)
                ]
              |)))
          | _, _, _ => M.impossible
          end.
        
        Axiom AssociatedFunction_len :
          forall (T A : Ty.t),
          M.IsAssociatedFunction (Self T A) "len" (len T A).
        
        (*
            pub const fn is_empty(&self) -> bool {
                self.len() == 0
            }
        *)
        Definition is_empty
            (T A : Ty.t)
            (ε : list Value.t)
            (τ : list Ty.t)
            (α : list Value.t)
            : M :=
          let Self : Ty.t := Self T A in
          match ε, τ, α with
          | [], [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              BinOp.Pure.eq
                (M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "alloc::collections::btree::set::BTreeSet") [] [ T; A ],
                    "len",
                    []
                  |),
                  [ M.read (| self |) ]
                |))
                (Value.Integer 0)))
          | _, _, _ => M.impossible
          end.
        
        Axiom AssociatedFunction_is_empty :
          forall (T A : Ty.t),
          M.IsAssociatedFunction (Self T A) "is_empty" (is_empty T A).
        
        (*
            pub fn lower_bound<Q: ?Sized>(&self, bound: Bound<&Q>) -> Cursor<'_, T>
            where
                T: Borrow<Q> + Ord,
                Q: Ord,
            {
                Cursor { inner: self.map.lower_bound(bound) }
            }
        *)
        Definition lower_bound
            (T A : Ty.t)
            (ε : list Value.t)
            (τ : list Ty.t)
            (α : list Value.t)
            : M :=
          let Self : Ty.t := Self T A in
          match ε, τ, α with
          | [], [ Q ], [ self; bound ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let bound := M.alloc (| bound |) in
              Value.StructRecord
                "alloc::collections::btree::set::Cursor"
                [
                  ("inner",
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "alloc::collections::btree::map::BTreeMap")
                          []
                          [ T; Ty.path "alloc::collections::btree::set_val::SetValZST"; A ],
                        "lower_bound",
                        [ Q ]
                      |),
                      [
                        M.SubPointer.get_struct_record_field (|
                          M.read (| self |),
                          "alloc::collections::btree::set::BTreeSet",
                          "map"
                        |);
                        M.read (| bound |)
                      ]
                    |))
                ]))
          | _, _, _ => M.impossible
          end.
        
        Axiom AssociatedFunction_lower_bound :
          forall (T A : Ty.t),
          M.IsAssociatedFunction (Self T A) "lower_bound" (lower_bound T A).
        
        (*
            pub fn lower_bound_mut<Q: ?Sized>(&mut self, bound: Bound<&Q>) -> CursorMut<'_, T, A>
            where
                T: Borrow<Q> + Ord,
                Q: Ord,
            {
                CursorMut { inner: self.map.lower_bound_mut(bound) }
            }
        *)
        Definition lower_bound_mut
            (T A : Ty.t)
            (ε : list Value.t)
            (τ : list Ty.t)
            (α : list Value.t)
            : M :=
          let Self : Ty.t := Self T A in
          match ε, τ, α with
          | [], [ Q ], [ self; bound ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let bound := M.alloc (| bound |) in
              Value.StructRecord
                "alloc::collections::btree::set::CursorMut"
                [
                  ("inner",
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "alloc::collections::btree::map::BTreeMap")
                          []
                          [ T; Ty.path "alloc::collections::btree::set_val::SetValZST"; A ],
                        "lower_bound_mut",
                        [ Q ]
                      |),
                      [
                        M.SubPointer.get_struct_record_field (|
                          M.read (| self |),
                          "alloc::collections::btree::set::BTreeSet",
                          "map"
                        |);
                        M.read (| bound |)
                      ]
                    |))
                ]))
          | _, _, _ => M.impossible
          end.
        
        Axiom AssociatedFunction_lower_bound_mut :
          forall (T A : Ty.t),
          M.IsAssociatedFunction (Self T A) "lower_bound_mut" (lower_bound_mut T A).
        
        (*
            pub fn upper_bound<Q: ?Sized>(&self, bound: Bound<&Q>) -> Cursor<'_, T>
            where
                T: Borrow<Q> + Ord,
                Q: Ord,
            {
                Cursor { inner: self.map.upper_bound(bound) }
            }
        *)
        Definition upper_bound
            (T A : Ty.t)
            (ε : list Value.t)
            (τ : list Ty.t)
            (α : list Value.t)
            : M :=
          let Self : Ty.t := Self T A in
          match ε, τ, α with
          | [], [ Q ], [ self; bound ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let bound := M.alloc (| bound |) in
              Value.StructRecord
                "alloc::collections::btree::set::Cursor"
                [
                  ("inner",
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "alloc::collections::btree::map::BTreeMap")
                          []
                          [ T; Ty.path "alloc::collections::btree::set_val::SetValZST"; A ],
                        "upper_bound",
                        [ Q ]
                      |),
                      [
                        M.SubPointer.get_struct_record_field (|
                          M.read (| self |),
                          "alloc::collections::btree::set::BTreeSet",
                          "map"
                        |);
                        M.read (| bound |)
                      ]
                    |))
                ]))
          | _, _, _ => M.impossible
          end.
        
        Axiom AssociatedFunction_upper_bound :
          forall (T A : Ty.t),
          M.IsAssociatedFunction (Self T A) "upper_bound" (upper_bound T A).
        
        (*
            pub unsafe fn upper_bound_mut<Q: ?Sized>(&mut self, bound: Bound<&Q>) -> CursorMut<'_, T, A>
            where
                T: Borrow<Q> + Ord,
                Q: Ord,
            {
                CursorMut { inner: self.map.upper_bound_mut(bound) }
            }
        *)
        Definition upper_bound_mut
            (T A : Ty.t)
            (ε : list Value.t)
            (τ : list Ty.t)
            (α : list Value.t)
            : M :=
          let Self : Ty.t := Self T A in
          match ε, τ, α with
          | [], [ Q ], [ self; bound ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let bound := M.alloc (| bound |) in
              Value.StructRecord
                "alloc::collections::btree::set::CursorMut"
                [
                  ("inner",
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "alloc::collections::btree::map::BTreeMap")
                          []
                          [ T; Ty.path "alloc::collections::btree::set_val::SetValZST"; A ],
                        "upper_bound_mut",
                        [ Q ]
                      |),
                      [
                        M.SubPointer.get_struct_record_field (|
                          M.read (| self |),
                          "alloc::collections::btree::set::BTreeSet",
                          "map"
                        |);
                        M.read (| bound |)
                      ]
                    |))
                ]))
          | _, _, _ => M.impossible
          end.
        
        Axiom AssociatedFunction_upper_bound_mut :
          forall (T A : Ty.t),
          M.IsAssociatedFunction (Self T A) "upper_bound_mut" (upper_bound_mut T A).
        (*
            fn from_sorted_iter<I: Iterator<Item = T>>(iter: I, alloc: A) -> BTreeSet<T, A> {
                let iter = iter.map(|k| (k, SetValZST::default()));
                let map = BTreeMap::bulk_build_from_sorted_iter(iter, alloc);
                BTreeSet { map }
            }
        *)
        Definition from_sorted_iter
            (T A : Ty.t)
            (ε : list Value.t)
            (τ : list Ty.t)
            (α : list Value.t)
            : M :=
          let Self : Ty.t := Self T A in
          match ε, τ, α with
          | [], [ _ as I ], [ iter; alloc ] =>
            ltac:(M.monadic
              (let iter := M.alloc (| iter |) in
              let alloc := M.alloc (| alloc |) in
              M.read (|
                let~ iter :=
                  M.alloc (|
                    M.call_closure (|
                      M.get_trait_method (|
                        "core::iter::traits::iterator::Iterator",
                        I,
                        [],
                        "map",
                        [
                          Ty.tuple [ T; Ty.path "alloc::collections::btree::set_val::SetValZST" ];
                          Ty.function
                            [ Ty.tuple [ T ] ]
                            (Ty.tuple
                              [ T; Ty.path "alloc::collections::btree::set_val::SetValZST" ])
                        ]
                      |),
                      [
                        M.read (| iter |);
                        M.closure
                          (fun γ =>
                            ltac:(M.monadic
                              match γ with
                              | [ α0 ] =>
                                M.match_operator (|
                                  M.alloc (| α0 |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let k := M.copy (| γ |) in
                                        Value.Tuple
                                          [
                                            M.read (| k |);
                                            M.call_closure (|
                                              M.get_trait_method (|
                                                "core::default::Default",
                                                Ty.path
                                                  "alloc::collections::btree::set_val::SetValZST",
                                                [],
                                                "default",
                                                []
                                              |),
                                              []
                                            |)
                                          ]))
                                  ]
                                |)
                              | _ => M.impossible (||)
                              end))
                      ]
                    |)
                  |) in
                let~ map :=
                  M.alloc (|
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "alloc::collections::btree::map::BTreeMap")
                          []
                          [ T; Ty.path "alloc::collections::btree::set_val::SetValZST"; A ],
                        "bulk_build_from_sorted_iter",
                        [
                          Ty.apply
                            (Ty.path "core::iter::adapters::map::Map")
                            []
                            [
                              I;
                              Ty.function
                                [ Ty.tuple [ T ] ]
                                (Ty.tuple
                                  [ T; Ty.path "alloc::collections::btree::set_val::SetValZST" ])
                            ]
                        ]
                      |),
                      [ M.read (| iter |); M.read (| alloc |) ]
                    |)
                  |) in
                M.alloc (|
                  Value.StructRecord
                    "alloc::collections::btree::set::BTreeSet"
                    [ ("map", M.read (| map |)) ]
                |)
              |)))
          | _, _, _ => M.impossible
          end.
        
        Axiom AssociatedFunction_from_sorted_iter :
          forall (T A : Ty.t),
          M.IsAssociatedFunction (Self T A) "from_sorted_iter" (from_sorted_iter T A).
      End Impl_alloc_collections_btree_set_BTreeSet_T_A.
      
      Module Impl_core_iter_traits_collect_FromIterator_where_core_cmp_Ord_T_T_for_alloc_collections_btree_set_BTreeSet_T_alloc_alloc_Global.
        Definition Self (T : Ty.t) : Ty.t :=
          Ty.apply
            (Ty.path "alloc::collections::btree::set::BTreeSet")
            []
            [ T; Ty.path "alloc::alloc::Global" ].
        
        (*
            fn from_iter<I: IntoIterator<Item = T>>(iter: I) -> BTreeSet<T> {
                let mut inputs: Vec<_> = iter.into_iter().collect();
        
                if inputs.is_empty() {
                    return BTreeSet::new();
                }
        
                // use stable sort to preserve the insertion order.
                inputs.sort();
                BTreeSet::from_sorted_iter(inputs.into_iter(), Global)
            }
        *)
        Definition from_iter (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self T in
          match ε, τ, α with
          | [], [ _ as I ], [ iter ] =>
            ltac:(M.monadic
              (let iter := M.alloc (| iter |) in
              M.catch_return (|
                ltac:(M.monadic
                  (M.read (|
                    let~ inputs :=
                      M.alloc (|
                        M.call_closure (|
                          M.get_trait_method (|
                            "core::iter::traits::iterator::Iterator",
                            Ty.associated,
                            [],
                            "collect",
                            [
                              Ty.apply
                                (Ty.path "alloc::vec::Vec")
                                []
                                [ T; Ty.path "alloc::alloc::Global" ]
                            ]
                          |),
                          [
                            M.call_closure (|
                              M.get_trait_method (|
                                "core::iter::traits::collect::IntoIterator",
                                I,
                                [],
                                "into_iter",
                                []
                              |),
                              [ M.read (| iter |) ]
                            |)
                          ]
                        |)
                      |) in
                    let~ _ :=
                      M.match_operator (|
                        M.alloc (| Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.use
                                  (M.alloc (|
                                    M.call_closure (|
                                      M.get_associated_function (|
                                        Ty.apply
                                          (Ty.path "alloc::vec::Vec")
                                          []
                                          [ T; Ty.path "alloc::alloc::Global" ],
                                        "is_empty",
                                        []
                                      |),
                                      [ inputs ]
                                    |)
                                  |)) in
                              let _ :=
                                M.is_constant_or_break_match (|
                                  M.read (| γ |),
                                  Value.Bool true
                                |) in
                              M.alloc (|
                                M.never_to_any (|
                                  M.read (|
                                    M.return_ (|
                                      M.call_closure (|
                                        M.get_associated_function (|
                                          Ty.apply
                                            (Ty.path "alloc::collections::btree::set::BTreeSet")
                                            []
                                            [ T; Ty.path "alloc::alloc::Global" ],
                                          "new",
                                          []
                                        |),
                                        []
                                      |)
                                    |)
                                  |)
                                |)
                              |)));
                          fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                        ]
                      |) in
                    let~ _ :=
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.apply (Ty.path "slice") [] [ T ],
                            "sort",
                            []
                          |),
                          [
                            M.call_closure (|
                              M.get_trait_method (|
                                "core::ops::deref::DerefMut",
                                Ty.apply
                                  (Ty.path "alloc::vec::Vec")
                                  []
                                  [ T; Ty.path "alloc::alloc::Global" ],
                                [],
                                "deref_mut",
                                []
                              |),
                              [ inputs ]
                            |)
                          ]
                        |)
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply
                            (Ty.path "alloc::collections::btree::set::BTreeSet")
                            []
                            [ T; Ty.path "alloc::alloc::Global" ],
                          "from_sorted_iter",
                          [
                            Ty.apply
                              (Ty.path "alloc::vec::into_iter::IntoIter")
                              []
                              [ T; Ty.path "alloc::alloc::Global" ]
                          ]
                        |),
                        [
                          M.call_closure (|
                            M.get_trait_method (|
                              "core::iter::traits::collect::IntoIterator",
                              Ty.apply
                                (Ty.path "alloc::vec::Vec")
                                []
                                [ T; Ty.path "alloc::alloc::Global" ],
                              [],
                              "into_iter",
                              []
                            |),
                            [ M.read (| inputs |) ]
                          |);
                          Value.StructTuple "alloc::alloc::Global" []
                        ]
                      |)
                    |)
                  |)))
              |)))
          | _, _, _ => M.impossible
          end.
        
        Axiom Implements :
          forall (T : Ty.t),
          M.IsTraitInstance
            "core::iter::traits::collect::FromIterator"
            (Self T)
            (* Trait polymorphic types *) [ (* A *) T ]
            (* Instance *) [ ("from_iter", InstanceField.Method (from_iter T)) ].
      End Impl_core_iter_traits_collect_FromIterator_where_core_cmp_Ord_T_T_for_alloc_collections_btree_set_BTreeSet_T_alloc_alloc_Global.
      
      
      Module Impl_core_convert_From_where_core_cmp_Ord_T_array_N_T_for_alloc_collections_btree_set_BTreeSet_T_alloc_alloc_Global.
        Definition Self (N : Value.t) (T : Ty.t) : Ty.t :=
          Ty.apply
            (Ty.path "alloc::collections::btree::set::BTreeSet")
            []
            [ T; Ty.path "alloc::alloc::Global" ].
        
        (*
            fn from(mut arr: [T; N]) -> Self {
                if N == 0 {
                    return BTreeSet::new();
                }
        
                // use stable sort to preserve the insertion order.
                arr.sort();
                let iter = IntoIterator::into_iter(arr).map(|k| (k, SetValZST::default()));
                let map = BTreeMap::bulk_build_from_sorted_iter(iter, Global);
                BTreeSet { map }
            }
        *)
        Definition from
            (N : Value.t)
            (T : Ty.t)
            (ε : list Value.t)
            (τ : list Ty.t)
            (α : list Value.t)
            : M :=
          let Self : Ty.t := Self N T in
          match ε, τ, α with
          | [], [], [ arr ] =>
            ltac:(M.monadic
              (let arr := M.alloc (| arr |) in
              M.catch_return (|
                ltac:(M.monadic
                  (M.read (|
                    let~ _ :=
                      M.match_operator (|
                        M.alloc (| Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.use
                                  (M.alloc (|
                                    BinOp.Pure.eq
                                      (M.read (|
                                        M.get_constant (| "alloc::collections::btree::set::N" |)
                                      |))
                                      (Value.Integer 0)
                                  |)) in
                              let _ :=
                                M.is_constant_or_break_match (|
                                  M.read (| γ |),
                                  Value.Bool true
                                |) in
                              M.alloc (|
                                M.never_to_any (|
                                  M.read (|
                                    M.return_ (|
                                      M.call_closure (|
                                        M.get_associated_function (|
                                          Ty.apply
                                            (Ty.path "alloc::collections::btree::set::BTreeSet")
                                            []
                                            [ T; Ty.path "alloc::alloc::Global" ],
                                          "new",
                                          []
                                        |),
                                        []
                                      |)
                                    |)
                                  |)
                                |)
                              |)));
                          fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                        ]
                      |) in
                    let~ _ :=
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.apply (Ty.path "slice") [] [ T ],
                            "sort",
                            []
                          |),
                          [ arr ]
                        |)
                      |) in
                    let~ iter :=
                      M.alloc (|
                        M.call_closure (|
                          M.get_trait_method (|
                            "core::iter::traits::iterator::Iterator",
                            Ty.apply (Ty.path "core::array::iter::IntoIter") [ N ] [ T ],
                            [],
                            "map",
                            [
                              Ty.tuple
                                [ T; Ty.path "alloc::collections::btree::set_val::SetValZST" ];
                              Ty.function
                                [ Ty.tuple [ T ] ]
                                (Ty.tuple
                                  [ T; Ty.path "alloc::collections::btree::set_val::SetValZST" ])
                            ]
                          |),
                          [
                            M.call_closure (|
                              M.get_trait_method (|
                                "core::iter::traits::collect::IntoIterator",
                                Ty.apply (Ty.path "array") [ N ] [ T ],
                                [],
                                "into_iter",
                                []
                              |),
                              [ M.read (| arr |) ]
                            |);
                            M.closure
                              (fun γ =>
                                ltac:(M.monadic
                                  match γ with
                                  | [ α0 ] =>
                                    M.match_operator (|
                                      M.alloc (| α0 |),
                                      [
                                        fun γ =>
                                          ltac:(M.monadic
                                            (let k := M.copy (| γ |) in
                                            Value.Tuple
                                              [
                                                M.read (| k |);
                                                M.call_closure (|
                                                  M.get_trait_method (|
                                                    "core::default::Default",
                                                    Ty.path
                                                      "alloc::collections::btree::set_val::SetValZST",
                                                    [],
                                                    "default",
                                                    []
                                                  |),
                                                  []
                                                |)
                                              ]))
                                      ]
                                    |)
                                  | _ => M.impossible (||)
                                  end))
                          ]
                        |)
                      |) in
                    let~ map :=
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.apply
                              (Ty.path "alloc::collections::btree::map::BTreeMap")
                              []
                              [
                                T;
                                Ty.path "alloc::collections::btree::set_val::SetValZST";
                                Ty.path "alloc::alloc::Global"
                              ],
                            "bulk_build_from_sorted_iter",
                            [
                              Ty.apply
                                (Ty.path "core::iter::adapters::map::Map")
                                []
                                [
                                  Ty.apply (Ty.path "core::array::iter::IntoIter") [ N ] [ T ];
                                  Ty.function
                                    [ Ty.tuple [ T ] ]
                                    (Ty.tuple
                                      [ T; Ty.path "alloc::collections::btree::set_val::SetValZST"
                                      ])
                                ]
                            ]
                          |),
                          [ M.read (| iter |); Value.StructTuple "alloc::alloc::Global" [] ]
                        |)
                      |) in
                    M.alloc (|
                      Value.StructRecord
                        "alloc::collections::btree::set::BTreeSet"
                        [ ("map", M.read (| map |)) ]
                    |)
                  |)))
              |)))
          | _, _, _ => M.impossible
          end.
        
        Axiom Implements :
          forall (N : Value.t) (T : Ty.t),
          M.IsTraitInstance
            "core::convert::From"
            (Self N T)
            (* Trait polymorphic types *) [ (* T *) Ty.apply (Ty.path "array") [ N ] [ T ] ]
            (* Instance *) [ ("from", InstanceField.Method (from N T)) ].
      End Impl_core_convert_From_where_core_cmp_Ord_T_array_N_T_for_alloc_collections_btree_set_BTreeSet_T_alloc_alloc_Global.
      
      Module Impl_core_iter_traits_collect_IntoIterator_where_core_alloc_Allocator_A_where_core_clone_Clone_A_for_alloc_collections_btree_set_BTreeSet_T_A.
        Definition Self (T A : Ty.t) : Ty.t :=
          Ty.apply (Ty.path "alloc::collections::btree::set::BTreeSet") [] [ T; A ].
        
        (*     type Item = T; *)
        Definition _Item (T A : Ty.t) : Ty.t := T.
        
        (*     type IntoIter = IntoIter<T, A>; *)
        Definition _IntoIter (T A : Ty.t) : Ty.t :=
          Ty.apply (Ty.path "alloc::collections::btree::set::IntoIter") [] [ T; A ].
        
        (*
            fn into_iter(self) -> IntoIter<T, A> {
                IntoIter { iter: self.map.into_iter() }
            }
        *)
        Definition into_iter
            (T A : Ty.t)
            (ε : list Value.t)
            (τ : list Ty.t)
            (α : list Value.t)
            : M :=
          let Self : Ty.t := Self T A in
          match ε, τ, α with
          | [], [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              Value.StructRecord
                "alloc::collections::btree::set::IntoIter"
                [
                  ("iter",
                    M.call_closure (|
                      M.get_trait_method (|
                        "core::iter::traits::collect::IntoIterator",
                        Ty.apply
                          (Ty.path "alloc::collections::btree::map::BTreeMap")
                          []
                          [ T; Ty.path "alloc::collections::btree::set_val::SetValZST"; A ],
                        [],
                        "into_iter",
                        []
                      |),
                      [
                        M.read (|
                          M.SubPointer.get_struct_record_field (|
                            self,
                            "alloc::collections::btree::set::BTreeSet",
                            "map"
                          |)
                        |)
                      ]
                    |))
                ]))
          | _, _, _ => M.impossible
          end.
        
        Axiom Implements :
          forall (T A : Ty.t),
          M.IsTraitInstance
            "core::iter::traits::collect::IntoIterator"
            (Self T A)
            (* Trait polymorphic types *) []
            (* Instance *)
            [
              ("Item", InstanceField.Ty (_Item T A));
              ("IntoIter", InstanceField.Ty (_IntoIter T A));
              ("into_iter", InstanceField.Method (into_iter T A))
            ].
      End Impl_core_iter_traits_collect_IntoIterator_where_core_alloc_Allocator_A_where_core_clone_Clone_A_for_alloc_collections_btree_set_BTreeSet_T_A.
      
      Module Impl_core_iter_traits_collect_IntoIterator_where_core_alloc_Allocator_A_where_core_clone_Clone_A_for_ref__alloc_collections_btree_set_BTreeSet_T_A.
        Definition Self (T A : Ty.t) : Ty.t :=
          Ty.apply
            (Ty.path "&")
            []
            [ Ty.apply (Ty.path "alloc::collections::btree::set::BTreeSet") [] [ T; A ] ].
        
        (*     type Item = &'a T; *)
        Definition _Item (T A : Ty.t) : Ty.t := Ty.apply (Ty.path "&") [] [ T ].
        
        (*     type IntoIter = Iter<'a, T>; *)
        Definition _IntoIter (T A : Ty.t) : Ty.t :=
          Ty.apply (Ty.path "alloc::collections::btree::set::Iter") [] [ T ].
        
        (*
            fn into_iter(self) -> Iter<'a, T> {
                self.iter()
            }
        *)
        Definition into_iter
            (T A : Ty.t)
            (ε : list Value.t)
            (τ : list Ty.t)
            (α : list Value.t)
            : M :=
          let Self : Ty.t := Self T A in
          match ε, τ, α with
          | [], [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply (Ty.path "alloc::collections::btree::set::BTreeSet") [] [ T; A ],
                  "iter",
                  []
                |),
                [ M.read (| self |) ]
              |)))
          | _, _, _ => M.impossible
          end.
        
        Axiom Implements :
          forall (T A : Ty.t),
          M.IsTraitInstance
            "core::iter::traits::collect::IntoIterator"
            (Self T A)
            (* Trait polymorphic types *) []
            (* Instance *)
            [
              ("Item", InstanceField.Ty (_Item T A));
              ("IntoIter", InstanceField.Ty (_IntoIter T A));
              ("into_iter", InstanceField.Method (into_iter T A))
            ].
      End Impl_core_iter_traits_collect_IntoIterator_where_core_alloc_Allocator_A_where_core_clone_Clone_A_for_ref__alloc_collections_btree_set_BTreeSet_T_A.
      
      (* StructRecord
        {
          name := "ExtractIf";
          const_params := [];
          ty_params := [ "T"; "F"; "A" ];
          fields :=
            [
              ("pred", F);
              ("inner",
                Ty.apply
                  (Ty.path "alloc::collections::btree::map::ExtractIfInner")
                  []
                  [ T; Ty.path "alloc::collections::btree::set_val::SetValZST" ]);
              ("alloc", A)
            ];
        } *)
      
      Module Impl_core_fmt_Debug_where_core_alloc_Allocator_A_where_core_clone_Clone_A_where_core_fmt_Debug_T_where_core_ops_function_FnMut_F_Tuple_ref__T__for_alloc_collections_btree_set_ExtractIf_T_F_A.
        Definition Self (T F A : Ty.t) : Ty.t :=
          Ty.apply (Ty.path "alloc::collections::btree::set::ExtractIf") [] [ T; F; A ].
        
        (*
            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                f.debug_tuple("ExtractIf").field(&self.inner.peek().map(|(k, _)| k)).finish()
            }
        *)
        Definition fmt (T F A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self T F A in
          match ε, τ, α with
          | [], [], [ self; f ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let f := M.alloc (| f |) in
              M.call_closure (|
                M.get_associated_function (|
                  Ty.path "core::fmt::builders::DebugTuple",
                  "finish",
                  []
                |),
                [
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.path "core::fmt::builders::DebugTuple",
                      "field",
                      []
                    |),
                    [
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.path "core::fmt::Formatter",
                            "debug_tuple",
                            []
                          |),
                          [ M.read (| f |); M.read (| Value.String "ExtractIf" |) ]
                        |)
                      |);
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.apply
                              (Ty.path "core::option::Option")
                              []
                              [
                                Ty.tuple
                                  [
                                    Ty.apply (Ty.path "&") [] [ T ];
                                    Ty.apply
                                      (Ty.path "&")
                                      []
                                      [ Ty.path "alloc::collections::btree::set_val::SetValZST" ]
                                  ]
                              ],
                            "map",
                            [
                              Ty.apply (Ty.path "&") [] [ T ];
                              Ty.function
                                [
                                  Ty.tuple
                                    [
                                      Ty.tuple
                                        [
                                          Ty.apply (Ty.path "&") [] [ T ];
                                          Ty.apply
                                            (Ty.path "&")
                                            []
                                            [
                                              Ty.path
                                                "alloc::collections::btree::set_val::SetValZST"
                                            ]
                                        ]
                                    ]
                                ]
                                (Ty.apply (Ty.path "&") [] [ T ])
                            ]
                          |),
                          [
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "alloc::collections::btree::map::ExtractIfInner")
                                  []
                                  [ T; Ty.path "alloc::collections::btree::set_val::SetValZST" ],
                                "peek",
                                []
                              |),
                              [
                                M.SubPointer.get_struct_record_field (|
                                  M.read (| self |),
                                  "alloc::collections::btree::set::ExtractIf",
                                  "inner"
                                |)
                              ]
                            |);
                            M.closure
                              (fun γ =>
                                ltac:(M.monadic
                                  match γ with
                                  | [ α0 ] =>
                                    M.match_operator (|
                                      M.alloc (| α0 |),
                                      [
                                        fun γ =>
                                          ltac:(M.monadic
                                            (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                                            let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                            let k := M.copy (| γ0_0 |) in
                                            M.read (| k |)))
                                      ]
                                    |)
                                  | _ => M.impossible (||)
                                  end))
                          ]
                        |)
                      |)
                    ]
                  |)
                ]
              |)))
          | _, _, _ => M.impossible
          end.
        
        Axiom Implements :
          forall (T F A : Ty.t),
          M.IsTraitInstance
            "core::fmt::Debug"
            (Self T F A)
            (* Trait polymorphic types *) []
            (* Instance *) [ ("fmt", InstanceField.Method (fmt T F A)) ].
      End Impl_core_fmt_Debug_where_core_alloc_Allocator_A_where_core_clone_Clone_A_where_core_fmt_Debug_T_where_core_ops_function_FnMut_F_Tuple_ref__T__for_alloc_collections_btree_set_ExtractIf_T_F_A.
      
      Module Impl_core_iter_traits_iterator_Iterator_where_core_alloc_Allocator_A_where_core_clone_Clone_A_where_core_ops_function_FnMut_F_Tuple_ref__T__for_alloc_collections_btree_set_ExtractIf_T_F_A.
        Definition Self (T F A : Ty.t) : Ty.t :=
          Ty.apply (Ty.path "alloc::collections::btree::set::ExtractIf") [] [ T; F; A ].
        
        (*     type Item = T; *)
        Definition _Item (T F A : Ty.t) : Ty.t := T.
        
        (*
            fn next(&mut self) -> Option<T> {
                let pred = &mut self.pred;
                let mut mapped_pred = |k: &T, _v: &mut SetValZST| pred(k);
                self.inner.next(&mut mapped_pred, self.alloc.clone()).map(|(k, _)| k)
            }
        *)
        Definition next (T F A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self T F A in
          match ε, τ, α with
          | [], [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              M.read (|
                let~ pred :=
                  M.alloc (|
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "alloc::collections::btree::set::ExtractIf",
                      "pred"
                    |)
                  |) in
                let~ mapped_pred :=
                  M.alloc (|
                    M.closure
                      (fun γ =>
                        ltac:(M.monadic
                          match γ with
                          | [ α0; α1 ] =>
                            M.match_operator (|
                              M.alloc (| α0 |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let k := M.copy (| γ |) in
                                    M.match_operator (|
                                      M.alloc (| α1 |),
                                      [
                                        fun γ =>
                                          ltac:(M.monadic
                                            (let _v := M.copy (| γ |) in
                                            M.call_closure (|
                                              M.get_trait_method (|
                                                "core::ops::function::FnMut",
                                                F,
                                                [ Ty.tuple [ Ty.apply (Ty.path "&") [] [ T ] ] ],
                                                "call_mut",
                                                []
                                              |),
                                              [ M.read (| pred |); Value.Tuple [ M.read (| k |) ] ]
                                            |)))
                                      ]
                                    |)))
                              ]
                            |)
                          | _ => M.impossible (||)
                          end))
                  |) in
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "core::option::Option")
                        []
                        [ Ty.tuple [ T; Ty.path "alloc::collections::btree::set_val::SetValZST" ] ],
                      "map",
                      [
                        T;
                        Ty.function
                          [
                            Ty.tuple
                              [
                                Ty.tuple
                                  [ T; Ty.path "alloc::collections::btree::set_val::SetValZST" ]
                              ]
                          ]
                          T
                      ]
                    |),
                    [
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply
                            (Ty.path "alloc::collections::btree::map::ExtractIfInner")
                            []
                            [ T; Ty.path "alloc::collections::btree::set_val::SetValZST" ],
                          "next",
                          [
                            Ty.function
                              [
                                Ty.tuple
                                  [
                                    Ty.apply (Ty.path "&") [] [ T ];
                                    Ty.apply
                                      (Ty.path "&mut")
                                      []
                                      [ Ty.path "alloc::collections::btree::set_val::SetValZST" ]
                                  ]
                              ]
                              (Ty.path "bool");
                            A
                          ]
                        |),
                        [
                          M.SubPointer.get_struct_record_field (|
                            M.read (| self |),
                            "alloc::collections::btree::set::ExtractIf",
                            "inner"
                          |);
                          mapped_pred;
                          M.call_closure (|
                            M.get_trait_method (| "core::clone::Clone", A, [], "clone", [] |),
                            [
                              M.SubPointer.get_struct_record_field (|
                                M.read (| self |),
                                "alloc::collections::btree::set::ExtractIf",
                                "alloc"
                              |)
                            ]
                          |)
                        ]
                      |);
                      M.closure
                        (fun γ =>
                          ltac:(M.monadic
                            match γ with
                            | [ α0 ] =>
                              M.match_operator (|
                                M.alloc (| α0 |),
                                [
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                      let k := M.copy (| γ0_0 |) in
                                      M.read (| k |)))
                                ]
                              |)
                            | _ => M.impossible (||)
                            end))
                    ]
                  |)
                |)
              |)))
          | _, _, _ => M.impossible
          end.
        
        (*
            fn size_hint(&self) -> (usize, Option<usize>) {
                self.inner.size_hint()
            }
        *)
        Definition size_hint
            (T F A : Ty.t)
            (ε : list Value.t)
            (τ : list Ty.t)
            (α : list Value.t)
            : M :=
          let Self : Ty.t := Self T F A in
          match ε, τ, α with
          | [], [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "alloc::collections::btree::map::ExtractIfInner")
                    []
                    [ T; Ty.path "alloc::collections::btree::set_val::SetValZST" ],
                  "size_hint",
                  []
                |),
                [
                  M.SubPointer.get_struct_record_field (|
                    M.read (| self |),
                    "alloc::collections::btree::set::ExtractIf",
                    "inner"
                  |)
                ]
              |)))
          | _, _, _ => M.impossible
          end.
        
        Axiom Implements :
          forall (T F A : Ty.t),
          M.IsTraitInstance
            "core::iter::traits::iterator::Iterator"
            (Self T F A)
            (* Trait polymorphic types *) []
            (* Instance *)
            [
              ("Item", InstanceField.Ty (_Item T F A));
              ("next", InstanceField.Method (next T F A));
              ("size_hint", InstanceField.Method (size_hint T F A))
            ].
      End Impl_core_iter_traits_iterator_Iterator_where_core_alloc_Allocator_A_where_core_clone_Clone_A_where_core_ops_function_FnMut_F_Tuple_ref__T__for_alloc_collections_btree_set_ExtractIf_T_F_A.
      
      Module Impl_core_iter_traits_marker_FusedIterator_where_core_alloc_Allocator_A_where_core_clone_Clone_A_where_core_ops_function_FnMut_F_Tuple_ref__T__for_alloc_collections_btree_set_ExtractIf_T_F_A.
        Definition Self (T F A : Ty.t) : Ty.t :=
          Ty.apply (Ty.path "alloc::collections::btree::set::ExtractIf") [] [ T; F; A ].
        
        Axiom Implements :
          forall (T F A : Ty.t),
          M.IsTraitInstance
            "core::iter::traits::marker::FusedIterator"
            (Self T F A)
            (* Trait polymorphic types *) []
            (* Instance *) [].
      End Impl_core_iter_traits_marker_FusedIterator_where_core_alloc_Allocator_A_where_core_clone_Clone_A_where_core_ops_function_FnMut_F_Tuple_ref__T__for_alloc_collections_btree_set_ExtractIf_T_F_A.
      
      Module Impl_core_iter_traits_collect_Extend_where_core_cmp_Ord_T_where_core_alloc_Allocator_A_where_core_clone_Clone_A_T_for_alloc_collections_btree_set_BTreeSet_T_A.
        Definition Self (T A : Ty.t) : Ty.t :=
          Ty.apply (Ty.path "alloc::collections::btree::set::BTreeSet") [] [ T; A ].
        
        (*
            fn extend<Iter: IntoIterator<Item = T>>(&mut self, iter: Iter) {
                iter.into_iter().for_each(move |elem| {
                    self.insert(elem);
                });
            }
        *)
        Definition extend (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self T A in
          match ε, τ, α with
          | [], [ Iter ], [ self; iter ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let iter := M.alloc (| iter |) in
              M.read (|
                let~ _ :=
                  M.alloc (|
                    M.call_closure (|
                      M.get_trait_method (|
                        "core::iter::traits::iterator::Iterator",
                        Ty.associated,
                        [],
                        "for_each",
                        [ Ty.function [ Ty.tuple [ T ] ] (Ty.tuple []) ]
                      |),
                      [
                        M.call_closure (|
                          M.get_trait_method (|
                            "core::iter::traits::collect::IntoIterator",
                            Iter,
                            [],
                            "into_iter",
                            []
                          |),
                          [ M.read (| iter |) ]
                        |);
                        M.closure
                          (fun γ =>
                            ltac:(M.monadic
                              match γ with
                              | [ α0 ] =>
                                M.match_operator (|
                                  M.alloc (| α0 |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let elem := M.copy (| γ |) in
                                        M.read (|
                                          let~ _ :=
                                            M.alloc (|
                                              M.call_closure (|
                                                M.get_associated_function (|
                                                  Ty.apply
                                                    (Ty.path
                                                      "alloc::collections::btree::set::BTreeSet")
                                                    []
                                                    [ T; A ],
                                                  "insert",
                                                  []
                                                |),
                                                [ M.read (| self |); M.read (| elem |) ]
                                              |)
                                            |) in
                                          M.alloc (| Value.Tuple [] |)
                                        |)))
                                  ]
                                |)
                              | _ => M.impossible (||)
                              end))
                      ]
                    |)
                  |) in
                M.alloc (| Value.Tuple [] |)
              |)))
          | _, _, _ => M.impossible
          end.
        
        (*
            fn extend_one(&mut self, elem: T) {
                self.insert(elem);
            }
        *)
        Definition extend_one
            (T A : Ty.t)
            (ε : list Value.t)
            (τ : list Ty.t)
            (α : list Value.t)
            : M :=
          let Self : Ty.t := Self T A in
          match ε, τ, α with
          | [], [], [ self; elem ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let elem := M.alloc (| elem |) in
              M.read (|
                let~ _ :=
                  M.alloc (|
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "alloc::collections::btree::set::BTreeSet") [] [ T; A ],
                        "insert",
                        []
                      |),
                      [ M.read (| self |); M.read (| elem |) ]
                    |)
                  |) in
                M.alloc (| Value.Tuple [] |)
              |)))
          | _, _, _ => M.impossible
          end.
        
        Axiom Implements :
          forall (T A : Ty.t),
          M.IsTraitInstance
            "core::iter::traits::collect::Extend"
            (Self T A)
            (* Trait polymorphic types *) [ (* A *) T ]
            (* Instance *)
            [
              ("extend", InstanceField.Method (extend T A));
              ("extend_one", InstanceField.Method (extend_one T A))
            ].
      End Impl_core_iter_traits_collect_Extend_where_core_cmp_Ord_T_where_core_alloc_Allocator_A_where_core_clone_Clone_A_T_for_alloc_collections_btree_set_BTreeSet_T_A.
      
      Module Impl_core_iter_traits_collect_Extend_where_core_cmp_Ord_T_where_core_marker_Copy_T_where_core_alloc_Allocator_A_where_core_clone_Clone_A_ref__T_for_alloc_collections_btree_set_BTreeSet_T_A.
        Definition Self (T A : Ty.t) : Ty.t :=
          Ty.apply (Ty.path "alloc::collections::btree::set::BTreeSet") [] [ T; A ].
        
        (*
            fn extend<I: IntoIterator<Item = &'a T>>(&mut self, iter: I) {
                self.extend(iter.into_iter().cloned());
            }
        *)
        Definition extend (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self T A in
          match ε, τ, α with
          | [], [ _ as I ], [ self; iter ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let iter := M.alloc (| iter |) in
              M.read (|
                let~ _ :=
                  M.alloc (|
                    M.call_closure (|
                      M.get_trait_method (|
                        "core::iter::traits::collect::Extend",
                        Ty.apply (Ty.path "alloc::collections::btree::set::BTreeSet") [] [ T; A ],
                        [ T ],
                        "extend",
                        [
                          Ty.apply
                            (Ty.path "core::iter::adapters::cloned::Cloned")
                            []
                            [ Ty.associated ]
                        ]
                      |),
                      [
                        M.read (| self |);
                        M.call_closure (|
                          M.get_trait_method (|
                            "core::iter::traits::iterator::Iterator",
                            Ty.associated,
                            [],
                            "cloned",
                            [ T ]
                          |),
                          [
                            M.call_closure (|
                              M.get_trait_method (|
                                "core::iter::traits::collect::IntoIterator",
                                I,
                                [],
                                "into_iter",
                                []
                              |),
                              [ M.read (| iter |) ]
                            |)
                          ]
                        |)
                      ]
                    |)
                  |) in
                M.alloc (| Value.Tuple [] |)
              |)))
          | _, _, _ => M.impossible
          end.
        
        (*
            fn extend_one(&mut self, &elem: &'a T) {
                self.insert(elem);
            }
        *)
        Definition extend_one
            (T A : Ty.t)
            (ε : list Value.t)
            (τ : list Ty.t)
            (α : list Value.t)
            : M :=
          let Self : Ty.t := Self T A in
          match ε, τ, α with
          | [], [], [ self; β1 ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let β1 := M.alloc (| β1 |) in
              M.match_operator (|
                β1,
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.read (| γ |) in
                      let elem := M.copy (| γ |) in
                      M.read (|
                        let~ _ :=
                          M.alloc (|
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "alloc::collections::btree::set::BTreeSet")
                                  []
                                  [ T; A ],
                                "insert",
                                []
                              |),
                              [ M.read (| self |); M.read (| elem |) ]
                            |)
                          |) in
                        M.alloc (| Value.Tuple [] |)
                      |)))
                ]
              |)))
          | _, _, _ => M.impossible
          end.
        
        Axiom Implements :
          forall (T A : Ty.t),
          M.IsTraitInstance
            "core::iter::traits::collect::Extend"
            (Self T A)
            (* Trait polymorphic types *) [ (* A *) Ty.apply (Ty.path "&") [] [ T ] ]
            (* Instance *)
            [
              ("extend", InstanceField.Method (extend T A));
              ("extend_one", InstanceField.Method (extend_one T A))
            ].
      End Impl_core_iter_traits_collect_Extend_where_core_cmp_Ord_T_where_core_marker_Copy_T_where_core_alloc_Allocator_A_where_core_clone_Clone_A_ref__T_for_alloc_collections_btree_set_BTreeSet_T_A.
      
      Module Impl_core_default_Default_for_alloc_collections_btree_set_BTreeSet_T_alloc_alloc_Global.
        Definition Self (T : Ty.t) : Ty.t :=
          Ty.apply
            (Ty.path "alloc::collections::btree::set::BTreeSet")
            []
            [ T; Ty.path "alloc::alloc::Global" ].
        
        (*
            fn default() -> BTreeSet<T> {
                BTreeSet::new()
            }
        *)
        Definition default (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self T in
          match ε, τ, α with
          | [], [], [] =>
            ltac:(M.monadic
              (M.call_closure (|
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "alloc::collections::btree::set::BTreeSet")
                    []
                    [ T; Ty.path "alloc::alloc::Global" ],
                  "new",
                  []
                |),
                []
              |)))
          | _, _, _ => M.impossible
          end.
        
        Axiom Implements :
          forall (T : Ty.t),
          M.IsTraitInstance
            "core::default::Default"
            (Self T)
            (* Trait polymorphic types *) []
            (* Instance *) [ ("default", InstanceField.Method (default T)) ].
      End Impl_core_default_Default_for_alloc_collections_btree_set_BTreeSet_T_alloc_alloc_Global.
      
      Module Impl_core_ops_arith_Sub_where_core_cmp_Ord_T_where_core_clone_Clone_T_where_core_alloc_Allocator_A_where_core_clone_Clone_A_ref__alloc_collections_btree_set_BTreeSet_T_A_for_ref__alloc_collections_btree_set_BTreeSet_T_A.
        Definition Self (T A : Ty.t) : Ty.t :=
          Ty.apply
            (Ty.path "&")
            []
            [ Ty.apply (Ty.path "alloc::collections::btree::set::BTreeSet") [] [ T; A ] ].
        
        (*     type Output = BTreeSet<T, A>; *)
        Definition _Output (T A : Ty.t) : Ty.t :=
          Ty.apply (Ty.path "alloc::collections::btree::set::BTreeSet") [] [ T; A ].
        
        (*
            fn sub(self, rhs: &BTreeSet<T, A>) -> BTreeSet<T, A> {
                BTreeSet::from_sorted_iter(
                    self.difference(rhs).cloned(),
                    ManuallyDrop::into_inner(self.map.alloc.clone()),
                )
            }
        *)
        Definition sub (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self T A in
          match ε, τ, α with
          | [], [], [ self; rhs ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let rhs := M.alloc (| rhs |) in
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply (Ty.path "alloc::collections::btree::set::BTreeSet") [] [ T; A ],
                  "from_sorted_iter",
                  [
                    Ty.apply
                      (Ty.path "core::iter::adapters::cloned::Cloned")
                      []
                      [ Ty.apply (Ty.path "alloc::collections::btree::set::Difference") [] [ T; A ]
                      ]
                  ]
                |),
                [
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::iter::traits::iterator::Iterator",
                      Ty.apply (Ty.path "alloc::collections::btree::set::Difference") [] [ T; A ],
                      [],
                      "cloned",
                      [ T ]
                    |),
                    [
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "alloc::collections::btree::set::BTreeSet") [] [ T; A ],
                          "difference",
                          []
                        |),
                        [ M.read (| self |); M.read (| rhs |) ]
                      |)
                    ]
                  |);
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply (Ty.path "core::mem::manually_drop::ManuallyDrop") [] [ A ],
                      "into_inner",
                      []
                    |),
                    [
                      M.call_closure (|
                        M.get_trait_method (|
                          "core::clone::Clone",
                          Ty.apply (Ty.path "core::mem::manually_drop::ManuallyDrop") [] [ A ],
                          [],
                          "clone",
                          []
                        |),
                        [
                          M.SubPointer.get_struct_record_field (|
                            M.SubPointer.get_struct_record_field (|
                              M.read (| self |),
                              "alloc::collections::btree::set::BTreeSet",
                              "map"
                            |),
                            "alloc::collections::btree::map::BTreeMap",
                            "alloc"
                          |)
                        ]
                      |)
                    ]
                  |)
                ]
              |)))
          | _, _, _ => M.impossible
          end.
        
        Axiom Implements :
          forall (T A : Ty.t),
          M.IsTraitInstance
            "core::ops::arith::Sub"
            (Self T A)
            (* Trait polymorphic types *)
            [
              (* Rhs *)
              Ty.apply
                (Ty.path "&")
                []
                [ Ty.apply (Ty.path "alloc::collections::btree::set::BTreeSet") [] [ T; A ] ]
            ]
            (* Instance *)
            [ ("Output", InstanceField.Ty (_Output T A)); ("sub", InstanceField.Method (sub T A)) ].
      End Impl_core_ops_arith_Sub_where_core_cmp_Ord_T_where_core_clone_Clone_T_where_core_alloc_Allocator_A_where_core_clone_Clone_A_ref__alloc_collections_btree_set_BTreeSet_T_A_for_ref__alloc_collections_btree_set_BTreeSet_T_A.
      
      Module Impl_core_ops_bit_BitXor_where_core_cmp_Ord_T_where_core_clone_Clone_T_where_core_alloc_Allocator_A_where_core_clone_Clone_A_ref__alloc_collections_btree_set_BTreeSet_T_A_for_ref__alloc_collections_btree_set_BTreeSet_T_A.
        Definition Self (T A : Ty.t) : Ty.t :=
          Ty.apply
            (Ty.path "&")
            []
            [ Ty.apply (Ty.path "alloc::collections::btree::set::BTreeSet") [] [ T; A ] ].
        
        (*     type Output = BTreeSet<T, A>; *)
        Definition _Output (T A : Ty.t) : Ty.t :=
          Ty.apply (Ty.path "alloc::collections::btree::set::BTreeSet") [] [ T; A ].
        
        (*
            fn bitxor(self, rhs: &BTreeSet<T, A>) -> BTreeSet<T, A> {
                BTreeSet::from_sorted_iter(
                    self.symmetric_difference(rhs).cloned(),
                    ManuallyDrop::into_inner(self.map.alloc.clone()),
                )
            }
        *)
        Definition bitxor (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self T A in
          match ε, τ, α with
          | [], [], [ self; rhs ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let rhs := M.alloc (| rhs |) in
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply (Ty.path "alloc::collections::btree::set::BTreeSet") [] [ T; A ],
                  "from_sorted_iter",
                  [
                    Ty.apply
                      (Ty.path "core::iter::adapters::cloned::Cloned")
                      []
                      [
                        Ty.apply
                          (Ty.path "alloc::collections::btree::set::SymmetricDifference")
                          []
                          [ T ]
                      ]
                  ]
                |),
                [
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::iter::traits::iterator::Iterator",
                      Ty.apply
                        (Ty.path "alloc::collections::btree::set::SymmetricDifference")
                        []
                        [ T ],
                      [],
                      "cloned",
                      [ T ]
                    |),
                    [
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "alloc::collections::btree::set::BTreeSet") [] [ T; A ],
                          "symmetric_difference",
                          []
                        |),
                        [ M.read (| self |); M.read (| rhs |) ]
                      |)
                    ]
                  |);
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply (Ty.path "core::mem::manually_drop::ManuallyDrop") [] [ A ],
                      "into_inner",
                      []
                    |),
                    [
                      M.call_closure (|
                        M.get_trait_method (|
                          "core::clone::Clone",
                          Ty.apply (Ty.path "core::mem::manually_drop::ManuallyDrop") [] [ A ],
                          [],
                          "clone",
                          []
                        |),
                        [
                          M.SubPointer.get_struct_record_field (|
                            M.SubPointer.get_struct_record_field (|
                              M.read (| self |),
                              "alloc::collections::btree::set::BTreeSet",
                              "map"
                            |),
                            "alloc::collections::btree::map::BTreeMap",
                            "alloc"
                          |)
                        ]
                      |)
                    ]
                  |)
                ]
              |)))
          | _, _, _ => M.impossible
          end.
        
        Axiom Implements :
          forall (T A : Ty.t),
          M.IsTraitInstance
            "core::ops::bit::BitXor"
            (Self T A)
            (* Trait polymorphic types *)
            [
              (* Rhs *)
              Ty.apply
                (Ty.path "&")
                []
                [ Ty.apply (Ty.path "alloc::collections::btree::set::BTreeSet") [] [ T; A ] ]
            ]
            (* Instance *)
            [
              ("Output", InstanceField.Ty (_Output T A));
              ("bitxor", InstanceField.Method (bitxor T A))
            ].
      End Impl_core_ops_bit_BitXor_where_core_cmp_Ord_T_where_core_clone_Clone_T_where_core_alloc_Allocator_A_where_core_clone_Clone_A_ref__alloc_collections_btree_set_BTreeSet_T_A_for_ref__alloc_collections_btree_set_BTreeSet_T_A.
      
      Module Impl_core_ops_bit_BitAnd_where_core_cmp_Ord_T_where_core_clone_Clone_T_where_core_alloc_Allocator_A_where_core_clone_Clone_A_ref__alloc_collections_btree_set_BTreeSet_T_A_for_ref__alloc_collections_btree_set_BTreeSet_T_A.
        Definition Self (T A : Ty.t) : Ty.t :=
          Ty.apply
            (Ty.path "&")
            []
            [ Ty.apply (Ty.path "alloc::collections::btree::set::BTreeSet") [] [ T; A ] ].
        
        (*     type Output = BTreeSet<T, A>; *)
        Definition _Output (T A : Ty.t) : Ty.t :=
          Ty.apply (Ty.path "alloc::collections::btree::set::BTreeSet") [] [ T; A ].
        
        (*
            fn bitand(self, rhs: &BTreeSet<T, A>) -> BTreeSet<T, A> {
                BTreeSet::from_sorted_iter(
                    self.intersection(rhs).cloned(),
                    ManuallyDrop::into_inner(self.map.alloc.clone()),
                )
            }
        *)
        Definition bitand (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self T A in
          match ε, τ, α with
          | [], [], [ self; rhs ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let rhs := M.alloc (| rhs |) in
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply (Ty.path "alloc::collections::btree::set::BTreeSet") [] [ T; A ],
                  "from_sorted_iter",
                  [
                    Ty.apply
                      (Ty.path "core::iter::adapters::cloned::Cloned")
                      []
                      [
                        Ty.apply
                          (Ty.path "alloc::collections::btree::set::Intersection")
                          []
                          [ T; A ]
                      ]
                  ]
                |),
                [
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::iter::traits::iterator::Iterator",
                      Ty.apply (Ty.path "alloc::collections::btree::set::Intersection") [] [ T; A ],
                      [],
                      "cloned",
                      [ T ]
                    |),
                    [
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "alloc::collections::btree::set::BTreeSet") [] [ T; A ],
                          "intersection",
                          []
                        |),
                        [ M.read (| self |); M.read (| rhs |) ]
                      |)
                    ]
                  |);
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply (Ty.path "core::mem::manually_drop::ManuallyDrop") [] [ A ],
                      "into_inner",
                      []
                    |),
                    [
                      M.call_closure (|
                        M.get_trait_method (|
                          "core::clone::Clone",
                          Ty.apply (Ty.path "core::mem::manually_drop::ManuallyDrop") [] [ A ],
                          [],
                          "clone",
                          []
                        |),
                        [
                          M.SubPointer.get_struct_record_field (|
                            M.SubPointer.get_struct_record_field (|
                              M.read (| self |),
                              "alloc::collections::btree::set::BTreeSet",
                              "map"
                            |),
                            "alloc::collections::btree::map::BTreeMap",
                            "alloc"
                          |)
                        ]
                      |)
                    ]
                  |)
                ]
              |)))
          | _, _, _ => M.impossible
          end.
        
        Axiom Implements :
          forall (T A : Ty.t),
          M.IsTraitInstance
            "core::ops::bit::BitAnd"
            (Self T A)
            (* Trait polymorphic types *)
            [
              (* Rhs *)
              Ty.apply
                (Ty.path "&")
                []
                [ Ty.apply (Ty.path "alloc::collections::btree::set::BTreeSet") [] [ T; A ] ]
            ]
            (* Instance *)
            [
              ("Output", InstanceField.Ty (_Output T A));
              ("bitand", InstanceField.Method (bitand T A))
            ].
      End Impl_core_ops_bit_BitAnd_where_core_cmp_Ord_T_where_core_clone_Clone_T_where_core_alloc_Allocator_A_where_core_clone_Clone_A_ref__alloc_collections_btree_set_BTreeSet_T_A_for_ref__alloc_collections_btree_set_BTreeSet_T_A.
      
      Module Impl_core_ops_bit_BitOr_where_core_cmp_Ord_T_where_core_clone_Clone_T_where_core_alloc_Allocator_A_where_core_clone_Clone_A_ref__alloc_collections_btree_set_BTreeSet_T_A_for_ref__alloc_collections_btree_set_BTreeSet_T_A.
        Definition Self (T A : Ty.t) : Ty.t :=
          Ty.apply
            (Ty.path "&")
            []
            [ Ty.apply (Ty.path "alloc::collections::btree::set::BTreeSet") [] [ T; A ] ].
        
        (*     type Output = BTreeSet<T, A>; *)
        Definition _Output (T A : Ty.t) : Ty.t :=
          Ty.apply (Ty.path "alloc::collections::btree::set::BTreeSet") [] [ T; A ].
        
        (*
            fn bitor(self, rhs: &BTreeSet<T, A>) -> BTreeSet<T, A> {
                BTreeSet::from_sorted_iter(
                    self.union(rhs).cloned(),
                    ManuallyDrop::into_inner(self.map.alloc.clone()),
                )
            }
        *)
        Definition bitor (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self T A in
          match ε, τ, α with
          | [], [], [ self; rhs ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let rhs := M.alloc (| rhs |) in
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply (Ty.path "alloc::collections::btree::set::BTreeSet") [] [ T; A ],
                  "from_sorted_iter",
                  [
                    Ty.apply
                      (Ty.path "core::iter::adapters::cloned::Cloned")
                      []
                      [ Ty.apply (Ty.path "alloc::collections::btree::set::Union") [] [ T ] ]
                  ]
                |),
                [
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::iter::traits::iterator::Iterator",
                      Ty.apply (Ty.path "alloc::collections::btree::set::Union") [] [ T ],
                      [],
                      "cloned",
                      [ T ]
                    |),
                    [
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "alloc::collections::btree::set::BTreeSet") [] [ T; A ],
                          "union",
                          []
                        |),
                        [ M.read (| self |); M.read (| rhs |) ]
                      |)
                    ]
                  |);
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply (Ty.path "core::mem::manually_drop::ManuallyDrop") [] [ A ],
                      "into_inner",
                      []
                    |),
                    [
                      M.call_closure (|
                        M.get_trait_method (|
                          "core::clone::Clone",
                          Ty.apply (Ty.path "core::mem::manually_drop::ManuallyDrop") [] [ A ],
                          [],
                          "clone",
                          []
                        |),
                        [
                          M.SubPointer.get_struct_record_field (|
                            M.SubPointer.get_struct_record_field (|
                              M.read (| self |),
                              "alloc::collections::btree::set::BTreeSet",
                              "map"
                            |),
                            "alloc::collections::btree::map::BTreeMap",
                            "alloc"
                          |)
                        ]
                      |)
                    ]
                  |)
                ]
              |)))
          | _, _, _ => M.impossible
          end.
        
        Axiom Implements :
          forall (T A : Ty.t),
          M.IsTraitInstance
            "core::ops::bit::BitOr"
            (Self T A)
            (* Trait polymorphic types *)
            [
              (* Rhs *)
              Ty.apply
                (Ty.path "&")
                []
                [ Ty.apply (Ty.path "alloc::collections::btree::set::BTreeSet") [] [ T; A ] ]
            ]
            (* Instance *)
            [
              ("Output", InstanceField.Ty (_Output T A));
              ("bitor", InstanceField.Method (bitor T A))
            ].
      End Impl_core_ops_bit_BitOr_where_core_cmp_Ord_T_where_core_clone_Clone_T_where_core_alloc_Allocator_A_where_core_clone_Clone_A_ref__alloc_collections_btree_set_BTreeSet_T_A_for_ref__alloc_collections_btree_set_BTreeSet_T_A.
      
      Module Impl_core_fmt_Debug_where_core_fmt_Debug_T_where_core_alloc_Allocator_A_where_core_clone_Clone_A_for_alloc_collections_btree_set_BTreeSet_T_A.
        Definition Self (T A : Ty.t) : Ty.t :=
          Ty.apply (Ty.path "alloc::collections::btree::set::BTreeSet") [] [ T; A ].
        
        (*
            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                f.debug_set().entries(self.iter()).finish()
            }
        *)
        Definition fmt (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self T A in
          match ε, τ, α with
          | [], [], [ self; f ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let f := M.alloc (| f |) in
              M.call_closure (|
                M.get_associated_function (|
                  Ty.path "core::fmt::builders::DebugSet",
                  "finish",
                  []
                |),
                [
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.path "core::fmt::builders::DebugSet",
                      "entries",
                      [
                        Ty.apply (Ty.path "&") [] [ T ];
                        Ty.apply (Ty.path "alloc::collections::btree::set::Iter") [] [ T ]
                      ]
                    |),
                    [
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.path "core::fmt::Formatter",
                            "debug_set",
                            []
                          |),
                          [ M.read (| f |) ]
                        |)
                      |);
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "alloc::collections::btree::set::BTreeSet") [] [ T; A ],
                          "iter",
                          []
                        |),
                        [ M.read (| self |) ]
                      |)
                    ]
                  |)
                ]
              |)))
          | _, _, _ => M.impossible
          end.
        
        Axiom Implements :
          forall (T A : Ty.t),
          M.IsTraitInstance
            "core::fmt::Debug"
            (Self T A)
            (* Trait polymorphic types *) []
            (* Instance *) [ ("fmt", InstanceField.Method (fmt T A)) ].
      End Impl_core_fmt_Debug_where_core_fmt_Debug_T_where_core_alloc_Allocator_A_where_core_clone_Clone_A_for_alloc_collections_btree_set_BTreeSet_T_A.
      
      Module Impl_core_clone_Clone_for_alloc_collections_btree_set_Iter_T.
        Definition Self (T : Ty.t) : Ty.t :=
          Ty.apply (Ty.path "alloc::collections::btree::set::Iter") [] [ T ].
        
        (*
            fn clone(&self) -> Self {
                Iter { iter: self.iter.clone() }
            }
        *)
        Definition clone (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self T in
          match ε, τ, α with
          | [], [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              Value.StructRecord
                "alloc::collections::btree::set::Iter"
                [
                  ("iter",
                    M.call_closure (|
                      M.get_trait_method (|
                        "core::clone::Clone",
                        Ty.apply
                          (Ty.path "alloc::collections::btree::map::Keys")
                          []
                          [ T; Ty.path "alloc::collections::btree::set_val::SetValZST" ],
                        [],
                        "clone",
                        []
                      |),
                      [
                        M.SubPointer.get_struct_record_field (|
                          M.read (| self |),
                          "alloc::collections::btree::set::Iter",
                          "iter"
                        |)
                      ]
                    |))
                ]))
          | _, _, _ => M.impossible
          end.
        
        Axiom Implements :
          forall (T : Ty.t),
          M.IsTraitInstance
            "core::clone::Clone"
            (Self T)
            (* Trait polymorphic types *) []
            (* Instance *) [ ("clone", InstanceField.Method (clone T)) ].
      End Impl_core_clone_Clone_for_alloc_collections_btree_set_Iter_T.
      
      Module Impl_core_iter_traits_iterator_Iterator_for_alloc_collections_btree_set_Iter_T.
        Definition Self (T : Ty.t) : Ty.t :=
          Ty.apply (Ty.path "alloc::collections::btree::set::Iter") [] [ T ].
        
        (*     type Item = &'a T; *)
        Definition _Item (T : Ty.t) : Ty.t := Ty.apply (Ty.path "&") [] [ T ].
        
        (*
            fn next(&mut self) -> Option<&'a T> {
                self.iter.next()
            }
        *)
        Definition next (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self T in
          match ε, τ, α with
          | [], [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              M.call_closure (|
                M.get_trait_method (|
                  "core::iter::traits::iterator::Iterator",
                  Ty.apply
                    (Ty.path "alloc::collections::btree::map::Keys")
                    []
                    [ T; Ty.path "alloc::collections::btree::set_val::SetValZST" ],
                  [],
                  "next",
                  []
                |),
                [
                  M.SubPointer.get_struct_record_field (|
                    M.read (| self |),
                    "alloc::collections::btree::set::Iter",
                    "iter"
                  |)
                ]
              |)))
          | _, _, _ => M.impossible
          end.
        
        (*
            fn size_hint(&self) -> (usize, Option<usize>) {
                self.iter.size_hint()
            }
        *)
        Definition size_hint (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self T in
          match ε, τ, α with
          | [], [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              M.call_closure (|
                M.get_trait_method (|
                  "core::iter::traits::iterator::Iterator",
                  Ty.apply
                    (Ty.path "alloc::collections::btree::map::Keys")
                    []
                    [ T; Ty.path "alloc::collections::btree::set_val::SetValZST" ],
                  [],
                  "size_hint",
                  []
                |),
                [
                  M.SubPointer.get_struct_record_field (|
                    M.read (| self |),
                    "alloc::collections::btree::set::Iter",
                    "iter"
                  |)
                ]
              |)))
          | _, _, _ => M.impossible
          end.
        
        (*
            fn last(mut self) -> Option<&'a T> {
                self.next_back()
            }
        *)
        Definition last (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self T in
          match ε, τ, α with
          | [], [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              M.call_closure (|
                M.get_trait_method (|
                  "core::iter::traits::double_ended::DoubleEndedIterator",
                  Ty.apply (Ty.path "alloc::collections::btree::set::Iter") [] [ T ],
                  [],
                  "next_back",
                  []
                |),
                [ self ]
              |)))
          | _, _, _ => M.impossible
          end.
        
        (*
            fn min(mut self) -> Option<&'a T>
            where
                &'a T: Ord,
            {
                self.next()
            }
        *)
        Definition min (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self T in
          match ε, τ, α with
          | [], [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              M.call_closure (|
                M.get_trait_method (|
                  "core::iter::traits::iterator::Iterator",
                  Ty.apply (Ty.path "alloc::collections::btree::set::Iter") [] [ T ],
                  [],
                  "next",
                  []
                |),
                [ self ]
              |)))
          | _, _, _ => M.impossible
          end.
        
        (*
            fn max(mut self) -> Option<&'a T>
            where
                &'a T: Ord,
            {
                self.next_back()
            }
        *)
        Definition max (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self T in
          match ε, τ, α with
          | [], [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              M.call_closure (|
                M.get_trait_method (|
                  "core::iter::traits::double_ended::DoubleEndedIterator",
                  Ty.apply (Ty.path "alloc::collections::btree::set::Iter") [] [ T ],
                  [],
                  "next_back",
                  []
                |),
                [ self ]
              |)))
          | _, _, _ => M.impossible
          end.
        
        Axiom Implements :
          forall (T : Ty.t),
          M.IsTraitInstance
            "core::iter::traits::iterator::Iterator"
            (Self T)
            (* Trait polymorphic types *) []
            (* Instance *)
            [
              ("Item", InstanceField.Ty (_Item T));
              ("next", InstanceField.Method (next T));
              ("size_hint", InstanceField.Method (size_hint T));
              ("last", InstanceField.Method (last T));
              ("min", InstanceField.Method (min T));
              ("max", InstanceField.Method (max T))
            ].
      End Impl_core_iter_traits_iterator_Iterator_for_alloc_collections_btree_set_Iter_T.
      
      Module Impl_core_iter_traits_double_ended_DoubleEndedIterator_for_alloc_collections_btree_set_Iter_T.
        Definition Self (T : Ty.t) : Ty.t :=
          Ty.apply (Ty.path "alloc::collections::btree::set::Iter") [] [ T ].
        
        (*
            fn next_back(&mut self) -> Option<&'a T> {
                self.iter.next_back()
            }
        *)
        Definition next_back (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self T in
          match ε, τ, α with
          | [], [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              M.call_closure (|
                M.get_trait_method (|
                  "core::iter::traits::double_ended::DoubleEndedIterator",
                  Ty.apply
                    (Ty.path "alloc::collections::btree::map::Keys")
                    []
                    [ T; Ty.path "alloc::collections::btree::set_val::SetValZST" ],
                  [],
                  "next_back",
                  []
                |),
                [
                  M.SubPointer.get_struct_record_field (|
                    M.read (| self |),
                    "alloc::collections::btree::set::Iter",
                    "iter"
                  |)
                ]
              |)))
          | _, _, _ => M.impossible
          end.
        
        Axiom Implements :
          forall (T : Ty.t),
          M.IsTraitInstance
            "core::iter::traits::double_ended::DoubleEndedIterator"
            (Self T)
            (* Trait polymorphic types *) []
            (* Instance *) [ ("next_back", InstanceField.Method (next_back T)) ].
      End Impl_core_iter_traits_double_ended_DoubleEndedIterator_for_alloc_collections_btree_set_Iter_T.
      
      Module Impl_core_iter_traits_exact_size_ExactSizeIterator_for_alloc_collections_btree_set_Iter_T.
        Definition Self (T : Ty.t) : Ty.t :=
          Ty.apply (Ty.path "alloc::collections::btree::set::Iter") [] [ T ].
        
        (*
            fn len(&self) -> usize {
                self.iter.len()
            }
        *)
        Definition len (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self T in
          match ε, τ, α with
          | [], [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              M.call_closure (|
                M.get_trait_method (|
                  "core::iter::traits::exact_size::ExactSizeIterator",
                  Ty.apply
                    (Ty.path "alloc::collections::btree::map::Keys")
                    []
                    [ T; Ty.path "alloc::collections::btree::set_val::SetValZST" ],
                  [],
                  "len",
                  []
                |),
                [
                  M.SubPointer.get_struct_record_field (|
                    M.read (| self |),
                    "alloc::collections::btree::set::Iter",
                    "iter"
                  |)
                ]
              |)))
          | _, _, _ => M.impossible
          end.
        
        Axiom Implements :
          forall (T : Ty.t),
          M.IsTraitInstance
            "core::iter::traits::exact_size::ExactSizeIterator"
            (Self T)
            (* Trait polymorphic types *) []
            (* Instance *) [ ("len", InstanceField.Method (len T)) ].
      End Impl_core_iter_traits_exact_size_ExactSizeIterator_for_alloc_collections_btree_set_Iter_T.
      
      Module Impl_core_iter_traits_marker_FusedIterator_for_alloc_collections_btree_set_Iter_T.
        Definition Self (T : Ty.t) : Ty.t :=
          Ty.apply (Ty.path "alloc::collections::btree::set::Iter") [] [ T ].
        
        Axiom Implements :
          forall (T : Ty.t),
          M.IsTraitInstance
            "core::iter::traits::marker::FusedIterator"
            (Self T)
            (* Trait polymorphic types *) []
            (* Instance *) [].
      End Impl_core_iter_traits_marker_FusedIterator_for_alloc_collections_btree_set_Iter_T.
      
      Module Impl_core_iter_traits_iterator_Iterator_where_core_alloc_Allocator_A_where_core_clone_Clone_A_for_alloc_collections_btree_set_IntoIter_T_A.
        Definition Self (T A : Ty.t) : Ty.t :=
          Ty.apply (Ty.path "alloc::collections::btree::set::IntoIter") [] [ T; A ].
        
        (*     type Item = T; *)
        Definition _Item (T A : Ty.t) : Ty.t := T.
        
        (*
            fn next(&mut self) -> Option<T> {
                self.iter.next().map(|(k, _)| k)
            }
        *)
        Definition next (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self T A in
          match ε, τ, α with
          | [], [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "core::option::Option")
                    []
                    [ Ty.tuple [ T; Ty.path "alloc::collections::btree::set_val::SetValZST" ] ],
                  "map",
                  [
                    T;
                    Ty.function
                      [
                        Ty.tuple
                          [ Ty.tuple [ T; Ty.path "alloc::collections::btree::set_val::SetValZST" ]
                          ]
                      ]
                      T
                  ]
                |),
                [
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::iter::traits::iterator::Iterator",
                      Ty.apply
                        (Ty.path "alloc::collections::btree::map::IntoIter")
                        []
                        [ T; Ty.path "alloc::collections::btree::set_val::SetValZST"; A ],
                      [],
                      "next",
                      []
                    |),
                    [
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "alloc::collections::btree::set::IntoIter",
                        "iter"
                      |)
                    ]
                  |);
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0 ] =>
                          M.match_operator (|
                            M.alloc (| α0 |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                                  let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                  let k := M.copy (| γ0_0 |) in
                                  M.read (| k |)))
                            ]
                          |)
                        | _ => M.impossible (||)
                        end))
                ]
              |)))
          | _, _, _ => M.impossible
          end.
        
        (*
            fn size_hint(&self) -> (usize, Option<usize>) {
                self.iter.size_hint()
            }
        *)
        Definition size_hint
            (T A : Ty.t)
            (ε : list Value.t)
            (τ : list Ty.t)
            (α : list Value.t)
            : M :=
          let Self : Ty.t := Self T A in
          match ε, τ, α with
          | [], [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              M.call_closure (|
                M.get_trait_method (|
                  "core::iter::traits::iterator::Iterator",
                  Ty.apply
                    (Ty.path "alloc::collections::btree::map::IntoIter")
                    []
                    [ T; Ty.path "alloc::collections::btree::set_val::SetValZST"; A ],
                  [],
                  "size_hint",
                  []
                |),
                [
                  M.SubPointer.get_struct_record_field (|
                    M.read (| self |),
                    "alloc::collections::btree::set::IntoIter",
                    "iter"
                  |)
                ]
              |)))
          | _, _, _ => M.impossible
          end.
        
        Axiom Implements :
          forall (T A : Ty.t),
          M.IsTraitInstance
            "core::iter::traits::iterator::Iterator"
            (Self T A)
            (* Trait polymorphic types *) []
            (* Instance *)
            [
              ("Item", InstanceField.Ty (_Item T A));
              ("next", InstanceField.Method (next T A));
              ("size_hint", InstanceField.Method (size_hint T A))
            ].
      End Impl_core_iter_traits_iterator_Iterator_where_core_alloc_Allocator_A_where_core_clone_Clone_A_for_alloc_collections_btree_set_IntoIter_T_A.
      
      Module Impl_core_default_Default_for_alloc_collections_btree_set_Iter_T.
        Definition Self (T : Ty.t) : Ty.t :=
          Ty.apply (Ty.path "alloc::collections::btree::set::Iter") [] [ T ].
        
        (*
            fn default() -> Self {
                Iter { iter: Default::default() }
            }
        *)
        Definition default (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self T in
          match ε, τ, α with
          | [], [], [] =>
            ltac:(M.monadic
              (Value.StructRecord
                "alloc::collections::btree::set::Iter"
                [
                  ("iter",
                    M.call_closure (|
                      M.get_trait_method (|
                        "core::default::Default",
                        Ty.apply
                          (Ty.path "alloc::collections::btree::map::Keys")
                          []
                          [ T; Ty.path "alloc::collections::btree::set_val::SetValZST" ],
                        [],
                        "default",
                        []
                      |),
                      []
                    |))
                ]))
          | _, _, _ => M.impossible
          end.
        
        Axiom Implements :
          forall (T : Ty.t),
          M.IsTraitInstance
            "core::default::Default"
            (Self T)
            (* Trait polymorphic types *) []
            (* Instance *) [ ("default", InstanceField.Method (default T)) ].
      End Impl_core_default_Default_for_alloc_collections_btree_set_Iter_T.
      
      Module Impl_core_iter_traits_double_ended_DoubleEndedIterator_where_core_alloc_Allocator_A_where_core_clone_Clone_A_for_alloc_collections_btree_set_IntoIter_T_A.
        Definition Self (T A : Ty.t) : Ty.t :=
          Ty.apply (Ty.path "alloc::collections::btree::set::IntoIter") [] [ T; A ].
        
        (*
            fn next_back(&mut self) -> Option<T> {
                self.iter.next_back().map(|(k, _)| k)
            }
        *)
        Definition next_back
            (T A : Ty.t)
            (ε : list Value.t)
            (τ : list Ty.t)
            (α : list Value.t)
            : M :=
          let Self : Ty.t := Self T A in
          match ε, τ, α with
          | [], [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "core::option::Option")
                    []
                    [ Ty.tuple [ T; Ty.path "alloc::collections::btree::set_val::SetValZST" ] ],
                  "map",
                  [
                    T;
                    Ty.function
                      [
                        Ty.tuple
                          [ Ty.tuple [ T; Ty.path "alloc::collections::btree::set_val::SetValZST" ]
                          ]
                      ]
                      T
                  ]
                |),
                [
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::iter::traits::double_ended::DoubleEndedIterator",
                      Ty.apply
                        (Ty.path "alloc::collections::btree::map::IntoIter")
                        []
                        [ T; Ty.path "alloc::collections::btree::set_val::SetValZST"; A ],
                      [],
                      "next_back",
                      []
                    |),
                    [
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "alloc::collections::btree::set::IntoIter",
                        "iter"
                      |)
                    ]
                  |);
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0 ] =>
                          M.match_operator (|
                            M.alloc (| α0 |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                                  let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                  let k := M.copy (| γ0_0 |) in
                                  M.read (| k |)))
                            ]
                          |)
                        | _ => M.impossible (||)
                        end))
                ]
              |)))
          | _, _, _ => M.impossible
          end.
        
        Axiom Implements :
          forall (T A : Ty.t),
          M.IsTraitInstance
            "core::iter::traits::double_ended::DoubleEndedIterator"
            (Self T A)
            (* Trait polymorphic types *) []
            (* Instance *) [ ("next_back", InstanceField.Method (next_back T A)) ].
      End Impl_core_iter_traits_double_ended_DoubleEndedIterator_where_core_alloc_Allocator_A_where_core_clone_Clone_A_for_alloc_collections_btree_set_IntoIter_T_A.
      
      Module Impl_core_iter_traits_exact_size_ExactSizeIterator_where_core_alloc_Allocator_A_where_core_clone_Clone_A_for_alloc_collections_btree_set_IntoIter_T_A.
        Definition Self (T A : Ty.t) : Ty.t :=
          Ty.apply (Ty.path "alloc::collections::btree::set::IntoIter") [] [ T; A ].
        
        (*
            fn len(&self) -> usize {
                self.iter.len()
            }
        *)
        Definition len (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self T A in
          match ε, τ, α with
          | [], [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              M.call_closure (|
                M.get_trait_method (|
                  "core::iter::traits::exact_size::ExactSizeIterator",
                  Ty.apply
                    (Ty.path "alloc::collections::btree::map::IntoIter")
                    []
                    [ T; Ty.path "alloc::collections::btree::set_val::SetValZST"; A ],
                  [],
                  "len",
                  []
                |),
                [
                  M.SubPointer.get_struct_record_field (|
                    M.read (| self |),
                    "alloc::collections::btree::set::IntoIter",
                    "iter"
                  |)
                ]
              |)))
          | _, _, _ => M.impossible
          end.
        
        Axiom Implements :
          forall (T A : Ty.t),
          M.IsTraitInstance
            "core::iter::traits::exact_size::ExactSizeIterator"
            (Self T A)
            (* Trait polymorphic types *) []
            (* Instance *) [ ("len", InstanceField.Method (len T A)) ].
      End Impl_core_iter_traits_exact_size_ExactSizeIterator_where_core_alloc_Allocator_A_where_core_clone_Clone_A_for_alloc_collections_btree_set_IntoIter_T_A.
      
      Module Impl_core_iter_traits_marker_FusedIterator_where_core_alloc_Allocator_A_where_core_clone_Clone_A_for_alloc_collections_btree_set_IntoIter_T_A.
        Definition Self (T A : Ty.t) : Ty.t :=
          Ty.apply (Ty.path "alloc::collections::btree::set::IntoIter") [] [ T; A ].
        
        Axiom Implements :
          forall (T A : Ty.t),
          M.IsTraitInstance
            "core::iter::traits::marker::FusedIterator"
            (Self T A)
            (* Trait polymorphic types *) []
            (* Instance *) [].
      End Impl_core_iter_traits_marker_FusedIterator_where_core_alloc_Allocator_A_where_core_clone_Clone_A_for_alloc_collections_btree_set_IntoIter_T_A.
      
      Module Impl_core_default_Default_where_core_alloc_Allocator_A_where_core_default_Default_A_where_core_clone_Clone_A_for_alloc_collections_btree_set_IntoIter_T_A.
        Definition Self (T A : Ty.t) : Ty.t :=
          Ty.apply (Ty.path "alloc::collections::btree::set::IntoIter") [] [ T; A ].
        
        (*
            fn default() -> Self {
                IntoIter { iter: Default::default() }
            }
        *)
        Definition default (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self T A in
          match ε, τ, α with
          | [], [], [] =>
            ltac:(M.monadic
              (Value.StructRecord
                "alloc::collections::btree::set::IntoIter"
                [
                  ("iter",
                    M.call_closure (|
                      M.get_trait_method (|
                        "core::default::Default",
                        Ty.apply
                          (Ty.path "alloc::collections::btree::map::IntoIter")
                          []
                          [ T; Ty.path "alloc::collections::btree::set_val::SetValZST"; A ],
                        [],
                        "default",
                        []
                      |),
                      []
                    |))
                ]))
          | _, _, _ => M.impossible
          end.
        
        Axiom Implements :
          forall (T A : Ty.t),
          M.IsTraitInstance
            "core::default::Default"
            (Self T A)
            (* Trait polymorphic types *) []
            (* Instance *) [ ("default", InstanceField.Method (default T A)) ].
      End Impl_core_default_Default_where_core_alloc_Allocator_A_where_core_default_Default_A_where_core_clone_Clone_A_for_alloc_collections_btree_set_IntoIter_T_A.
      
      Module Impl_core_clone_Clone_for_alloc_collections_btree_set_Range_T.
        Definition Self (T : Ty.t) : Ty.t :=
          Ty.apply (Ty.path "alloc::collections::btree::set::Range") [] [ T ].
        
        (*
            fn clone(&self) -> Self {
                Range { iter: self.iter.clone() }
            }
        *)
        Definition clone (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self T in
          match ε, τ, α with
          | [], [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              Value.StructRecord
                "alloc::collections::btree::set::Range"
                [
                  ("iter",
                    M.call_closure (|
                      M.get_trait_method (|
                        "core::clone::Clone",
                        Ty.apply
                          (Ty.path "alloc::collections::btree::map::Range")
                          []
                          [ T; Ty.path "alloc::collections::btree::set_val::SetValZST" ],
                        [],
                        "clone",
                        []
                      |),
                      [
                        M.SubPointer.get_struct_record_field (|
                          M.read (| self |),
                          "alloc::collections::btree::set::Range",
                          "iter"
                        |)
                      ]
                    |))
                ]))
          | _, _, _ => M.impossible
          end.
        
        Axiom Implements :
          forall (T : Ty.t),
          M.IsTraitInstance
            "core::clone::Clone"
            (Self T)
            (* Trait polymorphic types *) []
            (* Instance *) [ ("clone", InstanceField.Method (clone T)) ].
      End Impl_core_clone_Clone_for_alloc_collections_btree_set_Range_T.
      
      Module Impl_core_iter_traits_iterator_Iterator_for_alloc_collections_btree_set_Range_T.
        Definition Self (T : Ty.t) : Ty.t :=
          Ty.apply (Ty.path "alloc::collections::btree::set::Range") [] [ T ].
        
        (*     type Item = &'a T; *)
        Definition _Item (T : Ty.t) : Ty.t := Ty.apply (Ty.path "&") [] [ T ].
        
        (*
            fn next(&mut self) -> Option<&'a T> {
                self.iter.next().map(|(k, _)| k)
            }
        *)
        Definition next (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self T in
          match ε, τ, α with
          | [], [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "core::option::Option")
                    []
                    [
                      Ty.tuple
                        [
                          Ty.apply (Ty.path "&") [] [ T ];
                          Ty.apply
                            (Ty.path "&")
                            []
                            [ Ty.path "alloc::collections::btree::set_val::SetValZST" ]
                        ]
                    ],
                  "map",
                  [
                    Ty.apply (Ty.path "&") [] [ T ];
                    Ty.function
                      [
                        Ty.tuple
                          [
                            Ty.tuple
                              [
                                Ty.apply (Ty.path "&") [] [ T ];
                                Ty.apply
                                  (Ty.path "&")
                                  []
                                  [ Ty.path "alloc::collections::btree::set_val::SetValZST" ]
                              ]
                          ]
                      ]
                      (Ty.apply (Ty.path "&") [] [ T ])
                  ]
                |),
                [
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::iter::traits::iterator::Iterator",
                      Ty.apply
                        (Ty.path "alloc::collections::btree::map::Range")
                        []
                        [ T; Ty.path "alloc::collections::btree::set_val::SetValZST" ],
                      [],
                      "next",
                      []
                    |),
                    [
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "alloc::collections::btree::set::Range",
                        "iter"
                      |)
                    ]
                  |);
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0 ] =>
                          M.match_operator (|
                            M.alloc (| α0 |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                                  let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                  let k := M.copy (| γ0_0 |) in
                                  M.read (| k |)))
                            ]
                          |)
                        | _ => M.impossible (||)
                        end))
                ]
              |)))
          | _, _, _ => M.impossible
          end.
        
        (*
            fn last(mut self) -> Option<&'a T> {
                self.next_back()
            }
        *)
        Definition last (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self T in
          match ε, τ, α with
          | [], [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              M.call_closure (|
                M.get_trait_method (|
                  "core::iter::traits::double_ended::DoubleEndedIterator",
                  Ty.apply (Ty.path "alloc::collections::btree::set::Range") [] [ T ],
                  [],
                  "next_back",
                  []
                |),
                [ self ]
              |)))
          | _, _, _ => M.impossible
          end.
        
        (*
            fn min(mut self) -> Option<&'a T>
            where
                &'a T: Ord,
            {
                self.next()
            }
        *)
        Definition min (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self T in
          match ε, τ, α with
          | [], [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              M.call_closure (|
                M.get_trait_method (|
                  "core::iter::traits::iterator::Iterator",
                  Ty.apply (Ty.path "alloc::collections::btree::set::Range") [] [ T ],
                  [],
                  "next",
                  []
                |),
                [ self ]
              |)))
          | _, _, _ => M.impossible
          end.
        
        (*
            fn max(mut self) -> Option<&'a T>
            where
                &'a T: Ord,
            {
                self.next_back()
            }
        *)
        Definition max (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self T in
          match ε, τ, α with
          | [], [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              M.call_closure (|
                M.get_trait_method (|
                  "core::iter::traits::double_ended::DoubleEndedIterator",
                  Ty.apply (Ty.path "alloc::collections::btree::set::Range") [] [ T ],
                  [],
                  "next_back",
                  []
                |),
                [ self ]
              |)))
          | _, _, _ => M.impossible
          end.
        
        Axiom Implements :
          forall (T : Ty.t),
          M.IsTraitInstance
            "core::iter::traits::iterator::Iterator"
            (Self T)
            (* Trait polymorphic types *) []
            (* Instance *)
            [
              ("Item", InstanceField.Ty (_Item T));
              ("next", InstanceField.Method (next T));
              ("last", InstanceField.Method (last T));
              ("min", InstanceField.Method (min T));
              ("max", InstanceField.Method (max T))
            ].
      End Impl_core_iter_traits_iterator_Iterator_for_alloc_collections_btree_set_Range_T.
      
      Module Impl_core_iter_traits_double_ended_DoubleEndedIterator_for_alloc_collections_btree_set_Range_T.
        Definition Self (T : Ty.t) : Ty.t :=
          Ty.apply (Ty.path "alloc::collections::btree::set::Range") [] [ T ].
        
        (*
            fn next_back(&mut self) -> Option<&'a T> {
                self.iter.next_back().map(|(k, _)| k)
            }
        *)
        Definition next_back (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self T in
          match ε, τ, α with
          | [], [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "core::option::Option")
                    []
                    [
                      Ty.tuple
                        [
                          Ty.apply (Ty.path "&") [] [ T ];
                          Ty.apply
                            (Ty.path "&")
                            []
                            [ Ty.path "alloc::collections::btree::set_val::SetValZST" ]
                        ]
                    ],
                  "map",
                  [
                    Ty.apply (Ty.path "&") [] [ T ];
                    Ty.function
                      [
                        Ty.tuple
                          [
                            Ty.tuple
                              [
                                Ty.apply (Ty.path "&") [] [ T ];
                                Ty.apply
                                  (Ty.path "&")
                                  []
                                  [ Ty.path "alloc::collections::btree::set_val::SetValZST" ]
                              ]
                          ]
                      ]
                      (Ty.apply (Ty.path "&") [] [ T ])
                  ]
                |),
                [
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::iter::traits::double_ended::DoubleEndedIterator",
                      Ty.apply
                        (Ty.path "alloc::collections::btree::map::Range")
                        []
                        [ T; Ty.path "alloc::collections::btree::set_val::SetValZST" ],
                      [],
                      "next_back",
                      []
                    |),
                    [
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "alloc::collections::btree::set::Range",
                        "iter"
                      |)
                    ]
                  |);
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0 ] =>
                          M.match_operator (|
                            M.alloc (| α0 |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                                  let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                  let k := M.copy (| γ0_0 |) in
                                  M.read (| k |)))
                            ]
                          |)
                        | _ => M.impossible (||)
                        end))
                ]
              |)))
          | _, _, _ => M.impossible
          end.
        
        Axiom Implements :
          forall (T : Ty.t),
          M.IsTraitInstance
            "core::iter::traits::double_ended::DoubleEndedIterator"
            (Self T)
            (* Trait polymorphic types *) []
            (* Instance *) [ ("next_back", InstanceField.Method (next_back T)) ].
      End Impl_core_iter_traits_double_ended_DoubleEndedIterator_for_alloc_collections_btree_set_Range_T.
      
      Module Impl_core_iter_traits_marker_FusedIterator_for_alloc_collections_btree_set_Range_T.
        Definition Self (T : Ty.t) : Ty.t :=
          Ty.apply (Ty.path "alloc::collections::btree::set::Range") [] [ T ].
        
        Axiom Implements :
          forall (T : Ty.t),
          M.IsTraitInstance
            "core::iter::traits::marker::FusedIterator"
            (Self T)
            (* Trait polymorphic types *) []
            (* Instance *) [].
      End Impl_core_iter_traits_marker_FusedIterator_for_alloc_collections_btree_set_Range_T.
      
      Module Impl_core_default_Default_for_alloc_collections_btree_set_Range_T.
        Definition Self (T : Ty.t) : Ty.t :=
          Ty.apply (Ty.path "alloc::collections::btree::set::Range") [] [ T ].
        
        (*
            fn default() -> Self {
                Range { iter: Default::default() }
            }
        *)
        Definition default (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self T in
          match ε, τ, α with
          | [], [], [] =>
            ltac:(M.monadic
              (Value.StructRecord
                "alloc::collections::btree::set::Range"
                [
                  ("iter",
                    M.call_closure (|
                      M.get_trait_method (|
                        "core::default::Default",
                        Ty.apply
                          (Ty.path "alloc::collections::btree::map::Range")
                          []
                          [ T; Ty.path "alloc::collections::btree::set_val::SetValZST" ],
                        [],
                        "default",
                        []
                      |),
                      []
                    |))
                ]))
          | _, _, _ => M.impossible
          end.
        
        Axiom Implements :
          forall (T : Ty.t),
          M.IsTraitInstance
            "core::default::Default"
            (Self T)
            (* Trait polymorphic types *) []
            (* Instance *) [ ("default", InstanceField.Method (default T)) ].
      End Impl_core_default_Default_for_alloc_collections_btree_set_Range_T.
      
      Module Impl_core_clone_Clone_where_core_alloc_Allocator_A_where_core_clone_Clone_A_for_alloc_collections_btree_set_Difference_T_A.
        Definition Self (T A : Ty.t) : Ty.t :=
          Ty.apply (Ty.path "alloc::collections::btree::set::Difference") [] [ T; A ].
        
        (*
            fn clone(&self) -> Self {
                Difference {
                    inner: match &self.inner {
                        DifferenceInner::Stitch { self_iter, other_iter } => DifferenceInner::Stitch {
                            self_iter: self_iter.clone(),
                            other_iter: other_iter.clone(),
                        },
                        DifferenceInner::Search { self_iter, other_set } => {
                            DifferenceInner::Search { self_iter: self_iter.clone(), other_set }
                        }
                        DifferenceInner::Iterate(iter) => DifferenceInner::Iterate(iter.clone()),
                    },
                }
            }
        *)
        Definition clone (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self T A in
          match ε, τ, α with
          | [], [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              Value.StructRecord
                "alloc::collections::btree::set::Difference"
                [
                  ("inner",
                    M.read (|
                      M.match_operator (|
                        M.alloc (|
                          M.SubPointer.get_struct_record_field (|
                            M.read (| self |),
                            "alloc::collections::btree::set::Difference",
                            "inner"
                          |)
                        |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ := M.read (| γ |) in
                              let γ1_0 :=
                                M.SubPointer.get_struct_record_field (|
                                  γ,
                                  "alloc::collections::btree::set::DifferenceInner::Stitch",
                                  "self_iter"
                                |) in
                              let γ1_1 :=
                                M.SubPointer.get_struct_record_field (|
                                  γ,
                                  "alloc::collections::btree::set::DifferenceInner::Stitch",
                                  "other_iter"
                                |) in
                              let self_iter := M.alloc (| γ1_0 |) in
                              let other_iter := M.alloc (| γ1_1 |) in
                              M.alloc (|
                                Value.StructRecord
                                  "alloc::collections::btree::set::DifferenceInner::Stitch"
                                  [
                                    ("self_iter",
                                      M.call_closure (|
                                        M.get_trait_method (|
                                          "core::clone::Clone",
                                          Ty.apply
                                            (Ty.path "alloc::collections::btree::set::Iter")
                                            []
                                            [ T ],
                                          [],
                                          "clone",
                                          []
                                        |),
                                        [ M.read (| self_iter |) ]
                                      |));
                                    ("other_iter",
                                      M.call_closure (|
                                        M.get_trait_method (|
                                          "core::clone::Clone",
                                          Ty.apply
                                            (Ty.path "core::iter::adapters::peekable::Peekable")
                                            []
                                            [
                                              Ty.apply
                                                (Ty.path "alloc::collections::btree::set::Iter")
                                                []
                                                [ T ]
                                            ],
                                          [],
                                          "clone",
                                          []
                                        |),
                                        [ M.read (| other_iter |) ]
                                      |))
                                  ]
                              |)));
                          fun γ =>
                            ltac:(M.monadic
                              (let γ := M.read (| γ |) in
                              let γ1_0 :=
                                M.SubPointer.get_struct_record_field (|
                                  γ,
                                  "alloc::collections::btree::set::DifferenceInner::Search",
                                  "self_iter"
                                |) in
                              let γ1_1 :=
                                M.SubPointer.get_struct_record_field (|
                                  γ,
                                  "alloc::collections::btree::set::DifferenceInner::Search",
                                  "other_set"
                                |) in
                              let self_iter := M.alloc (| γ1_0 |) in
                              let other_set := M.alloc (| γ1_1 |) in
                              M.alloc (|
                                Value.StructRecord
                                  "alloc::collections::btree::set::DifferenceInner::Search"
                                  [
                                    ("self_iter",
                                      M.call_closure (|
                                        M.get_trait_method (|
                                          "core::clone::Clone",
                                          Ty.apply
                                            (Ty.path "alloc::collections::btree::set::Iter")
                                            []
                                            [ T ],
                                          [],
                                          "clone",
                                          []
                                        |),
                                        [ M.read (| self_iter |) ]
                                      |));
                                    ("other_set", M.read (| M.read (| other_set |) |))
                                  ]
                              |)));
                          fun γ =>
                            ltac:(M.monadic
                              (let γ := M.read (| γ |) in
                              let γ1_0 :=
                                M.SubPointer.get_struct_tuple_field (|
                                  γ,
                                  "alloc::collections::btree::set::DifferenceInner::Iterate",
                                  0
                                |) in
                              let iter := M.alloc (| γ1_0 |) in
                              M.alloc (|
                                Value.StructTuple
                                  "alloc::collections::btree::set::DifferenceInner::Iterate"
                                  [
                                    M.call_closure (|
                                      M.get_trait_method (|
                                        "core::clone::Clone",
                                        Ty.apply
                                          (Ty.path "alloc::collections::btree::set::Iter")
                                          []
                                          [ T ],
                                        [],
                                        "clone",
                                        []
                                      |),
                                      [ M.read (| iter |) ]
                                    |)
                                  ]
                              |)))
                        ]
                      |)
                    |))
                ]))
          | _, _, _ => M.impossible
          end.
        
        Axiom Implements :
          forall (T A : Ty.t),
          M.IsTraitInstance
            "core::clone::Clone"
            (Self T A)
            (* Trait polymorphic types *) []
            (* Instance *) [ ("clone", InstanceField.Method (clone T A)) ].
      End Impl_core_clone_Clone_where_core_alloc_Allocator_A_where_core_clone_Clone_A_for_alloc_collections_btree_set_Difference_T_A.
      
      Module Impl_core_iter_traits_iterator_Iterator_where_core_cmp_Ord_T_where_core_alloc_Allocator_A_where_core_clone_Clone_A_for_alloc_collections_btree_set_Difference_T_A.
        Definition Self (T A : Ty.t) : Ty.t :=
          Ty.apply (Ty.path "alloc::collections::btree::set::Difference") [] [ T; A ].
        
        (*     type Item = &'a T; *)
        Definition _Item (T A : Ty.t) : Ty.t := Ty.apply (Ty.path "&") [] [ T ].
        
        (*
            fn next(&mut self) -> Option<&'a T> {
                match &mut self.inner {
                    DifferenceInner::Stitch { self_iter, other_iter } => {
                        let mut self_next = self_iter.next()?;
                        loop {
                            match other_iter.peek().map_or(Less, |other_next| self_next.cmp(other_next)) {
                                Less => return Some(self_next),
                                Equal => {
                                    self_next = self_iter.next()?;
                                    other_iter.next();
                                }
                                Greater => {
                                    other_iter.next();
                                }
                            }
                        }
                    }
                    DifferenceInner::Search { self_iter, other_set } => loop {
                        let self_next = self_iter.next()?;
                        if !other_set.contains(&self_next) {
                            return Some(self_next);
                        }
                    },
                    DifferenceInner::Iterate(iter) => iter.next(),
                }
            }
        *)
        Definition next (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self T A in
          match ε, τ, α with
          | [], [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              M.catch_return (|
                ltac:(M.monadic
                  (M.read (|
                    M.match_operator (|
                      M.alloc (|
                        M.SubPointer.get_struct_record_field (|
                          M.read (| self |),
                          "alloc::collections::btree::set::Difference",
                          "inner"
                        |)
                      |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ := M.read (| γ |) in
                            let γ1_0 :=
                              M.SubPointer.get_struct_record_field (|
                                γ,
                                "alloc::collections::btree::set::DifferenceInner::Stitch",
                                "self_iter"
                              |) in
                            let γ1_1 :=
                              M.SubPointer.get_struct_record_field (|
                                γ,
                                "alloc::collections::btree::set::DifferenceInner::Stitch",
                                "other_iter"
                              |) in
                            let self_iter := M.alloc (| γ1_0 |) in
                            let other_iter := M.alloc (| γ1_1 |) in
                            let~ self_next :=
                              M.copy (|
                                M.match_operator (|
                                  M.alloc (|
                                    M.call_closure (|
                                      M.get_trait_method (|
                                        "core::ops::try_trait::Try",
                                        Ty.apply
                                          (Ty.path "core::option::Option")
                                          []
                                          [ Ty.apply (Ty.path "&") [] [ T ] ],
                                        [],
                                        "branch",
                                        []
                                      |),
                                      [
                                        M.call_closure (|
                                          M.get_trait_method (|
                                            "core::iter::traits::iterator::Iterator",
                                            Ty.apply
                                              (Ty.path "alloc::collections::btree::set::Iter")
                                              []
                                              [ T ],
                                            [],
                                            "next",
                                            []
                                          |),
                                          [ M.read (| self_iter |) ]
                                        |)
                                      ]
                                    |)
                                  |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ0_0 :=
                                          M.SubPointer.get_struct_tuple_field (|
                                            γ,
                                            "core::ops::control_flow::ControlFlow::Break",
                                            0
                                          |) in
                                        let residual := M.copy (| γ0_0 |) in
                                        M.alloc (|
                                          M.never_to_any (|
                                            M.read (|
                                              M.return_ (|
                                                M.call_closure (|
                                                  M.get_trait_method (|
                                                    "core::ops::try_trait::FromResidual",
                                                    Ty.apply
                                                      (Ty.path "core::option::Option")
                                                      []
                                                      [ Ty.apply (Ty.path "&") [] [ T ] ],
                                                    [
                                                      Ty.apply
                                                        (Ty.path "core::option::Option")
                                                        []
                                                        [ Ty.path "core::convert::Infallible" ]
                                                    ],
                                                    "from_residual",
                                                    []
                                                  |),
                                                  [ M.read (| residual |) ]
                                                |)
                                              |)
                                            |)
                                          |)
                                        |)));
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ0_0 :=
                                          M.SubPointer.get_struct_tuple_field (|
                                            γ,
                                            "core::ops::control_flow::ControlFlow::Continue",
                                            0
                                          |) in
                                        let val := M.copy (| γ0_0 |) in
                                        val))
                                  ]
                                |)
                              |) in
                            M.alloc (|
                              M.never_to_any (|
                                M.read (|
                                  M.loop (|
                                    ltac:(M.monadic
                                      (M.match_operator (|
                                        M.alloc (|
                                          M.call_closure (|
                                            M.get_associated_function (|
                                              Ty.apply
                                                (Ty.path "core::option::Option")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path "&")
                                                    []
                                                    [ Ty.apply (Ty.path "&") [] [ T ] ]
                                                ],
                                              "map_or",
                                              [
                                                Ty.path "core::cmp::Ordering";
                                                Ty.function
                                                  [
                                                    Ty.tuple
                                                      [
                                                        Ty.apply
                                                          (Ty.path "&")
                                                          []
                                                          [ Ty.apply (Ty.path "&") [] [ T ] ]
                                                      ]
                                                  ]
                                                  (Ty.path "core::cmp::Ordering")
                                              ]
                                            |),
                                            [
                                              M.call_closure (|
                                                M.get_associated_function (|
                                                  Ty.apply
                                                    (Ty.path
                                                      "core::iter::adapters::peekable::Peekable")
                                                    []
                                                    [
                                                      Ty.apply
                                                        (Ty.path
                                                          "alloc::collections::btree::set::Iter")
                                                        []
                                                        [ T ]
                                                    ],
                                                  "peek",
                                                  []
                                                |),
                                                [ M.read (| other_iter |) ]
                                              |);
                                              Value.StructTuple "core::cmp::Ordering::Less" [];
                                              M.closure
                                                (fun γ =>
                                                  ltac:(M.monadic
                                                    match γ with
                                                    | [ α0 ] =>
                                                      M.match_operator (|
                                                        M.alloc (| α0 |),
                                                        [
                                                          fun γ =>
                                                            ltac:(M.monadic
                                                              (let other_next := M.copy (| γ |) in
                                                              M.call_closure (|
                                                                M.get_trait_method (|
                                                                  "core::cmp::Ord",
                                                                  T,
                                                                  [],
                                                                  "cmp",
                                                                  []
                                                                |),
                                                                [
                                                                  M.read (| self_next |);
                                                                  M.read (|
                                                                    M.read (| other_next |)
                                                                  |)
                                                                ]
                                                              |)))
                                                        ]
                                                      |)
                                                    | _ => M.impossible (||)
                                                    end))
                                            ]
                                          |)
                                        |),
                                        [
                                          fun γ =>
                                            ltac:(M.monadic
                                              (let _ :=
                                                M.is_struct_tuple (|
                                                  γ,
                                                  "core::cmp::Ordering::Less"
                                                |) in
                                              M.alloc (|
                                                M.never_to_any (|
                                                  M.read (|
                                                    M.return_ (|
                                                      Value.StructTuple
                                                        "core::option::Option::Some"
                                                        [ M.read (| self_next |) ]
                                                    |)
                                                  |)
                                                |)
                                              |)));
                                          fun γ =>
                                            ltac:(M.monadic
                                              (let _ :=
                                                M.is_struct_tuple (|
                                                  γ,
                                                  "core::cmp::Ordering::Equal"
                                                |) in
                                              let~ _ :=
                                                M.write (|
                                                  self_next,
                                                  M.read (|
                                                    M.match_operator (|
                                                      M.alloc (|
                                                        M.call_closure (|
                                                          M.get_trait_method (|
                                                            "core::ops::try_trait::Try",
                                                            Ty.apply
                                                              (Ty.path "core::option::Option")
                                                              []
                                                              [ Ty.apply (Ty.path "&") [] [ T ] ],
                                                            [],
                                                            "branch",
                                                            []
                                                          |),
                                                          [
                                                            M.call_closure (|
                                                              M.get_trait_method (|
                                                                "core::iter::traits::iterator::Iterator",
                                                                Ty.apply
                                                                  (Ty.path
                                                                    "alloc::collections::btree::set::Iter")
                                                                  []
                                                                  [ T ],
                                                                [],
                                                                "next",
                                                                []
                                                              |),
                                                              [ M.read (| self_iter |) ]
                                                            |)
                                                          ]
                                                        |)
                                                      |),
                                                      [
                                                        fun γ =>
                                                          ltac:(M.monadic
                                                            (let γ0_0 :=
                                                              M.SubPointer.get_struct_tuple_field (|
                                                                γ,
                                                                "core::ops::control_flow::ControlFlow::Break",
                                                                0
                                                              |) in
                                                            let residual := M.copy (| γ0_0 |) in
                                                            M.alloc (|
                                                              M.never_to_any (|
                                                                M.read (|
                                                                  M.return_ (|
                                                                    M.call_closure (|
                                                                      M.get_trait_method (|
                                                                        "core::ops::try_trait::FromResidual",
                                                                        Ty.apply
                                                                          (Ty.path
                                                                            "core::option::Option")
                                                                          []
                                                                          [
                                                                            Ty.apply
                                                                              (Ty.path "&")
                                                                              []
                                                                              [ T ]
                                                                          ],
                                                                        [
                                                                          Ty.apply
                                                                            (Ty.path
                                                                              "core::option::Option")
                                                                            []
                                                                            [
                                                                              Ty.path
                                                                                "core::convert::Infallible"
                                                                            ]
                                                                        ],
                                                                        "from_residual",
                                                                        []
                                                                      |),
                                                                      [ M.read (| residual |) ]
                                                                    |)
                                                                  |)
                                                                |)
                                                              |)
                                                            |)));
                                                        fun γ =>
                                                          ltac:(M.monadic
                                                            (let γ0_0 :=
                                                              M.SubPointer.get_struct_tuple_field (|
                                                                γ,
                                                                "core::ops::control_flow::ControlFlow::Continue",
                                                                0
                                                              |) in
                                                            let val := M.copy (| γ0_0 |) in
                                                            M.alloc (| M.read (| val |) |)))
                                                      ]
                                                    |)
                                                  |)
                                                |) in
                                              let~ _ :=
                                                M.alloc (|
                                                  M.call_closure (|
                                                    M.get_trait_method (|
                                                      "core::iter::traits::iterator::Iterator",
                                                      Ty.apply
                                                        (Ty.path
                                                          "core::iter::adapters::peekable::Peekable")
                                                        []
                                                        [
                                                          Ty.apply
                                                            (Ty.path
                                                              "alloc::collections::btree::set::Iter")
                                                            []
                                                            [ T ]
                                                        ],
                                                      [],
                                                      "next",
                                                      []
                                                    |),
                                                    [ M.read (| other_iter |) ]
                                                  |)
                                                |) in
                                              M.alloc (| Value.Tuple [] |)));
                                          fun γ =>
                                            ltac:(M.monadic
                                              (let _ :=
                                                M.is_struct_tuple (|
                                                  γ,
                                                  "core::cmp::Ordering::Greater"
                                                |) in
                                              let~ _ :=
                                                M.alloc (|
                                                  M.call_closure (|
                                                    M.get_trait_method (|
                                                      "core::iter::traits::iterator::Iterator",
                                                      Ty.apply
                                                        (Ty.path
                                                          "core::iter::adapters::peekable::Peekable")
                                                        []
                                                        [
                                                          Ty.apply
                                                            (Ty.path
                                                              "alloc::collections::btree::set::Iter")
                                                            []
                                                            [ T ]
                                                        ],
                                                      [],
                                                      "next",
                                                      []
                                                    |),
                                                    [ M.read (| other_iter |) ]
                                                  |)
                                                |) in
                                              M.alloc (| Value.Tuple [] |)))
                                        ]
                                      |)))
                                  |)
                                |)
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ := M.read (| γ |) in
                            let γ1_0 :=
                              M.SubPointer.get_struct_record_field (|
                                γ,
                                "alloc::collections::btree::set::DifferenceInner::Search",
                                "self_iter"
                              |) in
                            let γ1_1 :=
                              M.SubPointer.get_struct_record_field (|
                                γ,
                                "alloc::collections::btree::set::DifferenceInner::Search",
                                "other_set"
                              |) in
                            let self_iter := M.alloc (| γ1_0 |) in
                            let other_set := M.alloc (| γ1_1 |) in
                            M.alloc (|
                              M.never_to_any (|
                                M.read (|
                                  M.loop (|
                                    ltac:(M.monadic
                                      (let~ self_next :=
                                        M.copy (|
                                          M.match_operator (|
                                            M.alloc (|
                                              M.call_closure (|
                                                M.get_trait_method (|
                                                  "core::ops::try_trait::Try",
                                                  Ty.apply
                                                    (Ty.path "core::option::Option")
                                                    []
                                                    [ Ty.apply (Ty.path "&") [] [ T ] ],
                                                  [],
                                                  "branch",
                                                  []
                                                |),
                                                [
                                                  M.call_closure (|
                                                    M.get_trait_method (|
                                                      "core::iter::traits::iterator::Iterator",
                                                      Ty.apply
                                                        (Ty.path
                                                          "alloc::collections::btree::set::Iter")
                                                        []
                                                        [ T ],
                                                      [],
                                                      "next",
                                                      []
                                                    |),
                                                    [ M.read (| self_iter |) ]
                                                  |)
                                                ]
                                              |)
                                            |),
                                            [
                                              fun γ =>
                                                ltac:(M.monadic
                                                  (let γ0_0 :=
                                                    M.SubPointer.get_struct_tuple_field (|
                                                      γ,
                                                      "core::ops::control_flow::ControlFlow::Break",
                                                      0
                                                    |) in
                                                  let residual := M.copy (| γ0_0 |) in
                                                  M.alloc (|
                                                    M.never_to_any (|
                                                      M.read (|
                                                        M.return_ (|
                                                          M.call_closure (|
                                                            M.get_trait_method (|
                                                              "core::ops::try_trait::FromResidual",
                                                              Ty.apply
                                                                (Ty.path "core::option::Option")
                                                                []
                                                                [ Ty.apply (Ty.path "&") [] [ T ] ],
                                                              [
                                                                Ty.apply
                                                                  (Ty.path "core::option::Option")
                                                                  []
                                                                  [
                                                                    Ty.path
                                                                      "core::convert::Infallible"
                                                                  ]
                                                              ],
                                                              "from_residual",
                                                              []
                                                            |),
                                                            [ M.read (| residual |) ]
                                                          |)
                                                        |)
                                                      |)
                                                    |)
                                                  |)));
                                              fun γ =>
                                                ltac:(M.monadic
                                                  (let γ0_0 :=
                                                    M.SubPointer.get_struct_tuple_field (|
                                                      γ,
                                                      "core::ops::control_flow::ControlFlow::Continue",
                                                      0
                                                    |) in
                                                  let val := M.copy (| γ0_0 |) in
                                                  val))
                                            ]
                                          |)
                                        |) in
                                      M.match_operator (|
                                        M.alloc (| Value.Tuple [] |),
                                        [
                                          fun γ =>
                                            ltac:(M.monadic
                                              (let γ :=
                                                M.use
                                                  (M.alloc (|
                                                    UnOp.Pure.not
                                                      (M.call_closure (|
                                                        M.get_associated_function (|
                                                          Ty.apply
                                                            (Ty.path
                                                              "alloc::collections::btree::set::BTreeSet")
                                                            []
                                                            [ T; A ],
                                                          "contains",
                                                          [ T ]
                                                        |),
                                                        [
                                                          M.read (| M.read (| other_set |) |);
                                                          M.read (| self_next |)
                                                        ]
                                                      |))
                                                  |)) in
                                              let _ :=
                                                M.is_constant_or_break_match (|
                                                  M.read (| γ |),
                                                  Value.Bool true
                                                |) in
                                              M.alloc (|
                                                M.never_to_any (|
                                                  M.read (|
                                                    M.return_ (|
                                                      Value.StructTuple
                                                        "core::option::Option::Some"
                                                        [ M.read (| self_next |) ]
                                                    |)
                                                  |)
                                                |)
                                              |)));
                                          fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                                        ]
                                      |)))
                                  |)
                                |)
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ := M.read (| γ |) in
                            let γ1_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "alloc::collections::btree::set::DifferenceInner::Iterate",
                                0
                              |) in
                            let iter := M.alloc (| γ1_0 |) in
                            M.alloc (|
                              M.call_closure (|
                                M.get_trait_method (|
                                  "core::iter::traits::iterator::Iterator",
                                  Ty.apply
                                    (Ty.path "alloc::collections::btree::set::Iter")
                                    []
                                    [ T ],
                                  [],
                                  "next",
                                  []
                                |),
                                [ M.read (| iter |) ]
                              |)
                            |)))
                      ]
                    |)
                  |)))
              |)))
          | _, _, _ => M.impossible
          end.
        
        (*
            fn size_hint(&self) -> (usize, Option<usize>) {
                let (self_len, other_len) = match &self.inner {
                    DifferenceInner::Stitch { self_iter, other_iter } => {
                        (self_iter.len(), other_iter.len())
                    }
                    DifferenceInner::Search { self_iter, other_set } => (self_iter.len(), other_set.len()),
                    DifferenceInner::Iterate(iter) => (iter.len(), 0),
                };
                (self_len.saturating_sub(other_len), Some(self_len))
            }
        *)
        Definition size_hint
            (T A : Ty.t)
            (ε : list Value.t)
            (τ : list Ty.t)
            (α : list Value.t)
            : M :=
          let Self : Ty.t := Self T A in
          match ε, τ, α with
          | [], [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              M.read (|
                M.match_operator (|
                  M.match_operator (|
                    M.alloc (|
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "alloc::collections::btree::set::Difference",
                        "inner"
                      |)
                    |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ := M.read (| γ |) in
                          let γ1_0 :=
                            M.SubPointer.get_struct_record_field (|
                              γ,
                              "alloc::collections::btree::set::DifferenceInner::Stitch",
                              "self_iter"
                            |) in
                          let γ1_1 :=
                            M.SubPointer.get_struct_record_field (|
                              γ,
                              "alloc::collections::btree::set::DifferenceInner::Stitch",
                              "other_iter"
                            |) in
                          let self_iter := M.alloc (| γ1_0 |) in
                          let other_iter := M.alloc (| γ1_1 |) in
                          M.alloc (|
                            Value.Tuple
                              [
                                M.call_closure (|
                                  M.get_trait_method (|
                                    "core::iter::traits::exact_size::ExactSizeIterator",
                                    Ty.apply
                                      (Ty.path "alloc::collections::btree::set::Iter")
                                      []
                                      [ T ],
                                    [],
                                    "len",
                                    []
                                  |),
                                  [ M.read (| self_iter |) ]
                                |);
                                M.call_closure (|
                                  M.get_trait_method (|
                                    "core::iter::traits::exact_size::ExactSizeIterator",
                                    Ty.apply
                                      (Ty.path "core::iter::adapters::peekable::Peekable")
                                      []
                                      [
                                        Ty.apply
                                          (Ty.path "alloc::collections::btree::set::Iter")
                                          []
                                          [ T ]
                                      ],
                                    [],
                                    "len",
                                    []
                                  |),
                                  [ M.read (| other_iter |) ]
                                |)
                              ]
                          |)));
                      fun γ =>
                        ltac:(M.monadic
                          (let γ := M.read (| γ |) in
                          let γ1_0 :=
                            M.SubPointer.get_struct_record_field (|
                              γ,
                              "alloc::collections::btree::set::DifferenceInner::Search",
                              "self_iter"
                            |) in
                          let γ1_1 :=
                            M.SubPointer.get_struct_record_field (|
                              γ,
                              "alloc::collections::btree::set::DifferenceInner::Search",
                              "other_set"
                            |) in
                          let self_iter := M.alloc (| γ1_0 |) in
                          let other_set := M.alloc (| γ1_1 |) in
                          M.alloc (|
                            Value.Tuple
                              [
                                M.call_closure (|
                                  M.get_trait_method (|
                                    "core::iter::traits::exact_size::ExactSizeIterator",
                                    Ty.apply
                                      (Ty.path "alloc::collections::btree::set::Iter")
                                      []
                                      [ T ],
                                    [],
                                    "len",
                                    []
                                  |),
                                  [ M.read (| self_iter |) ]
                                |);
                                M.call_closure (|
                                  M.get_associated_function (|
                                    Ty.apply
                                      (Ty.path "alloc::collections::btree::set::BTreeSet")
                                      []
                                      [ T; A ],
                                    "len",
                                    []
                                  |),
                                  [ M.read (| M.read (| other_set |) |) ]
                                |)
                              ]
                          |)));
                      fun γ =>
                        ltac:(M.monadic
                          (let γ := M.read (| γ |) in
                          let γ1_0 :=
                            M.SubPointer.get_struct_tuple_field (|
                              γ,
                              "alloc::collections::btree::set::DifferenceInner::Iterate",
                              0
                            |) in
                          let iter := M.alloc (| γ1_0 |) in
                          M.alloc (|
                            Value.Tuple
                              [
                                M.call_closure (|
                                  M.get_trait_method (|
                                    "core::iter::traits::exact_size::ExactSizeIterator",
                                    Ty.apply
                                      (Ty.path "alloc::collections::btree::set::Iter")
                                      []
                                      [ T ],
                                    [],
                                    "len",
                                    []
                                  |),
                                  [ M.read (| iter |) ]
                                |);
                                Value.Integer 0
                              ]
                          |)))
                    ]
                  |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                        let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                        let self_len := M.copy (| γ0_0 |) in
                        let other_len := M.copy (| γ0_1 |) in
                        M.alloc (|
                          Value.Tuple
                            [
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.path "usize",
                                  "saturating_sub",
                                  []
                                |),
                                [ M.read (| self_len |); M.read (| other_len |) ]
                              |);
                              Value.StructTuple
                                "core::option::Option::Some"
                                [ M.read (| self_len |) ]
                            ]
                        |)))
                  ]
                |)
              |)))
          | _, _, _ => M.impossible
          end.
        
        (*
            fn min(mut self) -> Option<&'a T> {
                self.next()
            }
        *)
        Definition min (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self T A in
          match ε, τ, α with
          | [], [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              M.call_closure (|
                M.get_trait_method (|
                  "core::iter::traits::iterator::Iterator",
                  Ty.apply (Ty.path "alloc::collections::btree::set::Difference") [] [ T; A ],
                  [],
                  "next",
                  []
                |),
                [ self ]
              |)))
          | _, _, _ => M.impossible
          end.
        
        Axiom Implements :
          forall (T A : Ty.t),
          M.IsTraitInstance
            "core::iter::traits::iterator::Iterator"
            (Self T A)
            (* Trait polymorphic types *) []
            (* Instance *)
            [
              ("Item", InstanceField.Ty (_Item T A));
              ("next", InstanceField.Method (next T A));
              ("size_hint", InstanceField.Method (size_hint T A));
              ("min", InstanceField.Method (min T A))
            ].
      End Impl_core_iter_traits_iterator_Iterator_where_core_cmp_Ord_T_where_core_alloc_Allocator_A_where_core_clone_Clone_A_for_alloc_collections_btree_set_Difference_T_A.
      
      Module Impl_core_iter_traits_marker_FusedIterator_where_core_cmp_Ord_T_where_core_alloc_Allocator_A_where_core_clone_Clone_A_for_alloc_collections_btree_set_Difference_T_A.
        Definition Self (T A : Ty.t) : Ty.t :=
          Ty.apply (Ty.path "alloc::collections::btree::set::Difference") [] [ T; A ].
        
        Axiom Implements :
          forall (T A : Ty.t),
          M.IsTraitInstance
            "core::iter::traits::marker::FusedIterator"
            (Self T A)
            (* Trait polymorphic types *) []
            (* Instance *) [].
      End Impl_core_iter_traits_marker_FusedIterator_where_core_cmp_Ord_T_where_core_alloc_Allocator_A_where_core_clone_Clone_A_for_alloc_collections_btree_set_Difference_T_A.
      
      Module Impl_core_clone_Clone_for_alloc_collections_btree_set_SymmetricDifference_T.
        Definition Self (T : Ty.t) : Ty.t :=
          Ty.apply (Ty.path "alloc::collections::btree::set::SymmetricDifference") [] [ T ].
        
        (*
            fn clone(&self) -> Self {
                SymmetricDifference(self.0.clone())
            }
        *)
        Definition clone (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self T in
          match ε, τ, α with
          | [], [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              Value.StructTuple
                "alloc::collections::btree::set::SymmetricDifference"
                [
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::clone::Clone",
                      Ty.apply
                        (Ty.path "alloc::collections::btree::merge_iter::MergeIterInner")
                        []
                        [ Ty.apply (Ty.path "alloc::collections::btree::set::Iter") [] [ T ] ],
                      [],
                      "clone",
                      []
                    |),
                    [
                      M.SubPointer.get_struct_tuple_field (|
                        M.read (| self |),
                        "alloc::collections::btree::set::SymmetricDifference",
                        0
                      |)
                    ]
                  |)
                ]))
          | _, _, _ => M.impossible
          end.
        
        Axiom Implements :
          forall (T : Ty.t),
          M.IsTraitInstance
            "core::clone::Clone"
            (Self T)
            (* Trait polymorphic types *) []
            (* Instance *) [ ("clone", InstanceField.Method (clone T)) ].
      End Impl_core_clone_Clone_for_alloc_collections_btree_set_SymmetricDifference_T.
      
      Module Impl_core_iter_traits_iterator_Iterator_where_core_cmp_Ord_T_for_alloc_collections_btree_set_SymmetricDifference_T.
        Definition Self (T : Ty.t) : Ty.t :=
          Ty.apply (Ty.path "alloc::collections::btree::set::SymmetricDifference") [] [ T ].
        
        (*     type Item = &'a T; *)
        Definition _Item (T : Ty.t) : Ty.t := Ty.apply (Ty.path "&") [] [ T ].
        
        (*
            fn next(&mut self) -> Option<&'a T> {
                loop {
                    let (a_next, b_next) = self.0.nexts(Self::Item::cmp);
                    if a_next.and(b_next).is_none() {
                        return a_next.or(b_next);
                    }
                }
            }
        *)
        Definition next (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self T in
          match ε, τ, α with
          | [], [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              M.catch_return (|
                ltac:(M.monadic
                  (M.never_to_any (|
                    M.read (|
                      M.loop (|
                        ltac:(M.monadic
                          (M.match_operator (|
                            M.alloc (|
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path
                                      "alloc::collections::btree::merge_iter::MergeIterInner")
                                    []
                                    [
                                      Ty.apply
                                        (Ty.path "alloc::collections::btree::set::Iter")
                                        []
                                        [ T ]
                                    ],
                                  "nexts",
                                  [
                                    Ty.function
                                      [
                                        Ty.apply
                                          (Ty.path "&")
                                          []
                                          [ Ty.apply (Ty.path "&") [] [ T ] ];
                                        Ty.apply
                                          (Ty.path "&")
                                          []
                                          [ Ty.apply (Ty.path "&") [] [ T ] ]
                                      ]
                                      (Ty.path "core::cmp::Ordering")
                                  ]
                                |),
                                [
                                  M.SubPointer.get_struct_tuple_field (|
                                    M.read (| self |),
                                    "alloc::collections::btree::set::SymmetricDifference",
                                    0
                                  |);
                                  M.get_trait_method (|
                                    "core::cmp::Ord",
                                    Ty.apply (Ty.path "&") [] [ T ],
                                    [],
                                    "cmp",
                                    []
                                  |)
                                ]
                              |)
                            |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                                  let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                  let a_next := M.copy (| γ0_0 |) in
                                  let b_next := M.copy (| γ0_1 |) in
                                  M.match_operator (|
                                    M.alloc (| Value.Tuple [] |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let γ :=
                                            M.use
                                              (M.alloc (|
                                                M.call_closure (|
                                                  M.get_associated_function (|
                                                    Ty.apply
                                                      (Ty.path "core::option::Option")
                                                      []
                                                      [ Ty.apply (Ty.path "&") [] [ T ] ],
                                                    "is_none",
                                                    []
                                                  |),
                                                  [
                                                    M.alloc (|
                                                      M.call_closure (|
                                                        M.get_associated_function (|
                                                          Ty.apply
                                                            (Ty.path "core::option::Option")
                                                            []
                                                            [ Ty.apply (Ty.path "&") [] [ T ] ],
                                                          "and",
                                                          [ Ty.apply (Ty.path "&") [] [ T ] ]
                                                        |),
                                                        [ M.read (| a_next |); M.read (| b_next |) ]
                                                      |)
                                                    |)
                                                  ]
                                                |)
                                              |)) in
                                          let _ :=
                                            M.is_constant_or_break_match (|
                                              M.read (| γ |),
                                              Value.Bool true
                                            |) in
                                          M.alloc (|
                                            M.never_to_any (|
                                              M.read (|
                                                M.return_ (|
                                                  M.call_closure (|
                                                    M.get_associated_function (|
                                                      Ty.apply
                                                        (Ty.path "core::option::Option")
                                                        []
                                                        [ Ty.apply (Ty.path "&") [] [ T ] ],
                                                      "or",
                                                      []
                                                    |),
                                                    [ M.read (| a_next |); M.read (| b_next |) ]
                                                  |)
                                                |)
                                              |)
                                            |)
                                          |)));
                                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                                    ]
                                  |)))
                            ]
                          |)))
                      |)
                    |)
                  |)))
              |)))
          | _, _, _ => M.impossible
          end.
        
        (*
            fn size_hint(&self) -> (usize, Option<usize>) {
                let (a_len, b_len) = self.0.lens();
                // No checked_add, because even if a and b refer to the same set,
                // and T is a zero-sized type, the storage overhead of sets limits
                // the number of elements to less than half the range of usize.
                (0, Some(a_len + b_len))
            }
        *)
        Definition size_hint (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self T in
          match ε, τ, α with
          | [], [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              M.read (|
                M.match_operator (|
                  M.alloc (|
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "alloc::collections::btree::merge_iter::MergeIterInner")
                          []
                          [ Ty.apply (Ty.path "alloc::collections::btree::set::Iter") [] [ T ] ],
                        "lens",
                        []
                      |),
                      [
                        M.SubPointer.get_struct_tuple_field (|
                          M.read (| self |),
                          "alloc::collections::btree::set::SymmetricDifference",
                          0
                        |)
                      ]
                    |)
                  |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                        let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                        let a_len := M.copy (| γ0_0 |) in
                        let b_len := M.copy (| γ0_1 |) in
                        M.alloc (|
                          Value.Tuple
                            [
                              Value.Integer 0;
                              Value.StructTuple
                                "core::option::Option::Some"
                                [
                                  BinOp.Wrap.add
                                    Integer.Usize
                                    (M.read (| a_len |))
                                    (M.read (| b_len |))
                                ]
                            ]
                        |)))
                  ]
                |)
              |)))
          | _, _, _ => M.impossible
          end.
        
        (*
            fn min(mut self) -> Option<&'a T> {
                self.next()
            }
        *)
        Definition min (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self T in
          match ε, τ, α with
          | [], [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              M.call_closure (|
                M.get_trait_method (|
                  "core::iter::traits::iterator::Iterator",
                  Ty.apply (Ty.path "alloc::collections::btree::set::SymmetricDifference") [] [ T ],
                  [],
                  "next",
                  []
                |),
                [ self ]
              |)))
          | _, _, _ => M.impossible
          end.
        
        Axiom Implements :
          forall (T : Ty.t),
          M.IsTraitInstance
            "core::iter::traits::iterator::Iterator"
            (Self T)
            (* Trait polymorphic types *) []
            (* Instance *)
            [
              ("Item", InstanceField.Ty (_Item T));
              ("next", InstanceField.Method (next T));
              ("size_hint", InstanceField.Method (size_hint T));
              ("min", InstanceField.Method (min T))
            ].
      End Impl_core_iter_traits_iterator_Iterator_where_core_cmp_Ord_T_for_alloc_collections_btree_set_SymmetricDifference_T.
      
      Module Impl_core_iter_traits_marker_FusedIterator_where_core_cmp_Ord_T_for_alloc_collections_btree_set_SymmetricDifference_T.
        Definition Self (T : Ty.t) : Ty.t :=
          Ty.apply (Ty.path "alloc::collections::btree::set::SymmetricDifference") [] [ T ].
        
        Axiom Implements :
          forall (T : Ty.t),
          M.IsTraitInstance
            "core::iter::traits::marker::FusedIterator"
            (Self T)
            (* Trait polymorphic types *) []
            (* Instance *) [].
      End Impl_core_iter_traits_marker_FusedIterator_where_core_cmp_Ord_T_for_alloc_collections_btree_set_SymmetricDifference_T.
      
      Module Impl_core_clone_Clone_where_core_alloc_Allocator_A_where_core_clone_Clone_A_for_alloc_collections_btree_set_Intersection_T_A.
        Definition Self (T A : Ty.t) : Ty.t :=
          Ty.apply (Ty.path "alloc::collections::btree::set::Intersection") [] [ T; A ].
        
        (*
            fn clone(&self) -> Self {
                Intersection {
                    inner: match &self.inner {
                        IntersectionInner::Stitch { a, b } => {
                            IntersectionInner::Stitch { a: a.clone(), b: b.clone() }
                        }
                        IntersectionInner::Search { small_iter, large_set } => {
                            IntersectionInner::Search { small_iter: small_iter.clone(), large_set }
                        }
                        IntersectionInner::Answer(answer) => IntersectionInner::Answer( *answer),
                    },
                }
            }
        *)
        Definition clone (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self T A in
          match ε, τ, α with
          | [], [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              Value.StructRecord
                "alloc::collections::btree::set::Intersection"
                [
                  ("inner",
                    M.read (|
                      M.match_operator (|
                        M.alloc (|
                          M.SubPointer.get_struct_record_field (|
                            M.read (| self |),
                            "alloc::collections::btree::set::Intersection",
                            "inner"
                          |)
                        |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ := M.read (| γ |) in
                              let γ1_0 :=
                                M.SubPointer.get_struct_record_field (|
                                  γ,
                                  "alloc::collections::btree::set::IntersectionInner::Stitch",
                                  "a"
                                |) in
                              let γ1_1 :=
                                M.SubPointer.get_struct_record_field (|
                                  γ,
                                  "alloc::collections::btree::set::IntersectionInner::Stitch",
                                  "b"
                                |) in
                              let a := M.alloc (| γ1_0 |) in
                              let b := M.alloc (| γ1_1 |) in
                              M.alloc (|
                                Value.StructRecord
                                  "alloc::collections::btree::set::IntersectionInner::Stitch"
                                  [
                                    ("a",
                                      M.call_closure (|
                                        M.get_trait_method (|
                                          "core::clone::Clone",
                                          Ty.apply
                                            (Ty.path "alloc::collections::btree::set::Iter")
                                            []
                                            [ T ],
                                          [],
                                          "clone",
                                          []
                                        |),
                                        [ M.read (| a |) ]
                                      |));
                                    ("b",
                                      M.call_closure (|
                                        M.get_trait_method (|
                                          "core::clone::Clone",
                                          Ty.apply
                                            (Ty.path "alloc::collections::btree::set::Iter")
                                            []
                                            [ T ],
                                          [],
                                          "clone",
                                          []
                                        |),
                                        [ M.read (| b |) ]
                                      |))
                                  ]
                              |)));
                          fun γ =>
                            ltac:(M.monadic
                              (let γ := M.read (| γ |) in
                              let γ1_0 :=
                                M.SubPointer.get_struct_record_field (|
                                  γ,
                                  "alloc::collections::btree::set::IntersectionInner::Search",
                                  "small_iter"
                                |) in
                              let γ1_1 :=
                                M.SubPointer.get_struct_record_field (|
                                  γ,
                                  "alloc::collections::btree::set::IntersectionInner::Search",
                                  "large_set"
                                |) in
                              let small_iter := M.alloc (| γ1_0 |) in
                              let large_set := M.alloc (| γ1_1 |) in
                              M.alloc (|
                                Value.StructRecord
                                  "alloc::collections::btree::set::IntersectionInner::Search"
                                  [
                                    ("small_iter",
                                      M.call_closure (|
                                        M.get_trait_method (|
                                          "core::clone::Clone",
                                          Ty.apply
                                            (Ty.path "alloc::collections::btree::set::Iter")
                                            []
                                            [ T ],
                                          [],
                                          "clone",
                                          []
                                        |),
                                        [ M.read (| small_iter |) ]
                                      |));
                                    ("large_set", M.read (| M.read (| large_set |) |))
                                  ]
                              |)));
                          fun γ =>
                            ltac:(M.monadic
                              (let γ := M.read (| γ |) in
                              let γ1_0 :=
                                M.SubPointer.get_struct_tuple_field (|
                                  γ,
                                  "alloc::collections::btree::set::IntersectionInner::Answer",
                                  0
                                |) in
                              let answer := M.alloc (| γ1_0 |) in
                              M.alloc (|
                                Value.StructTuple
                                  "alloc::collections::btree::set::IntersectionInner::Answer"
                                  [ M.read (| M.read (| answer |) |) ]
                              |)))
                        ]
                      |)
                    |))
                ]))
          | _, _, _ => M.impossible
          end.
        
        Axiom Implements :
          forall (T A : Ty.t),
          M.IsTraitInstance
            "core::clone::Clone"
            (Self T A)
            (* Trait polymorphic types *) []
            (* Instance *) [ ("clone", InstanceField.Method (clone T A)) ].
      End Impl_core_clone_Clone_where_core_alloc_Allocator_A_where_core_clone_Clone_A_for_alloc_collections_btree_set_Intersection_T_A.
      
      Module Impl_core_iter_traits_iterator_Iterator_where_core_cmp_Ord_T_where_core_alloc_Allocator_A_where_core_clone_Clone_A_for_alloc_collections_btree_set_Intersection_T_A.
        Definition Self (T A : Ty.t) : Ty.t :=
          Ty.apply (Ty.path "alloc::collections::btree::set::Intersection") [] [ T; A ].
        
        (*     type Item = &'a T; *)
        Definition _Item (T A : Ty.t) : Ty.t := Ty.apply (Ty.path "&") [] [ T ].
        
        (*
            fn next(&mut self) -> Option<&'a T> {
                match &mut self.inner {
                    IntersectionInner::Stitch { a, b } => {
                        let mut a_next = a.next()?;
                        let mut b_next = b.next()?;
                        loop {
                            match a_next.cmp(b_next) {
                                Less => a_next = a.next()?,
                                Greater => b_next = b.next()?,
                                Equal => return Some(a_next),
                            }
                        }
                    }
                    IntersectionInner::Search { small_iter, large_set } => loop {
                        let small_next = small_iter.next()?;
                        if large_set.contains(&small_next) {
                            return Some(small_next);
                        }
                    },
                    IntersectionInner::Answer(answer) => answer.take(),
                }
            }
        *)
        Definition next (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self T A in
          match ε, τ, α with
          | [], [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              M.catch_return (|
                ltac:(M.monadic
                  (M.read (|
                    M.match_operator (|
                      M.alloc (|
                        M.SubPointer.get_struct_record_field (|
                          M.read (| self |),
                          "alloc::collections::btree::set::Intersection",
                          "inner"
                        |)
                      |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ := M.read (| γ |) in
                            let γ1_0 :=
                              M.SubPointer.get_struct_record_field (|
                                γ,
                                "alloc::collections::btree::set::IntersectionInner::Stitch",
                                "a"
                              |) in
                            let γ1_1 :=
                              M.SubPointer.get_struct_record_field (|
                                γ,
                                "alloc::collections::btree::set::IntersectionInner::Stitch",
                                "b"
                              |) in
                            let a := M.alloc (| γ1_0 |) in
                            let b := M.alloc (| γ1_1 |) in
                            let~ a_next :=
                              M.copy (|
                                M.match_operator (|
                                  M.alloc (|
                                    M.call_closure (|
                                      M.get_trait_method (|
                                        "core::ops::try_trait::Try",
                                        Ty.apply
                                          (Ty.path "core::option::Option")
                                          []
                                          [ Ty.apply (Ty.path "&") [] [ T ] ],
                                        [],
                                        "branch",
                                        []
                                      |),
                                      [
                                        M.call_closure (|
                                          M.get_trait_method (|
                                            "core::iter::traits::iterator::Iterator",
                                            Ty.apply
                                              (Ty.path "alloc::collections::btree::set::Iter")
                                              []
                                              [ T ],
                                            [],
                                            "next",
                                            []
                                          |),
                                          [ M.read (| a |) ]
                                        |)
                                      ]
                                    |)
                                  |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ0_0 :=
                                          M.SubPointer.get_struct_tuple_field (|
                                            γ,
                                            "core::ops::control_flow::ControlFlow::Break",
                                            0
                                          |) in
                                        let residual := M.copy (| γ0_0 |) in
                                        M.alloc (|
                                          M.never_to_any (|
                                            M.read (|
                                              M.return_ (|
                                                M.call_closure (|
                                                  M.get_trait_method (|
                                                    "core::ops::try_trait::FromResidual",
                                                    Ty.apply
                                                      (Ty.path "core::option::Option")
                                                      []
                                                      [ Ty.apply (Ty.path "&") [] [ T ] ],
                                                    [
                                                      Ty.apply
                                                        (Ty.path "core::option::Option")
                                                        []
                                                        [ Ty.path "core::convert::Infallible" ]
                                                    ],
                                                    "from_residual",
                                                    []
                                                  |),
                                                  [ M.read (| residual |) ]
                                                |)
                                              |)
                                            |)
                                          |)
                                        |)));
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ0_0 :=
                                          M.SubPointer.get_struct_tuple_field (|
                                            γ,
                                            "core::ops::control_flow::ControlFlow::Continue",
                                            0
                                          |) in
                                        let val := M.copy (| γ0_0 |) in
                                        val))
                                  ]
                                |)
                              |) in
                            let~ b_next :=
                              M.copy (|
                                M.match_operator (|
                                  M.alloc (|
                                    M.call_closure (|
                                      M.get_trait_method (|
                                        "core::ops::try_trait::Try",
                                        Ty.apply
                                          (Ty.path "core::option::Option")
                                          []
                                          [ Ty.apply (Ty.path "&") [] [ T ] ],
                                        [],
                                        "branch",
                                        []
                                      |),
                                      [
                                        M.call_closure (|
                                          M.get_trait_method (|
                                            "core::iter::traits::iterator::Iterator",
                                            Ty.apply
                                              (Ty.path "alloc::collections::btree::set::Iter")
                                              []
                                              [ T ],
                                            [],
                                            "next",
                                            []
                                          |),
                                          [ M.read (| b |) ]
                                        |)
                                      ]
                                    |)
                                  |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ0_0 :=
                                          M.SubPointer.get_struct_tuple_field (|
                                            γ,
                                            "core::ops::control_flow::ControlFlow::Break",
                                            0
                                          |) in
                                        let residual := M.copy (| γ0_0 |) in
                                        M.alloc (|
                                          M.never_to_any (|
                                            M.read (|
                                              M.return_ (|
                                                M.call_closure (|
                                                  M.get_trait_method (|
                                                    "core::ops::try_trait::FromResidual",
                                                    Ty.apply
                                                      (Ty.path "core::option::Option")
                                                      []
                                                      [ Ty.apply (Ty.path "&") [] [ T ] ],
                                                    [
                                                      Ty.apply
                                                        (Ty.path "core::option::Option")
                                                        []
                                                        [ Ty.path "core::convert::Infallible" ]
                                                    ],
                                                    "from_residual",
                                                    []
                                                  |),
                                                  [ M.read (| residual |) ]
                                                |)
                                              |)
                                            |)
                                          |)
                                        |)));
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ0_0 :=
                                          M.SubPointer.get_struct_tuple_field (|
                                            γ,
                                            "core::ops::control_flow::ControlFlow::Continue",
                                            0
                                          |) in
                                        let val := M.copy (| γ0_0 |) in
                                        val))
                                  ]
                                |)
                              |) in
                            M.alloc (|
                              M.never_to_any (|
                                M.read (|
                                  M.loop (|
                                    ltac:(M.monadic
                                      (M.match_operator (|
                                        M.alloc (|
                                          M.call_closure (|
                                            M.get_trait_method (|
                                              "core::cmp::Ord",
                                              T,
                                              [],
                                              "cmp",
                                              []
                                            |),
                                            [ M.read (| a_next |); M.read (| b_next |) ]
                                          |)
                                        |),
                                        [
                                          fun γ =>
                                            ltac:(M.monadic
                                              (let _ :=
                                                M.is_struct_tuple (|
                                                  γ,
                                                  "core::cmp::Ordering::Less"
                                                |) in
                                              M.write (|
                                                a_next,
                                                M.read (|
                                                  M.match_operator (|
                                                    M.alloc (|
                                                      M.call_closure (|
                                                        M.get_trait_method (|
                                                          "core::ops::try_trait::Try",
                                                          Ty.apply
                                                            (Ty.path "core::option::Option")
                                                            []
                                                            [ Ty.apply (Ty.path "&") [] [ T ] ],
                                                          [],
                                                          "branch",
                                                          []
                                                        |),
                                                        [
                                                          M.call_closure (|
                                                            M.get_trait_method (|
                                                              "core::iter::traits::iterator::Iterator",
                                                              Ty.apply
                                                                (Ty.path
                                                                  "alloc::collections::btree::set::Iter")
                                                                []
                                                                [ T ],
                                                              [],
                                                              "next",
                                                              []
                                                            |),
                                                            [ M.read (| a |) ]
                                                          |)
                                                        ]
                                                      |)
                                                    |),
                                                    [
                                                      fun γ =>
                                                        ltac:(M.monadic
                                                          (let γ0_0 :=
                                                            M.SubPointer.get_struct_tuple_field (|
                                                              γ,
                                                              "core::ops::control_flow::ControlFlow::Break",
                                                              0
                                                            |) in
                                                          let residual := M.copy (| γ0_0 |) in
                                                          M.alloc (|
                                                            M.never_to_any (|
                                                              M.read (|
                                                                M.return_ (|
                                                                  M.call_closure (|
                                                                    M.get_trait_method (|
                                                                      "core::ops::try_trait::FromResidual",
                                                                      Ty.apply
                                                                        (Ty.path
                                                                          "core::option::Option")
                                                                        []
                                                                        [
                                                                          Ty.apply
                                                                            (Ty.path "&")
                                                                            []
                                                                            [ T ]
                                                                        ],
                                                                      [
                                                                        Ty.apply
                                                                          (Ty.path
                                                                            "core::option::Option")
                                                                          []
                                                                          [
                                                                            Ty.path
                                                                              "core::convert::Infallible"
                                                                          ]
                                                                      ],
                                                                      "from_residual",
                                                                      []
                                                                    |),
                                                                    [ M.read (| residual |) ]
                                                                  |)
                                                                |)
                                                              |)
                                                            |)
                                                          |)));
                                                      fun γ =>
                                                        ltac:(M.monadic
                                                          (let γ0_0 :=
                                                            M.SubPointer.get_struct_tuple_field (|
                                                              γ,
                                                              "core::ops::control_flow::ControlFlow::Continue",
                                                              0
                                                            |) in
                                                          let val := M.copy (| γ0_0 |) in
                                                          M.alloc (| M.read (| val |) |)))
                                                    ]
                                                  |)
                                                |)
                                              |)));
                                          fun γ =>
                                            ltac:(M.monadic
                                              (let _ :=
                                                M.is_struct_tuple (|
                                                  γ,
                                                  "core::cmp::Ordering::Greater"
                                                |) in
                                              M.write (|
                                                b_next,
                                                M.read (|
                                                  M.match_operator (|
                                                    M.alloc (|
                                                      M.call_closure (|
                                                        M.get_trait_method (|
                                                          "core::ops::try_trait::Try",
                                                          Ty.apply
                                                            (Ty.path "core::option::Option")
                                                            []
                                                            [ Ty.apply (Ty.path "&") [] [ T ] ],
                                                          [],
                                                          "branch",
                                                          []
                                                        |),
                                                        [
                                                          M.call_closure (|
                                                            M.get_trait_method (|
                                                              "core::iter::traits::iterator::Iterator",
                                                              Ty.apply
                                                                (Ty.path
                                                                  "alloc::collections::btree::set::Iter")
                                                                []
                                                                [ T ],
                                                              [],
                                                              "next",
                                                              []
                                                            |),
                                                            [ M.read (| b |) ]
                                                          |)
                                                        ]
                                                      |)
                                                    |),
                                                    [
                                                      fun γ =>
                                                        ltac:(M.monadic
                                                          (let γ0_0 :=
                                                            M.SubPointer.get_struct_tuple_field (|
                                                              γ,
                                                              "core::ops::control_flow::ControlFlow::Break",
                                                              0
                                                            |) in
                                                          let residual := M.copy (| γ0_0 |) in
                                                          M.alloc (|
                                                            M.never_to_any (|
                                                              M.read (|
                                                                M.return_ (|
                                                                  M.call_closure (|
                                                                    M.get_trait_method (|
                                                                      "core::ops::try_trait::FromResidual",
                                                                      Ty.apply
                                                                        (Ty.path
                                                                          "core::option::Option")
                                                                        []
                                                                        [
                                                                          Ty.apply
                                                                            (Ty.path "&")
                                                                            []
                                                                            [ T ]
                                                                        ],
                                                                      [
                                                                        Ty.apply
                                                                          (Ty.path
                                                                            "core::option::Option")
                                                                          []
                                                                          [
                                                                            Ty.path
                                                                              "core::convert::Infallible"
                                                                          ]
                                                                      ],
                                                                      "from_residual",
                                                                      []
                                                                    |),
                                                                    [ M.read (| residual |) ]
                                                                  |)
                                                                |)
                                                              |)
                                                            |)
                                                          |)));
                                                      fun γ =>
                                                        ltac:(M.monadic
                                                          (let γ0_0 :=
                                                            M.SubPointer.get_struct_tuple_field (|
                                                              γ,
                                                              "core::ops::control_flow::ControlFlow::Continue",
                                                              0
                                                            |) in
                                                          let val := M.copy (| γ0_0 |) in
                                                          M.alloc (| M.read (| val |) |)))
                                                    ]
                                                  |)
                                                |)
                                              |)));
                                          fun γ =>
                                            ltac:(M.monadic
                                              (let _ :=
                                                M.is_struct_tuple (|
                                                  γ,
                                                  "core::cmp::Ordering::Equal"
                                                |) in
                                              M.alloc (|
                                                M.never_to_any (|
                                                  M.read (|
                                                    M.return_ (|
                                                      Value.StructTuple
                                                        "core::option::Option::Some"
                                                        [ M.read (| a_next |) ]
                                                    |)
                                                  |)
                                                |)
                                              |)))
                                        ]
                                      |)))
                                  |)
                                |)
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ := M.read (| γ |) in
                            let γ1_0 :=
                              M.SubPointer.get_struct_record_field (|
                                γ,
                                "alloc::collections::btree::set::IntersectionInner::Search",
                                "small_iter"
                              |) in
                            let γ1_1 :=
                              M.SubPointer.get_struct_record_field (|
                                γ,
                                "alloc::collections::btree::set::IntersectionInner::Search",
                                "large_set"
                              |) in
                            let small_iter := M.alloc (| γ1_0 |) in
                            let large_set := M.alloc (| γ1_1 |) in
                            M.alloc (|
                              M.never_to_any (|
                                M.read (|
                                  M.loop (|
                                    ltac:(M.monadic
                                      (let~ small_next :=
                                        M.copy (|
                                          M.match_operator (|
                                            M.alloc (|
                                              M.call_closure (|
                                                M.get_trait_method (|
                                                  "core::ops::try_trait::Try",
                                                  Ty.apply
                                                    (Ty.path "core::option::Option")
                                                    []
                                                    [ Ty.apply (Ty.path "&") [] [ T ] ],
                                                  [],
                                                  "branch",
                                                  []
                                                |),
                                                [
                                                  M.call_closure (|
                                                    M.get_trait_method (|
                                                      "core::iter::traits::iterator::Iterator",
                                                      Ty.apply
                                                        (Ty.path
                                                          "alloc::collections::btree::set::Iter")
                                                        []
                                                        [ T ],
                                                      [],
                                                      "next",
                                                      []
                                                    |),
                                                    [ M.read (| small_iter |) ]
                                                  |)
                                                ]
                                              |)
                                            |),
                                            [
                                              fun γ =>
                                                ltac:(M.monadic
                                                  (let γ0_0 :=
                                                    M.SubPointer.get_struct_tuple_field (|
                                                      γ,
                                                      "core::ops::control_flow::ControlFlow::Break",
                                                      0
                                                    |) in
                                                  let residual := M.copy (| γ0_0 |) in
                                                  M.alloc (|
                                                    M.never_to_any (|
                                                      M.read (|
                                                        M.return_ (|
                                                          M.call_closure (|
                                                            M.get_trait_method (|
                                                              "core::ops::try_trait::FromResidual",
                                                              Ty.apply
                                                                (Ty.path "core::option::Option")
                                                                []
                                                                [ Ty.apply (Ty.path "&") [] [ T ] ],
                                                              [
                                                                Ty.apply
                                                                  (Ty.path "core::option::Option")
                                                                  []
                                                                  [
                                                                    Ty.path
                                                                      "core::convert::Infallible"
                                                                  ]
                                                              ],
                                                              "from_residual",
                                                              []
                                                            |),
                                                            [ M.read (| residual |) ]
                                                          |)
                                                        |)
                                                      |)
                                                    |)
                                                  |)));
                                              fun γ =>
                                                ltac:(M.monadic
                                                  (let γ0_0 :=
                                                    M.SubPointer.get_struct_tuple_field (|
                                                      γ,
                                                      "core::ops::control_flow::ControlFlow::Continue",
                                                      0
                                                    |) in
                                                  let val := M.copy (| γ0_0 |) in
                                                  val))
                                            ]
                                          |)
                                        |) in
                                      M.match_operator (|
                                        M.alloc (| Value.Tuple [] |),
                                        [
                                          fun γ =>
                                            ltac:(M.monadic
                                              (let γ :=
                                                M.use
                                                  (M.alloc (|
                                                    M.call_closure (|
                                                      M.get_associated_function (|
                                                        Ty.apply
                                                          (Ty.path
                                                            "alloc::collections::btree::set::BTreeSet")
                                                          []
                                                          [ T; A ],
                                                        "contains",
                                                        [ T ]
                                                      |),
                                                      [
                                                        M.read (| M.read (| large_set |) |);
                                                        M.read (| small_next |)
                                                      ]
                                                    |)
                                                  |)) in
                                              let _ :=
                                                M.is_constant_or_break_match (|
                                                  M.read (| γ |),
                                                  Value.Bool true
                                                |) in
                                              M.alloc (|
                                                M.never_to_any (|
                                                  M.read (|
                                                    M.return_ (|
                                                      Value.StructTuple
                                                        "core::option::Option::Some"
                                                        [ M.read (| small_next |) ]
                                                    |)
                                                  |)
                                                |)
                                              |)));
                                          fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                                        ]
                                      |)))
                                  |)
                                |)
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ := M.read (| γ |) in
                            let γ1_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "alloc::collections::btree::set::IntersectionInner::Answer",
                                0
                              |) in
                            let answer := M.alloc (| γ1_0 |) in
                            M.alloc (|
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "core::option::Option")
                                    []
                                    [ Ty.apply (Ty.path "&") [] [ T ] ],
                                  "take",
                                  []
                                |),
                                [ M.read (| answer |) ]
                              |)
                            |)))
                      ]
                    |)
                  |)))
              |)))
          | _, _, _ => M.impossible
          end.
        
        (*
            fn size_hint(&self) -> (usize, Option<usize>) {
                match &self.inner {
                    IntersectionInner::Stitch { a, b } => (0, Some(min(a.len(), b.len()))),
                    IntersectionInner::Search { small_iter, .. } => (0, Some(small_iter.len())),
                    IntersectionInner::Answer(None) => (0, Some(0)),
                    IntersectionInner::Answer(Some(_)) => (1, Some(1)),
                }
            }
        *)
        Definition size_hint
            (T A : Ty.t)
            (ε : list Value.t)
            (τ : list Ty.t)
            (α : list Value.t)
            : M :=
          let Self : Ty.t := Self T A in
          match ε, τ, α with
          | [], [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              M.read (|
                M.match_operator (|
                  M.alloc (|
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "alloc::collections::btree::set::Intersection",
                      "inner"
                    |)
                  |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        let γ1_0 :=
                          M.SubPointer.get_struct_record_field (|
                            γ,
                            "alloc::collections::btree::set::IntersectionInner::Stitch",
                            "a"
                          |) in
                        let γ1_1 :=
                          M.SubPointer.get_struct_record_field (|
                            γ,
                            "alloc::collections::btree::set::IntersectionInner::Stitch",
                            "b"
                          |) in
                        let a := M.alloc (| γ1_0 |) in
                        let b := M.alloc (| γ1_1 |) in
                        M.alloc (|
                          Value.Tuple
                            [
                              Value.Integer 0;
                              Value.StructTuple
                                "core::option::Option::Some"
                                [
                                  M.call_closure (|
                                    M.get_function (| "core::cmp::min", [ Ty.path "usize" ] |),
                                    [
                                      M.call_closure (|
                                        M.get_trait_method (|
                                          "core::iter::traits::exact_size::ExactSizeIterator",
                                          Ty.apply
                                            (Ty.path "alloc::collections::btree::set::Iter")
                                            []
                                            [ T ],
                                          [],
                                          "len",
                                          []
                                        |),
                                        [ M.read (| a |) ]
                                      |);
                                      M.call_closure (|
                                        M.get_trait_method (|
                                          "core::iter::traits::exact_size::ExactSizeIterator",
                                          Ty.apply
                                            (Ty.path "alloc::collections::btree::set::Iter")
                                            []
                                            [ T ],
                                          [],
                                          "len",
                                          []
                                        |),
                                        [ M.read (| b |) ]
                                      |)
                                    ]
                                  |)
                                ]
                            ]
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        let γ1_0 :=
                          M.SubPointer.get_struct_record_field (|
                            γ,
                            "alloc::collections::btree::set::IntersectionInner::Search",
                            "small_iter"
                          |) in
                        let small_iter := M.alloc (| γ1_0 |) in
                        M.alloc (|
                          Value.Tuple
                            [
                              Value.Integer 0;
                              Value.StructTuple
                                "core::option::Option::Some"
                                [
                                  M.call_closure (|
                                    M.get_trait_method (|
                                      "core::iter::traits::exact_size::ExactSizeIterator",
                                      Ty.apply
                                        (Ty.path "alloc::collections::btree::set::Iter")
                                        []
                                        [ T ],
                                      [],
                                      "len",
                                      []
                                    |),
                                    [ M.read (| small_iter |) ]
                                  |)
                                ]
                            ]
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        let γ1_0 :=
                          M.SubPointer.get_struct_tuple_field (|
                            γ,
                            "alloc::collections::btree::set::IntersectionInner::Answer",
                            0
                          |) in
                        let _ := M.is_struct_tuple (| γ1_0, "core::option::Option::None" |) in
                        M.alloc (|
                          Value.Tuple
                            [
                              Value.Integer 0;
                              Value.StructTuple "core::option::Option::Some" [ Value.Integer 0 ]
                            ]
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        let γ1_0 :=
                          M.SubPointer.get_struct_tuple_field (|
                            γ,
                            "alloc::collections::btree::set::IntersectionInner::Answer",
                            0
                          |) in
                        let γ2_0 :=
                          M.SubPointer.get_struct_tuple_field (|
                            γ1_0,
                            "core::option::Option::Some",
                            0
                          |) in
                        M.alloc (|
                          Value.Tuple
                            [
                              Value.Integer 1;
                              Value.StructTuple "core::option::Option::Some" [ Value.Integer 1 ]
                            ]
                        |)))
                  ]
                |)
              |)))
          | _, _, _ => M.impossible
          end.
        
        (*
            fn min(mut self) -> Option<&'a T> {
                self.next()
            }
        *)
        Definition min (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self T A in
          match ε, τ, α with
          | [], [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              M.call_closure (|
                M.get_trait_method (|
                  "core::iter::traits::iterator::Iterator",
                  Ty.apply (Ty.path "alloc::collections::btree::set::Intersection") [] [ T; A ],
                  [],
                  "next",
                  []
                |),
                [ self ]
              |)))
          | _, _, _ => M.impossible
          end.
        
        Axiom Implements :
          forall (T A : Ty.t),
          M.IsTraitInstance
            "core::iter::traits::iterator::Iterator"
            (Self T A)
            (* Trait polymorphic types *) []
            (* Instance *)
            [
              ("Item", InstanceField.Ty (_Item T A));
              ("next", InstanceField.Method (next T A));
              ("size_hint", InstanceField.Method (size_hint T A));
              ("min", InstanceField.Method (min T A))
            ].
      End Impl_core_iter_traits_iterator_Iterator_where_core_cmp_Ord_T_where_core_alloc_Allocator_A_where_core_clone_Clone_A_for_alloc_collections_btree_set_Intersection_T_A.
      
      Module Impl_core_iter_traits_marker_FusedIterator_where_core_cmp_Ord_T_where_core_alloc_Allocator_A_where_core_clone_Clone_A_for_alloc_collections_btree_set_Intersection_T_A.
        Definition Self (T A : Ty.t) : Ty.t :=
          Ty.apply (Ty.path "alloc::collections::btree::set::Intersection") [] [ T; A ].
        
        Axiom Implements :
          forall (T A : Ty.t),
          M.IsTraitInstance
            "core::iter::traits::marker::FusedIterator"
            (Self T A)
            (* Trait polymorphic types *) []
            (* Instance *) [].
      End Impl_core_iter_traits_marker_FusedIterator_where_core_cmp_Ord_T_where_core_alloc_Allocator_A_where_core_clone_Clone_A_for_alloc_collections_btree_set_Intersection_T_A.
      
      Module Impl_core_clone_Clone_for_alloc_collections_btree_set_Union_T.
        Definition Self (T : Ty.t) : Ty.t :=
          Ty.apply (Ty.path "alloc::collections::btree::set::Union") [] [ T ].
        
        (*
            fn clone(&self) -> Self {
                Union(self.0.clone())
            }
        *)
        Definition clone (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self T in
          match ε, τ, α with
          | [], [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              Value.StructTuple
                "alloc::collections::btree::set::Union"
                [
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::clone::Clone",
                      Ty.apply
                        (Ty.path "alloc::collections::btree::merge_iter::MergeIterInner")
                        []
                        [ Ty.apply (Ty.path "alloc::collections::btree::set::Iter") [] [ T ] ],
                      [],
                      "clone",
                      []
                    |),
                    [
                      M.SubPointer.get_struct_tuple_field (|
                        M.read (| self |),
                        "alloc::collections::btree::set::Union",
                        0
                      |)
                    ]
                  |)
                ]))
          | _, _, _ => M.impossible
          end.
        
        Axiom Implements :
          forall (T : Ty.t),
          M.IsTraitInstance
            "core::clone::Clone"
            (Self T)
            (* Trait polymorphic types *) []
            (* Instance *) [ ("clone", InstanceField.Method (clone T)) ].
      End Impl_core_clone_Clone_for_alloc_collections_btree_set_Union_T.
      
      Module Impl_core_iter_traits_iterator_Iterator_where_core_cmp_Ord_T_for_alloc_collections_btree_set_Union_T.
        Definition Self (T : Ty.t) : Ty.t :=
          Ty.apply (Ty.path "alloc::collections::btree::set::Union") [] [ T ].
        
        (*     type Item = &'a T; *)
        Definition _Item (T : Ty.t) : Ty.t := Ty.apply (Ty.path "&") [] [ T ].
        
        (*
            fn next(&mut self) -> Option<&'a T> {
                let (a_next, b_next) = self.0.nexts(Self::Item::cmp);
                a_next.or(b_next)
            }
        *)
        Definition next (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self T in
          match ε, τ, α with
          | [], [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              M.read (|
                M.match_operator (|
                  M.alloc (|
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "alloc::collections::btree::merge_iter::MergeIterInner")
                          []
                          [ Ty.apply (Ty.path "alloc::collections::btree::set::Iter") [] [ T ] ],
                        "nexts",
                        [
                          Ty.function
                            [
                              Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "&") [] [ T ] ];
                              Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "&") [] [ T ] ]
                            ]
                            (Ty.path "core::cmp::Ordering")
                        ]
                      |),
                      [
                        M.SubPointer.get_struct_tuple_field (|
                          M.read (| self |),
                          "alloc::collections::btree::set::Union",
                          0
                        |);
                        M.get_trait_method (|
                          "core::cmp::Ord",
                          Ty.apply (Ty.path "&") [] [ T ],
                          [],
                          "cmp",
                          []
                        |)
                      ]
                    |)
                  |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                        let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                        let a_next := M.copy (| γ0_0 |) in
                        let b_next := M.copy (| γ0_1 |) in
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply
                                (Ty.path "core::option::Option")
                                []
                                [ Ty.apply (Ty.path "&") [] [ T ] ],
                              "or",
                              []
                            |),
                            [ M.read (| a_next |); M.read (| b_next |) ]
                          |)
                        |)))
                  ]
                |)
              |)))
          | _, _, _ => M.impossible
          end.
        
        (*
            fn size_hint(&self) -> (usize, Option<usize>) {
                let (a_len, b_len) = self.0.lens();
                // No checked_add - see SymmetricDifference::size_hint.
                (max(a_len, b_len), Some(a_len + b_len))
            }
        *)
        Definition size_hint (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self T in
          match ε, τ, α with
          | [], [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              M.read (|
                M.match_operator (|
                  M.alloc (|
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "alloc::collections::btree::merge_iter::MergeIterInner")
                          []
                          [ Ty.apply (Ty.path "alloc::collections::btree::set::Iter") [] [ T ] ],
                        "lens",
                        []
                      |),
                      [
                        M.SubPointer.get_struct_tuple_field (|
                          M.read (| self |),
                          "alloc::collections::btree::set::Union",
                          0
                        |)
                      ]
                    |)
                  |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                        let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                        let a_len := M.copy (| γ0_0 |) in
                        let b_len := M.copy (| γ0_1 |) in
                        M.alloc (|
                          Value.Tuple
                            [
                              M.call_closure (|
                                M.get_function (| "core::cmp::max", [ Ty.path "usize" ] |),
                                [ M.read (| a_len |); M.read (| b_len |) ]
                              |);
                              Value.StructTuple
                                "core::option::Option::Some"
                                [
                                  BinOp.Wrap.add
                                    Integer.Usize
                                    (M.read (| a_len |))
                                    (M.read (| b_len |))
                                ]
                            ]
                        |)))
                  ]
                |)
              |)))
          | _, _, _ => M.impossible
          end.
        
        (*
            fn min(mut self) -> Option<&'a T> {
                self.next()
            }
        *)
        Definition min (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self T in
          match ε, τ, α with
          | [], [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              M.call_closure (|
                M.get_trait_method (|
                  "core::iter::traits::iterator::Iterator",
                  Ty.apply (Ty.path "alloc::collections::btree::set::Union") [] [ T ],
                  [],
                  "next",
                  []
                |),
                [ self ]
              |)))
          | _, _, _ => M.impossible
          end.
        
        Axiom Implements :
          forall (T : Ty.t),
          M.IsTraitInstance
            "core::iter::traits::iterator::Iterator"
            (Self T)
            (* Trait polymorphic types *) []
            (* Instance *)
            [
              ("Item", InstanceField.Ty (_Item T));
              ("next", InstanceField.Method (next T));
              ("size_hint", InstanceField.Method (size_hint T));
              ("min", InstanceField.Method (min T))
            ].
      End Impl_core_iter_traits_iterator_Iterator_where_core_cmp_Ord_T_for_alloc_collections_btree_set_Union_T.
      
      Module Impl_core_iter_traits_marker_FusedIterator_where_core_cmp_Ord_T_for_alloc_collections_btree_set_Union_T.
        Definition Self (T : Ty.t) : Ty.t :=
          Ty.apply (Ty.path "alloc::collections::btree::set::Union") [] [ T ].
        
        Axiom Implements :
          forall (T : Ty.t),
          M.IsTraitInstance
            "core::iter::traits::marker::FusedIterator"
            (Self T)
            (* Trait polymorphic types *) []
            (* Instance *) [].
      End Impl_core_iter_traits_marker_FusedIterator_where_core_cmp_Ord_T_for_alloc_collections_btree_set_Union_T.
      
      (* StructRecord
        {
          name := "Cursor";
          const_params := [];
          ty_params := [ "K" ];
          fields :=
            [
              ("inner",
                Ty.apply
                  (Ty.path "alloc::collections::btree::map::Cursor")
                  []
                  [ K; Ty.path "alloc::collections::btree::set_val::SetValZST" ])
            ];
        } *)
      
      Module Impl_core_clone_Clone_where_core_clone_Clone_K_for_alloc_collections_btree_set_Cursor_K.
        Definition Self (K : Ty.t) : Ty.t :=
          Ty.apply (Ty.path "alloc::collections::btree::set::Cursor") [] [ K ].
        
        (* Clone *)
        Definition clone (K : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self K in
          match ε, τ, α with
          | [], [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              Value.StructRecord
                "alloc::collections::btree::set::Cursor"
                [
                  ("inner",
                    M.call_closure (|
                      M.get_trait_method (|
                        "core::clone::Clone",
                        Ty.apply
                          (Ty.path "alloc::collections::btree::map::Cursor")
                          []
                          [ K; Ty.path "alloc::collections::btree::set_val::SetValZST" ],
                        [],
                        "clone",
                        []
                      |),
                      [
                        M.SubPointer.get_struct_record_field (|
                          M.read (| self |),
                          "alloc::collections::btree::set::Cursor",
                          "inner"
                        |)
                      ]
                    |))
                ]))
          | _, _, _ => M.impossible
          end.
        
        Axiom Implements :
          forall (K : Ty.t),
          M.IsTraitInstance
            "core::clone::Clone"
            (Self K)
            (* Trait polymorphic types *) []
            (* Instance *) [ ("clone", InstanceField.Method (clone K)) ].
      End Impl_core_clone_Clone_where_core_clone_Clone_K_for_alloc_collections_btree_set_Cursor_K.
      
      Module Impl_core_fmt_Debug_where_core_fmt_Debug_K_for_alloc_collections_btree_set_Cursor_K.
        Definition Self (K : Ty.t) : Ty.t :=
          Ty.apply (Ty.path "alloc::collections::btree::set::Cursor") [] [ K ].
        
        (*
            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                f.write_str("Cursor")
            }
        *)
        Definition fmt (K : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self K in
          match ε, τ, α with
          | [], [], [ self; f ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let f := M.alloc (| f |) in
              M.call_closure (|
                M.get_associated_function (| Ty.path "core::fmt::Formatter", "write_str", [] |),
                [ M.read (| f |); M.read (| Value.String "Cursor" |) ]
              |)))
          | _, _, _ => M.impossible
          end.
        
        Axiom Implements :
          forall (K : Ty.t),
          M.IsTraitInstance
            "core::fmt::Debug"
            (Self K)
            (* Trait polymorphic types *) []
            (* Instance *) [ ("fmt", InstanceField.Method (fmt K)) ].
      End Impl_core_fmt_Debug_where_core_fmt_Debug_K_for_alloc_collections_btree_set_Cursor_K.
      
      (* StructRecord
        {
          name := "CursorMut";
          const_params := [];
          ty_params := [ "K"; "A" ];
          fields :=
            [
              ("inner",
                Ty.apply
                  (Ty.path "alloc::collections::btree::map::CursorMut")
                  []
                  [ K; Ty.path "alloc::collections::btree::set_val::SetValZST"; A ])
            ];
        } *)
      
      Module Impl_core_fmt_Debug_where_core_fmt_Debug_K_for_alloc_collections_btree_set_CursorMut_K_A.
        Definition Self (K A : Ty.t) : Ty.t :=
          Ty.apply (Ty.path "alloc::collections::btree::set::CursorMut") [] [ K; A ].
        
        (*
            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                f.write_str("CursorMut")
            }
        *)
        Definition fmt (K A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self K A in
          match ε, τ, α with
          | [], [], [ self; f ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let f := M.alloc (| f |) in
              M.call_closure (|
                M.get_associated_function (| Ty.path "core::fmt::Formatter", "write_str", [] |),
                [ M.read (| f |); M.read (| Value.String "CursorMut" |) ]
              |)))
          | _, _, _ => M.impossible
          end.
        
        Axiom Implements :
          forall (K A : Ty.t),
          M.IsTraitInstance
            "core::fmt::Debug"
            (Self K A)
            (* Trait polymorphic types *) []
            (* Instance *) [ ("fmt", InstanceField.Method (fmt K A)) ].
      End Impl_core_fmt_Debug_where_core_fmt_Debug_K_for_alloc_collections_btree_set_CursorMut_K_A.
      
      (* StructRecord
        {
          name := "CursorMutKey";
          const_params := [];
          ty_params := [ "K"; "A" ];
          fields :=
            [
              ("inner",
                Ty.apply
                  (Ty.path "alloc::collections::btree::map::CursorMutKey")
                  []
                  [ K; Ty.path "alloc::collections::btree::set_val::SetValZST"; A ])
            ];
        } *)
      
      Module Impl_core_fmt_Debug_where_core_fmt_Debug_K_for_alloc_collections_btree_set_CursorMutKey_K_A.
        Definition Self (K A : Ty.t) : Ty.t :=
          Ty.apply (Ty.path "alloc::collections::btree::set::CursorMutKey") [] [ K; A ].
        
        (*
            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                f.write_str("CursorMutKey")
            }
        *)
        Definition fmt (K A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self K A in
          match ε, τ, α with
          | [], [], [ self; f ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let f := M.alloc (| f |) in
              M.call_closure (|
                M.get_associated_function (| Ty.path "core::fmt::Formatter", "write_str", [] |),
                [ M.read (| f |); M.read (| Value.String "CursorMutKey" |) ]
              |)))
          | _, _, _ => M.impossible
          end.
        
        Axiom Implements :
          forall (K A : Ty.t),
          M.IsTraitInstance
            "core::fmt::Debug"
            (Self K A)
            (* Trait polymorphic types *) []
            (* Instance *) [ ("fmt", InstanceField.Method (fmt K A)) ].
      End Impl_core_fmt_Debug_where_core_fmt_Debug_K_for_alloc_collections_btree_set_CursorMutKey_K_A.
      
      Module Impl_alloc_collections_btree_set_Cursor_K.
        Definition Self (K : Ty.t) : Ty.t :=
          Ty.apply (Ty.path "alloc::collections::btree::set::Cursor") [] [ K ].
        
        (*
            pub fn next(&mut self) -> Option<&'a K> {
                self.inner.next().map(|(k, _)| k)
            }
        *)
        Definition next (K : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self K in
          match ε, τ, α with
          | [], [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "core::option::Option")
                    []
                    [
                      Ty.tuple
                        [
                          Ty.apply (Ty.path "&") [] [ K ];
                          Ty.apply
                            (Ty.path "&")
                            []
                            [ Ty.path "alloc::collections::btree::set_val::SetValZST" ]
                        ]
                    ],
                  "map",
                  [
                    Ty.apply (Ty.path "&") [] [ K ];
                    Ty.function
                      [
                        Ty.tuple
                          [
                            Ty.tuple
                              [
                                Ty.apply (Ty.path "&") [] [ K ];
                                Ty.apply
                                  (Ty.path "&")
                                  []
                                  [ Ty.path "alloc::collections::btree::set_val::SetValZST" ]
                              ]
                          ]
                      ]
                      (Ty.apply (Ty.path "&") [] [ K ])
                  ]
                |),
                [
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "alloc::collections::btree::map::Cursor")
                        []
                        [ K; Ty.path "alloc::collections::btree::set_val::SetValZST" ],
                      "next",
                      []
                    |),
                    [
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "alloc::collections::btree::set::Cursor",
                        "inner"
                      |)
                    ]
                  |);
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0 ] =>
                          M.match_operator (|
                            M.alloc (| α0 |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                                  let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                  let k := M.copy (| γ0_0 |) in
                                  M.read (| k |)))
                            ]
                          |)
                        | _ => M.impossible (||)
                        end))
                ]
              |)))
          | _, _, _ => M.impossible
          end.
        
        Axiom AssociatedFunction_next :
          forall (K : Ty.t),
          M.IsAssociatedFunction (Self K) "next" (next K).
        
        (*
            pub fn prev(&mut self) -> Option<&'a K> {
                self.inner.prev().map(|(k, _)| k)
            }
        *)
        Definition prev (K : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self K in
          match ε, τ, α with
          | [], [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "core::option::Option")
                    []
                    [
                      Ty.tuple
                        [
                          Ty.apply (Ty.path "&") [] [ K ];
                          Ty.apply
                            (Ty.path "&")
                            []
                            [ Ty.path "alloc::collections::btree::set_val::SetValZST" ]
                        ]
                    ],
                  "map",
                  [
                    Ty.apply (Ty.path "&") [] [ K ];
                    Ty.function
                      [
                        Ty.tuple
                          [
                            Ty.tuple
                              [
                                Ty.apply (Ty.path "&") [] [ K ];
                                Ty.apply
                                  (Ty.path "&")
                                  []
                                  [ Ty.path "alloc::collections::btree::set_val::SetValZST" ]
                              ]
                          ]
                      ]
                      (Ty.apply (Ty.path "&") [] [ K ])
                  ]
                |),
                [
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "alloc::collections::btree::map::Cursor")
                        []
                        [ K; Ty.path "alloc::collections::btree::set_val::SetValZST" ],
                      "prev",
                      []
                    |),
                    [
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "alloc::collections::btree::set::Cursor",
                        "inner"
                      |)
                    ]
                  |);
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0 ] =>
                          M.match_operator (|
                            M.alloc (| α0 |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                                  let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                  let k := M.copy (| γ0_0 |) in
                                  M.read (| k |)))
                            ]
                          |)
                        | _ => M.impossible (||)
                        end))
                ]
              |)))
          | _, _, _ => M.impossible
          end.
        
        Axiom AssociatedFunction_prev :
          forall (K : Ty.t),
          M.IsAssociatedFunction (Self K) "prev" (prev K).
        
        (*
            pub fn peek_next(&self) -> Option<&'a K> {
                self.inner.peek_next().map(|(k, _)| k)
            }
        *)
        Definition peek_next (K : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self K in
          match ε, τ, α with
          | [], [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "core::option::Option")
                    []
                    [
                      Ty.tuple
                        [
                          Ty.apply (Ty.path "&") [] [ K ];
                          Ty.apply
                            (Ty.path "&")
                            []
                            [ Ty.path "alloc::collections::btree::set_val::SetValZST" ]
                        ]
                    ],
                  "map",
                  [
                    Ty.apply (Ty.path "&") [] [ K ];
                    Ty.function
                      [
                        Ty.tuple
                          [
                            Ty.tuple
                              [
                                Ty.apply (Ty.path "&") [] [ K ];
                                Ty.apply
                                  (Ty.path "&")
                                  []
                                  [ Ty.path "alloc::collections::btree::set_val::SetValZST" ]
                              ]
                          ]
                      ]
                      (Ty.apply (Ty.path "&") [] [ K ])
                  ]
                |),
                [
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "alloc::collections::btree::map::Cursor")
                        []
                        [ K; Ty.path "alloc::collections::btree::set_val::SetValZST" ],
                      "peek_next",
                      []
                    |),
                    [
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "alloc::collections::btree::set::Cursor",
                        "inner"
                      |)
                    ]
                  |);
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0 ] =>
                          M.match_operator (|
                            M.alloc (| α0 |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                                  let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                  let k := M.copy (| γ0_0 |) in
                                  M.read (| k |)))
                            ]
                          |)
                        | _ => M.impossible (||)
                        end))
                ]
              |)))
          | _, _, _ => M.impossible
          end.
        
        Axiom AssociatedFunction_peek_next :
          forall (K : Ty.t),
          M.IsAssociatedFunction (Self K) "peek_next" (peek_next K).
        
        (*
            pub fn peek_prev(&self) -> Option<&'a K> {
                self.inner.peek_prev().map(|(k, _)| k)
            }
        *)
        Definition peek_prev (K : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self K in
          match ε, τ, α with
          | [], [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "core::option::Option")
                    []
                    [
                      Ty.tuple
                        [
                          Ty.apply (Ty.path "&") [] [ K ];
                          Ty.apply
                            (Ty.path "&")
                            []
                            [ Ty.path "alloc::collections::btree::set_val::SetValZST" ]
                        ]
                    ],
                  "map",
                  [
                    Ty.apply (Ty.path "&") [] [ K ];
                    Ty.function
                      [
                        Ty.tuple
                          [
                            Ty.tuple
                              [
                                Ty.apply (Ty.path "&") [] [ K ];
                                Ty.apply
                                  (Ty.path "&")
                                  []
                                  [ Ty.path "alloc::collections::btree::set_val::SetValZST" ]
                              ]
                          ]
                      ]
                      (Ty.apply (Ty.path "&") [] [ K ])
                  ]
                |),
                [
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "alloc::collections::btree::map::Cursor")
                        []
                        [ K; Ty.path "alloc::collections::btree::set_val::SetValZST" ],
                      "peek_prev",
                      []
                    |),
                    [
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "alloc::collections::btree::set::Cursor",
                        "inner"
                      |)
                    ]
                  |);
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0 ] =>
                          M.match_operator (|
                            M.alloc (| α0 |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                                  let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                  let k := M.copy (| γ0_0 |) in
                                  M.read (| k |)))
                            ]
                          |)
                        | _ => M.impossible (||)
                        end))
                ]
              |)))
          | _, _, _ => M.impossible
          end.
        
        Axiom AssociatedFunction_peek_prev :
          forall (K : Ty.t),
          M.IsAssociatedFunction (Self K) "peek_prev" (peek_prev K).
      End Impl_alloc_collections_btree_set_Cursor_K.
      
      Module Impl_alloc_collections_btree_set_CursorMut_T_A.
        Definition Self (T A : Ty.t) : Ty.t :=
          Ty.apply (Ty.path "alloc::collections::btree::set::CursorMut") [] [ T; A ].
        
        (*
            pub fn next(&mut self) -> Option<&T> {
                self.inner.next().map(|(k, _)| k)
            }
        *)
        Definition next (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self T A in
          match ε, τ, α with
          | [], [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "core::option::Option")
                    []
                    [
                      Ty.tuple
                        [
                          Ty.apply (Ty.path "&") [] [ T ];
                          Ty.apply
                            (Ty.path "&mut")
                            []
                            [ Ty.path "alloc::collections::btree::set_val::SetValZST" ]
                        ]
                    ],
                  "map",
                  [
                    Ty.apply (Ty.path "&") [] [ T ];
                    Ty.function
                      [
                        Ty.tuple
                          [
                            Ty.tuple
                              [
                                Ty.apply (Ty.path "&") [] [ T ];
                                Ty.apply
                                  (Ty.path "&mut")
                                  []
                                  [ Ty.path "alloc::collections::btree::set_val::SetValZST" ]
                              ]
                          ]
                      ]
                      (Ty.apply (Ty.path "&") [] [ T ])
                  ]
                |),
                [
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "alloc::collections::btree::map::CursorMut")
                        []
                        [ T; Ty.path "alloc::collections::btree::set_val::SetValZST"; A ],
                      "next",
                      []
                    |),
                    [
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "alloc::collections::btree::set::CursorMut",
                        "inner"
                      |)
                    ]
                  |);
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0 ] =>
                          M.match_operator (|
                            M.alloc (| α0 |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                                  let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                  let k := M.copy (| γ0_0 |) in
                                  M.read (| k |)))
                            ]
                          |)
                        | _ => M.impossible (||)
                        end))
                ]
              |)))
          | _, _, _ => M.impossible
          end.
        
        Axiom AssociatedFunction_next :
          forall (T A : Ty.t),
          M.IsAssociatedFunction (Self T A) "next" (next T A).
        
        (*
            pub fn prev(&mut self) -> Option<&T> {
                self.inner.prev().map(|(k, _)| k)
            }
        *)
        Definition prev (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self T A in
          match ε, τ, α with
          | [], [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "core::option::Option")
                    []
                    [
                      Ty.tuple
                        [
                          Ty.apply (Ty.path "&") [] [ T ];
                          Ty.apply
                            (Ty.path "&mut")
                            []
                            [ Ty.path "alloc::collections::btree::set_val::SetValZST" ]
                        ]
                    ],
                  "map",
                  [
                    Ty.apply (Ty.path "&") [] [ T ];
                    Ty.function
                      [
                        Ty.tuple
                          [
                            Ty.tuple
                              [
                                Ty.apply (Ty.path "&") [] [ T ];
                                Ty.apply
                                  (Ty.path "&mut")
                                  []
                                  [ Ty.path "alloc::collections::btree::set_val::SetValZST" ]
                              ]
                          ]
                      ]
                      (Ty.apply (Ty.path "&") [] [ T ])
                  ]
                |),
                [
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "alloc::collections::btree::map::CursorMut")
                        []
                        [ T; Ty.path "alloc::collections::btree::set_val::SetValZST"; A ],
                      "prev",
                      []
                    |),
                    [
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "alloc::collections::btree::set::CursorMut",
                        "inner"
                      |)
                    ]
                  |);
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0 ] =>
                          M.match_operator (|
                            M.alloc (| α0 |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                                  let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                  let k := M.copy (| γ0_0 |) in
                                  M.read (| k |)))
                            ]
                          |)
                        | _ => M.impossible (||)
                        end))
                ]
              |)))
          | _, _, _ => M.impossible
          end.
        
        Axiom AssociatedFunction_prev :
          forall (T A : Ty.t),
          M.IsAssociatedFunction (Self T A) "prev" (prev T A).
        
        (*
            pub fn peek_next(&mut self) -> Option<&T> {
                self.inner.peek_next().map(|(k, _)| k)
            }
        *)
        Definition peek_next
            (T A : Ty.t)
            (ε : list Value.t)
            (τ : list Ty.t)
            (α : list Value.t)
            : M :=
          let Self : Ty.t := Self T A in
          match ε, τ, α with
          | [], [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "core::option::Option")
                    []
                    [
                      Ty.tuple
                        [
                          Ty.apply (Ty.path "&") [] [ T ];
                          Ty.apply
                            (Ty.path "&mut")
                            []
                            [ Ty.path "alloc::collections::btree::set_val::SetValZST" ]
                        ]
                    ],
                  "map",
                  [
                    Ty.apply (Ty.path "&") [] [ T ];
                    Ty.function
                      [
                        Ty.tuple
                          [
                            Ty.tuple
                              [
                                Ty.apply (Ty.path "&") [] [ T ];
                                Ty.apply
                                  (Ty.path "&mut")
                                  []
                                  [ Ty.path "alloc::collections::btree::set_val::SetValZST" ]
                              ]
                          ]
                      ]
                      (Ty.apply (Ty.path "&") [] [ T ])
                  ]
                |),
                [
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "alloc::collections::btree::map::CursorMut")
                        []
                        [ T; Ty.path "alloc::collections::btree::set_val::SetValZST"; A ],
                      "peek_next",
                      []
                    |),
                    [
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "alloc::collections::btree::set::CursorMut",
                        "inner"
                      |)
                    ]
                  |);
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0 ] =>
                          M.match_operator (|
                            M.alloc (| α0 |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                                  let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                  let k := M.copy (| γ0_0 |) in
                                  M.read (| k |)))
                            ]
                          |)
                        | _ => M.impossible (||)
                        end))
                ]
              |)))
          | _, _, _ => M.impossible
          end.
        
        Axiom AssociatedFunction_peek_next :
          forall (T A : Ty.t),
          M.IsAssociatedFunction (Self T A) "peek_next" (peek_next T A).
        
        (*
            pub fn peek_prev(&mut self) -> Option<&T> {
                self.inner.peek_prev().map(|(k, _)| k)
            }
        *)
        Definition peek_prev
            (T A : Ty.t)
            (ε : list Value.t)
            (τ : list Ty.t)
            (α : list Value.t)
            : M :=
          let Self : Ty.t := Self T A in
          match ε, τ, α with
          | [], [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "core::option::Option")
                    []
                    [
                      Ty.tuple
                        [
                          Ty.apply (Ty.path "&") [] [ T ];
                          Ty.apply
                            (Ty.path "&mut")
                            []
                            [ Ty.path "alloc::collections::btree::set_val::SetValZST" ]
                        ]
                    ],
                  "map",
                  [
                    Ty.apply (Ty.path "&") [] [ T ];
                    Ty.function
                      [
                        Ty.tuple
                          [
                            Ty.tuple
                              [
                                Ty.apply (Ty.path "&") [] [ T ];
                                Ty.apply
                                  (Ty.path "&mut")
                                  []
                                  [ Ty.path "alloc::collections::btree::set_val::SetValZST" ]
                              ]
                          ]
                      ]
                      (Ty.apply (Ty.path "&") [] [ T ])
                  ]
                |),
                [
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "alloc::collections::btree::map::CursorMut")
                        []
                        [ T; Ty.path "alloc::collections::btree::set_val::SetValZST"; A ],
                      "peek_prev",
                      []
                    |),
                    [
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "alloc::collections::btree::set::CursorMut",
                        "inner"
                      |)
                    ]
                  |);
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0 ] =>
                          M.match_operator (|
                            M.alloc (| α0 |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                                  let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                  let k := M.copy (| γ0_0 |) in
                                  M.read (| k |)))
                            ]
                          |)
                        | _ => M.impossible (||)
                        end))
                ]
              |)))
          | _, _, _ => M.impossible
          end.
        
        Axiom AssociatedFunction_peek_prev :
          forall (T A : Ty.t),
          M.IsAssociatedFunction (Self T A) "peek_prev" (peek_prev T A).
        
        (*
            pub fn as_cursor(&self) -> Cursor<'_, T> {
                Cursor { inner: self.inner.as_cursor() }
            }
        *)
        Definition as_cursor
            (T A : Ty.t)
            (ε : list Value.t)
            (τ : list Ty.t)
            (α : list Value.t)
            : M :=
          let Self : Ty.t := Self T A in
          match ε, τ, α with
          | [], [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              Value.StructRecord
                "alloc::collections::btree::set::Cursor"
                [
                  ("inner",
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "alloc::collections::btree::map::CursorMut")
                          []
                          [ T; Ty.path "alloc::collections::btree::set_val::SetValZST"; A ],
                        "as_cursor",
                        []
                      |),
                      [
                        M.SubPointer.get_struct_record_field (|
                          M.read (| self |),
                          "alloc::collections::btree::set::CursorMut",
                          "inner"
                        |)
                      ]
                    |))
                ]))
          | _, _, _ => M.impossible
          end.
        
        Axiom AssociatedFunction_as_cursor :
          forall (T A : Ty.t),
          M.IsAssociatedFunction (Self T A) "as_cursor" (as_cursor T A).
        
        (*
            pub unsafe fn with_mutable_key(self) -> CursorMutKey<'a, T, A> {
                CursorMutKey { inner: unsafe { self.inner.with_mutable_key() } }
            }
        *)
        Definition with_mutable_key
            (T A : Ty.t)
            (ε : list Value.t)
            (τ : list Ty.t)
            (α : list Value.t)
            : M :=
          let Self : Ty.t := Self T A in
          match ε, τ, α with
          | [], [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              Value.StructRecord
                "alloc::collections::btree::set::CursorMutKey"
                [
                  ("inner",
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "alloc::collections::btree::map::CursorMut")
                          []
                          [ T; Ty.path "alloc::collections::btree::set_val::SetValZST"; A ],
                        "with_mutable_key",
                        []
                      |),
                      [
                        M.read (|
                          M.SubPointer.get_struct_record_field (|
                            self,
                            "alloc::collections::btree::set::CursorMut",
                            "inner"
                          |)
                        |)
                      ]
                    |))
                ]))
          | _, _, _ => M.impossible
          end.
        
        Axiom AssociatedFunction_with_mutable_key :
          forall (T A : Ty.t),
          M.IsAssociatedFunction (Self T A) "with_mutable_key" (with_mutable_key T A).
        (*
            pub unsafe fn insert_after_unchecked(&mut self, value: T) {
                unsafe { self.inner.insert_after_unchecked(value, SetValZST) }
            }
        *)
        Definition insert_after_unchecked
            (T A : Ty.t)
            (ε : list Value.t)
            (τ : list Ty.t)
            (α : list Value.t)
            : M :=
          let Self : Ty.t := Self T A in
          match ε, τ, α with
          | [], [], [ self; value ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let value := M.alloc (| value |) in
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "alloc::collections::btree::map::CursorMut")
                    []
                    [ T; Ty.path "alloc::collections::btree::set_val::SetValZST"; A ],
                  "insert_after_unchecked",
                  []
                |),
                [
                  M.SubPointer.get_struct_record_field (|
                    M.read (| self |),
                    "alloc::collections::btree::set::CursorMut",
                    "inner"
                  |);
                  M.read (| value |);
                  Value.StructTuple "alloc::collections::btree::set_val::SetValZST" []
                ]
              |)))
          | _, _, _ => M.impossible
          end.
        
        Axiom AssociatedFunction_insert_after_unchecked :
          forall (T A : Ty.t),
          M.IsAssociatedFunction (Self T A) "insert_after_unchecked" (insert_after_unchecked T A).
        
        (*
            pub unsafe fn insert_before_unchecked(&mut self, value: T) {
                unsafe { self.inner.insert_before_unchecked(value, SetValZST) }
            }
        *)
        Definition insert_before_unchecked
            (T A : Ty.t)
            (ε : list Value.t)
            (τ : list Ty.t)
            (α : list Value.t)
            : M :=
          let Self : Ty.t := Self T A in
          match ε, τ, α with
          | [], [], [ self; value ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let value := M.alloc (| value |) in
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "alloc::collections::btree::map::CursorMut")
                    []
                    [ T; Ty.path "alloc::collections::btree::set_val::SetValZST"; A ],
                  "insert_before_unchecked",
                  []
                |),
                [
                  M.SubPointer.get_struct_record_field (|
                    M.read (| self |),
                    "alloc::collections::btree::set::CursorMut",
                    "inner"
                  |);
                  M.read (| value |);
                  Value.StructTuple "alloc::collections::btree::set_val::SetValZST" []
                ]
              |)))
          | _, _, _ => M.impossible
          end.
        
        Axiom AssociatedFunction_insert_before_unchecked :
          forall (T A : Ty.t),
          M.IsAssociatedFunction (Self T A) "insert_before_unchecked" (insert_before_unchecked T A).
        
        (*
            pub fn insert_after(&mut self, value: T) -> Result<(), UnorderedKeyError> {
                self.inner.insert_after(value, SetValZST)
            }
        *)
        Definition insert_after
            (T A : Ty.t)
            (ε : list Value.t)
            (τ : list Ty.t)
            (α : list Value.t)
            : M :=
          let Self : Ty.t := Self T A in
          match ε, τ, α with
          | [], [], [ self; value ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let value := M.alloc (| value |) in
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "alloc::collections::btree::map::CursorMut")
                    []
                    [ T; Ty.path "alloc::collections::btree::set_val::SetValZST"; A ],
                  "insert_after",
                  []
                |),
                [
                  M.SubPointer.get_struct_record_field (|
                    M.read (| self |),
                    "alloc::collections::btree::set::CursorMut",
                    "inner"
                  |);
                  M.read (| value |);
                  Value.StructTuple "alloc::collections::btree::set_val::SetValZST" []
                ]
              |)))
          | _, _, _ => M.impossible
          end.
        
        Axiom AssociatedFunction_insert_after :
          forall (T A : Ty.t),
          M.IsAssociatedFunction (Self T A) "insert_after" (insert_after T A).
        
        (*
            pub fn insert_before(&mut self, value: T) -> Result<(), UnorderedKeyError> {
                self.inner.insert_before(value, SetValZST)
            }
        *)
        Definition insert_before
            (T A : Ty.t)
            (ε : list Value.t)
            (τ : list Ty.t)
            (α : list Value.t)
            : M :=
          let Self : Ty.t := Self T A in
          match ε, τ, α with
          | [], [], [ self; value ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let value := M.alloc (| value |) in
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "alloc::collections::btree::map::CursorMut")
                    []
                    [ T; Ty.path "alloc::collections::btree::set_val::SetValZST"; A ],
                  "insert_before",
                  []
                |),
                [
                  M.SubPointer.get_struct_record_field (|
                    M.read (| self |),
                    "alloc::collections::btree::set::CursorMut",
                    "inner"
                  |);
                  M.read (| value |);
                  Value.StructTuple "alloc::collections::btree::set_val::SetValZST" []
                ]
              |)))
          | _, _, _ => M.impossible
          end.
        
        Axiom AssociatedFunction_insert_before :
          forall (T A : Ty.t),
          M.IsAssociatedFunction (Self T A) "insert_before" (insert_before T A).
        
        (*
            pub fn remove_next(&mut self) -> Option<T> {
                self.inner.remove_next().map(|(k, _)| k)
            }
        *)
        Definition remove_next
            (T A : Ty.t)
            (ε : list Value.t)
            (τ : list Ty.t)
            (α : list Value.t)
            : M :=
          let Self : Ty.t := Self T A in
          match ε, τ, α with
          | [], [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "core::option::Option")
                    []
                    [ Ty.tuple [ T; Ty.path "alloc::collections::btree::set_val::SetValZST" ] ],
                  "map",
                  [
                    T;
                    Ty.function
                      [
                        Ty.tuple
                          [ Ty.tuple [ T; Ty.path "alloc::collections::btree::set_val::SetValZST" ]
                          ]
                      ]
                      T
                  ]
                |),
                [
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "alloc::collections::btree::map::CursorMut")
                        []
                        [ T; Ty.path "alloc::collections::btree::set_val::SetValZST"; A ],
                      "remove_next",
                      []
                    |),
                    [
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "alloc::collections::btree::set::CursorMut",
                        "inner"
                      |)
                    ]
                  |);
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0 ] =>
                          M.match_operator (|
                            M.alloc (| α0 |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                                  let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                  let k := M.copy (| γ0_0 |) in
                                  M.read (| k |)))
                            ]
                          |)
                        | _ => M.impossible (||)
                        end))
                ]
              |)))
          | _, _, _ => M.impossible
          end.
        
        Axiom AssociatedFunction_remove_next :
          forall (T A : Ty.t),
          M.IsAssociatedFunction (Self T A) "remove_next" (remove_next T A).
        
        (*
            pub fn remove_prev(&mut self) -> Option<T> {
                self.inner.remove_prev().map(|(k, _)| k)
            }
        *)
        Definition remove_prev
            (T A : Ty.t)
            (ε : list Value.t)
            (τ : list Ty.t)
            (α : list Value.t)
            : M :=
          let Self : Ty.t := Self T A in
          match ε, τ, α with
          | [], [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "core::option::Option")
                    []
                    [ Ty.tuple [ T; Ty.path "alloc::collections::btree::set_val::SetValZST" ] ],
                  "map",
                  [
                    T;
                    Ty.function
                      [
                        Ty.tuple
                          [ Ty.tuple [ T; Ty.path "alloc::collections::btree::set_val::SetValZST" ]
                          ]
                      ]
                      T
                  ]
                |),
                [
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "alloc::collections::btree::map::CursorMut")
                        []
                        [ T; Ty.path "alloc::collections::btree::set_val::SetValZST"; A ],
                      "remove_prev",
                      []
                    |),
                    [
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "alloc::collections::btree::set::CursorMut",
                        "inner"
                      |)
                    ]
                  |);
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0 ] =>
                          M.match_operator (|
                            M.alloc (| α0 |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                                  let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                  let k := M.copy (| γ0_0 |) in
                                  M.read (| k |)))
                            ]
                          |)
                        | _ => M.impossible (||)
                        end))
                ]
              |)))
          | _, _, _ => M.impossible
          end.
        
        Axiom AssociatedFunction_remove_prev :
          forall (T A : Ty.t),
          M.IsAssociatedFunction (Self T A) "remove_prev" (remove_prev T A).
      End Impl_alloc_collections_btree_set_CursorMut_T_A.
      
      Module Impl_alloc_collections_btree_set_CursorMutKey_T_A.
        Definition Self (T A : Ty.t) : Ty.t :=
          Ty.apply (Ty.path "alloc::collections::btree::set::CursorMutKey") [] [ T; A ].
        
        (*
            pub fn next(&mut self) -> Option<&mut T> {
                self.inner.next().map(|(k, _)| k)
            }
        *)
        Definition next (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self T A in
          match ε, τ, α with
          | [], [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "core::option::Option")
                    []
                    [
                      Ty.tuple
                        [
                          Ty.apply (Ty.path "&mut") [] [ T ];
                          Ty.apply
                            (Ty.path "&mut")
                            []
                            [ Ty.path "alloc::collections::btree::set_val::SetValZST" ]
                        ]
                    ],
                  "map",
                  [
                    Ty.apply (Ty.path "&mut") [] [ T ];
                    Ty.function
                      [
                        Ty.tuple
                          [
                            Ty.tuple
                              [
                                Ty.apply (Ty.path "&mut") [] [ T ];
                                Ty.apply
                                  (Ty.path "&mut")
                                  []
                                  [ Ty.path "alloc::collections::btree::set_val::SetValZST" ]
                              ]
                          ]
                      ]
                      (Ty.apply (Ty.path "&mut") [] [ T ])
                  ]
                |),
                [
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "alloc::collections::btree::map::CursorMutKey")
                        []
                        [ T; Ty.path "alloc::collections::btree::set_val::SetValZST"; A ],
                      "next",
                      []
                    |),
                    [
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "alloc::collections::btree::set::CursorMutKey",
                        "inner"
                      |)
                    ]
                  |);
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0 ] =>
                          M.match_operator (|
                            M.alloc (| α0 |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                                  let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                  let k := M.copy (| γ0_0 |) in
                                  M.read (| k |)))
                            ]
                          |)
                        | _ => M.impossible (||)
                        end))
                ]
              |)))
          | _, _, _ => M.impossible
          end.
        
        Axiom AssociatedFunction_next :
          forall (T A : Ty.t),
          M.IsAssociatedFunction (Self T A) "next" (next T A).
        
        (*
            pub fn prev(&mut self) -> Option<&mut T> {
                self.inner.prev().map(|(k, _)| k)
            }
        *)
        Definition prev (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self T A in
          match ε, τ, α with
          | [], [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "core::option::Option")
                    []
                    [
                      Ty.tuple
                        [
                          Ty.apply (Ty.path "&mut") [] [ T ];
                          Ty.apply
                            (Ty.path "&mut")
                            []
                            [ Ty.path "alloc::collections::btree::set_val::SetValZST" ]
                        ]
                    ],
                  "map",
                  [
                    Ty.apply (Ty.path "&mut") [] [ T ];
                    Ty.function
                      [
                        Ty.tuple
                          [
                            Ty.tuple
                              [
                                Ty.apply (Ty.path "&mut") [] [ T ];
                                Ty.apply
                                  (Ty.path "&mut")
                                  []
                                  [ Ty.path "alloc::collections::btree::set_val::SetValZST" ]
                              ]
                          ]
                      ]
                      (Ty.apply (Ty.path "&mut") [] [ T ])
                  ]
                |),
                [
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "alloc::collections::btree::map::CursorMutKey")
                        []
                        [ T; Ty.path "alloc::collections::btree::set_val::SetValZST"; A ],
                      "prev",
                      []
                    |),
                    [
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "alloc::collections::btree::set::CursorMutKey",
                        "inner"
                      |)
                    ]
                  |);
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0 ] =>
                          M.match_operator (|
                            M.alloc (| α0 |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                                  let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                  let k := M.copy (| γ0_0 |) in
                                  M.read (| k |)))
                            ]
                          |)
                        | _ => M.impossible (||)
                        end))
                ]
              |)))
          | _, _, _ => M.impossible
          end.
        
        Axiom AssociatedFunction_prev :
          forall (T A : Ty.t),
          M.IsAssociatedFunction (Self T A) "prev" (prev T A).
        
        (*
            pub fn peek_next(&mut self) -> Option<&mut T> {
                self.inner.peek_next().map(|(k, _)| k)
            }
        *)
        Definition peek_next
            (T A : Ty.t)
            (ε : list Value.t)
            (τ : list Ty.t)
            (α : list Value.t)
            : M :=
          let Self : Ty.t := Self T A in
          match ε, τ, α with
          | [], [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "core::option::Option")
                    []
                    [
                      Ty.tuple
                        [
                          Ty.apply (Ty.path "&mut") [] [ T ];
                          Ty.apply
                            (Ty.path "&mut")
                            []
                            [ Ty.path "alloc::collections::btree::set_val::SetValZST" ]
                        ]
                    ],
                  "map",
                  [
                    Ty.apply (Ty.path "&mut") [] [ T ];
                    Ty.function
                      [
                        Ty.tuple
                          [
                            Ty.tuple
                              [
                                Ty.apply (Ty.path "&mut") [] [ T ];
                                Ty.apply
                                  (Ty.path "&mut")
                                  []
                                  [ Ty.path "alloc::collections::btree::set_val::SetValZST" ]
                              ]
                          ]
                      ]
                      (Ty.apply (Ty.path "&mut") [] [ T ])
                  ]
                |),
                [
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "alloc::collections::btree::map::CursorMutKey")
                        []
                        [ T; Ty.path "alloc::collections::btree::set_val::SetValZST"; A ],
                      "peek_next",
                      []
                    |),
                    [
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "alloc::collections::btree::set::CursorMutKey",
                        "inner"
                      |)
                    ]
                  |);
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0 ] =>
                          M.match_operator (|
                            M.alloc (| α0 |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                                  let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                  let k := M.copy (| γ0_0 |) in
                                  M.read (| k |)))
                            ]
                          |)
                        | _ => M.impossible (||)
                        end))
                ]
              |)))
          | _, _, _ => M.impossible
          end.
        
        Axiom AssociatedFunction_peek_next :
          forall (T A : Ty.t),
          M.IsAssociatedFunction (Self T A) "peek_next" (peek_next T A).
        
        (*
            pub fn peek_prev(&mut self) -> Option<&mut T> {
                self.inner.peek_prev().map(|(k, _)| k)
            }
        *)
        Definition peek_prev
            (T A : Ty.t)
            (ε : list Value.t)
            (τ : list Ty.t)
            (α : list Value.t)
            : M :=
          let Self : Ty.t := Self T A in
          match ε, τ, α with
          | [], [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "core::option::Option")
                    []
                    [
                      Ty.tuple
                        [
                          Ty.apply (Ty.path "&mut") [] [ T ];
                          Ty.apply
                            (Ty.path "&mut")
                            []
                            [ Ty.path "alloc::collections::btree::set_val::SetValZST" ]
                        ]
                    ],
                  "map",
                  [
                    Ty.apply (Ty.path "&mut") [] [ T ];
                    Ty.function
                      [
                        Ty.tuple
                          [
                            Ty.tuple
                              [
                                Ty.apply (Ty.path "&mut") [] [ T ];
                                Ty.apply
                                  (Ty.path "&mut")
                                  []
                                  [ Ty.path "alloc::collections::btree::set_val::SetValZST" ]
                              ]
                          ]
                      ]
                      (Ty.apply (Ty.path "&mut") [] [ T ])
                  ]
                |),
                [
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "alloc::collections::btree::map::CursorMutKey")
                        []
                        [ T; Ty.path "alloc::collections::btree::set_val::SetValZST"; A ],
                      "peek_prev",
                      []
                    |),
                    [
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "alloc::collections::btree::set::CursorMutKey",
                        "inner"
                      |)
                    ]
                  |);
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0 ] =>
                          M.match_operator (|
                            M.alloc (| α0 |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                                  let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                  let k := M.copy (| γ0_0 |) in
                                  M.read (| k |)))
                            ]
                          |)
                        | _ => M.impossible (||)
                        end))
                ]
              |)))
          | _, _, _ => M.impossible
          end.
        
        Axiom AssociatedFunction_peek_prev :
          forall (T A : Ty.t),
          M.IsAssociatedFunction (Self T A) "peek_prev" (peek_prev T A).
        
        (*
            pub fn as_cursor(&self) -> Cursor<'_, T> {
                Cursor { inner: self.inner.as_cursor() }
            }
        *)
        Definition as_cursor
            (T A : Ty.t)
            (ε : list Value.t)
            (τ : list Ty.t)
            (α : list Value.t)
            : M :=
          let Self : Ty.t := Self T A in
          match ε, τ, α with
          | [], [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              Value.StructRecord
                "alloc::collections::btree::set::Cursor"
                [
                  ("inner",
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "alloc::collections::btree::map::CursorMutKey")
                          []
                          [ T; Ty.path "alloc::collections::btree::set_val::SetValZST"; A ],
                        "as_cursor",
                        []
                      |),
                      [
                        M.SubPointer.get_struct_record_field (|
                          M.read (| self |),
                          "alloc::collections::btree::set::CursorMutKey",
                          "inner"
                        |)
                      ]
                    |))
                ]))
          | _, _, _ => M.impossible
          end.
        
        Axiom AssociatedFunction_as_cursor :
          forall (T A : Ty.t),
          M.IsAssociatedFunction (Self T A) "as_cursor" (as_cursor T A).
        (*
            pub unsafe fn insert_after_unchecked(&mut self, value: T) {
                unsafe { self.inner.insert_after_unchecked(value, SetValZST) }
            }
        *)
        Definition insert_after_unchecked
            (T A : Ty.t)
            (ε : list Value.t)
            (τ : list Ty.t)
            (α : list Value.t)
            : M :=
          let Self : Ty.t := Self T A in
          match ε, τ, α with
          | [], [], [ self; value ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let value := M.alloc (| value |) in
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "alloc::collections::btree::map::CursorMutKey")
                    []
                    [ T; Ty.path "alloc::collections::btree::set_val::SetValZST"; A ],
                  "insert_after_unchecked",
                  []
                |),
                [
                  M.SubPointer.get_struct_record_field (|
                    M.read (| self |),
                    "alloc::collections::btree::set::CursorMutKey",
                    "inner"
                  |);
                  M.read (| value |);
                  Value.StructTuple "alloc::collections::btree::set_val::SetValZST" []
                ]
              |)))
          | _, _, _ => M.impossible
          end.
        
        Axiom AssociatedFunction_insert_after_unchecked :
          forall (T A : Ty.t),
          M.IsAssociatedFunction (Self T A) "insert_after_unchecked" (insert_after_unchecked T A).
        
        (*
            pub unsafe fn insert_before_unchecked(&mut self, value: T) {
                unsafe { self.inner.insert_before_unchecked(value, SetValZST) }
            }
        *)
        Definition insert_before_unchecked
            (T A : Ty.t)
            (ε : list Value.t)
            (τ : list Ty.t)
            (α : list Value.t)
            : M :=
          let Self : Ty.t := Self T A in
          match ε, τ, α with
          | [], [], [ self; value ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let value := M.alloc (| value |) in
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "alloc::collections::btree::map::CursorMutKey")
                    []
                    [ T; Ty.path "alloc::collections::btree::set_val::SetValZST"; A ],
                  "insert_before_unchecked",
                  []
                |),
                [
                  M.SubPointer.get_struct_record_field (|
                    M.read (| self |),
                    "alloc::collections::btree::set::CursorMutKey",
                    "inner"
                  |);
                  M.read (| value |);
                  Value.StructTuple "alloc::collections::btree::set_val::SetValZST" []
                ]
              |)))
          | _, _, _ => M.impossible
          end.
        
        Axiom AssociatedFunction_insert_before_unchecked :
          forall (T A : Ty.t),
          M.IsAssociatedFunction (Self T A) "insert_before_unchecked" (insert_before_unchecked T A).
        
        (*
            pub fn insert_after(&mut self, value: T) -> Result<(), UnorderedKeyError> {
                self.inner.insert_after(value, SetValZST)
            }
        *)
        Definition insert_after
            (T A : Ty.t)
            (ε : list Value.t)
            (τ : list Ty.t)
            (α : list Value.t)
            : M :=
          let Self : Ty.t := Self T A in
          match ε, τ, α with
          | [], [], [ self; value ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let value := M.alloc (| value |) in
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "alloc::collections::btree::map::CursorMutKey")
                    []
                    [ T; Ty.path "alloc::collections::btree::set_val::SetValZST"; A ],
                  "insert_after",
                  []
                |),
                [
                  M.SubPointer.get_struct_record_field (|
                    M.read (| self |),
                    "alloc::collections::btree::set::CursorMutKey",
                    "inner"
                  |);
                  M.read (| value |);
                  Value.StructTuple "alloc::collections::btree::set_val::SetValZST" []
                ]
              |)))
          | _, _, _ => M.impossible
          end.
        
        Axiom AssociatedFunction_insert_after :
          forall (T A : Ty.t),
          M.IsAssociatedFunction (Self T A) "insert_after" (insert_after T A).
        
        (*
            pub fn insert_before(&mut self, value: T) -> Result<(), UnorderedKeyError> {
                self.inner.insert_before(value, SetValZST)
            }
        *)
        Definition insert_before
            (T A : Ty.t)
            (ε : list Value.t)
            (τ : list Ty.t)
            (α : list Value.t)
            : M :=
          let Self : Ty.t := Self T A in
          match ε, τ, α with
          | [], [], [ self; value ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let value := M.alloc (| value |) in
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "alloc::collections::btree::map::CursorMutKey")
                    []
                    [ T; Ty.path "alloc::collections::btree::set_val::SetValZST"; A ],
                  "insert_before",
                  []
                |),
                [
                  M.SubPointer.get_struct_record_field (|
                    M.read (| self |),
                    "alloc::collections::btree::set::CursorMutKey",
                    "inner"
                  |);
                  M.read (| value |);
                  Value.StructTuple "alloc::collections::btree::set_val::SetValZST" []
                ]
              |)))
          | _, _, _ => M.impossible
          end.
        
        Axiom AssociatedFunction_insert_before :
          forall (T A : Ty.t),
          M.IsAssociatedFunction (Self T A) "insert_before" (insert_before T A).
        
        (*
            pub fn remove_next(&mut self) -> Option<T> {
                self.inner.remove_next().map(|(k, _)| k)
            }
        *)
        Definition remove_next
            (T A : Ty.t)
            (ε : list Value.t)
            (τ : list Ty.t)
            (α : list Value.t)
            : M :=
          let Self : Ty.t := Self T A in
          match ε, τ, α with
          | [], [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "core::option::Option")
                    []
                    [ Ty.tuple [ T; Ty.path "alloc::collections::btree::set_val::SetValZST" ] ],
                  "map",
                  [
                    T;
                    Ty.function
                      [
                        Ty.tuple
                          [ Ty.tuple [ T; Ty.path "alloc::collections::btree::set_val::SetValZST" ]
                          ]
                      ]
                      T
                  ]
                |),
                [
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "alloc::collections::btree::map::CursorMutKey")
                        []
                        [ T; Ty.path "alloc::collections::btree::set_val::SetValZST"; A ],
                      "remove_next",
                      []
                    |),
                    [
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "alloc::collections::btree::set::CursorMutKey",
                        "inner"
                      |)
                    ]
                  |);
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0 ] =>
                          M.match_operator (|
                            M.alloc (| α0 |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                                  let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                  let k := M.copy (| γ0_0 |) in
                                  M.read (| k |)))
                            ]
                          |)
                        | _ => M.impossible (||)
                        end))
                ]
              |)))
          | _, _, _ => M.impossible
          end.
        
        Axiom AssociatedFunction_remove_next :
          forall (T A : Ty.t),
          M.IsAssociatedFunction (Self T A) "remove_next" (remove_next T A).
        
        (*
            pub fn remove_prev(&mut self) -> Option<T> {
                self.inner.remove_prev().map(|(k, _)| k)
            }
        *)
        Definition remove_prev
            (T A : Ty.t)
            (ε : list Value.t)
            (τ : list Ty.t)
            (α : list Value.t)
            : M :=
          let Self : Ty.t := Self T A in
          match ε, τ, α with
          | [], [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "core::option::Option")
                    []
                    [ Ty.tuple [ T; Ty.path "alloc::collections::btree::set_val::SetValZST" ] ],
                  "map",
                  [
                    T;
                    Ty.function
                      [
                        Ty.tuple
                          [ Ty.tuple [ T; Ty.path "alloc::collections::btree::set_val::SetValZST" ]
                          ]
                      ]
                      T
                  ]
                |),
                [
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "alloc::collections::btree::map::CursorMutKey")
                        []
                        [ T; Ty.path "alloc::collections::btree::set_val::SetValZST"; A ],
                      "remove_prev",
                      []
                    |),
                    [
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "alloc::collections::btree::set::CursorMutKey",
                        "inner"
                      |)
                    ]
                  |);
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0 ] =>
                          M.match_operator (|
                            M.alloc (| α0 |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                                  let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                  let k := M.copy (| γ0_0 |) in
                                  M.read (| k |)))
                            ]
                          |)
                        | _ => M.impossible (||)
                        end))
                ]
              |)))
          | _, _, _ => M.impossible
          end.
        
        Axiom AssociatedFunction_remove_prev :
          forall (T A : Ty.t),
          M.IsAssociatedFunction (Self T A) "remove_prev" (remove_prev T A).
      End Impl_alloc_collections_btree_set_CursorMutKey_T_A.
      
      
    End set.
  End btree.
End collections.
