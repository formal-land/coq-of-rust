(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module collections.
  Module btree.
    Module set.
      (* StructRecord
        {
          name := "BTreeSet";
          const_params := [];
          ty_params := [ "T"; "A" ];
          fields :=
            [
              ("map",
                Ty.apply
                  (Ty.path "alloc::collections::btree::map::BTreeMap")
                  []
                  [ T; Ty.path "alloc::collections::btree::set_val::SetValZST"; A ])
            ];
        } *)
      
      Module Impl_core_hash_Hash_where_core_hash_Hash_T_where_core_alloc_Allocator_A_where_core_clone_Clone_A_for_alloc_collections_btree_set_BTreeSet_T_A.
        Definition Self (T A : Ty.t) : Ty.t :=
          Ty.apply (Ty.path "alloc::collections::btree::set::BTreeSet") [] [ T; A ].
        
        (*
            fn hash<H: Hasher>(&self, state: &mut H) {
                self.map.hash(state)
            }
        *)
        Definition hash (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self T A in
          match ε, τ, α with
          | [], [ H ], [ self; state ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let state := M.alloc (| state |) in
              M.call_closure (|
                Ty.tuple [],
                M.get_trait_method (|
                  "core::hash::Hash",
                  Ty.apply
                    (Ty.path "alloc::collections::btree::map::BTreeMap")
                    []
                    [ T; Ty.path "alloc::collections::btree::set_val::SetValZST"; A ],
                  [],
                  [],
                  "hash",
                  [],
                  [ H ]
                |),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| self |) |),
                      "alloc::collections::btree::set::BTreeSet",
                      "map"
                    |)
                  |);
                  M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                ]
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Axiom Implements :
          forall (T A : Ty.t),
          M.IsTraitInstance
            "core::hash::Hash"
            (* Trait polymorphic consts *) []
            (* Trait polymorphic types *) []
            (Self T A)
            (* Instance *) [ ("hash", InstanceField.Method (hash T A)) ].
      End Impl_core_hash_Hash_where_core_hash_Hash_T_where_core_alloc_Allocator_A_where_core_clone_Clone_A_for_alloc_collections_btree_set_BTreeSet_T_A.
      
      Module Impl_core_cmp_PartialEq_where_core_cmp_PartialEq_T_where_core_alloc_Allocator_A_where_core_clone_Clone_A_alloc_collections_btree_set_BTreeSet_T_A_for_alloc_collections_btree_set_BTreeSet_T_A.
        Definition Self (T A : Ty.t) : Ty.t :=
          Ty.apply (Ty.path "alloc::collections::btree::set::BTreeSet") [] [ T; A ].
        
        (*
            fn eq(&self, other: &BTreeSet<T, A>) -> bool {
                self.map.eq(&other.map)
            }
        *)
        Definition eq (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self T A in
          match ε, τ, α with
          | [], [], [ self; other ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let other := M.alloc (| other |) in
              M.call_closure (|
                Ty.path "bool",
                M.get_trait_method (|
                  "core::cmp::PartialEq",
                  Ty.apply
                    (Ty.path "alloc::collections::btree::map::BTreeMap")
                    []
                    [ T; Ty.path "alloc::collections::btree::set_val::SetValZST"; A ],
                  [],
                  [
                    Ty.apply
                      (Ty.path "alloc::collections::btree::map::BTreeMap")
                      []
                      [ T; Ty.path "alloc::collections::btree::set_val::SetValZST"; A ]
                  ],
                  "eq",
                  [],
                  []
                |),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| self |) |),
                      "alloc::collections::btree::set::BTreeSet",
                      "map"
                    |)
                  |);
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| other |) |),
                          "alloc::collections::btree::set::BTreeSet",
                          "map"
                        |)
                      |)
                    |)
                  |)
                ]
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Axiom Implements :
          forall (T A : Ty.t),
          M.IsTraitInstance
            "core::cmp::PartialEq"
            (* Trait polymorphic consts *) []
            (* Trait polymorphic types *)
            [ Ty.apply (Ty.path "alloc::collections::btree::set::BTreeSet") [] [ T; A ] ]
            (Self T A)
            (* Instance *) [ ("eq", InstanceField.Method (eq T A)) ].
      End Impl_core_cmp_PartialEq_where_core_cmp_PartialEq_T_where_core_alloc_Allocator_A_where_core_clone_Clone_A_alloc_collections_btree_set_BTreeSet_T_A_for_alloc_collections_btree_set_BTreeSet_T_A.
      
      Module Impl_core_cmp_Eq_where_core_cmp_Eq_T_where_core_alloc_Allocator_A_where_core_clone_Clone_A_for_alloc_collections_btree_set_BTreeSet_T_A.
        Definition Self (T A : Ty.t) : Ty.t :=
          Ty.apply (Ty.path "alloc::collections::btree::set::BTreeSet") [] [ T; A ].
        
        Axiom Implements :
          forall (T A : Ty.t),
          M.IsTraitInstance
            "core::cmp::Eq"
            (* Trait polymorphic consts *) []
            (* Trait polymorphic types *) []
            (Self T A)
            (* Instance *) [].
      End Impl_core_cmp_Eq_where_core_cmp_Eq_T_where_core_alloc_Allocator_A_where_core_clone_Clone_A_for_alloc_collections_btree_set_BTreeSet_T_A.
      
      Module Impl_core_cmp_PartialOrd_where_core_cmp_PartialOrd_T_where_core_alloc_Allocator_A_where_core_clone_Clone_A_alloc_collections_btree_set_BTreeSet_T_A_for_alloc_collections_btree_set_BTreeSet_T_A.
        Definition Self (T A : Ty.t) : Ty.t :=
          Ty.apply (Ty.path "alloc::collections::btree::set::BTreeSet") [] [ T; A ].
        
        (*
            fn partial_cmp(&self, other: &BTreeSet<T, A>) -> Option<Ordering> {
                self.map.partial_cmp(&other.map)
            }
        *)
        Definition partial_cmp
            (T A : Ty.t)
            (ε : list Value.t)
            (τ : list Ty.t)
            (α : list Value.t)
            : M :=
          let Self : Ty.t := Self T A in
          match ε, τ, α with
          | [], [], [ self; other ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let other := M.alloc (| other |) in
              M.call_closure (|
                Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "core::cmp::Ordering" ],
                M.get_trait_method (|
                  "core::cmp::PartialOrd",
                  Ty.apply
                    (Ty.path "alloc::collections::btree::map::BTreeMap")
                    []
                    [ T; Ty.path "alloc::collections::btree::set_val::SetValZST"; A ],
                  [],
                  [
                    Ty.apply
                      (Ty.path "alloc::collections::btree::map::BTreeMap")
                      []
                      [ T; Ty.path "alloc::collections::btree::set_val::SetValZST"; A ]
                  ],
                  "partial_cmp",
                  [],
                  []
                |),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| self |) |),
                      "alloc::collections::btree::set::BTreeSet",
                      "map"
                    |)
                  |);
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| other |) |),
                          "alloc::collections::btree::set::BTreeSet",
                          "map"
                        |)
                      |)
                    |)
                  |)
                ]
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Axiom Implements :
          forall (T A : Ty.t),
          M.IsTraitInstance
            "core::cmp::PartialOrd"
            (* Trait polymorphic consts *) []
            (* Trait polymorphic types *)
            [ Ty.apply (Ty.path "alloc::collections::btree::set::BTreeSet") [] [ T; A ] ]
            (Self T A)
            (* Instance *) [ ("partial_cmp", InstanceField.Method (partial_cmp T A)) ].
      End Impl_core_cmp_PartialOrd_where_core_cmp_PartialOrd_T_where_core_alloc_Allocator_A_where_core_clone_Clone_A_alloc_collections_btree_set_BTreeSet_T_A_for_alloc_collections_btree_set_BTreeSet_T_A.
      
      Module Impl_core_cmp_Ord_where_core_cmp_Ord_T_where_core_alloc_Allocator_A_where_core_clone_Clone_A_for_alloc_collections_btree_set_BTreeSet_T_A.
        Definition Self (T A : Ty.t) : Ty.t :=
          Ty.apply (Ty.path "alloc::collections::btree::set::BTreeSet") [] [ T; A ].
        
        (*
            fn cmp(&self, other: &BTreeSet<T, A>) -> Ordering {
                self.map.cmp(&other.map)
            }
        *)
        Definition cmp (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self T A in
          match ε, τ, α with
          | [], [], [ self; other ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let other := M.alloc (| other |) in
              M.call_closure (|
                Ty.path "core::cmp::Ordering",
                M.get_trait_method (|
                  "core::cmp::Ord",
                  Ty.apply
                    (Ty.path "alloc::collections::btree::map::BTreeMap")
                    []
                    [ T; Ty.path "alloc::collections::btree::set_val::SetValZST"; A ],
                  [],
                  [],
                  "cmp",
                  [],
                  []
                |),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| self |) |),
                      "alloc::collections::btree::set::BTreeSet",
                      "map"
                    |)
                  |);
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| other |) |),
                          "alloc::collections::btree::set::BTreeSet",
                          "map"
                        |)
                      |)
                    |)
                  |)
                ]
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Axiom Implements :
          forall (T A : Ty.t),
          M.IsTraitInstance
            "core::cmp::Ord"
            (* Trait polymorphic consts *) []
            (* Trait polymorphic types *) []
            (Self T A)
            (* Instance *) [ ("cmp", InstanceField.Method (cmp T A)) ].
      End Impl_core_cmp_Ord_where_core_cmp_Ord_T_where_core_alloc_Allocator_A_where_core_clone_Clone_A_for_alloc_collections_btree_set_BTreeSet_T_A.
      
      Module Impl_core_clone_Clone_where_core_clone_Clone_T_where_core_alloc_Allocator_A_where_core_clone_Clone_A_for_alloc_collections_btree_set_BTreeSet_T_A.
        Definition Self (T A : Ty.t) : Ty.t :=
          Ty.apply (Ty.path "alloc::collections::btree::set::BTreeSet") [] [ T; A ].
        
        (*
            fn clone(&self) -> Self {
                BTreeSet { map: self.map.clone() }
            }
        *)
        Definition clone (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self T A in
          match ε, τ, α with
          | [], [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              Value.StructRecord
                "alloc::collections::btree::set::BTreeSet"
                [
                  ("map",
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "alloc::collections::btree::map::BTreeMap")
                        []
                        [ T; Ty.path "alloc::collections::btree::set_val::SetValZST"; A ],
                      M.get_trait_method (|
                        "core::clone::Clone",
                        Ty.apply
                          (Ty.path "alloc::collections::btree::map::BTreeMap")
                          []
                          [ T; Ty.path "alloc::collections::btree::set_val::SetValZST"; A ],
                        [],
                        [],
                        "clone",
                        [],
                        []
                      |),
                      [
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "alloc::collections::btree::set::BTreeSet",
                            "map"
                          |)
                        |)
                      ]
                    |))
                ]))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        (*
            fn clone_from(&mut self, source: &Self) {
                self.map.clone_from(&source.map);
            }
        *)
        Definition clone_from
            (T A : Ty.t)
            (ε : list Value.t)
            (τ : list Ty.t)
            (α : list Value.t)
            : M :=
          let Self : Ty.t := Self T A in
          match ε, τ, α with
          | [], [], [ self; source ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let source := M.alloc (| source |) in
              M.read (|
                let~ _ : Ty.tuple [] :=
                  M.alloc (|
                    M.call_closure (|
                      Ty.tuple [],
                      M.get_trait_method (|
                        "core::clone::Clone",
                        Ty.apply
                          (Ty.path "alloc::collections::btree::map::BTreeMap")
                          []
                          [ T; Ty.path "alloc::collections::btree::set_val::SetValZST"; A ],
                        [],
                        [],
                        "clone_from",
                        [],
                        []
                      |),
                      [
                        M.borrow (|
                          Pointer.Kind.MutRef,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "alloc::collections::btree::set::BTreeSet",
                            "map"
                          |)
                        |);
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.deref (|
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.SubPointer.get_struct_record_field (|
                                M.deref (| M.read (| source |) |),
                                "alloc::collections::btree::set::BTreeSet",
                                "map"
                              |)
                            |)
                          |)
                        |)
                      ]
                    |)
                  |) in
                M.alloc (| Value.Tuple [] |)
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Axiom Implements :
          forall (T A : Ty.t),
          M.IsTraitInstance
            "core::clone::Clone"
            (* Trait polymorphic consts *) []
            (* Trait polymorphic types *) []
            (Self T A)
            (* Instance *)
            [
              ("clone", InstanceField.Method (clone T A));
              ("clone_from", InstanceField.Method (clone_from T A))
            ].
      End Impl_core_clone_Clone_where_core_clone_Clone_T_where_core_alloc_Allocator_A_where_core_clone_Clone_A_for_alloc_collections_btree_set_BTreeSet_T_A.
      
      (* StructRecord
        {
          name := "Iter";
          const_params := [];
          ty_params := [ "T" ];
          fields :=
            [
              ("iter",
                Ty.apply
                  (Ty.path "alloc::collections::btree::map::Keys")
                  []
                  [ T; Ty.path "alloc::collections::btree::set_val::SetValZST" ])
            ];
        } *)
      
      Module Impl_core_fmt_Debug_where_core_fmt_Debug_T_for_alloc_collections_btree_set_Iter_T.
        Definition Self (T : Ty.t) : Ty.t :=
          Ty.apply (Ty.path "alloc::collections::btree::set::Iter") [] [ T ].
        
        (*
            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                f.debug_tuple("Iter").field(&self.iter.clone()).finish()
            }
        *)
        Definition fmt (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self T in
          match ε, τ, α with
          | [], [], [ self; f ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let f := M.alloc (| f |) in
              M.call_closure (|
                Ty.apply
                  (Ty.path "core::result::Result")
                  []
                  [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                M.get_associated_function (|
                  Ty.path "core::fmt::builders::DebugTuple",
                  "finish",
                  [],
                  []
                |),
                [
                  M.borrow (|
                    Pointer.Kind.MutRef,
                    M.deref (|
                      M.call_closure (|
                        Ty.apply (Ty.path "&mut") [] [ Ty.path "core::fmt::builders::DebugTuple" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::builders::DebugTuple",
                          "field",
                          [],
                          []
                        |),
                        [
                          M.borrow (|
                            Pointer.Kind.MutRef,
                            M.alloc (|
                              M.call_closure (|
                                Ty.path "core::fmt::builders::DebugTuple",
                                M.get_associated_function (|
                                  Ty.path "core::fmt::Formatter",
                                  "debug_tuple",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                                  M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "Iter" |) |) |)
                                ]
                              |)
                            |)
                          |);
                          (* Unsize *)
                          M.pointer_coercion
                            (M.borrow (|
                              Pointer.Kind.Ref,
                              M.deref (|
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.alloc (|
                                    M.call_closure (|
                                      Ty.apply
                                        (Ty.path "alloc::collections::btree::map::Keys")
                                        []
                                        [ T; Ty.path "alloc::collections::btree::set_val::SetValZST"
                                        ],
                                      M.get_trait_method (|
                                        "core::clone::Clone",
                                        Ty.apply
                                          (Ty.path "alloc::collections::btree::map::Keys")
                                          []
                                          [
                                            T;
                                            Ty.path "alloc::collections::btree::set_val::SetValZST"
                                          ],
                                        [],
                                        [],
                                        "clone",
                                        [],
                                        []
                                      |),
                                      [
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.SubPointer.get_struct_record_field (|
                                            M.deref (| M.read (| self |) |),
                                            "alloc::collections::btree::set::Iter",
                                            "iter"
                                          |)
                                        |)
                                      ]
                                    |)
                                  |)
                                |)
                              |)
                            |))
                        ]
                      |)
                    |)
                  |)
                ]
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Axiom Implements :
          forall (T : Ty.t),
          M.IsTraitInstance
            "core::fmt::Debug"
            (* Trait polymorphic consts *) []
            (* Trait polymorphic types *) []
            (Self T)
            (* Instance *) [ ("fmt", InstanceField.Method (fmt T)) ].
      End Impl_core_fmt_Debug_where_core_fmt_Debug_T_for_alloc_collections_btree_set_Iter_T.
      
      (* StructRecord
        {
          name := "IntoIter";
          const_params := [];
          ty_params := [ "T"; "A" ];
          fields :=
            [
              ("iter",
                Ty.apply
                  (Ty.path "alloc::collections::btree::map::IntoIter")
                  []
                  [ T; Ty.path "alloc::collections::btree::set_val::SetValZST"; A ])
            ];
        } *)
      
      Module Impl_core_fmt_Debug_where_core_fmt_Debug_T_where_core_fmt_Debug_A_where_core_alloc_Allocator_A_where_core_clone_Clone_A_for_alloc_collections_btree_set_IntoIter_T_A.
        Definition Self (T A : Ty.t) : Ty.t :=
          Ty.apply (Ty.path "alloc::collections::btree::set::IntoIter") [] [ T; A ].
        
        (* Debug *)
        Definition fmt (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self T A in
          match ε, τ, α with
          | [], [], [ self; f ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let f := M.alloc (| f |) in
              M.call_closure (|
                Ty.apply
                  (Ty.path "core::result::Result")
                  []
                  [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                M.get_associated_function (|
                  Ty.path "core::fmt::Formatter",
                  "debug_struct_field1_finish",
                  [],
                  []
                |),
                [
                  M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                  M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "IntoIter" |) |) |);
                  M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "iter" |) |) |);
                  (* Unsize *)
                  M.pointer_coercion
                    (M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.alloc (|
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.SubPointer.get_struct_record_field (|
                                M.deref (| M.read (| self |) |),
                                "alloc::collections::btree::set::IntoIter",
                                "iter"
                              |)
                            |)
                          |)
                        |)
                      |)
                    |))
                ]
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Axiom Implements :
          forall (T A : Ty.t),
          M.IsTraitInstance
            "core::fmt::Debug"
            (* Trait polymorphic consts *) []
            (* Trait polymorphic types *) []
            (Self T A)
            (* Instance *) [ ("fmt", InstanceField.Method (fmt T A)) ].
      End Impl_core_fmt_Debug_where_core_fmt_Debug_T_where_core_fmt_Debug_A_where_core_alloc_Allocator_A_where_core_clone_Clone_A_for_alloc_collections_btree_set_IntoIter_T_A.
      
      (* StructRecord
        {
          name := "Range";
          const_params := [];
          ty_params := [ "T" ];
          fields :=
            [
              ("iter",
                Ty.apply
                  (Ty.path "alloc::collections::btree::map::Range")
                  []
                  [ T; Ty.path "alloc::collections::btree::set_val::SetValZST" ])
            ];
        } *)
      
      Module Impl_core_fmt_Debug_where_core_fmt_Debug_T_for_alloc_collections_btree_set_Range_T.
        Definition Self (T : Ty.t) : Ty.t :=
          Ty.apply (Ty.path "alloc::collections::btree::set::Range") [] [ T ].
        
        (* Debug *)
        Definition fmt (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self T in
          match ε, τ, α with
          | [], [], [ self; f ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let f := M.alloc (| f |) in
              M.call_closure (|
                Ty.apply
                  (Ty.path "core::result::Result")
                  []
                  [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                M.get_associated_function (|
                  Ty.path "core::fmt::Formatter",
                  "debug_struct_field1_finish",
                  [],
                  []
                |),
                [
                  M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                  M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "Range" |) |) |);
                  M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "iter" |) |) |);
                  (* Unsize *)
                  M.pointer_coercion
                    (M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.alloc (|
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.SubPointer.get_struct_record_field (|
                                M.deref (| M.read (| self |) |),
                                "alloc::collections::btree::set::Range",
                                "iter"
                              |)
                            |)
                          |)
                        |)
                      |)
                    |))
                ]
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Axiom Implements :
          forall (T : Ty.t),
          M.IsTraitInstance
            "core::fmt::Debug"
            (* Trait polymorphic consts *) []
            (* Trait polymorphic types *) []
            (Self T)
            (* Instance *) [ ("fmt", InstanceField.Method (fmt T)) ].
      End Impl_core_fmt_Debug_where_core_fmt_Debug_T_for_alloc_collections_btree_set_Range_T.
      
      (* StructRecord
        {
          name := "Difference";
          const_params := [];
          ty_params := [ "T"; "A" ];
          fields :=
            [
              ("inner",
                Ty.apply (Ty.path "alloc::collections::btree::set::DifferenceInner") [] [ T; A ])
            ];
        } *)
      
      (*
      Enum DifferenceInner
      {
        const_params := [];
        ty_params := [ "T"; "A" ];
        variants :=
          [
            {
              name := "Stitch";
              item :=
                StructRecord
                  [
                    ("self_iter",
                      Ty.apply (Ty.path "alloc::collections::btree::set::Iter") [] [ T ]);
                    ("other_iter",
                      Ty.apply
                        (Ty.path "core::iter::adapters::peekable::Peekable")
                        []
                        [ Ty.apply (Ty.path "alloc::collections::btree::set::Iter") [] [ T ] ])
                  ];
            };
            {
              name := "Search";
              item :=
                StructRecord
                  [
                    ("self_iter",
                      Ty.apply (Ty.path "alloc::collections::btree::set::Iter") [] [ T ]);
                    ("other_set",
                      Ty.apply
                        (Ty.path "&")
                        []
                        [ Ty.apply (Ty.path "alloc::collections::btree::set::BTreeSet") [] [ T; A ]
                        ])
                  ];
            };
            {
              name := "Iterate";
              item :=
                StructTuple [ Ty.apply (Ty.path "alloc::collections::btree::set::Iter") [] [ T ] ];
            }
          ];
      }
      *)
      
      Axiom IsDiscriminant_DifferenceInner_Stitch :
        M.IsDiscriminant "alloc::collections::btree::set::DifferenceInner::Stitch" 0.
      Axiom IsDiscriminant_DifferenceInner_Search :
        M.IsDiscriminant "alloc::collections::btree::set::DifferenceInner::Search" 1.
      Axiom IsDiscriminant_DifferenceInner_Iterate :
        M.IsDiscriminant "alloc::collections::btree::set::DifferenceInner::Iterate" 2.
      
      Module Impl_core_fmt_Debug_where_core_fmt_Debug_T_where_core_alloc_Allocator_A_where_core_clone_Clone_A_for_alloc_collections_btree_set_DifferenceInner_T_A.
        Definition Self (T A : Ty.t) : Ty.t :=
          Ty.apply (Ty.path "alloc::collections::btree::set::DifferenceInner") [] [ T; A ].
        
        (*
            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                match self {
                    DifferenceInner::Stitch { self_iter, other_iter } => f
                        .debug_struct("Stitch")
                        .field("self_iter", self_iter)
                        .field("other_iter", other_iter)
                        .finish(),
                    DifferenceInner::Search { self_iter, other_set } => f
                        .debug_struct("Search")
                        .field("self_iter", self_iter)
                        .field("other_iter", other_set)
                        .finish(),
                    DifferenceInner::Iterate(x) => f.debug_tuple("Iterate").field(x).finish(),
                }
            }
        *)
        Definition fmt (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self T A in
          match ε, τ, α with
          | [], [], [ self; f ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let f := M.alloc (| f |) in
              M.read (|
                M.match_operator (|
                  Some
                    (Ty.apply
                      (Ty.path "core::result::Result")
                      []
                      [ Ty.tuple []; Ty.path "core::fmt::Error" ]),
                  self,
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        let γ1_0 :=
                          M.SubPointer.get_struct_record_field (|
                            γ,
                            "alloc::collections::btree::set::DifferenceInner::Stitch",
                            "self_iter"
                          |) in
                        let γ1_1 :=
                          M.SubPointer.get_struct_record_field (|
                            γ,
                            "alloc::collections::btree::set::DifferenceInner::Stitch",
                            "other_iter"
                          |) in
                        let self_iter := M.alloc (| γ1_0 |) in
                        let other_iter := M.alloc (| γ1_1 |) in
                        M.alloc (|
                          M.call_closure (|
                            Ty.apply
                              (Ty.path "core::result::Result")
                              []
                              [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                            M.get_associated_function (|
                              Ty.path "core::fmt::builders::DebugStruct",
                              "finish",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.MutRef,
                                M.deref (|
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "&mut")
                                      []
                                      [ Ty.path "core::fmt::builders::DebugStruct" ],
                                    M.get_associated_function (|
                                      Ty.path "core::fmt::builders::DebugStruct",
                                      "field",
                                      [],
                                      []
                                    |),
                                    [
                                      M.borrow (|
                                        Pointer.Kind.MutRef,
                                        M.deref (|
                                          M.call_closure (|
                                            Ty.apply
                                              (Ty.path "&mut")
                                              []
                                              [ Ty.path "core::fmt::builders::DebugStruct" ],
                                            M.get_associated_function (|
                                              Ty.path "core::fmt::builders::DebugStruct",
                                              "field",
                                              [],
                                              []
                                            |),
                                            [
                                              M.borrow (|
                                                Pointer.Kind.MutRef,
                                                M.alloc (|
                                                  M.call_closure (|
                                                    Ty.path "core::fmt::builders::DebugStruct",
                                                    M.get_associated_function (|
                                                      Ty.path "core::fmt::Formatter",
                                                      "debug_struct",
                                                      [],
                                                      []
                                                    |),
                                                    [
                                                      M.borrow (|
                                                        Pointer.Kind.MutRef,
                                                        M.deref (| M.read (| f |) |)
                                                      |);
                                                      M.borrow (|
                                                        Pointer.Kind.Ref,
                                                        M.deref (| mk_str (| "Stitch" |) |)
                                                      |)
                                                    ]
                                                  |)
                                                |)
                                              |);
                                              M.borrow (|
                                                Pointer.Kind.Ref,
                                                M.deref (| mk_str (| "self_iter" |) |)
                                              |);
                                              (* Unsize *)
                                              M.pointer_coercion
                                                (M.borrow (|
                                                  Pointer.Kind.Ref,
                                                  M.deref (| M.read (| self_iter |) |)
                                                |))
                                            ]
                                          |)
                                        |)
                                      |);
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.deref (| mk_str (| "other_iter" |) |)
                                      |);
                                      (* Unsize *)
                                      M.pointer_coercion
                                        (M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.deref (| M.read (| other_iter |) |)
                                        |))
                                    ]
                                  |)
                                |)
                              |)
                            ]
                          |)
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        let γ1_0 :=
                          M.SubPointer.get_struct_record_field (|
                            γ,
                            "alloc::collections::btree::set::DifferenceInner::Search",
                            "self_iter"
                          |) in
                        let γ1_1 :=
                          M.SubPointer.get_struct_record_field (|
                            γ,
                            "alloc::collections::btree::set::DifferenceInner::Search",
                            "other_set"
                          |) in
                        let self_iter := M.alloc (| γ1_0 |) in
                        let other_set := M.alloc (| γ1_1 |) in
                        M.alloc (|
                          M.call_closure (|
                            Ty.apply
                              (Ty.path "core::result::Result")
                              []
                              [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                            M.get_associated_function (|
                              Ty.path "core::fmt::builders::DebugStruct",
                              "finish",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.MutRef,
                                M.deref (|
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "&mut")
                                      []
                                      [ Ty.path "core::fmt::builders::DebugStruct" ],
                                    M.get_associated_function (|
                                      Ty.path "core::fmt::builders::DebugStruct",
                                      "field",
                                      [],
                                      []
                                    |),
                                    [
                                      M.borrow (|
                                        Pointer.Kind.MutRef,
                                        M.deref (|
                                          M.call_closure (|
                                            Ty.apply
                                              (Ty.path "&mut")
                                              []
                                              [ Ty.path "core::fmt::builders::DebugStruct" ],
                                            M.get_associated_function (|
                                              Ty.path "core::fmt::builders::DebugStruct",
                                              "field",
                                              [],
                                              []
                                            |),
                                            [
                                              M.borrow (|
                                                Pointer.Kind.MutRef,
                                                M.alloc (|
                                                  M.call_closure (|
                                                    Ty.path "core::fmt::builders::DebugStruct",
                                                    M.get_associated_function (|
                                                      Ty.path "core::fmt::Formatter",
                                                      "debug_struct",
                                                      [],
                                                      []
                                                    |),
                                                    [
                                                      M.borrow (|
                                                        Pointer.Kind.MutRef,
                                                        M.deref (| M.read (| f |) |)
                                                      |);
                                                      M.borrow (|
                                                        Pointer.Kind.Ref,
                                                        M.deref (| mk_str (| "Search" |) |)
                                                      |)
                                                    ]
                                                  |)
                                                |)
                                              |);
                                              M.borrow (|
                                                Pointer.Kind.Ref,
                                                M.deref (| mk_str (| "self_iter" |) |)
                                              |);
                                              (* Unsize *)
                                              M.pointer_coercion
                                                (M.borrow (|
                                                  Pointer.Kind.Ref,
                                                  M.deref (| M.read (| self_iter |) |)
                                                |))
                                            ]
                                          |)
                                        |)
                                      |);
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.deref (| mk_str (| "other_iter" |) |)
                                      |);
                                      (* Unsize *)
                                      M.pointer_coercion
                                        (M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.deref (| M.read (| other_set |) |)
                                        |))
                                    ]
                                  |)
                                |)
                              |)
                            ]
                          |)
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        let γ1_0 :=
                          M.SubPointer.get_struct_tuple_field (|
                            γ,
                            "alloc::collections::btree::set::DifferenceInner::Iterate",
                            0
                          |) in
                        let x := M.alloc (| γ1_0 |) in
                        M.alloc (|
                          M.call_closure (|
                            Ty.apply
                              (Ty.path "core::result::Result")
                              []
                              [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                            M.get_associated_function (|
                              Ty.path "core::fmt::builders::DebugTuple",
                              "finish",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.MutRef,
                                M.deref (|
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "&mut")
                                      []
                                      [ Ty.path "core::fmt::builders::DebugTuple" ],
                                    M.get_associated_function (|
                                      Ty.path "core::fmt::builders::DebugTuple",
                                      "field",
                                      [],
                                      []
                                    |),
                                    [
                                      M.borrow (|
                                        Pointer.Kind.MutRef,
                                        M.alloc (|
                                          M.call_closure (|
                                            Ty.path "core::fmt::builders::DebugTuple",
                                            M.get_associated_function (|
                                              Ty.path "core::fmt::Formatter",
                                              "debug_tuple",
                                              [],
                                              []
                                            |),
                                            [
                                              M.borrow (|
                                                Pointer.Kind.MutRef,
                                                M.deref (| M.read (| f |) |)
                                              |);
                                              M.borrow (|
                                                Pointer.Kind.Ref,
                                                M.deref (| mk_str (| "Iterate" |) |)
                                              |)
                                            ]
                                          |)
                                        |)
                                      |);
                                      (* Unsize *)
                                      M.pointer_coercion
                                        (M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.deref (| M.read (| x |) |)
                                        |))
                                    ]
                                  |)
                                |)
                              |)
                            ]
                          |)
                        |)))
                  ]
                |)
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Axiom Implements :
          forall (T A : Ty.t),
          M.IsTraitInstance
            "core::fmt::Debug"
            (* Trait polymorphic consts *) []
            (* Trait polymorphic types *) []
            (Self T A)
            (* Instance *) [ ("fmt", InstanceField.Method (fmt T A)) ].
      End Impl_core_fmt_Debug_where_core_fmt_Debug_T_where_core_alloc_Allocator_A_where_core_clone_Clone_A_for_alloc_collections_btree_set_DifferenceInner_T_A.
      
      Module Impl_core_fmt_Debug_where_core_fmt_Debug_T_where_core_alloc_Allocator_A_where_core_clone_Clone_A_for_alloc_collections_btree_set_Difference_T_A.
        Definition Self (T A : Ty.t) : Ty.t :=
          Ty.apply (Ty.path "alloc::collections::btree::set::Difference") [] [ T; A ].
        
        (*
            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                f.debug_tuple("Difference").field(&self.inner).finish()
            }
        *)
        Definition fmt (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self T A in
          match ε, τ, α with
          | [], [], [ self; f ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let f := M.alloc (| f |) in
              M.call_closure (|
                Ty.apply
                  (Ty.path "core::result::Result")
                  []
                  [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                M.get_associated_function (|
                  Ty.path "core::fmt::builders::DebugTuple",
                  "finish",
                  [],
                  []
                |),
                [
                  M.borrow (|
                    Pointer.Kind.MutRef,
                    M.deref (|
                      M.call_closure (|
                        Ty.apply (Ty.path "&mut") [] [ Ty.path "core::fmt::builders::DebugTuple" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::builders::DebugTuple",
                          "field",
                          [],
                          []
                        |),
                        [
                          M.borrow (|
                            Pointer.Kind.MutRef,
                            M.alloc (|
                              M.call_closure (|
                                Ty.path "core::fmt::builders::DebugTuple",
                                M.get_associated_function (|
                                  Ty.path "core::fmt::Formatter",
                                  "debug_tuple",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (| mk_str (| "Difference" |) |)
                                  |)
                                ]
                              |)
                            |)
                          |);
                          (* Unsize *)
                          M.pointer_coercion
                            (M.borrow (|
                              Pointer.Kind.Ref,
                              M.deref (|
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.SubPointer.get_struct_record_field (|
                                    M.deref (| M.read (| self |) |),
                                    "alloc::collections::btree::set::Difference",
                                    "inner"
                                  |)
                                |)
                              |)
                            |))
                        ]
                      |)
                    |)
                  |)
                ]
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Axiom Implements :
          forall (T A : Ty.t),
          M.IsTraitInstance
            "core::fmt::Debug"
            (* Trait polymorphic consts *) []
            (* Trait polymorphic types *) []
            (Self T A)
            (* Instance *) [ ("fmt", InstanceField.Method (fmt T A)) ].
      End Impl_core_fmt_Debug_where_core_fmt_Debug_T_where_core_alloc_Allocator_A_where_core_clone_Clone_A_for_alloc_collections_btree_set_Difference_T_A.
      
      (* StructTuple
        {
          name := "SymmetricDifference";
          const_params := [];
          ty_params := [ "T" ];
          fields :=
            [
              Ty.apply
                (Ty.path "alloc::collections::btree::merge_iter::MergeIterInner")
                []
                [ Ty.apply (Ty.path "alloc::collections::btree::set::Iter") [] [ T ] ]
            ];
        } *)
      
      Module Impl_core_fmt_Debug_where_core_fmt_Debug_T_for_alloc_collections_btree_set_SymmetricDifference_T.
        Definition Self (T : Ty.t) : Ty.t :=
          Ty.apply (Ty.path "alloc::collections::btree::set::SymmetricDifference") [] [ T ].
        
        (*
            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                f.debug_tuple("SymmetricDifference").field(&self.0).finish()
            }
        *)
        Definition fmt (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self T in
          match ε, τ, α with
          | [], [], [ self; f ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let f := M.alloc (| f |) in
              M.call_closure (|
                Ty.apply
                  (Ty.path "core::result::Result")
                  []
                  [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                M.get_associated_function (|
                  Ty.path "core::fmt::builders::DebugTuple",
                  "finish",
                  [],
                  []
                |),
                [
                  M.borrow (|
                    Pointer.Kind.MutRef,
                    M.deref (|
                      M.call_closure (|
                        Ty.apply (Ty.path "&mut") [] [ Ty.path "core::fmt::builders::DebugTuple" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::builders::DebugTuple",
                          "field",
                          [],
                          []
                        |),
                        [
                          M.borrow (|
                            Pointer.Kind.MutRef,
                            M.alloc (|
                              M.call_closure (|
                                Ty.path "core::fmt::builders::DebugTuple",
                                M.get_associated_function (|
                                  Ty.path "core::fmt::Formatter",
                                  "debug_tuple",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (| mk_str (| "SymmetricDifference" |) |)
                                  |)
                                ]
                              |)
                            |)
                          |);
                          (* Unsize *)
                          M.pointer_coercion
                            (M.borrow (|
                              Pointer.Kind.Ref,
                              M.deref (|
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.SubPointer.get_struct_tuple_field (|
                                    M.deref (| M.read (| self |) |),
                                    "alloc::collections::btree::set::SymmetricDifference",
                                    0
                                  |)
                                |)
                              |)
                            |))
                        ]
                      |)
                    |)
                  |)
                ]
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Axiom Implements :
          forall (T : Ty.t),
          M.IsTraitInstance
            "core::fmt::Debug"
            (* Trait polymorphic consts *) []
            (* Trait polymorphic types *) []
            (Self T)
            (* Instance *) [ ("fmt", InstanceField.Method (fmt T)) ].
      End Impl_core_fmt_Debug_where_core_fmt_Debug_T_for_alloc_collections_btree_set_SymmetricDifference_T.
      
      (* StructRecord
        {
          name := "Intersection";
          const_params := [];
          ty_params := [ "T"; "A" ];
          fields :=
            [
              ("inner",
                Ty.apply (Ty.path "alloc::collections::btree::set::IntersectionInner") [] [ T; A ])
            ];
        } *)
      
      (*
      Enum IntersectionInner
      {
        const_params := [];
        ty_params := [ "T"; "A" ];
        variants :=
          [
            {
              name := "Stitch";
              item :=
                StructRecord
                  [
                    ("a", Ty.apply (Ty.path "alloc::collections::btree::set::Iter") [] [ T ]);
                    ("b", Ty.apply (Ty.path "alloc::collections::btree::set::Iter") [] [ T ])
                  ];
            };
            {
              name := "Search";
              item :=
                StructRecord
                  [
                    ("small_iter",
                      Ty.apply (Ty.path "alloc::collections::btree::set::Iter") [] [ T ]);
                    ("large_set",
                      Ty.apply
                        (Ty.path "&")
                        []
                        [ Ty.apply (Ty.path "alloc::collections::btree::set::BTreeSet") [] [ T; A ]
                        ])
                  ];
            };
            {
              name := "Answer";
              item :=
                StructTuple
                  [ Ty.apply (Ty.path "core::option::Option") [] [ Ty.apply (Ty.path "&") [] [ T ] ]
                  ];
            }
          ];
      }
      *)
      
      Axiom IsDiscriminant_IntersectionInner_Stitch :
        M.IsDiscriminant "alloc::collections::btree::set::IntersectionInner::Stitch" 0.
      Axiom IsDiscriminant_IntersectionInner_Search :
        M.IsDiscriminant "alloc::collections::btree::set::IntersectionInner::Search" 1.
      Axiom IsDiscriminant_IntersectionInner_Answer :
        M.IsDiscriminant "alloc::collections::btree::set::IntersectionInner::Answer" 2.
      
      Module Impl_core_fmt_Debug_where_core_fmt_Debug_T_where_core_alloc_Allocator_A_where_core_clone_Clone_A_for_alloc_collections_btree_set_IntersectionInner_T_A.
        Definition Self (T A : Ty.t) : Ty.t :=
          Ty.apply (Ty.path "alloc::collections::btree::set::IntersectionInner") [] [ T; A ].
        
        (*
            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                match self {
                    IntersectionInner::Stitch { a, b } => {
                        f.debug_struct("Stitch").field("a", a).field("b", b).finish()
                    }
                    IntersectionInner::Search { small_iter, large_set } => f
                        .debug_struct("Search")
                        .field("small_iter", small_iter)
                        .field("large_set", large_set)
                        .finish(),
                    IntersectionInner::Answer(x) => f.debug_tuple("Answer").field(x).finish(),
                }
            }
        *)
        Definition fmt (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self T A in
          match ε, τ, α with
          | [], [], [ self; f ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let f := M.alloc (| f |) in
              M.read (|
                M.match_operator (|
                  Some
                    (Ty.apply
                      (Ty.path "core::result::Result")
                      []
                      [ Ty.tuple []; Ty.path "core::fmt::Error" ]),
                  self,
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        let γ1_0 :=
                          M.SubPointer.get_struct_record_field (|
                            γ,
                            "alloc::collections::btree::set::IntersectionInner::Stitch",
                            "a"
                          |) in
                        let γ1_1 :=
                          M.SubPointer.get_struct_record_field (|
                            γ,
                            "alloc::collections::btree::set::IntersectionInner::Stitch",
                            "b"
                          |) in
                        let a := M.alloc (| γ1_0 |) in
                        let b := M.alloc (| γ1_1 |) in
                        M.alloc (|
                          M.call_closure (|
                            Ty.apply
                              (Ty.path "core::result::Result")
                              []
                              [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                            M.get_associated_function (|
                              Ty.path "core::fmt::builders::DebugStruct",
                              "finish",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.MutRef,
                                M.deref (|
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "&mut")
                                      []
                                      [ Ty.path "core::fmt::builders::DebugStruct" ],
                                    M.get_associated_function (|
                                      Ty.path "core::fmt::builders::DebugStruct",
                                      "field",
                                      [],
                                      []
                                    |),
                                    [
                                      M.borrow (|
                                        Pointer.Kind.MutRef,
                                        M.deref (|
                                          M.call_closure (|
                                            Ty.apply
                                              (Ty.path "&mut")
                                              []
                                              [ Ty.path "core::fmt::builders::DebugStruct" ],
                                            M.get_associated_function (|
                                              Ty.path "core::fmt::builders::DebugStruct",
                                              "field",
                                              [],
                                              []
                                            |),
                                            [
                                              M.borrow (|
                                                Pointer.Kind.MutRef,
                                                M.alloc (|
                                                  M.call_closure (|
                                                    Ty.path "core::fmt::builders::DebugStruct",
                                                    M.get_associated_function (|
                                                      Ty.path "core::fmt::Formatter",
                                                      "debug_struct",
                                                      [],
                                                      []
                                                    |),
                                                    [
                                                      M.borrow (|
                                                        Pointer.Kind.MutRef,
                                                        M.deref (| M.read (| f |) |)
                                                      |);
                                                      M.borrow (|
                                                        Pointer.Kind.Ref,
                                                        M.deref (| mk_str (| "Stitch" |) |)
                                                      |)
                                                    ]
                                                  |)
                                                |)
                                              |);
                                              M.borrow (|
                                                Pointer.Kind.Ref,
                                                M.deref (| mk_str (| "a" |) |)
                                              |);
                                              (* Unsize *)
                                              M.pointer_coercion
                                                (M.borrow (|
                                                  Pointer.Kind.Ref,
                                                  M.deref (| M.read (| a |) |)
                                                |))
                                            ]
                                          |)
                                        |)
                                      |);
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.deref (| mk_str (| "b" |) |)
                                      |);
                                      (* Unsize *)
                                      M.pointer_coercion
                                        (M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.deref (| M.read (| b |) |)
                                        |))
                                    ]
                                  |)
                                |)
                              |)
                            ]
                          |)
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        let γ1_0 :=
                          M.SubPointer.get_struct_record_field (|
                            γ,
                            "alloc::collections::btree::set::IntersectionInner::Search",
                            "small_iter"
                          |) in
                        let γ1_1 :=
                          M.SubPointer.get_struct_record_field (|
                            γ,
                            "alloc::collections::btree::set::IntersectionInner::Search",
                            "large_set"
                          |) in
                        let small_iter := M.alloc (| γ1_0 |) in
                        let large_set := M.alloc (| γ1_1 |) in
                        M.alloc (|
                          M.call_closure (|
                            Ty.apply
                              (Ty.path "core::result::Result")
                              []
                              [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                            M.get_associated_function (|
                              Ty.path "core::fmt::builders::DebugStruct",
                              "finish",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.MutRef,
                                M.deref (|
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "&mut")
                                      []
                                      [ Ty.path "core::fmt::builders::DebugStruct" ],
                                    M.get_associated_function (|
                                      Ty.path "core::fmt::builders::DebugStruct",
                                      "field",
                                      [],
                                      []
                                    |),
                                    [
                                      M.borrow (|
                                        Pointer.Kind.MutRef,
                                        M.deref (|
                                          M.call_closure (|
                                            Ty.apply
                                              (Ty.path "&mut")
                                              []
                                              [ Ty.path "core::fmt::builders::DebugStruct" ],
                                            M.get_associated_function (|
                                              Ty.path "core::fmt::builders::DebugStruct",
                                              "field",
                                              [],
                                              []
                                            |),
                                            [
                                              M.borrow (|
                                                Pointer.Kind.MutRef,
                                                M.alloc (|
                                                  M.call_closure (|
                                                    Ty.path "core::fmt::builders::DebugStruct",
                                                    M.get_associated_function (|
                                                      Ty.path "core::fmt::Formatter",
                                                      "debug_struct",
                                                      [],
                                                      []
                                                    |),
                                                    [
                                                      M.borrow (|
                                                        Pointer.Kind.MutRef,
                                                        M.deref (| M.read (| f |) |)
                                                      |);
                                                      M.borrow (|
                                                        Pointer.Kind.Ref,
                                                        M.deref (| mk_str (| "Search" |) |)
                                                      |)
                                                    ]
                                                  |)
                                                |)
                                              |);
                                              M.borrow (|
                                                Pointer.Kind.Ref,
                                                M.deref (| mk_str (| "small_iter" |) |)
                                              |);
                                              (* Unsize *)
                                              M.pointer_coercion
                                                (M.borrow (|
                                                  Pointer.Kind.Ref,
                                                  M.deref (| M.read (| small_iter |) |)
                                                |))
                                            ]
                                          |)
                                        |)
                                      |);
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.deref (| mk_str (| "large_set" |) |)
                                      |);
                                      (* Unsize *)
                                      M.pointer_coercion
                                        (M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.deref (| M.read (| large_set |) |)
                                        |))
                                    ]
                                  |)
                                |)
                              |)
                            ]
                          |)
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        let γ1_0 :=
                          M.SubPointer.get_struct_tuple_field (|
                            γ,
                            "alloc::collections::btree::set::IntersectionInner::Answer",
                            0
                          |) in
                        let x := M.alloc (| γ1_0 |) in
                        M.alloc (|
                          M.call_closure (|
                            Ty.apply
                              (Ty.path "core::result::Result")
                              []
                              [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                            M.get_associated_function (|
                              Ty.path "core::fmt::builders::DebugTuple",
                              "finish",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.MutRef,
                                M.deref (|
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "&mut")
                                      []
                                      [ Ty.path "core::fmt::builders::DebugTuple" ],
                                    M.get_associated_function (|
                                      Ty.path "core::fmt::builders::DebugTuple",
                                      "field",
                                      [],
                                      []
                                    |),
                                    [
                                      M.borrow (|
                                        Pointer.Kind.MutRef,
                                        M.alloc (|
                                          M.call_closure (|
                                            Ty.path "core::fmt::builders::DebugTuple",
                                            M.get_associated_function (|
                                              Ty.path "core::fmt::Formatter",
                                              "debug_tuple",
                                              [],
                                              []
                                            |),
                                            [
                                              M.borrow (|
                                                Pointer.Kind.MutRef,
                                                M.deref (| M.read (| f |) |)
                                              |);
                                              M.borrow (|
                                                Pointer.Kind.Ref,
                                                M.deref (| mk_str (| "Answer" |) |)
                                              |)
                                            ]
                                          |)
                                        |)
                                      |);
                                      (* Unsize *)
                                      M.pointer_coercion
                                        (M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.deref (| M.read (| x |) |)
                                        |))
                                    ]
                                  |)
                                |)
                              |)
                            ]
                          |)
                        |)))
                  ]
                |)
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Axiom Implements :
          forall (T A : Ty.t),
          M.IsTraitInstance
            "core::fmt::Debug"
            (* Trait polymorphic consts *) []
            (* Trait polymorphic types *) []
            (Self T A)
            (* Instance *) [ ("fmt", InstanceField.Method (fmt T A)) ].
      End Impl_core_fmt_Debug_where_core_fmt_Debug_T_where_core_alloc_Allocator_A_where_core_clone_Clone_A_for_alloc_collections_btree_set_IntersectionInner_T_A.
      
      Module Impl_core_fmt_Debug_where_core_fmt_Debug_T_where_core_alloc_Allocator_A_where_core_clone_Clone_A_for_alloc_collections_btree_set_Intersection_T_A.
        Definition Self (T A : Ty.t) : Ty.t :=
          Ty.apply (Ty.path "alloc::collections::btree::set::Intersection") [] [ T; A ].
        
        (*
            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                f.debug_tuple("Intersection").field(&self.inner).finish()
            }
        *)
        Definition fmt (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self T A in
          match ε, τ, α with
          | [], [], [ self; f ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let f := M.alloc (| f |) in
              M.call_closure (|
                Ty.apply
                  (Ty.path "core::result::Result")
                  []
                  [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                M.get_associated_function (|
                  Ty.path "core::fmt::builders::DebugTuple",
                  "finish",
                  [],
                  []
                |),
                [
                  M.borrow (|
                    Pointer.Kind.MutRef,
                    M.deref (|
                      M.call_closure (|
                        Ty.apply (Ty.path "&mut") [] [ Ty.path "core::fmt::builders::DebugTuple" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::builders::DebugTuple",
                          "field",
                          [],
                          []
                        |),
                        [
                          M.borrow (|
                            Pointer.Kind.MutRef,
                            M.alloc (|
                              M.call_closure (|
                                Ty.path "core::fmt::builders::DebugTuple",
                                M.get_associated_function (|
                                  Ty.path "core::fmt::Formatter",
                                  "debug_tuple",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (| mk_str (| "Intersection" |) |)
                                  |)
                                ]
                              |)
                            |)
                          |);
                          (* Unsize *)
                          M.pointer_coercion
                            (M.borrow (|
                              Pointer.Kind.Ref,
                              M.deref (|
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.SubPointer.get_struct_record_field (|
                                    M.deref (| M.read (| self |) |),
                                    "alloc::collections::btree::set::Intersection",
                                    "inner"
                                  |)
                                |)
                              |)
                            |))
                        ]
                      |)
                    |)
                  |)
                ]
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Axiom Implements :
          forall (T A : Ty.t),
          M.IsTraitInstance
            "core::fmt::Debug"
            (* Trait polymorphic consts *) []
            (* Trait polymorphic types *) []
            (Self T A)
            (* Instance *) [ ("fmt", InstanceField.Method (fmt T A)) ].
      End Impl_core_fmt_Debug_where_core_fmt_Debug_T_where_core_alloc_Allocator_A_where_core_clone_Clone_A_for_alloc_collections_btree_set_Intersection_T_A.
      
      (* StructTuple
        {
          name := "Union";
          const_params := [];
          ty_params := [ "T" ];
          fields :=
            [
              Ty.apply
                (Ty.path "alloc::collections::btree::merge_iter::MergeIterInner")
                []
                [ Ty.apply (Ty.path "alloc::collections::btree::set::Iter") [] [ T ] ]
            ];
        } *)
      
      Module Impl_core_fmt_Debug_where_core_fmt_Debug_T_for_alloc_collections_btree_set_Union_T.
        Definition Self (T : Ty.t) : Ty.t :=
          Ty.apply (Ty.path "alloc::collections::btree::set::Union") [] [ T ].
        
        (*
            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                f.debug_tuple("Union").field(&self.0).finish()
            }
        *)
        Definition fmt (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self T in
          match ε, τ, α with
          | [], [], [ self; f ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let f := M.alloc (| f |) in
              M.call_closure (|
                Ty.apply
                  (Ty.path "core::result::Result")
                  []
                  [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                M.get_associated_function (|
                  Ty.path "core::fmt::builders::DebugTuple",
                  "finish",
                  [],
                  []
                |),
                [
                  M.borrow (|
                    Pointer.Kind.MutRef,
                    M.deref (|
                      M.call_closure (|
                        Ty.apply (Ty.path "&mut") [] [ Ty.path "core::fmt::builders::DebugTuple" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::builders::DebugTuple",
                          "field",
                          [],
                          []
                        |),
                        [
                          M.borrow (|
                            Pointer.Kind.MutRef,
                            M.alloc (|
                              M.call_closure (|
                                Ty.path "core::fmt::builders::DebugTuple",
                                M.get_associated_function (|
                                  Ty.path "core::fmt::Formatter",
                                  "debug_tuple",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (| mk_str (| "Union" |) |)
                                  |)
                                ]
                              |)
                            |)
                          |);
                          (* Unsize *)
                          M.pointer_coercion
                            (M.borrow (|
                              Pointer.Kind.Ref,
                              M.deref (|
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.SubPointer.get_struct_tuple_field (|
                                    M.deref (| M.read (| self |) |),
                                    "alloc::collections::btree::set::Union",
                                    0
                                  |)
                                |)
                              |)
                            |))
                        ]
                      |)
                    |)
                  |)
                ]
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Axiom Implements :
          forall (T : Ty.t),
          M.IsTraitInstance
            "core::fmt::Debug"
            (* Trait polymorphic consts *) []
            (* Trait polymorphic types *) []
            (Self T)
            (* Instance *) [ ("fmt", InstanceField.Method (fmt T)) ].
      End Impl_core_fmt_Debug_where_core_fmt_Debug_T_for_alloc_collections_btree_set_Union_T.
      
      Definition value_ITER_PERFORMANCE_TIPPING_SIZE_DIFF
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        ltac:(M.monadic (M.alloc (| Value.Integer IntegerKind.Usize 16 |))).
      
      Global Instance Instance_IsConstant_value_ITER_PERFORMANCE_TIPPING_SIZE_DIFF :
        M.IsFunction.C
          "alloc::collections::btree::set::ITER_PERFORMANCE_TIPPING_SIZE_DIFF"
          value_ITER_PERFORMANCE_TIPPING_SIZE_DIFF.
      Admitted.
      Global Typeclasses Opaque value_ITER_PERFORMANCE_TIPPING_SIZE_DIFF.
      
      Module Impl_alloc_collections_btree_set_BTreeSet_T_alloc_alloc_Global.
        Definition Self (T : Ty.t) : Ty.t :=
          Ty.apply
            (Ty.path "alloc::collections::btree::set::BTreeSet")
            []
            [ T; Ty.path "alloc::alloc::Global" ].
        
        (*
            pub const fn new() -> BTreeSet<T> {
                BTreeSet { map: BTreeMap::new() }
            }
        *)
        Definition new (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self T in
          match ε, τ, α with
          | [], [], [] =>
            ltac:(M.monadic
              (Value.StructRecord
                "alloc::collections::btree::set::BTreeSet"
                [
                  ("map",
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "alloc::collections::btree::map::BTreeMap")
                        []
                        [
                          T;
                          Ty.path "alloc::collections::btree::set_val::SetValZST";
                          Ty.path "alloc::alloc::Global"
                        ],
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "alloc::collections::btree::map::BTreeMap")
                          []
                          [
                            T;
                            Ty.path "alloc::collections::btree::set_val::SetValZST";
                            Ty.path "alloc::alloc::Global"
                          ],
                        "new",
                        [],
                        []
                      |),
                      []
                    |))
                ]))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Global Instance AssociatedFunction_new :
          forall (T : Ty.t),
          M.IsAssociatedFunction.C (Self T) "new" (new T).
        Admitted.
        Global Typeclasses Opaque new.
      End Impl_alloc_collections_btree_set_BTreeSet_T_alloc_alloc_Global.
      
      Module Impl_alloc_collections_btree_set_BTreeSet_T_A.
        Definition Self (T A : Ty.t) : Ty.t :=
          Ty.apply (Ty.path "alloc::collections::btree::set::BTreeSet") [] [ T; A ].
        
        (*
            pub const fn new_in(alloc: A) -> BTreeSet<T, A> {
                BTreeSet { map: BTreeMap::new_in(alloc) }
            }
        *)
        Definition new_in (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self T A in
          match ε, τ, α with
          | [], [], [ alloc ] =>
            ltac:(M.monadic
              (let alloc := M.alloc (| alloc |) in
              Value.StructRecord
                "alloc::collections::btree::set::BTreeSet"
                [
                  ("map",
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "alloc::collections::btree::map::BTreeMap")
                        []
                        [ T; Ty.path "alloc::collections::btree::set_val::SetValZST"; A ],
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "alloc::collections::btree::map::BTreeMap")
                          []
                          [ T; Ty.path "alloc::collections::btree::set_val::SetValZST"; A ],
                        "new_in",
                        [],
                        []
                      |),
                      [ M.read (| alloc |) ]
                    |))
                ]))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Global Instance AssociatedFunction_new_in :
          forall (T A : Ty.t),
          M.IsAssociatedFunction.C (Self T A) "new_in" (new_in T A).
        Admitted.
        Global Typeclasses Opaque new_in.
        
        (*
            pub fn range<K: ?Sized, R>(&self, range: R) -> Range<'_, T>
            where
                K: Ord,
                T: Borrow<K> + Ord,
                R: RangeBounds<K>,
            {
                Range { iter: self.map.range(range) }
            }
        *)
        Definition range (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self T A in
          match ε, τ, α with
          | [], [ K; R ], [ self; range ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let range := M.alloc (| range |) in
              Value.StructRecord
                "alloc::collections::btree::set::Range"
                [
                  ("iter",
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "alloc::collections::btree::map::Range")
                        []
                        [ T; Ty.path "alloc::collections::btree::set_val::SetValZST" ],
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "alloc::collections::btree::map::BTreeMap")
                          []
                          [ T; Ty.path "alloc::collections::btree::set_val::SetValZST"; A ],
                        "range",
                        [],
                        [ K; R ]
                      |),
                      [
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "alloc::collections::btree::set::BTreeSet",
                            "map"
                          |)
                        |);
                        M.read (| range |)
                      ]
                    |))
                ]))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Global Instance AssociatedFunction_range :
          forall (T A : Ty.t),
          M.IsAssociatedFunction.C (Self T A) "range" (range T A).
        Admitted.
        Global Typeclasses Opaque range.
        
        (*
            pub fn difference<'a>(&'a self, other: &'a BTreeSet<T, A>) -> Difference<'a, T, A>
            where
                T: Ord,
            {
                let (self_min, self_max) =
                    if let (Some(self_min), Some(self_max)) = (self.first(), self.last()) {
                        (self_min, self_max)
                    } else {
                        return Difference { inner: DifferenceInner::Iterate(self.iter()) };
                    };
                let (other_min, other_max) =
                    if let (Some(other_min), Some(other_max)) = (other.first(), other.last()) {
                        (other_min, other_max)
                    } else {
                        return Difference { inner: DifferenceInner::Iterate(self.iter()) };
                    };
                Difference {
                    inner: match (self_min.cmp(other_max), self_max.cmp(other_min)) {
                        (Greater, _) | (_, Less) => DifferenceInner::Iterate(self.iter()),
                        (Equal, _) => {
                            let mut self_iter = self.iter();
                            self_iter.next();
                            DifferenceInner::Iterate(self_iter)
                        }
                        (_, Equal) => {
                            let mut self_iter = self.iter();
                            self_iter.next_back();
                            DifferenceInner::Iterate(self_iter)
                        }
                        _ if self.len() <= other.len() / ITER_PERFORMANCE_TIPPING_SIZE_DIFF => {
                            DifferenceInner::Search { self_iter: self.iter(), other_set: other }
                        }
                        _ => DifferenceInner::Stitch {
                            self_iter: self.iter(),
                            other_iter: other.iter().peekable(),
                        },
                    },
                }
            }
        *)
        Definition difference
            (T A : Ty.t)
            (ε : list Value.t)
            (τ : list Ty.t)
            (α : list Value.t)
            : M :=
          let Self : Ty.t := Self T A in
          match ε, τ, α with
          | [], [], [ self; other ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let other := M.alloc (| other |) in
              M.catch_return (|
                ltac:(M.monadic
                  (M.read (|
                    M.match_operator (|
                      None,
                      M.match_operator (|
                        Some
                          (Ty.tuple
                            [ Ty.apply (Ty.path "&") [] [ T ]; Ty.apply (Ty.path "&") [] [ T ] ]),
                        M.alloc (| Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.alloc (|
                                  Value.Tuple
                                    [
                                      M.call_closure (|
                                        Ty.apply
                                          (Ty.path "core::option::Option")
                                          []
                                          [ Ty.apply (Ty.path "&") [] [ T ] ],
                                        M.get_associated_function (|
                                          Ty.apply
                                            (Ty.path "alloc::collections::btree::set::BTreeSet")
                                            []
                                            [ T; A ],
                                          "first",
                                          [],
                                          []
                                        |),
                                        [
                                          M.borrow (|
                                            Pointer.Kind.Ref,
                                            M.deref (| M.read (| self |) |)
                                          |)
                                        ]
                                      |);
                                      M.call_closure (|
                                        Ty.apply
                                          (Ty.path "core::option::Option")
                                          []
                                          [ Ty.apply (Ty.path "&") [] [ T ] ],
                                        M.get_associated_function (|
                                          Ty.apply
                                            (Ty.path "alloc::collections::btree::set::BTreeSet")
                                            []
                                            [ T; A ],
                                          "last",
                                          [],
                                          []
                                        |),
                                        [
                                          M.borrow (|
                                            Pointer.Kind.Ref,
                                            M.deref (| M.read (| self |) |)
                                          |)
                                        ]
                                      |)
                                    ]
                                |) in
                              let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                              let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                              let γ1_0 :=
                                M.SubPointer.get_struct_tuple_field (|
                                  γ0_0,
                                  "core::option::Option::Some",
                                  0
                                |) in
                              let self_min := M.copy (| γ1_0 |) in
                              let γ1_0 :=
                                M.SubPointer.get_struct_tuple_field (|
                                  γ0_1,
                                  "core::option::Option::Some",
                                  0
                                |) in
                              let self_max := M.copy (| γ1_0 |) in
                              M.alloc (|
                                Value.Tuple [ M.read (| self_min |); M.read (| self_max |) ]
                              |)));
                          fun γ =>
                            ltac:(M.monadic
                              (M.alloc (|
                                M.never_to_any (|
                                  M.read (|
                                    M.return_ (|
                                      Value.StructRecord
                                        "alloc::collections::btree::set::Difference"
                                        [
                                          ("inner",
                                            Value.StructTuple
                                              "alloc::collections::btree::set::DifferenceInner::Iterate"
                                              [
                                                M.call_closure (|
                                                  Ty.apply
                                                    (Ty.path "alloc::collections::btree::set::Iter")
                                                    []
                                                    [ T ],
                                                  M.get_associated_function (|
                                                    Ty.apply
                                                      (Ty.path
                                                        "alloc::collections::btree::set::BTreeSet")
                                                      []
                                                      [ T; A ],
                                                    "iter",
                                                    [],
                                                    []
                                                  |),
                                                  [
                                                    M.borrow (|
                                                      Pointer.Kind.Ref,
                                                      M.deref (| M.read (| self |) |)
                                                    |)
                                                  ]
                                                |)
                                              ])
                                        ]
                                    |)
                                  |)
                                |)
                              |)))
                        ]
                      |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                            let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                            let self_min := M.copy (| γ0_0 |) in
                            let self_max := M.copy (| γ0_1 |) in
                            M.match_operator (|
                              None,
                              M.match_operator (|
                                Some
                                  (Ty.tuple
                                    [
                                      Ty.apply (Ty.path "&") [] [ T ];
                                      Ty.apply (Ty.path "&") [] [ T ]
                                    ]),
                                M.alloc (| Value.Tuple [] |),
                                [
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let γ :=
                                        M.alloc (|
                                          Value.Tuple
                                            [
                                              M.call_closure (|
                                                Ty.apply
                                                  (Ty.path "core::option::Option")
                                                  []
                                                  [ Ty.apply (Ty.path "&") [] [ T ] ],
                                                M.get_associated_function (|
                                                  Ty.apply
                                                    (Ty.path
                                                      "alloc::collections::btree::set::BTreeSet")
                                                    []
                                                    [ T; A ],
                                                  "first",
                                                  [],
                                                  []
                                                |),
                                                [
                                                  M.borrow (|
                                                    Pointer.Kind.Ref,
                                                    M.deref (| M.read (| other |) |)
                                                  |)
                                                ]
                                              |);
                                              M.call_closure (|
                                                Ty.apply
                                                  (Ty.path "core::option::Option")
                                                  []
                                                  [ Ty.apply (Ty.path "&") [] [ T ] ],
                                                M.get_associated_function (|
                                                  Ty.apply
                                                    (Ty.path
                                                      "alloc::collections::btree::set::BTreeSet")
                                                    []
                                                    [ T; A ],
                                                  "last",
                                                  [],
                                                  []
                                                |),
                                                [
                                                  M.borrow (|
                                                    Pointer.Kind.Ref,
                                                    M.deref (| M.read (| other |) |)
                                                  |)
                                                ]
                                              |)
                                            ]
                                        |) in
                                      let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                      let γ1_0 :=
                                        M.SubPointer.get_struct_tuple_field (|
                                          γ0_0,
                                          "core::option::Option::Some",
                                          0
                                        |) in
                                      let other_min := M.copy (| γ1_0 |) in
                                      let γ1_0 :=
                                        M.SubPointer.get_struct_tuple_field (|
                                          γ0_1,
                                          "core::option::Option::Some",
                                          0
                                        |) in
                                      let other_max := M.copy (| γ1_0 |) in
                                      M.alloc (|
                                        Value.Tuple
                                          [ M.read (| other_min |); M.read (| other_max |) ]
                                      |)));
                                  fun γ =>
                                    ltac:(M.monadic
                                      (M.alloc (|
                                        M.never_to_any (|
                                          M.read (|
                                            M.return_ (|
                                              Value.StructRecord
                                                "alloc::collections::btree::set::Difference"
                                                [
                                                  ("inner",
                                                    Value.StructTuple
                                                      "alloc::collections::btree::set::DifferenceInner::Iterate"
                                                      [
                                                        M.call_closure (|
                                                          Ty.apply
                                                            (Ty.path
                                                              "alloc::collections::btree::set::Iter")
                                                            []
                                                            [ T ],
                                                          M.get_associated_function (|
                                                            Ty.apply
                                                              (Ty.path
                                                                "alloc::collections::btree::set::BTreeSet")
                                                              []
                                                              [ T; A ],
                                                            "iter",
                                                            [],
                                                            []
                                                          |),
                                                          [
                                                            M.borrow (|
                                                              Pointer.Kind.Ref,
                                                              M.deref (| M.read (| self |) |)
                                                            |)
                                                          ]
                                                        |)
                                                      ])
                                                ]
                                            |)
                                          |)
                                        |)
                                      |)))
                                ]
                              |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                    let other_min := M.copy (| γ0_0 |) in
                                    let other_max := M.copy (| γ0_1 |) in
                                    M.alloc (|
                                      Value.StructRecord
                                        "alloc::collections::btree::set::Difference"
                                        [
                                          ("inner",
                                            M.read (|
                                              M.match_operator (|
                                                Some
                                                  (Ty.apply
                                                    (Ty.path
                                                      "alloc::collections::btree::set::DifferenceInner")
                                                    []
                                                    [ T; A ]),
                                                M.alloc (|
                                                  Value.Tuple
                                                    [
                                                      M.call_closure (|
                                                        Ty.path "core::cmp::Ordering",
                                                        M.get_trait_method (|
                                                          "core::cmp::Ord",
                                                          T,
                                                          [],
                                                          [],
                                                          "cmp",
                                                          [],
                                                          []
                                                        |),
                                                        [
                                                          M.borrow (|
                                                            Pointer.Kind.Ref,
                                                            M.deref (| M.read (| self_min |) |)
                                                          |);
                                                          M.borrow (|
                                                            Pointer.Kind.Ref,
                                                            M.deref (| M.read (| other_max |) |)
                                                          |)
                                                        ]
                                                      |);
                                                      M.call_closure (|
                                                        Ty.path "core::cmp::Ordering",
                                                        M.get_trait_method (|
                                                          "core::cmp::Ord",
                                                          T,
                                                          [],
                                                          [],
                                                          "cmp",
                                                          [],
                                                          []
                                                        |),
                                                        [
                                                          M.borrow (|
                                                            Pointer.Kind.Ref,
                                                            M.deref (| M.read (| self_max |) |)
                                                          |);
                                                          M.borrow (|
                                                            Pointer.Kind.Ref,
                                                            M.deref (| M.read (| other_min |) |)
                                                          |)
                                                        ]
                                                      |)
                                                    ]
                                                |),
                                                [
                                                  fun γ =>
                                                    ltac:(M.monadic
                                                      (M.find_or_pattern (|
                                                        γ,
                                                        [
                                                          fun γ =>
                                                            ltac:(M.monadic
                                                              (let γ0_0 :=
                                                                M.SubPointer.get_tuple_field (|
                                                                  γ,
                                                                  0
                                                                |) in
                                                              let γ0_1 :=
                                                                M.SubPointer.get_tuple_field (|
                                                                  γ,
                                                                  1
                                                                |) in
                                                              let _ :=
                                                                M.is_struct_tuple (|
                                                                  γ0_0,
                                                                  "core::cmp::Ordering::Greater"
                                                                |) in
                                                              Value.Tuple []));
                                                          fun γ =>
                                                            ltac:(M.monadic
                                                              (let γ0_0 :=
                                                                M.SubPointer.get_tuple_field (|
                                                                  γ,
                                                                  0
                                                                |) in
                                                              let γ0_1 :=
                                                                M.SubPointer.get_tuple_field (|
                                                                  γ,
                                                                  1
                                                                |) in
                                                              let _ :=
                                                                M.is_struct_tuple (|
                                                                  γ0_1,
                                                                  "core::cmp::Ordering::Less"
                                                                |) in
                                                              Value.Tuple []))
                                                        ],
                                                        fun γ =>
                                                          ltac:(M.monadic
                                                            match γ with
                                                            | [] =>
                                                              ltac:(M.monadic
                                                                (M.alloc (|
                                                                  Value.StructTuple
                                                                    "alloc::collections::btree::set::DifferenceInner::Iterate"
                                                                    [
                                                                      M.call_closure (|
                                                                        Ty.apply
                                                                          (Ty.path
                                                                            "alloc::collections::btree::set::Iter")
                                                                          []
                                                                          [ T ],
                                                                        M.get_associated_function (|
                                                                          Ty.apply
                                                                            (Ty.path
                                                                              "alloc::collections::btree::set::BTreeSet")
                                                                            []
                                                                            [ T; A ],
                                                                          "iter",
                                                                          [],
                                                                          []
                                                                        |),
                                                                        [
                                                                          M.borrow (|
                                                                            Pointer.Kind.Ref,
                                                                            M.deref (|
                                                                              M.read (| self |)
                                                                            |)
                                                                          |)
                                                                        ]
                                                                      |)
                                                                    ]
                                                                |)))
                                                            | _ =>
                                                              M.impossible
                                                                "wrong number of arguments"
                                                            end)
                                                      |)));
                                                  fun γ =>
                                                    ltac:(M.monadic
                                                      (let γ0_0 :=
                                                        M.SubPointer.get_tuple_field (| γ, 0 |) in
                                                      let γ0_1 :=
                                                        M.SubPointer.get_tuple_field (| γ, 1 |) in
                                                      let _ :=
                                                        M.is_struct_tuple (|
                                                          γ0_0,
                                                          "core::cmp::Ordering::Equal"
                                                        |) in
                                                      let~ self_iter :
                                                          Ty.apply
                                                            (Ty.path
                                                              "alloc::collections::btree::set::Iter")
                                                            []
                                                            [ T ] :=
                                                        M.alloc (|
                                                          M.call_closure (|
                                                            Ty.apply
                                                              (Ty.path
                                                                "alloc::collections::btree::set::Iter")
                                                              []
                                                              [ T ],
                                                            M.get_associated_function (|
                                                              Ty.apply
                                                                (Ty.path
                                                                  "alloc::collections::btree::set::BTreeSet")
                                                                []
                                                                [ T; A ],
                                                              "iter",
                                                              [],
                                                              []
                                                            |),
                                                            [
                                                              M.borrow (|
                                                                Pointer.Kind.Ref,
                                                                M.deref (| M.read (| self |) |)
                                                              |)
                                                            ]
                                                          |)
                                                        |) in
                                                      let~ _ :
                                                          Ty.apply
                                                            (Ty.path "core::option::Option")
                                                            []
                                                            [ Ty.apply (Ty.path "&") [] [ T ] ] :=
                                                        M.alloc (|
                                                          M.call_closure (|
                                                            Ty.apply
                                                              (Ty.path "core::option::Option")
                                                              []
                                                              [ Ty.apply (Ty.path "&") [] [ T ] ],
                                                            M.get_trait_method (|
                                                              "core::iter::traits::iterator::Iterator",
                                                              Ty.apply
                                                                (Ty.path
                                                                  "alloc::collections::btree::set::Iter")
                                                                []
                                                                [ T ],
                                                              [],
                                                              [],
                                                              "next",
                                                              [],
                                                              []
                                                            |),
                                                            [
                                                              M.borrow (|
                                                                Pointer.Kind.MutRef,
                                                                self_iter
                                                              |)
                                                            ]
                                                          |)
                                                        |) in
                                                      M.alloc (|
                                                        Value.StructTuple
                                                          "alloc::collections::btree::set::DifferenceInner::Iterate"
                                                          [ M.read (| self_iter |) ]
                                                      |)));
                                                  fun γ =>
                                                    ltac:(M.monadic
                                                      (let γ0_0 :=
                                                        M.SubPointer.get_tuple_field (| γ, 0 |) in
                                                      let γ0_1 :=
                                                        M.SubPointer.get_tuple_field (| γ, 1 |) in
                                                      let _ :=
                                                        M.is_struct_tuple (|
                                                          γ0_1,
                                                          "core::cmp::Ordering::Equal"
                                                        |) in
                                                      let~ self_iter :
                                                          Ty.apply
                                                            (Ty.path
                                                              "alloc::collections::btree::set::Iter")
                                                            []
                                                            [ T ] :=
                                                        M.alloc (|
                                                          M.call_closure (|
                                                            Ty.apply
                                                              (Ty.path
                                                                "alloc::collections::btree::set::Iter")
                                                              []
                                                              [ T ],
                                                            M.get_associated_function (|
                                                              Ty.apply
                                                                (Ty.path
                                                                  "alloc::collections::btree::set::BTreeSet")
                                                                []
                                                                [ T; A ],
                                                              "iter",
                                                              [],
                                                              []
                                                            |),
                                                            [
                                                              M.borrow (|
                                                                Pointer.Kind.Ref,
                                                                M.deref (| M.read (| self |) |)
                                                              |)
                                                            ]
                                                          |)
                                                        |) in
                                                      let~ _ :
                                                          Ty.apply
                                                            (Ty.path "core::option::Option")
                                                            []
                                                            [ Ty.apply (Ty.path "&") [] [ T ] ] :=
                                                        M.alloc (|
                                                          M.call_closure (|
                                                            Ty.apply
                                                              (Ty.path "core::option::Option")
                                                              []
                                                              [ Ty.apply (Ty.path "&") [] [ T ] ],
                                                            M.get_trait_method (|
                                                              "core::iter::traits::double_ended::DoubleEndedIterator",
                                                              Ty.apply
                                                                (Ty.path
                                                                  "alloc::collections::btree::set::Iter")
                                                                []
                                                                [ T ],
                                                              [],
                                                              [],
                                                              "next_back",
                                                              [],
                                                              []
                                                            |),
                                                            [
                                                              M.borrow (|
                                                                Pointer.Kind.MutRef,
                                                                self_iter
                                                              |)
                                                            ]
                                                          |)
                                                        |) in
                                                      M.alloc (|
                                                        Value.StructTuple
                                                          "alloc::collections::btree::set::DifferenceInner::Iterate"
                                                          [ M.read (| self_iter |) ]
                                                      |)));
                                                  fun γ =>
                                                    ltac:(M.monadic
                                                      (let γ :=
                                                        M.alloc (|
                                                          M.call_closure (|
                                                            Ty.path "bool",
                                                            BinOp.le,
                                                            [
                                                              M.call_closure (|
                                                                Ty.path "usize",
                                                                M.get_associated_function (|
                                                                  Ty.apply
                                                                    (Ty.path
                                                                      "alloc::collections::btree::set::BTreeSet")
                                                                    []
                                                                    [ T; A ],
                                                                  "len",
                                                                  [],
                                                                  []
                                                                |),
                                                                [
                                                                  M.borrow (|
                                                                    Pointer.Kind.Ref,
                                                                    M.deref (| M.read (| self |) |)
                                                                  |)
                                                                ]
                                                              |);
                                                              M.call_closure (|
                                                                Ty.path "usize",
                                                                BinOp.Wrap.div,
                                                                [
                                                                  M.call_closure (|
                                                                    Ty.path "usize",
                                                                    M.get_associated_function (|
                                                                      Ty.apply
                                                                        (Ty.path
                                                                          "alloc::collections::btree::set::BTreeSet")
                                                                        []
                                                                        [ T; A ],
                                                                      "len",
                                                                      [],
                                                                      []
                                                                    |),
                                                                    [
                                                                      M.borrow (|
                                                                        Pointer.Kind.Ref,
                                                                        M.deref (|
                                                                          M.read (| other |)
                                                                        |)
                                                                      |)
                                                                    ]
                                                                  |);
                                                                  M.read (|
                                                                    get_constant (|
                                                                      "alloc::collections::btree::set::ITER_PERFORMANCE_TIPPING_SIZE_DIFF",
                                                                      Ty.path "usize"
                                                                    |)
                                                                  |)
                                                                ]
                                                              |)
                                                            ]
                                                          |)
                                                        |) in
                                                      let _ :=
                                                        is_constant_or_break_match (|
                                                          M.read (| γ |),
                                                          Value.Bool true
                                                        |) in
                                                      M.alloc (|
                                                        Value.StructRecord
                                                          "alloc::collections::btree::set::DifferenceInner::Search"
                                                          [
                                                            ("self_iter",
                                                              M.call_closure (|
                                                                Ty.apply
                                                                  (Ty.path
                                                                    "alloc::collections::btree::set::Iter")
                                                                  []
                                                                  [ T ],
                                                                M.get_associated_function (|
                                                                  Ty.apply
                                                                    (Ty.path
                                                                      "alloc::collections::btree::set::BTreeSet")
                                                                    []
                                                                    [ T; A ],
                                                                  "iter",
                                                                  [],
                                                                  []
                                                                |),
                                                                [
                                                                  M.borrow (|
                                                                    Pointer.Kind.Ref,
                                                                    M.deref (| M.read (| self |) |)
                                                                  |)
                                                                ]
                                                              |));
                                                            ("other_set",
                                                              M.borrow (|
                                                                Pointer.Kind.Ref,
                                                                M.deref (| M.read (| other |) |)
                                                              |))
                                                          ]
                                                      |)));
                                                  fun γ =>
                                                    ltac:(M.monadic
                                                      (M.alloc (|
                                                        Value.StructRecord
                                                          "alloc::collections::btree::set::DifferenceInner::Stitch"
                                                          [
                                                            ("self_iter",
                                                              M.call_closure (|
                                                                Ty.apply
                                                                  (Ty.path
                                                                    "alloc::collections::btree::set::Iter")
                                                                  []
                                                                  [ T ],
                                                                M.get_associated_function (|
                                                                  Ty.apply
                                                                    (Ty.path
                                                                      "alloc::collections::btree::set::BTreeSet")
                                                                    []
                                                                    [ T; A ],
                                                                  "iter",
                                                                  [],
                                                                  []
                                                                |),
                                                                [
                                                                  M.borrow (|
                                                                    Pointer.Kind.Ref,
                                                                    M.deref (| M.read (| self |) |)
                                                                  |)
                                                                ]
                                                              |));
                                                            ("other_iter",
                                                              M.call_closure (|
                                                                Ty.apply
                                                                  (Ty.path
                                                                    "core::iter::adapters::peekable::Peekable")
                                                                  []
                                                                  [
                                                                    Ty.apply
                                                                      (Ty.path
                                                                        "alloc::collections::btree::set::Iter")
                                                                      []
                                                                      [ T ]
                                                                  ],
                                                                M.get_trait_method (|
                                                                  "core::iter::traits::iterator::Iterator",
                                                                  Ty.apply
                                                                    (Ty.path
                                                                      "alloc::collections::btree::set::Iter")
                                                                    []
                                                                    [ T ],
                                                                  [],
                                                                  [],
                                                                  "peekable",
                                                                  [],
                                                                  []
                                                                |),
                                                                [
                                                                  M.call_closure (|
                                                                    Ty.apply
                                                                      (Ty.path
                                                                        "alloc::collections::btree::set::Iter")
                                                                      []
                                                                      [ T ],
                                                                    M.get_associated_function (|
                                                                      Ty.apply
                                                                        (Ty.path
                                                                          "alloc::collections::btree::set::BTreeSet")
                                                                        []
                                                                        [ T; A ],
                                                                      "iter",
                                                                      [],
                                                                      []
                                                                    |),
                                                                    [
                                                                      M.borrow (|
                                                                        Pointer.Kind.Ref,
                                                                        M.deref (|
                                                                          M.read (| other |)
                                                                        |)
                                                                      |)
                                                                    ]
                                                                  |)
                                                                ]
                                                              |))
                                                          ]
                                                      |)))
                                                ]
                                              |)
                                            |))
                                        ]
                                    |)))
                              ]
                            |)))
                      ]
                    |)
                  |)))
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Global Instance AssociatedFunction_difference :
          forall (T A : Ty.t),
          M.IsAssociatedFunction.C (Self T A) "difference" (difference T A).
        Admitted.
        Global Typeclasses Opaque difference.
        
        (*
            pub fn symmetric_difference<'a>(
                &'a self,
                other: &'a BTreeSet<T, A>,
            ) -> SymmetricDifference<'a, T>
            where
                T: Ord,
            {
                SymmetricDifference(MergeIterInner::new(self.iter(), other.iter()))
            }
        *)
        Definition symmetric_difference
            (T A : Ty.t)
            (ε : list Value.t)
            (τ : list Ty.t)
            (α : list Value.t)
            : M :=
          let Self : Ty.t := Self T A in
          match ε, τ, α with
          | [], [], [ self; other ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let other := M.alloc (| other |) in
              Value.StructTuple
                "alloc::collections::btree::set::SymmetricDifference"
                [
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "alloc::collections::btree::merge_iter::MergeIterInner")
                      []
                      [ Ty.apply (Ty.path "alloc::collections::btree::set::Iter") [] [ T ] ],
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "alloc::collections::btree::merge_iter::MergeIterInner")
                        []
                        [ Ty.apply (Ty.path "alloc::collections::btree::set::Iter") [] [ T ] ],
                      "new",
                      [],
                      []
                    |),
                    [
                      M.call_closure (|
                        Ty.apply (Ty.path "alloc::collections::btree::set::Iter") [] [ T ],
                        M.get_associated_function (|
                          Ty.apply (Ty.path "alloc::collections::btree::set::BTreeSet") [] [ T; A ],
                          "iter",
                          [],
                          []
                        |),
                        [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                      |);
                      M.call_closure (|
                        Ty.apply (Ty.path "alloc::collections::btree::set::Iter") [] [ T ],
                        M.get_associated_function (|
                          Ty.apply (Ty.path "alloc::collections::btree::set::BTreeSet") [] [ T; A ],
                          "iter",
                          [],
                          []
                        |),
                        [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| other |) |) |) ]
                      |)
                    ]
                  |)
                ]))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Global Instance AssociatedFunction_symmetric_difference :
          forall (T A : Ty.t),
          M.IsAssociatedFunction.C (Self T A) "symmetric_difference" (symmetric_difference T A).
        Admitted.
        Global Typeclasses Opaque symmetric_difference.
        
        (*
            pub fn intersection<'a>(&'a self, other: &'a BTreeSet<T, A>) -> Intersection<'a, T, A>
            where
                T: Ord,
            {
                let (self_min, self_max) =
                    if let (Some(self_min), Some(self_max)) = (self.first(), self.last()) {
                        (self_min, self_max)
                    } else {
                        return Intersection { inner: IntersectionInner::Answer(None) };
                    };
                let (other_min, other_max) =
                    if let (Some(other_min), Some(other_max)) = (other.first(), other.last()) {
                        (other_min, other_max)
                    } else {
                        return Intersection { inner: IntersectionInner::Answer(None) };
                    };
                Intersection {
                    inner: match (self_min.cmp(other_max), self_max.cmp(other_min)) {
                        (Greater, _) | (_, Less) => IntersectionInner::Answer(None),
                        (Equal, _) => IntersectionInner::Answer(Some(self_min)),
                        (_, Equal) => IntersectionInner::Answer(Some(self_max)),
                        _ if self.len() <= other.len() / ITER_PERFORMANCE_TIPPING_SIZE_DIFF => {
                            IntersectionInner::Search { small_iter: self.iter(), large_set: other }
                        }
                        _ if other.len() <= self.len() / ITER_PERFORMANCE_TIPPING_SIZE_DIFF => {
                            IntersectionInner::Search { small_iter: other.iter(), large_set: self }
                        }
                        _ => IntersectionInner::Stitch { a: self.iter(), b: other.iter() },
                    },
                }
            }
        *)
        Definition intersection
            (T A : Ty.t)
            (ε : list Value.t)
            (τ : list Ty.t)
            (α : list Value.t)
            : M :=
          let Self : Ty.t := Self T A in
          match ε, τ, α with
          | [], [], [ self; other ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let other := M.alloc (| other |) in
              M.catch_return (|
                ltac:(M.monadic
                  (M.read (|
                    M.match_operator (|
                      None,
                      M.match_operator (|
                        Some
                          (Ty.tuple
                            [ Ty.apply (Ty.path "&") [] [ T ]; Ty.apply (Ty.path "&") [] [ T ] ]),
                        M.alloc (| Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.alloc (|
                                  Value.Tuple
                                    [
                                      M.call_closure (|
                                        Ty.apply
                                          (Ty.path "core::option::Option")
                                          []
                                          [ Ty.apply (Ty.path "&") [] [ T ] ],
                                        M.get_associated_function (|
                                          Ty.apply
                                            (Ty.path "alloc::collections::btree::set::BTreeSet")
                                            []
                                            [ T; A ],
                                          "first",
                                          [],
                                          []
                                        |),
                                        [
                                          M.borrow (|
                                            Pointer.Kind.Ref,
                                            M.deref (| M.read (| self |) |)
                                          |)
                                        ]
                                      |);
                                      M.call_closure (|
                                        Ty.apply
                                          (Ty.path "core::option::Option")
                                          []
                                          [ Ty.apply (Ty.path "&") [] [ T ] ],
                                        M.get_associated_function (|
                                          Ty.apply
                                            (Ty.path "alloc::collections::btree::set::BTreeSet")
                                            []
                                            [ T; A ],
                                          "last",
                                          [],
                                          []
                                        |),
                                        [
                                          M.borrow (|
                                            Pointer.Kind.Ref,
                                            M.deref (| M.read (| self |) |)
                                          |)
                                        ]
                                      |)
                                    ]
                                |) in
                              let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                              let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                              let γ1_0 :=
                                M.SubPointer.get_struct_tuple_field (|
                                  γ0_0,
                                  "core::option::Option::Some",
                                  0
                                |) in
                              let self_min := M.copy (| γ1_0 |) in
                              let γ1_0 :=
                                M.SubPointer.get_struct_tuple_field (|
                                  γ0_1,
                                  "core::option::Option::Some",
                                  0
                                |) in
                              let self_max := M.copy (| γ1_0 |) in
                              M.alloc (|
                                Value.Tuple [ M.read (| self_min |); M.read (| self_max |) ]
                              |)));
                          fun γ =>
                            ltac:(M.monadic
                              (M.alloc (|
                                M.never_to_any (|
                                  M.read (|
                                    M.return_ (|
                                      Value.StructRecord
                                        "alloc::collections::btree::set::Intersection"
                                        [
                                          ("inner",
                                            Value.StructTuple
                                              "alloc::collections::btree::set::IntersectionInner::Answer"
                                              [ Value.StructTuple "core::option::Option::None" [] ])
                                        ]
                                    |)
                                  |)
                                |)
                              |)))
                        ]
                      |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                            let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                            let self_min := M.copy (| γ0_0 |) in
                            let self_max := M.copy (| γ0_1 |) in
                            M.match_operator (|
                              None,
                              M.match_operator (|
                                Some
                                  (Ty.tuple
                                    [
                                      Ty.apply (Ty.path "&") [] [ T ];
                                      Ty.apply (Ty.path "&") [] [ T ]
                                    ]),
                                M.alloc (| Value.Tuple [] |),
                                [
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let γ :=
                                        M.alloc (|
                                          Value.Tuple
                                            [
                                              M.call_closure (|
                                                Ty.apply
                                                  (Ty.path "core::option::Option")
                                                  []
                                                  [ Ty.apply (Ty.path "&") [] [ T ] ],
                                                M.get_associated_function (|
                                                  Ty.apply
                                                    (Ty.path
                                                      "alloc::collections::btree::set::BTreeSet")
                                                    []
                                                    [ T; A ],
                                                  "first",
                                                  [],
                                                  []
                                                |),
                                                [
                                                  M.borrow (|
                                                    Pointer.Kind.Ref,
                                                    M.deref (| M.read (| other |) |)
                                                  |)
                                                ]
                                              |);
                                              M.call_closure (|
                                                Ty.apply
                                                  (Ty.path "core::option::Option")
                                                  []
                                                  [ Ty.apply (Ty.path "&") [] [ T ] ],
                                                M.get_associated_function (|
                                                  Ty.apply
                                                    (Ty.path
                                                      "alloc::collections::btree::set::BTreeSet")
                                                    []
                                                    [ T; A ],
                                                  "last",
                                                  [],
                                                  []
                                                |),
                                                [
                                                  M.borrow (|
                                                    Pointer.Kind.Ref,
                                                    M.deref (| M.read (| other |) |)
                                                  |)
                                                ]
                                              |)
                                            ]
                                        |) in
                                      let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                      let γ1_0 :=
                                        M.SubPointer.get_struct_tuple_field (|
                                          γ0_0,
                                          "core::option::Option::Some",
                                          0
                                        |) in
                                      let other_min := M.copy (| γ1_0 |) in
                                      let γ1_0 :=
                                        M.SubPointer.get_struct_tuple_field (|
                                          γ0_1,
                                          "core::option::Option::Some",
                                          0
                                        |) in
                                      let other_max := M.copy (| γ1_0 |) in
                                      M.alloc (|
                                        Value.Tuple
                                          [ M.read (| other_min |); M.read (| other_max |) ]
                                      |)));
                                  fun γ =>
                                    ltac:(M.monadic
                                      (M.alloc (|
                                        M.never_to_any (|
                                          M.read (|
                                            M.return_ (|
                                              Value.StructRecord
                                                "alloc::collections::btree::set::Intersection"
                                                [
                                                  ("inner",
                                                    Value.StructTuple
                                                      "alloc::collections::btree::set::IntersectionInner::Answer"
                                                      [
                                                        Value.StructTuple
                                                          "core::option::Option::None"
                                                          []
                                                      ])
                                                ]
                                            |)
                                          |)
                                        |)
                                      |)))
                                ]
                              |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                    let other_min := M.copy (| γ0_0 |) in
                                    let other_max := M.copy (| γ0_1 |) in
                                    M.alloc (|
                                      Value.StructRecord
                                        "alloc::collections::btree::set::Intersection"
                                        [
                                          ("inner",
                                            M.read (|
                                              M.match_operator (|
                                                Some
                                                  (Ty.apply
                                                    (Ty.path
                                                      "alloc::collections::btree::set::IntersectionInner")
                                                    []
                                                    [ T; A ]),
                                                M.alloc (|
                                                  Value.Tuple
                                                    [
                                                      M.call_closure (|
                                                        Ty.path "core::cmp::Ordering",
                                                        M.get_trait_method (|
                                                          "core::cmp::Ord",
                                                          T,
                                                          [],
                                                          [],
                                                          "cmp",
                                                          [],
                                                          []
                                                        |),
                                                        [
                                                          M.borrow (|
                                                            Pointer.Kind.Ref,
                                                            M.deref (| M.read (| self_min |) |)
                                                          |);
                                                          M.borrow (|
                                                            Pointer.Kind.Ref,
                                                            M.deref (| M.read (| other_max |) |)
                                                          |)
                                                        ]
                                                      |);
                                                      M.call_closure (|
                                                        Ty.path "core::cmp::Ordering",
                                                        M.get_trait_method (|
                                                          "core::cmp::Ord",
                                                          T,
                                                          [],
                                                          [],
                                                          "cmp",
                                                          [],
                                                          []
                                                        |),
                                                        [
                                                          M.borrow (|
                                                            Pointer.Kind.Ref,
                                                            M.deref (| M.read (| self_max |) |)
                                                          |);
                                                          M.borrow (|
                                                            Pointer.Kind.Ref,
                                                            M.deref (| M.read (| other_min |) |)
                                                          |)
                                                        ]
                                                      |)
                                                    ]
                                                |),
                                                [
                                                  fun γ =>
                                                    ltac:(M.monadic
                                                      (M.find_or_pattern (|
                                                        γ,
                                                        [
                                                          fun γ =>
                                                            ltac:(M.monadic
                                                              (let γ0_0 :=
                                                                M.SubPointer.get_tuple_field (|
                                                                  γ,
                                                                  0
                                                                |) in
                                                              let γ0_1 :=
                                                                M.SubPointer.get_tuple_field (|
                                                                  γ,
                                                                  1
                                                                |) in
                                                              let _ :=
                                                                M.is_struct_tuple (|
                                                                  γ0_0,
                                                                  "core::cmp::Ordering::Greater"
                                                                |) in
                                                              Value.Tuple []));
                                                          fun γ =>
                                                            ltac:(M.monadic
                                                              (let γ0_0 :=
                                                                M.SubPointer.get_tuple_field (|
                                                                  γ,
                                                                  0
                                                                |) in
                                                              let γ0_1 :=
                                                                M.SubPointer.get_tuple_field (|
                                                                  γ,
                                                                  1
                                                                |) in
                                                              let _ :=
                                                                M.is_struct_tuple (|
                                                                  γ0_1,
                                                                  "core::cmp::Ordering::Less"
                                                                |) in
                                                              Value.Tuple []))
                                                        ],
                                                        fun γ =>
                                                          ltac:(M.monadic
                                                            match γ with
                                                            | [] =>
                                                              ltac:(M.monadic
                                                                (M.alloc (|
                                                                  Value.StructTuple
                                                                    "alloc::collections::btree::set::IntersectionInner::Answer"
                                                                    [
                                                                      Value.StructTuple
                                                                        "core::option::Option::None"
                                                                        []
                                                                    ]
                                                                |)))
                                                            | _ =>
                                                              M.impossible
                                                                "wrong number of arguments"
                                                            end)
                                                      |)));
                                                  fun γ =>
                                                    ltac:(M.monadic
                                                      (let γ0_0 :=
                                                        M.SubPointer.get_tuple_field (| γ, 0 |) in
                                                      let γ0_1 :=
                                                        M.SubPointer.get_tuple_field (| γ, 1 |) in
                                                      let _ :=
                                                        M.is_struct_tuple (|
                                                          γ0_0,
                                                          "core::cmp::Ordering::Equal"
                                                        |) in
                                                      M.alloc (|
                                                        Value.StructTuple
                                                          "alloc::collections::btree::set::IntersectionInner::Answer"
                                                          [
                                                            Value.StructTuple
                                                              "core::option::Option::Some"
                                                              [
                                                                M.borrow (|
                                                                  Pointer.Kind.Ref,
                                                                  M.deref (|
                                                                    M.read (| self_min |)
                                                                  |)
                                                                |)
                                                              ]
                                                          ]
                                                      |)));
                                                  fun γ =>
                                                    ltac:(M.monadic
                                                      (let γ0_0 :=
                                                        M.SubPointer.get_tuple_field (| γ, 0 |) in
                                                      let γ0_1 :=
                                                        M.SubPointer.get_tuple_field (| γ, 1 |) in
                                                      let _ :=
                                                        M.is_struct_tuple (|
                                                          γ0_1,
                                                          "core::cmp::Ordering::Equal"
                                                        |) in
                                                      M.alloc (|
                                                        Value.StructTuple
                                                          "alloc::collections::btree::set::IntersectionInner::Answer"
                                                          [
                                                            Value.StructTuple
                                                              "core::option::Option::Some"
                                                              [
                                                                M.borrow (|
                                                                  Pointer.Kind.Ref,
                                                                  M.deref (|
                                                                    M.read (| self_max |)
                                                                  |)
                                                                |)
                                                              ]
                                                          ]
                                                      |)));
                                                  fun γ =>
                                                    ltac:(M.monadic
                                                      (let γ :=
                                                        M.alloc (|
                                                          M.call_closure (|
                                                            Ty.path "bool",
                                                            BinOp.le,
                                                            [
                                                              M.call_closure (|
                                                                Ty.path "usize",
                                                                M.get_associated_function (|
                                                                  Ty.apply
                                                                    (Ty.path
                                                                      "alloc::collections::btree::set::BTreeSet")
                                                                    []
                                                                    [ T; A ],
                                                                  "len",
                                                                  [],
                                                                  []
                                                                |),
                                                                [
                                                                  M.borrow (|
                                                                    Pointer.Kind.Ref,
                                                                    M.deref (| M.read (| self |) |)
                                                                  |)
                                                                ]
                                                              |);
                                                              M.call_closure (|
                                                                Ty.path "usize",
                                                                BinOp.Wrap.div,
                                                                [
                                                                  M.call_closure (|
                                                                    Ty.path "usize",
                                                                    M.get_associated_function (|
                                                                      Ty.apply
                                                                        (Ty.path
                                                                          "alloc::collections::btree::set::BTreeSet")
                                                                        []
                                                                        [ T; A ],
                                                                      "len",
                                                                      [],
                                                                      []
                                                                    |),
                                                                    [
                                                                      M.borrow (|
                                                                        Pointer.Kind.Ref,
                                                                        M.deref (|
                                                                          M.read (| other |)
                                                                        |)
                                                                      |)
                                                                    ]
                                                                  |);
                                                                  M.read (|
                                                                    get_constant (|
                                                                      "alloc::collections::btree::set::ITER_PERFORMANCE_TIPPING_SIZE_DIFF",
                                                                      Ty.path "usize"
                                                                    |)
                                                                  |)
                                                                ]
                                                              |)
                                                            ]
                                                          |)
                                                        |) in
                                                      let _ :=
                                                        is_constant_or_break_match (|
                                                          M.read (| γ |),
                                                          Value.Bool true
                                                        |) in
                                                      M.alloc (|
                                                        Value.StructRecord
                                                          "alloc::collections::btree::set::IntersectionInner::Search"
                                                          [
                                                            ("small_iter",
                                                              M.call_closure (|
                                                                Ty.apply
                                                                  (Ty.path
                                                                    "alloc::collections::btree::set::Iter")
                                                                  []
                                                                  [ T ],
                                                                M.get_associated_function (|
                                                                  Ty.apply
                                                                    (Ty.path
                                                                      "alloc::collections::btree::set::BTreeSet")
                                                                    []
                                                                    [ T; A ],
                                                                  "iter",
                                                                  [],
                                                                  []
                                                                |),
                                                                [
                                                                  M.borrow (|
                                                                    Pointer.Kind.Ref,
                                                                    M.deref (| M.read (| self |) |)
                                                                  |)
                                                                ]
                                                              |));
                                                            ("large_set",
                                                              M.borrow (|
                                                                Pointer.Kind.Ref,
                                                                M.deref (| M.read (| other |) |)
                                                              |))
                                                          ]
                                                      |)));
                                                  fun γ =>
                                                    ltac:(M.monadic
                                                      (let γ :=
                                                        M.alloc (|
                                                          M.call_closure (|
                                                            Ty.path "bool",
                                                            BinOp.le,
                                                            [
                                                              M.call_closure (|
                                                                Ty.path "usize",
                                                                M.get_associated_function (|
                                                                  Ty.apply
                                                                    (Ty.path
                                                                      "alloc::collections::btree::set::BTreeSet")
                                                                    []
                                                                    [ T; A ],
                                                                  "len",
                                                                  [],
                                                                  []
                                                                |),
                                                                [
                                                                  M.borrow (|
                                                                    Pointer.Kind.Ref,
                                                                    M.deref (| M.read (| other |) |)
                                                                  |)
                                                                ]
                                                              |);
                                                              M.call_closure (|
                                                                Ty.path "usize",
                                                                BinOp.Wrap.div,
                                                                [
                                                                  M.call_closure (|
                                                                    Ty.path "usize",
                                                                    M.get_associated_function (|
                                                                      Ty.apply
                                                                        (Ty.path
                                                                          "alloc::collections::btree::set::BTreeSet")
                                                                        []
                                                                        [ T; A ],
                                                                      "len",
                                                                      [],
                                                                      []
                                                                    |),
                                                                    [
                                                                      M.borrow (|
                                                                        Pointer.Kind.Ref,
                                                                        M.deref (|
                                                                          M.read (| self |)
                                                                        |)
                                                                      |)
                                                                    ]
                                                                  |);
                                                                  M.read (|
                                                                    get_constant (|
                                                                      "alloc::collections::btree::set::ITER_PERFORMANCE_TIPPING_SIZE_DIFF",
                                                                      Ty.path "usize"
                                                                    |)
                                                                  |)
                                                                ]
                                                              |)
                                                            ]
                                                          |)
                                                        |) in
                                                      let _ :=
                                                        is_constant_or_break_match (|
                                                          M.read (| γ |),
                                                          Value.Bool true
                                                        |) in
                                                      M.alloc (|
                                                        Value.StructRecord
                                                          "alloc::collections::btree::set::IntersectionInner::Search"
                                                          [
                                                            ("small_iter",
                                                              M.call_closure (|
                                                                Ty.apply
                                                                  (Ty.path
                                                                    "alloc::collections::btree::set::Iter")
                                                                  []
                                                                  [ T ],
                                                                M.get_associated_function (|
                                                                  Ty.apply
                                                                    (Ty.path
                                                                      "alloc::collections::btree::set::BTreeSet")
                                                                    []
                                                                    [ T; A ],
                                                                  "iter",
                                                                  [],
                                                                  []
                                                                |),
                                                                [
                                                                  M.borrow (|
                                                                    Pointer.Kind.Ref,
                                                                    M.deref (| M.read (| other |) |)
                                                                  |)
                                                                ]
                                                              |));
                                                            ("large_set",
                                                              M.borrow (|
                                                                Pointer.Kind.Ref,
                                                                M.deref (| M.read (| self |) |)
                                                              |))
                                                          ]
                                                      |)));
                                                  fun γ =>
                                                    ltac:(M.monadic
                                                      (M.alloc (|
                                                        Value.StructRecord
                                                          "alloc::collections::btree::set::IntersectionInner::Stitch"
                                                          [
                                                            ("a",
                                                              M.call_closure (|
                                                                Ty.apply
                                                                  (Ty.path
                                                                    "alloc::collections::btree::set::Iter")
                                                                  []
                                                                  [ T ],
                                                                M.get_associated_function (|
                                                                  Ty.apply
                                                                    (Ty.path
                                                                      "alloc::collections::btree::set::BTreeSet")
                                                                    []
                                                                    [ T; A ],
                                                                  "iter",
                                                                  [],
                                                                  []
                                                                |),
                                                                [
                                                                  M.borrow (|
                                                                    Pointer.Kind.Ref,
                                                                    M.deref (| M.read (| self |) |)
                                                                  |)
                                                                ]
                                                              |));
                                                            ("b",
                                                              M.call_closure (|
                                                                Ty.apply
                                                                  (Ty.path
                                                                    "alloc::collections::btree::set::Iter")
                                                                  []
                                                                  [ T ],
                                                                M.get_associated_function (|
                                                                  Ty.apply
                                                                    (Ty.path
                                                                      "alloc::collections::btree::set::BTreeSet")
                                                                    []
                                                                    [ T; A ],
                                                                  "iter",
                                                                  [],
                                                                  []
                                                                |),
                                                                [
                                                                  M.borrow (|
                                                                    Pointer.Kind.Ref,
                                                                    M.deref (| M.read (| other |) |)
                                                                  |)
                                                                ]
                                                              |))
                                                          ]
                                                      |)))
                                                ]
                                              |)
                                            |))
                                        ]
                                    |)))
                              ]
                            |)))
                      ]
                    |)
                  |)))
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Global Instance AssociatedFunction_intersection :
          forall (T A : Ty.t),
          M.IsAssociatedFunction.C (Self T A) "intersection" (intersection T A).
        Admitted.
        Global Typeclasses Opaque intersection.
        
        (*
            pub fn union<'a>(&'a self, other: &'a BTreeSet<T, A>) -> Union<'a, T>
            where
                T: Ord,
            {
                Union(MergeIterInner::new(self.iter(), other.iter()))
            }
        *)
        Definition union (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self T A in
          match ε, τ, α with
          | [], [], [ self; other ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let other := M.alloc (| other |) in
              Value.StructTuple
                "alloc::collections::btree::set::Union"
                [
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "alloc::collections::btree::merge_iter::MergeIterInner")
                      []
                      [ Ty.apply (Ty.path "alloc::collections::btree::set::Iter") [] [ T ] ],
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "alloc::collections::btree::merge_iter::MergeIterInner")
                        []
                        [ Ty.apply (Ty.path "alloc::collections::btree::set::Iter") [] [ T ] ],
                      "new",
                      [],
                      []
                    |),
                    [
                      M.call_closure (|
                        Ty.apply (Ty.path "alloc::collections::btree::set::Iter") [] [ T ],
                        M.get_associated_function (|
                          Ty.apply (Ty.path "alloc::collections::btree::set::BTreeSet") [] [ T; A ],
                          "iter",
                          [],
                          []
                        |),
                        [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                      |);
                      M.call_closure (|
                        Ty.apply (Ty.path "alloc::collections::btree::set::Iter") [] [ T ],
                        M.get_associated_function (|
                          Ty.apply (Ty.path "alloc::collections::btree::set::BTreeSet") [] [ T; A ],
                          "iter",
                          [],
                          []
                        |),
                        [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| other |) |) |) ]
                      |)
                    ]
                  |)
                ]))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Global Instance AssociatedFunction_union :
          forall (T A : Ty.t),
          M.IsAssociatedFunction.C (Self T A) "union" (union T A).
        Admitted.
        Global Typeclasses Opaque union.
        
        (*
            pub fn clear(&mut self)
            where
                A: Clone,
            {
                self.map.clear()
            }
        *)
        Definition clear (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self T A in
          match ε, τ, α with
          | [], [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              M.call_closure (|
                Ty.tuple [],
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "alloc::collections::btree::map::BTreeMap")
                    []
                    [ T; Ty.path "alloc::collections::btree::set_val::SetValZST"; A ],
                  "clear",
                  [],
                  []
                |),
                [
                  M.borrow (|
                    Pointer.Kind.MutRef,
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| self |) |),
                      "alloc::collections::btree::set::BTreeSet",
                      "map"
                    |)
                  |)
                ]
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Global Instance AssociatedFunction_clear :
          forall (T A : Ty.t),
          M.IsAssociatedFunction.C (Self T A) "clear" (clear T A).
        Admitted.
        Global Typeclasses Opaque clear.
        
        (*
            pub fn contains<Q: ?Sized>(&self, value: &Q) -> bool
            where
                T: Borrow<Q> + Ord,
                Q: Ord,
            {
                self.map.contains_key(value)
            }
        *)
        Definition contains
            (T A : Ty.t)
            (ε : list Value.t)
            (τ : list Ty.t)
            (α : list Value.t)
            : M :=
          let Self : Ty.t := Self T A in
          match ε, τ, α with
          | [], [ Q ], [ self; value ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let value := M.alloc (| value |) in
              M.call_closure (|
                Ty.path "bool",
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "alloc::collections::btree::map::BTreeMap")
                    []
                    [ T; Ty.path "alloc::collections::btree::set_val::SetValZST"; A ],
                  "contains_key",
                  [],
                  [ Q ]
                |),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| self |) |),
                      "alloc::collections::btree::set::BTreeSet",
                      "map"
                    |)
                  |);
                  M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| value |) |) |)
                ]
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Global Instance AssociatedFunction_contains :
          forall (T A : Ty.t),
          M.IsAssociatedFunction.C (Self T A) "contains" (contains T A).
        Admitted.
        Global Typeclasses Opaque contains.
        
        (*
            pub fn get<Q: ?Sized>(&self, value: &Q) -> Option<&T>
            where
                T: Borrow<Q> + Ord,
                Q: Ord,
            {
                self.map.get_key_value(value).map(|(k, _)| k)
            }
        *)
        Definition get (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self T A in
          match ε, τ, α with
          | [], [ Q ], [ self; value ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let value := M.alloc (| value |) in
              M.call_closure (|
                Ty.apply (Ty.path "core::option::Option") [] [ Ty.apply (Ty.path "&") [] [ T ] ],
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "core::option::Option")
                    []
                    [
                      Ty.tuple
                        [
                          Ty.apply (Ty.path "&") [] [ T ];
                          Ty.apply
                            (Ty.path "&")
                            []
                            [ Ty.path "alloc::collections::btree::set_val::SetValZST" ]
                        ]
                    ],
                  "map",
                  [],
                  [
                    Ty.apply (Ty.path "&") [] [ T ];
                    Ty.function
                      [
                        Ty.tuple
                          [
                            Ty.tuple
                              [
                                Ty.apply (Ty.path "&") [] [ T ];
                                Ty.apply
                                  (Ty.path "&")
                                  []
                                  [ Ty.path "alloc::collections::btree::set_val::SetValZST" ]
                              ]
                          ]
                      ]
                      (Ty.apply (Ty.path "&") [] [ T ])
                  ]
                |),
                [
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "core::option::Option")
                      []
                      [
                        Ty.tuple
                          [
                            Ty.apply (Ty.path "&") [] [ T ];
                            Ty.apply
                              (Ty.path "&")
                              []
                              [ Ty.path "alloc::collections::btree::set_val::SetValZST" ]
                          ]
                      ],
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "alloc::collections::btree::map::BTreeMap")
                        []
                        [ T; Ty.path "alloc::collections::btree::set_val::SetValZST"; A ],
                      "get_key_value",
                      [],
                      [ Q ]
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "alloc::collections::btree::set::BTreeSet",
                          "map"
                        |)
                      |);
                      M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| value |) |) |)
                    ]
                  |);
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0 ] =>
                          ltac:(M.monadic
                            (M.match_operator (|
                              Some
                                (Ty.function
                                  [
                                    Ty.tuple
                                      [
                                        Ty.tuple
                                          [
                                            Ty.apply (Ty.path "&") [] [ T ];
                                            Ty.apply
                                              (Ty.path "&")
                                              []
                                              [
                                                Ty.path
                                                  "alloc::collections::btree::set_val::SetValZST"
                                              ]
                                          ]
                                      ]
                                  ]
                                  (Ty.apply (Ty.path "&") [] [ T ])),
                              M.alloc (| α0 |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                    let k := M.copy (| γ0_0 |) in
                                    M.read (| k |)))
                              ]
                            |)))
                        | _ => M.impossible "wrong number of arguments"
                        end))
                ]
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Global Instance AssociatedFunction_get :
          forall (T A : Ty.t),
          M.IsAssociatedFunction.C (Self T A) "get" (get T A).
        Admitted.
        Global Typeclasses Opaque get.
        
        (*
            pub fn is_disjoint(&self, other: &BTreeSet<T, A>) -> bool
            where
                T: Ord,
            {
                self.intersection(other).next().is_none()
            }
        *)
        Definition is_disjoint
            (T A : Ty.t)
            (ε : list Value.t)
            (τ : list Ty.t)
            (α : list Value.t)
            : M :=
          let Self : Ty.t := Self T A in
          match ε, τ, α with
          | [], [], [ self; other ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let other := M.alloc (| other |) in
              M.call_closure (|
                Ty.path "bool",
                M.get_associated_function (|
                  Ty.apply (Ty.path "core::option::Option") [] [ Ty.apply (Ty.path "&") [] [ T ] ],
                  "is_none",
                  [],
                  []
                |),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::option::Option")
                          []
                          [ Ty.apply (Ty.path "&") [] [ T ] ],
                        M.get_trait_method (|
                          "core::iter::traits::iterator::Iterator",
                          Ty.apply
                            (Ty.path "alloc::collections::btree::set::Intersection")
                            []
                            [ T; A ],
                          [],
                          [],
                          "next",
                          [],
                          []
                        |),
                        [
                          M.borrow (|
                            Pointer.Kind.MutRef,
                            M.alloc (|
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "alloc::collections::btree::set::Intersection")
                                  []
                                  [ T; A ],
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "alloc::collections::btree::set::BTreeSet")
                                    []
                                    [ T; A ],
                                  "intersection",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |);
                                  M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| other |) |) |)
                                ]
                              |)
                            |)
                          |)
                        ]
                      |)
                    |)
                  |)
                ]
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Global Instance AssociatedFunction_is_disjoint :
          forall (T A : Ty.t),
          M.IsAssociatedFunction.C (Self T A) "is_disjoint" (is_disjoint T A).
        Admitted.
        Global Typeclasses Opaque is_disjoint.
        
        (*
            pub fn is_subset(&self, other: &BTreeSet<T, A>) -> bool
            where
                T: Ord,
            {
                // Same result as self.difference(other).next().is_none()
                // but the code below is faster (hugely in some cases).
                if self.len() > other.len() {
                    return false;
                }
                let (self_min, self_max) =
                    if let (Some(self_min), Some(self_max)) = (self.first(), self.last()) {
                        (self_min, self_max)
                    } else {
                        return true; // self is empty
                    };
                let (other_min, other_max) =
                    if let (Some(other_min), Some(other_max)) = (other.first(), other.last()) {
                        (other_min, other_max)
                    } else {
                        return false; // other is empty
                    };
                let mut self_iter = self.iter();
                match self_min.cmp(other_min) {
                    Less => return false,
                    Equal => {
                        self_iter.next();
                    }
                    Greater => (),
                }
                match self_max.cmp(other_max) {
                    Greater => return false,
                    Equal => {
                        self_iter.next_back();
                    }
                    Less => (),
                }
                if self_iter.len() <= other.len() / ITER_PERFORMANCE_TIPPING_SIZE_DIFF {
                    for next in self_iter {
                        if !other.contains(next) {
                            return false;
                        }
                    }
                } else {
                    let mut other_iter = other.iter();
                    other_iter.next();
                    other_iter.next_back();
                    let mut self_next = self_iter.next();
                    while let Some(self1) = self_next {
                        match other_iter.next().map_or(Less, |other1| self1.cmp(other1)) {
                            Less => return false,
                            Equal => self_next = self_iter.next(),
                            Greater => (),
                        }
                    }
                }
                true
            }
        *)
        Definition is_subset
            (T A : Ty.t)
            (ε : list Value.t)
            (τ : list Ty.t)
            (α : list Value.t)
            : M :=
          let Self : Ty.t := Self T A in
          match ε, τ, α with
          | [], [], [ self; other ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let other := M.alloc (| other |) in
              M.catch_return (|
                ltac:(M.monadic
                  (M.read (|
                    let~ _ : Ty.tuple [] :=
                      M.match_operator (|
                        Some (Ty.tuple []),
                        M.alloc (| Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.use
                                  (M.alloc (|
                                    M.call_closure (|
                                      Ty.path "bool",
                                      BinOp.gt,
                                      [
                                        M.call_closure (|
                                          Ty.path "usize",
                                          M.get_associated_function (|
                                            Ty.apply
                                              (Ty.path "alloc::collections::btree::set::BTreeSet")
                                              []
                                              [ T; A ],
                                            "len",
                                            [],
                                            []
                                          |),
                                          [
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.deref (| M.read (| self |) |)
                                            |)
                                          ]
                                        |);
                                        M.call_closure (|
                                          Ty.path "usize",
                                          M.get_associated_function (|
                                            Ty.apply
                                              (Ty.path "alloc::collections::btree::set::BTreeSet")
                                              []
                                              [ T; A ],
                                            "len",
                                            [],
                                            []
                                          |),
                                          [
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.deref (| M.read (| other |) |)
                                            |)
                                          ]
                                        |)
                                      ]
                                    |)
                                  |)) in
                              let _ :=
                                is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                              M.alloc (|
                                M.never_to_any (| M.read (| M.return_ (| Value.Bool false |) |) |)
                              |)));
                          fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                        ]
                      |) in
                    M.match_operator (|
                      None,
                      M.match_operator (|
                        Some
                          (Ty.tuple
                            [ Ty.apply (Ty.path "&") [] [ T ]; Ty.apply (Ty.path "&") [] [ T ] ]),
                        M.alloc (| Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.alloc (|
                                  Value.Tuple
                                    [
                                      M.call_closure (|
                                        Ty.apply
                                          (Ty.path "core::option::Option")
                                          []
                                          [ Ty.apply (Ty.path "&") [] [ T ] ],
                                        M.get_associated_function (|
                                          Ty.apply
                                            (Ty.path "alloc::collections::btree::set::BTreeSet")
                                            []
                                            [ T; A ],
                                          "first",
                                          [],
                                          []
                                        |),
                                        [
                                          M.borrow (|
                                            Pointer.Kind.Ref,
                                            M.deref (| M.read (| self |) |)
                                          |)
                                        ]
                                      |);
                                      M.call_closure (|
                                        Ty.apply
                                          (Ty.path "core::option::Option")
                                          []
                                          [ Ty.apply (Ty.path "&") [] [ T ] ],
                                        M.get_associated_function (|
                                          Ty.apply
                                            (Ty.path "alloc::collections::btree::set::BTreeSet")
                                            []
                                            [ T; A ],
                                          "last",
                                          [],
                                          []
                                        |),
                                        [
                                          M.borrow (|
                                            Pointer.Kind.Ref,
                                            M.deref (| M.read (| self |) |)
                                          |)
                                        ]
                                      |)
                                    ]
                                |) in
                              let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                              let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                              let γ1_0 :=
                                M.SubPointer.get_struct_tuple_field (|
                                  γ0_0,
                                  "core::option::Option::Some",
                                  0
                                |) in
                              let self_min := M.copy (| γ1_0 |) in
                              let γ1_0 :=
                                M.SubPointer.get_struct_tuple_field (|
                                  γ0_1,
                                  "core::option::Option::Some",
                                  0
                                |) in
                              let self_max := M.copy (| γ1_0 |) in
                              M.alloc (|
                                Value.Tuple [ M.read (| self_min |); M.read (| self_max |) ]
                              |)));
                          fun γ =>
                            ltac:(M.monadic
                              (M.alloc (|
                                M.never_to_any (| M.read (| M.return_ (| Value.Bool true |) |) |)
                              |)))
                        ]
                      |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                            let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                            let self_min := M.copy (| γ0_0 |) in
                            let self_max := M.copy (| γ0_1 |) in
                            M.match_operator (|
                              None,
                              M.match_operator (|
                                Some
                                  (Ty.tuple
                                    [
                                      Ty.apply (Ty.path "&") [] [ T ];
                                      Ty.apply (Ty.path "&") [] [ T ]
                                    ]),
                                M.alloc (| Value.Tuple [] |),
                                [
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let γ :=
                                        M.alloc (|
                                          Value.Tuple
                                            [
                                              M.call_closure (|
                                                Ty.apply
                                                  (Ty.path "core::option::Option")
                                                  []
                                                  [ Ty.apply (Ty.path "&") [] [ T ] ],
                                                M.get_associated_function (|
                                                  Ty.apply
                                                    (Ty.path
                                                      "alloc::collections::btree::set::BTreeSet")
                                                    []
                                                    [ T; A ],
                                                  "first",
                                                  [],
                                                  []
                                                |),
                                                [
                                                  M.borrow (|
                                                    Pointer.Kind.Ref,
                                                    M.deref (| M.read (| other |) |)
                                                  |)
                                                ]
                                              |);
                                              M.call_closure (|
                                                Ty.apply
                                                  (Ty.path "core::option::Option")
                                                  []
                                                  [ Ty.apply (Ty.path "&") [] [ T ] ],
                                                M.get_associated_function (|
                                                  Ty.apply
                                                    (Ty.path
                                                      "alloc::collections::btree::set::BTreeSet")
                                                    []
                                                    [ T; A ],
                                                  "last",
                                                  [],
                                                  []
                                                |),
                                                [
                                                  M.borrow (|
                                                    Pointer.Kind.Ref,
                                                    M.deref (| M.read (| other |) |)
                                                  |)
                                                ]
                                              |)
                                            ]
                                        |) in
                                      let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                      let γ1_0 :=
                                        M.SubPointer.get_struct_tuple_field (|
                                          γ0_0,
                                          "core::option::Option::Some",
                                          0
                                        |) in
                                      let other_min := M.copy (| γ1_0 |) in
                                      let γ1_0 :=
                                        M.SubPointer.get_struct_tuple_field (|
                                          γ0_1,
                                          "core::option::Option::Some",
                                          0
                                        |) in
                                      let other_max := M.copy (| γ1_0 |) in
                                      M.alloc (|
                                        Value.Tuple
                                          [ M.read (| other_min |); M.read (| other_max |) ]
                                      |)));
                                  fun γ =>
                                    ltac:(M.monadic
                                      (M.alloc (|
                                        M.never_to_any (|
                                          M.read (| M.return_ (| Value.Bool false |) |)
                                        |)
                                      |)))
                                ]
                              |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                    let other_min := M.copy (| γ0_0 |) in
                                    let other_max := M.copy (| γ0_1 |) in
                                    let~ self_iter :
                                        Ty.apply
                                          (Ty.path "alloc::collections::btree::set::Iter")
                                          []
                                          [ T ] :=
                                      M.alloc (|
                                        M.call_closure (|
                                          Ty.apply
                                            (Ty.path "alloc::collections::btree::set::Iter")
                                            []
                                            [ T ],
                                          M.get_associated_function (|
                                            Ty.apply
                                              (Ty.path "alloc::collections::btree::set::BTreeSet")
                                              []
                                              [ T; A ],
                                            "iter",
                                            [],
                                            []
                                          |),
                                          [
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.deref (| M.read (| self |) |)
                                            |)
                                          ]
                                        |)
                                      |) in
                                    let~ _ : Ty.tuple [] :=
                                      M.match_operator (|
                                        Some (Ty.tuple []),
                                        M.alloc (|
                                          M.call_closure (|
                                            Ty.path "core::cmp::Ordering",
                                            M.get_trait_method (|
                                              "core::cmp::Ord",
                                              T,
                                              [],
                                              [],
                                              "cmp",
                                              [],
                                              []
                                            |),
                                            [
                                              M.borrow (|
                                                Pointer.Kind.Ref,
                                                M.deref (| M.read (| self_min |) |)
                                              |);
                                              M.borrow (|
                                                Pointer.Kind.Ref,
                                                M.deref (| M.read (| other_min |) |)
                                              |)
                                            ]
                                          |)
                                        |),
                                        [
                                          fun γ =>
                                            ltac:(M.monadic
                                              (let _ :=
                                                M.is_struct_tuple (|
                                                  γ,
                                                  "core::cmp::Ordering::Less"
                                                |) in
                                              M.alloc (|
                                                M.never_to_any (|
                                                  M.read (| M.return_ (| Value.Bool false |) |)
                                                |)
                                              |)));
                                          fun γ =>
                                            ltac:(M.monadic
                                              (let _ :=
                                                M.is_struct_tuple (|
                                                  γ,
                                                  "core::cmp::Ordering::Equal"
                                                |) in
                                              let~ _ :
                                                  Ty.apply
                                                    (Ty.path "core::option::Option")
                                                    []
                                                    [ Ty.apply (Ty.path "&") [] [ T ] ] :=
                                                M.alloc (|
                                                  M.call_closure (|
                                                    Ty.apply
                                                      (Ty.path "core::option::Option")
                                                      []
                                                      [ Ty.apply (Ty.path "&") [] [ T ] ],
                                                    M.get_trait_method (|
                                                      "core::iter::traits::iterator::Iterator",
                                                      Ty.apply
                                                        (Ty.path
                                                          "alloc::collections::btree::set::Iter")
                                                        []
                                                        [ T ],
                                                      [],
                                                      [],
                                                      "next",
                                                      [],
                                                      []
                                                    |),
                                                    [ M.borrow (| Pointer.Kind.MutRef, self_iter |)
                                                    ]
                                                  |)
                                                |) in
                                              M.alloc (| Value.Tuple [] |)));
                                          fun γ =>
                                            ltac:(M.monadic
                                              (let _ :=
                                                M.is_struct_tuple (|
                                                  γ,
                                                  "core::cmp::Ordering::Greater"
                                                |) in
                                              M.alloc (| Value.Tuple [] |)))
                                        ]
                                      |) in
                                    let~ _ : Ty.tuple [] :=
                                      M.match_operator (|
                                        Some (Ty.tuple []),
                                        M.alloc (|
                                          M.call_closure (|
                                            Ty.path "core::cmp::Ordering",
                                            M.get_trait_method (|
                                              "core::cmp::Ord",
                                              T,
                                              [],
                                              [],
                                              "cmp",
                                              [],
                                              []
                                            |),
                                            [
                                              M.borrow (|
                                                Pointer.Kind.Ref,
                                                M.deref (| M.read (| self_max |) |)
                                              |);
                                              M.borrow (|
                                                Pointer.Kind.Ref,
                                                M.deref (| M.read (| other_max |) |)
                                              |)
                                            ]
                                          |)
                                        |),
                                        [
                                          fun γ =>
                                            ltac:(M.monadic
                                              (let _ :=
                                                M.is_struct_tuple (|
                                                  γ,
                                                  "core::cmp::Ordering::Greater"
                                                |) in
                                              M.alloc (|
                                                M.never_to_any (|
                                                  M.read (| M.return_ (| Value.Bool false |) |)
                                                |)
                                              |)));
                                          fun γ =>
                                            ltac:(M.monadic
                                              (let _ :=
                                                M.is_struct_tuple (|
                                                  γ,
                                                  "core::cmp::Ordering::Equal"
                                                |) in
                                              let~ _ :
                                                  Ty.apply
                                                    (Ty.path "core::option::Option")
                                                    []
                                                    [ Ty.apply (Ty.path "&") [] [ T ] ] :=
                                                M.alloc (|
                                                  M.call_closure (|
                                                    Ty.apply
                                                      (Ty.path "core::option::Option")
                                                      []
                                                      [ Ty.apply (Ty.path "&") [] [ T ] ],
                                                    M.get_trait_method (|
                                                      "core::iter::traits::double_ended::DoubleEndedIterator",
                                                      Ty.apply
                                                        (Ty.path
                                                          "alloc::collections::btree::set::Iter")
                                                        []
                                                        [ T ],
                                                      [],
                                                      [],
                                                      "next_back",
                                                      [],
                                                      []
                                                    |),
                                                    [ M.borrow (| Pointer.Kind.MutRef, self_iter |)
                                                    ]
                                                  |)
                                                |) in
                                              M.alloc (| Value.Tuple [] |)));
                                          fun γ =>
                                            ltac:(M.monadic
                                              (let _ :=
                                                M.is_struct_tuple (|
                                                  γ,
                                                  "core::cmp::Ordering::Less"
                                                |) in
                                              M.alloc (| Value.Tuple [] |)))
                                        ]
                                      |) in
                                    let~ _ : Ty.tuple [] :=
                                      M.match_operator (|
                                        Some (Ty.tuple []),
                                        M.alloc (| Value.Tuple [] |),
                                        [
                                          fun γ =>
                                            ltac:(M.monadic
                                              (let γ :=
                                                M.use
                                                  (M.alloc (|
                                                    M.call_closure (|
                                                      Ty.path "bool",
                                                      BinOp.le,
                                                      [
                                                        M.call_closure (|
                                                          Ty.path "usize",
                                                          M.get_trait_method (|
                                                            "core::iter::traits::exact_size::ExactSizeIterator",
                                                            Ty.apply
                                                              (Ty.path
                                                                "alloc::collections::btree::set::Iter")
                                                              []
                                                              [ T ],
                                                            [],
                                                            [],
                                                            "len",
                                                            [],
                                                            []
                                                          |),
                                                          [
                                                            M.borrow (|
                                                              Pointer.Kind.Ref,
                                                              self_iter
                                                            |)
                                                          ]
                                                        |);
                                                        M.call_closure (|
                                                          Ty.path "usize",
                                                          BinOp.Wrap.div,
                                                          [
                                                            M.call_closure (|
                                                              Ty.path "usize",
                                                              M.get_associated_function (|
                                                                Ty.apply
                                                                  (Ty.path
                                                                    "alloc::collections::btree::set::BTreeSet")
                                                                  []
                                                                  [ T; A ],
                                                                "len",
                                                                [],
                                                                []
                                                              |),
                                                              [
                                                                M.borrow (|
                                                                  Pointer.Kind.Ref,
                                                                  M.deref (| M.read (| other |) |)
                                                                |)
                                                              ]
                                                            |);
                                                            M.read (|
                                                              get_constant (|
                                                                "alloc::collections::btree::set::ITER_PERFORMANCE_TIPPING_SIZE_DIFF",
                                                                Ty.path "usize"
                                                              |)
                                                            |)
                                                          ]
                                                        |)
                                                      ]
                                                    |)
                                                  |)) in
                                              let _ :=
                                                is_constant_or_break_match (|
                                                  M.read (| γ |),
                                                  Value.Bool true
                                                |) in
                                              M.use
                                                (M.match_operator (|
                                                  Some (Ty.tuple []),
                                                  M.alloc (|
                                                    M.call_closure (|
                                                      Ty.apply
                                                        (Ty.path
                                                          "alloc::collections::btree::set::Iter")
                                                        []
                                                        [ T ],
                                                      M.get_trait_method (|
                                                        "core::iter::traits::collect::IntoIterator",
                                                        Ty.apply
                                                          (Ty.path
                                                            "alloc::collections::btree::set::Iter")
                                                          []
                                                          [ T ],
                                                        [],
                                                        [],
                                                        "into_iter",
                                                        [],
                                                        []
                                                      |),
                                                      [ M.read (| self_iter |) ]
                                                    |)
                                                  |),
                                                  [
                                                    fun γ =>
                                                      ltac:(M.monadic
                                                        (let iter := M.copy (| γ |) in
                                                        M.loop (|
                                                          Ty.tuple [],
                                                          ltac:(M.monadic
                                                            (let~ _ : Ty.tuple [] :=
                                                              M.match_operator (|
                                                                Some (Ty.tuple []),
                                                                M.alloc (|
                                                                  M.call_closure (|
                                                                    Ty.apply
                                                                      (Ty.path
                                                                        "core::option::Option")
                                                                      []
                                                                      [
                                                                        Ty.apply
                                                                          (Ty.path "&")
                                                                          []
                                                                          [ T ]
                                                                      ],
                                                                    M.get_trait_method (|
                                                                      "core::iter::traits::iterator::Iterator",
                                                                      Ty.apply
                                                                        (Ty.path
                                                                          "alloc::collections::btree::set::Iter")
                                                                        []
                                                                        [ T ],
                                                                      [],
                                                                      [],
                                                                      "next",
                                                                      [],
                                                                      []
                                                                    |),
                                                                    [
                                                                      M.borrow (|
                                                                        Pointer.Kind.MutRef,
                                                                        M.deref (|
                                                                          M.borrow (|
                                                                            Pointer.Kind.MutRef,
                                                                            iter
                                                                          |)
                                                                        |)
                                                                      |)
                                                                    ]
                                                                  |)
                                                                |),
                                                                [
                                                                  fun γ =>
                                                                    ltac:(M.monadic
                                                                      (let _ :=
                                                                        M.is_struct_tuple (|
                                                                          γ,
                                                                          "core::option::Option::None"
                                                                        |) in
                                                                      M.alloc (|
                                                                        M.never_to_any (|
                                                                          M.read (| M.break (||) |)
                                                                        |)
                                                                      |)));
                                                                  fun γ =>
                                                                    ltac:(M.monadic
                                                                      (let γ0_0 :=
                                                                        M.SubPointer.get_struct_tuple_field (|
                                                                          γ,
                                                                          "core::option::Option::Some",
                                                                          0
                                                                        |) in
                                                                      let next :=
                                                                        M.copy (| γ0_0 |) in
                                                                      M.match_operator (|
                                                                        Some (Ty.tuple []),
                                                                        M.alloc (|
                                                                          Value.Tuple []
                                                                        |),
                                                                        [
                                                                          fun γ =>
                                                                            ltac:(M.monadic
                                                                              (let γ :=
                                                                                M.use
                                                                                  (M.alloc (|
                                                                                    UnOp.not (|
                                                                                      M.call_closure (|
                                                                                        Ty.path
                                                                                          "bool",
                                                                                        M.get_associated_function (|
                                                                                          Ty.apply
                                                                                            (Ty.path
                                                                                              "alloc::collections::btree::set::BTreeSet")
                                                                                            []
                                                                                            [ T; A
                                                                                            ],
                                                                                          "contains",
                                                                                          [],
                                                                                          [ T ]
                                                                                        |),
                                                                                        [
                                                                                          M.borrow (|
                                                                                            Pointer.Kind.Ref,
                                                                                            M.deref (|
                                                                                              M.read (|
                                                                                                other
                                                                                              |)
                                                                                            |)
                                                                                          |);
                                                                                          M.borrow (|
                                                                                            Pointer.Kind.Ref,
                                                                                            M.deref (|
                                                                                              M.read (|
                                                                                                next
                                                                                              |)
                                                                                            |)
                                                                                          |)
                                                                                        ]
                                                                                      |)
                                                                                    |)
                                                                                  |)) in
                                                                              let _ :=
                                                                                is_constant_or_break_match (|
                                                                                  M.read (| γ |),
                                                                                  Value.Bool true
                                                                                |) in
                                                                              M.alloc (|
                                                                                M.never_to_any (|
                                                                                  M.read (|
                                                                                    M.return_ (|
                                                                                      Value.Bool
                                                                                        false
                                                                                    |)
                                                                                  |)
                                                                                |)
                                                                              |)));
                                                                          fun γ =>
                                                                            ltac:(M.monadic
                                                                              (M.alloc (|
                                                                                Value.Tuple []
                                                                              |)))
                                                                        ]
                                                                      |)))
                                                                ]
                                                              |) in
                                                            M.alloc (| Value.Tuple [] |)))
                                                        |)))
                                                  ]
                                                |))));
                                          fun γ =>
                                            ltac:(M.monadic
                                              (let~ other_iter :
                                                  Ty.apply
                                                    (Ty.path "alloc::collections::btree::set::Iter")
                                                    []
                                                    [ T ] :=
                                                M.alloc (|
                                                  M.call_closure (|
                                                    Ty.apply
                                                      (Ty.path
                                                        "alloc::collections::btree::set::Iter")
                                                      []
                                                      [ T ],
                                                    M.get_associated_function (|
                                                      Ty.apply
                                                        (Ty.path
                                                          "alloc::collections::btree::set::BTreeSet")
                                                        []
                                                        [ T; A ],
                                                      "iter",
                                                      [],
                                                      []
                                                    |),
                                                    [
                                                      M.borrow (|
                                                        Pointer.Kind.Ref,
                                                        M.deref (| M.read (| other |) |)
                                                      |)
                                                    ]
                                                  |)
                                                |) in
                                              let~ _ :
                                                  Ty.apply
                                                    (Ty.path "core::option::Option")
                                                    []
                                                    [ Ty.apply (Ty.path "&") [] [ T ] ] :=
                                                M.alloc (|
                                                  M.call_closure (|
                                                    Ty.apply
                                                      (Ty.path "core::option::Option")
                                                      []
                                                      [ Ty.apply (Ty.path "&") [] [ T ] ],
                                                    M.get_trait_method (|
                                                      "core::iter::traits::iterator::Iterator",
                                                      Ty.apply
                                                        (Ty.path
                                                          "alloc::collections::btree::set::Iter")
                                                        []
                                                        [ T ],
                                                      [],
                                                      [],
                                                      "next",
                                                      [],
                                                      []
                                                    |),
                                                    [ M.borrow (| Pointer.Kind.MutRef, other_iter |)
                                                    ]
                                                  |)
                                                |) in
                                              let~ _ :
                                                  Ty.apply
                                                    (Ty.path "core::option::Option")
                                                    []
                                                    [ Ty.apply (Ty.path "&") [] [ T ] ] :=
                                                M.alloc (|
                                                  M.call_closure (|
                                                    Ty.apply
                                                      (Ty.path "core::option::Option")
                                                      []
                                                      [ Ty.apply (Ty.path "&") [] [ T ] ],
                                                    M.get_trait_method (|
                                                      "core::iter::traits::double_ended::DoubleEndedIterator",
                                                      Ty.apply
                                                        (Ty.path
                                                          "alloc::collections::btree::set::Iter")
                                                        []
                                                        [ T ],
                                                      [],
                                                      [],
                                                      "next_back",
                                                      [],
                                                      []
                                                    |),
                                                    [ M.borrow (| Pointer.Kind.MutRef, other_iter |)
                                                    ]
                                                  |)
                                                |) in
                                              let~ self_next :
                                                  Ty.apply
                                                    (Ty.path "core::option::Option")
                                                    []
                                                    [ Ty.apply (Ty.path "&") [] [ T ] ] :=
                                                M.alloc (|
                                                  M.call_closure (|
                                                    Ty.apply
                                                      (Ty.path "core::option::Option")
                                                      []
                                                      [ Ty.apply (Ty.path "&") [] [ T ] ],
                                                    M.get_trait_method (|
                                                      "core::iter::traits::iterator::Iterator",
                                                      Ty.apply
                                                        (Ty.path
                                                          "alloc::collections::btree::set::Iter")
                                                        []
                                                        [ T ],
                                                      [],
                                                      [],
                                                      "next",
                                                      [],
                                                      []
                                                    |),
                                                    [ M.borrow (| Pointer.Kind.MutRef, self_iter |)
                                                    ]
                                                  |)
                                                |) in
                                              M.loop (|
                                                Ty.tuple [],
                                                ltac:(M.monadic
                                                  (M.match_operator (|
                                                    Some (Ty.tuple []),
                                                    M.alloc (| Value.Tuple [] |),
                                                    [
                                                      fun γ =>
                                                        ltac:(M.monadic
                                                          (let γ := self_next in
                                                          let γ0_0 :=
                                                            M.SubPointer.get_struct_tuple_field (|
                                                              γ,
                                                              "core::option::Option::Some",
                                                              0
                                                            |) in
                                                          let self1 := M.copy (| γ0_0 |) in
                                                          M.match_operator (|
                                                            Some (Ty.tuple []),
                                                            M.alloc (|
                                                              M.call_closure (|
                                                                Ty.path "core::cmp::Ordering",
                                                                M.get_associated_function (|
                                                                  Ty.apply
                                                                    (Ty.path "core::option::Option")
                                                                    []
                                                                    [
                                                                      Ty.apply
                                                                        (Ty.path "&")
                                                                        []
                                                                        [ T ]
                                                                    ],
                                                                  "map_or",
                                                                  [],
                                                                  [
                                                                    Ty.path "core::cmp::Ordering";
                                                                    Ty.function
                                                                      [
                                                                        Ty.tuple
                                                                          [
                                                                            Ty.apply
                                                                              (Ty.path "&")
                                                                              []
                                                                              [ T ]
                                                                          ]
                                                                      ]
                                                                      (Ty.path
                                                                        "core::cmp::Ordering")
                                                                  ]
                                                                |),
                                                                [
                                                                  M.call_closure (|
                                                                    Ty.apply
                                                                      (Ty.path
                                                                        "core::option::Option")
                                                                      []
                                                                      [
                                                                        Ty.apply
                                                                          (Ty.path "&")
                                                                          []
                                                                          [ T ]
                                                                      ],
                                                                    M.get_trait_method (|
                                                                      "core::iter::traits::iterator::Iterator",
                                                                      Ty.apply
                                                                        (Ty.path
                                                                          "alloc::collections::btree::set::Iter")
                                                                        []
                                                                        [ T ],
                                                                      [],
                                                                      [],
                                                                      "next",
                                                                      [],
                                                                      []
                                                                    |),
                                                                    [
                                                                      M.borrow (|
                                                                        Pointer.Kind.MutRef,
                                                                        other_iter
                                                                      |)
                                                                    ]
                                                                  |);
                                                                  Value.StructTuple
                                                                    "core::cmp::Ordering::Less"
                                                                    [];
                                                                  M.closure
                                                                    (fun γ =>
                                                                      ltac:(M.monadic
                                                                        match γ with
                                                                        | [ α0 ] =>
                                                                          ltac:(M.monadic
                                                                            (M.match_operator (|
                                                                              Some
                                                                                (Ty.function
                                                                                  [
                                                                                    Ty.tuple
                                                                                      [
                                                                                        Ty.apply
                                                                                          (Ty.path
                                                                                            "&")
                                                                                          []
                                                                                          [ T ]
                                                                                      ]
                                                                                  ]
                                                                                  (Ty.path
                                                                                    "core::cmp::Ordering")),
                                                                              M.alloc (| α0 |),
                                                                              [
                                                                                fun γ =>
                                                                                  ltac:(M.monadic
                                                                                    (let other1 :=
                                                                                      M.copy (|
                                                                                        γ
                                                                                      |) in
                                                                                    M.call_closure (|
                                                                                      Ty.path
                                                                                        "core::cmp::Ordering",
                                                                                      M.get_trait_method (|
                                                                                        "core::cmp::Ord",
                                                                                        T,
                                                                                        [],
                                                                                        [],
                                                                                        "cmp",
                                                                                        [],
                                                                                        []
                                                                                      |),
                                                                                      [
                                                                                        M.borrow (|
                                                                                          Pointer.Kind.Ref,
                                                                                          M.deref (|
                                                                                            M.read (|
                                                                                              self1
                                                                                            |)
                                                                                          |)
                                                                                        |);
                                                                                        M.borrow (|
                                                                                          Pointer.Kind.Ref,
                                                                                          M.deref (|
                                                                                            M.read (|
                                                                                              other1
                                                                                            |)
                                                                                          |)
                                                                                        |)
                                                                                      ]
                                                                                    |)))
                                                                              ]
                                                                            |)))
                                                                        | _ =>
                                                                          M.impossible
                                                                            "wrong number of arguments"
                                                                        end))
                                                                ]
                                                              |)
                                                            |),
                                                            [
                                                              fun γ =>
                                                                ltac:(M.monadic
                                                                  (let _ :=
                                                                    M.is_struct_tuple (|
                                                                      γ,
                                                                      "core::cmp::Ordering::Less"
                                                                    |) in
                                                                  M.alloc (|
                                                                    M.never_to_any (|
                                                                      M.read (|
                                                                        M.return_ (|
                                                                          Value.Bool false
                                                                        |)
                                                                      |)
                                                                    |)
                                                                  |)));
                                                              fun γ =>
                                                                ltac:(M.monadic
                                                                  (let _ :=
                                                                    M.is_struct_tuple (|
                                                                      γ,
                                                                      "core::cmp::Ordering::Equal"
                                                                    |) in
                                                                  M.alloc (|
                                                                    M.write (|
                                                                      self_next,
                                                                      M.call_closure (|
                                                                        Ty.apply
                                                                          (Ty.path
                                                                            "core::option::Option")
                                                                          []
                                                                          [
                                                                            Ty.apply
                                                                              (Ty.path "&")
                                                                              []
                                                                              [ T ]
                                                                          ],
                                                                        M.get_trait_method (|
                                                                          "core::iter::traits::iterator::Iterator",
                                                                          Ty.apply
                                                                            (Ty.path
                                                                              "alloc::collections::btree::set::Iter")
                                                                            []
                                                                            [ T ],
                                                                          [],
                                                                          [],
                                                                          "next",
                                                                          [],
                                                                          []
                                                                        |),
                                                                        [
                                                                          M.borrow (|
                                                                            Pointer.Kind.MutRef,
                                                                            self_iter
                                                                          |)
                                                                        ]
                                                                      |)
                                                                    |)
                                                                  |)));
                                                              fun γ =>
                                                                ltac:(M.monadic
                                                                  (let _ :=
                                                                    M.is_struct_tuple (|
                                                                      γ,
                                                                      "core::cmp::Ordering::Greater"
                                                                    |) in
                                                                  M.alloc (| Value.Tuple [] |)))
                                                            ]
                                                          |)));
                                                      fun γ =>
                                                        ltac:(M.monadic
                                                          (M.alloc (|
                                                            M.never_to_any (|
                                                              M.read (|
                                                                let~ _ : Ty.tuple [] :=
                                                                  M.alloc (|
                                                                    M.never_to_any (|
                                                                      M.read (| M.break (||) |)
                                                                    |)
                                                                  |) in
                                                                M.alloc (| Value.Tuple [] |)
                                                              |)
                                                            |)
                                                          |)))
                                                    ]
                                                  |)))
                                              |)))
                                        ]
                                      |) in
                                    M.alloc (| Value.Bool true |)))
                              ]
                            |)))
                      ]
                    |)
                  |)))
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Global Instance AssociatedFunction_is_subset :
          forall (T A : Ty.t),
          M.IsAssociatedFunction.C (Self T A) "is_subset" (is_subset T A).
        Admitted.
        Global Typeclasses Opaque is_subset.
        
        (*
            pub fn is_superset(&self, other: &BTreeSet<T, A>) -> bool
            where
                T: Ord,
            {
                other.is_subset(self)
            }
        *)
        Definition is_superset
            (T A : Ty.t)
            (ε : list Value.t)
            (τ : list Ty.t)
            (α : list Value.t)
            : M :=
          let Self : Ty.t := Self T A in
          match ε, τ, α with
          | [], [], [ self; other ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let other := M.alloc (| other |) in
              M.call_closure (|
                Ty.path "bool",
                M.get_associated_function (|
                  Ty.apply (Ty.path "alloc::collections::btree::set::BTreeSet") [] [ T; A ],
                  "is_subset",
                  [],
                  []
                |),
                [
                  M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| other |) |) |);
                  M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |)
                ]
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Global Instance AssociatedFunction_is_superset :
          forall (T A : Ty.t),
          M.IsAssociatedFunction.C (Self T A) "is_superset" (is_superset T A).
        Admitted.
        Global Typeclasses Opaque is_superset.
        
        (*
            pub fn first(&self) -> Option<&T>
            where
                T: Ord,
            {
                self.map.first_key_value().map(|(k, _)| k)
            }
        *)
        Definition first (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self T A in
          match ε, τ, α with
          | [], [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              M.call_closure (|
                Ty.apply (Ty.path "core::option::Option") [] [ Ty.apply (Ty.path "&") [] [ T ] ],
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "core::option::Option")
                    []
                    [
                      Ty.tuple
                        [
                          Ty.apply (Ty.path "&") [] [ T ];
                          Ty.apply
                            (Ty.path "&")
                            []
                            [ Ty.path "alloc::collections::btree::set_val::SetValZST" ]
                        ]
                    ],
                  "map",
                  [],
                  [
                    Ty.apply (Ty.path "&") [] [ T ];
                    Ty.function
                      [
                        Ty.tuple
                          [
                            Ty.tuple
                              [
                                Ty.apply (Ty.path "&") [] [ T ];
                                Ty.apply
                                  (Ty.path "&")
                                  []
                                  [ Ty.path "alloc::collections::btree::set_val::SetValZST" ]
                              ]
                          ]
                      ]
                      (Ty.apply (Ty.path "&") [] [ T ])
                  ]
                |),
                [
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "core::option::Option")
                      []
                      [
                        Ty.tuple
                          [
                            Ty.apply (Ty.path "&") [] [ T ];
                            Ty.apply
                              (Ty.path "&")
                              []
                              [ Ty.path "alloc::collections::btree::set_val::SetValZST" ]
                          ]
                      ],
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "alloc::collections::btree::map::BTreeMap")
                        []
                        [ T; Ty.path "alloc::collections::btree::set_val::SetValZST"; A ],
                      "first_key_value",
                      [],
                      []
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "alloc::collections::btree::set::BTreeSet",
                          "map"
                        |)
                      |)
                    ]
                  |);
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0 ] =>
                          ltac:(M.monadic
                            (M.match_operator (|
                              Some
                                (Ty.function
                                  [
                                    Ty.tuple
                                      [
                                        Ty.tuple
                                          [
                                            Ty.apply (Ty.path "&") [] [ T ];
                                            Ty.apply
                                              (Ty.path "&")
                                              []
                                              [
                                                Ty.path
                                                  "alloc::collections::btree::set_val::SetValZST"
                                              ]
                                          ]
                                      ]
                                  ]
                                  (Ty.apply (Ty.path "&") [] [ T ])),
                              M.alloc (| α0 |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                    let k := M.copy (| γ0_0 |) in
                                    M.read (| k |)))
                              ]
                            |)))
                        | _ => M.impossible "wrong number of arguments"
                        end))
                ]
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Global Instance AssociatedFunction_first :
          forall (T A : Ty.t),
          M.IsAssociatedFunction.C (Self T A) "first" (first T A).
        Admitted.
        Global Typeclasses Opaque first.
        
        (*
            pub fn last(&self) -> Option<&T>
            where
                T: Ord,
            {
                self.map.last_key_value().map(|(k, _)| k)
            }
        *)
        Definition last (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self T A in
          match ε, τ, α with
          | [], [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              M.call_closure (|
                Ty.apply (Ty.path "core::option::Option") [] [ Ty.apply (Ty.path "&") [] [ T ] ],
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "core::option::Option")
                    []
                    [
                      Ty.tuple
                        [
                          Ty.apply (Ty.path "&") [] [ T ];
                          Ty.apply
                            (Ty.path "&")
                            []
                            [ Ty.path "alloc::collections::btree::set_val::SetValZST" ]
                        ]
                    ],
                  "map",
                  [],
                  [
                    Ty.apply (Ty.path "&") [] [ T ];
                    Ty.function
                      [
                        Ty.tuple
                          [
                            Ty.tuple
                              [
                                Ty.apply (Ty.path "&") [] [ T ];
                                Ty.apply
                                  (Ty.path "&")
                                  []
                                  [ Ty.path "alloc::collections::btree::set_val::SetValZST" ]
                              ]
                          ]
                      ]
                      (Ty.apply (Ty.path "&") [] [ T ])
                  ]
                |),
                [
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "core::option::Option")
                      []
                      [
                        Ty.tuple
                          [
                            Ty.apply (Ty.path "&") [] [ T ];
                            Ty.apply
                              (Ty.path "&")
                              []
                              [ Ty.path "alloc::collections::btree::set_val::SetValZST" ]
                          ]
                      ],
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "alloc::collections::btree::map::BTreeMap")
                        []
                        [ T; Ty.path "alloc::collections::btree::set_val::SetValZST"; A ],
                      "last_key_value",
                      [],
                      []
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "alloc::collections::btree::set::BTreeSet",
                          "map"
                        |)
                      |)
                    ]
                  |);
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0 ] =>
                          ltac:(M.monadic
                            (M.match_operator (|
                              Some
                                (Ty.function
                                  [
                                    Ty.tuple
                                      [
                                        Ty.tuple
                                          [
                                            Ty.apply (Ty.path "&") [] [ T ];
                                            Ty.apply
                                              (Ty.path "&")
                                              []
                                              [
                                                Ty.path
                                                  "alloc::collections::btree::set_val::SetValZST"
                                              ]
                                          ]
                                      ]
                                  ]
                                  (Ty.apply (Ty.path "&") [] [ T ])),
                              M.alloc (| α0 |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                    let k := M.copy (| γ0_0 |) in
                                    M.read (| k |)))
                              ]
                            |)))
                        | _ => M.impossible "wrong number of arguments"
                        end))
                ]
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Global Instance AssociatedFunction_last :
          forall (T A : Ty.t),
          M.IsAssociatedFunction.C (Self T A) "last" (last T A).
        Admitted.
        Global Typeclasses Opaque last.
        
        (*
            pub fn pop_first(&mut self) -> Option<T>
            where
                T: Ord,
            {
                self.map.pop_first().map(|kv| kv.0)
            }
        *)
        Definition pop_first
            (T A : Ty.t)
            (ε : list Value.t)
            (τ : list Ty.t)
            (α : list Value.t)
            : M :=
          let Self : Ty.t := Self T A in
          match ε, τ, α with
          | [], [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              M.call_closure (|
                Ty.apply (Ty.path "core::option::Option") [] [ T ],
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "core::option::Option")
                    []
                    [ Ty.tuple [ T; Ty.path "alloc::collections::btree::set_val::SetValZST" ] ],
                  "map",
                  [],
                  [
                    T;
                    Ty.function
                      [
                        Ty.tuple
                          [ Ty.tuple [ T; Ty.path "alloc::collections::btree::set_val::SetValZST" ]
                          ]
                      ]
                      T
                  ]
                |),
                [
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "core::option::Option")
                      []
                      [ Ty.tuple [ T; Ty.path "alloc::collections::btree::set_val::SetValZST" ] ],
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "alloc::collections::btree::map::BTreeMap")
                        []
                        [ T; Ty.path "alloc::collections::btree::set_val::SetValZST"; A ],
                      "pop_first",
                      [],
                      []
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.MutRef,
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "alloc::collections::btree::set::BTreeSet",
                          "map"
                        |)
                      |)
                    ]
                  |);
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0 ] =>
                          ltac:(M.monadic
                            (M.match_operator (|
                              Some
                                (Ty.function
                                  [
                                    Ty.tuple
                                      [
                                        Ty.tuple
                                          [
                                            T;
                                            Ty.path "alloc::collections::btree::set_val::SetValZST"
                                          ]
                                      ]
                                  ]
                                  T),
                              M.alloc (| α0 |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let kv := M.copy (| γ |) in
                                    M.read (| M.SubPointer.get_tuple_field (| kv, 0 |) |)))
                              ]
                            |)))
                        | _ => M.impossible "wrong number of arguments"
                        end))
                ]
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Global Instance AssociatedFunction_pop_first :
          forall (T A : Ty.t),
          M.IsAssociatedFunction.C (Self T A) "pop_first" (pop_first T A).
        Admitted.
        Global Typeclasses Opaque pop_first.
        
        (*
            pub fn pop_last(&mut self) -> Option<T>
            where
                T: Ord,
            {
                self.map.pop_last().map(|kv| kv.0)
            }
        *)
        Definition pop_last
            (T A : Ty.t)
            (ε : list Value.t)
            (τ : list Ty.t)
            (α : list Value.t)
            : M :=
          let Self : Ty.t := Self T A in
          match ε, τ, α with
          | [], [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              M.call_closure (|
                Ty.apply (Ty.path "core::option::Option") [] [ T ],
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "core::option::Option")
                    []
                    [ Ty.tuple [ T; Ty.path "alloc::collections::btree::set_val::SetValZST" ] ],
                  "map",
                  [],
                  [
                    T;
                    Ty.function
                      [
                        Ty.tuple
                          [ Ty.tuple [ T; Ty.path "alloc::collections::btree::set_val::SetValZST" ]
                          ]
                      ]
                      T
                  ]
                |),
                [
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "core::option::Option")
                      []
                      [ Ty.tuple [ T; Ty.path "alloc::collections::btree::set_val::SetValZST" ] ],
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "alloc::collections::btree::map::BTreeMap")
                        []
                        [ T; Ty.path "alloc::collections::btree::set_val::SetValZST"; A ],
                      "pop_last",
                      [],
                      []
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.MutRef,
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "alloc::collections::btree::set::BTreeSet",
                          "map"
                        |)
                      |)
                    ]
                  |);
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0 ] =>
                          ltac:(M.monadic
                            (M.match_operator (|
                              Some
                                (Ty.function
                                  [
                                    Ty.tuple
                                      [
                                        Ty.tuple
                                          [
                                            T;
                                            Ty.path "alloc::collections::btree::set_val::SetValZST"
                                          ]
                                      ]
                                  ]
                                  T),
                              M.alloc (| α0 |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let kv := M.copy (| γ |) in
                                    M.read (| M.SubPointer.get_tuple_field (| kv, 0 |) |)))
                              ]
                            |)))
                        | _ => M.impossible "wrong number of arguments"
                        end))
                ]
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Global Instance AssociatedFunction_pop_last :
          forall (T A : Ty.t),
          M.IsAssociatedFunction.C (Self T A) "pop_last" (pop_last T A).
        Admitted.
        Global Typeclasses Opaque pop_last.
        
        (*
            pub fn insert(&mut self, value: T) -> bool
            where
                T: Ord,
            {
                self.map.insert(value, SetValZST::default()).is_none()
            }
        *)
        Definition insert (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self T A in
          match ε, τ, α with
          | [], [], [ self; value ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let value := M.alloc (| value |) in
              M.call_closure (|
                Ty.path "bool",
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "core::option::Option")
                    []
                    [ Ty.path "alloc::collections::btree::set_val::SetValZST" ],
                  "is_none",
                  [],
                  []
                |),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::option::Option")
                          []
                          [ Ty.path "alloc::collections::btree::set_val::SetValZST" ],
                        M.get_associated_function (|
                          Ty.apply
                            (Ty.path "alloc::collections::btree::map::BTreeMap")
                            []
                            [ T; Ty.path "alloc::collections::btree::set_val::SetValZST"; A ],
                          "insert",
                          [],
                          []
                        |),
                        [
                          M.borrow (|
                            Pointer.Kind.MutRef,
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| self |) |),
                              "alloc::collections::btree::set::BTreeSet",
                              "map"
                            |)
                          |);
                          M.read (| value |);
                          M.call_closure (|
                            Ty.path "alloc::collections::btree::set_val::SetValZST",
                            M.get_trait_method (|
                              "core::default::Default",
                              Ty.path "alloc::collections::btree::set_val::SetValZST",
                              [],
                              [],
                              "default",
                              [],
                              []
                            |),
                            []
                          |)
                        ]
                      |)
                    |)
                  |)
                ]
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Global Instance AssociatedFunction_insert :
          forall (T A : Ty.t),
          M.IsAssociatedFunction.C (Self T A) "insert" (insert T A).
        Admitted.
        Global Typeclasses Opaque insert.
        
        (*
            pub fn replace(&mut self, value: T) -> Option<T>
            where
                T: Ord,
            {
                self.map.replace(value)
            }
        *)
        Definition replace (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self T A in
          match ε, τ, α with
          | [], [], [ self; value ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let value := M.alloc (| value |) in
              M.call_closure (|
                Ty.apply (Ty.path "core::option::Option") [] [ T ],
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "alloc::collections::btree::map::BTreeMap")
                    []
                    [ T; Ty.path "alloc::collections::btree::set_val::SetValZST"; A ],
                  "replace",
                  [],
                  []
                |),
                [
                  M.borrow (|
                    Pointer.Kind.MutRef,
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| self |) |),
                      "alloc::collections::btree::set::BTreeSet",
                      "map"
                    |)
                  |);
                  M.read (| value |)
                ]
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Global Instance AssociatedFunction_replace :
          forall (T A : Ty.t),
          M.IsAssociatedFunction.C (Self T A) "replace" (replace T A).
        Admitted.
        Global Typeclasses Opaque replace.
        
        (*
            pub fn get_or_insert(&mut self, value: T) -> &T
            where
                T: Ord,
            {
                self.map.entry(value).insert_entry(SetValZST).into_key()
            }
        *)
        Definition get_or_insert
            (T A : Ty.t)
            (ε : list Value.t)
            (τ : list Ty.t)
            (α : list Value.t)
            : M :=
          let Self : Ty.t := Self T A in
          match ε, τ, α with
          | [], [], [ self; value ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let value := M.alloc (| value |) in
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.call_closure (|
                    Ty.apply (Ty.path "&") [] [ T ],
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "alloc::collections::btree::map::entry::OccupiedEntry")
                        []
                        [ T; Ty.path "alloc::collections::btree::set_val::SetValZST"; A ],
                      "into_key",
                      [],
                      []
                    |),
                    [
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "alloc::collections::btree::map::entry::OccupiedEntry")
                          []
                          [ T; Ty.path "alloc::collections::btree::set_val::SetValZST"; A ],
                        M.get_associated_function (|
                          Ty.apply
                            (Ty.path "alloc::collections::btree::map::entry::Entry")
                            []
                            [ T; Ty.path "alloc::collections::btree::set_val::SetValZST"; A ],
                          "insert_entry",
                          [],
                          []
                        |),
                        [
                          M.call_closure (|
                            Ty.apply
                              (Ty.path "alloc::collections::btree::map::entry::Entry")
                              []
                              [ T; Ty.path "alloc::collections::btree::set_val::SetValZST"; A ],
                            M.get_associated_function (|
                              Ty.apply
                                (Ty.path "alloc::collections::btree::map::BTreeMap")
                                []
                                [ T; Ty.path "alloc::collections::btree::set_val::SetValZST"; A ],
                              "entry",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.MutRef,
                                M.SubPointer.get_struct_record_field (|
                                  M.deref (| M.read (| self |) |),
                                  "alloc::collections::btree::set::BTreeSet",
                                  "map"
                                |)
                              |);
                              M.read (| value |)
                            ]
                          |);
                          Value.StructTuple "alloc::collections::btree::set_val::SetValZST" []
                        ]
                      |)
                    ]
                  |)
                |)
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Global Instance AssociatedFunction_get_or_insert :
          forall (T A : Ty.t),
          M.IsAssociatedFunction.C (Self T A) "get_or_insert" (get_or_insert T A).
        Admitted.
        Global Typeclasses Opaque get_or_insert.
        
        (*
            pub fn get_or_insert_with<Q: ?Sized, F>(&mut self, value: &Q, f: F) -> &T
            where
                T: Borrow<Q> + Ord,
                Q: Ord,
                F: FnOnce(&Q) -> T,
            {
                self.map.get_or_insert_with(value, f)
            }
        *)
        Definition get_or_insert_with
            (T A : Ty.t)
            (ε : list Value.t)
            (τ : list Ty.t)
            (α : list Value.t)
            : M :=
          let Self : Ty.t := Self T A in
          match ε, τ, α with
          | [], [ Q; F ], [ self; value; f ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let value := M.alloc (| value |) in
              let f := M.alloc (| f |) in
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.call_closure (|
                    Ty.apply (Ty.path "&") [] [ T ],
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "alloc::collections::btree::map::BTreeMap")
                        []
                        [ T; Ty.path "alloc::collections::btree::set_val::SetValZST"; A ],
                      "get_or_insert_with",
                      [],
                      [ Q; F ]
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.MutRef,
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "alloc::collections::btree::set::BTreeSet",
                          "map"
                        |)
                      |);
                      M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| value |) |) |);
                      M.read (| f |)
                    ]
                  |)
                |)
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Global Instance AssociatedFunction_get_or_insert_with :
          forall (T A : Ty.t),
          M.IsAssociatedFunction.C (Self T A) "get_or_insert_with" (get_or_insert_with T A).
        Admitted.
        Global Typeclasses Opaque get_or_insert_with.
        
        (*
            pub fn entry(&mut self, value: T) -> Entry<'_, T, A>
            where
                T: Ord,
            {
                match self.map.entry(value) {
                    map::Entry::Occupied(entry) => Entry::Occupied(OccupiedEntry { inner: entry }),
                    map::Entry::Vacant(entry) => Entry::Vacant(VacantEntry { inner: entry }),
                }
            }
        *)
        Definition entry (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self T A in
          match ε, τ, α with
          | [], [], [ self; value ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let value := M.alloc (| value |) in
              M.read (|
                M.match_operator (|
                  Some
                    (Ty.apply (Ty.path "alloc::collections::btree::set::entry::Entry") [] [ T; A ]),
                  M.alloc (|
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "alloc::collections::btree::map::entry::Entry")
                        []
                        [ T; Ty.path "alloc::collections::btree::set_val::SetValZST"; A ],
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "alloc::collections::btree::map::BTreeMap")
                          []
                          [ T; Ty.path "alloc::collections::btree::set_val::SetValZST"; A ],
                        "entry",
                        [],
                        []
                      |),
                      [
                        M.borrow (|
                          Pointer.Kind.MutRef,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "alloc::collections::btree::set::BTreeSet",
                            "map"
                          |)
                        |);
                        M.read (| value |)
                      ]
                    |)
                  |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ0_0 :=
                          M.SubPointer.get_struct_tuple_field (|
                            γ,
                            "alloc::collections::btree::map::entry::Entry::Occupied",
                            0
                          |) in
                        let entry := M.copy (| γ0_0 |) in
                        M.alloc (|
                          Value.StructTuple
                            "alloc::collections::btree::set::entry::Entry::Occupied"
                            [
                              Value.StructRecord
                                "alloc::collections::btree::set::entry::OccupiedEntry"
                                [ ("inner", M.read (| entry |)) ]
                            ]
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ0_0 :=
                          M.SubPointer.get_struct_tuple_field (|
                            γ,
                            "alloc::collections::btree::map::entry::Entry::Vacant",
                            0
                          |) in
                        let entry := M.copy (| γ0_0 |) in
                        M.alloc (|
                          Value.StructTuple
                            "alloc::collections::btree::set::entry::Entry::Vacant"
                            [
                              Value.StructRecord
                                "alloc::collections::btree::set::entry::VacantEntry"
                                [ ("inner", M.read (| entry |)) ]
                            ]
                        |)))
                  ]
                |)
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Global Instance AssociatedFunction_entry :
          forall (T A : Ty.t),
          M.IsAssociatedFunction.C (Self T A) "entry" (entry T A).
        Admitted.
        Global Typeclasses Opaque entry.
        
        (*
            pub fn remove<Q: ?Sized>(&mut self, value: &Q) -> bool
            where
                T: Borrow<Q> + Ord,
                Q: Ord,
            {
                self.map.remove(value).is_some()
            }
        *)
        Definition remove (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self T A in
          match ε, τ, α with
          | [], [ Q ], [ self; value ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let value := M.alloc (| value |) in
              M.call_closure (|
                Ty.path "bool",
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "core::option::Option")
                    []
                    [ Ty.path "alloc::collections::btree::set_val::SetValZST" ],
                  "is_some",
                  [],
                  []
                |),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::option::Option")
                          []
                          [ Ty.path "alloc::collections::btree::set_val::SetValZST" ],
                        M.get_associated_function (|
                          Ty.apply
                            (Ty.path "alloc::collections::btree::map::BTreeMap")
                            []
                            [ T; Ty.path "alloc::collections::btree::set_val::SetValZST"; A ],
                          "remove",
                          [],
                          [ Q ]
                        |),
                        [
                          M.borrow (|
                            Pointer.Kind.MutRef,
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| self |) |),
                              "alloc::collections::btree::set::BTreeSet",
                              "map"
                            |)
                          |);
                          M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| value |) |) |)
                        ]
                      |)
                    |)
                  |)
                ]
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Global Instance AssociatedFunction_remove :
          forall (T A : Ty.t),
          M.IsAssociatedFunction.C (Self T A) "remove" (remove T A).
        Admitted.
        Global Typeclasses Opaque remove.
        
        (*
            pub fn take<Q: ?Sized>(&mut self, value: &Q) -> Option<T>
            where
                T: Borrow<Q> + Ord,
                Q: Ord,
            {
                self.map.remove_entry(value).map(|(k, _)| k)
            }
        *)
        Definition take (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self T A in
          match ε, τ, α with
          | [], [ Q ], [ self; value ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let value := M.alloc (| value |) in
              M.call_closure (|
                Ty.apply (Ty.path "core::option::Option") [] [ T ],
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "core::option::Option")
                    []
                    [ Ty.tuple [ T; Ty.path "alloc::collections::btree::set_val::SetValZST" ] ],
                  "map",
                  [],
                  [
                    T;
                    Ty.function
                      [
                        Ty.tuple
                          [ Ty.tuple [ T; Ty.path "alloc::collections::btree::set_val::SetValZST" ]
                          ]
                      ]
                      T
                  ]
                |),
                [
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "core::option::Option")
                      []
                      [ Ty.tuple [ T; Ty.path "alloc::collections::btree::set_val::SetValZST" ] ],
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "alloc::collections::btree::map::BTreeMap")
                        []
                        [ T; Ty.path "alloc::collections::btree::set_val::SetValZST"; A ],
                      "remove_entry",
                      [],
                      [ Q ]
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.MutRef,
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "alloc::collections::btree::set::BTreeSet",
                          "map"
                        |)
                      |);
                      M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| value |) |) |)
                    ]
                  |);
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0 ] =>
                          ltac:(M.monadic
                            (M.match_operator (|
                              Some
                                (Ty.function
                                  [
                                    Ty.tuple
                                      [
                                        Ty.tuple
                                          [
                                            T;
                                            Ty.path "alloc::collections::btree::set_val::SetValZST"
                                          ]
                                      ]
                                  ]
                                  T),
                              M.alloc (| α0 |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                    let k := M.copy (| γ0_0 |) in
                                    M.read (| k |)))
                              ]
                            |)))
                        | _ => M.impossible "wrong number of arguments"
                        end))
                ]
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Global Instance AssociatedFunction_take :
          forall (T A : Ty.t),
          M.IsAssociatedFunction.C (Self T A) "take" (take T A).
        Admitted.
        Global Typeclasses Opaque take.
        
        (*
            pub fn retain<F>(&mut self, mut f: F)
            where
                T: Ord,
                F: FnMut(&T) -> bool,
            {
                self.extract_if(|v| !f(v)).for_each(drop);
            }
        *)
        Definition retain (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self T A in
          match ε, τ, α with
          | [], [ F ], [ self; f ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let f := M.alloc (| f |) in
              M.read (|
                let~ _ : Ty.tuple [] :=
                  M.alloc (|
                    M.call_closure (|
                      Ty.tuple [],
                      M.get_trait_method (|
                        "core::iter::traits::iterator::Iterator",
                        Ty.apply
                          (Ty.path "alloc::collections::btree::set::ExtractIf")
                          []
                          [
                            T;
                            Ty.function
                              [ Ty.tuple [ Ty.apply (Ty.path "&") [] [ T ] ] ]
                              (Ty.path "bool");
                            A
                          ],
                        [],
                        [],
                        "for_each",
                        [],
                        [ Ty.function [ T ] (Ty.tuple []) ]
                      |),
                      [
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "alloc::collections::btree::set::ExtractIf")
                            []
                            [
                              T;
                              Ty.function
                                [ Ty.tuple [ Ty.apply (Ty.path "&") [] [ T ] ] ]
                                (Ty.path "bool");
                              A
                            ],
                          M.get_associated_function (|
                            Ty.apply
                              (Ty.path "alloc::collections::btree::set::BTreeSet")
                              []
                              [ T; A ],
                            "extract_if",
                            [],
                            [
                              Ty.function
                                [ Ty.tuple [ Ty.apply (Ty.path "&") [] [ T ] ] ]
                                (Ty.path "bool")
                            ]
                          |),
                          [
                            M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |);
                            M.closure
                              (fun γ =>
                                ltac:(M.monadic
                                  match γ with
                                  | [ α0 ] =>
                                    ltac:(M.monadic
                                      (M.match_operator (|
                                        Some
                                          (Ty.function
                                            [ Ty.tuple [ Ty.apply (Ty.path "&") [] [ T ] ] ]
                                            (Ty.path "bool")),
                                        M.alloc (| α0 |),
                                        [
                                          fun γ =>
                                            ltac:(M.monadic
                                              (let v := M.copy (| γ |) in
                                              UnOp.not (|
                                                M.call_closure (|
                                                  Ty.path "bool",
                                                  M.get_trait_method (|
                                                    "core::ops::function::FnMut",
                                                    F,
                                                    [],
                                                    [ Ty.tuple [ Ty.apply (Ty.path "&") [] [ T ] ]
                                                    ],
                                                    "call_mut",
                                                    [],
                                                    []
                                                  |),
                                                  [
                                                    M.borrow (| Pointer.Kind.MutRef, f |);
                                                    Value.Tuple
                                                      [
                                                        M.borrow (|
                                                          Pointer.Kind.Ref,
                                                          M.deref (| M.read (| v |) |)
                                                        |)
                                                      ]
                                                  ]
                                                |)
                                              |)))
                                        ]
                                      |)))
                                  | _ => M.impossible "wrong number of arguments"
                                  end))
                          ]
                        |);
                        M.get_function (| "core::mem::drop", [], [ T ] |)
                      ]
                    |)
                  |) in
                M.alloc (| Value.Tuple [] |)
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Global Instance AssociatedFunction_retain :
          forall (T A : Ty.t),
          M.IsAssociatedFunction.C (Self T A) "retain" (retain T A).
        Admitted.
        Global Typeclasses Opaque retain.
        
        (*
            pub fn append(&mut self, other: &mut Self)
            where
                T: Ord,
                A: Clone,
            {
                self.map.append(&mut other.map);
            }
        *)
        Definition append (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self T A in
          match ε, τ, α with
          | [], [], [ self; other ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let other := M.alloc (| other |) in
              M.read (|
                let~ _ : Ty.tuple [] :=
                  M.alloc (|
                    M.call_closure (|
                      Ty.tuple [],
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "alloc::collections::btree::map::BTreeMap")
                          []
                          [ T; Ty.path "alloc::collections::btree::set_val::SetValZST"; A ],
                        "append",
                        [],
                        []
                      |),
                      [
                        M.borrow (|
                          Pointer.Kind.MutRef,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "alloc::collections::btree::set::BTreeSet",
                            "map"
                          |)
                        |);
                        M.borrow (|
                          Pointer.Kind.MutRef,
                          M.deref (|
                            M.borrow (|
                              Pointer.Kind.MutRef,
                              M.SubPointer.get_struct_record_field (|
                                M.deref (| M.read (| other |) |),
                                "alloc::collections::btree::set::BTreeSet",
                                "map"
                              |)
                            |)
                          |)
                        |)
                      ]
                    |)
                  |) in
                M.alloc (| Value.Tuple [] |)
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Global Instance AssociatedFunction_append :
          forall (T A : Ty.t),
          M.IsAssociatedFunction.C (Self T A) "append" (append T A).
        Admitted.
        Global Typeclasses Opaque append.
        
        (*
            pub fn split_off<Q: ?Sized + Ord>(&mut self, value: &Q) -> Self
            where
                T: Borrow<Q> + Ord,
                A: Clone,
            {
                BTreeSet { map: self.map.split_off(value) }
            }
        *)
        Definition split_off
            (T A : Ty.t)
            (ε : list Value.t)
            (τ : list Ty.t)
            (α : list Value.t)
            : M :=
          let Self : Ty.t := Self T A in
          match ε, τ, α with
          | [], [ Q ], [ self; value ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let value := M.alloc (| value |) in
              Value.StructRecord
                "alloc::collections::btree::set::BTreeSet"
                [
                  ("map",
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "alloc::collections::btree::map::BTreeMap")
                        []
                        [ T; Ty.path "alloc::collections::btree::set_val::SetValZST"; A ],
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "alloc::collections::btree::map::BTreeMap")
                          []
                          [ T; Ty.path "alloc::collections::btree::set_val::SetValZST"; A ],
                        "split_off",
                        [],
                        [ Q ]
                      |),
                      [
                        M.borrow (|
                          Pointer.Kind.MutRef,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "alloc::collections::btree::set::BTreeSet",
                            "map"
                          |)
                        |);
                        M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| value |) |) |)
                      ]
                    |))
                ]))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Global Instance AssociatedFunction_split_off :
          forall (T A : Ty.t),
          M.IsAssociatedFunction.C (Self T A) "split_off" (split_off T A).
        Admitted.
        Global Typeclasses Opaque split_off.
        
        (*
            pub fn extract_if<'a, F>(&'a mut self, pred: F) -> ExtractIf<'a, T, F, A>
            where
                T: Ord,
                F: 'a + FnMut(&T) -> bool,
            {
                let (inner, alloc) = self.map.extract_if_inner();
                ExtractIf { pred, inner, alloc }
            }
        *)
        Definition extract_if
            (T A : Ty.t)
            (ε : list Value.t)
            (τ : list Ty.t)
            (α : list Value.t)
            : M :=
          let Self : Ty.t := Self T A in
          match ε, τ, α with
          | [], [ F ], [ self; pred ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let pred := M.alloc (| pred |) in
              M.read (|
                M.match_operator (|
                  None,
                  M.alloc (|
                    M.call_closure (|
                      Ty.tuple
                        [
                          Ty.apply
                            (Ty.path "alloc::collections::btree::map::ExtractIfInner")
                            []
                            [ T; Ty.path "alloc::collections::btree::set_val::SetValZST" ];
                          A
                        ],
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "alloc::collections::btree::map::BTreeMap")
                          []
                          [ T; Ty.path "alloc::collections::btree::set_val::SetValZST"; A ],
                        "extract_if_inner",
                        [],
                        []
                      |),
                      [
                        M.borrow (|
                          Pointer.Kind.MutRef,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "alloc::collections::btree::set::BTreeSet",
                            "map"
                          |)
                        |)
                      ]
                    |)
                  |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                        let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                        let inner := M.copy (| γ0_0 |) in
                        let alloc := M.copy (| γ0_1 |) in
                        M.alloc (|
                          Value.StructRecord
                            "alloc::collections::btree::set::ExtractIf"
                            [
                              ("pred", M.read (| pred |));
                              ("inner", M.read (| inner |));
                              ("alloc", M.read (| alloc |))
                            ]
                        |)))
                  ]
                |)
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Global Instance AssociatedFunction_extract_if :
          forall (T A : Ty.t),
          M.IsAssociatedFunction.C (Self T A) "extract_if" (extract_if T A).
        Admitted.
        Global Typeclasses Opaque extract_if.
        
        (*
            pub fn iter(&self) -> Iter<'_, T> {
                Iter { iter: self.map.keys() }
            }
        *)
        Definition iter (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self T A in
          match ε, τ, α with
          | [], [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              Value.StructRecord
                "alloc::collections::btree::set::Iter"
                [
                  ("iter",
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "alloc::collections::btree::map::Keys")
                        []
                        [ T; Ty.path "alloc::collections::btree::set_val::SetValZST" ],
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "alloc::collections::btree::map::BTreeMap")
                          []
                          [ T; Ty.path "alloc::collections::btree::set_val::SetValZST"; A ],
                        "keys",
                        [],
                        []
                      |),
                      [
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "alloc::collections::btree::set::BTreeSet",
                            "map"
                          |)
                        |)
                      ]
                    |))
                ]))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Global Instance AssociatedFunction_iter :
          forall (T A : Ty.t),
          M.IsAssociatedFunction.C (Self T A) "iter" (iter T A).
        Admitted.
        Global Typeclasses Opaque iter.
        
        (*
            pub const fn len(&self) -> usize {
                self.map.len()
            }
        *)
        Definition len (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self T A in
          match ε, τ, α with
          | [], [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              M.call_closure (|
                Ty.path "usize",
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "alloc::collections::btree::map::BTreeMap")
                    []
                    [ T; Ty.path "alloc::collections::btree::set_val::SetValZST"; A ],
                  "len",
                  [],
                  []
                |),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| self |) |),
                      "alloc::collections::btree::set::BTreeSet",
                      "map"
                    |)
                  |)
                ]
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Global Instance AssociatedFunction_len :
          forall (T A : Ty.t),
          M.IsAssociatedFunction.C (Self T A) "len" (len T A).
        Admitted.
        Global Typeclasses Opaque len.
        
        (*
            pub const fn is_empty(&self) -> bool {
                self.len() == 0
            }
        *)
        Definition is_empty
            (T A : Ty.t)
            (ε : list Value.t)
            (τ : list Ty.t)
            (α : list Value.t)
            : M :=
          let Self : Ty.t := Self T A in
          match ε, τ, α with
          | [], [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              M.call_closure (|
                Ty.path "bool",
                BinOp.eq,
                [
                  M.call_closure (|
                    Ty.path "usize",
                    M.get_associated_function (|
                      Ty.apply (Ty.path "alloc::collections::btree::set::BTreeSet") [] [ T; A ],
                      "len",
                      [],
                      []
                    |),
                    [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                  |);
                  Value.Integer IntegerKind.Usize 0
                ]
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Global Instance AssociatedFunction_is_empty :
          forall (T A : Ty.t),
          M.IsAssociatedFunction.C (Self T A) "is_empty" (is_empty T A).
        Admitted.
        Global Typeclasses Opaque is_empty.
        
        (*
            pub fn lower_bound<Q: ?Sized>(&self, bound: Bound<&Q>) -> Cursor<'_, T>
            where
                T: Borrow<Q> + Ord,
                Q: Ord,
            {
                Cursor { inner: self.map.lower_bound(bound) }
            }
        *)
        Definition lower_bound
            (T A : Ty.t)
            (ε : list Value.t)
            (τ : list Ty.t)
            (α : list Value.t)
            : M :=
          let Self : Ty.t := Self T A in
          match ε, τ, α with
          | [], [ Q ], [ self; bound ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let bound := M.alloc (| bound |) in
              Value.StructRecord
                "alloc::collections::btree::set::Cursor"
                [
                  ("inner",
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "alloc::collections::btree::map::Cursor")
                        []
                        [ T; Ty.path "alloc::collections::btree::set_val::SetValZST" ],
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "alloc::collections::btree::map::BTreeMap")
                          []
                          [ T; Ty.path "alloc::collections::btree::set_val::SetValZST"; A ],
                        "lower_bound",
                        [],
                        [ Q ]
                      |),
                      [
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "alloc::collections::btree::set::BTreeSet",
                            "map"
                          |)
                        |);
                        M.read (| bound |)
                      ]
                    |))
                ]))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Global Instance AssociatedFunction_lower_bound :
          forall (T A : Ty.t),
          M.IsAssociatedFunction.C (Self T A) "lower_bound" (lower_bound T A).
        Admitted.
        Global Typeclasses Opaque lower_bound.
        
        (*
            pub fn lower_bound_mut<Q: ?Sized>(&mut self, bound: Bound<&Q>) -> CursorMut<'_, T, A>
            where
                T: Borrow<Q> + Ord,
                Q: Ord,
            {
                CursorMut { inner: self.map.lower_bound_mut(bound) }
            }
        *)
        Definition lower_bound_mut
            (T A : Ty.t)
            (ε : list Value.t)
            (τ : list Ty.t)
            (α : list Value.t)
            : M :=
          let Self : Ty.t := Self T A in
          match ε, τ, α with
          | [], [ Q ], [ self; bound ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let bound := M.alloc (| bound |) in
              Value.StructRecord
                "alloc::collections::btree::set::CursorMut"
                [
                  ("inner",
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "alloc::collections::btree::map::CursorMut")
                        []
                        [ T; Ty.path "alloc::collections::btree::set_val::SetValZST"; A ],
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "alloc::collections::btree::map::BTreeMap")
                          []
                          [ T; Ty.path "alloc::collections::btree::set_val::SetValZST"; A ],
                        "lower_bound_mut",
                        [],
                        [ Q ]
                      |),
                      [
                        M.borrow (|
                          Pointer.Kind.MutRef,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "alloc::collections::btree::set::BTreeSet",
                            "map"
                          |)
                        |);
                        M.read (| bound |)
                      ]
                    |))
                ]))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Global Instance AssociatedFunction_lower_bound_mut :
          forall (T A : Ty.t),
          M.IsAssociatedFunction.C (Self T A) "lower_bound_mut" (lower_bound_mut T A).
        Admitted.
        Global Typeclasses Opaque lower_bound_mut.
        
        (*
            pub fn upper_bound<Q: ?Sized>(&self, bound: Bound<&Q>) -> Cursor<'_, T>
            where
                T: Borrow<Q> + Ord,
                Q: Ord,
            {
                Cursor { inner: self.map.upper_bound(bound) }
            }
        *)
        Definition upper_bound
            (T A : Ty.t)
            (ε : list Value.t)
            (τ : list Ty.t)
            (α : list Value.t)
            : M :=
          let Self : Ty.t := Self T A in
          match ε, τ, α with
          | [], [ Q ], [ self; bound ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let bound := M.alloc (| bound |) in
              Value.StructRecord
                "alloc::collections::btree::set::Cursor"
                [
                  ("inner",
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "alloc::collections::btree::map::Cursor")
                        []
                        [ T; Ty.path "alloc::collections::btree::set_val::SetValZST" ],
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "alloc::collections::btree::map::BTreeMap")
                          []
                          [ T; Ty.path "alloc::collections::btree::set_val::SetValZST"; A ],
                        "upper_bound",
                        [],
                        [ Q ]
                      |),
                      [
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "alloc::collections::btree::set::BTreeSet",
                            "map"
                          |)
                        |);
                        M.read (| bound |)
                      ]
                    |))
                ]))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Global Instance AssociatedFunction_upper_bound :
          forall (T A : Ty.t),
          M.IsAssociatedFunction.C (Self T A) "upper_bound" (upper_bound T A).
        Admitted.
        Global Typeclasses Opaque upper_bound.
        
        (*
            pub unsafe fn upper_bound_mut<Q: ?Sized>(&mut self, bound: Bound<&Q>) -> CursorMut<'_, T, A>
            where
                T: Borrow<Q> + Ord,
                Q: Ord,
            {
                CursorMut { inner: self.map.upper_bound_mut(bound) }
            }
        *)
        Definition upper_bound_mut
            (T A : Ty.t)
            (ε : list Value.t)
            (τ : list Ty.t)
            (α : list Value.t)
            : M :=
          let Self : Ty.t := Self T A in
          match ε, τ, α with
          | [], [ Q ], [ self; bound ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let bound := M.alloc (| bound |) in
              Value.StructRecord
                "alloc::collections::btree::set::CursorMut"
                [
                  ("inner",
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "alloc::collections::btree::map::CursorMut")
                        []
                        [ T; Ty.path "alloc::collections::btree::set_val::SetValZST"; A ],
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "alloc::collections::btree::map::BTreeMap")
                          []
                          [ T; Ty.path "alloc::collections::btree::set_val::SetValZST"; A ],
                        "upper_bound_mut",
                        [],
                        [ Q ]
                      |),
                      [
                        M.borrow (|
                          Pointer.Kind.MutRef,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "alloc::collections::btree::set::BTreeSet",
                            "map"
                          |)
                        |);
                        M.read (| bound |)
                      ]
                    |))
                ]))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Global Instance AssociatedFunction_upper_bound_mut :
          forall (T A : Ty.t),
          M.IsAssociatedFunction.C (Self T A) "upper_bound_mut" (upper_bound_mut T A).
        Admitted.
        Global Typeclasses Opaque upper_bound_mut.
        (*
            fn from_sorted_iter<I: Iterator<Item = T>>(iter: I, alloc: A) -> BTreeSet<T, A> {
                let iter = iter.map(|k| (k, SetValZST::default()));
                let map = BTreeMap::bulk_build_from_sorted_iter(iter, alloc);
                BTreeSet { map }
            }
        *)
        Definition from_sorted_iter
            (T A : Ty.t)
            (ε : list Value.t)
            (τ : list Ty.t)
            (α : list Value.t)
            : M :=
          let Self : Ty.t := Self T A in
          match ε, τ, α with
          | [], [ _ as I ], [ iter; alloc ] =>
            ltac:(M.monadic
              (let iter := M.alloc (| iter |) in
              let alloc := M.alloc (| alloc |) in
              M.read (|
                let~ iter :
                    Ty.apply
                      (Ty.path "core::iter::adapters::map::Map")
                      []
                      [
                        I;
                        Ty.function
                          [ Ty.tuple [ T ] ]
                          (Ty.tuple [ T; Ty.path "alloc::collections::btree::set_val::SetValZST" ])
                      ] :=
                  M.alloc (|
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "core::iter::adapters::map::Map")
                        []
                        [
                          I;
                          Ty.function
                            [ Ty.tuple [ T ] ]
                            (Ty.tuple
                              [ T; Ty.path "alloc::collections::btree::set_val::SetValZST" ])
                        ],
                      M.get_trait_method (|
                        "core::iter::traits::iterator::Iterator",
                        I,
                        [],
                        [],
                        "map",
                        [],
                        [
                          Ty.tuple [ T; Ty.path "alloc::collections::btree::set_val::SetValZST" ];
                          Ty.function
                            [ Ty.tuple [ T ] ]
                            (Ty.tuple
                              [ T; Ty.path "alloc::collections::btree::set_val::SetValZST" ])
                        ]
                      |),
                      [
                        M.read (| iter |);
                        M.closure
                          (fun γ =>
                            ltac:(M.monadic
                              match γ with
                              | [ α0 ] =>
                                ltac:(M.monadic
                                  (M.match_operator (|
                                    Some
                                      (Ty.function
                                        [ Ty.tuple [ T ] ]
                                        (Ty.tuple
                                          [
                                            T;
                                            Ty.path "alloc::collections::btree::set_val::SetValZST"
                                          ])),
                                    M.alloc (| α0 |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let k := M.copy (| γ |) in
                                          Value.Tuple
                                            [
                                              M.read (| k |);
                                              M.call_closure (|
                                                Ty.path
                                                  "alloc::collections::btree::set_val::SetValZST",
                                                M.get_trait_method (|
                                                  "core::default::Default",
                                                  Ty.path
                                                    "alloc::collections::btree::set_val::SetValZST",
                                                  [],
                                                  [],
                                                  "default",
                                                  [],
                                                  []
                                                |),
                                                []
                                              |)
                                            ]))
                                    ]
                                  |)))
                              | _ => M.impossible "wrong number of arguments"
                              end))
                      ]
                    |)
                  |) in
                let~ map :
                    Ty.apply
                      (Ty.path "alloc::collections::btree::map::BTreeMap")
                      []
                      [ T; Ty.path "alloc::collections::btree::set_val::SetValZST"; A ] :=
                  M.alloc (|
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "alloc::collections::btree::map::BTreeMap")
                        []
                        [ T; Ty.path "alloc::collections::btree::set_val::SetValZST"; A ],
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "alloc::collections::btree::map::BTreeMap")
                          []
                          [ T; Ty.path "alloc::collections::btree::set_val::SetValZST"; A ],
                        "bulk_build_from_sorted_iter",
                        [],
                        [
                          Ty.apply
                            (Ty.path "core::iter::adapters::map::Map")
                            []
                            [
                              I;
                              Ty.function
                                [ Ty.tuple [ T ] ]
                                (Ty.tuple
                                  [ T; Ty.path "alloc::collections::btree::set_val::SetValZST" ])
                            ]
                        ]
                      |),
                      [ M.read (| iter |); M.read (| alloc |) ]
                    |)
                  |) in
                M.alloc (|
                  Value.StructRecord
                    "alloc::collections::btree::set::BTreeSet"
                    [ ("map", M.read (| map |)) ]
                |)
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Global Instance AssociatedFunction_from_sorted_iter :
          forall (T A : Ty.t),
          M.IsAssociatedFunction.C (Self T A) "from_sorted_iter" (from_sorted_iter T A).
        Admitted.
        Global Typeclasses Opaque from_sorted_iter.
      End Impl_alloc_collections_btree_set_BTreeSet_T_A.
      
      Module Impl_core_iter_traits_collect_FromIterator_where_core_cmp_Ord_T_T_for_alloc_collections_btree_set_BTreeSet_T_alloc_alloc_Global.
        Definition Self (T : Ty.t) : Ty.t :=
          Ty.apply
            (Ty.path "alloc::collections::btree::set::BTreeSet")
            []
            [ T; Ty.path "alloc::alloc::Global" ].
        
        (*
            fn from_iter<I: IntoIterator<Item = T>>(iter: I) -> BTreeSet<T> {
                let mut inputs: Vec<_> = iter.into_iter().collect();
        
                if inputs.is_empty() {
                    return BTreeSet::new();
                }
        
                // use stable sort to preserve the insertion order.
                inputs.sort();
                BTreeSet::from_sorted_iter(inputs.into_iter(), Global)
            }
        *)
        Definition from_iter (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self T in
          match ε, τ, α with
          | [], [ _ as I ], [ iter ] =>
            ltac:(M.monadic
              (let iter := M.alloc (| iter |) in
              M.catch_return (|
                ltac:(M.monadic
                  (M.read (|
                    let~ inputs :
                        Ty.apply
                          (Ty.path "alloc::vec::Vec")
                          []
                          [ T; Ty.path "alloc::alloc::Global" ] :=
                      M.alloc (|
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "alloc::vec::Vec")
                            []
                            [ T; Ty.path "alloc::alloc::Global" ],
                          M.get_trait_method (|
                            "core::iter::traits::iterator::Iterator",
                            Ty.associated_in_trait
                              "core::iter::traits::collect::IntoIterator"
                              []
                              []
                              I
                              "IntoIter",
                            [],
                            [],
                            "collect",
                            [],
                            [
                              Ty.apply
                                (Ty.path "alloc::vec::Vec")
                                []
                                [ T; Ty.path "alloc::alloc::Global" ]
                            ]
                          |),
                          [
                            M.call_closure (|
                              Ty.associated_in_trait
                                "core::iter::traits::collect::IntoIterator"
                                []
                                []
                                I
                                "IntoIter",
                              M.get_trait_method (|
                                "core::iter::traits::collect::IntoIterator",
                                I,
                                [],
                                [],
                                "into_iter",
                                [],
                                []
                              |),
                              [ M.read (| iter |) ]
                            |)
                          ]
                        |)
                      |) in
                    let~ _ : Ty.tuple [] :=
                      M.match_operator (|
                        Some (Ty.tuple []),
                        M.alloc (| Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.use
                                  (M.alloc (|
                                    M.call_closure (|
                                      Ty.path "bool",
                                      M.get_associated_function (|
                                        Ty.apply
                                          (Ty.path "alloc::vec::Vec")
                                          []
                                          [ T; Ty.path "alloc::alloc::Global" ],
                                        "is_empty",
                                        [],
                                        []
                                      |),
                                      [ M.borrow (| Pointer.Kind.Ref, inputs |) ]
                                    |)
                                  |)) in
                              let _ :=
                                is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                              M.alloc (|
                                M.never_to_any (|
                                  M.read (|
                                    M.return_ (|
                                      M.call_closure (|
                                        Ty.apply
                                          (Ty.path "alloc::collections::btree::set::BTreeSet")
                                          []
                                          [ T; Ty.path "alloc::alloc::Global" ],
                                        M.get_associated_function (|
                                          Ty.apply
                                            (Ty.path "alloc::collections::btree::set::BTreeSet")
                                            []
                                            [ T; Ty.path "alloc::alloc::Global" ],
                                          "new",
                                          [],
                                          []
                                        |),
                                        []
                                      |)
                                    |)
                                  |)
                                |)
                              |)));
                          fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                        ]
                      |) in
                    let~ _ : Ty.tuple [] :=
                      M.alloc (|
                        M.call_closure (|
                          Ty.tuple [],
                          M.get_associated_function (|
                            Ty.apply (Ty.path "slice") [] [ T ],
                            "sort",
                            [],
                            []
                          |),
                          [
                            M.borrow (|
                              Pointer.Kind.MutRef,
                              M.deref (|
                                M.call_closure (|
                                  Ty.apply
                                    (Ty.path "&mut")
                                    []
                                    [ Ty.apply (Ty.path "slice") [] [ T ] ],
                                  M.get_trait_method (|
                                    "core::ops::deref::DerefMut",
                                    Ty.apply
                                      (Ty.path "alloc::vec::Vec")
                                      []
                                      [ T; Ty.path "alloc::alloc::Global" ],
                                    [],
                                    [],
                                    "deref_mut",
                                    [],
                                    []
                                  |),
                                  [ M.borrow (| Pointer.Kind.MutRef, inputs |) ]
                                |)
                              |)
                            |)
                          ]
                        |)
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "alloc::collections::btree::set::BTreeSet")
                          []
                          [ T; Ty.path "alloc::alloc::Global" ],
                        M.get_associated_function (|
                          Ty.apply
                            (Ty.path "alloc::collections::btree::set::BTreeSet")
                            []
                            [ T; Ty.path "alloc::alloc::Global" ],
                          "from_sorted_iter",
                          [],
                          [
                            Ty.apply
                              (Ty.path "alloc::vec::into_iter::IntoIter")
                              []
                              [ T; Ty.path "alloc::alloc::Global" ]
                          ]
                        |),
                        [
                          M.call_closure (|
                            Ty.apply
                              (Ty.path "alloc::vec::into_iter::IntoIter")
                              []
                              [ T; Ty.path "alloc::alloc::Global" ],
                            M.get_trait_method (|
                              "core::iter::traits::collect::IntoIterator",
                              Ty.apply
                                (Ty.path "alloc::vec::Vec")
                                []
                                [ T; Ty.path "alloc::alloc::Global" ],
                              [],
                              [],
                              "into_iter",
                              [],
                              []
                            |),
                            [ M.read (| inputs |) ]
                          |);
                          Value.StructTuple "alloc::alloc::Global" []
                        ]
                      |)
                    |)
                  |)))
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Axiom Implements :
          forall (T : Ty.t),
          M.IsTraitInstance
            "core::iter::traits::collect::FromIterator"
            (* Trait polymorphic consts *) []
            (* Trait polymorphic types *) [ T ]
            (Self T)
            (* Instance *) [ ("from_iter", InstanceField.Method (from_iter T)) ].
      End Impl_core_iter_traits_collect_FromIterator_where_core_cmp_Ord_T_T_for_alloc_collections_btree_set_BTreeSet_T_alloc_alloc_Global.
      
      
      Module Impl_core_convert_From_where_core_cmp_Ord_T_array_N_T_for_alloc_collections_btree_set_BTreeSet_T_alloc_alloc_Global.
        Definition Self (N : Value.t) (T : Ty.t) : Ty.t :=
          Ty.apply
            (Ty.path "alloc::collections::btree::set::BTreeSet")
            []
            [ T; Ty.path "alloc::alloc::Global" ].
        
        (*
            fn from(mut arr: [T; N]) -> Self {
                if N == 0 {
                    return BTreeSet::new();
                }
        
                // use stable sort to preserve the insertion order.
                arr.sort();
                let iter = IntoIterator::into_iter(arr).map(|k| (k, SetValZST::default()));
                let map = BTreeMap::bulk_build_from_sorted_iter(iter, Global);
                BTreeSet { map }
            }
        *)
        Definition from
            (N : Value.t)
            (T : Ty.t)
            (ε : list Value.t)
            (τ : list Ty.t)
            (α : list Value.t)
            : M :=
          let Self : Ty.t := Self N T in
          match ε, τ, α with
          | [], [], [ arr ] =>
            ltac:(M.monadic
              (let arr := M.alloc (| arr |) in
              M.catch_return (|
                ltac:(M.monadic
                  (M.read (|
                    let~ _ : Ty.tuple [] :=
                      M.match_operator (|
                        Some (Ty.tuple []),
                        M.alloc (| Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.use
                                  (M.alloc (|
                                    M.call_closure (|
                                      Ty.path "bool",
                                      BinOp.eq,
                                      [ N; Value.Integer IntegerKind.Usize 0 ]
                                    |)
                                  |)) in
                              let _ :=
                                is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                              M.alloc (|
                                M.never_to_any (|
                                  M.read (|
                                    M.return_ (|
                                      M.call_closure (|
                                        Ty.apply
                                          (Ty.path "alloc::collections::btree::set::BTreeSet")
                                          []
                                          [ T; Ty.path "alloc::alloc::Global" ],
                                        M.get_associated_function (|
                                          Ty.apply
                                            (Ty.path "alloc::collections::btree::set::BTreeSet")
                                            []
                                            [ T; Ty.path "alloc::alloc::Global" ],
                                          "new",
                                          [],
                                          []
                                        |),
                                        []
                                      |)
                                    |)
                                  |)
                                |)
                              |)));
                          fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                        ]
                      |) in
                    let~ _ : Ty.tuple [] :=
                      M.alloc (|
                        M.call_closure (|
                          Ty.tuple [],
                          M.get_associated_function (|
                            Ty.apply (Ty.path "slice") [] [ T ],
                            "sort",
                            [],
                            []
                          |),
                          [
                            (* Unsize *)
                            M.pointer_coercion (M.borrow (| Pointer.Kind.MutRef, arr |))
                          ]
                        |)
                      |) in
                    let~ iter :
                        Ty.apply
                          (Ty.path "core::iter::adapters::map::Map")
                          []
                          [
                            Ty.apply (Ty.path "core::array::iter::IntoIter") [ N ] [ T ];
                            Ty.function
                              [ Ty.tuple [ T ] ]
                              (Ty.tuple
                                [ T; Ty.path "alloc::collections::btree::set_val::SetValZST" ])
                          ] :=
                      M.alloc (|
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "core::iter::adapters::map::Map")
                            []
                            [
                              Ty.apply (Ty.path "core::array::iter::IntoIter") [ N ] [ T ];
                              Ty.function
                                [ Ty.tuple [ T ] ]
                                (Ty.tuple
                                  [ T; Ty.path "alloc::collections::btree::set_val::SetValZST" ])
                            ],
                          M.get_trait_method (|
                            "core::iter::traits::iterator::Iterator",
                            Ty.apply (Ty.path "core::array::iter::IntoIter") [ N ] [ T ],
                            [],
                            [],
                            "map",
                            [],
                            [
                              Ty.tuple
                                [ T; Ty.path "alloc::collections::btree::set_val::SetValZST" ];
                              Ty.function
                                [ Ty.tuple [ T ] ]
                                (Ty.tuple
                                  [ T; Ty.path "alloc::collections::btree::set_val::SetValZST" ])
                            ]
                          |),
                          [
                            M.call_closure (|
                              Ty.apply (Ty.path "core::array::iter::IntoIter") [ N ] [ T ],
                              M.get_trait_method (|
                                "core::iter::traits::collect::IntoIterator",
                                Ty.apply (Ty.path "array") [ N ] [ T ],
                                [],
                                [],
                                "into_iter",
                                [],
                                []
                              |),
                              [ M.read (| arr |) ]
                            |);
                            M.closure
                              (fun γ =>
                                ltac:(M.monadic
                                  match γ with
                                  | [ α0 ] =>
                                    ltac:(M.monadic
                                      (M.match_operator (|
                                        Some
                                          (Ty.function
                                            [ Ty.tuple [ T ] ]
                                            (Ty.tuple
                                              [
                                                T;
                                                Ty.path
                                                  "alloc::collections::btree::set_val::SetValZST"
                                              ])),
                                        M.alloc (| α0 |),
                                        [
                                          fun γ =>
                                            ltac:(M.monadic
                                              (let k := M.copy (| γ |) in
                                              Value.Tuple
                                                [
                                                  M.read (| k |);
                                                  M.call_closure (|
                                                    Ty.path
                                                      "alloc::collections::btree::set_val::SetValZST",
                                                    M.get_trait_method (|
                                                      "core::default::Default",
                                                      Ty.path
                                                        "alloc::collections::btree::set_val::SetValZST",
                                                      [],
                                                      [],
                                                      "default",
                                                      [],
                                                      []
                                                    |),
                                                    []
                                                  |)
                                                ]))
                                        ]
                                      |)))
                                  | _ => M.impossible "wrong number of arguments"
                                  end))
                          ]
                        |)
                      |) in
                    let~ map :
                        Ty.apply
                          (Ty.path "alloc::collections::btree::map::BTreeMap")
                          []
                          [
                            T;
                            Ty.path "alloc::collections::btree::set_val::SetValZST";
                            Ty.path "alloc::alloc::Global"
                          ] :=
                      M.alloc (|
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "alloc::collections::btree::map::BTreeMap")
                            []
                            [
                              T;
                              Ty.path "alloc::collections::btree::set_val::SetValZST";
                              Ty.path "alloc::alloc::Global"
                            ],
                          M.get_associated_function (|
                            Ty.apply
                              (Ty.path "alloc::collections::btree::map::BTreeMap")
                              []
                              [
                                T;
                                Ty.path "alloc::collections::btree::set_val::SetValZST";
                                Ty.path "alloc::alloc::Global"
                              ],
                            "bulk_build_from_sorted_iter",
                            [],
                            [
                              Ty.apply
                                (Ty.path "core::iter::adapters::map::Map")
                                []
                                [
                                  Ty.apply (Ty.path "core::array::iter::IntoIter") [ N ] [ T ];
                                  Ty.function
                                    [ Ty.tuple [ T ] ]
                                    (Ty.tuple
                                      [ T; Ty.path "alloc::collections::btree::set_val::SetValZST"
                                      ])
                                ]
                            ]
                          |),
                          [ M.read (| iter |); Value.StructTuple "alloc::alloc::Global" [] ]
                        |)
                      |) in
                    M.alloc (|
                      Value.StructRecord
                        "alloc::collections::btree::set::BTreeSet"
                        [ ("map", M.read (| map |)) ]
                    |)
                  |)))
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Axiom Implements :
          forall (N : Value.t) (T : Ty.t),
          M.IsTraitInstance
            "core::convert::From"
            (* Trait polymorphic consts *) []
            (* Trait polymorphic types *) [ Ty.apply (Ty.path "array") [ N ] [ T ] ]
            (Self N T)
            (* Instance *) [ ("from", InstanceField.Method (from N T)) ].
      End Impl_core_convert_From_where_core_cmp_Ord_T_array_N_T_for_alloc_collections_btree_set_BTreeSet_T_alloc_alloc_Global.
      
      Module Impl_core_iter_traits_collect_IntoIterator_where_core_alloc_Allocator_A_where_core_clone_Clone_A_for_alloc_collections_btree_set_BTreeSet_T_A.
        Definition Self (T A : Ty.t) : Ty.t :=
          Ty.apply (Ty.path "alloc::collections::btree::set::BTreeSet") [] [ T; A ].
        
        (*     type Item = T; *)
        Definition _Item (T A : Ty.t) : Ty.t := T.
        
        (*     type IntoIter = IntoIter<T, A>; *)
        Definition _IntoIter (T A : Ty.t) : Ty.t :=
          Ty.apply (Ty.path "alloc::collections::btree::set::IntoIter") [] [ T; A ].
        
        (*
            fn into_iter(self) -> IntoIter<T, A> {
                IntoIter { iter: self.map.into_iter() }
            }
        *)
        Definition into_iter
            (T A : Ty.t)
            (ε : list Value.t)
            (τ : list Ty.t)
            (α : list Value.t)
            : M :=
          let Self : Ty.t := Self T A in
          match ε, τ, α with
          | [], [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              Value.StructRecord
                "alloc::collections::btree::set::IntoIter"
                [
                  ("iter",
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "alloc::collections::btree::map::IntoIter")
                        []
                        [ T; Ty.path "alloc::collections::btree::set_val::SetValZST"; A ],
                      M.get_trait_method (|
                        "core::iter::traits::collect::IntoIterator",
                        Ty.apply
                          (Ty.path "alloc::collections::btree::map::BTreeMap")
                          []
                          [ T; Ty.path "alloc::collections::btree::set_val::SetValZST"; A ],
                        [],
                        [],
                        "into_iter",
                        [],
                        []
                      |),
                      [
                        M.read (|
                          M.SubPointer.get_struct_record_field (|
                            self,
                            "alloc::collections::btree::set::BTreeSet",
                            "map"
                          |)
                        |)
                      ]
                    |))
                ]))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Axiom Implements :
          forall (T A : Ty.t),
          M.IsTraitInstance
            "core::iter::traits::collect::IntoIterator"
            (* Trait polymorphic consts *) []
            (* Trait polymorphic types *) []
            (Self T A)
            (* Instance *)
            [
              ("Item", InstanceField.Ty (_Item T A));
              ("IntoIter", InstanceField.Ty (_IntoIter T A));
              ("into_iter", InstanceField.Method (into_iter T A))
            ].
      End Impl_core_iter_traits_collect_IntoIterator_where_core_alloc_Allocator_A_where_core_clone_Clone_A_for_alloc_collections_btree_set_BTreeSet_T_A.
      
      Module Impl_core_iter_traits_collect_IntoIterator_where_core_alloc_Allocator_A_where_core_clone_Clone_A_for_ref__alloc_collections_btree_set_BTreeSet_T_A.
        Definition Self (T A : Ty.t) : Ty.t :=
          Ty.apply
            (Ty.path "&")
            []
            [ Ty.apply (Ty.path "alloc::collections::btree::set::BTreeSet") [] [ T; A ] ].
        
        (*     type Item = &'a T; *)
        Definition _Item (T A : Ty.t) : Ty.t := Ty.apply (Ty.path "&") [] [ T ].
        
        (*     type IntoIter = Iter<'a, T>; *)
        Definition _IntoIter (T A : Ty.t) : Ty.t :=
          Ty.apply (Ty.path "alloc::collections::btree::set::Iter") [] [ T ].
        
        (*
            fn into_iter(self) -> Iter<'a, T> {
                self.iter()
            }
        *)
        Definition into_iter
            (T A : Ty.t)
            (ε : list Value.t)
            (τ : list Ty.t)
            (α : list Value.t)
            : M :=
          let Self : Ty.t := Self T A in
          match ε, τ, α with
          | [], [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              M.call_closure (|
                Ty.apply (Ty.path "alloc::collections::btree::set::Iter") [] [ T ],
                M.get_associated_function (|
                  Ty.apply (Ty.path "alloc::collections::btree::set::BTreeSet") [] [ T; A ],
                  "iter",
                  [],
                  []
                |),
                [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Axiom Implements :
          forall (T A : Ty.t),
          M.IsTraitInstance
            "core::iter::traits::collect::IntoIterator"
            (* Trait polymorphic consts *) []
            (* Trait polymorphic types *) []
            (Self T A)
            (* Instance *)
            [
              ("Item", InstanceField.Ty (_Item T A));
              ("IntoIter", InstanceField.Ty (_IntoIter T A));
              ("into_iter", InstanceField.Method (into_iter T A))
            ].
      End Impl_core_iter_traits_collect_IntoIterator_where_core_alloc_Allocator_A_where_core_clone_Clone_A_for_ref__alloc_collections_btree_set_BTreeSet_T_A.
      
      (* StructRecord
        {
          name := "ExtractIf";
          const_params := [];
          ty_params := [ "T"; "F"; "A" ];
          fields :=
            [
              ("pred", F);
              ("inner",
                Ty.apply
                  (Ty.path "alloc::collections::btree::map::ExtractIfInner")
                  []
                  [ T; Ty.path "alloc::collections::btree::set_val::SetValZST" ]);
              ("alloc", A)
            ];
        } *)
      
      Module Impl_core_fmt_Debug_where_core_alloc_Allocator_A_where_core_clone_Clone_A_where_core_fmt_Debug_T_where_core_ops_function_FnMut_F_Tuple_ref__T__for_alloc_collections_btree_set_ExtractIf_T_F_A.
        Definition Self (T F A : Ty.t) : Ty.t :=
          Ty.apply (Ty.path "alloc::collections::btree::set::ExtractIf") [] [ T; F; A ].
        
        (*
            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                f.debug_tuple("ExtractIf").field(&self.inner.peek().map(|(k, _)| k)).finish()
            }
        *)
        Definition fmt (T F A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self T F A in
          match ε, τ, α with
          | [], [], [ self; f ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let f := M.alloc (| f |) in
              M.call_closure (|
                Ty.apply
                  (Ty.path "core::result::Result")
                  []
                  [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                M.get_associated_function (|
                  Ty.path "core::fmt::builders::DebugTuple",
                  "finish",
                  [],
                  []
                |),
                [
                  M.borrow (|
                    Pointer.Kind.MutRef,
                    M.deref (|
                      M.call_closure (|
                        Ty.apply (Ty.path "&mut") [] [ Ty.path "core::fmt::builders::DebugTuple" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::builders::DebugTuple",
                          "field",
                          [],
                          []
                        |),
                        [
                          M.borrow (|
                            Pointer.Kind.MutRef,
                            M.alloc (|
                              M.call_closure (|
                                Ty.path "core::fmt::builders::DebugTuple",
                                M.get_associated_function (|
                                  Ty.path "core::fmt::Formatter",
                                  "debug_tuple",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (| mk_str (| "ExtractIf" |) |)
                                  |)
                                ]
                              |)
                            |)
                          |);
                          (* Unsize *)
                          M.pointer_coercion
                            (M.borrow (|
                              Pointer.Kind.Ref,
                              M.deref (|
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.alloc (|
                                    M.call_closure (|
                                      Ty.apply
                                        (Ty.path "core::option::Option")
                                        []
                                        [ Ty.apply (Ty.path "&") [] [ T ] ],
                                      M.get_associated_function (|
                                        Ty.apply
                                          (Ty.path "core::option::Option")
                                          []
                                          [
                                            Ty.tuple
                                              [
                                                Ty.apply (Ty.path "&") [] [ T ];
                                                Ty.apply
                                                  (Ty.path "&")
                                                  []
                                                  [
                                                    Ty.path
                                                      "alloc::collections::btree::set_val::SetValZST"
                                                  ]
                                              ]
                                          ],
                                        "map",
                                        [],
                                        [
                                          Ty.apply (Ty.path "&") [] [ T ];
                                          Ty.function
                                            [
                                              Ty.tuple
                                                [
                                                  Ty.tuple
                                                    [
                                                      Ty.apply (Ty.path "&") [] [ T ];
                                                      Ty.apply
                                                        (Ty.path "&")
                                                        []
                                                        [
                                                          Ty.path
                                                            "alloc::collections::btree::set_val::SetValZST"
                                                        ]
                                                    ]
                                                ]
                                            ]
                                            (Ty.apply (Ty.path "&") [] [ T ])
                                        ]
                                      |),
                                      [
                                        M.call_closure (|
                                          Ty.apply
                                            (Ty.path "core::option::Option")
                                            []
                                            [
                                              Ty.tuple
                                                [
                                                  Ty.apply (Ty.path "&") [] [ T ];
                                                  Ty.apply
                                                    (Ty.path "&")
                                                    []
                                                    [
                                                      Ty.path
                                                        "alloc::collections::btree::set_val::SetValZST"
                                                    ]
                                                ]
                                            ],
                                          M.get_associated_function (|
                                            Ty.apply
                                              (Ty.path
                                                "alloc::collections::btree::map::ExtractIfInner")
                                              []
                                              [
                                                T;
                                                Ty.path
                                                  "alloc::collections::btree::set_val::SetValZST"
                                              ],
                                            "peek",
                                            [],
                                            []
                                          |),
                                          [
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.SubPointer.get_struct_record_field (|
                                                M.deref (| M.read (| self |) |),
                                                "alloc::collections::btree::set::ExtractIf",
                                                "inner"
                                              |)
                                            |)
                                          ]
                                        |);
                                        M.closure
                                          (fun γ =>
                                            ltac:(M.monadic
                                              match γ with
                                              | [ α0 ] =>
                                                ltac:(M.monadic
                                                  (M.match_operator (|
                                                    Some
                                                      (Ty.function
                                                        [
                                                          Ty.tuple
                                                            [
                                                              Ty.tuple
                                                                [
                                                                  Ty.apply (Ty.path "&") [] [ T ];
                                                                  Ty.apply
                                                                    (Ty.path "&")
                                                                    []
                                                                    [
                                                                      Ty.path
                                                                        "alloc::collections::btree::set_val::SetValZST"
                                                                    ]
                                                                ]
                                                            ]
                                                        ]
                                                        (Ty.apply (Ty.path "&") [] [ T ])),
                                                    M.alloc (| α0 |),
                                                    [
                                                      fun γ =>
                                                        ltac:(M.monadic
                                                          (let γ0_0 :=
                                                            M.SubPointer.get_tuple_field (|
                                                              γ,
                                                              0
                                                            |) in
                                                          let γ0_1 :=
                                                            M.SubPointer.get_tuple_field (|
                                                              γ,
                                                              1
                                                            |) in
                                                          let k := M.copy (| γ0_0 |) in
                                                          M.read (| k |)))
                                                    ]
                                                  |)))
                                              | _ => M.impossible "wrong number of arguments"
                                              end))
                                      ]
                                    |)
                                  |)
                                |)
                              |)
                            |))
                        ]
                      |)
                    |)
                  |)
                ]
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Axiom Implements :
          forall (T F A : Ty.t),
          M.IsTraitInstance
            "core::fmt::Debug"
            (* Trait polymorphic consts *) []
            (* Trait polymorphic types *) []
            (Self T F A)
            (* Instance *) [ ("fmt", InstanceField.Method (fmt T F A)) ].
      End Impl_core_fmt_Debug_where_core_alloc_Allocator_A_where_core_clone_Clone_A_where_core_fmt_Debug_T_where_core_ops_function_FnMut_F_Tuple_ref__T__for_alloc_collections_btree_set_ExtractIf_T_F_A.
      
      Module Impl_core_iter_traits_iterator_Iterator_where_core_alloc_Allocator_A_where_core_clone_Clone_A_where_core_ops_function_FnMut_F_Tuple_ref__T__for_alloc_collections_btree_set_ExtractIf_T_F_A.
        Definition Self (T F A : Ty.t) : Ty.t :=
          Ty.apply (Ty.path "alloc::collections::btree::set::ExtractIf") [] [ T; F; A ].
        
        (*     type Item = T; *)
        Definition _Item (T F A : Ty.t) : Ty.t := T.
        
        (*
            fn next(&mut self) -> Option<T> {
                let pred = &mut self.pred;
                let mut mapped_pred = |k: &T, _v: &mut SetValZST| pred(k);
                self.inner.next(&mut mapped_pred, self.alloc.clone()).map(|(k, _)| k)
            }
        *)
        Definition next (T F A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self T F A in
          match ε, τ, α with
          | [], [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              M.read (|
                let~ pred : Ty.apply (Ty.path "&mut") [] [ F ] :=
                  M.alloc (|
                    M.borrow (|
                      Pointer.Kind.MutRef,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "alloc::collections::btree::set::ExtractIf",
                        "pred"
                      |)
                    |)
                  |) in
                let~ mapped_pred :
                    Ty.function
                      [
                        Ty.tuple
                          [
                            Ty.apply (Ty.path "&") [] [ T ];
                            Ty.apply
                              (Ty.path "&mut")
                              []
                              [ Ty.path "alloc::collections::btree::set_val::SetValZST" ]
                          ]
                      ]
                      (Ty.path "bool") :=
                  M.alloc (|
                    M.closure
                      (fun γ =>
                        ltac:(M.monadic
                          match γ with
                          | [ α0; α1 ] =>
                            ltac:(M.monadic
                              (M.match_operator (|
                                Some
                                  (Ty.function
                                    [
                                      Ty.tuple
                                        [
                                          Ty.apply (Ty.path "&") [] [ T ];
                                          Ty.apply
                                            (Ty.path "&mut")
                                            []
                                            [
                                              Ty.path
                                                "alloc::collections::btree::set_val::SetValZST"
                                            ]
                                        ]
                                    ]
                                    (Ty.path "bool")),
                                M.alloc (| α0 |),
                                [
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let k := M.copy (| γ |) in
                                      M.match_operator (|
                                        Some
                                          (Ty.function
                                            [
                                              Ty.tuple
                                                [
                                                  Ty.apply (Ty.path "&") [] [ T ];
                                                  Ty.apply
                                                    (Ty.path "&mut")
                                                    []
                                                    [
                                                      Ty.path
                                                        "alloc::collections::btree::set_val::SetValZST"
                                                    ]
                                                ]
                                            ]
                                            (Ty.path "bool")),
                                        M.alloc (| α1 |),
                                        [
                                          fun γ =>
                                            ltac:(M.monadic
                                              (let _v := M.copy (| γ |) in
                                              M.call_closure (|
                                                Ty.path "bool",
                                                M.get_trait_method (|
                                                  "core::ops::function::FnMut",
                                                  F,
                                                  [],
                                                  [ Ty.tuple [ Ty.apply (Ty.path "&") [] [ T ] ] ],
                                                  "call_mut",
                                                  [],
                                                  []
                                                |),
                                                [
                                                  M.borrow (|
                                                    Pointer.Kind.MutRef,
                                                    M.deref (| M.read (| pred |) |)
                                                  |);
                                                  Value.Tuple
                                                    [
                                                      M.borrow (|
                                                        Pointer.Kind.Ref,
                                                        M.deref (| M.read (| k |) |)
                                                      |)
                                                    ]
                                                ]
                                              |)))
                                        ]
                                      |)))
                                ]
                              |)))
                          | _ => M.impossible "wrong number of arguments"
                          end))
                  |) in
                M.alloc (|
                  M.call_closure (|
                    Ty.apply (Ty.path "core::option::Option") [] [ T ],
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "core::option::Option")
                        []
                        [ Ty.tuple [ T; Ty.path "alloc::collections::btree::set_val::SetValZST" ] ],
                      "map",
                      [],
                      [
                        T;
                        Ty.function
                          [
                            Ty.tuple
                              [
                                Ty.tuple
                                  [ T; Ty.path "alloc::collections::btree::set_val::SetValZST" ]
                              ]
                          ]
                          T
                      ]
                    |),
                    [
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::option::Option")
                          []
                          [ Ty.tuple [ T; Ty.path "alloc::collections::btree::set_val::SetValZST" ]
                          ],
                        M.get_associated_function (|
                          Ty.apply
                            (Ty.path "alloc::collections::btree::map::ExtractIfInner")
                            []
                            [ T; Ty.path "alloc::collections::btree::set_val::SetValZST" ],
                          "next",
                          [],
                          [
                            Ty.function
                              [
                                Ty.tuple
                                  [
                                    Ty.apply (Ty.path "&") [] [ T ];
                                    Ty.apply
                                      (Ty.path "&mut")
                                      []
                                      [ Ty.path "alloc::collections::btree::set_val::SetValZST" ]
                                  ]
                              ]
                              (Ty.path "bool");
                            A
                          ]
                        |),
                        [
                          M.borrow (|
                            Pointer.Kind.MutRef,
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| self |) |),
                              "alloc::collections::btree::set::ExtractIf",
                              "inner"
                            |)
                          |);
                          M.borrow (|
                            Pointer.Kind.MutRef,
                            M.deref (| M.borrow (| Pointer.Kind.MutRef, mapped_pred |) |)
                          |);
                          M.call_closure (|
                            A,
                            M.get_trait_method (|
                              "core::clone::Clone",
                              A,
                              [],
                              [],
                              "clone",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.SubPointer.get_struct_record_field (|
                                  M.deref (| M.read (| self |) |),
                                  "alloc::collections::btree::set::ExtractIf",
                                  "alloc"
                                |)
                              |)
                            ]
                          |)
                        ]
                      |);
                      M.closure
                        (fun γ =>
                          ltac:(M.monadic
                            match γ with
                            | [ α0 ] =>
                              ltac:(M.monadic
                                (M.match_operator (|
                                  Some
                                    (Ty.function
                                      [
                                        Ty.tuple
                                          [
                                            Ty.tuple
                                              [
                                                T;
                                                Ty.path
                                                  "alloc::collections::btree::set_val::SetValZST"
                                              ]
                                          ]
                                      ]
                                      T),
                                  M.alloc (| α0 |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                                        let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                        let k := M.copy (| γ0_0 |) in
                                        M.read (| k |)))
                                  ]
                                |)))
                            | _ => M.impossible "wrong number of arguments"
                            end))
                    ]
                  |)
                |)
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        (*
            fn size_hint(&self) -> (usize, Option<usize>) {
                self.inner.size_hint()
            }
        *)
        Definition size_hint
            (T F A : Ty.t)
            (ε : list Value.t)
            (τ : list Ty.t)
            (α : list Value.t)
            : M :=
          let Self : Ty.t := Self T F A in
          match ε, τ, α with
          | [], [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              M.call_closure (|
                Ty.tuple
                  [
                    Ty.path "usize";
                    Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "usize" ]
                  ],
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "alloc::collections::btree::map::ExtractIfInner")
                    []
                    [ T; Ty.path "alloc::collections::btree::set_val::SetValZST" ],
                  "size_hint",
                  [],
                  []
                |),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| self |) |),
                      "alloc::collections::btree::set::ExtractIf",
                      "inner"
                    |)
                  |)
                ]
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Axiom Implements :
          forall (T F A : Ty.t),
          M.IsTraitInstance
            "core::iter::traits::iterator::Iterator"
            (* Trait polymorphic consts *) []
            (* Trait polymorphic types *) []
            (Self T F A)
            (* Instance *)
            [
              ("Item", InstanceField.Ty (_Item T F A));
              ("next", InstanceField.Method (next T F A));
              ("size_hint", InstanceField.Method (size_hint T F A))
            ].
      End Impl_core_iter_traits_iterator_Iterator_where_core_alloc_Allocator_A_where_core_clone_Clone_A_where_core_ops_function_FnMut_F_Tuple_ref__T__for_alloc_collections_btree_set_ExtractIf_T_F_A.
      
      Module Impl_core_iter_traits_marker_FusedIterator_where_core_alloc_Allocator_A_where_core_clone_Clone_A_where_core_ops_function_FnMut_F_Tuple_ref__T__for_alloc_collections_btree_set_ExtractIf_T_F_A.
        Definition Self (T F A : Ty.t) : Ty.t :=
          Ty.apply (Ty.path "alloc::collections::btree::set::ExtractIf") [] [ T; F; A ].
        
        Axiom Implements :
          forall (T F A : Ty.t),
          M.IsTraitInstance
            "core::iter::traits::marker::FusedIterator"
            (* Trait polymorphic consts *) []
            (* Trait polymorphic types *) []
            (Self T F A)
            (* Instance *) [].
      End Impl_core_iter_traits_marker_FusedIterator_where_core_alloc_Allocator_A_where_core_clone_Clone_A_where_core_ops_function_FnMut_F_Tuple_ref__T__for_alloc_collections_btree_set_ExtractIf_T_F_A.
      
      Module Impl_core_iter_traits_collect_Extend_where_core_cmp_Ord_T_where_core_alloc_Allocator_A_where_core_clone_Clone_A_T_for_alloc_collections_btree_set_BTreeSet_T_A.
        Definition Self (T A : Ty.t) : Ty.t :=
          Ty.apply (Ty.path "alloc::collections::btree::set::BTreeSet") [] [ T; A ].
        
        (*
            fn extend<Iter: IntoIterator<Item = T>>(&mut self, iter: Iter) {
                iter.into_iter().for_each(move |elem| {
                    self.insert(elem);
                });
            }
        *)
        Definition extend (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self T A in
          match ε, τ, α with
          | [], [ Iter ], [ self; iter ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let iter := M.alloc (| iter |) in
              M.read (|
                let~ _ : Ty.tuple [] :=
                  M.alloc (|
                    M.call_closure (|
                      Ty.tuple [],
                      M.get_trait_method (|
                        "core::iter::traits::iterator::Iterator",
                        Ty.associated_in_trait
                          "core::iter::traits::collect::IntoIterator"
                          []
                          []
                          Iter
                          "IntoIter",
                        [],
                        [],
                        "for_each",
                        [],
                        [ Ty.function [ Ty.tuple [ T ] ] (Ty.tuple []) ]
                      |),
                      [
                        M.call_closure (|
                          Ty.associated_in_trait
                            "core::iter::traits::collect::IntoIterator"
                            []
                            []
                            Iter
                            "IntoIter",
                          M.get_trait_method (|
                            "core::iter::traits::collect::IntoIterator",
                            Iter,
                            [],
                            [],
                            "into_iter",
                            [],
                            []
                          |),
                          [ M.read (| iter |) ]
                        |);
                        M.closure
                          (fun γ =>
                            ltac:(M.monadic
                              match γ with
                              | [ α0 ] =>
                                ltac:(M.monadic
                                  (M.match_operator (|
                                    Some (Ty.function [ Ty.tuple [ T ] ] (Ty.tuple [])),
                                    M.alloc (| α0 |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let elem := M.copy (| γ |) in
                                          M.read (|
                                            let~ _ : Ty.path "bool" :=
                                              M.alloc (|
                                                M.call_closure (|
                                                  Ty.path "bool",
                                                  M.get_associated_function (|
                                                    Ty.apply
                                                      (Ty.path
                                                        "alloc::collections::btree::set::BTreeSet")
                                                      []
                                                      [ T; A ],
                                                    "insert",
                                                    [],
                                                    []
                                                  |),
                                                  [
                                                    M.borrow (|
                                                      Pointer.Kind.MutRef,
                                                      M.deref (| M.read (| self |) |)
                                                    |);
                                                    M.read (| elem |)
                                                  ]
                                                |)
                                              |) in
                                            M.alloc (| Value.Tuple [] |)
                                          |)))
                                    ]
                                  |)))
                              | _ => M.impossible "wrong number of arguments"
                              end))
                      ]
                    |)
                  |) in
                M.alloc (| Value.Tuple [] |)
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        (*
            fn extend_one(&mut self, elem: T) {
                self.insert(elem);
            }
        *)
        Definition extend_one
            (T A : Ty.t)
            (ε : list Value.t)
            (τ : list Ty.t)
            (α : list Value.t)
            : M :=
          let Self : Ty.t := Self T A in
          match ε, τ, α with
          | [], [], [ self; elem ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let elem := M.alloc (| elem |) in
              M.read (|
                let~ _ : Ty.path "bool" :=
                  M.alloc (|
                    M.call_closure (|
                      Ty.path "bool",
                      M.get_associated_function (|
                        Ty.apply (Ty.path "alloc::collections::btree::set::BTreeSet") [] [ T; A ],
                        "insert",
                        [],
                        []
                      |),
                      [
                        M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |);
                        M.read (| elem |)
                      ]
                    |)
                  |) in
                M.alloc (| Value.Tuple [] |)
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Axiom Implements :
          forall (T A : Ty.t),
          M.IsTraitInstance
            "core::iter::traits::collect::Extend"
            (* Trait polymorphic consts *) []
            (* Trait polymorphic types *) [ T ]
            (Self T A)
            (* Instance *)
            [
              ("extend", InstanceField.Method (extend T A));
              ("extend_one", InstanceField.Method (extend_one T A))
            ].
      End Impl_core_iter_traits_collect_Extend_where_core_cmp_Ord_T_where_core_alloc_Allocator_A_where_core_clone_Clone_A_T_for_alloc_collections_btree_set_BTreeSet_T_A.
      
      Module Impl_core_iter_traits_collect_Extend_where_core_cmp_Ord_T_where_core_marker_Copy_T_where_core_alloc_Allocator_A_where_core_clone_Clone_A_ref__T_for_alloc_collections_btree_set_BTreeSet_T_A.
        Definition Self (T A : Ty.t) : Ty.t :=
          Ty.apply (Ty.path "alloc::collections::btree::set::BTreeSet") [] [ T; A ].
        
        (*
            fn extend<I: IntoIterator<Item = &'a T>>(&mut self, iter: I) {
                self.extend(iter.into_iter().cloned());
            }
        *)
        Definition extend (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self T A in
          match ε, τ, α with
          | [], [ _ as I ], [ self; iter ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let iter := M.alloc (| iter |) in
              M.read (|
                let~ _ : Ty.tuple [] :=
                  M.alloc (|
                    M.call_closure (|
                      Ty.tuple [],
                      M.get_trait_method (|
                        "core::iter::traits::collect::Extend",
                        Ty.apply (Ty.path "alloc::collections::btree::set::BTreeSet") [] [ T; A ],
                        [],
                        [ T ],
                        "extend",
                        [],
                        [
                          Ty.apply
                            (Ty.path "core::iter::adapters::cloned::Cloned")
                            []
                            [
                              Ty.associated_in_trait
                                "core::iter::traits::collect::IntoIterator"
                                []
                                []
                                I
                                "IntoIter"
                            ]
                        ]
                      |),
                      [
                        M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |);
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "core::iter::adapters::cloned::Cloned")
                            []
                            [
                              Ty.associated_in_trait
                                "core::iter::traits::collect::IntoIterator"
                                []
                                []
                                I
                                "IntoIter"
                            ],
                          M.get_trait_method (|
                            "core::iter::traits::iterator::Iterator",
                            Ty.associated_in_trait
                              "core::iter::traits::collect::IntoIterator"
                              []
                              []
                              I
                              "IntoIter",
                            [],
                            [],
                            "cloned",
                            [],
                            [ T ]
                          |),
                          [
                            M.call_closure (|
                              Ty.associated_in_trait
                                "core::iter::traits::collect::IntoIterator"
                                []
                                []
                                I
                                "IntoIter",
                              M.get_trait_method (|
                                "core::iter::traits::collect::IntoIterator",
                                I,
                                [],
                                [],
                                "into_iter",
                                [],
                                []
                              |),
                              [ M.read (| iter |) ]
                            |)
                          ]
                        |)
                      ]
                    |)
                  |) in
                M.alloc (| Value.Tuple [] |)
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        (*
            fn extend_one(&mut self, &elem: &'a T) {
                self.insert(elem);
            }
        *)
        Definition extend_one
            (T A : Ty.t)
            (ε : list Value.t)
            (τ : list Ty.t)
            (α : list Value.t)
            : M :=
          let Self : Ty.t := Self T A in
          match ε, τ, α with
          | [], [], [ self; β1 ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let β1 := M.alloc (| β1 |) in
              M.match_operator (|
                None,
                β1,
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.read (| γ |) in
                      let elem := M.copy (| γ |) in
                      M.read (|
                        let~ _ : Ty.path "bool" :=
                          M.alloc (|
                            M.call_closure (|
                              Ty.path "bool",
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "alloc::collections::btree::set::BTreeSet")
                                  []
                                  [ T; A ],
                                "insert",
                                [],
                                []
                              |),
                              [
                                M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |);
                                M.read (| elem |)
                              ]
                            |)
                          |) in
                        M.alloc (| Value.Tuple [] |)
                      |)))
                ]
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Axiom Implements :
          forall (T A : Ty.t),
          M.IsTraitInstance
            "core::iter::traits::collect::Extend"
            (* Trait polymorphic consts *) []
            (* Trait polymorphic types *) [ Ty.apply (Ty.path "&") [] [ T ] ]
            (Self T A)
            (* Instance *)
            [
              ("extend", InstanceField.Method (extend T A));
              ("extend_one", InstanceField.Method (extend_one T A))
            ].
      End Impl_core_iter_traits_collect_Extend_where_core_cmp_Ord_T_where_core_marker_Copy_T_where_core_alloc_Allocator_A_where_core_clone_Clone_A_ref__T_for_alloc_collections_btree_set_BTreeSet_T_A.
      
      Module Impl_core_default_Default_for_alloc_collections_btree_set_BTreeSet_T_alloc_alloc_Global.
        Definition Self (T : Ty.t) : Ty.t :=
          Ty.apply
            (Ty.path "alloc::collections::btree::set::BTreeSet")
            []
            [ T; Ty.path "alloc::alloc::Global" ].
        
        (*
            fn default() -> BTreeSet<T> {
                BTreeSet::new()
            }
        *)
        Definition default (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self T in
          match ε, τ, α with
          | [], [], [] =>
            ltac:(M.monadic
              (M.call_closure (|
                Ty.apply
                  (Ty.path "alloc::collections::btree::set::BTreeSet")
                  []
                  [ T; Ty.path "alloc::alloc::Global" ],
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "alloc::collections::btree::set::BTreeSet")
                    []
                    [ T; Ty.path "alloc::alloc::Global" ],
                  "new",
                  [],
                  []
                |),
                []
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Axiom Implements :
          forall (T : Ty.t),
          M.IsTraitInstance
            "core::default::Default"
            (* Trait polymorphic consts *) []
            (* Trait polymorphic types *) []
            (Self T)
            (* Instance *) [ ("default", InstanceField.Method (default T)) ].
      End Impl_core_default_Default_for_alloc_collections_btree_set_BTreeSet_T_alloc_alloc_Global.
      
      Module Impl_core_ops_arith_Sub_where_core_cmp_Ord_T_where_core_clone_Clone_T_where_core_alloc_Allocator_A_where_core_clone_Clone_A_ref__alloc_collections_btree_set_BTreeSet_T_A_for_ref__alloc_collections_btree_set_BTreeSet_T_A.
        Definition Self (T A : Ty.t) : Ty.t :=
          Ty.apply
            (Ty.path "&")
            []
            [ Ty.apply (Ty.path "alloc::collections::btree::set::BTreeSet") [] [ T; A ] ].
        
        (*     type Output = BTreeSet<T, A>; *)
        Definition _Output (T A : Ty.t) : Ty.t :=
          Ty.apply (Ty.path "alloc::collections::btree::set::BTreeSet") [] [ T; A ].
        
        (*
            fn sub(self, rhs: &BTreeSet<T, A>) -> BTreeSet<T, A> {
                BTreeSet::from_sorted_iter(
                    self.difference(rhs).cloned(),
                    ManuallyDrop::into_inner(self.map.alloc.clone()),
                )
            }
        *)
        Definition sub (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self T A in
          match ε, τ, α with
          | [], [], [ self; rhs ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let rhs := M.alloc (| rhs |) in
              M.call_closure (|
                Ty.apply (Ty.path "alloc::collections::btree::set::BTreeSet") [] [ T; A ],
                M.get_associated_function (|
                  Ty.apply (Ty.path "alloc::collections::btree::set::BTreeSet") [] [ T; A ],
                  "from_sorted_iter",
                  [],
                  [
                    Ty.apply
                      (Ty.path "core::iter::adapters::cloned::Cloned")
                      []
                      [ Ty.apply (Ty.path "alloc::collections::btree::set::Difference") [] [ T; A ]
                      ]
                  ]
                |),
                [
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "core::iter::adapters::cloned::Cloned")
                      []
                      [ Ty.apply (Ty.path "alloc::collections::btree::set::Difference") [] [ T; A ]
                      ],
                    M.get_trait_method (|
                      "core::iter::traits::iterator::Iterator",
                      Ty.apply (Ty.path "alloc::collections::btree::set::Difference") [] [ T; A ],
                      [],
                      [],
                      "cloned",
                      [],
                      [ T ]
                    |),
                    [
                      M.call_closure (|
                        Ty.apply (Ty.path "alloc::collections::btree::set::Difference") [] [ T; A ],
                        M.get_associated_function (|
                          Ty.apply (Ty.path "alloc::collections::btree::set::BTreeSet") [] [ T; A ],
                          "difference",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |);
                          M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| rhs |) |) |)
                        ]
                      |)
                    ]
                  |);
                  M.call_closure (|
                    A,
                    M.get_associated_function (|
                      Ty.apply (Ty.path "core::mem::manually_drop::ManuallyDrop") [] [ A ],
                      "into_inner",
                      [],
                      []
                    |),
                    [
                      M.call_closure (|
                        Ty.apply (Ty.path "core::mem::manually_drop::ManuallyDrop") [] [ A ],
                        M.get_trait_method (|
                          "core::clone::Clone",
                          Ty.apply (Ty.path "core::mem::manually_drop::ManuallyDrop") [] [ A ],
                          [],
                          [],
                          "clone",
                          [],
                          []
                        |),
                        [
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.SubPointer.get_struct_record_field (|
                              M.SubPointer.get_struct_record_field (|
                                M.deref (| M.read (| self |) |),
                                "alloc::collections::btree::set::BTreeSet",
                                "map"
                              |),
                              "alloc::collections::btree::map::BTreeMap",
                              "alloc"
                            |)
                          |)
                        ]
                      |)
                    ]
                  |)
                ]
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Axiom Implements :
          forall (T A : Ty.t),
          M.IsTraitInstance
            "core::ops::arith::Sub"
            (* Trait polymorphic consts *) []
            (* Trait polymorphic types *)
            [
              Ty.apply
                (Ty.path "&")
                []
                [ Ty.apply (Ty.path "alloc::collections::btree::set::BTreeSet") [] [ T; A ] ]
            ]
            (Self T A)
            (* Instance *)
            [ ("Output", InstanceField.Ty (_Output T A)); ("sub", InstanceField.Method (sub T A)) ].
      End Impl_core_ops_arith_Sub_where_core_cmp_Ord_T_where_core_clone_Clone_T_where_core_alloc_Allocator_A_where_core_clone_Clone_A_ref__alloc_collections_btree_set_BTreeSet_T_A_for_ref__alloc_collections_btree_set_BTreeSet_T_A.
      
      Module Impl_core_ops_bit_BitXor_where_core_cmp_Ord_T_where_core_clone_Clone_T_where_core_alloc_Allocator_A_where_core_clone_Clone_A_ref__alloc_collections_btree_set_BTreeSet_T_A_for_ref__alloc_collections_btree_set_BTreeSet_T_A.
        Definition Self (T A : Ty.t) : Ty.t :=
          Ty.apply
            (Ty.path "&")
            []
            [ Ty.apply (Ty.path "alloc::collections::btree::set::BTreeSet") [] [ T; A ] ].
        
        (*     type Output = BTreeSet<T, A>; *)
        Definition _Output (T A : Ty.t) : Ty.t :=
          Ty.apply (Ty.path "alloc::collections::btree::set::BTreeSet") [] [ T; A ].
        
        (*
            fn bitxor(self, rhs: &BTreeSet<T, A>) -> BTreeSet<T, A> {
                BTreeSet::from_sorted_iter(
                    self.symmetric_difference(rhs).cloned(),
                    ManuallyDrop::into_inner(self.map.alloc.clone()),
                )
            }
        *)
        Definition bitxor (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self T A in
          match ε, τ, α with
          | [], [], [ self; rhs ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let rhs := M.alloc (| rhs |) in
              M.call_closure (|
                Ty.apply (Ty.path "alloc::collections::btree::set::BTreeSet") [] [ T; A ],
                M.get_associated_function (|
                  Ty.apply (Ty.path "alloc::collections::btree::set::BTreeSet") [] [ T; A ],
                  "from_sorted_iter",
                  [],
                  [
                    Ty.apply
                      (Ty.path "core::iter::adapters::cloned::Cloned")
                      []
                      [
                        Ty.apply
                          (Ty.path "alloc::collections::btree::set::SymmetricDifference")
                          []
                          [ T ]
                      ]
                  ]
                |),
                [
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "core::iter::adapters::cloned::Cloned")
                      []
                      [
                        Ty.apply
                          (Ty.path "alloc::collections::btree::set::SymmetricDifference")
                          []
                          [ T ]
                      ],
                    M.get_trait_method (|
                      "core::iter::traits::iterator::Iterator",
                      Ty.apply
                        (Ty.path "alloc::collections::btree::set::SymmetricDifference")
                        []
                        [ T ],
                      [],
                      [],
                      "cloned",
                      [],
                      [ T ]
                    |),
                    [
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "alloc::collections::btree::set::SymmetricDifference")
                          []
                          [ T ],
                        M.get_associated_function (|
                          Ty.apply (Ty.path "alloc::collections::btree::set::BTreeSet") [] [ T; A ],
                          "symmetric_difference",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |);
                          M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| rhs |) |) |)
                        ]
                      |)
                    ]
                  |);
                  M.call_closure (|
                    A,
                    M.get_associated_function (|
                      Ty.apply (Ty.path "core::mem::manually_drop::ManuallyDrop") [] [ A ],
                      "into_inner",
                      [],
                      []
                    |),
                    [
                      M.call_closure (|
                        Ty.apply (Ty.path "core::mem::manually_drop::ManuallyDrop") [] [ A ],
                        M.get_trait_method (|
                          "core::clone::Clone",
                          Ty.apply (Ty.path "core::mem::manually_drop::ManuallyDrop") [] [ A ],
                          [],
                          [],
                          "clone",
                          [],
                          []
                        |),
                        [
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.SubPointer.get_struct_record_field (|
                              M.SubPointer.get_struct_record_field (|
                                M.deref (| M.read (| self |) |),
                                "alloc::collections::btree::set::BTreeSet",
                                "map"
                              |),
                              "alloc::collections::btree::map::BTreeMap",
                              "alloc"
                            |)
                          |)
                        ]
                      |)
                    ]
                  |)
                ]
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Axiom Implements :
          forall (T A : Ty.t),
          M.IsTraitInstance
            "core::ops::bit::BitXor"
            (* Trait polymorphic consts *) []
            (* Trait polymorphic types *)
            [
              Ty.apply
                (Ty.path "&")
                []
                [ Ty.apply (Ty.path "alloc::collections::btree::set::BTreeSet") [] [ T; A ] ]
            ]
            (Self T A)
            (* Instance *)
            [
              ("Output", InstanceField.Ty (_Output T A));
              ("bitxor", InstanceField.Method (bitxor T A))
            ].
      End Impl_core_ops_bit_BitXor_where_core_cmp_Ord_T_where_core_clone_Clone_T_where_core_alloc_Allocator_A_where_core_clone_Clone_A_ref__alloc_collections_btree_set_BTreeSet_T_A_for_ref__alloc_collections_btree_set_BTreeSet_T_A.
      
      Module Impl_core_ops_bit_BitAnd_where_core_cmp_Ord_T_where_core_clone_Clone_T_where_core_alloc_Allocator_A_where_core_clone_Clone_A_ref__alloc_collections_btree_set_BTreeSet_T_A_for_ref__alloc_collections_btree_set_BTreeSet_T_A.
        Definition Self (T A : Ty.t) : Ty.t :=
          Ty.apply
            (Ty.path "&")
            []
            [ Ty.apply (Ty.path "alloc::collections::btree::set::BTreeSet") [] [ T; A ] ].
        
        (*     type Output = BTreeSet<T, A>; *)
        Definition _Output (T A : Ty.t) : Ty.t :=
          Ty.apply (Ty.path "alloc::collections::btree::set::BTreeSet") [] [ T; A ].
        
        (*
            fn bitand(self, rhs: &BTreeSet<T, A>) -> BTreeSet<T, A> {
                BTreeSet::from_sorted_iter(
                    self.intersection(rhs).cloned(),
                    ManuallyDrop::into_inner(self.map.alloc.clone()),
                )
            }
        *)
        Definition bitand (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self T A in
          match ε, τ, α with
          | [], [], [ self; rhs ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let rhs := M.alloc (| rhs |) in
              M.call_closure (|
                Ty.apply (Ty.path "alloc::collections::btree::set::BTreeSet") [] [ T; A ],
                M.get_associated_function (|
                  Ty.apply (Ty.path "alloc::collections::btree::set::BTreeSet") [] [ T; A ],
                  "from_sorted_iter",
                  [],
                  [
                    Ty.apply
                      (Ty.path "core::iter::adapters::cloned::Cloned")
                      []
                      [
                        Ty.apply
                          (Ty.path "alloc::collections::btree::set::Intersection")
                          []
                          [ T; A ]
                      ]
                  ]
                |),
                [
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "core::iter::adapters::cloned::Cloned")
                      []
                      [
                        Ty.apply
                          (Ty.path "alloc::collections::btree::set::Intersection")
                          []
                          [ T; A ]
                      ],
                    M.get_trait_method (|
                      "core::iter::traits::iterator::Iterator",
                      Ty.apply (Ty.path "alloc::collections::btree::set::Intersection") [] [ T; A ],
                      [],
                      [],
                      "cloned",
                      [],
                      [ T ]
                    |),
                    [
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "alloc::collections::btree::set::Intersection")
                          []
                          [ T; A ],
                        M.get_associated_function (|
                          Ty.apply (Ty.path "alloc::collections::btree::set::BTreeSet") [] [ T; A ],
                          "intersection",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |);
                          M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| rhs |) |) |)
                        ]
                      |)
                    ]
                  |);
                  M.call_closure (|
                    A,
                    M.get_associated_function (|
                      Ty.apply (Ty.path "core::mem::manually_drop::ManuallyDrop") [] [ A ],
                      "into_inner",
                      [],
                      []
                    |),
                    [
                      M.call_closure (|
                        Ty.apply (Ty.path "core::mem::manually_drop::ManuallyDrop") [] [ A ],
                        M.get_trait_method (|
                          "core::clone::Clone",
                          Ty.apply (Ty.path "core::mem::manually_drop::ManuallyDrop") [] [ A ],
                          [],
                          [],
                          "clone",
                          [],
                          []
                        |),
                        [
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.SubPointer.get_struct_record_field (|
                              M.SubPointer.get_struct_record_field (|
                                M.deref (| M.read (| self |) |),
                                "alloc::collections::btree::set::BTreeSet",
                                "map"
                              |),
                              "alloc::collections::btree::map::BTreeMap",
                              "alloc"
                            |)
                          |)
                        ]
                      |)
                    ]
                  |)
                ]
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Axiom Implements :
          forall (T A : Ty.t),
          M.IsTraitInstance
            "core::ops::bit::BitAnd"
            (* Trait polymorphic consts *) []
            (* Trait polymorphic types *)
            [
              Ty.apply
                (Ty.path "&")
                []
                [ Ty.apply (Ty.path "alloc::collections::btree::set::BTreeSet") [] [ T; A ] ]
            ]
            (Self T A)
            (* Instance *)
            [
              ("Output", InstanceField.Ty (_Output T A));
              ("bitand", InstanceField.Method (bitand T A))
            ].
      End Impl_core_ops_bit_BitAnd_where_core_cmp_Ord_T_where_core_clone_Clone_T_where_core_alloc_Allocator_A_where_core_clone_Clone_A_ref__alloc_collections_btree_set_BTreeSet_T_A_for_ref__alloc_collections_btree_set_BTreeSet_T_A.
      
      Module Impl_core_ops_bit_BitOr_where_core_cmp_Ord_T_where_core_clone_Clone_T_where_core_alloc_Allocator_A_where_core_clone_Clone_A_ref__alloc_collections_btree_set_BTreeSet_T_A_for_ref__alloc_collections_btree_set_BTreeSet_T_A.
        Definition Self (T A : Ty.t) : Ty.t :=
          Ty.apply
            (Ty.path "&")
            []
            [ Ty.apply (Ty.path "alloc::collections::btree::set::BTreeSet") [] [ T; A ] ].
        
        (*     type Output = BTreeSet<T, A>; *)
        Definition _Output (T A : Ty.t) : Ty.t :=
          Ty.apply (Ty.path "alloc::collections::btree::set::BTreeSet") [] [ T; A ].
        
        (*
            fn bitor(self, rhs: &BTreeSet<T, A>) -> BTreeSet<T, A> {
                BTreeSet::from_sorted_iter(
                    self.union(rhs).cloned(),
                    ManuallyDrop::into_inner(self.map.alloc.clone()),
                )
            }
        *)
        Definition bitor (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self T A in
          match ε, τ, α with
          | [], [], [ self; rhs ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let rhs := M.alloc (| rhs |) in
              M.call_closure (|
                Ty.apply (Ty.path "alloc::collections::btree::set::BTreeSet") [] [ T; A ],
                M.get_associated_function (|
                  Ty.apply (Ty.path "alloc::collections::btree::set::BTreeSet") [] [ T; A ],
                  "from_sorted_iter",
                  [],
                  [
                    Ty.apply
                      (Ty.path "core::iter::adapters::cloned::Cloned")
                      []
                      [ Ty.apply (Ty.path "alloc::collections::btree::set::Union") [] [ T ] ]
                  ]
                |),
                [
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "core::iter::adapters::cloned::Cloned")
                      []
                      [ Ty.apply (Ty.path "alloc::collections::btree::set::Union") [] [ T ] ],
                    M.get_trait_method (|
                      "core::iter::traits::iterator::Iterator",
                      Ty.apply (Ty.path "alloc::collections::btree::set::Union") [] [ T ],
                      [],
                      [],
                      "cloned",
                      [],
                      [ T ]
                    |),
                    [
                      M.call_closure (|
                        Ty.apply (Ty.path "alloc::collections::btree::set::Union") [] [ T ],
                        M.get_associated_function (|
                          Ty.apply (Ty.path "alloc::collections::btree::set::BTreeSet") [] [ T; A ],
                          "union",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |);
                          M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| rhs |) |) |)
                        ]
                      |)
                    ]
                  |);
                  M.call_closure (|
                    A,
                    M.get_associated_function (|
                      Ty.apply (Ty.path "core::mem::manually_drop::ManuallyDrop") [] [ A ],
                      "into_inner",
                      [],
                      []
                    |),
                    [
                      M.call_closure (|
                        Ty.apply (Ty.path "core::mem::manually_drop::ManuallyDrop") [] [ A ],
                        M.get_trait_method (|
                          "core::clone::Clone",
                          Ty.apply (Ty.path "core::mem::manually_drop::ManuallyDrop") [] [ A ],
                          [],
                          [],
                          "clone",
                          [],
                          []
                        |),
                        [
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.SubPointer.get_struct_record_field (|
                              M.SubPointer.get_struct_record_field (|
                                M.deref (| M.read (| self |) |),
                                "alloc::collections::btree::set::BTreeSet",
                                "map"
                              |),
                              "alloc::collections::btree::map::BTreeMap",
                              "alloc"
                            |)
                          |)
                        ]
                      |)
                    ]
                  |)
                ]
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Axiom Implements :
          forall (T A : Ty.t),
          M.IsTraitInstance
            "core::ops::bit::BitOr"
            (* Trait polymorphic consts *) []
            (* Trait polymorphic types *)
            [
              Ty.apply
                (Ty.path "&")
                []
                [ Ty.apply (Ty.path "alloc::collections::btree::set::BTreeSet") [] [ T; A ] ]
            ]
            (Self T A)
            (* Instance *)
            [
              ("Output", InstanceField.Ty (_Output T A));
              ("bitor", InstanceField.Method (bitor T A))
            ].
      End Impl_core_ops_bit_BitOr_where_core_cmp_Ord_T_where_core_clone_Clone_T_where_core_alloc_Allocator_A_where_core_clone_Clone_A_ref__alloc_collections_btree_set_BTreeSet_T_A_for_ref__alloc_collections_btree_set_BTreeSet_T_A.
      
      Module Impl_core_fmt_Debug_where_core_fmt_Debug_T_where_core_alloc_Allocator_A_where_core_clone_Clone_A_for_alloc_collections_btree_set_BTreeSet_T_A.
        Definition Self (T A : Ty.t) : Ty.t :=
          Ty.apply (Ty.path "alloc::collections::btree::set::BTreeSet") [] [ T; A ].
        
        (*
            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                f.debug_set().entries(self.iter()).finish()
            }
        *)
        Definition fmt (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self T A in
          match ε, τ, α with
          | [], [], [ self; f ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let f := M.alloc (| f |) in
              M.call_closure (|
                Ty.apply
                  (Ty.path "core::result::Result")
                  []
                  [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                M.get_associated_function (|
                  Ty.path "core::fmt::builders::DebugSet",
                  "finish",
                  [],
                  []
                |),
                [
                  M.borrow (|
                    Pointer.Kind.MutRef,
                    M.deref (|
                      M.call_closure (|
                        Ty.apply (Ty.path "&mut") [] [ Ty.path "core::fmt::builders::DebugSet" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::builders::DebugSet",
                          "entries",
                          [],
                          [
                            Ty.apply (Ty.path "&") [] [ T ];
                            Ty.apply (Ty.path "alloc::collections::btree::set::Iter") [] [ T ]
                          ]
                        |),
                        [
                          M.borrow (|
                            Pointer.Kind.MutRef,
                            M.alloc (|
                              M.call_closure (|
                                Ty.path "core::fmt::builders::DebugSet",
                                M.get_associated_function (|
                                  Ty.path "core::fmt::Formatter",
                                  "debug_set",
                                  [],
                                  []
                                |),
                                [ M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |) ]
                              |)
                            |)
                          |);
                          M.call_closure (|
                            Ty.apply (Ty.path "alloc::collections::btree::set::Iter") [] [ T ],
                            M.get_associated_function (|
                              Ty.apply
                                (Ty.path "alloc::collections::btree::set::BTreeSet")
                                []
                                [ T; A ],
                              "iter",
                              [],
                              []
                            |),
                            [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                          |)
                        ]
                      |)
                    |)
                  |)
                ]
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Axiom Implements :
          forall (T A : Ty.t),
          M.IsTraitInstance
            "core::fmt::Debug"
            (* Trait polymorphic consts *) []
            (* Trait polymorphic types *) []
            (Self T A)
            (* Instance *) [ ("fmt", InstanceField.Method (fmt T A)) ].
      End Impl_core_fmt_Debug_where_core_fmt_Debug_T_where_core_alloc_Allocator_A_where_core_clone_Clone_A_for_alloc_collections_btree_set_BTreeSet_T_A.
      
      Module Impl_core_clone_Clone_for_alloc_collections_btree_set_Iter_T.
        Definition Self (T : Ty.t) : Ty.t :=
          Ty.apply (Ty.path "alloc::collections::btree::set::Iter") [] [ T ].
        
        (*
            fn clone(&self) -> Self {
                Iter { iter: self.iter.clone() }
            }
        *)
        Definition clone (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self T in
          match ε, τ, α with
          | [], [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              Value.StructRecord
                "alloc::collections::btree::set::Iter"
                [
                  ("iter",
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "alloc::collections::btree::map::Keys")
                        []
                        [ T; Ty.path "alloc::collections::btree::set_val::SetValZST" ],
                      M.get_trait_method (|
                        "core::clone::Clone",
                        Ty.apply
                          (Ty.path "alloc::collections::btree::map::Keys")
                          []
                          [ T; Ty.path "alloc::collections::btree::set_val::SetValZST" ],
                        [],
                        [],
                        "clone",
                        [],
                        []
                      |),
                      [
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "alloc::collections::btree::set::Iter",
                            "iter"
                          |)
                        |)
                      ]
                    |))
                ]))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Axiom Implements :
          forall (T : Ty.t),
          M.IsTraitInstance
            "core::clone::Clone"
            (* Trait polymorphic consts *) []
            (* Trait polymorphic types *) []
            (Self T)
            (* Instance *) [ ("clone", InstanceField.Method (clone T)) ].
      End Impl_core_clone_Clone_for_alloc_collections_btree_set_Iter_T.
      
      Module Impl_core_iter_traits_iterator_Iterator_for_alloc_collections_btree_set_Iter_T.
        Definition Self (T : Ty.t) : Ty.t :=
          Ty.apply (Ty.path "alloc::collections::btree::set::Iter") [] [ T ].
        
        (*     type Item = &'a T; *)
        Definition _Item (T : Ty.t) : Ty.t := Ty.apply (Ty.path "&") [] [ T ].
        
        (*
            fn next(&mut self) -> Option<&'a T> {
                self.iter.next()
            }
        *)
        Definition next (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self T in
          match ε, τ, α with
          | [], [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              M.call_closure (|
                Ty.apply (Ty.path "core::option::Option") [] [ Ty.apply (Ty.path "&") [] [ T ] ],
                M.get_trait_method (|
                  "core::iter::traits::iterator::Iterator",
                  Ty.apply
                    (Ty.path "alloc::collections::btree::map::Keys")
                    []
                    [ T; Ty.path "alloc::collections::btree::set_val::SetValZST" ],
                  [],
                  [],
                  "next",
                  [],
                  []
                |),
                [
                  M.borrow (|
                    Pointer.Kind.MutRef,
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| self |) |),
                      "alloc::collections::btree::set::Iter",
                      "iter"
                    |)
                  |)
                ]
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        (*
            fn size_hint(&self) -> (usize, Option<usize>) {
                self.iter.size_hint()
            }
        *)
        Definition size_hint (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self T in
          match ε, τ, α with
          | [], [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              M.call_closure (|
                Ty.tuple
                  [
                    Ty.path "usize";
                    Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "usize" ]
                  ],
                M.get_trait_method (|
                  "core::iter::traits::iterator::Iterator",
                  Ty.apply
                    (Ty.path "alloc::collections::btree::map::Keys")
                    []
                    [ T; Ty.path "alloc::collections::btree::set_val::SetValZST" ],
                  [],
                  [],
                  "size_hint",
                  [],
                  []
                |),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| self |) |),
                      "alloc::collections::btree::set::Iter",
                      "iter"
                    |)
                  |)
                ]
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        (*
            fn last(mut self) -> Option<&'a T> {
                self.next_back()
            }
        *)
        Definition last (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self T in
          match ε, τ, α with
          | [], [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              M.call_closure (|
                Ty.apply (Ty.path "core::option::Option") [] [ Ty.apply (Ty.path "&") [] [ T ] ],
                M.get_trait_method (|
                  "core::iter::traits::double_ended::DoubleEndedIterator",
                  Ty.apply (Ty.path "alloc::collections::btree::set::Iter") [] [ T ],
                  [],
                  [],
                  "next_back",
                  [],
                  []
                |),
                [ M.borrow (| Pointer.Kind.MutRef, self |) ]
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        (*
            fn min(mut self) -> Option<&'a T>
            where
                &'a T: Ord,
            {
                self.next()
            }
        *)
        Definition min (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self T in
          match ε, τ, α with
          | [], [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              M.call_closure (|
                Ty.apply (Ty.path "core::option::Option") [] [ Ty.apply (Ty.path "&") [] [ T ] ],
                M.get_trait_method (|
                  "core::iter::traits::iterator::Iterator",
                  Ty.apply (Ty.path "alloc::collections::btree::set::Iter") [] [ T ],
                  [],
                  [],
                  "next",
                  [],
                  []
                |),
                [ M.borrow (| Pointer.Kind.MutRef, self |) ]
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        (*
            fn max(mut self) -> Option<&'a T>
            where
                &'a T: Ord,
            {
                self.next_back()
            }
        *)
        Definition max (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self T in
          match ε, τ, α with
          | [], [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              M.call_closure (|
                Ty.apply (Ty.path "core::option::Option") [] [ Ty.apply (Ty.path "&") [] [ T ] ],
                M.get_trait_method (|
                  "core::iter::traits::double_ended::DoubleEndedIterator",
                  Ty.apply (Ty.path "alloc::collections::btree::set::Iter") [] [ T ],
                  [],
                  [],
                  "next_back",
                  [],
                  []
                |),
                [ M.borrow (| Pointer.Kind.MutRef, self |) ]
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Axiom Implements :
          forall (T : Ty.t),
          M.IsTraitInstance
            "core::iter::traits::iterator::Iterator"
            (* Trait polymorphic consts *) []
            (* Trait polymorphic types *) []
            (Self T)
            (* Instance *)
            [
              ("Item", InstanceField.Ty (_Item T));
              ("next", InstanceField.Method (next T));
              ("size_hint", InstanceField.Method (size_hint T));
              ("last", InstanceField.Method (last T));
              ("min", InstanceField.Method (min T));
              ("max", InstanceField.Method (max T))
            ].
      End Impl_core_iter_traits_iterator_Iterator_for_alloc_collections_btree_set_Iter_T.
      
      Module Impl_core_iter_traits_double_ended_DoubleEndedIterator_for_alloc_collections_btree_set_Iter_T.
        Definition Self (T : Ty.t) : Ty.t :=
          Ty.apply (Ty.path "alloc::collections::btree::set::Iter") [] [ T ].
        
        (*
            fn next_back(&mut self) -> Option<&'a T> {
                self.iter.next_back()
            }
        *)
        Definition next_back (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self T in
          match ε, τ, α with
          | [], [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              M.call_closure (|
                Ty.apply (Ty.path "core::option::Option") [] [ Ty.apply (Ty.path "&") [] [ T ] ],
                M.get_trait_method (|
                  "core::iter::traits::double_ended::DoubleEndedIterator",
                  Ty.apply
                    (Ty.path "alloc::collections::btree::map::Keys")
                    []
                    [ T; Ty.path "alloc::collections::btree::set_val::SetValZST" ],
                  [],
                  [],
                  "next_back",
                  [],
                  []
                |),
                [
                  M.borrow (|
                    Pointer.Kind.MutRef,
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| self |) |),
                      "alloc::collections::btree::set::Iter",
                      "iter"
                    |)
                  |)
                ]
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Axiom Implements :
          forall (T : Ty.t),
          M.IsTraitInstance
            "core::iter::traits::double_ended::DoubleEndedIterator"
            (* Trait polymorphic consts *) []
            (* Trait polymorphic types *) []
            (Self T)
            (* Instance *) [ ("next_back", InstanceField.Method (next_back T)) ].
      End Impl_core_iter_traits_double_ended_DoubleEndedIterator_for_alloc_collections_btree_set_Iter_T.
      
      Module Impl_core_iter_traits_exact_size_ExactSizeIterator_for_alloc_collections_btree_set_Iter_T.
        Definition Self (T : Ty.t) : Ty.t :=
          Ty.apply (Ty.path "alloc::collections::btree::set::Iter") [] [ T ].
        
        (*
            fn len(&self) -> usize {
                self.iter.len()
            }
        *)
        Definition len (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self T in
          match ε, τ, α with
          | [], [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              M.call_closure (|
                Ty.path "usize",
                M.get_trait_method (|
                  "core::iter::traits::exact_size::ExactSizeIterator",
                  Ty.apply
                    (Ty.path "alloc::collections::btree::map::Keys")
                    []
                    [ T; Ty.path "alloc::collections::btree::set_val::SetValZST" ],
                  [],
                  [],
                  "len",
                  [],
                  []
                |),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| self |) |),
                      "alloc::collections::btree::set::Iter",
                      "iter"
                    |)
                  |)
                ]
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Axiom Implements :
          forall (T : Ty.t),
          M.IsTraitInstance
            "core::iter::traits::exact_size::ExactSizeIterator"
            (* Trait polymorphic consts *) []
            (* Trait polymorphic types *) []
            (Self T)
            (* Instance *) [ ("len", InstanceField.Method (len T)) ].
      End Impl_core_iter_traits_exact_size_ExactSizeIterator_for_alloc_collections_btree_set_Iter_T.
      
      Module Impl_core_iter_traits_marker_FusedIterator_for_alloc_collections_btree_set_Iter_T.
        Definition Self (T : Ty.t) : Ty.t :=
          Ty.apply (Ty.path "alloc::collections::btree::set::Iter") [] [ T ].
        
        Axiom Implements :
          forall (T : Ty.t),
          M.IsTraitInstance
            "core::iter::traits::marker::FusedIterator"
            (* Trait polymorphic consts *) []
            (* Trait polymorphic types *) []
            (Self T)
            (* Instance *) [].
      End Impl_core_iter_traits_marker_FusedIterator_for_alloc_collections_btree_set_Iter_T.
      
      Module Impl_core_iter_traits_iterator_Iterator_where_core_alloc_Allocator_A_where_core_clone_Clone_A_for_alloc_collections_btree_set_IntoIter_T_A.
        Definition Self (T A : Ty.t) : Ty.t :=
          Ty.apply (Ty.path "alloc::collections::btree::set::IntoIter") [] [ T; A ].
        
        (*     type Item = T; *)
        Definition _Item (T A : Ty.t) : Ty.t := T.
        
        (*
            fn next(&mut self) -> Option<T> {
                self.iter.next().map(|(k, _)| k)
            }
        *)
        Definition next (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self T A in
          match ε, τ, α with
          | [], [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              M.call_closure (|
                Ty.apply (Ty.path "core::option::Option") [] [ T ],
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "core::option::Option")
                    []
                    [ Ty.tuple [ T; Ty.path "alloc::collections::btree::set_val::SetValZST" ] ],
                  "map",
                  [],
                  [
                    T;
                    Ty.function
                      [
                        Ty.tuple
                          [ Ty.tuple [ T; Ty.path "alloc::collections::btree::set_val::SetValZST" ]
                          ]
                      ]
                      T
                  ]
                |),
                [
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "core::option::Option")
                      []
                      [ Ty.tuple [ T; Ty.path "alloc::collections::btree::set_val::SetValZST" ] ],
                    M.get_trait_method (|
                      "core::iter::traits::iterator::Iterator",
                      Ty.apply
                        (Ty.path "alloc::collections::btree::map::IntoIter")
                        []
                        [ T; Ty.path "alloc::collections::btree::set_val::SetValZST"; A ],
                      [],
                      [],
                      "next",
                      [],
                      []
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.MutRef,
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "alloc::collections::btree::set::IntoIter",
                          "iter"
                        |)
                      |)
                    ]
                  |);
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0 ] =>
                          ltac:(M.monadic
                            (M.match_operator (|
                              Some
                                (Ty.function
                                  [
                                    Ty.tuple
                                      [
                                        Ty.tuple
                                          [
                                            T;
                                            Ty.path "alloc::collections::btree::set_val::SetValZST"
                                          ]
                                      ]
                                  ]
                                  T),
                              M.alloc (| α0 |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                    let k := M.copy (| γ0_0 |) in
                                    M.read (| k |)))
                              ]
                            |)))
                        | _ => M.impossible "wrong number of arguments"
                        end))
                ]
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        (*
            fn size_hint(&self) -> (usize, Option<usize>) {
                self.iter.size_hint()
            }
        *)
        Definition size_hint
            (T A : Ty.t)
            (ε : list Value.t)
            (τ : list Ty.t)
            (α : list Value.t)
            : M :=
          let Self : Ty.t := Self T A in
          match ε, τ, α with
          | [], [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              M.call_closure (|
                Ty.tuple
                  [
                    Ty.path "usize";
                    Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "usize" ]
                  ],
                M.get_trait_method (|
                  "core::iter::traits::iterator::Iterator",
                  Ty.apply
                    (Ty.path "alloc::collections::btree::map::IntoIter")
                    []
                    [ T; Ty.path "alloc::collections::btree::set_val::SetValZST"; A ],
                  [],
                  [],
                  "size_hint",
                  [],
                  []
                |),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| self |) |),
                      "alloc::collections::btree::set::IntoIter",
                      "iter"
                    |)
                  |)
                ]
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Axiom Implements :
          forall (T A : Ty.t),
          M.IsTraitInstance
            "core::iter::traits::iterator::Iterator"
            (* Trait polymorphic consts *) []
            (* Trait polymorphic types *) []
            (Self T A)
            (* Instance *)
            [
              ("Item", InstanceField.Ty (_Item T A));
              ("next", InstanceField.Method (next T A));
              ("size_hint", InstanceField.Method (size_hint T A))
            ].
      End Impl_core_iter_traits_iterator_Iterator_where_core_alloc_Allocator_A_where_core_clone_Clone_A_for_alloc_collections_btree_set_IntoIter_T_A.
      
      Module Impl_core_default_Default_for_alloc_collections_btree_set_Iter_T.
        Definition Self (T : Ty.t) : Ty.t :=
          Ty.apply (Ty.path "alloc::collections::btree::set::Iter") [] [ T ].
        
        (*
            fn default() -> Self {
                Iter { iter: Default::default() }
            }
        *)
        Definition default (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self T in
          match ε, τ, α with
          | [], [], [] =>
            ltac:(M.monadic
              (Value.StructRecord
                "alloc::collections::btree::set::Iter"
                [
                  ("iter",
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "alloc::collections::btree::map::Keys")
                        []
                        [ T; Ty.path "alloc::collections::btree::set_val::SetValZST" ],
                      M.get_trait_method (|
                        "core::default::Default",
                        Ty.apply
                          (Ty.path "alloc::collections::btree::map::Keys")
                          []
                          [ T; Ty.path "alloc::collections::btree::set_val::SetValZST" ],
                        [],
                        [],
                        "default",
                        [],
                        []
                      |),
                      []
                    |))
                ]))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Axiom Implements :
          forall (T : Ty.t),
          M.IsTraitInstance
            "core::default::Default"
            (* Trait polymorphic consts *) []
            (* Trait polymorphic types *) []
            (Self T)
            (* Instance *) [ ("default", InstanceField.Method (default T)) ].
      End Impl_core_default_Default_for_alloc_collections_btree_set_Iter_T.
      
      Module Impl_core_iter_traits_double_ended_DoubleEndedIterator_where_core_alloc_Allocator_A_where_core_clone_Clone_A_for_alloc_collections_btree_set_IntoIter_T_A.
        Definition Self (T A : Ty.t) : Ty.t :=
          Ty.apply (Ty.path "alloc::collections::btree::set::IntoIter") [] [ T; A ].
        
        (*
            fn next_back(&mut self) -> Option<T> {
                self.iter.next_back().map(|(k, _)| k)
            }
        *)
        Definition next_back
            (T A : Ty.t)
            (ε : list Value.t)
            (τ : list Ty.t)
            (α : list Value.t)
            : M :=
          let Self : Ty.t := Self T A in
          match ε, τ, α with
          | [], [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              M.call_closure (|
                Ty.apply (Ty.path "core::option::Option") [] [ T ],
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "core::option::Option")
                    []
                    [ Ty.tuple [ T; Ty.path "alloc::collections::btree::set_val::SetValZST" ] ],
                  "map",
                  [],
                  [
                    T;
                    Ty.function
                      [
                        Ty.tuple
                          [ Ty.tuple [ T; Ty.path "alloc::collections::btree::set_val::SetValZST" ]
                          ]
                      ]
                      T
                  ]
                |),
                [
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "core::option::Option")
                      []
                      [ Ty.tuple [ T; Ty.path "alloc::collections::btree::set_val::SetValZST" ] ],
                    M.get_trait_method (|
                      "core::iter::traits::double_ended::DoubleEndedIterator",
                      Ty.apply
                        (Ty.path "alloc::collections::btree::map::IntoIter")
                        []
                        [ T; Ty.path "alloc::collections::btree::set_val::SetValZST"; A ],
                      [],
                      [],
                      "next_back",
                      [],
                      []
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.MutRef,
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "alloc::collections::btree::set::IntoIter",
                          "iter"
                        |)
                      |)
                    ]
                  |);
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0 ] =>
                          ltac:(M.monadic
                            (M.match_operator (|
                              Some
                                (Ty.function
                                  [
                                    Ty.tuple
                                      [
                                        Ty.tuple
                                          [
                                            T;
                                            Ty.path "alloc::collections::btree::set_val::SetValZST"
                                          ]
                                      ]
                                  ]
                                  T),
                              M.alloc (| α0 |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                    let k := M.copy (| γ0_0 |) in
                                    M.read (| k |)))
                              ]
                            |)))
                        | _ => M.impossible "wrong number of arguments"
                        end))
                ]
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Axiom Implements :
          forall (T A : Ty.t),
          M.IsTraitInstance
            "core::iter::traits::double_ended::DoubleEndedIterator"
            (* Trait polymorphic consts *) []
            (* Trait polymorphic types *) []
            (Self T A)
            (* Instance *) [ ("next_back", InstanceField.Method (next_back T A)) ].
      End Impl_core_iter_traits_double_ended_DoubleEndedIterator_where_core_alloc_Allocator_A_where_core_clone_Clone_A_for_alloc_collections_btree_set_IntoIter_T_A.
      
      Module Impl_core_iter_traits_exact_size_ExactSizeIterator_where_core_alloc_Allocator_A_where_core_clone_Clone_A_for_alloc_collections_btree_set_IntoIter_T_A.
        Definition Self (T A : Ty.t) : Ty.t :=
          Ty.apply (Ty.path "alloc::collections::btree::set::IntoIter") [] [ T; A ].
        
        (*
            fn len(&self) -> usize {
                self.iter.len()
            }
        *)
        Definition len (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self T A in
          match ε, τ, α with
          | [], [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              M.call_closure (|
                Ty.path "usize",
                M.get_trait_method (|
                  "core::iter::traits::exact_size::ExactSizeIterator",
                  Ty.apply
                    (Ty.path "alloc::collections::btree::map::IntoIter")
                    []
                    [ T; Ty.path "alloc::collections::btree::set_val::SetValZST"; A ],
                  [],
                  [],
                  "len",
                  [],
                  []
                |),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| self |) |),
                      "alloc::collections::btree::set::IntoIter",
                      "iter"
                    |)
                  |)
                ]
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Axiom Implements :
          forall (T A : Ty.t),
          M.IsTraitInstance
            "core::iter::traits::exact_size::ExactSizeIterator"
            (* Trait polymorphic consts *) []
            (* Trait polymorphic types *) []
            (Self T A)
            (* Instance *) [ ("len", InstanceField.Method (len T A)) ].
      End Impl_core_iter_traits_exact_size_ExactSizeIterator_where_core_alloc_Allocator_A_where_core_clone_Clone_A_for_alloc_collections_btree_set_IntoIter_T_A.
      
      Module Impl_core_iter_traits_marker_FusedIterator_where_core_alloc_Allocator_A_where_core_clone_Clone_A_for_alloc_collections_btree_set_IntoIter_T_A.
        Definition Self (T A : Ty.t) : Ty.t :=
          Ty.apply (Ty.path "alloc::collections::btree::set::IntoIter") [] [ T; A ].
        
        Axiom Implements :
          forall (T A : Ty.t),
          M.IsTraitInstance
            "core::iter::traits::marker::FusedIterator"
            (* Trait polymorphic consts *) []
            (* Trait polymorphic types *) []
            (Self T A)
            (* Instance *) [].
      End Impl_core_iter_traits_marker_FusedIterator_where_core_alloc_Allocator_A_where_core_clone_Clone_A_for_alloc_collections_btree_set_IntoIter_T_A.
      
      Module Impl_core_default_Default_where_core_alloc_Allocator_A_where_core_default_Default_A_where_core_clone_Clone_A_for_alloc_collections_btree_set_IntoIter_T_A.
        Definition Self (T A : Ty.t) : Ty.t :=
          Ty.apply (Ty.path "alloc::collections::btree::set::IntoIter") [] [ T; A ].
        
        (*
            fn default() -> Self {
                IntoIter { iter: Default::default() }
            }
        *)
        Definition default (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self T A in
          match ε, τ, α with
          | [], [], [] =>
            ltac:(M.monadic
              (Value.StructRecord
                "alloc::collections::btree::set::IntoIter"
                [
                  ("iter",
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "alloc::collections::btree::map::IntoIter")
                        []
                        [ T; Ty.path "alloc::collections::btree::set_val::SetValZST"; A ],
                      M.get_trait_method (|
                        "core::default::Default",
                        Ty.apply
                          (Ty.path "alloc::collections::btree::map::IntoIter")
                          []
                          [ T; Ty.path "alloc::collections::btree::set_val::SetValZST"; A ],
                        [],
                        [],
                        "default",
                        [],
                        []
                      |),
                      []
                    |))
                ]))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Axiom Implements :
          forall (T A : Ty.t),
          M.IsTraitInstance
            "core::default::Default"
            (* Trait polymorphic consts *) []
            (* Trait polymorphic types *) []
            (Self T A)
            (* Instance *) [ ("default", InstanceField.Method (default T A)) ].
      End Impl_core_default_Default_where_core_alloc_Allocator_A_where_core_default_Default_A_where_core_clone_Clone_A_for_alloc_collections_btree_set_IntoIter_T_A.
      
      Module Impl_core_clone_Clone_for_alloc_collections_btree_set_Range_T.
        Definition Self (T : Ty.t) : Ty.t :=
          Ty.apply (Ty.path "alloc::collections::btree::set::Range") [] [ T ].
        
        (*
            fn clone(&self) -> Self {
                Range { iter: self.iter.clone() }
            }
        *)
        Definition clone (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self T in
          match ε, τ, α with
          | [], [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              Value.StructRecord
                "alloc::collections::btree::set::Range"
                [
                  ("iter",
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "alloc::collections::btree::map::Range")
                        []
                        [ T; Ty.path "alloc::collections::btree::set_val::SetValZST" ],
                      M.get_trait_method (|
                        "core::clone::Clone",
                        Ty.apply
                          (Ty.path "alloc::collections::btree::map::Range")
                          []
                          [ T; Ty.path "alloc::collections::btree::set_val::SetValZST" ],
                        [],
                        [],
                        "clone",
                        [],
                        []
                      |),
                      [
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "alloc::collections::btree::set::Range",
                            "iter"
                          |)
                        |)
                      ]
                    |))
                ]))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Axiom Implements :
          forall (T : Ty.t),
          M.IsTraitInstance
            "core::clone::Clone"
            (* Trait polymorphic consts *) []
            (* Trait polymorphic types *) []
            (Self T)
            (* Instance *) [ ("clone", InstanceField.Method (clone T)) ].
      End Impl_core_clone_Clone_for_alloc_collections_btree_set_Range_T.
      
      Module Impl_core_iter_traits_iterator_Iterator_for_alloc_collections_btree_set_Range_T.
        Definition Self (T : Ty.t) : Ty.t :=
          Ty.apply (Ty.path "alloc::collections::btree::set::Range") [] [ T ].
        
        (*     type Item = &'a T; *)
        Definition _Item (T : Ty.t) : Ty.t := Ty.apply (Ty.path "&") [] [ T ].
        
        (*
            fn next(&mut self) -> Option<&'a T> {
                self.iter.next().map(|(k, _)| k)
            }
        *)
        Definition next (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self T in
          match ε, τ, α with
          | [], [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              M.call_closure (|
                Ty.apply (Ty.path "core::option::Option") [] [ Ty.apply (Ty.path "&") [] [ T ] ],
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "core::option::Option")
                    []
                    [
                      Ty.tuple
                        [
                          Ty.apply (Ty.path "&") [] [ T ];
                          Ty.apply
                            (Ty.path "&")
                            []
                            [ Ty.path "alloc::collections::btree::set_val::SetValZST" ]
                        ]
                    ],
                  "map",
                  [],
                  [
                    Ty.apply (Ty.path "&") [] [ T ];
                    Ty.function
                      [
                        Ty.tuple
                          [
                            Ty.tuple
                              [
                                Ty.apply (Ty.path "&") [] [ T ];
                                Ty.apply
                                  (Ty.path "&")
                                  []
                                  [ Ty.path "alloc::collections::btree::set_val::SetValZST" ]
                              ]
                          ]
                      ]
                      (Ty.apply (Ty.path "&") [] [ T ])
                  ]
                |),
                [
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "core::option::Option")
                      []
                      [
                        Ty.tuple
                          [
                            Ty.apply (Ty.path "&") [] [ T ];
                            Ty.apply
                              (Ty.path "&")
                              []
                              [ Ty.path "alloc::collections::btree::set_val::SetValZST" ]
                          ]
                      ],
                    M.get_trait_method (|
                      "core::iter::traits::iterator::Iterator",
                      Ty.apply
                        (Ty.path "alloc::collections::btree::map::Range")
                        []
                        [ T; Ty.path "alloc::collections::btree::set_val::SetValZST" ],
                      [],
                      [],
                      "next",
                      [],
                      []
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.MutRef,
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "alloc::collections::btree::set::Range",
                          "iter"
                        |)
                      |)
                    ]
                  |);
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0 ] =>
                          ltac:(M.monadic
                            (M.match_operator (|
                              Some
                                (Ty.function
                                  [
                                    Ty.tuple
                                      [
                                        Ty.tuple
                                          [
                                            Ty.apply (Ty.path "&") [] [ T ];
                                            Ty.apply
                                              (Ty.path "&")
                                              []
                                              [
                                                Ty.path
                                                  "alloc::collections::btree::set_val::SetValZST"
                                              ]
                                          ]
                                      ]
                                  ]
                                  (Ty.apply (Ty.path "&") [] [ T ])),
                              M.alloc (| α0 |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                    let k := M.copy (| γ0_0 |) in
                                    M.read (| k |)))
                              ]
                            |)))
                        | _ => M.impossible "wrong number of arguments"
                        end))
                ]
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        (*
            fn last(mut self) -> Option<&'a T> {
                self.next_back()
            }
        *)
        Definition last (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self T in
          match ε, τ, α with
          | [], [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              M.call_closure (|
                Ty.apply (Ty.path "core::option::Option") [] [ Ty.apply (Ty.path "&") [] [ T ] ],
                M.get_trait_method (|
                  "core::iter::traits::double_ended::DoubleEndedIterator",
                  Ty.apply (Ty.path "alloc::collections::btree::set::Range") [] [ T ],
                  [],
                  [],
                  "next_back",
                  [],
                  []
                |),
                [ M.borrow (| Pointer.Kind.MutRef, self |) ]
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        (*
            fn min(mut self) -> Option<&'a T>
            where
                &'a T: Ord,
            {
                self.next()
            }
        *)
        Definition min (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self T in
          match ε, τ, α with
          | [], [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              M.call_closure (|
                Ty.apply (Ty.path "core::option::Option") [] [ Ty.apply (Ty.path "&") [] [ T ] ],
                M.get_trait_method (|
                  "core::iter::traits::iterator::Iterator",
                  Ty.apply (Ty.path "alloc::collections::btree::set::Range") [] [ T ],
                  [],
                  [],
                  "next",
                  [],
                  []
                |),
                [ M.borrow (| Pointer.Kind.MutRef, self |) ]
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        (*
            fn max(mut self) -> Option<&'a T>
            where
                &'a T: Ord,
            {
                self.next_back()
            }
        *)
        Definition max (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self T in
          match ε, τ, α with
          | [], [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              M.call_closure (|
                Ty.apply (Ty.path "core::option::Option") [] [ Ty.apply (Ty.path "&") [] [ T ] ],
                M.get_trait_method (|
                  "core::iter::traits::double_ended::DoubleEndedIterator",
                  Ty.apply (Ty.path "alloc::collections::btree::set::Range") [] [ T ],
                  [],
                  [],
                  "next_back",
                  [],
                  []
                |),
                [ M.borrow (| Pointer.Kind.MutRef, self |) ]
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Axiom Implements :
          forall (T : Ty.t),
          M.IsTraitInstance
            "core::iter::traits::iterator::Iterator"
            (* Trait polymorphic consts *) []
            (* Trait polymorphic types *) []
            (Self T)
            (* Instance *)
            [
              ("Item", InstanceField.Ty (_Item T));
              ("next", InstanceField.Method (next T));
              ("last", InstanceField.Method (last T));
              ("min", InstanceField.Method (min T));
              ("max", InstanceField.Method (max T))
            ].
      End Impl_core_iter_traits_iterator_Iterator_for_alloc_collections_btree_set_Range_T.
      
      Module Impl_core_iter_traits_double_ended_DoubleEndedIterator_for_alloc_collections_btree_set_Range_T.
        Definition Self (T : Ty.t) : Ty.t :=
          Ty.apply (Ty.path "alloc::collections::btree::set::Range") [] [ T ].
        
        (*
            fn next_back(&mut self) -> Option<&'a T> {
                self.iter.next_back().map(|(k, _)| k)
            }
        *)
        Definition next_back (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self T in
          match ε, τ, α with
          | [], [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              M.call_closure (|
                Ty.apply (Ty.path "core::option::Option") [] [ Ty.apply (Ty.path "&") [] [ T ] ],
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "core::option::Option")
                    []
                    [
                      Ty.tuple
                        [
                          Ty.apply (Ty.path "&") [] [ T ];
                          Ty.apply
                            (Ty.path "&")
                            []
                            [ Ty.path "alloc::collections::btree::set_val::SetValZST" ]
                        ]
                    ],
                  "map",
                  [],
                  [
                    Ty.apply (Ty.path "&") [] [ T ];
                    Ty.function
                      [
                        Ty.tuple
                          [
                            Ty.tuple
                              [
                                Ty.apply (Ty.path "&") [] [ T ];
                                Ty.apply
                                  (Ty.path "&")
                                  []
                                  [ Ty.path "alloc::collections::btree::set_val::SetValZST" ]
                              ]
                          ]
                      ]
                      (Ty.apply (Ty.path "&") [] [ T ])
                  ]
                |),
                [
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "core::option::Option")
                      []
                      [
                        Ty.tuple
                          [
                            Ty.apply (Ty.path "&") [] [ T ];
                            Ty.apply
                              (Ty.path "&")
                              []
                              [ Ty.path "alloc::collections::btree::set_val::SetValZST" ]
                          ]
                      ],
                    M.get_trait_method (|
                      "core::iter::traits::double_ended::DoubleEndedIterator",
                      Ty.apply
                        (Ty.path "alloc::collections::btree::map::Range")
                        []
                        [ T; Ty.path "alloc::collections::btree::set_val::SetValZST" ],
                      [],
                      [],
                      "next_back",
                      [],
                      []
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.MutRef,
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "alloc::collections::btree::set::Range",
                          "iter"
                        |)
                      |)
                    ]
                  |);
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0 ] =>
                          ltac:(M.monadic
                            (M.match_operator (|
                              Some
                                (Ty.function
                                  [
                                    Ty.tuple
                                      [
                                        Ty.tuple
                                          [
                                            Ty.apply (Ty.path "&") [] [ T ];
                                            Ty.apply
                                              (Ty.path "&")
                                              []
                                              [
                                                Ty.path
                                                  "alloc::collections::btree::set_val::SetValZST"
                                              ]
                                          ]
                                      ]
                                  ]
                                  (Ty.apply (Ty.path "&") [] [ T ])),
                              M.alloc (| α0 |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                    let k := M.copy (| γ0_0 |) in
                                    M.read (| k |)))
                              ]
                            |)))
                        | _ => M.impossible "wrong number of arguments"
                        end))
                ]
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Axiom Implements :
          forall (T : Ty.t),
          M.IsTraitInstance
            "core::iter::traits::double_ended::DoubleEndedIterator"
            (* Trait polymorphic consts *) []
            (* Trait polymorphic types *) []
            (Self T)
            (* Instance *) [ ("next_back", InstanceField.Method (next_back T)) ].
      End Impl_core_iter_traits_double_ended_DoubleEndedIterator_for_alloc_collections_btree_set_Range_T.
      
      Module Impl_core_iter_traits_marker_FusedIterator_for_alloc_collections_btree_set_Range_T.
        Definition Self (T : Ty.t) : Ty.t :=
          Ty.apply (Ty.path "alloc::collections::btree::set::Range") [] [ T ].
        
        Axiom Implements :
          forall (T : Ty.t),
          M.IsTraitInstance
            "core::iter::traits::marker::FusedIterator"
            (* Trait polymorphic consts *) []
            (* Trait polymorphic types *) []
            (Self T)
            (* Instance *) [].
      End Impl_core_iter_traits_marker_FusedIterator_for_alloc_collections_btree_set_Range_T.
      
      Module Impl_core_default_Default_for_alloc_collections_btree_set_Range_T.
        Definition Self (T : Ty.t) : Ty.t :=
          Ty.apply (Ty.path "alloc::collections::btree::set::Range") [] [ T ].
        
        (*
            fn default() -> Self {
                Range { iter: Default::default() }
            }
        *)
        Definition default (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self T in
          match ε, τ, α with
          | [], [], [] =>
            ltac:(M.monadic
              (Value.StructRecord
                "alloc::collections::btree::set::Range"
                [
                  ("iter",
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "alloc::collections::btree::map::Range")
                        []
                        [ T; Ty.path "alloc::collections::btree::set_val::SetValZST" ],
                      M.get_trait_method (|
                        "core::default::Default",
                        Ty.apply
                          (Ty.path "alloc::collections::btree::map::Range")
                          []
                          [ T; Ty.path "alloc::collections::btree::set_val::SetValZST" ],
                        [],
                        [],
                        "default",
                        [],
                        []
                      |),
                      []
                    |))
                ]))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Axiom Implements :
          forall (T : Ty.t),
          M.IsTraitInstance
            "core::default::Default"
            (* Trait polymorphic consts *) []
            (* Trait polymorphic types *) []
            (Self T)
            (* Instance *) [ ("default", InstanceField.Method (default T)) ].
      End Impl_core_default_Default_for_alloc_collections_btree_set_Range_T.
      
      Module Impl_core_clone_Clone_where_core_alloc_Allocator_A_where_core_clone_Clone_A_for_alloc_collections_btree_set_Difference_T_A.
        Definition Self (T A : Ty.t) : Ty.t :=
          Ty.apply (Ty.path "alloc::collections::btree::set::Difference") [] [ T; A ].
        
        (*
            fn clone(&self) -> Self {
                Difference {
                    inner: match &self.inner {
                        DifferenceInner::Stitch { self_iter, other_iter } => DifferenceInner::Stitch {
                            self_iter: self_iter.clone(),
                            other_iter: other_iter.clone(),
                        },
                        DifferenceInner::Search { self_iter, other_set } => {
                            DifferenceInner::Search { self_iter: self_iter.clone(), other_set }
                        }
                        DifferenceInner::Iterate(iter) => DifferenceInner::Iterate(iter.clone()),
                    },
                }
            }
        *)
        Definition clone (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self T A in
          match ε, τ, α with
          | [], [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              Value.StructRecord
                "alloc::collections::btree::set::Difference"
                [
                  ("inner",
                    M.read (|
                      M.match_operator (|
                        Some
                          (Ty.apply
                            (Ty.path "alloc::collections::btree::set::DifferenceInner")
                            []
                            [ T; A ]),
                        M.alloc (|
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| self |) |),
                              "alloc::collections::btree::set::Difference",
                              "inner"
                            |)
                          |)
                        |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ := M.read (| γ |) in
                              let γ1_0 :=
                                M.SubPointer.get_struct_record_field (|
                                  γ,
                                  "alloc::collections::btree::set::DifferenceInner::Stitch",
                                  "self_iter"
                                |) in
                              let γ1_1 :=
                                M.SubPointer.get_struct_record_field (|
                                  γ,
                                  "alloc::collections::btree::set::DifferenceInner::Stitch",
                                  "other_iter"
                                |) in
                              let self_iter := M.alloc (| γ1_0 |) in
                              let other_iter := M.alloc (| γ1_1 |) in
                              M.alloc (|
                                Value.StructRecord
                                  "alloc::collections::btree::set::DifferenceInner::Stitch"
                                  [
                                    ("self_iter",
                                      M.call_closure (|
                                        Ty.apply
                                          (Ty.path "alloc::collections::btree::set::Iter")
                                          []
                                          [ T ],
                                        M.get_trait_method (|
                                          "core::clone::Clone",
                                          Ty.apply
                                            (Ty.path "alloc::collections::btree::set::Iter")
                                            []
                                            [ T ],
                                          [],
                                          [],
                                          "clone",
                                          [],
                                          []
                                        |),
                                        [
                                          M.borrow (|
                                            Pointer.Kind.Ref,
                                            M.deref (| M.read (| self_iter |) |)
                                          |)
                                        ]
                                      |));
                                    ("other_iter",
                                      M.call_closure (|
                                        Ty.apply
                                          (Ty.path "core::iter::adapters::peekable::Peekable")
                                          []
                                          [
                                            Ty.apply
                                              (Ty.path "alloc::collections::btree::set::Iter")
                                              []
                                              [ T ]
                                          ],
                                        M.get_trait_method (|
                                          "core::clone::Clone",
                                          Ty.apply
                                            (Ty.path "core::iter::adapters::peekable::Peekable")
                                            []
                                            [
                                              Ty.apply
                                                (Ty.path "alloc::collections::btree::set::Iter")
                                                []
                                                [ T ]
                                            ],
                                          [],
                                          [],
                                          "clone",
                                          [],
                                          []
                                        |),
                                        [
                                          M.borrow (|
                                            Pointer.Kind.Ref,
                                            M.deref (| M.read (| other_iter |) |)
                                          |)
                                        ]
                                      |))
                                  ]
                              |)));
                          fun γ =>
                            ltac:(M.monadic
                              (let γ := M.read (| γ |) in
                              let γ1_0 :=
                                M.SubPointer.get_struct_record_field (|
                                  γ,
                                  "alloc::collections::btree::set::DifferenceInner::Search",
                                  "self_iter"
                                |) in
                              let γ1_1 :=
                                M.SubPointer.get_struct_record_field (|
                                  γ,
                                  "alloc::collections::btree::set::DifferenceInner::Search",
                                  "other_set"
                                |) in
                              let self_iter := M.alloc (| γ1_0 |) in
                              let other_set := M.alloc (| γ1_1 |) in
                              M.alloc (|
                                Value.StructRecord
                                  "alloc::collections::btree::set::DifferenceInner::Search"
                                  [
                                    ("self_iter",
                                      M.call_closure (|
                                        Ty.apply
                                          (Ty.path "alloc::collections::btree::set::Iter")
                                          []
                                          [ T ],
                                        M.get_trait_method (|
                                          "core::clone::Clone",
                                          Ty.apply
                                            (Ty.path "alloc::collections::btree::set::Iter")
                                            []
                                            [ T ],
                                          [],
                                          [],
                                          "clone",
                                          [],
                                          []
                                        |),
                                        [
                                          M.borrow (|
                                            Pointer.Kind.Ref,
                                            M.deref (| M.read (| self_iter |) |)
                                          |)
                                        ]
                                      |));
                                    ("other_set",
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.deref (|
                                          M.read (| M.deref (| M.read (| other_set |) |) |)
                                        |)
                                      |))
                                  ]
                              |)));
                          fun γ =>
                            ltac:(M.monadic
                              (let γ := M.read (| γ |) in
                              let γ1_0 :=
                                M.SubPointer.get_struct_tuple_field (|
                                  γ,
                                  "alloc::collections::btree::set::DifferenceInner::Iterate",
                                  0
                                |) in
                              let iter := M.alloc (| γ1_0 |) in
                              M.alloc (|
                                Value.StructTuple
                                  "alloc::collections::btree::set::DifferenceInner::Iterate"
                                  [
                                    M.call_closure (|
                                      Ty.apply
                                        (Ty.path "alloc::collections::btree::set::Iter")
                                        []
                                        [ T ],
                                      M.get_trait_method (|
                                        "core::clone::Clone",
                                        Ty.apply
                                          (Ty.path "alloc::collections::btree::set::Iter")
                                          []
                                          [ T ],
                                        [],
                                        [],
                                        "clone",
                                        [],
                                        []
                                      |),
                                      [
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.deref (| M.read (| iter |) |)
                                        |)
                                      ]
                                    |)
                                  ]
                              |)))
                        ]
                      |)
                    |))
                ]))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Axiom Implements :
          forall (T A : Ty.t),
          M.IsTraitInstance
            "core::clone::Clone"
            (* Trait polymorphic consts *) []
            (* Trait polymorphic types *) []
            (Self T A)
            (* Instance *) [ ("clone", InstanceField.Method (clone T A)) ].
      End Impl_core_clone_Clone_where_core_alloc_Allocator_A_where_core_clone_Clone_A_for_alloc_collections_btree_set_Difference_T_A.
      
      Module Impl_core_iter_traits_iterator_Iterator_where_core_cmp_Ord_T_where_core_alloc_Allocator_A_where_core_clone_Clone_A_for_alloc_collections_btree_set_Difference_T_A.
        Definition Self (T A : Ty.t) : Ty.t :=
          Ty.apply (Ty.path "alloc::collections::btree::set::Difference") [] [ T; A ].
        
        (*     type Item = &'a T; *)
        Definition _Item (T A : Ty.t) : Ty.t := Ty.apply (Ty.path "&") [] [ T ].
        
        (*
            fn next(&mut self) -> Option<&'a T> {
                match &mut self.inner {
                    DifferenceInner::Stitch { self_iter, other_iter } => {
                        let mut self_next = self_iter.next()?;
                        loop {
                            match other_iter.peek().map_or(Less, |other_next| self_next.cmp(other_next)) {
                                Less => return Some(self_next),
                                Equal => {
                                    self_next = self_iter.next()?;
                                    other_iter.next();
                                }
                                Greater => {
                                    other_iter.next();
                                }
                            }
                        }
                    }
                    DifferenceInner::Search { self_iter, other_set } => loop {
                        let self_next = self_iter.next()?;
                        if !other_set.contains(&self_next) {
                            return Some(self_next);
                        }
                    },
                    DifferenceInner::Iterate(iter) => iter.next(),
                }
            }
        *)
        Definition next (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self T A in
          match ε, τ, α with
          | [], [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              M.catch_return (|
                ltac:(M.monadic
                  (M.read (|
                    M.match_operator (|
                      Some
                        (Ty.apply
                          (Ty.path "core::option::Option")
                          []
                          [ Ty.apply (Ty.path "&") [] [ T ] ]),
                      M.alloc (|
                        M.borrow (|
                          Pointer.Kind.MutRef,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "alloc::collections::btree::set::Difference",
                            "inner"
                          |)
                        |)
                      |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ := M.read (| γ |) in
                            let γ1_0 :=
                              M.SubPointer.get_struct_record_field (|
                                γ,
                                "alloc::collections::btree::set::DifferenceInner::Stitch",
                                "self_iter"
                              |) in
                            let γ1_1 :=
                              M.SubPointer.get_struct_record_field (|
                                γ,
                                "alloc::collections::btree::set::DifferenceInner::Stitch",
                                "other_iter"
                              |) in
                            let self_iter := M.alloc (| γ1_0 |) in
                            let other_iter := M.alloc (| γ1_1 |) in
                            let~ self_next : Ty.apply (Ty.path "&") [] [ T ] :=
                              M.copy (|
                                M.match_operator (|
                                  Some (Ty.apply (Ty.path "&") [] [ T ]),
                                  M.alloc (|
                                    M.call_closure (|
                                      Ty.apply
                                        (Ty.path "core::ops::control_flow::ControlFlow")
                                        []
                                        [
                                          Ty.apply
                                            (Ty.path "core::option::Option")
                                            []
                                            [ Ty.path "core::convert::Infallible" ];
                                          Ty.apply (Ty.path "&") [] [ T ]
                                        ],
                                      M.get_trait_method (|
                                        "core::ops::try_trait::Try",
                                        Ty.apply
                                          (Ty.path "core::option::Option")
                                          []
                                          [ Ty.apply (Ty.path "&") [] [ T ] ],
                                        [],
                                        [],
                                        "branch",
                                        [],
                                        []
                                      |),
                                      [
                                        M.call_closure (|
                                          Ty.apply
                                            (Ty.path "core::option::Option")
                                            []
                                            [ Ty.apply (Ty.path "&") [] [ T ] ],
                                          M.get_trait_method (|
                                            "core::iter::traits::iterator::Iterator",
                                            Ty.apply
                                              (Ty.path "alloc::collections::btree::set::Iter")
                                              []
                                              [ T ],
                                            [],
                                            [],
                                            "next",
                                            [],
                                            []
                                          |),
                                          [
                                            M.borrow (|
                                              Pointer.Kind.MutRef,
                                              M.deref (| M.read (| self_iter |) |)
                                            |)
                                          ]
                                        |)
                                      ]
                                    |)
                                  |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ0_0 :=
                                          M.SubPointer.get_struct_tuple_field (|
                                            γ,
                                            "core::ops::control_flow::ControlFlow::Break",
                                            0
                                          |) in
                                        let residual := M.copy (| γ0_0 |) in
                                        M.alloc (|
                                          M.never_to_any (|
                                            M.read (|
                                              M.return_ (|
                                                M.call_closure (|
                                                  Ty.apply
                                                    (Ty.path "core::option::Option")
                                                    []
                                                    [ Ty.apply (Ty.path "&") [] [ T ] ],
                                                  M.get_trait_method (|
                                                    "core::ops::try_trait::FromResidual",
                                                    Ty.apply
                                                      (Ty.path "core::option::Option")
                                                      []
                                                      [ Ty.apply (Ty.path "&") [] [ T ] ],
                                                    [],
                                                    [
                                                      Ty.apply
                                                        (Ty.path "core::option::Option")
                                                        []
                                                        [ Ty.path "core::convert::Infallible" ]
                                                    ],
                                                    "from_residual",
                                                    [],
                                                    []
                                                  |),
                                                  [ M.read (| residual |) ]
                                                |)
                                              |)
                                            |)
                                          |)
                                        |)));
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ0_0 :=
                                          M.SubPointer.get_struct_tuple_field (|
                                            γ,
                                            "core::ops::control_flow::ControlFlow::Continue",
                                            0
                                          |) in
                                        let val := M.copy (| γ0_0 |) in
                                        val))
                                  ]
                                |)
                              |) in
                            M.alloc (|
                              M.never_to_any (|
                                M.read (|
                                  M.loop (|
                                    Ty.path "never",
                                    ltac:(M.monadic
                                      (M.match_operator (|
                                        Some (Ty.tuple []),
                                        M.alloc (|
                                          M.call_closure (|
                                            Ty.path "core::cmp::Ordering",
                                            M.get_associated_function (|
                                              Ty.apply
                                                (Ty.path "core::option::Option")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path "&")
                                                    []
                                                    [ Ty.apply (Ty.path "&") [] [ T ] ]
                                                ],
                                              "map_or",
                                              [],
                                              [
                                                Ty.path "core::cmp::Ordering";
                                                Ty.function
                                                  [
                                                    Ty.tuple
                                                      [
                                                        Ty.apply
                                                          (Ty.path "&")
                                                          []
                                                          [ Ty.apply (Ty.path "&") [] [ T ] ]
                                                      ]
                                                  ]
                                                  (Ty.path "core::cmp::Ordering")
                                              ]
                                            |),
                                            [
                                              M.call_closure (|
                                                Ty.apply
                                                  (Ty.path "core::option::Option")
                                                  []
                                                  [
                                                    Ty.apply
                                                      (Ty.path "&")
                                                      []
                                                      [ Ty.apply (Ty.path "&") [] [ T ] ]
                                                  ],
                                                M.get_associated_function (|
                                                  Ty.apply
                                                    (Ty.path
                                                      "core::iter::adapters::peekable::Peekable")
                                                    []
                                                    [
                                                      Ty.apply
                                                        (Ty.path
                                                          "alloc::collections::btree::set::Iter")
                                                        []
                                                        [ T ]
                                                    ],
                                                  "peek",
                                                  [],
                                                  []
                                                |),
                                                [
                                                  M.borrow (|
                                                    Pointer.Kind.MutRef,
                                                    M.deref (| M.read (| other_iter |) |)
                                                  |)
                                                ]
                                              |);
                                              Value.StructTuple "core::cmp::Ordering::Less" [];
                                              M.closure
                                                (fun γ =>
                                                  ltac:(M.monadic
                                                    match γ with
                                                    | [ α0 ] =>
                                                      ltac:(M.monadic
                                                        (M.match_operator (|
                                                          Some
                                                            (Ty.function
                                                              [
                                                                Ty.tuple
                                                                  [
                                                                    Ty.apply
                                                                      (Ty.path "&")
                                                                      []
                                                                      [
                                                                        Ty.apply
                                                                          (Ty.path "&")
                                                                          []
                                                                          [ T ]
                                                                      ]
                                                                  ]
                                                              ]
                                                              (Ty.path "core::cmp::Ordering")),
                                                          M.alloc (| α0 |),
                                                          [
                                                            fun γ =>
                                                              ltac:(M.monadic
                                                                (let other_next := M.copy (| γ |) in
                                                                M.call_closure (|
                                                                  Ty.path "core::cmp::Ordering",
                                                                  M.get_trait_method (|
                                                                    "core::cmp::Ord",
                                                                    T,
                                                                    [],
                                                                    [],
                                                                    "cmp",
                                                                    [],
                                                                    []
                                                                  |),
                                                                  [
                                                                    M.borrow (|
                                                                      Pointer.Kind.Ref,
                                                                      M.deref (|
                                                                        M.read (| self_next |)
                                                                      |)
                                                                    |);
                                                                    M.borrow (|
                                                                      Pointer.Kind.Ref,
                                                                      M.deref (|
                                                                        M.read (|
                                                                          M.deref (|
                                                                            M.read (| other_next |)
                                                                          |)
                                                                        |)
                                                                      |)
                                                                    |)
                                                                  ]
                                                                |)))
                                                          ]
                                                        |)))
                                                    | _ => M.impossible "wrong number of arguments"
                                                    end))
                                            ]
                                          |)
                                        |),
                                        [
                                          fun γ =>
                                            ltac:(M.monadic
                                              (let _ :=
                                                M.is_struct_tuple (|
                                                  γ,
                                                  "core::cmp::Ordering::Less"
                                                |) in
                                              M.alloc (|
                                                M.never_to_any (|
                                                  M.read (|
                                                    M.return_ (|
                                                      Value.StructTuple
                                                        "core::option::Option::Some"
                                                        [
                                                          M.borrow (|
                                                            Pointer.Kind.Ref,
                                                            M.deref (| M.read (| self_next |) |)
                                                          |)
                                                        ]
                                                    |)
                                                  |)
                                                |)
                                              |)));
                                          fun γ =>
                                            ltac:(M.monadic
                                              (let _ :=
                                                M.is_struct_tuple (|
                                                  γ,
                                                  "core::cmp::Ordering::Equal"
                                                |) in
                                              let~ _ : Ty.tuple [] :=
                                                M.alloc (|
                                                  M.write (|
                                                    self_next,
                                                    M.borrow (|
                                                      Pointer.Kind.Ref,
                                                      M.deref (|
                                                        M.read (|
                                                          M.match_operator (|
                                                            Some (Ty.apply (Ty.path "&") [] [ T ]),
                                                            M.alloc (|
                                                              M.call_closure (|
                                                                Ty.apply
                                                                  (Ty.path
                                                                    "core::ops::control_flow::ControlFlow")
                                                                  []
                                                                  [
                                                                    Ty.apply
                                                                      (Ty.path
                                                                        "core::option::Option")
                                                                      []
                                                                      [
                                                                        Ty.path
                                                                          "core::convert::Infallible"
                                                                      ];
                                                                    Ty.apply (Ty.path "&") [] [ T ]
                                                                  ],
                                                                M.get_trait_method (|
                                                                  "core::ops::try_trait::Try",
                                                                  Ty.apply
                                                                    (Ty.path "core::option::Option")
                                                                    []
                                                                    [
                                                                      Ty.apply
                                                                        (Ty.path "&")
                                                                        []
                                                                        [ T ]
                                                                    ],
                                                                  [],
                                                                  [],
                                                                  "branch",
                                                                  [],
                                                                  []
                                                                |),
                                                                [
                                                                  M.call_closure (|
                                                                    Ty.apply
                                                                      (Ty.path
                                                                        "core::option::Option")
                                                                      []
                                                                      [
                                                                        Ty.apply
                                                                          (Ty.path "&")
                                                                          []
                                                                          [ T ]
                                                                      ],
                                                                    M.get_trait_method (|
                                                                      "core::iter::traits::iterator::Iterator",
                                                                      Ty.apply
                                                                        (Ty.path
                                                                          "alloc::collections::btree::set::Iter")
                                                                        []
                                                                        [ T ],
                                                                      [],
                                                                      [],
                                                                      "next",
                                                                      [],
                                                                      []
                                                                    |),
                                                                    [
                                                                      M.borrow (|
                                                                        Pointer.Kind.MutRef,
                                                                        M.deref (|
                                                                          M.read (| self_iter |)
                                                                        |)
                                                                      |)
                                                                    ]
                                                                  |)
                                                                ]
                                                              |)
                                                            |),
                                                            [
                                                              fun γ =>
                                                                ltac:(M.monadic
                                                                  (let γ0_0 :=
                                                                    M.SubPointer.get_struct_tuple_field (|
                                                                      γ,
                                                                      "core::ops::control_flow::ControlFlow::Break",
                                                                      0
                                                                    |) in
                                                                  let residual :=
                                                                    M.copy (| γ0_0 |) in
                                                                  M.alloc (|
                                                                    M.never_to_any (|
                                                                      M.read (|
                                                                        M.return_ (|
                                                                          M.call_closure (|
                                                                            Ty.apply
                                                                              (Ty.path
                                                                                "core::option::Option")
                                                                              []
                                                                              [
                                                                                Ty.apply
                                                                                  (Ty.path "&")
                                                                                  []
                                                                                  [ T ]
                                                                              ],
                                                                            M.get_trait_method (|
                                                                              "core::ops::try_trait::FromResidual",
                                                                              Ty.apply
                                                                                (Ty.path
                                                                                  "core::option::Option")
                                                                                []
                                                                                [
                                                                                  Ty.apply
                                                                                    (Ty.path "&")
                                                                                    []
                                                                                    [ T ]
                                                                                ],
                                                                              [],
                                                                              [
                                                                                Ty.apply
                                                                                  (Ty.path
                                                                                    "core::option::Option")
                                                                                  []
                                                                                  [
                                                                                    Ty.path
                                                                                      "core::convert::Infallible"
                                                                                  ]
                                                                              ],
                                                                              "from_residual",
                                                                              [],
                                                                              []
                                                                            |),
                                                                            [ M.read (| residual |)
                                                                            ]
                                                                          |)
                                                                        |)
                                                                      |)
                                                                    |)
                                                                  |)));
                                                              fun γ =>
                                                                ltac:(M.monadic
                                                                  (let γ0_0 :=
                                                                    M.SubPointer.get_struct_tuple_field (|
                                                                      γ,
                                                                      "core::ops::control_flow::ControlFlow::Continue",
                                                                      0
                                                                    |) in
                                                                  let val := M.copy (| γ0_0 |) in
                                                                  M.alloc (|
                                                                    M.borrow (|
                                                                      Pointer.Kind.Ref,
                                                                      M.deref (| M.read (| val |) |)
                                                                    |)
                                                                  |)))
                                                            ]
                                                          |)
                                                        |)
                                                      |)
                                                    |)
                                                  |)
                                                |) in
                                              let~ _ :
                                                  Ty.apply
                                                    (Ty.path "core::option::Option")
                                                    []
                                                    [ Ty.apply (Ty.path "&") [] [ T ] ] :=
                                                M.alloc (|
                                                  M.call_closure (|
                                                    Ty.apply
                                                      (Ty.path "core::option::Option")
                                                      []
                                                      [ Ty.apply (Ty.path "&") [] [ T ] ],
                                                    M.get_trait_method (|
                                                      "core::iter::traits::iterator::Iterator",
                                                      Ty.apply
                                                        (Ty.path
                                                          "core::iter::adapters::peekable::Peekable")
                                                        []
                                                        [
                                                          Ty.apply
                                                            (Ty.path
                                                              "alloc::collections::btree::set::Iter")
                                                            []
                                                            [ T ]
                                                        ],
                                                      [],
                                                      [],
                                                      "next",
                                                      [],
                                                      []
                                                    |),
                                                    [
                                                      M.borrow (|
                                                        Pointer.Kind.MutRef,
                                                        M.deref (| M.read (| other_iter |) |)
                                                      |)
                                                    ]
                                                  |)
                                                |) in
                                              M.alloc (| Value.Tuple [] |)));
                                          fun γ =>
                                            ltac:(M.monadic
                                              (let _ :=
                                                M.is_struct_tuple (|
                                                  γ,
                                                  "core::cmp::Ordering::Greater"
                                                |) in
                                              let~ _ :
                                                  Ty.apply
                                                    (Ty.path "core::option::Option")
                                                    []
                                                    [ Ty.apply (Ty.path "&") [] [ T ] ] :=
                                                M.alloc (|
                                                  M.call_closure (|
                                                    Ty.apply
                                                      (Ty.path "core::option::Option")
                                                      []
                                                      [ Ty.apply (Ty.path "&") [] [ T ] ],
                                                    M.get_trait_method (|
                                                      "core::iter::traits::iterator::Iterator",
                                                      Ty.apply
                                                        (Ty.path
                                                          "core::iter::adapters::peekable::Peekable")
                                                        []
                                                        [
                                                          Ty.apply
                                                            (Ty.path
                                                              "alloc::collections::btree::set::Iter")
                                                            []
                                                            [ T ]
                                                        ],
                                                      [],
                                                      [],
                                                      "next",
                                                      [],
                                                      []
                                                    |),
                                                    [
                                                      M.borrow (|
                                                        Pointer.Kind.MutRef,
                                                        M.deref (| M.read (| other_iter |) |)
                                                      |)
                                                    ]
                                                  |)
                                                |) in
                                              M.alloc (| Value.Tuple [] |)))
                                        ]
                                      |)))
                                  |)
                                |)
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ := M.read (| γ |) in
                            let γ1_0 :=
                              M.SubPointer.get_struct_record_field (|
                                γ,
                                "alloc::collections::btree::set::DifferenceInner::Search",
                                "self_iter"
                              |) in
                            let γ1_1 :=
                              M.SubPointer.get_struct_record_field (|
                                γ,
                                "alloc::collections::btree::set::DifferenceInner::Search",
                                "other_set"
                              |) in
                            let self_iter := M.alloc (| γ1_0 |) in
                            let other_set := M.alloc (| γ1_1 |) in
                            M.alloc (|
                              M.never_to_any (|
                                M.read (|
                                  M.loop (|
                                    Ty.path "never",
                                    ltac:(M.monadic
                                      (let~ self_next : Ty.apply (Ty.path "&") [] [ T ] :=
                                        M.copy (|
                                          M.match_operator (|
                                            Some (Ty.apply (Ty.path "&") [] [ T ]),
                                            M.alloc (|
                                              M.call_closure (|
                                                Ty.apply
                                                  (Ty.path "core::ops::control_flow::ControlFlow")
                                                  []
                                                  [
                                                    Ty.apply
                                                      (Ty.path "core::option::Option")
                                                      []
                                                      [ Ty.path "core::convert::Infallible" ];
                                                    Ty.apply (Ty.path "&") [] [ T ]
                                                  ],
                                                M.get_trait_method (|
                                                  "core::ops::try_trait::Try",
                                                  Ty.apply
                                                    (Ty.path "core::option::Option")
                                                    []
                                                    [ Ty.apply (Ty.path "&") [] [ T ] ],
                                                  [],
                                                  [],
                                                  "branch",
                                                  [],
                                                  []
                                                |),
                                                [
                                                  M.call_closure (|
                                                    Ty.apply
                                                      (Ty.path "core::option::Option")
                                                      []
                                                      [ Ty.apply (Ty.path "&") [] [ T ] ],
                                                    M.get_trait_method (|
                                                      "core::iter::traits::iterator::Iterator",
                                                      Ty.apply
                                                        (Ty.path
                                                          "alloc::collections::btree::set::Iter")
                                                        []
                                                        [ T ],
                                                      [],
                                                      [],
                                                      "next",
                                                      [],
                                                      []
                                                    |),
                                                    [
                                                      M.borrow (|
                                                        Pointer.Kind.MutRef,
                                                        M.deref (| M.read (| self_iter |) |)
                                                      |)
                                                    ]
                                                  |)
                                                ]
                                              |)
                                            |),
                                            [
                                              fun γ =>
                                                ltac:(M.monadic
                                                  (let γ0_0 :=
                                                    M.SubPointer.get_struct_tuple_field (|
                                                      γ,
                                                      "core::ops::control_flow::ControlFlow::Break",
                                                      0
                                                    |) in
                                                  let residual := M.copy (| γ0_0 |) in
                                                  M.alloc (|
                                                    M.never_to_any (|
                                                      M.read (|
                                                        M.return_ (|
                                                          M.call_closure (|
                                                            Ty.apply
                                                              (Ty.path "core::option::Option")
                                                              []
                                                              [ Ty.apply (Ty.path "&") [] [ T ] ],
                                                            M.get_trait_method (|
                                                              "core::ops::try_trait::FromResidual",
                                                              Ty.apply
                                                                (Ty.path "core::option::Option")
                                                                []
                                                                [ Ty.apply (Ty.path "&") [] [ T ] ],
                                                              [],
                                                              [
                                                                Ty.apply
                                                                  (Ty.path "core::option::Option")
                                                                  []
                                                                  [
                                                                    Ty.path
                                                                      "core::convert::Infallible"
                                                                  ]
                                                              ],
                                                              "from_residual",
                                                              [],
                                                              []
                                                            |),
                                                            [ M.read (| residual |) ]
                                                          |)
                                                        |)
                                                      |)
                                                    |)
                                                  |)));
                                              fun γ =>
                                                ltac:(M.monadic
                                                  (let γ0_0 :=
                                                    M.SubPointer.get_struct_tuple_field (|
                                                      γ,
                                                      "core::ops::control_flow::ControlFlow::Continue",
                                                      0
                                                    |) in
                                                  let val := M.copy (| γ0_0 |) in
                                                  val))
                                            ]
                                          |)
                                        |) in
                                      M.match_operator (|
                                        Some (Ty.tuple []),
                                        M.alloc (| Value.Tuple [] |),
                                        [
                                          fun γ =>
                                            ltac:(M.monadic
                                              (let γ :=
                                                M.use
                                                  (M.alloc (|
                                                    UnOp.not (|
                                                      M.call_closure (|
                                                        Ty.path "bool",
                                                        M.get_associated_function (|
                                                          Ty.apply
                                                            (Ty.path
                                                              "alloc::collections::btree::set::BTreeSet")
                                                            []
                                                            [ T; A ],
                                                          "contains",
                                                          [],
                                                          [ T ]
                                                        |),
                                                        [
                                                          M.borrow (|
                                                            Pointer.Kind.Ref,
                                                            M.deref (|
                                                              M.read (|
                                                                M.deref (| M.read (| other_set |) |)
                                                              |)
                                                            |)
                                                          |);
                                                          M.borrow (|
                                                            Pointer.Kind.Ref,
                                                            M.deref (|
                                                              M.read (|
                                                                M.deref (|
                                                                  M.borrow (|
                                                                    Pointer.Kind.Ref,
                                                                    self_next
                                                                  |)
                                                                |)
                                                              |)
                                                            |)
                                                          |)
                                                        ]
                                                      |)
                                                    |)
                                                  |)) in
                                              let _ :=
                                                is_constant_or_break_match (|
                                                  M.read (| γ |),
                                                  Value.Bool true
                                                |) in
                                              M.alloc (|
                                                M.never_to_any (|
                                                  M.read (|
                                                    M.return_ (|
                                                      Value.StructTuple
                                                        "core::option::Option::Some"
                                                        [
                                                          M.borrow (|
                                                            Pointer.Kind.Ref,
                                                            M.deref (| M.read (| self_next |) |)
                                                          |)
                                                        ]
                                                    |)
                                                  |)
                                                |)
                                              |)));
                                          fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                                        ]
                                      |)))
                                  |)
                                |)
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ := M.read (| γ |) in
                            let γ1_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "alloc::collections::btree::set::DifferenceInner::Iterate",
                                0
                              |) in
                            let iter := M.alloc (| γ1_0 |) in
                            M.alloc (|
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "core::option::Option")
                                  []
                                  [ Ty.apply (Ty.path "&") [] [ T ] ],
                                M.get_trait_method (|
                                  "core::iter::traits::iterator::Iterator",
                                  Ty.apply
                                    (Ty.path "alloc::collections::btree::set::Iter")
                                    []
                                    [ T ],
                                  [],
                                  [],
                                  "next",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (|
                                    Pointer.Kind.MutRef,
                                    M.deref (| M.read (| iter |) |)
                                  |)
                                ]
                              |)
                            |)))
                      ]
                    |)
                  |)))
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        (*
            fn size_hint(&self) -> (usize, Option<usize>) {
                let (self_len, other_len) = match &self.inner {
                    DifferenceInner::Stitch { self_iter, other_iter } => {
                        (self_iter.len(), other_iter.len())
                    }
                    DifferenceInner::Search { self_iter, other_set } => (self_iter.len(), other_set.len()),
                    DifferenceInner::Iterate(iter) => (iter.len(), 0),
                };
                (self_len.saturating_sub(other_len), Some(self_len))
            }
        *)
        Definition size_hint
            (T A : Ty.t)
            (ε : list Value.t)
            (τ : list Ty.t)
            (α : list Value.t)
            : M :=
          let Self : Ty.t := Self T A in
          match ε, τ, α with
          | [], [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              M.read (|
                M.match_operator (|
                  None,
                  M.match_operator (|
                    Some (Ty.tuple [ Ty.path "usize"; Ty.path "usize" ]),
                    M.alloc (|
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "alloc::collections::btree::set::Difference",
                          "inner"
                        |)
                      |)
                    |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ := M.read (| γ |) in
                          let γ1_0 :=
                            M.SubPointer.get_struct_record_field (|
                              γ,
                              "alloc::collections::btree::set::DifferenceInner::Stitch",
                              "self_iter"
                            |) in
                          let γ1_1 :=
                            M.SubPointer.get_struct_record_field (|
                              γ,
                              "alloc::collections::btree::set::DifferenceInner::Stitch",
                              "other_iter"
                            |) in
                          let self_iter := M.alloc (| γ1_0 |) in
                          let other_iter := M.alloc (| γ1_1 |) in
                          M.alloc (|
                            Value.Tuple
                              [
                                M.call_closure (|
                                  Ty.path "usize",
                                  M.get_trait_method (|
                                    "core::iter::traits::exact_size::ExactSizeIterator",
                                    Ty.apply
                                      (Ty.path "alloc::collections::btree::set::Iter")
                                      []
                                      [ T ],
                                    [],
                                    [],
                                    "len",
                                    [],
                                    []
                                  |),
                                  [
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.deref (| M.read (| self_iter |) |)
                                    |)
                                  ]
                                |);
                                M.call_closure (|
                                  Ty.path "usize",
                                  M.get_trait_method (|
                                    "core::iter::traits::exact_size::ExactSizeIterator",
                                    Ty.apply
                                      (Ty.path "core::iter::adapters::peekable::Peekable")
                                      []
                                      [
                                        Ty.apply
                                          (Ty.path "alloc::collections::btree::set::Iter")
                                          []
                                          [ T ]
                                      ],
                                    [],
                                    [],
                                    "len",
                                    [],
                                    []
                                  |),
                                  [
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.deref (| M.read (| other_iter |) |)
                                    |)
                                  ]
                                |)
                              ]
                          |)));
                      fun γ =>
                        ltac:(M.monadic
                          (let γ := M.read (| γ |) in
                          let γ1_0 :=
                            M.SubPointer.get_struct_record_field (|
                              γ,
                              "alloc::collections::btree::set::DifferenceInner::Search",
                              "self_iter"
                            |) in
                          let γ1_1 :=
                            M.SubPointer.get_struct_record_field (|
                              γ,
                              "alloc::collections::btree::set::DifferenceInner::Search",
                              "other_set"
                            |) in
                          let self_iter := M.alloc (| γ1_0 |) in
                          let other_set := M.alloc (| γ1_1 |) in
                          M.alloc (|
                            Value.Tuple
                              [
                                M.call_closure (|
                                  Ty.path "usize",
                                  M.get_trait_method (|
                                    "core::iter::traits::exact_size::ExactSizeIterator",
                                    Ty.apply
                                      (Ty.path "alloc::collections::btree::set::Iter")
                                      []
                                      [ T ],
                                    [],
                                    [],
                                    "len",
                                    [],
                                    []
                                  |),
                                  [
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.deref (| M.read (| self_iter |) |)
                                    |)
                                  ]
                                |);
                                M.call_closure (|
                                  Ty.path "usize",
                                  M.get_associated_function (|
                                    Ty.apply
                                      (Ty.path "alloc::collections::btree::set::BTreeSet")
                                      []
                                      [ T; A ],
                                    "len",
                                    [],
                                    []
                                  |),
                                  [
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.deref (|
                                        M.read (| M.deref (| M.read (| other_set |) |) |)
                                      |)
                                    |)
                                  ]
                                |)
                              ]
                          |)));
                      fun γ =>
                        ltac:(M.monadic
                          (let γ := M.read (| γ |) in
                          let γ1_0 :=
                            M.SubPointer.get_struct_tuple_field (|
                              γ,
                              "alloc::collections::btree::set::DifferenceInner::Iterate",
                              0
                            |) in
                          let iter := M.alloc (| γ1_0 |) in
                          M.alloc (|
                            Value.Tuple
                              [
                                M.call_closure (|
                                  Ty.path "usize",
                                  M.get_trait_method (|
                                    "core::iter::traits::exact_size::ExactSizeIterator",
                                    Ty.apply
                                      (Ty.path "alloc::collections::btree::set::Iter")
                                      []
                                      [ T ],
                                    [],
                                    [],
                                    "len",
                                    [],
                                    []
                                  |),
                                  [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| iter |) |) |)
                                  ]
                                |);
                                Value.Integer IntegerKind.Usize 0
                              ]
                          |)))
                    ]
                  |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                        let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                        let self_len := M.copy (| γ0_0 |) in
                        let other_len := M.copy (| γ0_1 |) in
                        M.alloc (|
                          Value.Tuple
                            [
                              M.call_closure (|
                                Ty.path "usize",
                                M.get_associated_function (|
                                  Ty.path "usize",
                                  "saturating_sub",
                                  [],
                                  []
                                |),
                                [ M.read (| self_len |); M.read (| other_len |) ]
                              |);
                              Value.StructTuple
                                "core::option::Option::Some"
                                [ M.read (| self_len |) ]
                            ]
                        |)))
                  ]
                |)
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        (*
            fn min(mut self) -> Option<&'a T> {
                self.next()
            }
        *)
        Definition min (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self T A in
          match ε, τ, α with
          | [], [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              M.call_closure (|
                Ty.apply (Ty.path "core::option::Option") [] [ Ty.apply (Ty.path "&") [] [ T ] ],
                M.get_trait_method (|
                  "core::iter::traits::iterator::Iterator",
                  Ty.apply (Ty.path "alloc::collections::btree::set::Difference") [] [ T; A ],
                  [],
                  [],
                  "next",
                  [],
                  []
                |),
                [ M.borrow (| Pointer.Kind.MutRef, self |) ]
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Axiom Implements :
          forall (T A : Ty.t),
          M.IsTraitInstance
            "core::iter::traits::iterator::Iterator"
            (* Trait polymorphic consts *) []
            (* Trait polymorphic types *) []
            (Self T A)
            (* Instance *)
            [
              ("Item", InstanceField.Ty (_Item T A));
              ("next", InstanceField.Method (next T A));
              ("size_hint", InstanceField.Method (size_hint T A));
              ("min", InstanceField.Method (min T A))
            ].
      End Impl_core_iter_traits_iterator_Iterator_where_core_cmp_Ord_T_where_core_alloc_Allocator_A_where_core_clone_Clone_A_for_alloc_collections_btree_set_Difference_T_A.
      
      Module Impl_core_iter_traits_marker_FusedIterator_where_core_cmp_Ord_T_where_core_alloc_Allocator_A_where_core_clone_Clone_A_for_alloc_collections_btree_set_Difference_T_A.
        Definition Self (T A : Ty.t) : Ty.t :=
          Ty.apply (Ty.path "alloc::collections::btree::set::Difference") [] [ T; A ].
        
        Axiom Implements :
          forall (T A : Ty.t),
          M.IsTraitInstance
            "core::iter::traits::marker::FusedIterator"
            (* Trait polymorphic consts *) []
            (* Trait polymorphic types *) []
            (Self T A)
            (* Instance *) [].
      End Impl_core_iter_traits_marker_FusedIterator_where_core_cmp_Ord_T_where_core_alloc_Allocator_A_where_core_clone_Clone_A_for_alloc_collections_btree_set_Difference_T_A.
      
      Module Impl_core_clone_Clone_for_alloc_collections_btree_set_SymmetricDifference_T.
        Definition Self (T : Ty.t) : Ty.t :=
          Ty.apply (Ty.path "alloc::collections::btree::set::SymmetricDifference") [] [ T ].
        
        (*
            fn clone(&self) -> Self {
                SymmetricDifference(self.0.clone())
            }
        *)
        Definition clone (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self T in
          match ε, τ, α with
          | [], [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              Value.StructTuple
                "alloc::collections::btree::set::SymmetricDifference"
                [
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "alloc::collections::btree::merge_iter::MergeIterInner")
                      []
                      [ Ty.apply (Ty.path "alloc::collections::btree::set::Iter") [] [ T ] ],
                    M.get_trait_method (|
                      "core::clone::Clone",
                      Ty.apply
                        (Ty.path "alloc::collections::btree::merge_iter::MergeIterInner")
                        []
                        [ Ty.apply (Ty.path "alloc::collections::btree::set::Iter") [] [ T ] ],
                      [],
                      [],
                      "clone",
                      [],
                      []
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.SubPointer.get_struct_tuple_field (|
                          M.deref (| M.read (| self |) |),
                          "alloc::collections::btree::set::SymmetricDifference",
                          0
                        |)
                      |)
                    ]
                  |)
                ]))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Axiom Implements :
          forall (T : Ty.t),
          M.IsTraitInstance
            "core::clone::Clone"
            (* Trait polymorphic consts *) []
            (* Trait polymorphic types *) []
            (Self T)
            (* Instance *) [ ("clone", InstanceField.Method (clone T)) ].
      End Impl_core_clone_Clone_for_alloc_collections_btree_set_SymmetricDifference_T.
      
      Module Impl_core_iter_traits_iterator_Iterator_where_core_cmp_Ord_T_for_alloc_collections_btree_set_SymmetricDifference_T.
        Definition Self (T : Ty.t) : Ty.t :=
          Ty.apply (Ty.path "alloc::collections::btree::set::SymmetricDifference") [] [ T ].
        
        (*     type Item = &'a T; *)
        Definition _Item (T : Ty.t) : Ty.t := Ty.apply (Ty.path "&") [] [ T ].
        
        (*
            fn next(&mut self) -> Option<&'a T> {
                loop {
                    let (a_next, b_next) = self.0.nexts(Self::Item::cmp);
                    if a_next.and(b_next).is_none() {
                        return a_next.or(b_next);
                    }
                }
            }
        *)
        Definition next (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self T in
          match ε, τ, α with
          | [], [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              M.catch_return (|
                ltac:(M.monadic
                  (M.never_to_any (|
                    M.read (|
                      M.loop (|
                        Ty.path "never",
                        ltac:(M.monadic
                          (M.match_operator (|
                            None,
                            M.alloc (|
                              M.call_closure (|
                                Ty.tuple
                                  [
                                    Ty.apply
                                      (Ty.path "core::option::Option")
                                      []
                                      [ Ty.apply (Ty.path "&") [] [ T ] ];
                                    Ty.apply
                                      (Ty.path "core::option::Option")
                                      []
                                      [ Ty.apply (Ty.path "&") [] [ T ] ]
                                  ],
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path
                                      "alloc::collections::btree::merge_iter::MergeIterInner")
                                    []
                                    [
                                      Ty.apply
                                        (Ty.path "alloc::collections::btree::set::Iter")
                                        []
                                        [ T ]
                                    ],
                                  "nexts",
                                  [],
                                  [
                                    Ty.function
                                      [
                                        Ty.apply
                                          (Ty.path "&")
                                          []
                                          [ Ty.apply (Ty.path "&") [] [ T ] ];
                                        Ty.apply
                                          (Ty.path "&")
                                          []
                                          [ Ty.apply (Ty.path "&") [] [ T ] ]
                                      ]
                                      (Ty.path "core::cmp::Ordering")
                                  ]
                                |),
                                [
                                  M.borrow (|
                                    Pointer.Kind.MutRef,
                                    M.SubPointer.get_struct_tuple_field (|
                                      M.deref (| M.read (| self |) |),
                                      "alloc::collections::btree::set::SymmetricDifference",
                                      0
                                    |)
                                  |);
                                  M.get_trait_method (|
                                    "core::cmp::Ord",
                                    Ty.apply (Ty.path "&") [] [ T ],
                                    [],
                                    [],
                                    "cmp",
                                    [],
                                    []
                                  |)
                                ]
                              |)
                            |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                                  let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                  let a_next := M.copy (| γ0_0 |) in
                                  let b_next := M.copy (| γ0_1 |) in
                                  M.match_operator (|
                                    Some (Ty.tuple []),
                                    M.alloc (| Value.Tuple [] |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let γ :=
                                            M.use
                                              (M.alloc (|
                                                M.call_closure (|
                                                  Ty.path "bool",
                                                  M.get_associated_function (|
                                                    Ty.apply
                                                      (Ty.path "core::option::Option")
                                                      []
                                                      [ Ty.apply (Ty.path "&") [] [ T ] ],
                                                    "is_none",
                                                    [],
                                                    []
                                                  |),
                                                  [
                                                    M.borrow (|
                                                      Pointer.Kind.Ref,
                                                      M.alloc (|
                                                        M.call_closure (|
                                                          Ty.apply
                                                            (Ty.path "core::option::Option")
                                                            []
                                                            [ Ty.apply (Ty.path "&") [] [ T ] ],
                                                          M.get_associated_function (|
                                                            Ty.apply
                                                              (Ty.path "core::option::Option")
                                                              []
                                                              [ Ty.apply (Ty.path "&") [] [ T ] ],
                                                            "and",
                                                            [],
                                                            [ Ty.apply (Ty.path "&") [] [ T ] ]
                                                          |),
                                                          [ M.read (| a_next |); M.read (| b_next |)
                                                          ]
                                                        |)
                                                      |)
                                                    |)
                                                  ]
                                                |)
                                              |)) in
                                          let _ :=
                                            is_constant_or_break_match (|
                                              M.read (| γ |),
                                              Value.Bool true
                                            |) in
                                          M.alloc (|
                                            M.never_to_any (|
                                              M.read (|
                                                M.return_ (|
                                                  M.call_closure (|
                                                    Ty.apply
                                                      (Ty.path "core::option::Option")
                                                      []
                                                      [ Ty.apply (Ty.path "&") [] [ T ] ],
                                                    M.get_associated_function (|
                                                      Ty.apply
                                                        (Ty.path "core::option::Option")
                                                        []
                                                        [ Ty.apply (Ty.path "&") [] [ T ] ],
                                                      "or",
                                                      [],
                                                      []
                                                    |),
                                                    [ M.read (| a_next |); M.read (| b_next |) ]
                                                  |)
                                                |)
                                              |)
                                            |)
                                          |)));
                                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                                    ]
                                  |)))
                            ]
                          |)))
                      |)
                    |)
                  |)))
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        (*
            fn size_hint(&self) -> (usize, Option<usize>) {
                let (a_len, b_len) = self.0.lens();
                // No checked_add, because even if a and b refer to the same set,
                // and T is a zero-sized type, the storage overhead of sets limits
                // the number of elements to less than half the range of usize.
                (0, Some(a_len + b_len))
            }
        *)
        Definition size_hint (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self T in
          match ε, τ, α with
          | [], [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              M.read (|
                M.match_operator (|
                  None,
                  M.alloc (|
                    M.call_closure (|
                      Ty.tuple [ Ty.path "usize"; Ty.path "usize" ],
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "alloc::collections::btree::merge_iter::MergeIterInner")
                          []
                          [ Ty.apply (Ty.path "alloc::collections::btree::set::Iter") [] [ T ] ],
                        "lens",
                        [],
                        []
                      |),
                      [
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_tuple_field (|
                            M.deref (| M.read (| self |) |),
                            "alloc::collections::btree::set::SymmetricDifference",
                            0
                          |)
                        |)
                      ]
                    |)
                  |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                        let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                        let a_len := M.copy (| γ0_0 |) in
                        let b_len := M.copy (| γ0_1 |) in
                        M.alloc (|
                          Value.Tuple
                            [
                              Value.Integer IntegerKind.Usize 0;
                              Value.StructTuple
                                "core::option::Option::Some"
                                [
                                  M.call_closure (|
                                    Ty.path "usize",
                                    BinOp.Wrap.add,
                                    [ M.read (| a_len |); M.read (| b_len |) ]
                                  |)
                                ]
                            ]
                        |)))
                  ]
                |)
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        (*
            fn min(mut self) -> Option<&'a T> {
                self.next()
            }
        *)
        Definition min (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self T in
          match ε, τ, α with
          | [], [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              M.call_closure (|
                Ty.apply (Ty.path "core::option::Option") [] [ Ty.apply (Ty.path "&") [] [ T ] ],
                M.get_trait_method (|
                  "core::iter::traits::iterator::Iterator",
                  Ty.apply (Ty.path "alloc::collections::btree::set::SymmetricDifference") [] [ T ],
                  [],
                  [],
                  "next",
                  [],
                  []
                |),
                [ M.borrow (| Pointer.Kind.MutRef, self |) ]
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Axiom Implements :
          forall (T : Ty.t),
          M.IsTraitInstance
            "core::iter::traits::iterator::Iterator"
            (* Trait polymorphic consts *) []
            (* Trait polymorphic types *) []
            (Self T)
            (* Instance *)
            [
              ("Item", InstanceField.Ty (_Item T));
              ("next", InstanceField.Method (next T));
              ("size_hint", InstanceField.Method (size_hint T));
              ("min", InstanceField.Method (min T))
            ].
      End Impl_core_iter_traits_iterator_Iterator_where_core_cmp_Ord_T_for_alloc_collections_btree_set_SymmetricDifference_T.
      
      Module Impl_core_iter_traits_marker_FusedIterator_where_core_cmp_Ord_T_for_alloc_collections_btree_set_SymmetricDifference_T.
        Definition Self (T : Ty.t) : Ty.t :=
          Ty.apply (Ty.path "alloc::collections::btree::set::SymmetricDifference") [] [ T ].
        
        Axiom Implements :
          forall (T : Ty.t),
          M.IsTraitInstance
            "core::iter::traits::marker::FusedIterator"
            (* Trait polymorphic consts *) []
            (* Trait polymorphic types *) []
            (Self T)
            (* Instance *) [].
      End Impl_core_iter_traits_marker_FusedIterator_where_core_cmp_Ord_T_for_alloc_collections_btree_set_SymmetricDifference_T.
      
      Module Impl_core_clone_Clone_where_core_alloc_Allocator_A_where_core_clone_Clone_A_for_alloc_collections_btree_set_Intersection_T_A.
        Definition Self (T A : Ty.t) : Ty.t :=
          Ty.apply (Ty.path "alloc::collections::btree::set::Intersection") [] [ T; A ].
        
        (*
            fn clone(&self) -> Self {
                Intersection {
                    inner: match &self.inner {
                        IntersectionInner::Stitch { a, b } => {
                            IntersectionInner::Stitch { a: a.clone(), b: b.clone() }
                        }
                        IntersectionInner::Search { small_iter, large_set } => {
                            IntersectionInner::Search { small_iter: small_iter.clone(), large_set }
                        }
                        IntersectionInner::Answer(answer) => IntersectionInner::Answer( *answer),
                    },
                }
            }
        *)
        Definition clone (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self T A in
          match ε, τ, α with
          | [], [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              Value.StructRecord
                "alloc::collections::btree::set::Intersection"
                [
                  ("inner",
                    M.read (|
                      M.match_operator (|
                        Some
                          (Ty.apply
                            (Ty.path "alloc::collections::btree::set::IntersectionInner")
                            []
                            [ T; A ]),
                        M.alloc (|
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| self |) |),
                              "alloc::collections::btree::set::Intersection",
                              "inner"
                            |)
                          |)
                        |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ := M.read (| γ |) in
                              let γ1_0 :=
                                M.SubPointer.get_struct_record_field (|
                                  γ,
                                  "alloc::collections::btree::set::IntersectionInner::Stitch",
                                  "a"
                                |) in
                              let γ1_1 :=
                                M.SubPointer.get_struct_record_field (|
                                  γ,
                                  "alloc::collections::btree::set::IntersectionInner::Stitch",
                                  "b"
                                |) in
                              let a := M.alloc (| γ1_0 |) in
                              let b := M.alloc (| γ1_1 |) in
                              M.alloc (|
                                Value.StructRecord
                                  "alloc::collections::btree::set::IntersectionInner::Stitch"
                                  [
                                    ("a",
                                      M.call_closure (|
                                        Ty.apply
                                          (Ty.path "alloc::collections::btree::set::Iter")
                                          []
                                          [ T ],
                                        M.get_trait_method (|
                                          "core::clone::Clone",
                                          Ty.apply
                                            (Ty.path "alloc::collections::btree::set::Iter")
                                            []
                                            [ T ],
                                          [],
                                          [],
                                          "clone",
                                          [],
                                          []
                                        |),
                                        [
                                          M.borrow (|
                                            Pointer.Kind.Ref,
                                            M.deref (| M.read (| a |) |)
                                          |)
                                        ]
                                      |));
                                    ("b",
                                      M.call_closure (|
                                        Ty.apply
                                          (Ty.path "alloc::collections::btree::set::Iter")
                                          []
                                          [ T ],
                                        M.get_trait_method (|
                                          "core::clone::Clone",
                                          Ty.apply
                                            (Ty.path "alloc::collections::btree::set::Iter")
                                            []
                                            [ T ],
                                          [],
                                          [],
                                          "clone",
                                          [],
                                          []
                                        |),
                                        [
                                          M.borrow (|
                                            Pointer.Kind.Ref,
                                            M.deref (| M.read (| b |) |)
                                          |)
                                        ]
                                      |))
                                  ]
                              |)));
                          fun γ =>
                            ltac:(M.monadic
                              (let γ := M.read (| γ |) in
                              let γ1_0 :=
                                M.SubPointer.get_struct_record_field (|
                                  γ,
                                  "alloc::collections::btree::set::IntersectionInner::Search",
                                  "small_iter"
                                |) in
                              let γ1_1 :=
                                M.SubPointer.get_struct_record_field (|
                                  γ,
                                  "alloc::collections::btree::set::IntersectionInner::Search",
                                  "large_set"
                                |) in
                              let small_iter := M.alloc (| γ1_0 |) in
                              let large_set := M.alloc (| γ1_1 |) in
                              M.alloc (|
                                Value.StructRecord
                                  "alloc::collections::btree::set::IntersectionInner::Search"
                                  [
                                    ("small_iter",
                                      M.call_closure (|
                                        Ty.apply
                                          (Ty.path "alloc::collections::btree::set::Iter")
                                          []
                                          [ T ],
                                        M.get_trait_method (|
                                          "core::clone::Clone",
                                          Ty.apply
                                            (Ty.path "alloc::collections::btree::set::Iter")
                                            []
                                            [ T ],
                                          [],
                                          [],
                                          "clone",
                                          [],
                                          []
                                        |),
                                        [
                                          M.borrow (|
                                            Pointer.Kind.Ref,
                                            M.deref (| M.read (| small_iter |) |)
                                          |)
                                        ]
                                      |));
                                    ("large_set",
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.deref (|
                                          M.read (| M.deref (| M.read (| large_set |) |) |)
                                        |)
                                      |))
                                  ]
                              |)));
                          fun γ =>
                            ltac:(M.monadic
                              (let γ := M.read (| γ |) in
                              let γ1_0 :=
                                M.SubPointer.get_struct_tuple_field (|
                                  γ,
                                  "alloc::collections::btree::set::IntersectionInner::Answer",
                                  0
                                |) in
                              let answer := M.alloc (| γ1_0 |) in
                              M.alloc (|
                                Value.StructTuple
                                  "alloc::collections::btree::set::IntersectionInner::Answer"
                                  [ M.read (| M.deref (| M.read (| answer |) |) |) ]
                              |)))
                        ]
                      |)
                    |))
                ]))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Axiom Implements :
          forall (T A : Ty.t),
          M.IsTraitInstance
            "core::clone::Clone"
            (* Trait polymorphic consts *) []
            (* Trait polymorphic types *) []
            (Self T A)
            (* Instance *) [ ("clone", InstanceField.Method (clone T A)) ].
      End Impl_core_clone_Clone_where_core_alloc_Allocator_A_where_core_clone_Clone_A_for_alloc_collections_btree_set_Intersection_T_A.
      
      Module Impl_core_iter_traits_iterator_Iterator_where_core_cmp_Ord_T_where_core_alloc_Allocator_A_where_core_clone_Clone_A_for_alloc_collections_btree_set_Intersection_T_A.
        Definition Self (T A : Ty.t) : Ty.t :=
          Ty.apply (Ty.path "alloc::collections::btree::set::Intersection") [] [ T; A ].
        
        (*     type Item = &'a T; *)
        Definition _Item (T A : Ty.t) : Ty.t := Ty.apply (Ty.path "&") [] [ T ].
        
        (*
            fn next(&mut self) -> Option<&'a T> {
                match &mut self.inner {
                    IntersectionInner::Stitch { a, b } => {
                        let mut a_next = a.next()?;
                        let mut b_next = b.next()?;
                        loop {
                            match a_next.cmp(b_next) {
                                Less => a_next = a.next()?,
                                Greater => b_next = b.next()?,
                                Equal => return Some(a_next),
                            }
                        }
                    }
                    IntersectionInner::Search { small_iter, large_set } => loop {
                        let small_next = small_iter.next()?;
                        if large_set.contains(&small_next) {
                            return Some(small_next);
                        }
                    },
                    IntersectionInner::Answer(answer) => answer.take(),
                }
            }
        *)
        Definition next (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self T A in
          match ε, τ, α with
          | [], [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              M.catch_return (|
                ltac:(M.monadic
                  (M.read (|
                    M.match_operator (|
                      Some
                        (Ty.apply
                          (Ty.path "core::option::Option")
                          []
                          [ Ty.apply (Ty.path "&") [] [ T ] ]),
                      M.alloc (|
                        M.borrow (|
                          Pointer.Kind.MutRef,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "alloc::collections::btree::set::Intersection",
                            "inner"
                          |)
                        |)
                      |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ := M.read (| γ |) in
                            let γ1_0 :=
                              M.SubPointer.get_struct_record_field (|
                                γ,
                                "alloc::collections::btree::set::IntersectionInner::Stitch",
                                "a"
                              |) in
                            let γ1_1 :=
                              M.SubPointer.get_struct_record_field (|
                                γ,
                                "alloc::collections::btree::set::IntersectionInner::Stitch",
                                "b"
                              |) in
                            let a := M.alloc (| γ1_0 |) in
                            let b := M.alloc (| γ1_1 |) in
                            let~ a_next : Ty.apply (Ty.path "&") [] [ T ] :=
                              M.copy (|
                                M.match_operator (|
                                  Some (Ty.apply (Ty.path "&") [] [ T ]),
                                  M.alloc (|
                                    M.call_closure (|
                                      Ty.apply
                                        (Ty.path "core::ops::control_flow::ControlFlow")
                                        []
                                        [
                                          Ty.apply
                                            (Ty.path "core::option::Option")
                                            []
                                            [ Ty.path "core::convert::Infallible" ];
                                          Ty.apply (Ty.path "&") [] [ T ]
                                        ],
                                      M.get_trait_method (|
                                        "core::ops::try_trait::Try",
                                        Ty.apply
                                          (Ty.path "core::option::Option")
                                          []
                                          [ Ty.apply (Ty.path "&") [] [ T ] ],
                                        [],
                                        [],
                                        "branch",
                                        [],
                                        []
                                      |),
                                      [
                                        M.call_closure (|
                                          Ty.apply
                                            (Ty.path "core::option::Option")
                                            []
                                            [ Ty.apply (Ty.path "&") [] [ T ] ],
                                          M.get_trait_method (|
                                            "core::iter::traits::iterator::Iterator",
                                            Ty.apply
                                              (Ty.path "alloc::collections::btree::set::Iter")
                                              []
                                              [ T ],
                                            [],
                                            [],
                                            "next",
                                            [],
                                            []
                                          |),
                                          [
                                            M.borrow (|
                                              Pointer.Kind.MutRef,
                                              M.deref (| M.read (| a |) |)
                                            |)
                                          ]
                                        |)
                                      ]
                                    |)
                                  |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ0_0 :=
                                          M.SubPointer.get_struct_tuple_field (|
                                            γ,
                                            "core::ops::control_flow::ControlFlow::Break",
                                            0
                                          |) in
                                        let residual := M.copy (| γ0_0 |) in
                                        M.alloc (|
                                          M.never_to_any (|
                                            M.read (|
                                              M.return_ (|
                                                M.call_closure (|
                                                  Ty.apply
                                                    (Ty.path "core::option::Option")
                                                    []
                                                    [ Ty.apply (Ty.path "&") [] [ T ] ],
                                                  M.get_trait_method (|
                                                    "core::ops::try_trait::FromResidual",
                                                    Ty.apply
                                                      (Ty.path "core::option::Option")
                                                      []
                                                      [ Ty.apply (Ty.path "&") [] [ T ] ],
                                                    [],
                                                    [
                                                      Ty.apply
                                                        (Ty.path "core::option::Option")
                                                        []
                                                        [ Ty.path "core::convert::Infallible" ]
                                                    ],
                                                    "from_residual",
                                                    [],
                                                    []
                                                  |),
                                                  [ M.read (| residual |) ]
                                                |)
                                              |)
                                            |)
                                          |)
                                        |)));
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ0_0 :=
                                          M.SubPointer.get_struct_tuple_field (|
                                            γ,
                                            "core::ops::control_flow::ControlFlow::Continue",
                                            0
                                          |) in
                                        let val := M.copy (| γ0_0 |) in
                                        val))
                                  ]
                                |)
                              |) in
                            let~ b_next : Ty.apply (Ty.path "&") [] [ T ] :=
                              M.copy (|
                                M.match_operator (|
                                  Some (Ty.apply (Ty.path "&") [] [ T ]),
                                  M.alloc (|
                                    M.call_closure (|
                                      Ty.apply
                                        (Ty.path "core::ops::control_flow::ControlFlow")
                                        []
                                        [
                                          Ty.apply
                                            (Ty.path "core::option::Option")
                                            []
                                            [ Ty.path "core::convert::Infallible" ];
                                          Ty.apply (Ty.path "&") [] [ T ]
                                        ],
                                      M.get_trait_method (|
                                        "core::ops::try_trait::Try",
                                        Ty.apply
                                          (Ty.path "core::option::Option")
                                          []
                                          [ Ty.apply (Ty.path "&") [] [ T ] ],
                                        [],
                                        [],
                                        "branch",
                                        [],
                                        []
                                      |),
                                      [
                                        M.call_closure (|
                                          Ty.apply
                                            (Ty.path "core::option::Option")
                                            []
                                            [ Ty.apply (Ty.path "&") [] [ T ] ],
                                          M.get_trait_method (|
                                            "core::iter::traits::iterator::Iterator",
                                            Ty.apply
                                              (Ty.path "alloc::collections::btree::set::Iter")
                                              []
                                              [ T ],
                                            [],
                                            [],
                                            "next",
                                            [],
                                            []
                                          |),
                                          [
                                            M.borrow (|
                                              Pointer.Kind.MutRef,
                                              M.deref (| M.read (| b |) |)
                                            |)
                                          ]
                                        |)
                                      ]
                                    |)
                                  |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ0_0 :=
                                          M.SubPointer.get_struct_tuple_field (|
                                            γ,
                                            "core::ops::control_flow::ControlFlow::Break",
                                            0
                                          |) in
                                        let residual := M.copy (| γ0_0 |) in
                                        M.alloc (|
                                          M.never_to_any (|
                                            M.read (|
                                              M.return_ (|
                                                M.call_closure (|
                                                  Ty.apply
                                                    (Ty.path "core::option::Option")
                                                    []
                                                    [ Ty.apply (Ty.path "&") [] [ T ] ],
                                                  M.get_trait_method (|
                                                    "core::ops::try_trait::FromResidual",
                                                    Ty.apply
                                                      (Ty.path "core::option::Option")
                                                      []
                                                      [ Ty.apply (Ty.path "&") [] [ T ] ],
                                                    [],
                                                    [
                                                      Ty.apply
                                                        (Ty.path "core::option::Option")
                                                        []
                                                        [ Ty.path "core::convert::Infallible" ]
                                                    ],
                                                    "from_residual",
                                                    [],
                                                    []
                                                  |),
                                                  [ M.read (| residual |) ]
                                                |)
                                              |)
                                            |)
                                          |)
                                        |)));
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ0_0 :=
                                          M.SubPointer.get_struct_tuple_field (|
                                            γ,
                                            "core::ops::control_flow::ControlFlow::Continue",
                                            0
                                          |) in
                                        let val := M.copy (| γ0_0 |) in
                                        val))
                                  ]
                                |)
                              |) in
                            M.alloc (|
                              M.never_to_any (|
                                M.read (|
                                  M.loop (|
                                    Ty.path "never",
                                    ltac:(M.monadic
                                      (M.match_operator (|
                                        Some (Ty.tuple []),
                                        M.alloc (|
                                          M.call_closure (|
                                            Ty.path "core::cmp::Ordering",
                                            M.get_trait_method (|
                                              "core::cmp::Ord",
                                              T,
                                              [],
                                              [],
                                              "cmp",
                                              [],
                                              []
                                            |),
                                            [
                                              M.borrow (|
                                                Pointer.Kind.Ref,
                                                M.deref (| M.read (| a_next |) |)
                                              |);
                                              M.borrow (|
                                                Pointer.Kind.Ref,
                                                M.deref (| M.read (| b_next |) |)
                                              |)
                                            ]
                                          |)
                                        |),
                                        [
                                          fun γ =>
                                            ltac:(M.monadic
                                              (let _ :=
                                                M.is_struct_tuple (|
                                                  γ,
                                                  "core::cmp::Ordering::Less"
                                                |) in
                                              M.alloc (|
                                                M.write (|
                                                  a_next,
                                                  M.borrow (|
                                                    Pointer.Kind.Ref,
                                                    M.deref (|
                                                      M.read (|
                                                        M.match_operator (|
                                                          Some (Ty.apply (Ty.path "&") [] [ T ]),
                                                          M.alloc (|
                                                            M.call_closure (|
                                                              Ty.apply
                                                                (Ty.path
                                                                  "core::ops::control_flow::ControlFlow")
                                                                []
                                                                [
                                                                  Ty.apply
                                                                    (Ty.path "core::option::Option")
                                                                    []
                                                                    [
                                                                      Ty.path
                                                                        "core::convert::Infallible"
                                                                    ];
                                                                  Ty.apply (Ty.path "&") [] [ T ]
                                                                ],
                                                              M.get_trait_method (|
                                                                "core::ops::try_trait::Try",
                                                                Ty.apply
                                                                  (Ty.path "core::option::Option")
                                                                  []
                                                                  [ Ty.apply (Ty.path "&") [] [ T ]
                                                                  ],
                                                                [],
                                                                [],
                                                                "branch",
                                                                [],
                                                                []
                                                              |),
                                                              [
                                                                M.call_closure (|
                                                                  Ty.apply
                                                                    (Ty.path "core::option::Option")
                                                                    []
                                                                    [
                                                                      Ty.apply
                                                                        (Ty.path "&")
                                                                        []
                                                                        [ T ]
                                                                    ],
                                                                  M.get_trait_method (|
                                                                    "core::iter::traits::iterator::Iterator",
                                                                    Ty.apply
                                                                      (Ty.path
                                                                        "alloc::collections::btree::set::Iter")
                                                                      []
                                                                      [ T ],
                                                                    [],
                                                                    [],
                                                                    "next",
                                                                    [],
                                                                    []
                                                                  |),
                                                                  [
                                                                    M.borrow (|
                                                                      Pointer.Kind.MutRef,
                                                                      M.deref (| M.read (| a |) |)
                                                                    |)
                                                                  ]
                                                                |)
                                                              ]
                                                            |)
                                                          |),
                                                          [
                                                            fun γ =>
                                                              ltac:(M.monadic
                                                                (let γ0_0 :=
                                                                  M.SubPointer.get_struct_tuple_field (|
                                                                    γ,
                                                                    "core::ops::control_flow::ControlFlow::Break",
                                                                    0
                                                                  |) in
                                                                let residual := M.copy (| γ0_0 |) in
                                                                M.alloc (|
                                                                  M.never_to_any (|
                                                                    M.read (|
                                                                      M.return_ (|
                                                                        M.call_closure (|
                                                                          Ty.apply
                                                                            (Ty.path
                                                                              "core::option::Option")
                                                                            []
                                                                            [
                                                                              Ty.apply
                                                                                (Ty.path "&")
                                                                                []
                                                                                [ T ]
                                                                            ],
                                                                          M.get_trait_method (|
                                                                            "core::ops::try_trait::FromResidual",
                                                                            Ty.apply
                                                                              (Ty.path
                                                                                "core::option::Option")
                                                                              []
                                                                              [
                                                                                Ty.apply
                                                                                  (Ty.path "&")
                                                                                  []
                                                                                  [ T ]
                                                                              ],
                                                                            [],
                                                                            [
                                                                              Ty.apply
                                                                                (Ty.path
                                                                                  "core::option::Option")
                                                                                []
                                                                                [
                                                                                  Ty.path
                                                                                    "core::convert::Infallible"
                                                                                ]
                                                                            ],
                                                                            "from_residual",
                                                                            [],
                                                                            []
                                                                          |),
                                                                          [ M.read (| residual |) ]
                                                                        |)
                                                                      |)
                                                                    |)
                                                                  |)
                                                                |)));
                                                            fun γ =>
                                                              ltac:(M.monadic
                                                                (let γ0_0 :=
                                                                  M.SubPointer.get_struct_tuple_field (|
                                                                    γ,
                                                                    "core::ops::control_flow::ControlFlow::Continue",
                                                                    0
                                                                  |) in
                                                                let val := M.copy (| γ0_0 |) in
                                                                M.alloc (|
                                                                  M.borrow (|
                                                                    Pointer.Kind.Ref,
                                                                    M.deref (| M.read (| val |) |)
                                                                  |)
                                                                |)))
                                                          ]
                                                        |)
                                                      |)
                                                    |)
                                                  |)
                                                |)
                                              |)));
                                          fun γ =>
                                            ltac:(M.monadic
                                              (let _ :=
                                                M.is_struct_tuple (|
                                                  γ,
                                                  "core::cmp::Ordering::Greater"
                                                |) in
                                              M.alloc (|
                                                M.write (|
                                                  b_next,
                                                  M.borrow (|
                                                    Pointer.Kind.Ref,
                                                    M.deref (|
                                                      M.read (|
                                                        M.match_operator (|
                                                          Some (Ty.apply (Ty.path "&") [] [ T ]),
                                                          M.alloc (|
                                                            M.call_closure (|
                                                              Ty.apply
                                                                (Ty.path
                                                                  "core::ops::control_flow::ControlFlow")
                                                                []
                                                                [
                                                                  Ty.apply
                                                                    (Ty.path "core::option::Option")
                                                                    []
                                                                    [
                                                                      Ty.path
                                                                        "core::convert::Infallible"
                                                                    ];
                                                                  Ty.apply (Ty.path "&") [] [ T ]
                                                                ],
                                                              M.get_trait_method (|
                                                                "core::ops::try_trait::Try",
                                                                Ty.apply
                                                                  (Ty.path "core::option::Option")
                                                                  []
                                                                  [ Ty.apply (Ty.path "&") [] [ T ]
                                                                  ],
                                                                [],
                                                                [],
                                                                "branch",
                                                                [],
                                                                []
                                                              |),
                                                              [
                                                                M.call_closure (|
                                                                  Ty.apply
                                                                    (Ty.path "core::option::Option")
                                                                    []
                                                                    [
                                                                      Ty.apply
                                                                        (Ty.path "&")
                                                                        []
                                                                        [ T ]
                                                                    ],
                                                                  M.get_trait_method (|
                                                                    "core::iter::traits::iterator::Iterator",
                                                                    Ty.apply
                                                                      (Ty.path
                                                                        "alloc::collections::btree::set::Iter")
                                                                      []
                                                                      [ T ],
                                                                    [],
                                                                    [],
                                                                    "next",
                                                                    [],
                                                                    []
                                                                  |),
                                                                  [
                                                                    M.borrow (|
                                                                      Pointer.Kind.MutRef,
                                                                      M.deref (| M.read (| b |) |)
                                                                    |)
                                                                  ]
                                                                |)
                                                              ]
                                                            |)
                                                          |),
                                                          [
                                                            fun γ =>
                                                              ltac:(M.monadic
                                                                (let γ0_0 :=
                                                                  M.SubPointer.get_struct_tuple_field (|
                                                                    γ,
                                                                    "core::ops::control_flow::ControlFlow::Break",
                                                                    0
                                                                  |) in
                                                                let residual := M.copy (| γ0_0 |) in
                                                                M.alloc (|
                                                                  M.never_to_any (|
                                                                    M.read (|
                                                                      M.return_ (|
                                                                        M.call_closure (|
                                                                          Ty.apply
                                                                            (Ty.path
                                                                              "core::option::Option")
                                                                            []
                                                                            [
                                                                              Ty.apply
                                                                                (Ty.path "&")
                                                                                []
                                                                                [ T ]
                                                                            ],
                                                                          M.get_trait_method (|
                                                                            "core::ops::try_trait::FromResidual",
                                                                            Ty.apply
                                                                              (Ty.path
                                                                                "core::option::Option")
                                                                              []
                                                                              [
                                                                                Ty.apply
                                                                                  (Ty.path "&")
                                                                                  []
                                                                                  [ T ]
                                                                              ],
                                                                            [],
                                                                            [
                                                                              Ty.apply
                                                                                (Ty.path
                                                                                  "core::option::Option")
                                                                                []
                                                                                [
                                                                                  Ty.path
                                                                                    "core::convert::Infallible"
                                                                                ]
                                                                            ],
                                                                            "from_residual",
                                                                            [],
                                                                            []
                                                                          |),
                                                                          [ M.read (| residual |) ]
                                                                        |)
                                                                      |)
                                                                    |)
                                                                  |)
                                                                |)));
                                                            fun γ =>
                                                              ltac:(M.monadic
                                                                (let γ0_0 :=
                                                                  M.SubPointer.get_struct_tuple_field (|
                                                                    γ,
                                                                    "core::ops::control_flow::ControlFlow::Continue",
                                                                    0
                                                                  |) in
                                                                let val := M.copy (| γ0_0 |) in
                                                                M.alloc (|
                                                                  M.borrow (|
                                                                    Pointer.Kind.Ref,
                                                                    M.deref (| M.read (| val |) |)
                                                                  |)
                                                                |)))
                                                          ]
                                                        |)
                                                      |)
                                                    |)
                                                  |)
                                                |)
                                              |)));
                                          fun γ =>
                                            ltac:(M.monadic
                                              (let _ :=
                                                M.is_struct_tuple (|
                                                  γ,
                                                  "core::cmp::Ordering::Equal"
                                                |) in
                                              M.alloc (|
                                                M.never_to_any (|
                                                  M.read (|
                                                    M.return_ (|
                                                      Value.StructTuple
                                                        "core::option::Option::Some"
                                                        [
                                                          M.borrow (|
                                                            Pointer.Kind.Ref,
                                                            M.deref (| M.read (| a_next |) |)
                                                          |)
                                                        ]
                                                    |)
                                                  |)
                                                |)
                                              |)))
                                        ]
                                      |)))
                                  |)
                                |)
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ := M.read (| γ |) in
                            let γ1_0 :=
                              M.SubPointer.get_struct_record_field (|
                                γ,
                                "alloc::collections::btree::set::IntersectionInner::Search",
                                "small_iter"
                              |) in
                            let γ1_1 :=
                              M.SubPointer.get_struct_record_field (|
                                γ,
                                "alloc::collections::btree::set::IntersectionInner::Search",
                                "large_set"
                              |) in
                            let small_iter := M.alloc (| γ1_0 |) in
                            let large_set := M.alloc (| γ1_1 |) in
                            M.alloc (|
                              M.never_to_any (|
                                M.read (|
                                  M.loop (|
                                    Ty.path "never",
                                    ltac:(M.monadic
                                      (let~ small_next : Ty.apply (Ty.path "&") [] [ T ] :=
                                        M.copy (|
                                          M.match_operator (|
                                            Some (Ty.apply (Ty.path "&") [] [ T ]),
                                            M.alloc (|
                                              M.call_closure (|
                                                Ty.apply
                                                  (Ty.path "core::ops::control_flow::ControlFlow")
                                                  []
                                                  [
                                                    Ty.apply
                                                      (Ty.path "core::option::Option")
                                                      []
                                                      [ Ty.path "core::convert::Infallible" ];
                                                    Ty.apply (Ty.path "&") [] [ T ]
                                                  ],
                                                M.get_trait_method (|
                                                  "core::ops::try_trait::Try",
                                                  Ty.apply
                                                    (Ty.path "core::option::Option")
                                                    []
                                                    [ Ty.apply (Ty.path "&") [] [ T ] ],
                                                  [],
                                                  [],
                                                  "branch",
                                                  [],
                                                  []
                                                |),
                                                [
                                                  M.call_closure (|
                                                    Ty.apply
                                                      (Ty.path "core::option::Option")
                                                      []
                                                      [ Ty.apply (Ty.path "&") [] [ T ] ],
                                                    M.get_trait_method (|
                                                      "core::iter::traits::iterator::Iterator",
                                                      Ty.apply
                                                        (Ty.path
                                                          "alloc::collections::btree::set::Iter")
                                                        []
                                                        [ T ],
                                                      [],
                                                      [],
                                                      "next",
                                                      [],
                                                      []
                                                    |),
                                                    [
                                                      M.borrow (|
                                                        Pointer.Kind.MutRef,
                                                        M.deref (| M.read (| small_iter |) |)
                                                      |)
                                                    ]
                                                  |)
                                                ]
                                              |)
                                            |),
                                            [
                                              fun γ =>
                                                ltac:(M.monadic
                                                  (let γ0_0 :=
                                                    M.SubPointer.get_struct_tuple_field (|
                                                      γ,
                                                      "core::ops::control_flow::ControlFlow::Break",
                                                      0
                                                    |) in
                                                  let residual := M.copy (| γ0_0 |) in
                                                  M.alloc (|
                                                    M.never_to_any (|
                                                      M.read (|
                                                        M.return_ (|
                                                          M.call_closure (|
                                                            Ty.apply
                                                              (Ty.path "core::option::Option")
                                                              []
                                                              [ Ty.apply (Ty.path "&") [] [ T ] ],
                                                            M.get_trait_method (|
                                                              "core::ops::try_trait::FromResidual",
                                                              Ty.apply
                                                                (Ty.path "core::option::Option")
                                                                []
                                                                [ Ty.apply (Ty.path "&") [] [ T ] ],
                                                              [],
                                                              [
                                                                Ty.apply
                                                                  (Ty.path "core::option::Option")
                                                                  []
                                                                  [
                                                                    Ty.path
                                                                      "core::convert::Infallible"
                                                                  ]
                                                              ],
                                                              "from_residual",
                                                              [],
                                                              []
                                                            |),
                                                            [ M.read (| residual |) ]
                                                          |)
                                                        |)
                                                      |)
                                                    |)
                                                  |)));
                                              fun γ =>
                                                ltac:(M.monadic
                                                  (let γ0_0 :=
                                                    M.SubPointer.get_struct_tuple_field (|
                                                      γ,
                                                      "core::ops::control_flow::ControlFlow::Continue",
                                                      0
                                                    |) in
                                                  let val := M.copy (| γ0_0 |) in
                                                  val))
                                            ]
                                          |)
                                        |) in
                                      M.match_operator (|
                                        Some (Ty.tuple []),
                                        M.alloc (| Value.Tuple [] |),
                                        [
                                          fun γ =>
                                            ltac:(M.monadic
                                              (let γ :=
                                                M.use
                                                  (M.alloc (|
                                                    M.call_closure (|
                                                      Ty.path "bool",
                                                      M.get_associated_function (|
                                                        Ty.apply
                                                          (Ty.path
                                                            "alloc::collections::btree::set::BTreeSet")
                                                          []
                                                          [ T; A ],
                                                        "contains",
                                                        [],
                                                        [ T ]
                                                      |),
                                                      [
                                                        M.borrow (|
                                                          Pointer.Kind.Ref,
                                                          M.deref (|
                                                            M.read (|
                                                              M.deref (| M.read (| large_set |) |)
                                                            |)
                                                          |)
                                                        |);
                                                        M.borrow (|
                                                          Pointer.Kind.Ref,
                                                          M.deref (|
                                                            M.read (|
                                                              M.deref (|
                                                                M.borrow (|
                                                                  Pointer.Kind.Ref,
                                                                  small_next
                                                                |)
                                                              |)
                                                            |)
                                                          |)
                                                        |)
                                                      ]
                                                    |)
                                                  |)) in
                                              let _ :=
                                                is_constant_or_break_match (|
                                                  M.read (| γ |),
                                                  Value.Bool true
                                                |) in
                                              M.alloc (|
                                                M.never_to_any (|
                                                  M.read (|
                                                    M.return_ (|
                                                      Value.StructTuple
                                                        "core::option::Option::Some"
                                                        [
                                                          M.borrow (|
                                                            Pointer.Kind.Ref,
                                                            M.deref (| M.read (| small_next |) |)
                                                          |)
                                                        ]
                                                    |)
                                                  |)
                                                |)
                                              |)));
                                          fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                                        ]
                                      |)))
                                  |)
                                |)
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ := M.read (| γ |) in
                            let γ1_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "alloc::collections::btree::set::IntersectionInner::Answer",
                                0
                              |) in
                            let answer := M.alloc (| γ1_0 |) in
                            M.alloc (|
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "core::option::Option")
                                  []
                                  [ Ty.apply (Ty.path "&") [] [ T ] ],
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "core::option::Option")
                                    []
                                    [ Ty.apply (Ty.path "&") [] [ T ] ],
                                  "take",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (|
                                    Pointer.Kind.MutRef,
                                    M.deref (| M.read (| answer |) |)
                                  |)
                                ]
                              |)
                            |)))
                      ]
                    |)
                  |)))
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        (*
            fn size_hint(&self) -> (usize, Option<usize>) {
                match &self.inner {
                    IntersectionInner::Stitch { a, b } => (0, Some(min(a.len(), b.len()))),
                    IntersectionInner::Search { small_iter, .. } => (0, Some(small_iter.len())),
                    IntersectionInner::Answer(None) => (0, Some(0)),
                    IntersectionInner::Answer(Some(_)) => (1, Some(1)),
                }
            }
        *)
        Definition size_hint
            (T A : Ty.t)
            (ε : list Value.t)
            (τ : list Ty.t)
            (α : list Value.t)
            : M :=
          let Self : Ty.t := Self T A in
          match ε, τ, α with
          | [], [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              M.read (|
                M.match_operator (|
                  Some
                    (Ty.tuple
                      [
                        Ty.path "usize";
                        Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "usize" ]
                      ]),
                  M.alloc (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "alloc::collections::btree::set::Intersection",
                        "inner"
                      |)
                    |)
                  |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        let γ1_0 :=
                          M.SubPointer.get_struct_record_field (|
                            γ,
                            "alloc::collections::btree::set::IntersectionInner::Stitch",
                            "a"
                          |) in
                        let γ1_1 :=
                          M.SubPointer.get_struct_record_field (|
                            γ,
                            "alloc::collections::btree::set::IntersectionInner::Stitch",
                            "b"
                          |) in
                        let a := M.alloc (| γ1_0 |) in
                        let b := M.alloc (| γ1_1 |) in
                        M.alloc (|
                          Value.Tuple
                            [
                              Value.Integer IntegerKind.Usize 0;
                              Value.StructTuple
                                "core::option::Option::Some"
                                [
                                  M.call_closure (|
                                    Ty.path "usize",
                                    M.get_function (| "core::cmp::min", [], [ Ty.path "usize" ] |),
                                    [
                                      M.call_closure (|
                                        Ty.path "usize",
                                        M.get_trait_method (|
                                          "core::iter::traits::exact_size::ExactSizeIterator",
                                          Ty.apply
                                            (Ty.path "alloc::collections::btree::set::Iter")
                                            []
                                            [ T ],
                                          [],
                                          [],
                                          "len",
                                          [],
                                          []
                                        |),
                                        [
                                          M.borrow (|
                                            Pointer.Kind.Ref,
                                            M.deref (| M.read (| a |) |)
                                          |)
                                        ]
                                      |);
                                      M.call_closure (|
                                        Ty.path "usize",
                                        M.get_trait_method (|
                                          "core::iter::traits::exact_size::ExactSizeIterator",
                                          Ty.apply
                                            (Ty.path "alloc::collections::btree::set::Iter")
                                            []
                                            [ T ],
                                          [],
                                          [],
                                          "len",
                                          [],
                                          []
                                        |),
                                        [
                                          M.borrow (|
                                            Pointer.Kind.Ref,
                                            M.deref (| M.read (| b |) |)
                                          |)
                                        ]
                                      |)
                                    ]
                                  |)
                                ]
                            ]
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        let γ1_0 :=
                          M.SubPointer.get_struct_record_field (|
                            γ,
                            "alloc::collections::btree::set::IntersectionInner::Search",
                            "small_iter"
                          |) in
                        let small_iter := M.alloc (| γ1_0 |) in
                        M.alloc (|
                          Value.Tuple
                            [
                              Value.Integer IntegerKind.Usize 0;
                              Value.StructTuple
                                "core::option::Option::Some"
                                [
                                  M.call_closure (|
                                    Ty.path "usize",
                                    M.get_trait_method (|
                                      "core::iter::traits::exact_size::ExactSizeIterator",
                                      Ty.apply
                                        (Ty.path "alloc::collections::btree::set::Iter")
                                        []
                                        [ T ],
                                      [],
                                      [],
                                      "len",
                                      [],
                                      []
                                    |),
                                    [
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.deref (| M.read (| small_iter |) |)
                                      |)
                                    ]
                                  |)
                                ]
                            ]
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        let γ1_0 :=
                          M.SubPointer.get_struct_tuple_field (|
                            γ,
                            "alloc::collections::btree::set::IntersectionInner::Answer",
                            0
                          |) in
                        let _ := M.is_struct_tuple (| γ1_0, "core::option::Option::None" |) in
                        M.alloc (|
                          Value.Tuple
                            [
                              Value.Integer IntegerKind.Usize 0;
                              Value.StructTuple
                                "core::option::Option::Some"
                                [ Value.Integer IntegerKind.Usize 0 ]
                            ]
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        let γ1_0 :=
                          M.SubPointer.get_struct_tuple_field (|
                            γ,
                            "alloc::collections::btree::set::IntersectionInner::Answer",
                            0
                          |) in
                        let γ2_0 :=
                          M.SubPointer.get_struct_tuple_field (|
                            γ1_0,
                            "core::option::Option::Some",
                            0
                          |) in
                        M.alloc (|
                          Value.Tuple
                            [
                              Value.Integer IntegerKind.Usize 1;
                              Value.StructTuple
                                "core::option::Option::Some"
                                [ Value.Integer IntegerKind.Usize 1 ]
                            ]
                        |)))
                  ]
                |)
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        (*
            fn min(mut self) -> Option<&'a T> {
                self.next()
            }
        *)
        Definition min (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self T A in
          match ε, τ, α with
          | [], [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              M.call_closure (|
                Ty.apply (Ty.path "core::option::Option") [] [ Ty.apply (Ty.path "&") [] [ T ] ],
                M.get_trait_method (|
                  "core::iter::traits::iterator::Iterator",
                  Ty.apply (Ty.path "alloc::collections::btree::set::Intersection") [] [ T; A ],
                  [],
                  [],
                  "next",
                  [],
                  []
                |),
                [ M.borrow (| Pointer.Kind.MutRef, self |) ]
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Axiom Implements :
          forall (T A : Ty.t),
          M.IsTraitInstance
            "core::iter::traits::iterator::Iterator"
            (* Trait polymorphic consts *) []
            (* Trait polymorphic types *) []
            (Self T A)
            (* Instance *)
            [
              ("Item", InstanceField.Ty (_Item T A));
              ("next", InstanceField.Method (next T A));
              ("size_hint", InstanceField.Method (size_hint T A));
              ("min", InstanceField.Method (min T A))
            ].
      End Impl_core_iter_traits_iterator_Iterator_where_core_cmp_Ord_T_where_core_alloc_Allocator_A_where_core_clone_Clone_A_for_alloc_collections_btree_set_Intersection_T_A.
      
      Module Impl_core_iter_traits_marker_FusedIterator_where_core_cmp_Ord_T_where_core_alloc_Allocator_A_where_core_clone_Clone_A_for_alloc_collections_btree_set_Intersection_T_A.
        Definition Self (T A : Ty.t) : Ty.t :=
          Ty.apply (Ty.path "alloc::collections::btree::set::Intersection") [] [ T; A ].
        
        Axiom Implements :
          forall (T A : Ty.t),
          M.IsTraitInstance
            "core::iter::traits::marker::FusedIterator"
            (* Trait polymorphic consts *) []
            (* Trait polymorphic types *) []
            (Self T A)
            (* Instance *) [].
      End Impl_core_iter_traits_marker_FusedIterator_where_core_cmp_Ord_T_where_core_alloc_Allocator_A_where_core_clone_Clone_A_for_alloc_collections_btree_set_Intersection_T_A.
      
      Module Impl_core_clone_Clone_for_alloc_collections_btree_set_Union_T.
        Definition Self (T : Ty.t) : Ty.t :=
          Ty.apply (Ty.path "alloc::collections::btree::set::Union") [] [ T ].
        
        (*
            fn clone(&self) -> Self {
                Union(self.0.clone())
            }
        *)
        Definition clone (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self T in
          match ε, τ, α with
          | [], [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              Value.StructTuple
                "alloc::collections::btree::set::Union"
                [
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "alloc::collections::btree::merge_iter::MergeIterInner")
                      []
                      [ Ty.apply (Ty.path "alloc::collections::btree::set::Iter") [] [ T ] ],
                    M.get_trait_method (|
                      "core::clone::Clone",
                      Ty.apply
                        (Ty.path "alloc::collections::btree::merge_iter::MergeIterInner")
                        []
                        [ Ty.apply (Ty.path "alloc::collections::btree::set::Iter") [] [ T ] ],
                      [],
                      [],
                      "clone",
                      [],
                      []
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.SubPointer.get_struct_tuple_field (|
                          M.deref (| M.read (| self |) |),
                          "alloc::collections::btree::set::Union",
                          0
                        |)
                      |)
                    ]
                  |)
                ]))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Axiom Implements :
          forall (T : Ty.t),
          M.IsTraitInstance
            "core::clone::Clone"
            (* Trait polymorphic consts *) []
            (* Trait polymorphic types *) []
            (Self T)
            (* Instance *) [ ("clone", InstanceField.Method (clone T)) ].
      End Impl_core_clone_Clone_for_alloc_collections_btree_set_Union_T.
      
      Module Impl_core_iter_traits_iterator_Iterator_where_core_cmp_Ord_T_for_alloc_collections_btree_set_Union_T.
        Definition Self (T : Ty.t) : Ty.t :=
          Ty.apply (Ty.path "alloc::collections::btree::set::Union") [] [ T ].
        
        (*     type Item = &'a T; *)
        Definition _Item (T : Ty.t) : Ty.t := Ty.apply (Ty.path "&") [] [ T ].
        
        (*
            fn next(&mut self) -> Option<&'a T> {
                let (a_next, b_next) = self.0.nexts(Self::Item::cmp);
                a_next.or(b_next)
            }
        *)
        Definition next (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self T in
          match ε, τ, α with
          | [], [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              M.read (|
                M.match_operator (|
                  None,
                  M.alloc (|
                    M.call_closure (|
                      Ty.tuple
                        [
                          Ty.apply
                            (Ty.path "core::option::Option")
                            []
                            [ Ty.apply (Ty.path "&") [] [ T ] ];
                          Ty.apply
                            (Ty.path "core::option::Option")
                            []
                            [ Ty.apply (Ty.path "&") [] [ T ] ]
                        ],
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "alloc::collections::btree::merge_iter::MergeIterInner")
                          []
                          [ Ty.apply (Ty.path "alloc::collections::btree::set::Iter") [] [ T ] ],
                        "nexts",
                        [],
                        [
                          Ty.function
                            [
                              Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "&") [] [ T ] ];
                              Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "&") [] [ T ] ]
                            ]
                            (Ty.path "core::cmp::Ordering")
                        ]
                      |),
                      [
                        M.borrow (|
                          Pointer.Kind.MutRef,
                          M.SubPointer.get_struct_tuple_field (|
                            M.deref (| M.read (| self |) |),
                            "alloc::collections::btree::set::Union",
                            0
                          |)
                        |);
                        M.get_trait_method (|
                          "core::cmp::Ord",
                          Ty.apply (Ty.path "&") [] [ T ],
                          [],
                          [],
                          "cmp",
                          [],
                          []
                        |)
                      ]
                    |)
                  |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                        let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                        let a_next := M.copy (| γ0_0 |) in
                        let b_next := M.copy (| γ0_1 |) in
                        M.alloc (|
                          M.call_closure (|
                            Ty.apply
                              (Ty.path "core::option::Option")
                              []
                              [ Ty.apply (Ty.path "&") [] [ T ] ],
                            M.get_associated_function (|
                              Ty.apply
                                (Ty.path "core::option::Option")
                                []
                                [ Ty.apply (Ty.path "&") [] [ T ] ],
                              "or",
                              [],
                              []
                            |),
                            [ M.read (| a_next |); M.read (| b_next |) ]
                          |)
                        |)))
                  ]
                |)
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        (*
            fn size_hint(&self) -> (usize, Option<usize>) {
                let (a_len, b_len) = self.0.lens();
                // No checked_add - see SymmetricDifference::size_hint.
                (max(a_len, b_len), Some(a_len + b_len))
            }
        *)
        Definition size_hint (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self T in
          match ε, τ, α with
          | [], [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              M.read (|
                M.match_operator (|
                  None,
                  M.alloc (|
                    M.call_closure (|
                      Ty.tuple [ Ty.path "usize"; Ty.path "usize" ],
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "alloc::collections::btree::merge_iter::MergeIterInner")
                          []
                          [ Ty.apply (Ty.path "alloc::collections::btree::set::Iter") [] [ T ] ],
                        "lens",
                        [],
                        []
                      |),
                      [
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_tuple_field (|
                            M.deref (| M.read (| self |) |),
                            "alloc::collections::btree::set::Union",
                            0
                          |)
                        |)
                      ]
                    |)
                  |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                        let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                        let a_len := M.copy (| γ0_0 |) in
                        let b_len := M.copy (| γ0_1 |) in
                        M.alloc (|
                          Value.Tuple
                            [
                              M.call_closure (|
                                Ty.path "usize",
                                M.get_function (| "core::cmp::max", [], [ Ty.path "usize" ] |),
                                [ M.read (| a_len |); M.read (| b_len |) ]
                              |);
                              Value.StructTuple
                                "core::option::Option::Some"
                                [
                                  M.call_closure (|
                                    Ty.path "usize",
                                    BinOp.Wrap.add,
                                    [ M.read (| a_len |); M.read (| b_len |) ]
                                  |)
                                ]
                            ]
                        |)))
                  ]
                |)
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        (*
            fn min(mut self) -> Option<&'a T> {
                self.next()
            }
        *)
        Definition min (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self T in
          match ε, τ, α with
          | [], [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              M.call_closure (|
                Ty.apply (Ty.path "core::option::Option") [] [ Ty.apply (Ty.path "&") [] [ T ] ],
                M.get_trait_method (|
                  "core::iter::traits::iterator::Iterator",
                  Ty.apply (Ty.path "alloc::collections::btree::set::Union") [] [ T ],
                  [],
                  [],
                  "next",
                  [],
                  []
                |),
                [ M.borrow (| Pointer.Kind.MutRef, self |) ]
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Axiom Implements :
          forall (T : Ty.t),
          M.IsTraitInstance
            "core::iter::traits::iterator::Iterator"
            (* Trait polymorphic consts *) []
            (* Trait polymorphic types *) []
            (Self T)
            (* Instance *)
            [
              ("Item", InstanceField.Ty (_Item T));
              ("next", InstanceField.Method (next T));
              ("size_hint", InstanceField.Method (size_hint T));
              ("min", InstanceField.Method (min T))
            ].
      End Impl_core_iter_traits_iterator_Iterator_where_core_cmp_Ord_T_for_alloc_collections_btree_set_Union_T.
      
      Module Impl_core_iter_traits_marker_FusedIterator_where_core_cmp_Ord_T_for_alloc_collections_btree_set_Union_T.
        Definition Self (T : Ty.t) : Ty.t :=
          Ty.apply (Ty.path "alloc::collections::btree::set::Union") [] [ T ].
        
        Axiom Implements :
          forall (T : Ty.t),
          M.IsTraitInstance
            "core::iter::traits::marker::FusedIterator"
            (* Trait polymorphic consts *) []
            (* Trait polymorphic types *) []
            (Self T)
            (* Instance *) [].
      End Impl_core_iter_traits_marker_FusedIterator_where_core_cmp_Ord_T_for_alloc_collections_btree_set_Union_T.
      
      (* StructRecord
        {
          name := "Cursor";
          const_params := [];
          ty_params := [ "K" ];
          fields :=
            [
              ("inner",
                Ty.apply
                  (Ty.path "alloc::collections::btree::map::Cursor")
                  []
                  [ K; Ty.path "alloc::collections::btree::set_val::SetValZST" ])
            ];
        } *)
      
      Module Impl_core_clone_Clone_where_core_clone_Clone_K_for_alloc_collections_btree_set_Cursor_K.
        Definition Self (K : Ty.t) : Ty.t :=
          Ty.apply (Ty.path "alloc::collections::btree::set::Cursor") [] [ K ].
        
        (* Clone *)
        Definition clone (K : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self K in
          match ε, τ, α with
          | [], [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              Value.StructRecord
                "alloc::collections::btree::set::Cursor"
                [
                  ("inner",
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "alloc::collections::btree::map::Cursor")
                        []
                        [ K; Ty.path "alloc::collections::btree::set_val::SetValZST" ],
                      M.get_trait_method (|
                        "core::clone::Clone",
                        Ty.apply
                          (Ty.path "alloc::collections::btree::map::Cursor")
                          []
                          [ K; Ty.path "alloc::collections::btree::set_val::SetValZST" ],
                        [],
                        [],
                        "clone",
                        [],
                        []
                      |),
                      [
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.deref (|
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.SubPointer.get_struct_record_field (|
                                M.deref (| M.read (| self |) |),
                                "alloc::collections::btree::set::Cursor",
                                "inner"
                              |)
                            |)
                          |)
                        |)
                      ]
                    |))
                ]))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Axiom Implements :
          forall (K : Ty.t),
          M.IsTraitInstance
            "core::clone::Clone"
            (* Trait polymorphic consts *) []
            (* Trait polymorphic types *) []
            (Self K)
            (* Instance *) [ ("clone", InstanceField.Method (clone K)) ].
      End Impl_core_clone_Clone_where_core_clone_Clone_K_for_alloc_collections_btree_set_Cursor_K.
      
      Module Impl_core_fmt_Debug_where_core_fmt_Debug_K_for_alloc_collections_btree_set_Cursor_K.
        Definition Self (K : Ty.t) : Ty.t :=
          Ty.apply (Ty.path "alloc::collections::btree::set::Cursor") [] [ K ].
        
        (*
            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                f.write_str("Cursor")
            }
        *)
        Definition fmt (K : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self K in
          match ε, τ, α with
          | [], [], [ self; f ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let f := M.alloc (| f |) in
              M.call_closure (|
                Ty.apply
                  (Ty.path "core::result::Result")
                  []
                  [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                M.get_associated_function (| Ty.path "core::fmt::Formatter", "write_str", [], [] |),
                [
                  M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                  M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "Cursor" |) |) |)
                ]
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Axiom Implements :
          forall (K : Ty.t),
          M.IsTraitInstance
            "core::fmt::Debug"
            (* Trait polymorphic consts *) []
            (* Trait polymorphic types *) []
            (Self K)
            (* Instance *) [ ("fmt", InstanceField.Method (fmt K)) ].
      End Impl_core_fmt_Debug_where_core_fmt_Debug_K_for_alloc_collections_btree_set_Cursor_K.
      
      (* StructRecord
        {
          name := "CursorMut";
          const_params := [];
          ty_params := [ "K"; "A" ];
          fields :=
            [
              ("inner",
                Ty.apply
                  (Ty.path "alloc::collections::btree::map::CursorMut")
                  []
                  [ K; Ty.path "alloc::collections::btree::set_val::SetValZST"; A ])
            ];
        } *)
      
      Module Impl_core_fmt_Debug_where_core_fmt_Debug_K_for_alloc_collections_btree_set_CursorMut_K_A.
        Definition Self (K A : Ty.t) : Ty.t :=
          Ty.apply (Ty.path "alloc::collections::btree::set::CursorMut") [] [ K; A ].
        
        (*
            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                f.write_str("CursorMut")
            }
        *)
        Definition fmt (K A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self K A in
          match ε, τ, α with
          | [], [], [ self; f ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let f := M.alloc (| f |) in
              M.call_closure (|
                Ty.apply
                  (Ty.path "core::result::Result")
                  []
                  [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                M.get_associated_function (| Ty.path "core::fmt::Formatter", "write_str", [], [] |),
                [
                  M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                  M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "CursorMut" |) |) |)
                ]
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Axiom Implements :
          forall (K A : Ty.t),
          M.IsTraitInstance
            "core::fmt::Debug"
            (* Trait polymorphic consts *) []
            (* Trait polymorphic types *) []
            (Self K A)
            (* Instance *) [ ("fmt", InstanceField.Method (fmt K A)) ].
      End Impl_core_fmt_Debug_where_core_fmt_Debug_K_for_alloc_collections_btree_set_CursorMut_K_A.
      
      (* StructRecord
        {
          name := "CursorMutKey";
          const_params := [];
          ty_params := [ "K"; "A" ];
          fields :=
            [
              ("inner",
                Ty.apply
                  (Ty.path "alloc::collections::btree::map::CursorMutKey")
                  []
                  [ K; Ty.path "alloc::collections::btree::set_val::SetValZST"; A ])
            ];
        } *)
      
      Module Impl_core_fmt_Debug_where_core_fmt_Debug_K_for_alloc_collections_btree_set_CursorMutKey_K_A.
        Definition Self (K A : Ty.t) : Ty.t :=
          Ty.apply (Ty.path "alloc::collections::btree::set::CursorMutKey") [] [ K; A ].
        
        (*
            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                f.write_str("CursorMutKey")
            }
        *)
        Definition fmt (K A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self K A in
          match ε, τ, α with
          | [], [], [ self; f ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let f := M.alloc (| f |) in
              M.call_closure (|
                Ty.apply
                  (Ty.path "core::result::Result")
                  []
                  [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                M.get_associated_function (| Ty.path "core::fmt::Formatter", "write_str", [], [] |),
                [
                  M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                  M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "CursorMutKey" |) |) |)
                ]
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Axiom Implements :
          forall (K A : Ty.t),
          M.IsTraitInstance
            "core::fmt::Debug"
            (* Trait polymorphic consts *) []
            (* Trait polymorphic types *) []
            (Self K A)
            (* Instance *) [ ("fmt", InstanceField.Method (fmt K A)) ].
      End Impl_core_fmt_Debug_where_core_fmt_Debug_K_for_alloc_collections_btree_set_CursorMutKey_K_A.
      
      Module Impl_alloc_collections_btree_set_Cursor_K.
        Definition Self (K : Ty.t) : Ty.t :=
          Ty.apply (Ty.path "alloc::collections::btree::set::Cursor") [] [ K ].
        
        (*
            pub fn next(&mut self) -> Option<&'a K> {
                self.inner.next().map(|(k, _)| k)
            }
        *)
        Definition next (K : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self K in
          match ε, τ, α with
          | [], [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              M.call_closure (|
                Ty.apply (Ty.path "core::option::Option") [] [ Ty.apply (Ty.path "&") [] [ K ] ],
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "core::option::Option")
                    []
                    [
                      Ty.tuple
                        [
                          Ty.apply (Ty.path "&") [] [ K ];
                          Ty.apply
                            (Ty.path "&")
                            []
                            [ Ty.path "alloc::collections::btree::set_val::SetValZST" ]
                        ]
                    ],
                  "map",
                  [],
                  [
                    Ty.apply (Ty.path "&") [] [ K ];
                    Ty.function
                      [
                        Ty.tuple
                          [
                            Ty.tuple
                              [
                                Ty.apply (Ty.path "&") [] [ K ];
                                Ty.apply
                                  (Ty.path "&")
                                  []
                                  [ Ty.path "alloc::collections::btree::set_val::SetValZST" ]
                              ]
                          ]
                      ]
                      (Ty.apply (Ty.path "&") [] [ K ])
                  ]
                |),
                [
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "core::option::Option")
                      []
                      [
                        Ty.tuple
                          [
                            Ty.apply (Ty.path "&") [] [ K ];
                            Ty.apply
                              (Ty.path "&")
                              []
                              [ Ty.path "alloc::collections::btree::set_val::SetValZST" ]
                          ]
                      ],
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "alloc::collections::btree::map::Cursor")
                        []
                        [ K; Ty.path "alloc::collections::btree::set_val::SetValZST" ],
                      "next",
                      [],
                      []
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.MutRef,
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "alloc::collections::btree::set::Cursor",
                          "inner"
                        |)
                      |)
                    ]
                  |);
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0 ] =>
                          ltac:(M.monadic
                            (M.match_operator (|
                              Some
                                (Ty.function
                                  [
                                    Ty.tuple
                                      [
                                        Ty.tuple
                                          [
                                            Ty.apply (Ty.path "&") [] [ K ];
                                            Ty.apply
                                              (Ty.path "&")
                                              []
                                              [
                                                Ty.path
                                                  "alloc::collections::btree::set_val::SetValZST"
                                              ]
                                          ]
                                      ]
                                  ]
                                  (Ty.apply (Ty.path "&") [] [ K ])),
                              M.alloc (| α0 |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                    let k := M.copy (| γ0_0 |) in
                                    M.read (| k |)))
                              ]
                            |)))
                        | _ => M.impossible "wrong number of arguments"
                        end))
                ]
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Global Instance AssociatedFunction_next :
          forall (K : Ty.t),
          M.IsAssociatedFunction.C (Self K) "next" (next K).
        Admitted.
        Global Typeclasses Opaque next.
        
        (*
            pub fn prev(&mut self) -> Option<&'a K> {
                self.inner.prev().map(|(k, _)| k)
            }
        *)
        Definition prev (K : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self K in
          match ε, τ, α with
          | [], [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              M.call_closure (|
                Ty.apply (Ty.path "core::option::Option") [] [ Ty.apply (Ty.path "&") [] [ K ] ],
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "core::option::Option")
                    []
                    [
                      Ty.tuple
                        [
                          Ty.apply (Ty.path "&") [] [ K ];
                          Ty.apply
                            (Ty.path "&")
                            []
                            [ Ty.path "alloc::collections::btree::set_val::SetValZST" ]
                        ]
                    ],
                  "map",
                  [],
                  [
                    Ty.apply (Ty.path "&") [] [ K ];
                    Ty.function
                      [
                        Ty.tuple
                          [
                            Ty.tuple
                              [
                                Ty.apply (Ty.path "&") [] [ K ];
                                Ty.apply
                                  (Ty.path "&")
                                  []
                                  [ Ty.path "alloc::collections::btree::set_val::SetValZST" ]
                              ]
                          ]
                      ]
                      (Ty.apply (Ty.path "&") [] [ K ])
                  ]
                |),
                [
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "core::option::Option")
                      []
                      [
                        Ty.tuple
                          [
                            Ty.apply (Ty.path "&") [] [ K ];
                            Ty.apply
                              (Ty.path "&")
                              []
                              [ Ty.path "alloc::collections::btree::set_val::SetValZST" ]
                          ]
                      ],
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "alloc::collections::btree::map::Cursor")
                        []
                        [ K; Ty.path "alloc::collections::btree::set_val::SetValZST" ],
                      "prev",
                      [],
                      []
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.MutRef,
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "alloc::collections::btree::set::Cursor",
                          "inner"
                        |)
                      |)
                    ]
                  |);
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0 ] =>
                          ltac:(M.monadic
                            (M.match_operator (|
                              Some
                                (Ty.function
                                  [
                                    Ty.tuple
                                      [
                                        Ty.tuple
                                          [
                                            Ty.apply (Ty.path "&") [] [ K ];
                                            Ty.apply
                                              (Ty.path "&")
                                              []
                                              [
                                                Ty.path
                                                  "alloc::collections::btree::set_val::SetValZST"
                                              ]
                                          ]
                                      ]
                                  ]
                                  (Ty.apply (Ty.path "&") [] [ K ])),
                              M.alloc (| α0 |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                    let k := M.copy (| γ0_0 |) in
                                    M.read (| k |)))
                              ]
                            |)))
                        | _ => M.impossible "wrong number of arguments"
                        end))
                ]
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Global Instance AssociatedFunction_prev :
          forall (K : Ty.t),
          M.IsAssociatedFunction.C (Self K) "prev" (prev K).
        Admitted.
        Global Typeclasses Opaque prev.
        
        (*
            pub fn peek_next(&self) -> Option<&'a K> {
                self.inner.peek_next().map(|(k, _)| k)
            }
        *)
        Definition peek_next (K : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self K in
          match ε, τ, α with
          | [], [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              M.call_closure (|
                Ty.apply (Ty.path "core::option::Option") [] [ Ty.apply (Ty.path "&") [] [ K ] ],
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "core::option::Option")
                    []
                    [
                      Ty.tuple
                        [
                          Ty.apply (Ty.path "&") [] [ K ];
                          Ty.apply
                            (Ty.path "&")
                            []
                            [ Ty.path "alloc::collections::btree::set_val::SetValZST" ]
                        ]
                    ],
                  "map",
                  [],
                  [
                    Ty.apply (Ty.path "&") [] [ K ];
                    Ty.function
                      [
                        Ty.tuple
                          [
                            Ty.tuple
                              [
                                Ty.apply (Ty.path "&") [] [ K ];
                                Ty.apply
                                  (Ty.path "&")
                                  []
                                  [ Ty.path "alloc::collections::btree::set_val::SetValZST" ]
                              ]
                          ]
                      ]
                      (Ty.apply (Ty.path "&") [] [ K ])
                  ]
                |),
                [
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "core::option::Option")
                      []
                      [
                        Ty.tuple
                          [
                            Ty.apply (Ty.path "&") [] [ K ];
                            Ty.apply
                              (Ty.path "&")
                              []
                              [ Ty.path "alloc::collections::btree::set_val::SetValZST" ]
                          ]
                      ],
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "alloc::collections::btree::map::Cursor")
                        []
                        [ K; Ty.path "alloc::collections::btree::set_val::SetValZST" ],
                      "peek_next",
                      [],
                      []
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "alloc::collections::btree::set::Cursor",
                          "inner"
                        |)
                      |)
                    ]
                  |);
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0 ] =>
                          ltac:(M.monadic
                            (M.match_operator (|
                              Some
                                (Ty.function
                                  [
                                    Ty.tuple
                                      [
                                        Ty.tuple
                                          [
                                            Ty.apply (Ty.path "&") [] [ K ];
                                            Ty.apply
                                              (Ty.path "&")
                                              []
                                              [
                                                Ty.path
                                                  "alloc::collections::btree::set_val::SetValZST"
                                              ]
                                          ]
                                      ]
                                  ]
                                  (Ty.apply (Ty.path "&") [] [ K ])),
                              M.alloc (| α0 |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                    let k := M.copy (| γ0_0 |) in
                                    M.read (| k |)))
                              ]
                            |)))
                        | _ => M.impossible "wrong number of arguments"
                        end))
                ]
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Global Instance AssociatedFunction_peek_next :
          forall (K : Ty.t),
          M.IsAssociatedFunction.C (Self K) "peek_next" (peek_next K).
        Admitted.
        Global Typeclasses Opaque peek_next.
        
        (*
            pub fn peek_prev(&self) -> Option<&'a K> {
                self.inner.peek_prev().map(|(k, _)| k)
            }
        *)
        Definition peek_prev (K : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self K in
          match ε, τ, α with
          | [], [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              M.call_closure (|
                Ty.apply (Ty.path "core::option::Option") [] [ Ty.apply (Ty.path "&") [] [ K ] ],
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "core::option::Option")
                    []
                    [
                      Ty.tuple
                        [
                          Ty.apply (Ty.path "&") [] [ K ];
                          Ty.apply
                            (Ty.path "&")
                            []
                            [ Ty.path "alloc::collections::btree::set_val::SetValZST" ]
                        ]
                    ],
                  "map",
                  [],
                  [
                    Ty.apply (Ty.path "&") [] [ K ];
                    Ty.function
                      [
                        Ty.tuple
                          [
                            Ty.tuple
                              [
                                Ty.apply (Ty.path "&") [] [ K ];
                                Ty.apply
                                  (Ty.path "&")
                                  []
                                  [ Ty.path "alloc::collections::btree::set_val::SetValZST" ]
                              ]
                          ]
                      ]
                      (Ty.apply (Ty.path "&") [] [ K ])
                  ]
                |),
                [
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "core::option::Option")
                      []
                      [
                        Ty.tuple
                          [
                            Ty.apply (Ty.path "&") [] [ K ];
                            Ty.apply
                              (Ty.path "&")
                              []
                              [ Ty.path "alloc::collections::btree::set_val::SetValZST" ]
                          ]
                      ],
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "alloc::collections::btree::map::Cursor")
                        []
                        [ K; Ty.path "alloc::collections::btree::set_val::SetValZST" ],
                      "peek_prev",
                      [],
                      []
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "alloc::collections::btree::set::Cursor",
                          "inner"
                        |)
                      |)
                    ]
                  |);
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0 ] =>
                          ltac:(M.monadic
                            (M.match_operator (|
                              Some
                                (Ty.function
                                  [
                                    Ty.tuple
                                      [
                                        Ty.tuple
                                          [
                                            Ty.apply (Ty.path "&") [] [ K ];
                                            Ty.apply
                                              (Ty.path "&")
                                              []
                                              [
                                                Ty.path
                                                  "alloc::collections::btree::set_val::SetValZST"
                                              ]
                                          ]
                                      ]
                                  ]
                                  (Ty.apply (Ty.path "&") [] [ K ])),
                              M.alloc (| α0 |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                    let k := M.copy (| γ0_0 |) in
                                    M.read (| k |)))
                              ]
                            |)))
                        | _ => M.impossible "wrong number of arguments"
                        end))
                ]
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Global Instance AssociatedFunction_peek_prev :
          forall (K : Ty.t),
          M.IsAssociatedFunction.C (Self K) "peek_prev" (peek_prev K).
        Admitted.
        Global Typeclasses Opaque peek_prev.
      End Impl_alloc_collections_btree_set_Cursor_K.
      
      Module Impl_alloc_collections_btree_set_CursorMut_T_A.
        Definition Self (T A : Ty.t) : Ty.t :=
          Ty.apply (Ty.path "alloc::collections::btree::set::CursorMut") [] [ T; A ].
        
        (*
            pub fn next(&mut self) -> Option<&T> {
                self.inner.next().map(|(k, _)| k)
            }
        *)
        Definition next (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self T A in
          match ε, τ, α with
          | [], [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              M.call_closure (|
                Ty.apply (Ty.path "core::option::Option") [] [ Ty.apply (Ty.path "&") [] [ T ] ],
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "core::option::Option")
                    []
                    [
                      Ty.tuple
                        [
                          Ty.apply (Ty.path "&") [] [ T ];
                          Ty.apply
                            (Ty.path "&mut")
                            []
                            [ Ty.path "alloc::collections::btree::set_val::SetValZST" ]
                        ]
                    ],
                  "map",
                  [],
                  [
                    Ty.apply (Ty.path "&") [] [ T ];
                    Ty.function
                      [
                        Ty.tuple
                          [
                            Ty.tuple
                              [
                                Ty.apply (Ty.path "&") [] [ T ];
                                Ty.apply
                                  (Ty.path "&mut")
                                  []
                                  [ Ty.path "alloc::collections::btree::set_val::SetValZST" ]
                              ]
                          ]
                      ]
                      (Ty.apply (Ty.path "&") [] [ T ])
                  ]
                |),
                [
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "core::option::Option")
                      []
                      [
                        Ty.tuple
                          [
                            Ty.apply (Ty.path "&") [] [ T ];
                            Ty.apply
                              (Ty.path "&mut")
                              []
                              [ Ty.path "alloc::collections::btree::set_val::SetValZST" ]
                          ]
                      ],
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "alloc::collections::btree::map::CursorMut")
                        []
                        [ T; Ty.path "alloc::collections::btree::set_val::SetValZST"; A ],
                      "next",
                      [],
                      []
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.MutRef,
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "alloc::collections::btree::set::CursorMut",
                          "inner"
                        |)
                      |)
                    ]
                  |);
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0 ] =>
                          ltac:(M.monadic
                            (M.match_operator (|
                              Some
                                (Ty.function
                                  [
                                    Ty.tuple
                                      [
                                        Ty.tuple
                                          [
                                            Ty.apply (Ty.path "&") [] [ T ];
                                            Ty.apply
                                              (Ty.path "&mut")
                                              []
                                              [
                                                Ty.path
                                                  "alloc::collections::btree::set_val::SetValZST"
                                              ]
                                          ]
                                      ]
                                  ]
                                  (Ty.apply (Ty.path "&") [] [ T ])),
                              M.alloc (| α0 |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                    let k := M.copy (| γ0_0 |) in
                                    M.read (| k |)))
                              ]
                            |)))
                        | _ => M.impossible "wrong number of arguments"
                        end))
                ]
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Global Instance AssociatedFunction_next :
          forall (T A : Ty.t),
          M.IsAssociatedFunction.C (Self T A) "next" (next T A).
        Admitted.
        Global Typeclasses Opaque next.
        
        (*
            pub fn prev(&mut self) -> Option<&T> {
                self.inner.prev().map(|(k, _)| k)
            }
        *)
        Definition prev (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self T A in
          match ε, τ, α with
          | [], [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              M.call_closure (|
                Ty.apply (Ty.path "core::option::Option") [] [ Ty.apply (Ty.path "&") [] [ T ] ],
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "core::option::Option")
                    []
                    [
                      Ty.tuple
                        [
                          Ty.apply (Ty.path "&") [] [ T ];
                          Ty.apply
                            (Ty.path "&mut")
                            []
                            [ Ty.path "alloc::collections::btree::set_val::SetValZST" ]
                        ]
                    ],
                  "map",
                  [],
                  [
                    Ty.apply (Ty.path "&") [] [ T ];
                    Ty.function
                      [
                        Ty.tuple
                          [
                            Ty.tuple
                              [
                                Ty.apply (Ty.path "&") [] [ T ];
                                Ty.apply
                                  (Ty.path "&mut")
                                  []
                                  [ Ty.path "alloc::collections::btree::set_val::SetValZST" ]
                              ]
                          ]
                      ]
                      (Ty.apply (Ty.path "&") [] [ T ])
                  ]
                |),
                [
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "core::option::Option")
                      []
                      [
                        Ty.tuple
                          [
                            Ty.apply (Ty.path "&") [] [ T ];
                            Ty.apply
                              (Ty.path "&mut")
                              []
                              [ Ty.path "alloc::collections::btree::set_val::SetValZST" ]
                          ]
                      ],
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "alloc::collections::btree::map::CursorMut")
                        []
                        [ T; Ty.path "alloc::collections::btree::set_val::SetValZST"; A ],
                      "prev",
                      [],
                      []
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.MutRef,
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "alloc::collections::btree::set::CursorMut",
                          "inner"
                        |)
                      |)
                    ]
                  |);
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0 ] =>
                          ltac:(M.monadic
                            (M.match_operator (|
                              Some
                                (Ty.function
                                  [
                                    Ty.tuple
                                      [
                                        Ty.tuple
                                          [
                                            Ty.apply (Ty.path "&") [] [ T ];
                                            Ty.apply
                                              (Ty.path "&mut")
                                              []
                                              [
                                                Ty.path
                                                  "alloc::collections::btree::set_val::SetValZST"
                                              ]
                                          ]
                                      ]
                                  ]
                                  (Ty.apply (Ty.path "&") [] [ T ])),
                              M.alloc (| α0 |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                    let k := M.copy (| γ0_0 |) in
                                    M.read (| k |)))
                              ]
                            |)))
                        | _ => M.impossible "wrong number of arguments"
                        end))
                ]
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Global Instance AssociatedFunction_prev :
          forall (T A : Ty.t),
          M.IsAssociatedFunction.C (Self T A) "prev" (prev T A).
        Admitted.
        Global Typeclasses Opaque prev.
        
        (*
            pub fn peek_next(&mut self) -> Option<&T> {
                self.inner.peek_next().map(|(k, _)| k)
            }
        *)
        Definition peek_next
            (T A : Ty.t)
            (ε : list Value.t)
            (τ : list Ty.t)
            (α : list Value.t)
            : M :=
          let Self : Ty.t := Self T A in
          match ε, τ, α with
          | [], [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              M.call_closure (|
                Ty.apply (Ty.path "core::option::Option") [] [ Ty.apply (Ty.path "&") [] [ T ] ],
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "core::option::Option")
                    []
                    [
                      Ty.tuple
                        [
                          Ty.apply (Ty.path "&") [] [ T ];
                          Ty.apply
                            (Ty.path "&mut")
                            []
                            [ Ty.path "alloc::collections::btree::set_val::SetValZST" ]
                        ]
                    ],
                  "map",
                  [],
                  [
                    Ty.apply (Ty.path "&") [] [ T ];
                    Ty.function
                      [
                        Ty.tuple
                          [
                            Ty.tuple
                              [
                                Ty.apply (Ty.path "&") [] [ T ];
                                Ty.apply
                                  (Ty.path "&mut")
                                  []
                                  [ Ty.path "alloc::collections::btree::set_val::SetValZST" ]
                              ]
                          ]
                      ]
                      (Ty.apply (Ty.path "&") [] [ T ])
                  ]
                |),
                [
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "core::option::Option")
                      []
                      [
                        Ty.tuple
                          [
                            Ty.apply (Ty.path "&") [] [ T ];
                            Ty.apply
                              (Ty.path "&mut")
                              []
                              [ Ty.path "alloc::collections::btree::set_val::SetValZST" ]
                          ]
                      ],
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "alloc::collections::btree::map::CursorMut")
                        []
                        [ T; Ty.path "alloc::collections::btree::set_val::SetValZST"; A ],
                      "peek_next",
                      [],
                      []
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.MutRef,
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "alloc::collections::btree::set::CursorMut",
                          "inner"
                        |)
                      |)
                    ]
                  |);
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0 ] =>
                          ltac:(M.monadic
                            (M.match_operator (|
                              Some
                                (Ty.function
                                  [
                                    Ty.tuple
                                      [
                                        Ty.tuple
                                          [
                                            Ty.apply (Ty.path "&") [] [ T ];
                                            Ty.apply
                                              (Ty.path "&mut")
                                              []
                                              [
                                                Ty.path
                                                  "alloc::collections::btree::set_val::SetValZST"
                                              ]
                                          ]
                                      ]
                                  ]
                                  (Ty.apply (Ty.path "&") [] [ T ])),
                              M.alloc (| α0 |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                    let k := M.copy (| γ0_0 |) in
                                    M.read (| k |)))
                              ]
                            |)))
                        | _ => M.impossible "wrong number of arguments"
                        end))
                ]
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Global Instance AssociatedFunction_peek_next :
          forall (T A : Ty.t),
          M.IsAssociatedFunction.C (Self T A) "peek_next" (peek_next T A).
        Admitted.
        Global Typeclasses Opaque peek_next.
        
        (*
            pub fn peek_prev(&mut self) -> Option<&T> {
                self.inner.peek_prev().map(|(k, _)| k)
            }
        *)
        Definition peek_prev
            (T A : Ty.t)
            (ε : list Value.t)
            (τ : list Ty.t)
            (α : list Value.t)
            : M :=
          let Self : Ty.t := Self T A in
          match ε, τ, α with
          | [], [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              M.call_closure (|
                Ty.apply (Ty.path "core::option::Option") [] [ Ty.apply (Ty.path "&") [] [ T ] ],
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "core::option::Option")
                    []
                    [
                      Ty.tuple
                        [
                          Ty.apply (Ty.path "&") [] [ T ];
                          Ty.apply
                            (Ty.path "&mut")
                            []
                            [ Ty.path "alloc::collections::btree::set_val::SetValZST" ]
                        ]
                    ],
                  "map",
                  [],
                  [
                    Ty.apply (Ty.path "&") [] [ T ];
                    Ty.function
                      [
                        Ty.tuple
                          [
                            Ty.tuple
                              [
                                Ty.apply (Ty.path "&") [] [ T ];
                                Ty.apply
                                  (Ty.path "&mut")
                                  []
                                  [ Ty.path "alloc::collections::btree::set_val::SetValZST" ]
                              ]
                          ]
                      ]
                      (Ty.apply (Ty.path "&") [] [ T ])
                  ]
                |),
                [
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "core::option::Option")
                      []
                      [
                        Ty.tuple
                          [
                            Ty.apply (Ty.path "&") [] [ T ];
                            Ty.apply
                              (Ty.path "&mut")
                              []
                              [ Ty.path "alloc::collections::btree::set_val::SetValZST" ]
                          ]
                      ],
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "alloc::collections::btree::map::CursorMut")
                        []
                        [ T; Ty.path "alloc::collections::btree::set_val::SetValZST"; A ],
                      "peek_prev",
                      [],
                      []
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.MutRef,
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "alloc::collections::btree::set::CursorMut",
                          "inner"
                        |)
                      |)
                    ]
                  |);
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0 ] =>
                          ltac:(M.monadic
                            (M.match_operator (|
                              Some
                                (Ty.function
                                  [
                                    Ty.tuple
                                      [
                                        Ty.tuple
                                          [
                                            Ty.apply (Ty.path "&") [] [ T ];
                                            Ty.apply
                                              (Ty.path "&mut")
                                              []
                                              [
                                                Ty.path
                                                  "alloc::collections::btree::set_val::SetValZST"
                                              ]
                                          ]
                                      ]
                                  ]
                                  (Ty.apply (Ty.path "&") [] [ T ])),
                              M.alloc (| α0 |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                    let k := M.copy (| γ0_0 |) in
                                    M.read (| k |)))
                              ]
                            |)))
                        | _ => M.impossible "wrong number of arguments"
                        end))
                ]
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Global Instance AssociatedFunction_peek_prev :
          forall (T A : Ty.t),
          M.IsAssociatedFunction.C (Self T A) "peek_prev" (peek_prev T A).
        Admitted.
        Global Typeclasses Opaque peek_prev.
        
        (*
            pub fn as_cursor(&self) -> Cursor<'_, T> {
                Cursor { inner: self.inner.as_cursor() }
            }
        *)
        Definition as_cursor
            (T A : Ty.t)
            (ε : list Value.t)
            (τ : list Ty.t)
            (α : list Value.t)
            : M :=
          let Self : Ty.t := Self T A in
          match ε, τ, α with
          | [], [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              Value.StructRecord
                "alloc::collections::btree::set::Cursor"
                [
                  ("inner",
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "alloc::collections::btree::map::Cursor")
                        []
                        [ T; Ty.path "alloc::collections::btree::set_val::SetValZST" ],
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "alloc::collections::btree::map::CursorMut")
                          []
                          [ T; Ty.path "alloc::collections::btree::set_val::SetValZST"; A ],
                        "as_cursor",
                        [],
                        []
                      |),
                      [
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "alloc::collections::btree::set::CursorMut",
                            "inner"
                          |)
                        |)
                      ]
                    |))
                ]))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Global Instance AssociatedFunction_as_cursor :
          forall (T A : Ty.t),
          M.IsAssociatedFunction.C (Self T A) "as_cursor" (as_cursor T A).
        Admitted.
        Global Typeclasses Opaque as_cursor.
        
        (*
            pub unsafe fn with_mutable_key(self) -> CursorMutKey<'a, T, A> {
                CursorMutKey { inner: unsafe { self.inner.with_mutable_key() } }
            }
        *)
        Definition with_mutable_key
            (T A : Ty.t)
            (ε : list Value.t)
            (τ : list Ty.t)
            (α : list Value.t)
            : M :=
          let Self : Ty.t := Self T A in
          match ε, τ, α with
          | [], [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              Value.StructRecord
                "alloc::collections::btree::set::CursorMutKey"
                [
                  ("inner",
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "alloc::collections::btree::map::CursorMutKey")
                        []
                        [ T; Ty.path "alloc::collections::btree::set_val::SetValZST"; A ],
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "alloc::collections::btree::map::CursorMut")
                          []
                          [ T; Ty.path "alloc::collections::btree::set_val::SetValZST"; A ],
                        "with_mutable_key",
                        [],
                        []
                      |),
                      [
                        M.read (|
                          M.SubPointer.get_struct_record_field (|
                            self,
                            "alloc::collections::btree::set::CursorMut",
                            "inner"
                          |)
                        |)
                      ]
                    |))
                ]))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Global Instance AssociatedFunction_with_mutable_key :
          forall (T A : Ty.t),
          M.IsAssociatedFunction.C (Self T A) "with_mutable_key" (with_mutable_key T A).
        Admitted.
        Global Typeclasses Opaque with_mutable_key.
        (*
            pub unsafe fn insert_after_unchecked(&mut self, value: T) {
                unsafe { self.inner.insert_after_unchecked(value, SetValZST) }
            }
        *)
        Definition insert_after_unchecked
            (T A : Ty.t)
            (ε : list Value.t)
            (τ : list Ty.t)
            (α : list Value.t)
            : M :=
          let Self : Ty.t := Self T A in
          match ε, τ, α with
          | [], [], [ self; value ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let value := M.alloc (| value |) in
              M.call_closure (|
                Ty.tuple [],
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "alloc::collections::btree::map::CursorMut")
                    []
                    [ T; Ty.path "alloc::collections::btree::set_val::SetValZST"; A ],
                  "insert_after_unchecked",
                  [],
                  []
                |),
                [
                  M.borrow (|
                    Pointer.Kind.MutRef,
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| self |) |),
                      "alloc::collections::btree::set::CursorMut",
                      "inner"
                    |)
                  |);
                  M.read (| value |);
                  Value.StructTuple "alloc::collections::btree::set_val::SetValZST" []
                ]
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Global Instance AssociatedFunction_insert_after_unchecked :
          forall (T A : Ty.t),
          M.IsAssociatedFunction.C (Self T A) "insert_after_unchecked" (insert_after_unchecked T A).
        Admitted.
        Global Typeclasses Opaque insert_after_unchecked.
        
        (*
            pub unsafe fn insert_before_unchecked(&mut self, value: T) {
                unsafe { self.inner.insert_before_unchecked(value, SetValZST) }
            }
        *)
        Definition insert_before_unchecked
            (T A : Ty.t)
            (ε : list Value.t)
            (τ : list Ty.t)
            (α : list Value.t)
            : M :=
          let Self : Ty.t := Self T A in
          match ε, τ, α with
          | [], [], [ self; value ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let value := M.alloc (| value |) in
              M.call_closure (|
                Ty.tuple [],
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "alloc::collections::btree::map::CursorMut")
                    []
                    [ T; Ty.path "alloc::collections::btree::set_val::SetValZST"; A ],
                  "insert_before_unchecked",
                  [],
                  []
                |),
                [
                  M.borrow (|
                    Pointer.Kind.MutRef,
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| self |) |),
                      "alloc::collections::btree::set::CursorMut",
                      "inner"
                    |)
                  |);
                  M.read (| value |);
                  Value.StructTuple "alloc::collections::btree::set_val::SetValZST" []
                ]
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Global Instance AssociatedFunction_insert_before_unchecked :
          forall (T A : Ty.t),
          M.IsAssociatedFunction.C
            (Self T A)
            "insert_before_unchecked"
            (insert_before_unchecked T A).
        Admitted.
        Global Typeclasses Opaque insert_before_unchecked.
        
        (*
            pub fn insert_after(&mut self, value: T) -> Result<(), UnorderedKeyError> {
                self.inner.insert_after(value, SetValZST)
            }
        *)
        Definition insert_after
            (T A : Ty.t)
            (ε : list Value.t)
            (τ : list Ty.t)
            (α : list Value.t)
            : M :=
          let Self : Ty.t := Self T A in
          match ε, τ, α with
          | [], [], [ self; value ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let value := M.alloc (| value |) in
              M.call_closure (|
                Ty.apply
                  (Ty.path "core::result::Result")
                  []
                  [ Ty.tuple []; Ty.path "alloc::collections::btree::map::UnorderedKeyError" ],
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "alloc::collections::btree::map::CursorMut")
                    []
                    [ T; Ty.path "alloc::collections::btree::set_val::SetValZST"; A ],
                  "insert_after",
                  [],
                  []
                |),
                [
                  M.borrow (|
                    Pointer.Kind.MutRef,
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| self |) |),
                      "alloc::collections::btree::set::CursorMut",
                      "inner"
                    |)
                  |);
                  M.read (| value |);
                  Value.StructTuple "alloc::collections::btree::set_val::SetValZST" []
                ]
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Global Instance AssociatedFunction_insert_after :
          forall (T A : Ty.t),
          M.IsAssociatedFunction.C (Self T A) "insert_after" (insert_after T A).
        Admitted.
        Global Typeclasses Opaque insert_after.
        
        (*
            pub fn insert_before(&mut self, value: T) -> Result<(), UnorderedKeyError> {
                self.inner.insert_before(value, SetValZST)
            }
        *)
        Definition insert_before
            (T A : Ty.t)
            (ε : list Value.t)
            (τ : list Ty.t)
            (α : list Value.t)
            : M :=
          let Self : Ty.t := Self T A in
          match ε, τ, α with
          | [], [], [ self; value ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let value := M.alloc (| value |) in
              M.call_closure (|
                Ty.apply
                  (Ty.path "core::result::Result")
                  []
                  [ Ty.tuple []; Ty.path "alloc::collections::btree::map::UnorderedKeyError" ],
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "alloc::collections::btree::map::CursorMut")
                    []
                    [ T; Ty.path "alloc::collections::btree::set_val::SetValZST"; A ],
                  "insert_before",
                  [],
                  []
                |),
                [
                  M.borrow (|
                    Pointer.Kind.MutRef,
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| self |) |),
                      "alloc::collections::btree::set::CursorMut",
                      "inner"
                    |)
                  |);
                  M.read (| value |);
                  Value.StructTuple "alloc::collections::btree::set_val::SetValZST" []
                ]
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Global Instance AssociatedFunction_insert_before :
          forall (T A : Ty.t),
          M.IsAssociatedFunction.C (Self T A) "insert_before" (insert_before T A).
        Admitted.
        Global Typeclasses Opaque insert_before.
        
        (*
            pub fn remove_next(&mut self) -> Option<T> {
                self.inner.remove_next().map(|(k, _)| k)
            }
        *)
        Definition remove_next
            (T A : Ty.t)
            (ε : list Value.t)
            (τ : list Ty.t)
            (α : list Value.t)
            : M :=
          let Self : Ty.t := Self T A in
          match ε, τ, α with
          | [], [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              M.call_closure (|
                Ty.apply (Ty.path "core::option::Option") [] [ T ],
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "core::option::Option")
                    []
                    [ Ty.tuple [ T; Ty.path "alloc::collections::btree::set_val::SetValZST" ] ],
                  "map",
                  [],
                  [
                    T;
                    Ty.function
                      [
                        Ty.tuple
                          [ Ty.tuple [ T; Ty.path "alloc::collections::btree::set_val::SetValZST" ]
                          ]
                      ]
                      T
                  ]
                |),
                [
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "core::option::Option")
                      []
                      [ Ty.tuple [ T; Ty.path "alloc::collections::btree::set_val::SetValZST" ] ],
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "alloc::collections::btree::map::CursorMut")
                        []
                        [ T; Ty.path "alloc::collections::btree::set_val::SetValZST"; A ],
                      "remove_next",
                      [],
                      []
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.MutRef,
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "alloc::collections::btree::set::CursorMut",
                          "inner"
                        |)
                      |)
                    ]
                  |);
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0 ] =>
                          ltac:(M.monadic
                            (M.match_operator (|
                              Some
                                (Ty.function
                                  [
                                    Ty.tuple
                                      [
                                        Ty.tuple
                                          [
                                            T;
                                            Ty.path "alloc::collections::btree::set_val::SetValZST"
                                          ]
                                      ]
                                  ]
                                  T),
                              M.alloc (| α0 |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                    let k := M.copy (| γ0_0 |) in
                                    M.read (| k |)))
                              ]
                            |)))
                        | _ => M.impossible "wrong number of arguments"
                        end))
                ]
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Global Instance AssociatedFunction_remove_next :
          forall (T A : Ty.t),
          M.IsAssociatedFunction.C (Self T A) "remove_next" (remove_next T A).
        Admitted.
        Global Typeclasses Opaque remove_next.
        
        (*
            pub fn remove_prev(&mut self) -> Option<T> {
                self.inner.remove_prev().map(|(k, _)| k)
            }
        *)
        Definition remove_prev
            (T A : Ty.t)
            (ε : list Value.t)
            (τ : list Ty.t)
            (α : list Value.t)
            : M :=
          let Self : Ty.t := Self T A in
          match ε, τ, α with
          | [], [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              M.call_closure (|
                Ty.apply (Ty.path "core::option::Option") [] [ T ],
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "core::option::Option")
                    []
                    [ Ty.tuple [ T; Ty.path "alloc::collections::btree::set_val::SetValZST" ] ],
                  "map",
                  [],
                  [
                    T;
                    Ty.function
                      [
                        Ty.tuple
                          [ Ty.tuple [ T; Ty.path "alloc::collections::btree::set_val::SetValZST" ]
                          ]
                      ]
                      T
                  ]
                |),
                [
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "core::option::Option")
                      []
                      [ Ty.tuple [ T; Ty.path "alloc::collections::btree::set_val::SetValZST" ] ],
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "alloc::collections::btree::map::CursorMut")
                        []
                        [ T; Ty.path "alloc::collections::btree::set_val::SetValZST"; A ],
                      "remove_prev",
                      [],
                      []
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.MutRef,
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "alloc::collections::btree::set::CursorMut",
                          "inner"
                        |)
                      |)
                    ]
                  |);
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0 ] =>
                          ltac:(M.monadic
                            (M.match_operator (|
                              Some
                                (Ty.function
                                  [
                                    Ty.tuple
                                      [
                                        Ty.tuple
                                          [
                                            T;
                                            Ty.path "alloc::collections::btree::set_val::SetValZST"
                                          ]
                                      ]
                                  ]
                                  T),
                              M.alloc (| α0 |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                    let k := M.copy (| γ0_0 |) in
                                    M.read (| k |)))
                              ]
                            |)))
                        | _ => M.impossible "wrong number of arguments"
                        end))
                ]
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Global Instance AssociatedFunction_remove_prev :
          forall (T A : Ty.t),
          M.IsAssociatedFunction.C (Self T A) "remove_prev" (remove_prev T A).
        Admitted.
        Global Typeclasses Opaque remove_prev.
      End Impl_alloc_collections_btree_set_CursorMut_T_A.
      
      Module Impl_alloc_collections_btree_set_CursorMutKey_T_A.
        Definition Self (T A : Ty.t) : Ty.t :=
          Ty.apply (Ty.path "alloc::collections::btree::set::CursorMutKey") [] [ T; A ].
        
        (*
            pub fn next(&mut self) -> Option<&mut T> {
                self.inner.next().map(|(k, _)| k)
            }
        *)
        Definition next (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self T A in
          match ε, τ, α with
          | [], [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              M.call_closure (|
                Ty.apply (Ty.path "core::option::Option") [] [ Ty.apply (Ty.path "&mut") [] [ T ] ],
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "core::option::Option")
                    []
                    [
                      Ty.tuple
                        [
                          Ty.apply (Ty.path "&mut") [] [ T ];
                          Ty.apply
                            (Ty.path "&mut")
                            []
                            [ Ty.path "alloc::collections::btree::set_val::SetValZST" ]
                        ]
                    ],
                  "map",
                  [],
                  [
                    Ty.apply (Ty.path "&mut") [] [ T ];
                    Ty.function
                      [
                        Ty.tuple
                          [
                            Ty.tuple
                              [
                                Ty.apply (Ty.path "&mut") [] [ T ];
                                Ty.apply
                                  (Ty.path "&mut")
                                  []
                                  [ Ty.path "alloc::collections::btree::set_val::SetValZST" ]
                              ]
                          ]
                      ]
                      (Ty.apply (Ty.path "&mut") [] [ T ])
                  ]
                |),
                [
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "core::option::Option")
                      []
                      [
                        Ty.tuple
                          [
                            Ty.apply (Ty.path "&mut") [] [ T ];
                            Ty.apply
                              (Ty.path "&mut")
                              []
                              [ Ty.path "alloc::collections::btree::set_val::SetValZST" ]
                          ]
                      ],
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "alloc::collections::btree::map::CursorMutKey")
                        []
                        [ T; Ty.path "alloc::collections::btree::set_val::SetValZST"; A ],
                      "next",
                      [],
                      []
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.MutRef,
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "alloc::collections::btree::set::CursorMutKey",
                          "inner"
                        |)
                      |)
                    ]
                  |);
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0 ] =>
                          ltac:(M.monadic
                            (M.match_operator (|
                              Some
                                (Ty.function
                                  [
                                    Ty.tuple
                                      [
                                        Ty.tuple
                                          [
                                            Ty.apply (Ty.path "&mut") [] [ T ];
                                            Ty.apply
                                              (Ty.path "&mut")
                                              []
                                              [
                                                Ty.path
                                                  "alloc::collections::btree::set_val::SetValZST"
                                              ]
                                          ]
                                      ]
                                  ]
                                  (Ty.apply (Ty.path "&mut") [] [ T ])),
                              M.alloc (| α0 |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                    let k := M.copy (| γ0_0 |) in
                                    M.read (| k |)))
                              ]
                            |)))
                        | _ => M.impossible "wrong number of arguments"
                        end))
                ]
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Global Instance AssociatedFunction_next :
          forall (T A : Ty.t),
          M.IsAssociatedFunction.C (Self T A) "next" (next T A).
        Admitted.
        Global Typeclasses Opaque next.
        
        (*
            pub fn prev(&mut self) -> Option<&mut T> {
                self.inner.prev().map(|(k, _)| k)
            }
        *)
        Definition prev (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self T A in
          match ε, τ, α with
          | [], [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              M.call_closure (|
                Ty.apply (Ty.path "core::option::Option") [] [ Ty.apply (Ty.path "&mut") [] [ T ] ],
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "core::option::Option")
                    []
                    [
                      Ty.tuple
                        [
                          Ty.apply (Ty.path "&mut") [] [ T ];
                          Ty.apply
                            (Ty.path "&mut")
                            []
                            [ Ty.path "alloc::collections::btree::set_val::SetValZST" ]
                        ]
                    ],
                  "map",
                  [],
                  [
                    Ty.apply (Ty.path "&mut") [] [ T ];
                    Ty.function
                      [
                        Ty.tuple
                          [
                            Ty.tuple
                              [
                                Ty.apply (Ty.path "&mut") [] [ T ];
                                Ty.apply
                                  (Ty.path "&mut")
                                  []
                                  [ Ty.path "alloc::collections::btree::set_val::SetValZST" ]
                              ]
                          ]
                      ]
                      (Ty.apply (Ty.path "&mut") [] [ T ])
                  ]
                |),
                [
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "core::option::Option")
                      []
                      [
                        Ty.tuple
                          [
                            Ty.apply (Ty.path "&mut") [] [ T ];
                            Ty.apply
                              (Ty.path "&mut")
                              []
                              [ Ty.path "alloc::collections::btree::set_val::SetValZST" ]
                          ]
                      ],
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "alloc::collections::btree::map::CursorMutKey")
                        []
                        [ T; Ty.path "alloc::collections::btree::set_val::SetValZST"; A ],
                      "prev",
                      [],
                      []
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.MutRef,
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "alloc::collections::btree::set::CursorMutKey",
                          "inner"
                        |)
                      |)
                    ]
                  |);
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0 ] =>
                          ltac:(M.monadic
                            (M.match_operator (|
                              Some
                                (Ty.function
                                  [
                                    Ty.tuple
                                      [
                                        Ty.tuple
                                          [
                                            Ty.apply (Ty.path "&mut") [] [ T ];
                                            Ty.apply
                                              (Ty.path "&mut")
                                              []
                                              [
                                                Ty.path
                                                  "alloc::collections::btree::set_val::SetValZST"
                                              ]
                                          ]
                                      ]
                                  ]
                                  (Ty.apply (Ty.path "&mut") [] [ T ])),
                              M.alloc (| α0 |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                    let k := M.copy (| γ0_0 |) in
                                    M.read (| k |)))
                              ]
                            |)))
                        | _ => M.impossible "wrong number of arguments"
                        end))
                ]
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Global Instance AssociatedFunction_prev :
          forall (T A : Ty.t),
          M.IsAssociatedFunction.C (Self T A) "prev" (prev T A).
        Admitted.
        Global Typeclasses Opaque prev.
        
        (*
            pub fn peek_next(&mut self) -> Option<&mut T> {
                self.inner.peek_next().map(|(k, _)| k)
            }
        *)
        Definition peek_next
            (T A : Ty.t)
            (ε : list Value.t)
            (τ : list Ty.t)
            (α : list Value.t)
            : M :=
          let Self : Ty.t := Self T A in
          match ε, τ, α with
          | [], [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              M.call_closure (|
                Ty.apply (Ty.path "core::option::Option") [] [ Ty.apply (Ty.path "&mut") [] [ T ] ],
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "core::option::Option")
                    []
                    [
                      Ty.tuple
                        [
                          Ty.apply (Ty.path "&mut") [] [ T ];
                          Ty.apply
                            (Ty.path "&mut")
                            []
                            [ Ty.path "alloc::collections::btree::set_val::SetValZST" ]
                        ]
                    ],
                  "map",
                  [],
                  [
                    Ty.apply (Ty.path "&mut") [] [ T ];
                    Ty.function
                      [
                        Ty.tuple
                          [
                            Ty.tuple
                              [
                                Ty.apply (Ty.path "&mut") [] [ T ];
                                Ty.apply
                                  (Ty.path "&mut")
                                  []
                                  [ Ty.path "alloc::collections::btree::set_val::SetValZST" ]
                              ]
                          ]
                      ]
                      (Ty.apply (Ty.path "&mut") [] [ T ])
                  ]
                |),
                [
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "core::option::Option")
                      []
                      [
                        Ty.tuple
                          [
                            Ty.apply (Ty.path "&mut") [] [ T ];
                            Ty.apply
                              (Ty.path "&mut")
                              []
                              [ Ty.path "alloc::collections::btree::set_val::SetValZST" ]
                          ]
                      ],
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "alloc::collections::btree::map::CursorMutKey")
                        []
                        [ T; Ty.path "alloc::collections::btree::set_val::SetValZST"; A ],
                      "peek_next",
                      [],
                      []
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.MutRef,
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "alloc::collections::btree::set::CursorMutKey",
                          "inner"
                        |)
                      |)
                    ]
                  |);
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0 ] =>
                          ltac:(M.monadic
                            (M.match_operator (|
                              Some
                                (Ty.function
                                  [
                                    Ty.tuple
                                      [
                                        Ty.tuple
                                          [
                                            Ty.apply (Ty.path "&mut") [] [ T ];
                                            Ty.apply
                                              (Ty.path "&mut")
                                              []
                                              [
                                                Ty.path
                                                  "alloc::collections::btree::set_val::SetValZST"
                                              ]
                                          ]
                                      ]
                                  ]
                                  (Ty.apply (Ty.path "&mut") [] [ T ])),
                              M.alloc (| α0 |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                    let k := M.copy (| γ0_0 |) in
                                    M.read (| k |)))
                              ]
                            |)))
                        | _ => M.impossible "wrong number of arguments"
                        end))
                ]
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Global Instance AssociatedFunction_peek_next :
          forall (T A : Ty.t),
          M.IsAssociatedFunction.C (Self T A) "peek_next" (peek_next T A).
        Admitted.
        Global Typeclasses Opaque peek_next.
        
        (*
            pub fn peek_prev(&mut self) -> Option<&mut T> {
                self.inner.peek_prev().map(|(k, _)| k)
            }
        *)
        Definition peek_prev
            (T A : Ty.t)
            (ε : list Value.t)
            (τ : list Ty.t)
            (α : list Value.t)
            : M :=
          let Self : Ty.t := Self T A in
          match ε, τ, α with
          | [], [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              M.call_closure (|
                Ty.apply (Ty.path "core::option::Option") [] [ Ty.apply (Ty.path "&mut") [] [ T ] ],
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "core::option::Option")
                    []
                    [
                      Ty.tuple
                        [
                          Ty.apply (Ty.path "&mut") [] [ T ];
                          Ty.apply
                            (Ty.path "&mut")
                            []
                            [ Ty.path "alloc::collections::btree::set_val::SetValZST" ]
                        ]
                    ],
                  "map",
                  [],
                  [
                    Ty.apply (Ty.path "&mut") [] [ T ];
                    Ty.function
                      [
                        Ty.tuple
                          [
                            Ty.tuple
                              [
                                Ty.apply (Ty.path "&mut") [] [ T ];
                                Ty.apply
                                  (Ty.path "&mut")
                                  []
                                  [ Ty.path "alloc::collections::btree::set_val::SetValZST" ]
                              ]
                          ]
                      ]
                      (Ty.apply (Ty.path "&mut") [] [ T ])
                  ]
                |),
                [
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "core::option::Option")
                      []
                      [
                        Ty.tuple
                          [
                            Ty.apply (Ty.path "&mut") [] [ T ];
                            Ty.apply
                              (Ty.path "&mut")
                              []
                              [ Ty.path "alloc::collections::btree::set_val::SetValZST" ]
                          ]
                      ],
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "alloc::collections::btree::map::CursorMutKey")
                        []
                        [ T; Ty.path "alloc::collections::btree::set_val::SetValZST"; A ],
                      "peek_prev",
                      [],
                      []
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.MutRef,
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "alloc::collections::btree::set::CursorMutKey",
                          "inner"
                        |)
                      |)
                    ]
                  |);
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0 ] =>
                          ltac:(M.monadic
                            (M.match_operator (|
                              Some
                                (Ty.function
                                  [
                                    Ty.tuple
                                      [
                                        Ty.tuple
                                          [
                                            Ty.apply (Ty.path "&mut") [] [ T ];
                                            Ty.apply
                                              (Ty.path "&mut")
                                              []
                                              [
                                                Ty.path
                                                  "alloc::collections::btree::set_val::SetValZST"
                                              ]
                                          ]
                                      ]
                                  ]
                                  (Ty.apply (Ty.path "&mut") [] [ T ])),
                              M.alloc (| α0 |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                    let k := M.copy (| γ0_0 |) in
                                    M.read (| k |)))
                              ]
                            |)))
                        | _ => M.impossible "wrong number of arguments"
                        end))
                ]
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Global Instance AssociatedFunction_peek_prev :
          forall (T A : Ty.t),
          M.IsAssociatedFunction.C (Self T A) "peek_prev" (peek_prev T A).
        Admitted.
        Global Typeclasses Opaque peek_prev.
        
        (*
            pub fn as_cursor(&self) -> Cursor<'_, T> {
                Cursor { inner: self.inner.as_cursor() }
            }
        *)
        Definition as_cursor
            (T A : Ty.t)
            (ε : list Value.t)
            (τ : list Ty.t)
            (α : list Value.t)
            : M :=
          let Self : Ty.t := Self T A in
          match ε, τ, α with
          | [], [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              Value.StructRecord
                "alloc::collections::btree::set::Cursor"
                [
                  ("inner",
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "alloc::collections::btree::map::Cursor")
                        []
                        [ T; Ty.path "alloc::collections::btree::set_val::SetValZST" ],
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "alloc::collections::btree::map::CursorMutKey")
                          []
                          [ T; Ty.path "alloc::collections::btree::set_val::SetValZST"; A ],
                        "as_cursor",
                        [],
                        []
                      |),
                      [
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "alloc::collections::btree::set::CursorMutKey",
                            "inner"
                          |)
                        |)
                      ]
                    |))
                ]))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Global Instance AssociatedFunction_as_cursor :
          forall (T A : Ty.t),
          M.IsAssociatedFunction.C (Self T A) "as_cursor" (as_cursor T A).
        Admitted.
        Global Typeclasses Opaque as_cursor.
        (*
            pub unsafe fn insert_after_unchecked(&mut self, value: T) {
                unsafe { self.inner.insert_after_unchecked(value, SetValZST) }
            }
        *)
        Definition insert_after_unchecked
            (T A : Ty.t)
            (ε : list Value.t)
            (τ : list Ty.t)
            (α : list Value.t)
            : M :=
          let Self : Ty.t := Self T A in
          match ε, τ, α with
          | [], [], [ self; value ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let value := M.alloc (| value |) in
              M.call_closure (|
                Ty.tuple [],
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "alloc::collections::btree::map::CursorMutKey")
                    []
                    [ T; Ty.path "alloc::collections::btree::set_val::SetValZST"; A ],
                  "insert_after_unchecked",
                  [],
                  []
                |),
                [
                  M.borrow (|
                    Pointer.Kind.MutRef,
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| self |) |),
                      "alloc::collections::btree::set::CursorMutKey",
                      "inner"
                    |)
                  |);
                  M.read (| value |);
                  Value.StructTuple "alloc::collections::btree::set_val::SetValZST" []
                ]
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Global Instance AssociatedFunction_insert_after_unchecked :
          forall (T A : Ty.t),
          M.IsAssociatedFunction.C (Self T A) "insert_after_unchecked" (insert_after_unchecked T A).
        Admitted.
        Global Typeclasses Opaque insert_after_unchecked.
        
        (*
            pub unsafe fn insert_before_unchecked(&mut self, value: T) {
                unsafe { self.inner.insert_before_unchecked(value, SetValZST) }
            }
        *)
        Definition insert_before_unchecked
            (T A : Ty.t)
            (ε : list Value.t)
            (τ : list Ty.t)
            (α : list Value.t)
            : M :=
          let Self : Ty.t := Self T A in
          match ε, τ, α with
          | [], [], [ self; value ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let value := M.alloc (| value |) in
              M.call_closure (|
                Ty.tuple [],
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "alloc::collections::btree::map::CursorMutKey")
                    []
                    [ T; Ty.path "alloc::collections::btree::set_val::SetValZST"; A ],
                  "insert_before_unchecked",
                  [],
                  []
                |),
                [
                  M.borrow (|
                    Pointer.Kind.MutRef,
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| self |) |),
                      "alloc::collections::btree::set::CursorMutKey",
                      "inner"
                    |)
                  |);
                  M.read (| value |);
                  Value.StructTuple "alloc::collections::btree::set_val::SetValZST" []
                ]
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Global Instance AssociatedFunction_insert_before_unchecked :
          forall (T A : Ty.t),
          M.IsAssociatedFunction.C
            (Self T A)
            "insert_before_unchecked"
            (insert_before_unchecked T A).
        Admitted.
        Global Typeclasses Opaque insert_before_unchecked.
        
        (*
            pub fn insert_after(&mut self, value: T) -> Result<(), UnorderedKeyError> {
                self.inner.insert_after(value, SetValZST)
            }
        *)
        Definition insert_after
            (T A : Ty.t)
            (ε : list Value.t)
            (τ : list Ty.t)
            (α : list Value.t)
            : M :=
          let Self : Ty.t := Self T A in
          match ε, τ, α with
          | [], [], [ self; value ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let value := M.alloc (| value |) in
              M.call_closure (|
                Ty.apply
                  (Ty.path "core::result::Result")
                  []
                  [ Ty.tuple []; Ty.path "alloc::collections::btree::map::UnorderedKeyError" ],
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "alloc::collections::btree::map::CursorMutKey")
                    []
                    [ T; Ty.path "alloc::collections::btree::set_val::SetValZST"; A ],
                  "insert_after",
                  [],
                  []
                |),
                [
                  M.borrow (|
                    Pointer.Kind.MutRef,
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| self |) |),
                      "alloc::collections::btree::set::CursorMutKey",
                      "inner"
                    |)
                  |);
                  M.read (| value |);
                  Value.StructTuple "alloc::collections::btree::set_val::SetValZST" []
                ]
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Global Instance AssociatedFunction_insert_after :
          forall (T A : Ty.t),
          M.IsAssociatedFunction.C (Self T A) "insert_after" (insert_after T A).
        Admitted.
        Global Typeclasses Opaque insert_after.
        
        (*
            pub fn insert_before(&mut self, value: T) -> Result<(), UnorderedKeyError> {
                self.inner.insert_before(value, SetValZST)
            }
        *)
        Definition insert_before
            (T A : Ty.t)
            (ε : list Value.t)
            (τ : list Ty.t)
            (α : list Value.t)
            : M :=
          let Self : Ty.t := Self T A in
          match ε, τ, α with
          | [], [], [ self; value ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let value := M.alloc (| value |) in
              M.call_closure (|
                Ty.apply
                  (Ty.path "core::result::Result")
                  []
                  [ Ty.tuple []; Ty.path "alloc::collections::btree::map::UnorderedKeyError" ],
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "alloc::collections::btree::map::CursorMutKey")
                    []
                    [ T; Ty.path "alloc::collections::btree::set_val::SetValZST"; A ],
                  "insert_before",
                  [],
                  []
                |),
                [
                  M.borrow (|
                    Pointer.Kind.MutRef,
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| self |) |),
                      "alloc::collections::btree::set::CursorMutKey",
                      "inner"
                    |)
                  |);
                  M.read (| value |);
                  Value.StructTuple "alloc::collections::btree::set_val::SetValZST" []
                ]
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Global Instance AssociatedFunction_insert_before :
          forall (T A : Ty.t),
          M.IsAssociatedFunction.C (Self T A) "insert_before" (insert_before T A).
        Admitted.
        Global Typeclasses Opaque insert_before.
        
        (*
            pub fn remove_next(&mut self) -> Option<T> {
                self.inner.remove_next().map(|(k, _)| k)
            }
        *)
        Definition remove_next
            (T A : Ty.t)
            (ε : list Value.t)
            (τ : list Ty.t)
            (α : list Value.t)
            : M :=
          let Self : Ty.t := Self T A in
          match ε, τ, α with
          | [], [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              M.call_closure (|
                Ty.apply (Ty.path "core::option::Option") [] [ T ],
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "core::option::Option")
                    []
                    [ Ty.tuple [ T; Ty.path "alloc::collections::btree::set_val::SetValZST" ] ],
                  "map",
                  [],
                  [
                    T;
                    Ty.function
                      [
                        Ty.tuple
                          [ Ty.tuple [ T; Ty.path "alloc::collections::btree::set_val::SetValZST" ]
                          ]
                      ]
                      T
                  ]
                |),
                [
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "core::option::Option")
                      []
                      [ Ty.tuple [ T; Ty.path "alloc::collections::btree::set_val::SetValZST" ] ],
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "alloc::collections::btree::map::CursorMutKey")
                        []
                        [ T; Ty.path "alloc::collections::btree::set_val::SetValZST"; A ],
                      "remove_next",
                      [],
                      []
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.MutRef,
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "alloc::collections::btree::set::CursorMutKey",
                          "inner"
                        |)
                      |)
                    ]
                  |);
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0 ] =>
                          ltac:(M.monadic
                            (M.match_operator (|
                              Some
                                (Ty.function
                                  [
                                    Ty.tuple
                                      [
                                        Ty.tuple
                                          [
                                            T;
                                            Ty.path "alloc::collections::btree::set_val::SetValZST"
                                          ]
                                      ]
                                  ]
                                  T),
                              M.alloc (| α0 |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                    let k := M.copy (| γ0_0 |) in
                                    M.read (| k |)))
                              ]
                            |)))
                        | _ => M.impossible "wrong number of arguments"
                        end))
                ]
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Global Instance AssociatedFunction_remove_next :
          forall (T A : Ty.t),
          M.IsAssociatedFunction.C (Self T A) "remove_next" (remove_next T A).
        Admitted.
        Global Typeclasses Opaque remove_next.
        
        (*
            pub fn remove_prev(&mut self) -> Option<T> {
                self.inner.remove_prev().map(|(k, _)| k)
            }
        *)
        Definition remove_prev
            (T A : Ty.t)
            (ε : list Value.t)
            (τ : list Ty.t)
            (α : list Value.t)
            : M :=
          let Self : Ty.t := Self T A in
          match ε, τ, α with
          | [], [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              M.call_closure (|
                Ty.apply (Ty.path "core::option::Option") [] [ T ],
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "core::option::Option")
                    []
                    [ Ty.tuple [ T; Ty.path "alloc::collections::btree::set_val::SetValZST" ] ],
                  "map",
                  [],
                  [
                    T;
                    Ty.function
                      [
                        Ty.tuple
                          [ Ty.tuple [ T; Ty.path "alloc::collections::btree::set_val::SetValZST" ]
                          ]
                      ]
                      T
                  ]
                |),
                [
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "core::option::Option")
                      []
                      [ Ty.tuple [ T; Ty.path "alloc::collections::btree::set_val::SetValZST" ] ],
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "alloc::collections::btree::map::CursorMutKey")
                        []
                        [ T; Ty.path "alloc::collections::btree::set_val::SetValZST"; A ],
                      "remove_prev",
                      [],
                      []
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.MutRef,
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "alloc::collections::btree::set::CursorMutKey",
                          "inner"
                        |)
                      |)
                    ]
                  |);
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0 ] =>
                          ltac:(M.monadic
                            (M.match_operator (|
                              Some
                                (Ty.function
                                  [
                                    Ty.tuple
                                      [
                                        Ty.tuple
                                          [
                                            T;
                                            Ty.path "alloc::collections::btree::set_val::SetValZST"
                                          ]
                                      ]
                                  ]
                                  T),
                              M.alloc (| α0 |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                    let k := M.copy (| γ0_0 |) in
                                    M.read (| k |)))
                              ]
                            |)))
                        | _ => M.impossible "wrong number of arguments"
                        end))
                ]
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Global Instance AssociatedFunction_remove_prev :
          forall (T A : Ty.t),
          M.IsAssociatedFunction.C (Self T A) "remove_prev" (remove_prev T A).
        Admitted.
        Global Typeclasses Opaque remove_prev.
      End Impl_alloc_collections_btree_set_CursorMutKey_T_A.
      
      
    End set.
  End btree.
End collections.
