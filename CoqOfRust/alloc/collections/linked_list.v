(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module collections.
  Module linked_list.
    (* StructRecord
      {
        name := "LinkedList";
        const_params := [];
        ty_params := [ "T"; "A" ];
        fields :=
          [
            ("head",
              Ty.apply
                (Ty.path "core::option::Option")
                []
                [
                  Ty.apply
                    (Ty.path "core::ptr::non_null::NonNull")
                    []
                    [ Ty.apply (Ty.path "alloc::collections::linked_list::Node") [] [ T ] ]
                ]);
            ("tail",
              Ty.apply
                (Ty.path "core::option::Option")
                []
                [
                  Ty.apply
                    (Ty.path "core::ptr::non_null::NonNull")
                    []
                    [ Ty.apply (Ty.path "alloc::collections::linked_list::Node") [] [ T ] ]
                ]);
            ("len", Ty.path "usize");
            ("alloc", A);
            ("marker",
              Ty.apply
                (Ty.path "core::marker::PhantomData")
                []
                [
                  Ty.apply
                    (Ty.path "alloc::boxed::Box")
                    []
                    [ Ty.apply (Ty.path "alloc::collections::linked_list::Node") [] [ T ]; A ]
                ])
          ];
      } *)
    
    (* StructRecord
      {
        name := "Node";
        const_params := [];
        ty_params := [ "T" ];
        fields :=
          [
            ("next",
              Ty.apply
                (Ty.path "core::option::Option")
                []
                [
                  Ty.apply
                    (Ty.path "core::ptr::non_null::NonNull")
                    []
                    [ Ty.apply (Ty.path "alloc::collections::linked_list::Node") [] [ T ] ]
                ]);
            ("prev",
              Ty.apply
                (Ty.path "core::option::Option")
                []
                [
                  Ty.apply
                    (Ty.path "core::ptr::non_null::NonNull")
                    []
                    [ Ty.apply (Ty.path "alloc::collections::linked_list::Node") [] [ T ] ]
                ]);
            ("element", T)
          ];
      } *)
    
    (* StructRecord
      {
        name := "Iter";
        const_params := [];
        ty_params := [ "T" ];
        fields :=
          [
            ("head",
              Ty.apply
                (Ty.path "core::option::Option")
                []
                [
                  Ty.apply
                    (Ty.path "core::ptr::non_null::NonNull")
                    []
                    [ Ty.apply (Ty.path "alloc::collections::linked_list::Node") [] [ T ] ]
                ]);
            ("tail",
              Ty.apply
                (Ty.path "core::option::Option")
                []
                [
                  Ty.apply
                    (Ty.path "core::ptr::non_null::NonNull")
                    []
                    [ Ty.apply (Ty.path "alloc::collections::linked_list::Node") [] [ T ] ]
                ]);
            ("len", Ty.path "usize");
            ("marker",
              Ty.apply
                (Ty.path "core::marker::PhantomData")
                []
                [
                  Ty.apply
                    (Ty.path "&")
                    []
                    [ Ty.apply (Ty.path "alloc::collections::linked_list::Node") [] [ T ] ]
                ])
          ];
      } *)
    
    Module Impl_core_fmt_Debug_where_core_fmt_Debug_T_for_alloc_collections_linked_list_Iter_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "alloc::collections::linked_list::Iter") [] [ T ].
      
      (*
          fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
              f.debug_tuple("Iter")
                  .field(&*mem::ManuallyDrop::new(LinkedList {
                      head: self.head,
                      tail: self.tail,
                      len: self.len,
                      alloc: Global,
                      marker: PhantomData,
                  }))
                  .field(&self.len)
                  .finish()
          }
      *)
      Definition fmt (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "core::result::Result")
                []
                [ Ty.tuple []; Ty.path "core::fmt::Error" ],
              M.get_associated_function (|
                Ty.path "core::fmt::builders::DebugTuple",
                "finish",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.deref (|
                    M.call_closure (|
                      Ty.apply (Ty.path "&mut") [] [ Ty.path "core::fmt::builders::DebugTuple" ],
                      M.get_associated_function (|
                        Ty.path "core::fmt::builders::DebugTuple",
                        "field",
                        [],
                        []
                      |),
                      [
                        M.borrow (|
                          Pointer.Kind.MutRef,
                          M.deref (|
                            M.call_closure (|
                              Ty.apply
                                (Ty.path "&mut")
                                []
                                [ Ty.path "core::fmt::builders::DebugTuple" ],
                              M.get_associated_function (|
                                Ty.path "core::fmt::builders::DebugTuple",
                                "field",
                                [],
                                []
                              |),
                              [
                                M.borrow (|
                                  Pointer.Kind.MutRef,
                                  M.alloc (|
                                    M.call_closure (|
                                      Ty.path "core::fmt::builders::DebugTuple",
                                      M.get_associated_function (|
                                        Ty.path "core::fmt::Formatter",
                                        "debug_tuple",
                                        [],
                                        []
                                      |),
                                      [
                                        M.borrow (|
                                          Pointer.Kind.MutRef,
                                          M.deref (| M.read (| f |) |)
                                        |);
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.deref (| mk_str (| "Iter" |) |)
                                        |)
                                      ]
                                    |)
                                  |)
                                |);
                                (* Unsize *)
                                M.pointer_coercion
                                  (M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (|
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.deref (|
                                          M.call_closure (|
                                            Ty.apply
                                              (Ty.path "&")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path
                                                    "alloc::collections::linked_list::LinkedList")
                                                  []
                                                  [ T; Ty.path "alloc::alloc::Global" ]
                                              ],
                                            M.get_trait_method (|
                                              "core::ops::deref::Deref",
                                              Ty.apply
                                                (Ty.path "core::mem::manually_drop::ManuallyDrop")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path
                                                      "alloc::collections::linked_list::LinkedList")
                                                    []
                                                    [ T; Ty.path "alloc::alloc::Global" ]
                                                ],
                                              [],
                                              [],
                                              "deref",
                                              [],
                                              []
                                            |),
                                            [
                                              M.borrow (|
                                                Pointer.Kind.Ref,
                                                M.alloc (|
                                                  M.call_closure (|
                                                    Ty.apply
                                                      (Ty.path
                                                        "core::mem::manually_drop::ManuallyDrop")
                                                      []
                                                      [
                                                        Ty.apply
                                                          (Ty.path
                                                            "alloc::collections::linked_list::LinkedList")
                                                          []
                                                          [ T; Ty.path "alloc::alloc::Global" ]
                                                      ],
                                                    M.get_associated_function (|
                                                      Ty.apply
                                                        (Ty.path
                                                          "core::mem::manually_drop::ManuallyDrop")
                                                        []
                                                        [
                                                          Ty.apply
                                                            (Ty.path
                                                              "alloc::collections::linked_list::LinkedList")
                                                            []
                                                            [ T; Ty.path "alloc::alloc::Global" ]
                                                        ],
                                                      "new",
                                                      [],
                                                      []
                                                    |),
                                                    [
                                                      Value.StructRecord
                                                        "alloc::collections::linked_list::LinkedList"
                                                        [
                                                          ("head",
                                                            M.read (|
                                                              M.SubPointer.get_struct_record_field (|
                                                                M.deref (| M.read (| self |) |),
                                                                "alloc::collections::linked_list::Iter",
                                                                "head"
                                                              |)
                                                            |));
                                                          ("tail",
                                                            M.read (|
                                                              M.SubPointer.get_struct_record_field (|
                                                                M.deref (| M.read (| self |) |),
                                                                "alloc::collections::linked_list::Iter",
                                                                "tail"
                                                              |)
                                                            |));
                                                          ("len",
                                                            M.read (|
                                                              M.SubPointer.get_struct_record_field (|
                                                                M.deref (| M.read (| self |) |),
                                                                "alloc::collections::linked_list::Iter",
                                                                "len"
                                                              |)
                                                            |));
                                                          ("alloc",
                                                            Value.StructTuple
                                                              "alloc::alloc::Global"
                                                              []);
                                                          ("marker",
                                                            Value.StructTuple
                                                              "core::marker::PhantomData"
                                                              [])
                                                        ]
                                                    ]
                                                  |)
                                                |)
                                              |)
                                            ]
                                          |)
                                        |)
                                      |)
                                    |)
                                  |))
                              ]
                            |)
                          |)
                        |);
                        (* Unsize *)
                        M.pointer_coercion
                          (M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (|
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.SubPointer.get_struct_record_field (|
                                  M.deref (| M.read (| self |) |),
                                  "alloc::collections::linked_list::Iter",
                                  "len"
                                |)
                              |)
                            |)
                          |))
                      ]
                    |)
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::fmt::Debug"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T)
          (* Instance *) [ ("fmt", InstanceField.Method (fmt T)) ].
    End Impl_core_fmt_Debug_where_core_fmt_Debug_T_for_alloc_collections_linked_list_Iter_T.
    
    Module Impl_core_clone_Clone_for_alloc_collections_linked_list_Iter_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "alloc::collections::linked_list::Iter") [] [ T ].
      
      (*
          fn clone(&self) -> Self {
              Iter { ..*self }
          }
      *)
      Definition clone (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructTuple "alloc::collections::linked_list::Iter" []))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::clone::Clone"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T)
          (* Instance *) [ ("clone", InstanceField.Method (clone T)) ].
    End Impl_core_clone_Clone_for_alloc_collections_linked_list_Iter_T.
    
    (* StructRecord
      {
        name := "IterMut";
        const_params := [];
        ty_params := [ "T" ];
        fields :=
          [
            ("head",
              Ty.apply
                (Ty.path "core::option::Option")
                []
                [
                  Ty.apply
                    (Ty.path "core::ptr::non_null::NonNull")
                    []
                    [ Ty.apply (Ty.path "alloc::collections::linked_list::Node") [] [ T ] ]
                ]);
            ("tail",
              Ty.apply
                (Ty.path "core::option::Option")
                []
                [
                  Ty.apply
                    (Ty.path "core::ptr::non_null::NonNull")
                    []
                    [ Ty.apply (Ty.path "alloc::collections::linked_list::Node") [] [ T ] ]
                ]);
            ("len", Ty.path "usize");
            ("marker",
              Ty.apply
                (Ty.path "core::marker::PhantomData")
                []
                [
                  Ty.apply
                    (Ty.path "&mut")
                    []
                    [ Ty.apply (Ty.path "alloc::collections::linked_list::Node") [] [ T ] ]
                ])
          ];
      } *)
    
    Module Impl_core_fmt_Debug_where_core_fmt_Debug_T_for_alloc_collections_linked_list_IterMut_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "alloc::collections::linked_list::IterMut") [] [ T ].
      
      (*
          fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
              f.debug_tuple("IterMut")
                  .field(&*mem::ManuallyDrop::new(LinkedList {
                      head: self.head,
                      tail: self.tail,
                      len: self.len,
                      alloc: Global,
                      marker: PhantomData,
                  }))
                  .field(&self.len)
                  .finish()
          }
      *)
      Definition fmt (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "core::result::Result")
                []
                [ Ty.tuple []; Ty.path "core::fmt::Error" ],
              M.get_associated_function (|
                Ty.path "core::fmt::builders::DebugTuple",
                "finish",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.deref (|
                    M.call_closure (|
                      Ty.apply (Ty.path "&mut") [] [ Ty.path "core::fmt::builders::DebugTuple" ],
                      M.get_associated_function (|
                        Ty.path "core::fmt::builders::DebugTuple",
                        "field",
                        [],
                        []
                      |),
                      [
                        M.borrow (|
                          Pointer.Kind.MutRef,
                          M.deref (|
                            M.call_closure (|
                              Ty.apply
                                (Ty.path "&mut")
                                []
                                [ Ty.path "core::fmt::builders::DebugTuple" ],
                              M.get_associated_function (|
                                Ty.path "core::fmt::builders::DebugTuple",
                                "field",
                                [],
                                []
                              |),
                              [
                                M.borrow (|
                                  Pointer.Kind.MutRef,
                                  M.alloc (|
                                    M.call_closure (|
                                      Ty.path "core::fmt::builders::DebugTuple",
                                      M.get_associated_function (|
                                        Ty.path "core::fmt::Formatter",
                                        "debug_tuple",
                                        [],
                                        []
                                      |),
                                      [
                                        M.borrow (|
                                          Pointer.Kind.MutRef,
                                          M.deref (| M.read (| f |) |)
                                        |);
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.deref (| mk_str (| "IterMut" |) |)
                                        |)
                                      ]
                                    |)
                                  |)
                                |);
                                (* Unsize *)
                                M.pointer_coercion
                                  (M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (|
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.deref (|
                                          M.call_closure (|
                                            Ty.apply
                                              (Ty.path "&")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path
                                                    "alloc::collections::linked_list::LinkedList")
                                                  []
                                                  [ T; Ty.path "alloc::alloc::Global" ]
                                              ],
                                            M.get_trait_method (|
                                              "core::ops::deref::Deref",
                                              Ty.apply
                                                (Ty.path "core::mem::manually_drop::ManuallyDrop")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path
                                                      "alloc::collections::linked_list::LinkedList")
                                                    []
                                                    [ T; Ty.path "alloc::alloc::Global" ]
                                                ],
                                              [],
                                              [],
                                              "deref",
                                              [],
                                              []
                                            |),
                                            [
                                              M.borrow (|
                                                Pointer.Kind.Ref,
                                                M.alloc (|
                                                  M.call_closure (|
                                                    Ty.apply
                                                      (Ty.path
                                                        "core::mem::manually_drop::ManuallyDrop")
                                                      []
                                                      [
                                                        Ty.apply
                                                          (Ty.path
                                                            "alloc::collections::linked_list::LinkedList")
                                                          []
                                                          [ T; Ty.path "alloc::alloc::Global" ]
                                                      ],
                                                    M.get_associated_function (|
                                                      Ty.apply
                                                        (Ty.path
                                                          "core::mem::manually_drop::ManuallyDrop")
                                                        []
                                                        [
                                                          Ty.apply
                                                            (Ty.path
                                                              "alloc::collections::linked_list::LinkedList")
                                                            []
                                                            [ T; Ty.path "alloc::alloc::Global" ]
                                                        ],
                                                      "new",
                                                      [],
                                                      []
                                                    |),
                                                    [
                                                      Value.StructRecord
                                                        "alloc::collections::linked_list::LinkedList"
                                                        [
                                                          ("head",
                                                            M.read (|
                                                              M.SubPointer.get_struct_record_field (|
                                                                M.deref (| M.read (| self |) |),
                                                                "alloc::collections::linked_list::IterMut",
                                                                "head"
                                                              |)
                                                            |));
                                                          ("tail",
                                                            M.read (|
                                                              M.SubPointer.get_struct_record_field (|
                                                                M.deref (| M.read (| self |) |),
                                                                "alloc::collections::linked_list::IterMut",
                                                                "tail"
                                                              |)
                                                            |));
                                                          ("len",
                                                            M.read (|
                                                              M.SubPointer.get_struct_record_field (|
                                                                M.deref (| M.read (| self |) |),
                                                                "alloc::collections::linked_list::IterMut",
                                                                "len"
                                                              |)
                                                            |));
                                                          ("alloc",
                                                            Value.StructTuple
                                                              "alloc::alloc::Global"
                                                              []);
                                                          ("marker",
                                                            Value.StructTuple
                                                              "core::marker::PhantomData"
                                                              [])
                                                        ]
                                                    ]
                                                  |)
                                                |)
                                              |)
                                            ]
                                          |)
                                        |)
                                      |)
                                    |)
                                  |))
                              ]
                            |)
                          |)
                        |);
                        (* Unsize *)
                        M.pointer_coercion
                          (M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (|
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.SubPointer.get_struct_record_field (|
                                  M.deref (| M.read (| self |) |),
                                  "alloc::collections::linked_list::IterMut",
                                  "len"
                                |)
                              |)
                            |)
                          |))
                      ]
                    |)
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::fmt::Debug"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T)
          (* Instance *) [ ("fmt", InstanceField.Method (fmt T)) ].
    End Impl_core_fmt_Debug_where_core_fmt_Debug_T_for_alloc_collections_linked_list_IterMut_T.
    
    (* StructRecord
      {
        name := "IntoIter";
        const_params := [];
        ty_params := [ "T"; "A" ];
        fields :=
          [ ("list", Ty.apply (Ty.path "alloc::collections::linked_list::LinkedList") [] [ T; A ])
          ];
      } *)
    
    Module Impl_core_clone_Clone_where_core_clone_Clone_T_where_core_clone_Clone_A_where_core_alloc_Allocator_A_for_alloc_collections_linked_list_IntoIter_T_A.
      Definition Self (T A : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "alloc::collections::linked_list::IntoIter") [] [ T; A ].
      
      (* Clone *)
      Definition clone (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructRecord
              "alloc::collections::linked_list::IntoIter"
              [
                ("list",
                  M.call_closure (|
                    Ty.apply (Ty.path "alloc::collections::linked_list::LinkedList") [] [ T; A ],
                    M.get_trait_method (|
                      "core::clone::Clone",
                      Ty.apply (Ty.path "alloc::collections::linked_list::LinkedList") [] [ T; A ],
                      [],
                      [],
                      "clone",
                      [],
                      []
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.deref (|
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| self |) |),
                              "alloc::collections::linked_list::IntoIter",
                              "list"
                            |)
                          |)
                        |)
                      |)
                    ]
                  |))
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T A : Ty.t),
        M.IsTraitInstance
          "core::clone::Clone"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T A)
          (* Instance *) [ ("clone", InstanceField.Method (clone T A)) ].
    End Impl_core_clone_Clone_where_core_clone_Clone_T_where_core_clone_Clone_A_where_core_alloc_Allocator_A_for_alloc_collections_linked_list_IntoIter_T_A.
    
    Module Impl_core_fmt_Debug_where_core_fmt_Debug_T_where_core_alloc_Allocator_A_for_alloc_collections_linked_list_IntoIter_T_A.
      Definition Self (T A : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "alloc::collections::linked_list::IntoIter") [] [ T; A ].
      
      (*
          fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
              f.debug_tuple("IntoIter").field(&self.list).finish()
          }
      *)
      Definition fmt (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match ε, τ, α with
        | [], [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "core::result::Result")
                []
                [ Ty.tuple []; Ty.path "core::fmt::Error" ],
              M.get_associated_function (|
                Ty.path "core::fmt::builders::DebugTuple",
                "finish",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.deref (|
                    M.call_closure (|
                      Ty.apply (Ty.path "&mut") [] [ Ty.path "core::fmt::builders::DebugTuple" ],
                      M.get_associated_function (|
                        Ty.path "core::fmt::builders::DebugTuple",
                        "field",
                        [],
                        []
                      |),
                      [
                        M.borrow (|
                          Pointer.Kind.MutRef,
                          M.alloc (|
                            M.call_closure (|
                              Ty.path "core::fmt::builders::DebugTuple",
                              M.get_associated_function (|
                                Ty.path "core::fmt::Formatter",
                                "debug_tuple",
                                [],
                                []
                              |),
                              [
                                M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.deref (| mk_str (| "IntoIter" |) |)
                                |)
                              ]
                            |)
                          |)
                        |);
                        (* Unsize *)
                        M.pointer_coercion
                          (M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (|
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.SubPointer.get_struct_record_field (|
                                  M.deref (| M.read (| self |) |),
                                  "alloc::collections::linked_list::IntoIter",
                                  "list"
                                |)
                              |)
                            |)
                          |))
                      ]
                    |)
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T A : Ty.t),
        M.IsTraitInstance
          "core::fmt::Debug"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T A)
          (* Instance *) [ ("fmt", InstanceField.Method (fmt T A)) ].
    End Impl_core_fmt_Debug_where_core_fmt_Debug_T_where_core_alloc_Allocator_A_for_alloc_collections_linked_list_IntoIter_T_A.
    
    Module Impl_alloc_collections_linked_list_Node_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "alloc::collections::linked_list::Node") [] [ T ].
      
      (*
          fn new(element: T) -> Self {
              Node { next: None, prev: None, element }
          }
      *)
      Definition new (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ element ] =>
          ltac:(M.monadic
            (let element := M.alloc (| element |) in
            Value.StructRecord
              "alloc::collections::linked_list::Node"
              [
                ("next", Value.StructTuple "core::option::Option::None" []);
                ("prev", Value.StructTuple "core::option::Option::None" []);
                ("element", M.read (| element |))
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_new :
        forall (T : Ty.t),
        M.IsAssociatedFunction.C (Self T) "new" (new T).
      Admitted.
      Global Typeclasses Opaque new.
      
      (*
          fn into_element<A: Allocator>(self: Box<Self, A>) -> T {
              self.element
          }
      *)
      Definition into_element
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [ A ], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.SubPointer.get_struct_record_field (|
                M.deref (| M.read (| self |) |),
                "alloc::collections::linked_list::Node",
                "element"
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_into_element :
        forall (T : Ty.t),
        M.IsAssociatedFunction.C (Self T) "into_element" (into_element T).
      Admitted.
      Global Typeclasses Opaque into_element.
    End Impl_alloc_collections_linked_list_Node_T.
    
    Module Impl_alloc_collections_linked_list_LinkedList_T_A.
      Definition Self (T A : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "alloc::collections::linked_list::LinkedList") [] [ T; A ].
      
      (*
          unsafe fn push_front_node(&mut self, node: NonNull<Node<T>>) {
              // This method takes care not to create mutable references to whole nodes,
              // to maintain validity of aliasing pointers into `element`.
              unsafe {
                  ( *node.as_ptr()).next = self.head;
                  ( *node.as_ptr()).prev = None;
                  let node = Some(node);
      
                  match self.head {
                      None => self.tail = node,
                      // Not creating new mutable (unique!) references overlapping `element`.
                      Some(head) => ( *head.as_ptr()).prev = node,
                  }
      
                  self.head = node;
                  self.len += 1;
              }
          }
      *)
      Definition push_front_node
          (T A : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self T A in
        match ε, τ, α with
        | [], [], [ self; node ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let node := M.alloc (| node |) in
            M.read (|
              let~ _ : Ty.tuple [] :=
                M.alloc (|
                  M.write (|
                    M.SubPointer.get_struct_record_field (|
                      M.deref (|
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "*mut")
                            []
                            [ Ty.apply (Ty.path "alloc::collections::linked_list::Node") [] [ T ] ],
                          M.get_associated_function (|
                            Ty.apply
                              (Ty.path "core::ptr::non_null::NonNull")
                              []
                              [ Ty.apply (Ty.path "alloc::collections::linked_list::Node") [] [ T ]
                              ],
                            "as_ptr",
                            [],
                            []
                          |),
                          [ M.read (| node |) ]
                        |)
                      |),
                      "alloc::collections::linked_list::Node",
                      "next"
                    |),
                    M.read (|
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "alloc::collections::linked_list::LinkedList",
                        "head"
                      |)
                    |)
                  |)
                |) in
              let~ _ : Ty.tuple [] :=
                M.alloc (|
                  M.write (|
                    M.SubPointer.get_struct_record_field (|
                      M.deref (|
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "*mut")
                            []
                            [ Ty.apply (Ty.path "alloc::collections::linked_list::Node") [] [ T ] ],
                          M.get_associated_function (|
                            Ty.apply
                              (Ty.path "core::ptr::non_null::NonNull")
                              []
                              [ Ty.apply (Ty.path "alloc::collections::linked_list::Node") [] [ T ]
                              ],
                            "as_ptr",
                            [],
                            []
                          |),
                          [ M.read (| node |) ]
                        |)
                      |),
                      "alloc::collections::linked_list::Node",
                      "prev"
                    |),
                    Value.StructTuple "core::option::Option::None" []
                  |)
                |) in
              let~ node :
                  Ty.apply
                    (Ty.path "core::option::Option")
                    []
                    [
                      Ty.apply
                        (Ty.path "core::ptr::non_null::NonNull")
                        []
                        [ Ty.apply (Ty.path "alloc::collections::linked_list::Node") [] [ T ] ]
                    ] :=
                M.alloc (|
                  Value.StructTuple "core::option::Option::Some" [ M.read (| node |) ]
                |) in
              let~ _ : Ty.tuple [] :=
                M.match_operator (|
                  Some (Ty.tuple []),
                  M.SubPointer.get_struct_record_field (|
                    M.deref (| M.read (| self |) |),
                    "alloc::collections::linked_list::LinkedList",
                    "head"
                  |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let _ := M.is_struct_tuple (| γ, "core::option::Option::None" |) in
                        M.alloc (|
                          M.write (|
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| self |) |),
                              "alloc::collections::linked_list::LinkedList",
                              "tail"
                            |),
                            M.read (| node |)
                          |)
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ0_0 :=
                          M.SubPointer.get_struct_tuple_field (|
                            γ,
                            "core::option::Option::Some",
                            0
                          |) in
                        let head := M.copy (| γ0_0 |) in
                        M.alloc (|
                          M.write (|
                            M.SubPointer.get_struct_record_field (|
                              M.deref (|
                                M.call_closure (|
                                  Ty.apply
                                    (Ty.path "*mut")
                                    []
                                    [
                                      Ty.apply
                                        (Ty.path "alloc::collections::linked_list::Node")
                                        []
                                        [ T ]
                                    ],
                                  M.get_associated_function (|
                                    Ty.apply
                                      (Ty.path "core::ptr::non_null::NonNull")
                                      []
                                      [
                                        Ty.apply
                                          (Ty.path "alloc::collections::linked_list::Node")
                                          []
                                          [ T ]
                                      ],
                                    "as_ptr",
                                    [],
                                    []
                                  |),
                                  [ M.read (| head |) ]
                                |)
                              |),
                              "alloc::collections::linked_list::Node",
                              "prev"
                            |),
                            M.read (| node |)
                          |)
                        |)))
                  ]
                |) in
              let~ _ : Ty.tuple [] :=
                M.alloc (|
                  M.write (|
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| self |) |),
                      "alloc::collections::linked_list::LinkedList",
                      "head"
                    |),
                    M.read (| node |)
                  |)
                |) in
              let~ _ : Ty.tuple [] :=
                M.alloc (|
                  let β :=
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| self |) |),
                      "alloc::collections::linked_list::LinkedList",
                      "len"
                    |) in
                  M.write (|
                    β,
                    M.call_closure (|
                      Ty.path "usize",
                      BinOp.Wrap.add,
                      [ M.read (| β |); Value.Integer IntegerKind.Usize 1 ]
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_push_front_node :
        forall (T A : Ty.t),
        M.IsAssociatedFunction.C (Self T A) "push_front_node" (push_front_node T A).
      Admitted.
      Global Typeclasses Opaque push_front_node.
      
      (*
          fn pop_front_node(&mut self) -> Option<Box<Node<T>, &A>> {
              // This method takes care not to create mutable references to whole nodes,
              // to maintain validity of aliasing pointers into `element`.
              self.head.map(|node| unsafe {
                  let node = Box::from_raw_in(node.as_ptr(), &self.alloc);
                  self.head = node.next;
      
                  match self.head {
                      None => self.tail = None,
                      // Not creating new mutable (unique!) references overlapping `element`.
                      Some(head) => ( *head.as_ptr()).prev = None,
                  }
      
                  self.len -= 1;
                  node
              })
          }
      *)
      Definition pop_front_node
          (T A : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self T A in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "core::option::Option")
                []
                [
                  Ty.apply
                    (Ty.path "alloc::boxed::Box")
                    []
                    [
                      Ty.apply (Ty.path "alloc::collections::linked_list::Node") [] [ T ];
                      Ty.apply (Ty.path "&") [] [ A ]
                    ]
                ],
              M.get_associated_function (|
                Ty.apply
                  (Ty.path "core::option::Option")
                  []
                  [
                    Ty.apply
                      (Ty.path "core::ptr::non_null::NonNull")
                      []
                      [ Ty.apply (Ty.path "alloc::collections::linked_list::Node") [] [ T ] ]
                  ],
                "map",
                [],
                [
                  Ty.apply
                    (Ty.path "alloc::boxed::Box")
                    []
                    [
                      Ty.apply (Ty.path "alloc::collections::linked_list::Node") [] [ T ];
                      Ty.apply (Ty.path "&") [] [ A ]
                    ];
                  Ty.function
                    [
                      Ty.tuple
                        [
                          Ty.apply
                            (Ty.path "core::ptr::non_null::NonNull")
                            []
                            [ Ty.apply (Ty.path "alloc::collections::linked_list::Node") [] [ T ] ]
                        ]
                    ]
                    (Ty.apply
                      (Ty.path "alloc::boxed::Box")
                      []
                      [
                        Ty.apply (Ty.path "alloc::collections::linked_list::Node") [] [ T ];
                        Ty.apply (Ty.path "&") [] [ A ]
                      ])
                ]
              |),
              [
                M.read (|
                  M.SubPointer.get_struct_record_field (|
                    M.deref (| M.read (| self |) |),
                    "alloc::collections::linked_list::LinkedList",
                    "head"
                  |)
                |);
                M.closure
                  (fun γ =>
                    ltac:(M.monadic
                      match γ with
                      | [ α0 ] =>
                        ltac:(M.monadic
                          (M.match_operator (|
                            Some
                              (Ty.function
                                [
                                  Ty.tuple
                                    [
                                      Ty.apply
                                        (Ty.path "core::ptr::non_null::NonNull")
                                        []
                                        [
                                          Ty.apply
                                            (Ty.path "alloc::collections::linked_list::Node")
                                            []
                                            [ T ]
                                        ]
                                    ]
                                ]
                                (Ty.apply
                                  (Ty.path "alloc::boxed::Box")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "alloc::collections::linked_list::Node")
                                      []
                                      [ T ];
                                    Ty.apply (Ty.path "&") [] [ A ]
                                  ])),
                            M.alloc (| α0 |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let node := M.copy (| γ |) in
                                  M.read (|
                                    let~ node :
                                        Ty.apply
                                          (Ty.path "alloc::boxed::Box")
                                          []
                                          [
                                            Ty.apply
                                              (Ty.path "alloc::collections::linked_list::Node")
                                              []
                                              [ T ];
                                            Ty.apply (Ty.path "&") [] [ A ]
                                          ] :=
                                      M.alloc (|
                                        M.call_closure (|
                                          Ty.apply
                                            (Ty.path "alloc::boxed::Box")
                                            []
                                            [
                                              Ty.apply
                                                (Ty.path "alloc::collections::linked_list::Node")
                                                []
                                                [ T ];
                                              Ty.apply (Ty.path "&") [] [ A ]
                                            ],
                                          M.get_associated_function (|
                                            Ty.apply
                                              (Ty.path "alloc::boxed::Box")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "alloc::collections::linked_list::Node")
                                                  []
                                                  [ T ];
                                                Ty.apply (Ty.path "&") [] [ A ]
                                              ],
                                            "from_raw_in",
                                            [],
                                            []
                                          |),
                                          [
                                            M.call_closure (|
                                              Ty.apply
                                                (Ty.path "*mut")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path
                                                      "alloc::collections::linked_list::Node")
                                                    []
                                                    [ T ]
                                                ],
                                              M.get_associated_function (|
                                                Ty.apply
                                                  (Ty.path "core::ptr::non_null::NonNull")
                                                  []
                                                  [
                                                    Ty.apply
                                                      (Ty.path
                                                        "alloc::collections::linked_list::Node")
                                                      []
                                                      [ T ]
                                                  ],
                                                "as_ptr",
                                                [],
                                                []
                                              |),
                                              [ M.read (| node |) ]
                                            |);
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.SubPointer.get_struct_record_field (|
                                                M.deref (| M.read (| self |) |),
                                                "alloc::collections::linked_list::LinkedList",
                                                "alloc"
                                              |)
                                            |)
                                          ]
                                        |)
                                      |) in
                                    let~ _ : Ty.tuple [] :=
                                      M.alloc (|
                                        M.write (|
                                          M.SubPointer.get_struct_record_field (|
                                            M.deref (| M.read (| self |) |),
                                            "alloc::collections::linked_list::LinkedList",
                                            "head"
                                          |),
                                          M.read (|
                                            M.SubPointer.get_struct_record_field (|
                                              M.deref (| M.read (| node |) |),
                                              "alloc::collections::linked_list::Node",
                                              "next"
                                            |)
                                          |)
                                        |)
                                      |) in
                                    let~ _ : Ty.tuple [] :=
                                      M.match_operator (|
                                        Some (Ty.tuple []),
                                        M.SubPointer.get_struct_record_field (|
                                          M.deref (| M.read (| self |) |),
                                          "alloc::collections::linked_list::LinkedList",
                                          "head"
                                        |),
                                        [
                                          fun γ =>
                                            ltac:(M.monadic
                                              (let _ :=
                                                M.is_struct_tuple (|
                                                  γ,
                                                  "core::option::Option::None"
                                                |) in
                                              M.alloc (|
                                                M.write (|
                                                  M.SubPointer.get_struct_record_field (|
                                                    M.deref (| M.read (| self |) |),
                                                    "alloc::collections::linked_list::LinkedList",
                                                    "tail"
                                                  |),
                                                  Value.StructTuple "core::option::Option::None" []
                                                |)
                                              |)));
                                          fun γ =>
                                            ltac:(M.monadic
                                              (let γ0_0 :=
                                                M.SubPointer.get_struct_tuple_field (|
                                                  γ,
                                                  "core::option::Option::Some",
                                                  0
                                                |) in
                                              let head := M.copy (| γ0_0 |) in
                                              M.alloc (|
                                                M.write (|
                                                  M.SubPointer.get_struct_record_field (|
                                                    M.deref (|
                                                      M.call_closure (|
                                                        Ty.apply
                                                          (Ty.path "*mut")
                                                          []
                                                          [
                                                            Ty.apply
                                                              (Ty.path
                                                                "alloc::collections::linked_list::Node")
                                                              []
                                                              [ T ]
                                                          ],
                                                        M.get_associated_function (|
                                                          Ty.apply
                                                            (Ty.path "core::ptr::non_null::NonNull")
                                                            []
                                                            [
                                                              Ty.apply
                                                                (Ty.path
                                                                  "alloc::collections::linked_list::Node")
                                                                []
                                                                [ T ]
                                                            ],
                                                          "as_ptr",
                                                          [],
                                                          []
                                                        |),
                                                        [ M.read (| head |) ]
                                                      |)
                                                    |),
                                                    "alloc::collections::linked_list::Node",
                                                    "prev"
                                                  |),
                                                  Value.StructTuple "core::option::Option::None" []
                                                |)
                                              |)))
                                        ]
                                      |) in
                                    let~ _ : Ty.tuple [] :=
                                      M.alloc (|
                                        let β :=
                                          M.SubPointer.get_struct_record_field (|
                                            M.deref (| M.read (| self |) |),
                                            "alloc::collections::linked_list::LinkedList",
                                            "len"
                                          |) in
                                        M.write (|
                                          β,
                                          M.call_closure (|
                                            Ty.path "usize",
                                            BinOp.Wrap.sub,
                                            [ M.read (| β |); Value.Integer IntegerKind.Usize 1 ]
                                          |)
                                        |)
                                      |) in
                                    node
                                  |)))
                            ]
                          |)))
                      | _ => M.impossible "wrong number of arguments"
                      end))
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_pop_front_node :
        forall (T A : Ty.t),
        M.IsAssociatedFunction.C (Self T A) "pop_front_node" (pop_front_node T A).
      Admitted.
      Global Typeclasses Opaque pop_front_node.
      
      (*
          unsafe fn push_back_node(&mut self, node: NonNull<Node<T>>) {
              // This method takes care not to create mutable references to whole nodes,
              // to maintain validity of aliasing pointers into `element`.
              unsafe {
                  ( *node.as_ptr()).next = None;
                  ( *node.as_ptr()).prev = self.tail;
                  let node = Some(node);
      
                  match self.tail {
                      None => self.head = node,
                      // Not creating new mutable (unique!) references overlapping `element`.
                      Some(tail) => ( *tail.as_ptr()).next = node,
                  }
      
                  self.tail = node;
                  self.len += 1;
              }
          }
      *)
      Definition push_back_node
          (T A : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self T A in
        match ε, τ, α with
        | [], [], [ self; node ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let node := M.alloc (| node |) in
            M.read (|
              let~ _ : Ty.tuple [] :=
                M.alloc (|
                  M.write (|
                    M.SubPointer.get_struct_record_field (|
                      M.deref (|
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "*mut")
                            []
                            [ Ty.apply (Ty.path "alloc::collections::linked_list::Node") [] [ T ] ],
                          M.get_associated_function (|
                            Ty.apply
                              (Ty.path "core::ptr::non_null::NonNull")
                              []
                              [ Ty.apply (Ty.path "alloc::collections::linked_list::Node") [] [ T ]
                              ],
                            "as_ptr",
                            [],
                            []
                          |),
                          [ M.read (| node |) ]
                        |)
                      |),
                      "alloc::collections::linked_list::Node",
                      "next"
                    |),
                    Value.StructTuple "core::option::Option::None" []
                  |)
                |) in
              let~ _ : Ty.tuple [] :=
                M.alloc (|
                  M.write (|
                    M.SubPointer.get_struct_record_field (|
                      M.deref (|
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "*mut")
                            []
                            [ Ty.apply (Ty.path "alloc::collections::linked_list::Node") [] [ T ] ],
                          M.get_associated_function (|
                            Ty.apply
                              (Ty.path "core::ptr::non_null::NonNull")
                              []
                              [ Ty.apply (Ty.path "alloc::collections::linked_list::Node") [] [ T ]
                              ],
                            "as_ptr",
                            [],
                            []
                          |),
                          [ M.read (| node |) ]
                        |)
                      |),
                      "alloc::collections::linked_list::Node",
                      "prev"
                    |),
                    M.read (|
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "alloc::collections::linked_list::LinkedList",
                        "tail"
                      |)
                    |)
                  |)
                |) in
              let~ node :
                  Ty.apply
                    (Ty.path "core::option::Option")
                    []
                    [
                      Ty.apply
                        (Ty.path "core::ptr::non_null::NonNull")
                        []
                        [ Ty.apply (Ty.path "alloc::collections::linked_list::Node") [] [ T ] ]
                    ] :=
                M.alloc (|
                  Value.StructTuple "core::option::Option::Some" [ M.read (| node |) ]
                |) in
              let~ _ : Ty.tuple [] :=
                M.match_operator (|
                  Some (Ty.tuple []),
                  M.SubPointer.get_struct_record_field (|
                    M.deref (| M.read (| self |) |),
                    "alloc::collections::linked_list::LinkedList",
                    "tail"
                  |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let _ := M.is_struct_tuple (| γ, "core::option::Option::None" |) in
                        M.alloc (|
                          M.write (|
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| self |) |),
                              "alloc::collections::linked_list::LinkedList",
                              "head"
                            |),
                            M.read (| node |)
                          |)
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ0_0 :=
                          M.SubPointer.get_struct_tuple_field (|
                            γ,
                            "core::option::Option::Some",
                            0
                          |) in
                        let tail := M.copy (| γ0_0 |) in
                        M.alloc (|
                          M.write (|
                            M.SubPointer.get_struct_record_field (|
                              M.deref (|
                                M.call_closure (|
                                  Ty.apply
                                    (Ty.path "*mut")
                                    []
                                    [
                                      Ty.apply
                                        (Ty.path "alloc::collections::linked_list::Node")
                                        []
                                        [ T ]
                                    ],
                                  M.get_associated_function (|
                                    Ty.apply
                                      (Ty.path "core::ptr::non_null::NonNull")
                                      []
                                      [
                                        Ty.apply
                                          (Ty.path "alloc::collections::linked_list::Node")
                                          []
                                          [ T ]
                                      ],
                                    "as_ptr",
                                    [],
                                    []
                                  |),
                                  [ M.read (| tail |) ]
                                |)
                              |),
                              "alloc::collections::linked_list::Node",
                              "next"
                            |),
                            M.read (| node |)
                          |)
                        |)))
                  ]
                |) in
              let~ _ : Ty.tuple [] :=
                M.alloc (|
                  M.write (|
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| self |) |),
                      "alloc::collections::linked_list::LinkedList",
                      "tail"
                    |),
                    M.read (| node |)
                  |)
                |) in
              let~ _ : Ty.tuple [] :=
                M.alloc (|
                  let β :=
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| self |) |),
                      "alloc::collections::linked_list::LinkedList",
                      "len"
                    |) in
                  M.write (|
                    β,
                    M.call_closure (|
                      Ty.path "usize",
                      BinOp.Wrap.add,
                      [ M.read (| β |); Value.Integer IntegerKind.Usize 1 ]
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_push_back_node :
        forall (T A : Ty.t),
        M.IsAssociatedFunction.C (Self T A) "push_back_node" (push_back_node T A).
      Admitted.
      Global Typeclasses Opaque push_back_node.
      
      (*
          fn pop_back_node(&mut self) -> Option<Box<Node<T>, &A>> {
              // This method takes care not to create mutable references to whole nodes,
              // to maintain validity of aliasing pointers into `element`.
              self.tail.map(|node| unsafe {
                  let node = Box::from_raw_in(node.as_ptr(), &self.alloc);
                  self.tail = node.prev;
      
                  match self.tail {
                      None => self.head = None,
                      // Not creating new mutable (unique!) references overlapping `element`.
                      Some(tail) => ( *tail.as_ptr()).next = None,
                  }
      
                  self.len -= 1;
                  node
              })
          }
      *)
      Definition pop_back_node
          (T A : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self T A in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "core::option::Option")
                []
                [
                  Ty.apply
                    (Ty.path "alloc::boxed::Box")
                    []
                    [
                      Ty.apply (Ty.path "alloc::collections::linked_list::Node") [] [ T ];
                      Ty.apply (Ty.path "&") [] [ A ]
                    ]
                ],
              M.get_associated_function (|
                Ty.apply
                  (Ty.path "core::option::Option")
                  []
                  [
                    Ty.apply
                      (Ty.path "core::ptr::non_null::NonNull")
                      []
                      [ Ty.apply (Ty.path "alloc::collections::linked_list::Node") [] [ T ] ]
                  ],
                "map",
                [],
                [
                  Ty.apply
                    (Ty.path "alloc::boxed::Box")
                    []
                    [
                      Ty.apply (Ty.path "alloc::collections::linked_list::Node") [] [ T ];
                      Ty.apply (Ty.path "&") [] [ A ]
                    ];
                  Ty.function
                    [
                      Ty.tuple
                        [
                          Ty.apply
                            (Ty.path "core::ptr::non_null::NonNull")
                            []
                            [ Ty.apply (Ty.path "alloc::collections::linked_list::Node") [] [ T ] ]
                        ]
                    ]
                    (Ty.apply
                      (Ty.path "alloc::boxed::Box")
                      []
                      [
                        Ty.apply (Ty.path "alloc::collections::linked_list::Node") [] [ T ];
                        Ty.apply (Ty.path "&") [] [ A ]
                      ])
                ]
              |),
              [
                M.read (|
                  M.SubPointer.get_struct_record_field (|
                    M.deref (| M.read (| self |) |),
                    "alloc::collections::linked_list::LinkedList",
                    "tail"
                  |)
                |);
                M.closure
                  (fun γ =>
                    ltac:(M.monadic
                      match γ with
                      | [ α0 ] =>
                        ltac:(M.monadic
                          (M.match_operator (|
                            Some
                              (Ty.function
                                [
                                  Ty.tuple
                                    [
                                      Ty.apply
                                        (Ty.path "core::ptr::non_null::NonNull")
                                        []
                                        [
                                          Ty.apply
                                            (Ty.path "alloc::collections::linked_list::Node")
                                            []
                                            [ T ]
                                        ]
                                    ]
                                ]
                                (Ty.apply
                                  (Ty.path "alloc::boxed::Box")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "alloc::collections::linked_list::Node")
                                      []
                                      [ T ];
                                    Ty.apply (Ty.path "&") [] [ A ]
                                  ])),
                            M.alloc (| α0 |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let node := M.copy (| γ |) in
                                  M.read (|
                                    let~ node :
                                        Ty.apply
                                          (Ty.path "alloc::boxed::Box")
                                          []
                                          [
                                            Ty.apply
                                              (Ty.path "alloc::collections::linked_list::Node")
                                              []
                                              [ T ];
                                            Ty.apply (Ty.path "&") [] [ A ]
                                          ] :=
                                      M.alloc (|
                                        M.call_closure (|
                                          Ty.apply
                                            (Ty.path "alloc::boxed::Box")
                                            []
                                            [
                                              Ty.apply
                                                (Ty.path "alloc::collections::linked_list::Node")
                                                []
                                                [ T ];
                                              Ty.apply (Ty.path "&") [] [ A ]
                                            ],
                                          M.get_associated_function (|
                                            Ty.apply
                                              (Ty.path "alloc::boxed::Box")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "alloc::collections::linked_list::Node")
                                                  []
                                                  [ T ];
                                                Ty.apply (Ty.path "&") [] [ A ]
                                              ],
                                            "from_raw_in",
                                            [],
                                            []
                                          |),
                                          [
                                            M.call_closure (|
                                              Ty.apply
                                                (Ty.path "*mut")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path
                                                      "alloc::collections::linked_list::Node")
                                                    []
                                                    [ T ]
                                                ],
                                              M.get_associated_function (|
                                                Ty.apply
                                                  (Ty.path "core::ptr::non_null::NonNull")
                                                  []
                                                  [
                                                    Ty.apply
                                                      (Ty.path
                                                        "alloc::collections::linked_list::Node")
                                                      []
                                                      [ T ]
                                                  ],
                                                "as_ptr",
                                                [],
                                                []
                                              |),
                                              [ M.read (| node |) ]
                                            |);
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.SubPointer.get_struct_record_field (|
                                                M.deref (| M.read (| self |) |),
                                                "alloc::collections::linked_list::LinkedList",
                                                "alloc"
                                              |)
                                            |)
                                          ]
                                        |)
                                      |) in
                                    let~ _ : Ty.tuple [] :=
                                      M.alloc (|
                                        M.write (|
                                          M.SubPointer.get_struct_record_field (|
                                            M.deref (| M.read (| self |) |),
                                            "alloc::collections::linked_list::LinkedList",
                                            "tail"
                                          |),
                                          M.read (|
                                            M.SubPointer.get_struct_record_field (|
                                              M.deref (| M.read (| node |) |),
                                              "alloc::collections::linked_list::Node",
                                              "prev"
                                            |)
                                          |)
                                        |)
                                      |) in
                                    let~ _ : Ty.tuple [] :=
                                      M.match_operator (|
                                        Some (Ty.tuple []),
                                        M.SubPointer.get_struct_record_field (|
                                          M.deref (| M.read (| self |) |),
                                          "alloc::collections::linked_list::LinkedList",
                                          "tail"
                                        |),
                                        [
                                          fun γ =>
                                            ltac:(M.monadic
                                              (let _ :=
                                                M.is_struct_tuple (|
                                                  γ,
                                                  "core::option::Option::None"
                                                |) in
                                              M.alloc (|
                                                M.write (|
                                                  M.SubPointer.get_struct_record_field (|
                                                    M.deref (| M.read (| self |) |),
                                                    "alloc::collections::linked_list::LinkedList",
                                                    "head"
                                                  |),
                                                  Value.StructTuple "core::option::Option::None" []
                                                |)
                                              |)));
                                          fun γ =>
                                            ltac:(M.monadic
                                              (let γ0_0 :=
                                                M.SubPointer.get_struct_tuple_field (|
                                                  γ,
                                                  "core::option::Option::Some",
                                                  0
                                                |) in
                                              let tail := M.copy (| γ0_0 |) in
                                              M.alloc (|
                                                M.write (|
                                                  M.SubPointer.get_struct_record_field (|
                                                    M.deref (|
                                                      M.call_closure (|
                                                        Ty.apply
                                                          (Ty.path "*mut")
                                                          []
                                                          [
                                                            Ty.apply
                                                              (Ty.path
                                                                "alloc::collections::linked_list::Node")
                                                              []
                                                              [ T ]
                                                          ],
                                                        M.get_associated_function (|
                                                          Ty.apply
                                                            (Ty.path "core::ptr::non_null::NonNull")
                                                            []
                                                            [
                                                              Ty.apply
                                                                (Ty.path
                                                                  "alloc::collections::linked_list::Node")
                                                                []
                                                                [ T ]
                                                            ],
                                                          "as_ptr",
                                                          [],
                                                          []
                                                        |),
                                                        [ M.read (| tail |) ]
                                                      |)
                                                    |),
                                                    "alloc::collections::linked_list::Node",
                                                    "next"
                                                  |),
                                                  Value.StructTuple "core::option::Option::None" []
                                                |)
                                              |)))
                                        ]
                                      |) in
                                    let~ _ : Ty.tuple [] :=
                                      M.alloc (|
                                        let β :=
                                          M.SubPointer.get_struct_record_field (|
                                            M.deref (| M.read (| self |) |),
                                            "alloc::collections::linked_list::LinkedList",
                                            "len"
                                          |) in
                                        M.write (|
                                          β,
                                          M.call_closure (|
                                            Ty.path "usize",
                                            BinOp.Wrap.sub,
                                            [ M.read (| β |); Value.Integer IntegerKind.Usize 1 ]
                                          |)
                                        |)
                                      |) in
                                    node
                                  |)))
                            ]
                          |)))
                      | _ => M.impossible "wrong number of arguments"
                      end))
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_pop_back_node :
        forall (T A : Ty.t),
        M.IsAssociatedFunction.C (Self T A) "pop_back_node" (pop_back_node T A).
      Admitted.
      Global Typeclasses Opaque pop_back_node.
      
      (*
          unsafe fn unlink_node(&mut self, mut node: NonNull<Node<T>>) {
              let node = unsafe { node.as_mut() }; // this one is ours now, we can create an &mut.
      
              // Not creating new mutable (unique!) references overlapping `element`.
              match node.prev {
                  Some(prev) => unsafe { ( *prev.as_ptr()).next = node.next },
                  // this node is the head node
                  None => self.head = node.next,
              };
      
              match node.next {
                  Some(next) => unsafe { ( *next.as_ptr()).prev = node.prev },
                  // this node is the tail node
                  None => self.tail = node.prev,
              };
      
              self.len -= 1;
          }
      *)
      Definition unlink_node
          (T A : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self T A in
        match ε, τ, α with
        | [], [], [ self; node ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let node := M.alloc (| node |) in
            M.read (|
              let~ node :
                  Ty.apply
                    (Ty.path "&mut")
                    []
                    [ Ty.apply (Ty.path "alloc::collections::linked_list::Node") [] [ T ] ] :=
                M.alloc (|
                  M.borrow (|
                    Pointer.Kind.MutRef,
                    M.deref (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "&mut")
                          []
                          [ Ty.apply (Ty.path "alloc::collections::linked_list::Node") [] [ T ] ],
                        M.get_associated_function (|
                          Ty.apply
                            (Ty.path "core::ptr::non_null::NonNull")
                            []
                            [ Ty.apply (Ty.path "alloc::collections::linked_list::Node") [] [ T ] ],
                          "as_mut",
                          [],
                          []
                        |),
                        [ M.borrow (| Pointer.Kind.MutRef, node |) ]
                      |)
                    |)
                  |)
                |) in
              let~ _ : Ty.tuple [] :=
                M.match_operator (|
                  Some (Ty.tuple []),
                  M.SubPointer.get_struct_record_field (|
                    M.deref (| M.read (| node |) |),
                    "alloc::collections::linked_list::Node",
                    "prev"
                  |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ0_0 :=
                          M.SubPointer.get_struct_tuple_field (|
                            γ,
                            "core::option::Option::Some",
                            0
                          |) in
                        let prev := M.copy (| γ0_0 |) in
                        M.alloc (|
                          M.write (|
                            M.SubPointer.get_struct_record_field (|
                              M.deref (|
                                M.call_closure (|
                                  Ty.apply
                                    (Ty.path "*mut")
                                    []
                                    [
                                      Ty.apply
                                        (Ty.path "alloc::collections::linked_list::Node")
                                        []
                                        [ T ]
                                    ],
                                  M.get_associated_function (|
                                    Ty.apply
                                      (Ty.path "core::ptr::non_null::NonNull")
                                      []
                                      [
                                        Ty.apply
                                          (Ty.path "alloc::collections::linked_list::Node")
                                          []
                                          [ T ]
                                      ],
                                    "as_ptr",
                                    [],
                                    []
                                  |),
                                  [ M.read (| prev |) ]
                                |)
                              |),
                              "alloc::collections::linked_list::Node",
                              "next"
                            |),
                            M.read (|
                              M.SubPointer.get_struct_record_field (|
                                M.deref (| M.read (| node |) |),
                                "alloc::collections::linked_list::Node",
                                "next"
                              |)
                            |)
                          |)
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let _ := M.is_struct_tuple (| γ, "core::option::Option::None" |) in
                        M.alloc (|
                          M.write (|
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| self |) |),
                              "alloc::collections::linked_list::LinkedList",
                              "head"
                            |),
                            M.read (|
                              M.SubPointer.get_struct_record_field (|
                                M.deref (| M.read (| node |) |),
                                "alloc::collections::linked_list::Node",
                                "next"
                              |)
                            |)
                          |)
                        |)))
                  ]
                |) in
              let~ _ : Ty.tuple [] :=
                M.match_operator (|
                  Some (Ty.tuple []),
                  M.SubPointer.get_struct_record_field (|
                    M.deref (| M.read (| node |) |),
                    "alloc::collections::linked_list::Node",
                    "next"
                  |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ0_0 :=
                          M.SubPointer.get_struct_tuple_field (|
                            γ,
                            "core::option::Option::Some",
                            0
                          |) in
                        let next := M.copy (| γ0_0 |) in
                        M.alloc (|
                          M.write (|
                            M.SubPointer.get_struct_record_field (|
                              M.deref (|
                                M.call_closure (|
                                  Ty.apply
                                    (Ty.path "*mut")
                                    []
                                    [
                                      Ty.apply
                                        (Ty.path "alloc::collections::linked_list::Node")
                                        []
                                        [ T ]
                                    ],
                                  M.get_associated_function (|
                                    Ty.apply
                                      (Ty.path "core::ptr::non_null::NonNull")
                                      []
                                      [
                                        Ty.apply
                                          (Ty.path "alloc::collections::linked_list::Node")
                                          []
                                          [ T ]
                                      ],
                                    "as_ptr",
                                    [],
                                    []
                                  |),
                                  [ M.read (| next |) ]
                                |)
                              |),
                              "alloc::collections::linked_list::Node",
                              "prev"
                            |),
                            M.read (|
                              M.SubPointer.get_struct_record_field (|
                                M.deref (| M.read (| node |) |),
                                "alloc::collections::linked_list::Node",
                                "prev"
                              |)
                            |)
                          |)
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let _ := M.is_struct_tuple (| γ, "core::option::Option::None" |) in
                        M.alloc (|
                          M.write (|
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| self |) |),
                              "alloc::collections::linked_list::LinkedList",
                              "tail"
                            |),
                            M.read (|
                              M.SubPointer.get_struct_record_field (|
                                M.deref (| M.read (| node |) |),
                                "alloc::collections::linked_list::Node",
                                "prev"
                              |)
                            |)
                          |)
                        |)))
                  ]
                |) in
              let~ _ : Ty.tuple [] :=
                M.alloc (|
                  let β :=
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| self |) |),
                      "alloc::collections::linked_list::LinkedList",
                      "len"
                    |) in
                  M.write (|
                    β,
                    M.call_closure (|
                      Ty.path "usize",
                      BinOp.Wrap.sub,
                      [ M.read (| β |); Value.Integer IntegerKind.Usize 1 ]
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_unlink_node :
        forall (T A : Ty.t),
        M.IsAssociatedFunction.C (Self T A) "unlink_node" (unlink_node T A).
      Admitted.
      Global Typeclasses Opaque unlink_node.
      
      (*
          unsafe fn splice_nodes(
              &mut self,
              existing_prev: Option<NonNull<Node<T>>>,
              existing_next: Option<NonNull<Node<T>>>,
              mut splice_start: NonNull<Node<T>>,
              mut splice_end: NonNull<Node<T>>,
              splice_length: usize,
          ) {
              // This method takes care not to create multiple mutable references to whole nodes at the same time,
              // to maintain validity of aliasing pointers into `element`.
              if let Some(mut existing_prev) = existing_prev {
                  unsafe {
                      existing_prev.as_mut().next = Some(splice_start);
                  }
              } else {
                  self.head = Some(splice_start);
              }
              if let Some(mut existing_next) = existing_next {
                  unsafe {
                      existing_next.as_mut().prev = Some(splice_end);
                  }
              } else {
                  self.tail = Some(splice_end);
              }
              unsafe {
                  splice_start.as_mut().prev = existing_prev;
                  splice_end.as_mut().next = existing_next;
              }
      
              self.len += splice_length;
          }
      *)
      Definition splice_nodes
          (T A : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self T A in
        match ε, τ, α with
        | [], [], [ self; existing_prev; existing_next; splice_start; splice_end; splice_length ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let existing_prev := M.alloc (| existing_prev |) in
            let existing_next := M.alloc (| existing_next |) in
            let splice_start := M.alloc (| splice_start |) in
            let splice_end := M.alloc (| splice_end |) in
            let splice_length := M.alloc (| splice_length |) in
            M.read (|
              let~ _ : Ty.tuple [] :=
                M.match_operator (|
                  Some (Ty.tuple []),
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := existing_prev in
                        let γ0_0 :=
                          M.SubPointer.get_struct_tuple_field (|
                            γ,
                            "core::option::Option::Some",
                            0
                          |) in
                        let existing_prev := M.copy (| γ0_0 |) in
                        let~ _ : Ty.tuple [] :=
                          M.alloc (|
                            M.write (|
                              M.SubPointer.get_struct_record_field (|
                                M.deref (|
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "&mut")
                                      []
                                      [
                                        Ty.apply
                                          (Ty.path "alloc::collections::linked_list::Node")
                                          []
                                          [ T ]
                                      ],
                                    M.get_associated_function (|
                                      Ty.apply
                                        (Ty.path "core::ptr::non_null::NonNull")
                                        []
                                        [
                                          Ty.apply
                                            (Ty.path "alloc::collections::linked_list::Node")
                                            []
                                            [ T ]
                                        ],
                                      "as_mut",
                                      [],
                                      []
                                    |),
                                    [ M.borrow (| Pointer.Kind.MutRef, existing_prev |) ]
                                  |)
                                |),
                                "alloc::collections::linked_list::Node",
                                "next"
                              |),
                              Value.StructTuple
                                "core::option::Option::Some"
                                [ M.read (| splice_start |) ]
                            |)
                          |) in
                        M.alloc (| Value.Tuple [] |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let~ _ : Ty.tuple [] :=
                          M.alloc (|
                            M.write (|
                              M.SubPointer.get_struct_record_field (|
                                M.deref (| M.read (| self |) |),
                                "alloc::collections::linked_list::LinkedList",
                                "head"
                              |),
                              Value.StructTuple
                                "core::option::Option::Some"
                                [ M.read (| splice_start |) ]
                            |)
                          |) in
                        M.alloc (| Value.Tuple [] |)))
                  ]
                |) in
              let~ _ : Ty.tuple [] :=
                M.match_operator (|
                  Some (Ty.tuple []),
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := existing_next in
                        let γ0_0 :=
                          M.SubPointer.get_struct_tuple_field (|
                            γ,
                            "core::option::Option::Some",
                            0
                          |) in
                        let existing_next := M.copy (| γ0_0 |) in
                        let~ _ : Ty.tuple [] :=
                          M.alloc (|
                            M.write (|
                              M.SubPointer.get_struct_record_field (|
                                M.deref (|
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "&mut")
                                      []
                                      [
                                        Ty.apply
                                          (Ty.path "alloc::collections::linked_list::Node")
                                          []
                                          [ T ]
                                      ],
                                    M.get_associated_function (|
                                      Ty.apply
                                        (Ty.path "core::ptr::non_null::NonNull")
                                        []
                                        [
                                          Ty.apply
                                            (Ty.path "alloc::collections::linked_list::Node")
                                            []
                                            [ T ]
                                        ],
                                      "as_mut",
                                      [],
                                      []
                                    |),
                                    [ M.borrow (| Pointer.Kind.MutRef, existing_next |) ]
                                  |)
                                |),
                                "alloc::collections::linked_list::Node",
                                "prev"
                              |),
                              Value.StructTuple
                                "core::option::Option::Some"
                                [ M.read (| splice_end |) ]
                            |)
                          |) in
                        M.alloc (| Value.Tuple [] |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let~ _ : Ty.tuple [] :=
                          M.alloc (|
                            M.write (|
                              M.SubPointer.get_struct_record_field (|
                                M.deref (| M.read (| self |) |),
                                "alloc::collections::linked_list::LinkedList",
                                "tail"
                              |),
                              Value.StructTuple
                                "core::option::Option::Some"
                                [ M.read (| splice_end |) ]
                            |)
                          |) in
                        M.alloc (| Value.Tuple [] |)))
                  ]
                |) in
              let~ _ : Ty.tuple [] :=
                let~ _ : Ty.tuple [] :=
                  M.alloc (|
                    M.write (|
                      M.SubPointer.get_struct_record_field (|
                        M.deref (|
                          M.call_closure (|
                            Ty.apply
                              (Ty.path "&mut")
                              []
                              [ Ty.apply (Ty.path "alloc::collections::linked_list::Node") [] [ T ]
                              ],
                            M.get_associated_function (|
                              Ty.apply
                                (Ty.path "core::ptr::non_null::NonNull")
                                []
                                [
                                  Ty.apply
                                    (Ty.path "alloc::collections::linked_list::Node")
                                    []
                                    [ T ]
                                ],
                              "as_mut",
                              [],
                              []
                            |),
                            [ M.borrow (| Pointer.Kind.MutRef, splice_start |) ]
                          |)
                        |),
                        "alloc::collections::linked_list::Node",
                        "prev"
                      |),
                      M.read (| existing_prev |)
                    |)
                  |) in
                let~ _ : Ty.tuple [] :=
                  M.alloc (|
                    M.write (|
                      M.SubPointer.get_struct_record_field (|
                        M.deref (|
                          M.call_closure (|
                            Ty.apply
                              (Ty.path "&mut")
                              []
                              [ Ty.apply (Ty.path "alloc::collections::linked_list::Node") [] [ T ]
                              ],
                            M.get_associated_function (|
                              Ty.apply
                                (Ty.path "core::ptr::non_null::NonNull")
                                []
                                [
                                  Ty.apply
                                    (Ty.path "alloc::collections::linked_list::Node")
                                    []
                                    [ T ]
                                ],
                              "as_mut",
                              [],
                              []
                            |),
                            [ M.borrow (| Pointer.Kind.MutRef, splice_end |) ]
                          |)
                        |),
                        "alloc::collections::linked_list::Node",
                        "next"
                      |),
                      M.read (| existing_next |)
                    |)
                  |) in
                M.alloc (| Value.Tuple [] |) in
              let~ _ : Ty.tuple [] :=
                M.alloc (|
                  let β :=
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| self |) |),
                      "alloc::collections::linked_list::LinkedList",
                      "len"
                    |) in
                  M.write (|
                    β,
                    M.call_closure (|
                      Ty.path "usize",
                      BinOp.Wrap.add,
                      [ M.read (| β |); M.read (| splice_length |) ]
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_splice_nodes :
        forall (T A : Ty.t),
        M.IsAssociatedFunction.C (Self T A) "splice_nodes" (splice_nodes T A).
      Admitted.
      Global Typeclasses Opaque splice_nodes.
      
      (*
          fn detach_all_nodes(mut self) -> Option<(NonNull<Node<T>>, NonNull<Node<T>>, usize)> {
              let head = self.head.take();
              let tail = self.tail.take();
              let len = mem::replace(&mut self.len, 0);
              if let Some(head) = head {
                  // SAFETY: In a LinkedList, either both the head and tail are None because
                  // the list is empty, or both head and tail are Some because the list is populated.
                  // Since we have verified the head is Some, we are sure the tail is Some too.
                  let tail = unsafe { tail.unwrap_unchecked() };
                  Some((head, tail, len))
              } else {
                  None
              }
          }
      *)
      Definition detach_all_nodes
          (T A : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self T A in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              let~ head :
                  Ty.apply
                    (Ty.path "core::option::Option")
                    []
                    [
                      Ty.apply
                        (Ty.path "core::ptr::non_null::NonNull")
                        []
                        [ Ty.apply (Ty.path "alloc::collections::linked_list::Node") [] [ T ] ]
                    ] :=
                M.alloc (|
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "core::option::Option")
                      []
                      [
                        Ty.apply
                          (Ty.path "core::ptr::non_null::NonNull")
                          []
                          [ Ty.apply (Ty.path "alloc::collections::linked_list::Node") [] [ T ] ]
                      ],
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "core::option::Option")
                        []
                        [
                          Ty.apply
                            (Ty.path "core::ptr::non_null::NonNull")
                            []
                            [ Ty.apply (Ty.path "alloc::collections::linked_list::Node") [] [ T ] ]
                        ],
                      "take",
                      [],
                      []
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.MutRef,
                        M.SubPointer.get_struct_record_field (|
                          self,
                          "alloc::collections::linked_list::LinkedList",
                          "head"
                        |)
                      |)
                    ]
                  |)
                |) in
              let~ tail :
                  Ty.apply
                    (Ty.path "core::option::Option")
                    []
                    [
                      Ty.apply
                        (Ty.path "core::ptr::non_null::NonNull")
                        []
                        [ Ty.apply (Ty.path "alloc::collections::linked_list::Node") [] [ T ] ]
                    ] :=
                M.alloc (|
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "core::option::Option")
                      []
                      [
                        Ty.apply
                          (Ty.path "core::ptr::non_null::NonNull")
                          []
                          [ Ty.apply (Ty.path "alloc::collections::linked_list::Node") [] [ T ] ]
                      ],
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "core::option::Option")
                        []
                        [
                          Ty.apply
                            (Ty.path "core::ptr::non_null::NonNull")
                            []
                            [ Ty.apply (Ty.path "alloc::collections::linked_list::Node") [] [ T ] ]
                        ],
                      "take",
                      [],
                      []
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.MutRef,
                        M.SubPointer.get_struct_record_field (|
                          self,
                          "alloc::collections::linked_list::LinkedList",
                          "tail"
                        |)
                      |)
                    ]
                  |)
                |) in
              let~ len : Ty.path "usize" :=
                M.alloc (|
                  M.call_closure (|
                    Ty.path "usize",
                    M.get_function (| "core::mem::replace", [], [ Ty.path "usize" ] |),
                    [
                      M.borrow (|
                        Pointer.Kind.MutRef,
                        M.deref (|
                          M.borrow (|
                            Pointer.Kind.MutRef,
                            M.SubPointer.get_struct_record_field (|
                              self,
                              "alloc::collections::linked_list::LinkedList",
                              "len"
                            |)
                          |)
                        |)
                      |);
                      Value.Integer IntegerKind.Usize 0
                    ]
                  |)
                |) in
              M.match_operator (|
                Some
                  (Ty.apply
                    (Ty.path "core::option::Option")
                    []
                    [
                      Ty.tuple
                        [
                          Ty.apply
                            (Ty.path "core::ptr::non_null::NonNull")
                            []
                            [ Ty.apply (Ty.path "alloc::collections::linked_list::Node") [] [ T ] ];
                          Ty.apply
                            (Ty.path "core::ptr::non_null::NonNull")
                            []
                            [ Ty.apply (Ty.path "alloc::collections::linked_list::Node") [] [ T ] ];
                          Ty.path "usize"
                        ]
                    ]),
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := head in
                      let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::option::Option::Some",
                          0
                        |) in
                      let head := M.copy (| γ0_0 |) in
                      let~ tail :
                          Ty.apply
                            (Ty.path "core::ptr::non_null::NonNull")
                            []
                            [ Ty.apply (Ty.path "alloc::collections::linked_list::Node") [] [ T ]
                            ] :=
                        M.alloc (|
                          M.call_closure (|
                            Ty.apply
                              (Ty.path "core::ptr::non_null::NonNull")
                              []
                              [ Ty.apply (Ty.path "alloc::collections::linked_list::Node") [] [ T ]
                              ],
                            M.get_associated_function (|
                              Ty.apply
                                (Ty.path "core::option::Option")
                                []
                                [
                                  Ty.apply
                                    (Ty.path "core::ptr::non_null::NonNull")
                                    []
                                    [
                                      Ty.apply
                                        (Ty.path "alloc::collections::linked_list::Node")
                                        []
                                        [ T ]
                                    ]
                                ],
                              "unwrap_unchecked",
                              [],
                              []
                            |),
                            [ M.read (| tail |) ]
                          |)
                        |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::option::Option::Some"
                          [ Value.Tuple [ M.read (| head |); M.read (| tail |); M.read (| len |) ] ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_detach_all_nodes :
        forall (T A : Ty.t),
        M.IsAssociatedFunction.C (Self T A) "detach_all_nodes" (detach_all_nodes T A).
      Admitted.
      Global Typeclasses Opaque detach_all_nodes.
      
      (*
          unsafe fn split_off_before_node(
              &mut self,
              split_node: Option<NonNull<Node<T>>>,
              at: usize,
          ) -> Self
          where
              A: Clone,
          {
              // The split node is the new head node of the second part
              if let Some(mut split_node) = split_node {
                  let first_part_head;
                  let first_part_tail;
                  unsafe {
                      first_part_tail = split_node.as_mut().prev.take();
                  }
                  if let Some(mut tail) = first_part_tail {
                      unsafe {
                          tail.as_mut().next = None;
                      }
                      first_part_head = self.head;
                  } else {
                      first_part_head = None;
                  }
      
                  let first_part = LinkedList {
                      head: first_part_head,
                      tail: first_part_tail,
                      len: at,
                      alloc: self.alloc.clone(),
                      marker: PhantomData,
                  };
      
                  // Fix the head ptr of the second part
                  self.head = Some(split_node);
                  self.len = self.len - at;
      
                  first_part
              } else {
                  mem::replace(self, LinkedList::new_in(self.alloc.clone()))
              }
          }
      *)
      Definition split_off_before_node
          (T A : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self T A in
        match ε, τ, α with
        | [], [], [ self; split_node; at_ ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let split_node := M.alloc (| split_node |) in
            let at_ := M.alloc (| at_ |) in
            M.read (|
              M.match_operator (|
                Some (Ty.apply (Ty.path "alloc::collections::linked_list::LinkedList") [] [ T; A ]),
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := split_node in
                      let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::option::Option::Some",
                          0
                        |) in
                      let split_node := M.copy (| γ0_0 |) in
                      let first_part_head := M.copy (| Value.DeclaredButUndefined |) in
                      let first_part_tail := M.copy (| Value.DeclaredButUndefined |) in
                      let~ _ : Ty.tuple [] :=
                        let~ _ : Ty.tuple [] :=
                          M.alloc (|
                            M.write (|
                              first_part_tail,
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "core::option::Option")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "core::ptr::non_null::NonNull")
                                      []
                                      [
                                        Ty.apply
                                          (Ty.path "alloc::collections::linked_list::Node")
                                          []
                                          [ T ]
                                      ]
                                  ],
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "core::option::Option")
                                    []
                                    [
                                      Ty.apply
                                        (Ty.path "core::ptr::non_null::NonNull")
                                        []
                                        [
                                          Ty.apply
                                            (Ty.path "alloc::collections::linked_list::Node")
                                            []
                                            [ T ]
                                        ]
                                    ],
                                  "take",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (|
                                    Pointer.Kind.MutRef,
                                    M.SubPointer.get_struct_record_field (|
                                      M.deref (|
                                        M.call_closure (|
                                          Ty.apply
                                            (Ty.path "&mut")
                                            []
                                            [
                                              Ty.apply
                                                (Ty.path "alloc::collections::linked_list::Node")
                                                []
                                                [ T ]
                                            ],
                                          M.get_associated_function (|
                                            Ty.apply
                                              (Ty.path "core::ptr::non_null::NonNull")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "alloc::collections::linked_list::Node")
                                                  []
                                                  [ T ]
                                              ],
                                            "as_mut",
                                            [],
                                            []
                                          |),
                                          [ M.borrow (| Pointer.Kind.MutRef, split_node |) ]
                                        |)
                                      |),
                                      "alloc::collections::linked_list::Node",
                                      "prev"
                                    |)
                                  |)
                                ]
                              |)
                            |)
                          |) in
                        M.alloc (| Value.Tuple [] |) in
                      let~ _ : Ty.tuple [] :=
                        M.match_operator (|
                          Some (Ty.tuple []),
                          M.alloc (| Value.Tuple [] |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ := first_part_tail in
                                let γ0_0 :=
                                  M.SubPointer.get_struct_tuple_field (|
                                    γ,
                                    "core::option::Option::Some",
                                    0
                                  |) in
                                let tail := M.copy (| γ0_0 |) in
                                let~ _ : Ty.tuple [] :=
                                  let~ _ : Ty.tuple [] :=
                                    M.alloc (|
                                      M.write (|
                                        M.SubPointer.get_struct_record_field (|
                                          M.deref (|
                                            M.call_closure (|
                                              Ty.apply
                                                (Ty.path "&mut")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path
                                                      "alloc::collections::linked_list::Node")
                                                    []
                                                    [ T ]
                                                ],
                                              M.get_associated_function (|
                                                Ty.apply
                                                  (Ty.path "core::ptr::non_null::NonNull")
                                                  []
                                                  [
                                                    Ty.apply
                                                      (Ty.path
                                                        "alloc::collections::linked_list::Node")
                                                      []
                                                      [ T ]
                                                  ],
                                                "as_mut",
                                                [],
                                                []
                                              |),
                                              [ M.borrow (| Pointer.Kind.MutRef, tail |) ]
                                            |)
                                          |),
                                          "alloc::collections::linked_list::Node",
                                          "next"
                                        |),
                                        Value.StructTuple "core::option::Option::None" []
                                      |)
                                    |) in
                                  M.alloc (| Value.Tuple [] |) in
                                let~ _ : Ty.tuple [] :=
                                  M.alloc (|
                                    M.write (|
                                      first_part_head,
                                      M.read (|
                                        M.SubPointer.get_struct_record_field (|
                                          M.deref (| M.read (| self |) |),
                                          "alloc::collections::linked_list::LinkedList",
                                          "head"
                                        |)
                                      |)
                                    |)
                                  |) in
                                M.alloc (| Value.Tuple [] |)));
                            fun γ =>
                              ltac:(M.monadic
                                (let~ _ : Ty.tuple [] :=
                                  M.alloc (|
                                    M.write (|
                                      first_part_head,
                                      Value.StructTuple "core::option::Option::None" []
                                    |)
                                  |) in
                                M.alloc (| Value.Tuple [] |)))
                          ]
                        |) in
                      let~ first_part :
                          Ty.apply
                            (Ty.path "alloc::collections::linked_list::LinkedList")
                            []
                            [ T; A ] :=
                        M.alloc (|
                          Value.StructRecord
                            "alloc::collections::linked_list::LinkedList"
                            [
                              ("head", M.read (| first_part_head |));
                              ("tail", M.read (| first_part_tail |));
                              ("len", M.read (| at_ |));
                              ("alloc",
                                M.call_closure (|
                                  A,
                                  M.get_trait_method (|
                                    "core::clone::Clone",
                                    A,
                                    [],
                                    [],
                                    "clone",
                                    [],
                                    []
                                  |),
                                  [
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.SubPointer.get_struct_record_field (|
                                        M.deref (| M.read (| self |) |),
                                        "alloc::collections::linked_list::LinkedList",
                                        "alloc"
                                      |)
                                    |)
                                  ]
                                |));
                              ("marker", Value.StructTuple "core::marker::PhantomData" [])
                            ]
                        |) in
                      let~ _ : Ty.tuple [] :=
                        M.alloc (|
                          M.write (|
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| self |) |),
                              "alloc::collections::linked_list::LinkedList",
                              "head"
                            |),
                            Value.StructTuple
                              "core::option::Option::Some"
                              [ M.read (| split_node |) ]
                          |)
                        |) in
                      let~ _ : Ty.tuple [] :=
                        M.alloc (|
                          M.write (|
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| self |) |),
                              "alloc::collections::linked_list::LinkedList",
                              "len"
                            |),
                            M.call_closure (|
                              Ty.path "usize",
                              BinOp.Wrap.sub,
                              [
                                M.read (|
                                  M.SubPointer.get_struct_record_field (|
                                    M.deref (| M.read (| self |) |),
                                    "alloc::collections::linked_list::LinkedList",
                                    "len"
                                  |)
                                |);
                                M.read (| at_ |)
                              ]
                            |)
                          |)
                        |) in
                      first_part));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (|
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "alloc::collections::linked_list::LinkedList")
                            []
                            [ T; A ],
                          M.get_function (|
                            "core::mem::replace",
                            [],
                            [
                              Ty.apply
                                (Ty.path "alloc::collections::linked_list::LinkedList")
                                []
                                [ T; A ]
                            ]
                          |),
                          [
                            M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |);
                            M.call_closure (|
                              Ty.apply
                                (Ty.path "alloc::collections::linked_list::LinkedList")
                                []
                                [ T; A ],
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "alloc::collections::linked_list::LinkedList")
                                  []
                                  [ T; A ],
                                "new_in",
                                [],
                                []
                              |),
                              [
                                M.call_closure (|
                                  A,
                                  M.get_trait_method (|
                                    "core::clone::Clone",
                                    A,
                                    [],
                                    [],
                                    "clone",
                                    [],
                                    []
                                  |),
                                  [
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.SubPointer.get_struct_record_field (|
                                        M.deref (| M.read (| self |) |),
                                        "alloc::collections::linked_list::LinkedList",
                                        "alloc"
                                      |)
                                    |)
                                  ]
                                |)
                              ]
                            |)
                          ]
                        |)
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_split_off_before_node :
        forall (T A : Ty.t),
        M.IsAssociatedFunction.C (Self T A) "split_off_before_node" (split_off_before_node T A).
      Admitted.
      Global Typeclasses Opaque split_off_before_node.
      
      (*
          unsafe fn split_off_after_node(
              &mut self,
              split_node: Option<NonNull<Node<T>>>,
              at: usize,
          ) -> Self
          where
              A: Clone,
          {
              // The split node is the new tail node of the first part and owns
              // the head of the second part.
              if let Some(mut split_node) = split_node {
                  let second_part_head;
                  let second_part_tail;
                  unsafe {
                      second_part_head = split_node.as_mut().next.take();
                  }
                  if let Some(mut head) = second_part_head {
                      unsafe {
                          head.as_mut().prev = None;
                      }
                      second_part_tail = self.tail;
                  } else {
                      second_part_tail = None;
                  }
      
                  let second_part = LinkedList {
                      head: second_part_head,
                      tail: second_part_tail,
                      len: self.len - at,
                      alloc: self.alloc.clone(),
                      marker: PhantomData,
                  };
      
                  // Fix the tail ptr of the first part
                  self.tail = Some(split_node);
                  self.len = at;
      
                  second_part
              } else {
                  mem::replace(self, LinkedList::new_in(self.alloc.clone()))
              }
          }
      *)
      Definition split_off_after_node
          (T A : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self T A in
        match ε, τ, α with
        | [], [], [ self; split_node; at_ ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let split_node := M.alloc (| split_node |) in
            let at_ := M.alloc (| at_ |) in
            M.read (|
              M.match_operator (|
                Some (Ty.apply (Ty.path "alloc::collections::linked_list::LinkedList") [] [ T; A ]),
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := split_node in
                      let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::option::Option::Some",
                          0
                        |) in
                      let split_node := M.copy (| γ0_0 |) in
                      let second_part_head := M.copy (| Value.DeclaredButUndefined |) in
                      let second_part_tail := M.copy (| Value.DeclaredButUndefined |) in
                      let~ _ : Ty.tuple [] :=
                        let~ _ : Ty.tuple [] :=
                          M.alloc (|
                            M.write (|
                              second_part_head,
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "core::option::Option")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "core::ptr::non_null::NonNull")
                                      []
                                      [
                                        Ty.apply
                                          (Ty.path "alloc::collections::linked_list::Node")
                                          []
                                          [ T ]
                                      ]
                                  ],
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "core::option::Option")
                                    []
                                    [
                                      Ty.apply
                                        (Ty.path "core::ptr::non_null::NonNull")
                                        []
                                        [
                                          Ty.apply
                                            (Ty.path "alloc::collections::linked_list::Node")
                                            []
                                            [ T ]
                                        ]
                                    ],
                                  "take",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (|
                                    Pointer.Kind.MutRef,
                                    M.SubPointer.get_struct_record_field (|
                                      M.deref (|
                                        M.call_closure (|
                                          Ty.apply
                                            (Ty.path "&mut")
                                            []
                                            [
                                              Ty.apply
                                                (Ty.path "alloc::collections::linked_list::Node")
                                                []
                                                [ T ]
                                            ],
                                          M.get_associated_function (|
                                            Ty.apply
                                              (Ty.path "core::ptr::non_null::NonNull")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "alloc::collections::linked_list::Node")
                                                  []
                                                  [ T ]
                                              ],
                                            "as_mut",
                                            [],
                                            []
                                          |),
                                          [ M.borrow (| Pointer.Kind.MutRef, split_node |) ]
                                        |)
                                      |),
                                      "alloc::collections::linked_list::Node",
                                      "next"
                                    |)
                                  |)
                                ]
                              |)
                            |)
                          |) in
                        M.alloc (| Value.Tuple [] |) in
                      let~ _ : Ty.tuple [] :=
                        M.match_operator (|
                          Some (Ty.tuple []),
                          M.alloc (| Value.Tuple [] |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ := second_part_head in
                                let γ0_0 :=
                                  M.SubPointer.get_struct_tuple_field (|
                                    γ,
                                    "core::option::Option::Some",
                                    0
                                  |) in
                                let head := M.copy (| γ0_0 |) in
                                let~ _ : Ty.tuple [] :=
                                  let~ _ : Ty.tuple [] :=
                                    M.alloc (|
                                      M.write (|
                                        M.SubPointer.get_struct_record_field (|
                                          M.deref (|
                                            M.call_closure (|
                                              Ty.apply
                                                (Ty.path "&mut")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path
                                                      "alloc::collections::linked_list::Node")
                                                    []
                                                    [ T ]
                                                ],
                                              M.get_associated_function (|
                                                Ty.apply
                                                  (Ty.path "core::ptr::non_null::NonNull")
                                                  []
                                                  [
                                                    Ty.apply
                                                      (Ty.path
                                                        "alloc::collections::linked_list::Node")
                                                      []
                                                      [ T ]
                                                  ],
                                                "as_mut",
                                                [],
                                                []
                                              |),
                                              [ M.borrow (| Pointer.Kind.MutRef, head |) ]
                                            |)
                                          |),
                                          "alloc::collections::linked_list::Node",
                                          "prev"
                                        |),
                                        Value.StructTuple "core::option::Option::None" []
                                      |)
                                    |) in
                                  M.alloc (| Value.Tuple [] |) in
                                let~ _ : Ty.tuple [] :=
                                  M.alloc (|
                                    M.write (|
                                      second_part_tail,
                                      M.read (|
                                        M.SubPointer.get_struct_record_field (|
                                          M.deref (| M.read (| self |) |),
                                          "alloc::collections::linked_list::LinkedList",
                                          "tail"
                                        |)
                                      |)
                                    |)
                                  |) in
                                M.alloc (| Value.Tuple [] |)));
                            fun γ =>
                              ltac:(M.monadic
                                (let~ _ : Ty.tuple [] :=
                                  M.alloc (|
                                    M.write (|
                                      second_part_tail,
                                      Value.StructTuple "core::option::Option::None" []
                                    |)
                                  |) in
                                M.alloc (| Value.Tuple [] |)))
                          ]
                        |) in
                      let~ second_part :
                          Ty.apply
                            (Ty.path "alloc::collections::linked_list::LinkedList")
                            []
                            [ T; A ] :=
                        M.alloc (|
                          Value.StructRecord
                            "alloc::collections::linked_list::LinkedList"
                            [
                              ("head", M.read (| second_part_head |));
                              ("tail", M.read (| second_part_tail |));
                              ("len",
                                M.call_closure (|
                                  Ty.path "usize",
                                  BinOp.Wrap.sub,
                                  [
                                    M.read (|
                                      M.SubPointer.get_struct_record_field (|
                                        M.deref (| M.read (| self |) |),
                                        "alloc::collections::linked_list::LinkedList",
                                        "len"
                                      |)
                                    |);
                                    M.read (| at_ |)
                                  ]
                                |));
                              ("alloc",
                                M.call_closure (|
                                  A,
                                  M.get_trait_method (|
                                    "core::clone::Clone",
                                    A,
                                    [],
                                    [],
                                    "clone",
                                    [],
                                    []
                                  |),
                                  [
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.SubPointer.get_struct_record_field (|
                                        M.deref (| M.read (| self |) |),
                                        "alloc::collections::linked_list::LinkedList",
                                        "alloc"
                                      |)
                                    |)
                                  ]
                                |));
                              ("marker", Value.StructTuple "core::marker::PhantomData" [])
                            ]
                        |) in
                      let~ _ : Ty.tuple [] :=
                        M.alloc (|
                          M.write (|
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| self |) |),
                              "alloc::collections::linked_list::LinkedList",
                              "tail"
                            |),
                            Value.StructTuple
                              "core::option::Option::Some"
                              [ M.read (| split_node |) ]
                          |)
                        |) in
                      let~ _ : Ty.tuple [] :=
                        M.alloc (|
                          M.write (|
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| self |) |),
                              "alloc::collections::linked_list::LinkedList",
                              "len"
                            |),
                            M.read (| at_ |)
                          |)
                        |) in
                      second_part));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (|
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "alloc::collections::linked_list::LinkedList")
                            []
                            [ T; A ],
                          M.get_function (|
                            "core::mem::replace",
                            [],
                            [
                              Ty.apply
                                (Ty.path "alloc::collections::linked_list::LinkedList")
                                []
                                [ T; A ]
                            ]
                          |),
                          [
                            M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |);
                            M.call_closure (|
                              Ty.apply
                                (Ty.path "alloc::collections::linked_list::LinkedList")
                                []
                                [ T; A ],
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "alloc::collections::linked_list::LinkedList")
                                  []
                                  [ T; A ],
                                "new_in",
                                [],
                                []
                              |),
                              [
                                M.call_closure (|
                                  A,
                                  M.get_trait_method (|
                                    "core::clone::Clone",
                                    A,
                                    [],
                                    [],
                                    "clone",
                                    [],
                                    []
                                  |),
                                  [
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.SubPointer.get_struct_record_field (|
                                        M.deref (| M.read (| self |) |),
                                        "alloc::collections::linked_list::LinkedList",
                                        "alloc"
                                      |)
                                    |)
                                  ]
                                |)
                              ]
                            |)
                          ]
                        |)
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_split_off_after_node :
        forall (T A : Ty.t),
        M.IsAssociatedFunction.C (Self T A) "split_off_after_node" (split_off_after_node T A).
      Admitted.
      Global Typeclasses Opaque split_off_after_node.
      (*
          pub const fn new_in(alloc: A) -> Self {
              LinkedList { head: None, tail: None, len: 0, alloc, marker: PhantomData }
          }
      *)
      Definition new_in (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match ε, τ, α with
        | [], [], [ alloc ] =>
          ltac:(M.monadic
            (let alloc := M.alloc (| alloc |) in
            Value.StructRecord
              "alloc::collections::linked_list::LinkedList"
              [
                ("head", Value.StructTuple "core::option::Option::None" []);
                ("tail", Value.StructTuple "core::option::Option::None" []);
                ("len", Value.Integer IntegerKind.Usize 0);
                ("alloc", M.read (| alloc |));
                ("marker", Value.StructTuple "core::marker::PhantomData" [])
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_new_in :
        forall (T A : Ty.t),
        M.IsAssociatedFunction.C (Self T A) "new_in" (new_in T A).
      Admitted.
      Global Typeclasses Opaque new_in.
      
      (*
          pub fn iter(&self) -> Iter<'_, T> {
              Iter { head: self.head, tail: self.tail, len: self.len, marker: PhantomData }
          }
      *)
      Definition iter (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructRecord
              "alloc::collections::linked_list::Iter"
              [
                ("head",
                  M.read (|
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| self |) |),
                      "alloc::collections::linked_list::LinkedList",
                      "head"
                    |)
                  |));
                ("tail",
                  M.read (|
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| self |) |),
                      "alloc::collections::linked_list::LinkedList",
                      "tail"
                    |)
                  |));
                ("len",
                  M.read (|
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| self |) |),
                      "alloc::collections::linked_list::LinkedList",
                      "len"
                    |)
                  |));
                ("marker", Value.StructTuple "core::marker::PhantomData" [])
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_iter :
        forall (T A : Ty.t),
        M.IsAssociatedFunction.C (Self T A) "iter" (iter T A).
      Admitted.
      Global Typeclasses Opaque iter.
      
      (*
          pub fn iter_mut(&mut self) -> IterMut<'_, T> {
              IterMut { head: self.head, tail: self.tail, len: self.len, marker: PhantomData }
          }
      *)
      Definition iter_mut (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructRecord
              "alloc::collections::linked_list::IterMut"
              [
                ("head",
                  M.read (|
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| self |) |),
                      "alloc::collections::linked_list::LinkedList",
                      "head"
                    |)
                  |));
                ("tail",
                  M.read (|
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| self |) |),
                      "alloc::collections::linked_list::LinkedList",
                      "tail"
                    |)
                  |));
                ("len",
                  M.read (|
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| self |) |),
                      "alloc::collections::linked_list::LinkedList",
                      "len"
                    |)
                  |));
                ("marker", Value.StructTuple "core::marker::PhantomData" [])
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_iter_mut :
        forall (T A : Ty.t),
        M.IsAssociatedFunction.C (Self T A) "iter_mut" (iter_mut T A).
      Admitted.
      Global Typeclasses Opaque iter_mut.
      
      (*
          pub fn cursor_front(&self) -> Cursor<'_, T, A> {
              Cursor { index: 0, current: self.head, list: self }
          }
      *)
      Definition cursor_front
          (T A : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self T A in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructRecord
              "alloc::collections::linked_list::Cursor"
              [
                ("index", Value.Integer IntegerKind.Usize 0);
                ("current",
                  M.read (|
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| self |) |),
                      "alloc::collections::linked_list::LinkedList",
                      "head"
                    |)
                  |));
                ("list", M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |))
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_cursor_front :
        forall (T A : Ty.t),
        M.IsAssociatedFunction.C (Self T A) "cursor_front" (cursor_front T A).
      Admitted.
      Global Typeclasses Opaque cursor_front.
      
      (*
          pub fn cursor_front_mut(&mut self) -> CursorMut<'_, T, A> {
              CursorMut { index: 0, current: self.head, list: self }
          }
      *)
      Definition cursor_front_mut
          (T A : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self T A in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructRecord
              "alloc::collections::linked_list::CursorMut"
              [
                ("index", Value.Integer IntegerKind.Usize 0);
                ("current",
                  M.read (|
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| self |) |),
                      "alloc::collections::linked_list::LinkedList",
                      "head"
                    |)
                  |));
                ("list", M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |))
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_cursor_front_mut :
        forall (T A : Ty.t),
        M.IsAssociatedFunction.C (Self T A) "cursor_front_mut" (cursor_front_mut T A).
      Admitted.
      Global Typeclasses Opaque cursor_front_mut.
      
      (*
          pub fn cursor_back(&self) -> Cursor<'_, T, A> {
              Cursor { index: self.len.checked_sub(1).unwrap_or(0), current: self.tail, list: self }
          }
      *)
      Definition cursor_back
          (T A : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self T A in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructRecord
              "alloc::collections::linked_list::Cursor"
              [
                ("index",
                  M.call_closure (|
                    Ty.path "usize",
                    M.get_associated_function (|
                      Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "usize" ],
                      "unwrap_or",
                      [],
                      []
                    |),
                    [
                      M.call_closure (|
                        Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "usize" ],
                        M.get_associated_function (| Ty.path "usize", "checked_sub", [], [] |),
                        [
                          M.read (|
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| self |) |),
                              "alloc::collections::linked_list::LinkedList",
                              "len"
                            |)
                          |);
                          Value.Integer IntegerKind.Usize 1
                        ]
                      |);
                      Value.Integer IntegerKind.Usize 0
                    ]
                  |));
                ("current",
                  M.read (|
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| self |) |),
                      "alloc::collections::linked_list::LinkedList",
                      "tail"
                    |)
                  |));
                ("list", M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |))
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_cursor_back :
        forall (T A : Ty.t),
        M.IsAssociatedFunction.C (Self T A) "cursor_back" (cursor_back T A).
      Admitted.
      Global Typeclasses Opaque cursor_back.
      
      (*
          pub fn cursor_back_mut(&mut self) -> CursorMut<'_, T, A> {
              CursorMut { index: self.len.checked_sub(1).unwrap_or(0), current: self.tail, list: self }
          }
      *)
      Definition cursor_back_mut
          (T A : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self T A in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructRecord
              "alloc::collections::linked_list::CursorMut"
              [
                ("index",
                  M.call_closure (|
                    Ty.path "usize",
                    M.get_associated_function (|
                      Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "usize" ],
                      "unwrap_or",
                      [],
                      []
                    |),
                    [
                      M.call_closure (|
                        Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "usize" ],
                        M.get_associated_function (| Ty.path "usize", "checked_sub", [], [] |),
                        [
                          M.read (|
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| self |) |),
                              "alloc::collections::linked_list::LinkedList",
                              "len"
                            |)
                          |);
                          Value.Integer IntegerKind.Usize 1
                        ]
                      |);
                      Value.Integer IntegerKind.Usize 0
                    ]
                  |));
                ("current",
                  M.read (|
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| self |) |),
                      "alloc::collections::linked_list::LinkedList",
                      "tail"
                    |)
                  |));
                ("list", M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |))
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_cursor_back_mut :
        forall (T A : Ty.t),
        M.IsAssociatedFunction.C (Self T A) "cursor_back_mut" (cursor_back_mut T A).
      Admitted.
      Global Typeclasses Opaque cursor_back_mut.
      
      (*
          pub fn is_empty(&self) -> bool {
              self.head.is_none()
          }
      *)
      Definition is_empty (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "bool",
              M.get_associated_function (|
                Ty.apply
                  (Ty.path "core::option::Option")
                  []
                  [
                    Ty.apply
                      (Ty.path "core::ptr::non_null::NonNull")
                      []
                      [ Ty.apply (Ty.path "alloc::collections::linked_list::Node") [] [ T ] ]
                  ],
                "is_none",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.SubPointer.get_struct_record_field (|
                    M.deref (| M.read (| self |) |),
                    "alloc::collections::linked_list::LinkedList",
                    "head"
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_is_empty :
        forall (T A : Ty.t),
        M.IsAssociatedFunction.C (Self T A) "is_empty" (is_empty T A).
      Admitted.
      Global Typeclasses Opaque is_empty.
      
      (*
          pub fn len(&self) -> usize {
              self.len
          }
      *)
      Definition len (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.SubPointer.get_struct_record_field (|
                M.deref (| M.read (| self |) |),
                "alloc::collections::linked_list::LinkedList",
                "len"
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_len :
        forall (T A : Ty.t),
        M.IsAssociatedFunction.C (Self T A) "len" (len T A).
      Admitted.
      Global Typeclasses Opaque len.
      
      (*
          pub fn clear(&mut self) {
              // We need to drop the nodes while keeping self.alloc
              // We can do this by moving (head, tail, len) into a new list that borrows self.alloc
              drop(LinkedList {
                  head: self.head.take(),
                  tail: self.tail.take(),
                  len: mem::take(&mut self.len),
                  alloc: &self.alloc,
                  marker: PhantomData,
              });
          }
      *)
      Definition clear (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              let~ _ : Ty.tuple [] :=
                M.alloc (|
                  M.call_closure (|
                    Ty.tuple [],
                    M.get_function (|
                      "core::mem::drop",
                      [],
                      [
                        Ty.apply
                          (Ty.path "alloc::collections::linked_list::LinkedList")
                          []
                          [ T; Ty.apply (Ty.path "&") [] [ A ] ]
                      ]
                    |),
                    [
                      Value.StructRecord
                        "alloc::collections::linked_list::LinkedList"
                        [
                          ("head",
                            M.call_closure (|
                              Ty.apply
                                (Ty.path "core::option::Option")
                                []
                                [
                                  Ty.apply
                                    (Ty.path "core::ptr::non_null::NonNull")
                                    []
                                    [
                                      Ty.apply
                                        (Ty.path "alloc::collections::linked_list::Node")
                                        []
                                        [ T ]
                                    ]
                                ],
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "core::option::Option")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "core::ptr::non_null::NonNull")
                                      []
                                      [
                                        Ty.apply
                                          (Ty.path "alloc::collections::linked_list::Node")
                                          []
                                          [ T ]
                                      ]
                                  ],
                                "take",
                                [],
                                []
                              |),
                              [
                                M.borrow (|
                                  Pointer.Kind.MutRef,
                                  M.SubPointer.get_struct_record_field (|
                                    M.deref (| M.read (| self |) |),
                                    "alloc::collections::linked_list::LinkedList",
                                    "head"
                                  |)
                                |)
                              ]
                            |));
                          ("tail",
                            M.call_closure (|
                              Ty.apply
                                (Ty.path "core::option::Option")
                                []
                                [
                                  Ty.apply
                                    (Ty.path "core::ptr::non_null::NonNull")
                                    []
                                    [
                                      Ty.apply
                                        (Ty.path "alloc::collections::linked_list::Node")
                                        []
                                        [ T ]
                                    ]
                                ],
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "core::option::Option")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "core::ptr::non_null::NonNull")
                                      []
                                      [
                                        Ty.apply
                                          (Ty.path "alloc::collections::linked_list::Node")
                                          []
                                          [ T ]
                                      ]
                                  ],
                                "take",
                                [],
                                []
                              |),
                              [
                                M.borrow (|
                                  Pointer.Kind.MutRef,
                                  M.SubPointer.get_struct_record_field (|
                                    M.deref (| M.read (| self |) |),
                                    "alloc::collections::linked_list::LinkedList",
                                    "tail"
                                  |)
                                |)
                              ]
                            |));
                          ("len",
                            M.call_closure (|
                              Ty.path "usize",
                              M.get_function (| "core::mem::take", [], [ Ty.path "usize" ] |),
                              [
                                M.borrow (|
                                  Pointer.Kind.MutRef,
                                  M.deref (|
                                    M.borrow (|
                                      Pointer.Kind.MutRef,
                                      M.SubPointer.get_struct_record_field (|
                                        M.deref (| M.read (| self |) |),
                                        "alloc::collections::linked_list::LinkedList",
                                        "len"
                                      |)
                                    |)
                                  |)
                                |)
                              ]
                            |));
                          ("alloc",
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.SubPointer.get_struct_record_field (|
                                M.deref (| M.read (| self |) |),
                                "alloc::collections::linked_list::LinkedList",
                                "alloc"
                              |)
                            |));
                          ("marker", Value.StructTuple "core::marker::PhantomData" [])
                        ]
                    ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_clear :
        forall (T A : Ty.t),
        M.IsAssociatedFunction.C (Self T A) "clear" (clear T A).
      Admitted.
      Global Typeclasses Opaque clear.
      
      (*
          pub fn contains(&self, x: &T) -> bool
          where
              T: PartialEq<T>,
          {
              self.iter().any(|e| e == x)
          }
      *)
      Definition contains (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match ε, τ, α with
        | [], [], [ self; x ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let x := M.alloc (| x |) in
            M.call_closure (|
              Ty.path "bool",
              M.get_trait_method (|
                "core::iter::traits::iterator::Iterator",
                Ty.apply (Ty.path "alloc::collections::linked_list::Iter") [] [ T ],
                [],
                [],
                "any",
                [],
                [ Ty.function [ Ty.tuple [ Ty.apply (Ty.path "&") [] [ T ] ] ] (Ty.path "bool") ]
              |),
              [
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.alloc (|
                    M.call_closure (|
                      Ty.apply (Ty.path "alloc::collections::linked_list::Iter") [] [ T ],
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "alloc::collections::linked_list::LinkedList")
                          []
                          [ T; A ],
                        "iter",
                        [],
                        []
                      |),
                      [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                    |)
                  |)
                |);
                M.closure
                  (fun γ =>
                    ltac:(M.monadic
                      match γ with
                      | [ α0 ] =>
                        ltac:(M.monadic
                          (M.match_operator (|
                            Some
                              (Ty.function
                                [ Ty.tuple [ Ty.apply (Ty.path "&") [] [ T ] ] ]
                                (Ty.path "bool")),
                            M.alloc (| α0 |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let e := M.copy (| γ |) in
                                  M.call_closure (|
                                    Ty.path "bool",
                                    M.get_trait_method (|
                                      "core::cmp::PartialEq",
                                      Ty.apply (Ty.path "&") [] [ T ],
                                      [],
                                      [ Ty.apply (Ty.path "&") [] [ T ] ],
                                      "eq",
                                      [],
                                      []
                                    |),
                                    [
                                      M.borrow (| Pointer.Kind.Ref, e |);
                                      M.borrow (| Pointer.Kind.Ref, x |)
                                    ]
                                  |)))
                            ]
                          |)))
                      | _ => M.impossible "wrong number of arguments"
                      end))
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_contains :
        forall (T A : Ty.t),
        M.IsAssociatedFunction.C (Self T A) "contains" (contains T A).
      Admitted.
      Global Typeclasses Opaque contains.
      
      (*
          pub fn front(&self) -> Option<&T> {
              unsafe { self.head.as_ref().map(|node| &node.as_ref().element) }
          }
      *)
      Definition front (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.apply (Ty.path "core::option::Option") [] [ Ty.apply (Ty.path "&") [] [ T ] ],
              M.get_associated_function (|
                Ty.apply
                  (Ty.path "core::option::Option")
                  []
                  [
                    Ty.apply
                      (Ty.path "&")
                      []
                      [
                        Ty.apply
                          (Ty.path "core::ptr::non_null::NonNull")
                          []
                          [ Ty.apply (Ty.path "alloc::collections::linked_list::Node") [] [ T ] ]
                      ]
                  ],
                "map",
                [],
                [
                  Ty.apply (Ty.path "&") [] [ T ];
                  Ty.function
                    [
                      Ty.tuple
                        [
                          Ty.apply
                            (Ty.path "&")
                            []
                            [
                              Ty.apply
                                (Ty.path "core::ptr::non_null::NonNull")
                                []
                                [
                                  Ty.apply
                                    (Ty.path "alloc::collections::linked_list::Node")
                                    []
                                    [ T ]
                                ]
                            ]
                        ]
                    ]
                    (Ty.apply (Ty.path "&") [] [ T ])
                ]
              |),
              [
                M.call_closure (|
                  Ty.apply
                    (Ty.path "core::option::Option")
                    []
                    [
                      Ty.apply
                        (Ty.path "&")
                        []
                        [
                          Ty.apply
                            (Ty.path "core::ptr::non_null::NonNull")
                            []
                            [ Ty.apply (Ty.path "alloc::collections::linked_list::Node") [] [ T ] ]
                        ]
                    ],
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "core::option::Option")
                      []
                      [
                        Ty.apply
                          (Ty.path "core::ptr::non_null::NonNull")
                          []
                          [ Ty.apply (Ty.path "alloc::collections::linked_list::Node") [] [ T ] ]
                      ],
                    "as_ref",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "alloc::collections::linked_list::LinkedList",
                        "head"
                      |)
                    |)
                  ]
                |);
                M.closure
                  (fun γ =>
                    ltac:(M.monadic
                      match γ with
                      | [ α0 ] =>
                        ltac:(M.monadic
                          (M.match_operator (|
                            Some
                              (Ty.function
                                [
                                  Ty.tuple
                                    [
                                      Ty.apply
                                        (Ty.path "&")
                                        []
                                        [
                                          Ty.apply
                                            (Ty.path "core::ptr::non_null::NonNull")
                                            []
                                            [
                                              Ty.apply
                                                (Ty.path "alloc::collections::linked_list::Node")
                                                []
                                                [ T ]
                                            ]
                                        ]
                                    ]
                                ]
                                (Ty.apply (Ty.path "&") [] [ T ])),
                            M.alloc (| α0 |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let node := M.copy (| γ |) in
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.SubPointer.get_struct_record_field (|
                                      M.deref (|
                                        M.call_closure (|
                                          Ty.apply
                                            (Ty.path "&")
                                            []
                                            [
                                              Ty.apply
                                                (Ty.path "alloc::collections::linked_list::Node")
                                                []
                                                [ T ]
                                            ],
                                          M.get_associated_function (|
                                            Ty.apply
                                              (Ty.path "core::ptr::non_null::NonNull")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "alloc::collections::linked_list::Node")
                                                  []
                                                  [ T ]
                                              ],
                                            "as_ref",
                                            [],
                                            []
                                          |),
                                          [
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.deref (| M.read (| node |) |)
                                            |)
                                          ]
                                        |)
                                      |),
                                      "alloc::collections::linked_list::Node",
                                      "element"
                                    |)
                                  |)))
                            ]
                          |)))
                      | _ => M.impossible "wrong number of arguments"
                      end))
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_front :
        forall (T A : Ty.t),
        M.IsAssociatedFunction.C (Self T A) "front" (front T A).
      Admitted.
      Global Typeclasses Opaque front.
      
      (*
          pub fn front_mut(&mut self) -> Option<&mut T> {
              unsafe { self.head.as_mut().map(|node| &mut node.as_mut().element) }
          }
      *)
      Definition front_mut (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.apply (Ty.path "core::option::Option") [] [ Ty.apply (Ty.path "&mut") [] [ T ] ],
              M.get_associated_function (|
                Ty.apply
                  (Ty.path "core::option::Option")
                  []
                  [
                    Ty.apply
                      (Ty.path "&mut")
                      []
                      [
                        Ty.apply
                          (Ty.path "core::ptr::non_null::NonNull")
                          []
                          [ Ty.apply (Ty.path "alloc::collections::linked_list::Node") [] [ T ] ]
                      ]
                  ],
                "map",
                [],
                [
                  Ty.apply (Ty.path "&mut") [] [ T ];
                  Ty.function
                    [
                      Ty.tuple
                        [
                          Ty.apply
                            (Ty.path "&mut")
                            []
                            [
                              Ty.apply
                                (Ty.path "core::ptr::non_null::NonNull")
                                []
                                [
                                  Ty.apply
                                    (Ty.path "alloc::collections::linked_list::Node")
                                    []
                                    [ T ]
                                ]
                            ]
                        ]
                    ]
                    (Ty.apply (Ty.path "&mut") [] [ T ])
                ]
              |),
              [
                M.call_closure (|
                  Ty.apply
                    (Ty.path "core::option::Option")
                    []
                    [
                      Ty.apply
                        (Ty.path "&mut")
                        []
                        [
                          Ty.apply
                            (Ty.path "core::ptr::non_null::NonNull")
                            []
                            [ Ty.apply (Ty.path "alloc::collections::linked_list::Node") [] [ T ] ]
                        ]
                    ],
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "core::option::Option")
                      []
                      [
                        Ty.apply
                          (Ty.path "core::ptr::non_null::NonNull")
                          []
                          [ Ty.apply (Ty.path "alloc::collections::linked_list::Node") [] [ T ] ]
                      ],
                    "as_mut",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.MutRef,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "alloc::collections::linked_list::LinkedList",
                        "head"
                      |)
                    |)
                  ]
                |);
                M.closure
                  (fun γ =>
                    ltac:(M.monadic
                      match γ with
                      | [ α0 ] =>
                        ltac:(M.monadic
                          (M.match_operator (|
                            Some
                              (Ty.function
                                [
                                  Ty.tuple
                                    [
                                      Ty.apply
                                        (Ty.path "&mut")
                                        []
                                        [
                                          Ty.apply
                                            (Ty.path "core::ptr::non_null::NonNull")
                                            []
                                            [
                                              Ty.apply
                                                (Ty.path "alloc::collections::linked_list::Node")
                                                []
                                                [ T ]
                                            ]
                                        ]
                                    ]
                                ]
                                (Ty.apply (Ty.path "&mut") [] [ T ])),
                            M.alloc (| α0 |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let node := M.copy (| γ |) in
                                  M.borrow (|
                                    Pointer.Kind.MutRef,
                                    M.SubPointer.get_struct_record_field (|
                                      M.deref (|
                                        M.call_closure (|
                                          Ty.apply
                                            (Ty.path "&mut")
                                            []
                                            [
                                              Ty.apply
                                                (Ty.path "alloc::collections::linked_list::Node")
                                                []
                                                [ T ]
                                            ],
                                          M.get_associated_function (|
                                            Ty.apply
                                              (Ty.path "core::ptr::non_null::NonNull")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "alloc::collections::linked_list::Node")
                                                  []
                                                  [ T ]
                                              ],
                                            "as_mut",
                                            [],
                                            []
                                          |),
                                          [
                                            M.borrow (|
                                              Pointer.Kind.MutRef,
                                              M.deref (| M.read (| node |) |)
                                            |)
                                          ]
                                        |)
                                      |),
                                      "alloc::collections::linked_list::Node",
                                      "element"
                                    |)
                                  |)))
                            ]
                          |)))
                      | _ => M.impossible "wrong number of arguments"
                      end))
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_front_mut :
        forall (T A : Ty.t),
        M.IsAssociatedFunction.C (Self T A) "front_mut" (front_mut T A).
      Admitted.
      Global Typeclasses Opaque front_mut.
      
      (*
          pub fn back(&self) -> Option<&T> {
              unsafe { self.tail.as_ref().map(|node| &node.as_ref().element) }
          }
      *)
      Definition back (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.apply (Ty.path "core::option::Option") [] [ Ty.apply (Ty.path "&") [] [ T ] ],
              M.get_associated_function (|
                Ty.apply
                  (Ty.path "core::option::Option")
                  []
                  [
                    Ty.apply
                      (Ty.path "&")
                      []
                      [
                        Ty.apply
                          (Ty.path "core::ptr::non_null::NonNull")
                          []
                          [ Ty.apply (Ty.path "alloc::collections::linked_list::Node") [] [ T ] ]
                      ]
                  ],
                "map",
                [],
                [
                  Ty.apply (Ty.path "&") [] [ T ];
                  Ty.function
                    [
                      Ty.tuple
                        [
                          Ty.apply
                            (Ty.path "&")
                            []
                            [
                              Ty.apply
                                (Ty.path "core::ptr::non_null::NonNull")
                                []
                                [
                                  Ty.apply
                                    (Ty.path "alloc::collections::linked_list::Node")
                                    []
                                    [ T ]
                                ]
                            ]
                        ]
                    ]
                    (Ty.apply (Ty.path "&") [] [ T ])
                ]
              |),
              [
                M.call_closure (|
                  Ty.apply
                    (Ty.path "core::option::Option")
                    []
                    [
                      Ty.apply
                        (Ty.path "&")
                        []
                        [
                          Ty.apply
                            (Ty.path "core::ptr::non_null::NonNull")
                            []
                            [ Ty.apply (Ty.path "alloc::collections::linked_list::Node") [] [ T ] ]
                        ]
                    ],
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "core::option::Option")
                      []
                      [
                        Ty.apply
                          (Ty.path "core::ptr::non_null::NonNull")
                          []
                          [ Ty.apply (Ty.path "alloc::collections::linked_list::Node") [] [ T ] ]
                      ],
                    "as_ref",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "alloc::collections::linked_list::LinkedList",
                        "tail"
                      |)
                    |)
                  ]
                |);
                M.closure
                  (fun γ =>
                    ltac:(M.monadic
                      match γ with
                      | [ α0 ] =>
                        ltac:(M.monadic
                          (M.match_operator (|
                            Some
                              (Ty.function
                                [
                                  Ty.tuple
                                    [
                                      Ty.apply
                                        (Ty.path "&")
                                        []
                                        [
                                          Ty.apply
                                            (Ty.path "core::ptr::non_null::NonNull")
                                            []
                                            [
                                              Ty.apply
                                                (Ty.path "alloc::collections::linked_list::Node")
                                                []
                                                [ T ]
                                            ]
                                        ]
                                    ]
                                ]
                                (Ty.apply (Ty.path "&") [] [ T ])),
                            M.alloc (| α0 |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let node := M.copy (| γ |) in
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.SubPointer.get_struct_record_field (|
                                      M.deref (|
                                        M.call_closure (|
                                          Ty.apply
                                            (Ty.path "&")
                                            []
                                            [
                                              Ty.apply
                                                (Ty.path "alloc::collections::linked_list::Node")
                                                []
                                                [ T ]
                                            ],
                                          M.get_associated_function (|
                                            Ty.apply
                                              (Ty.path "core::ptr::non_null::NonNull")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "alloc::collections::linked_list::Node")
                                                  []
                                                  [ T ]
                                              ],
                                            "as_ref",
                                            [],
                                            []
                                          |),
                                          [
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.deref (| M.read (| node |) |)
                                            |)
                                          ]
                                        |)
                                      |),
                                      "alloc::collections::linked_list::Node",
                                      "element"
                                    |)
                                  |)))
                            ]
                          |)))
                      | _ => M.impossible "wrong number of arguments"
                      end))
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_back :
        forall (T A : Ty.t),
        M.IsAssociatedFunction.C (Self T A) "back" (back T A).
      Admitted.
      Global Typeclasses Opaque back.
      
      (*
          pub fn back_mut(&mut self) -> Option<&mut T> {
              unsafe { self.tail.as_mut().map(|node| &mut node.as_mut().element) }
          }
      *)
      Definition back_mut (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.apply (Ty.path "core::option::Option") [] [ Ty.apply (Ty.path "&mut") [] [ T ] ],
              M.get_associated_function (|
                Ty.apply
                  (Ty.path "core::option::Option")
                  []
                  [
                    Ty.apply
                      (Ty.path "&mut")
                      []
                      [
                        Ty.apply
                          (Ty.path "core::ptr::non_null::NonNull")
                          []
                          [ Ty.apply (Ty.path "alloc::collections::linked_list::Node") [] [ T ] ]
                      ]
                  ],
                "map",
                [],
                [
                  Ty.apply (Ty.path "&mut") [] [ T ];
                  Ty.function
                    [
                      Ty.tuple
                        [
                          Ty.apply
                            (Ty.path "&mut")
                            []
                            [
                              Ty.apply
                                (Ty.path "core::ptr::non_null::NonNull")
                                []
                                [
                                  Ty.apply
                                    (Ty.path "alloc::collections::linked_list::Node")
                                    []
                                    [ T ]
                                ]
                            ]
                        ]
                    ]
                    (Ty.apply (Ty.path "&mut") [] [ T ])
                ]
              |),
              [
                M.call_closure (|
                  Ty.apply
                    (Ty.path "core::option::Option")
                    []
                    [
                      Ty.apply
                        (Ty.path "&mut")
                        []
                        [
                          Ty.apply
                            (Ty.path "core::ptr::non_null::NonNull")
                            []
                            [ Ty.apply (Ty.path "alloc::collections::linked_list::Node") [] [ T ] ]
                        ]
                    ],
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "core::option::Option")
                      []
                      [
                        Ty.apply
                          (Ty.path "core::ptr::non_null::NonNull")
                          []
                          [ Ty.apply (Ty.path "alloc::collections::linked_list::Node") [] [ T ] ]
                      ],
                    "as_mut",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.MutRef,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "alloc::collections::linked_list::LinkedList",
                        "tail"
                      |)
                    |)
                  ]
                |);
                M.closure
                  (fun γ =>
                    ltac:(M.monadic
                      match γ with
                      | [ α0 ] =>
                        ltac:(M.monadic
                          (M.match_operator (|
                            Some
                              (Ty.function
                                [
                                  Ty.tuple
                                    [
                                      Ty.apply
                                        (Ty.path "&mut")
                                        []
                                        [
                                          Ty.apply
                                            (Ty.path "core::ptr::non_null::NonNull")
                                            []
                                            [
                                              Ty.apply
                                                (Ty.path "alloc::collections::linked_list::Node")
                                                []
                                                [ T ]
                                            ]
                                        ]
                                    ]
                                ]
                                (Ty.apply (Ty.path "&mut") [] [ T ])),
                            M.alloc (| α0 |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let node := M.copy (| γ |) in
                                  M.borrow (|
                                    Pointer.Kind.MutRef,
                                    M.SubPointer.get_struct_record_field (|
                                      M.deref (|
                                        M.call_closure (|
                                          Ty.apply
                                            (Ty.path "&mut")
                                            []
                                            [
                                              Ty.apply
                                                (Ty.path "alloc::collections::linked_list::Node")
                                                []
                                                [ T ]
                                            ],
                                          M.get_associated_function (|
                                            Ty.apply
                                              (Ty.path "core::ptr::non_null::NonNull")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "alloc::collections::linked_list::Node")
                                                  []
                                                  [ T ]
                                              ],
                                            "as_mut",
                                            [],
                                            []
                                          |),
                                          [
                                            M.borrow (|
                                              Pointer.Kind.MutRef,
                                              M.deref (| M.read (| node |) |)
                                            |)
                                          ]
                                        |)
                                      |),
                                      "alloc::collections::linked_list::Node",
                                      "element"
                                    |)
                                  |)))
                            ]
                          |)))
                      | _ => M.impossible "wrong number of arguments"
                      end))
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_back_mut :
        forall (T A : Ty.t),
        M.IsAssociatedFunction.C (Self T A) "back_mut" (back_mut T A).
      Admitted.
      Global Typeclasses Opaque back_mut.
      
      (*
          pub fn push_front(&mut self, elt: T) {
              let node = Box::new_in(Node::new(elt), &self.alloc);
              let node_ptr = NonNull::from(Box::leak(node));
              // SAFETY: node_ptr is a unique pointer to a node we boxed with self.alloc and leaked
              unsafe {
                  self.push_front_node(node_ptr);
              }
          }
      *)
      Definition push_front
          (T A : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self T A in
        match ε, τ, α with
        | [], [], [ self; elt ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let elt := M.alloc (| elt |) in
            M.read (|
              let~ node :
                  Ty.apply
                    (Ty.path "alloc::boxed::Box")
                    []
                    [
                      Ty.apply (Ty.path "alloc::collections::linked_list::Node") [] [ T ];
                      Ty.apply (Ty.path "&") [] [ A ]
                    ] :=
                M.alloc (|
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "alloc::boxed::Box")
                      []
                      [
                        Ty.apply (Ty.path "alloc::collections::linked_list::Node") [] [ T ];
                        Ty.apply (Ty.path "&") [] [ A ]
                      ],
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "alloc::boxed::Box")
                        []
                        [
                          Ty.apply (Ty.path "alloc::collections::linked_list::Node") [] [ T ];
                          Ty.apply (Ty.path "&") [] [ A ]
                        ],
                      "new_in",
                      [],
                      []
                    |),
                    [
                      M.call_closure (|
                        Ty.apply (Ty.path "alloc::collections::linked_list::Node") [] [ T ],
                        M.get_associated_function (|
                          Ty.apply (Ty.path "alloc::collections::linked_list::Node") [] [ T ],
                          "new",
                          [],
                          []
                        |),
                        [ M.read (| elt |) ]
                      |);
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "alloc::collections::linked_list::LinkedList",
                          "alloc"
                        |)
                      |)
                    ]
                  |)
                |) in
              let~ node_ptr :
                  Ty.apply
                    (Ty.path "core::ptr::non_null::NonNull")
                    []
                    [ Ty.apply (Ty.path "alloc::collections::linked_list::Node") [] [ T ] ] :=
                M.alloc (|
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "core::ptr::non_null::NonNull")
                      []
                      [ Ty.apply (Ty.path "alloc::collections::linked_list::Node") [] [ T ] ],
                    M.get_trait_method (|
                      "core::convert::From",
                      Ty.apply
                        (Ty.path "core::ptr::non_null::NonNull")
                        []
                        [ Ty.apply (Ty.path "alloc::collections::linked_list::Node") [] [ T ] ],
                      [],
                      [
                        Ty.apply
                          (Ty.path "&mut")
                          []
                          [ Ty.apply (Ty.path "alloc::collections::linked_list::Node") [] [ T ] ]
                      ],
                      "from",
                      [],
                      []
                    |),
                    [
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "&mut")
                          []
                          [ Ty.apply (Ty.path "alloc::collections::linked_list::Node") [] [ T ] ],
                        M.get_associated_function (|
                          Ty.apply
                            (Ty.path "alloc::boxed::Box")
                            []
                            [
                              Ty.apply (Ty.path "alloc::collections::linked_list::Node") [] [ T ];
                              Ty.apply (Ty.path "&") [] [ A ]
                            ],
                          "leak",
                          [],
                          []
                        |),
                        [ M.read (| node |) ]
                      |)
                    ]
                  |)
                |) in
              let~ _ : Ty.tuple [] :=
                M.alloc (|
                  M.call_closure (|
                    Ty.tuple [],
                    M.get_associated_function (|
                      Ty.apply (Ty.path "alloc::collections::linked_list::LinkedList") [] [ T; A ],
                      "push_front_node",
                      [],
                      []
                    |),
                    [
                      M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |);
                      M.read (| node_ptr |)
                    ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_push_front :
        forall (T A : Ty.t),
        M.IsAssociatedFunction.C (Self T A) "push_front" (push_front T A).
      Admitted.
      Global Typeclasses Opaque push_front.
      
      (*
          pub fn pop_front(&mut self) -> Option<T> {
              self.pop_front_node().map(Node::into_element)
          }
      *)
      Definition pop_front (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.apply (Ty.path "core::option::Option") [] [ T ],
              M.get_associated_function (|
                Ty.apply
                  (Ty.path "core::option::Option")
                  []
                  [
                    Ty.apply
                      (Ty.path "alloc::boxed::Box")
                      []
                      [
                        Ty.apply (Ty.path "alloc::collections::linked_list::Node") [] [ T ];
                        Ty.apply (Ty.path "&") [] [ A ]
                      ]
                  ],
                "map",
                [],
                [
                  T;
                  Ty.function
                    [
                      Ty.apply
                        (Ty.path "alloc::boxed::Box")
                        []
                        [
                          Ty.apply (Ty.path "alloc::collections::linked_list::Node") [] [ T ];
                          Ty.apply (Ty.path "&") [] [ A ]
                        ]
                    ]
                    T
                ]
              |),
              [
                M.call_closure (|
                  Ty.apply
                    (Ty.path "core::option::Option")
                    []
                    [
                      Ty.apply
                        (Ty.path "alloc::boxed::Box")
                        []
                        [
                          Ty.apply (Ty.path "alloc::collections::linked_list::Node") [] [ T ];
                          Ty.apply (Ty.path "&") [] [ A ]
                        ]
                    ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "alloc::collections::linked_list::LinkedList") [] [ T; A ],
                    "pop_front_node",
                    [],
                    []
                  |),
                  [ M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |) ]
                |);
                M.get_associated_function (|
                  Ty.apply (Ty.path "alloc::collections::linked_list::Node") [] [ T ],
                  "into_element",
                  [],
                  [ Ty.apply (Ty.path "&") [] [ A ] ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_pop_front :
        forall (T A : Ty.t),
        M.IsAssociatedFunction.C (Self T A) "pop_front" (pop_front T A).
      Admitted.
      Global Typeclasses Opaque pop_front.
      
      (*
          pub fn push_back(&mut self, elt: T) {
              let node = Box::new_in(Node::new(elt), &self.alloc);
              let node_ptr = NonNull::from(Box::leak(node));
              // SAFETY: node_ptr is a unique pointer to a node we boxed with self.alloc and leaked
              unsafe {
                  self.push_back_node(node_ptr);
              }
          }
      *)
      Definition push_back (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match ε, τ, α with
        | [], [], [ self; elt ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let elt := M.alloc (| elt |) in
            M.read (|
              let~ node :
                  Ty.apply
                    (Ty.path "alloc::boxed::Box")
                    []
                    [
                      Ty.apply (Ty.path "alloc::collections::linked_list::Node") [] [ T ];
                      Ty.apply (Ty.path "&") [] [ A ]
                    ] :=
                M.alloc (|
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "alloc::boxed::Box")
                      []
                      [
                        Ty.apply (Ty.path "alloc::collections::linked_list::Node") [] [ T ];
                        Ty.apply (Ty.path "&") [] [ A ]
                      ],
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "alloc::boxed::Box")
                        []
                        [
                          Ty.apply (Ty.path "alloc::collections::linked_list::Node") [] [ T ];
                          Ty.apply (Ty.path "&") [] [ A ]
                        ],
                      "new_in",
                      [],
                      []
                    |),
                    [
                      M.call_closure (|
                        Ty.apply (Ty.path "alloc::collections::linked_list::Node") [] [ T ],
                        M.get_associated_function (|
                          Ty.apply (Ty.path "alloc::collections::linked_list::Node") [] [ T ],
                          "new",
                          [],
                          []
                        |),
                        [ M.read (| elt |) ]
                      |);
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "alloc::collections::linked_list::LinkedList",
                          "alloc"
                        |)
                      |)
                    ]
                  |)
                |) in
              let~ node_ptr :
                  Ty.apply
                    (Ty.path "core::ptr::non_null::NonNull")
                    []
                    [ Ty.apply (Ty.path "alloc::collections::linked_list::Node") [] [ T ] ] :=
                M.alloc (|
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "core::ptr::non_null::NonNull")
                      []
                      [ Ty.apply (Ty.path "alloc::collections::linked_list::Node") [] [ T ] ],
                    M.get_trait_method (|
                      "core::convert::From",
                      Ty.apply
                        (Ty.path "core::ptr::non_null::NonNull")
                        []
                        [ Ty.apply (Ty.path "alloc::collections::linked_list::Node") [] [ T ] ],
                      [],
                      [
                        Ty.apply
                          (Ty.path "&mut")
                          []
                          [ Ty.apply (Ty.path "alloc::collections::linked_list::Node") [] [ T ] ]
                      ],
                      "from",
                      [],
                      []
                    |),
                    [
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "&mut")
                          []
                          [ Ty.apply (Ty.path "alloc::collections::linked_list::Node") [] [ T ] ],
                        M.get_associated_function (|
                          Ty.apply
                            (Ty.path "alloc::boxed::Box")
                            []
                            [
                              Ty.apply (Ty.path "alloc::collections::linked_list::Node") [] [ T ];
                              Ty.apply (Ty.path "&") [] [ A ]
                            ],
                          "leak",
                          [],
                          []
                        |),
                        [ M.read (| node |) ]
                      |)
                    ]
                  |)
                |) in
              let~ _ : Ty.tuple [] :=
                M.alloc (|
                  M.call_closure (|
                    Ty.tuple [],
                    M.get_associated_function (|
                      Ty.apply (Ty.path "alloc::collections::linked_list::LinkedList") [] [ T; A ],
                      "push_back_node",
                      [],
                      []
                    |),
                    [
                      M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |);
                      M.read (| node_ptr |)
                    ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_push_back :
        forall (T A : Ty.t),
        M.IsAssociatedFunction.C (Self T A) "push_back" (push_back T A).
      Admitted.
      Global Typeclasses Opaque push_back.
      
      (*
          pub fn pop_back(&mut self) -> Option<T> {
              self.pop_back_node().map(Node::into_element)
          }
      *)
      Definition pop_back (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.apply (Ty.path "core::option::Option") [] [ T ],
              M.get_associated_function (|
                Ty.apply
                  (Ty.path "core::option::Option")
                  []
                  [
                    Ty.apply
                      (Ty.path "alloc::boxed::Box")
                      []
                      [
                        Ty.apply (Ty.path "alloc::collections::linked_list::Node") [] [ T ];
                        Ty.apply (Ty.path "&") [] [ A ]
                      ]
                  ],
                "map",
                [],
                [
                  T;
                  Ty.function
                    [
                      Ty.apply
                        (Ty.path "alloc::boxed::Box")
                        []
                        [
                          Ty.apply (Ty.path "alloc::collections::linked_list::Node") [] [ T ];
                          Ty.apply (Ty.path "&") [] [ A ]
                        ]
                    ]
                    T
                ]
              |),
              [
                M.call_closure (|
                  Ty.apply
                    (Ty.path "core::option::Option")
                    []
                    [
                      Ty.apply
                        (Ty.path "alloc::boxed::Box")
                        []
                        [
                          Ty.apply (Ty.path "alloc::collections::linked_list::Node") [] [ T ];
                          Ty.apply (Ty.path "&") [] [ A ]
                        ]
                    ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "alloc::collections::linked_list::LinkedList") [] [ T; A ],
                    "pop_back_node",
                    [],
                    []
                  |),
                  [ M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |) ]
                |);
                M.get_associated_function (|
                  Ty.apply (Ty.path "alloc::collections::linked_list::Node") [] [ T ],
                  "into_element",
                  [],
                  [ Ty.apply (Ty.path "&") [] [ A ] ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_pop_back :
        forall (T A : Ty.t),
        M.IsAssociatedFunction.C (Self T A) "pop_back" (pop_back T A).
      Admitted.
      Global Typeclasses Opaque pop_back.
      
      (*
          pub fn split_off(&mut self, at: usize) -> LinkedList<T, A>
          where
              A: Clone,
          {
              let len = self.len();
              assert!(at <= len, "Cannot split off at a nonexistent index");
              if at == 0 {
                  return mem::replace(self, Self::new_in(self.alloc.clone()));
              } else if at == len {
                  return Self::new_in(self.alloc.clone());
              }
      
              // Below, we iterate towards the `i-1`th node, either from the start or the end,
              // depending on which would be faster.
              let split_node = if at - 1 <= len - 1 - (at - 1) {
                  let mut iter = self.iter_mut();
                  // instead of skipping using .skip() (which creates a new struct),
                  // we skip manually so we can access the head field without
                  // depending on implementation details of Skip
                  for _ in 0..at - 1 {
                      iter.next();
                  }
                  iter.head
              } else {
                  // better off starting from the end
                  let mut iter = self.iter_mut();
                  for _ in 0..len - 1 - (at - 1) {
                      iter.next_back();
                  }
                  iter.tail
              };
              unsafe { self.split_off_after_node(split_node, at) }
          }
      *)
      Definition split_off (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match ε, τ, α with
        | [], [], [ self; at_ ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let at_ := M.alloc (| at_ |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.read (|
                  let~ len : Ty.path "usize" :=
                    M.alloc (|
                      M.call_closure (|
                        Ty.path "usize",
                        M.get_associated_function (|
                          Ty.apply
                            (Ty.path "alloc::collections::linked_list::LinkedList")
                            []
                            [ T; A ],
                          "len",
                          [],
                          []
                        |),
                        [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                      |)
                    |) in
                  let~ _ : Ty.tuple [] :=
                    M.match_operator (|
                      Some (Ty.tuple []),
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  UnOp.not (|
                                    M.call_closure (|
                                      Ty.path "bool",
                                      BinOp.le,
                                      [ M.read (| at_ |); M.read (| len |) ]
                                    |)
                                  |)
                                |)) in
                            let _ :=
                              is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (|
                              M.never_to_any (|
                                M.call_closure (|
                                  Ty.path "never",
                                  M.get_function (| "core::panicking::panic_fmt", [], [] |),
                                  [
                                    M.call_closure (|
                                      Ty.path "core::fmt::Arguments",
                                      M.get_associated_function (|
                                        Ty.path "core::fmt::Arguments",
                                        "new_const",
                                        [ Value.Integer IntegerKind.Usize 1 ],
                                        []
                                      |),
                                      [
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.deref (|
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.alloc (|
                                                Value.Array
                                                  [
                                                    mk_str (|
                                                      "Cannot split off at a nonexistent index"
                                                    |)
                                                  ]
                                              |)
                                            |)
                                          |)
                                        |)
                                      ]
                                    |)
                                  ]
                                |)
                              |)
                            |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                      ]
                    |) in
                  let~ _ : Ty.tuple [] :=
                    M.match_operator (|
                      Some (Ty.tuple []),
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  M.call_closure (|
                                    Ty.path "bool",
                                    BinOp.eq,
                                    [ M.read (| at_ |); Value.Integer IntegerKind.Usize 0 ]
                                  |)
                                |)) in
                            let _ :=
                              is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (|
                              M.never_to_any (|
                                M.read (|
                                  M.return_ (|
                                    M.call_closure (|
                                      Ty.apply
                                        (Ty.path "alloc::collections::linked_list::LinkedList")
                                        []
                                        [ T; A ],
                                      M.get_function (|
                                        "core::mem::replace",
                                        [],
                                        [
                                          Ty.apply
                                            (Ty.path "alloc::collections::linked_list::LinkedList")
                                            []
                                            [ T; A ]
                                        ]
                                      |),
                                      [
                                        M.borrow (|
                                          Pointer.Kind.MutRef,
                                          M.deref (| M.read (| self |) |)
                                        |);
                                        M.call_closure (|
                                          Ty.apply
                                            (Ty.path "alloc::collections::linked_list::LinkedList")
                                            []
                                            [ T; A ],
                                          M.get_associated_function (|
                                            Ty.apply
                                              (Ty.path
                                                "alloc::collections::linked_list::LinkedList")
                                              []
                                              [ T; A ],
                                            "new_in",
                                            [],
                                            []
                                          |),
                                          [
                                            M.call_closure (|
                                              A,
                                              M.get_trait_method (|
                                                "core::clone::Clone",
                                                A,
                                                [],
                                                [],
                                                "clone",
                                                [],
                                                []
                                              |),
                                              [
                                                M.borrow (|
                                                  Pointer.Kind.Ref,
                                                  M.SubPointer.get_struct_record_field (|
                                                    M.deref (| M.read (| self |) |),
                                                    "alloc::collections::linked_list::LinkedList",
                                                    "alloc"
                                                  |)
                                                |)
                                              ]
                                            |)
                                          ]
                                        |)
                                      ]
                                    |)
                                  |)
                                |)
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (M.match_operator (|
                              Some (Ty.tuple []),
                              M.alloc (| Value.Tuple [] |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let γ :=
                                      M.use
                                        (M.alloc (|
                                          M.call_closure (|
                                            Ty.path "bool",
                                            BinOp.eq,
                                            [ M.read (| at_ |); M.read (| len |) ]
                                          |)
                                        |)) in
                                    let _ :=
                                      is_constant_or_break_match (|
                                        M.read (| γ |),
                                        Value.Bool true
                                      |) in
                                    M.alloc (|
                                      M.never_to_any (|
                                        M.read (|
                                          M.return_ (|
                                            M.call_closure (|
                                              Ty.apply
                                                (Ty.path
                                                  "alloc::collections::linked_list::LinkedList")
                                                []
                                                [ T; A ],
                                              M.get_associated_function (|
                                                Ty.apply
                                                  (Ty.path
                                                    "alloc::collections::linked_list::LinkedList")
                                                  []
                                                  [ T; A ],
                                                "new_in",
                                                [],
                                                []
                                              |),
                                              [
                                                M.call_closure (|
                                                  A,
                                                  M.get_trait_method (|
                                                    "core::clone::Clone",
                                                    A,
                                                    [],
                                                    [],
                                                    "clone",
                                                    [],
                                                    []
                                                  |),
                                                  [
                                                    M.borrow (|
                                                      Pointer.Kind.Ref,
                                                      M.SubPointer.get_struct_record_field (|
                                                        M.deref (| M.read (| self |) |),
                                                        "alloc::collections::linked_list::LinkedList",
                                                        "alloc"
                                                      |)
                                                    |)
                                                  ]
                                                |)
                                              ]
                                            |)
                                          |)
                                        |)
                                      |)
                                    |)));
                                fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                              ]
                            |)))
                      ]
                    |) in
                  let~ split_node :
                      Ty.apply
                        (Ty.path "core::option::Option")
                        []
                        [
                          Ty.apply
                            (Ty.path "core::ptr::non_null::NonNull")
                            []
                            [ Ty.apply (Ty.path "alloc::collections::linked_list::Node") [] [ T ] ]
                        ] :=
                    M.copy (|
                      M.match_operator (|
                        Some
                          (Ty.apply
                            (Ty.path "core::option::Option")
                            []
                            [
                              Ty.apply
                                (Ty.path "core::ptr::non_null::NonNull")
                                []
                                [
                                  Ty.apply
                                    (Ty.path "alloc::collections::linked_list::Node")
                                    []
                                    [ T ]
                                ]
                            ]),
                        M.alloc (| Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.use
                                  (M.alloc (|
                                    M.call_closure (|
                                      Ty.path "bool",
                                      BinOp.le,
                                      [
                                        M.call_closure (|
                                          Ty.path "usize",
                                          BinOp.Wrap.sub,
                                          [ M.read (| at_ |); Value.Integer IntegerKind.Usize 1 ]
                                        |);
                                        M.call_closure (|
                                          Ty.path "usize",
                                          BinOp.Wrap.sub,
                                          [
                                            M.call_closure (|
                                              Ty.path "usize",
                                              BinOp.Wrap.sub,
                                              [ M.read (| len |); Value.Integer IntegerKind.Usize 1
                                              ]
                                            |);
                                            M.call_closure (|
                                              Ty.path "usize",
                                              BinOp.Wrap.sub,
                                              [ M.read (| at_ |); Value.Integer IntegerKind.Usize 1
                                              ]
                                            |)
                                          ]
                                        |)
                                      ]
                                    |)
                                  |)) in
                              let _ :=
                                is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                              let~ iter :
                                  Ty.apply
                                    (Ty.path "alloc::collections::linked_list::IterMut")
                                    []
                                    [ T ] :=
                                M.alloc (|
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "alloc::collections::linked_list::IterMut")
                                      []
                                      [ T ],
                                    M.get_associated_function (|
                                      Ty.apply
                                        (Ty.path "alloc::collections::linked_list::LinkedList")
                                        []
                                        [ T; A ],
                                      "iter_mut",
                                      [],
                                      []
                                    |),
                                    [
                                      M.borrow (|
                                        Pointer.Kind.MutRef,
                                        M.deref (| M.read (| self |) |)
                                      |)
                                    ]
                                  |)
                                |) in
                              let~ _ : Ty.tuple [] :=
                                M.use
                                  (M.match_operator (|
                                    Some (Ty.tuple []),
                                    M.alloc (|
                                      M.call_closure (|
                                        Ty.apply
                                          (Ty.path "core::ops::range::Range")
                                          []
                                          [ Ty.path "usize" ],
                                        M.get_trait_method (|
                                          "core::iter::traits::collect::IntoIterator",
                                          Ty.apply
                                            (Ty.path "core::ops::range::Range")
                                            []
                                            [ Ty.path "usize" ],
                                          [],
                                          [],
                                          "into_iter",
                                          [],
                                          []
                                        |),
                                        [
                                          Value.StructRecord
                                            "core::ops::range::Range"
                                            [
                                              ("start", Value.Integer IntegerKind.Usize 0);
                                              ("end_",
                                                M.call_closure (|
                                                  Ty.path "usize",
                                                  BinOp.Wrap.sub,
                                                  [
                                                    M.read (| at_ |);
                                                    Value.Integer IntegerKind.Usize 1
                                                  ]
                                                |))
                                            ]
                                        ]
                                      |)
                                    |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let iter := M.copy (| γ |) in
                                          M.loop (|
                                            Ty.tuple [],
                                            ltac:(M.monadic
                                              (let~ _ : Ty.tuple [] :=
                                                M.match_operator (|
                                                  Some (Ty.tuple []),
                                                  M.alloc (|
                                                    M.call_closure (|
                                                      Ty.apply
                                                        (Ty.path "core::option::Option")
                                                        []
                                                        [ Ty.path "usize" ],
                                                      M.get_trait_method (|
                                                        "core::iter::traits::iterator::Iterator",
                                                        Ty.apply
                                                          (Ty.path "core::ops::range::Range")
                                                          []
                                                          [ Ty.path "usize" ],
                                                        [],
                                                        [],
                                                        "next",
                                                        [],
                                                        []
                                                      |),
                                                      [
                                                        M.borrow (|
                                                          Pointer.Kind.MutRef,
                                                          M.deref (|
                                                            M.borrow (| Pointer.Kind.MutRef, iter |)
                                                          |)
                                                        |)
                                                      ]
                                                    |)
                                                  |),
                                                  [
                                                    fun γ =>
                                                      ltac:(M.monadic
                                                        (let _ :=
                                                          M.is_struct_tuple (|
                                                            γ,
                                                            "core::option::Option::None"
                                                          |) in
                                                        M.alloc (|
                                                          M.never_to_any (|
                                                            M.read (| M.break (||) |)
                                                          |)
                                                        |)));
                                                    fun γ =>
                                                      ltac:(M.monadic
                                                        (let γ0_0 :=
                                                          M.SubPointer.get_struct_tuple_field (|
                                                            γ,
                                                            "core::option::Option::Some",
                                                            0
                                                          |) in
                                                        let~ _ :
                                                            Ty.apply
                                                              (Ty.path "core::option::Option")
                                                              []
                                                              [ Ty.apply (Ty.path "&mut") [] [ T ]
                                                              ] :=
                                                          M.alloc (|
                                                            M.call_closure (|
                                                              Ty.apply
                                                                (Ty.path "core::option::Option")
                                                                []
                                                                [ Ty.apply (Ty.path "&mut") [] [ T ]
                                                                ],
                                                              M.get_trait_method (|
                                                                "core::iter::traits::iterator::Iterator",
                                                                Ty.apply
                                                                  (Ty.path
                                                                    "alloc::collections::linked_list::IterMut")
                                                                  []
                                                                  [ T ],
                                                                [],
                                                                [],
                                                                "next",
                                                                [],
                                                                []
                                                              |),
                                                              [
                                                                M.borrow (|
                                                                  Pointer.Kind.MutRef,
                                                                  iter
                                                                |)
                                                              ]
                                                            |)
                                                          |) in
                                                        M.alloc (| Value.Tuple [] |)))
                                                  ]
                                                |) in
                                              M.alloc (| Value.Tuple [] |)))
                                          |)))
                                    ]
                                  |)) in
                              M.SubPointer.get_struct_record_field (|
                                iter,
                                "alloc::collections::linked_list::IterMut",
                                "head"
                              |)));
                          fun γ =>
                            ltac:(M.monadic
                              (let~ iter :
                                  Ty.apply
                                    (Ty.path "alloc::collections::linked_list::IterMut")
                                    []
                                    [ T ] :=
                                M.alloc (|
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "alloc::collections::linked_list::IterMut")
                                      []
                                      [ T ],
                                    M.get_associated_function (|
                                      Ty.apply
                                        (Ty.path "alloc::collections::linked_list::LinkedList")
                                        []
                                        [ T; A ],
                                      "iter_mut",
                                      [],
                                      []
                                    |),
                                    [
                                      M.borrow (|
                                        Pointer.Kind.MutRef,
                                        M.deref (| M.read (| self |) |)
                                      |)
                                    ]
                                  |)
                                |) in
                              let~ _ : Ty.tuple [] :=
                                M.use
                                  (M.match_operator (|
                                    Some (Ty.tuple []),
                                    M.alloc (|
                                      M.call_closure (|
                                        Ty.apply
                                          (Ty.path "core::ops::range::Range")
                                          []
                                          [ Ty.path "usize" ],
                                        M.get_trait_method (|
                                          "core::iter::traits::collect::IntoIterator",
                                          Ty.apply
                                            (Ty.path "core::ops::range::Range")
                                            []
                                            [ Ty.path "usize" ],
                                          [],
                                          [],
                                          "into_iter",
                                          [],
                                          []
                                        |),
                                        [
                                          Value.StructRecord
                                            "core::ops::range::Range"
                                            [
                                              ("start", Value.Integer IntegerKind.Usize 0);
                                              ("end_",
                                                M.call_closure (|
                                                  Ty.path "usize",
                                                  BinOp.Wrap.sub,
                                                  [
                                                    M.call_closure (|
                                                      Ty.path "usize",
                                                      BinOp.Wrap.sub,
                                                      [
                                                        M.read (| len |);
                                                        Value.Integer IntegerKind.Usize 1
                                                      ]
                                                    |);
                                                    M.call_closure (|
                                                      Ty.path "usize",
                                                      BinOp.Wrap.sub,
                                                      [
                                                        M.read (| at_ |);
                                                        Value.Integer IntegerKind.Usize 1
                                                      ]
                                                    |)
                                                  ]
                                                |))
                                            ]
                                        ]
                                      |)
                                    |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let iter := M.copy (| γ |) in
                                          M.loop (|
                                            Ty.tuple [],
                                            ltac:(M.monadic
                                              (let~ _ : Ty.tuple [] :=
                                                M.match_operator (|
                                                  Some (Ty.tuple []),
                                                  M.alloc (|
                                                    M.call_closure (|
                                                      Ty.apply
                                                        (Ty.path "core::option::Option")
                                                        []
                                                        [ Ty.path "usize" ],
                                                      M.get_trait_method (|
                                                        "core::iter::traits::iterator::Iterator",
                                                        Ty.apply
                                                          (Ty.path "core::ops::range::Range")
                                                          []
                                                          [ Ty.path "usize" ],
                                                        [],
                                                        [],
                                                        "next",
                                                        [],
                                                        []
                                                      |),
                                                      [
                                                        M.borrow (|
                                                          Pointer.Kind.MutRef,
                                                          M.deref (|
                                                            M.borrow (| Pointer.Kind.MutRef, iter |)
                                                          |)
                                                        |)
                                                      ]
                                                    |)
                                                  |),
                                                  [
                                                    fun γ =>
                                                      ltac:(M.monadic
                                                        (let _ :=
                                                          M.is_struct_tuple (|
                                                            γ,
                                                            "core::option::Option::None"
                                                          |) in
                                                        M.alloc (|
                                                          M.never_to_any (|
                                                            M.read (| M.break (||) |)
                                                          |)
                                                        |)));
                                                    fun γ =>
                                                      ltac:(M.monadic
                                                        (let γ0_0 :=
                                                          M.SubPointer.get_struct_tuple_field (|
                                                            γ,
                                                            "core::option::Option::Some",
                                                            0
                                                          |) in
                                                        let~ _ :
                                                            Ty.apply
                                                              (Ty.path "core::option::Option")
                                                              []
                                                              [ Ty.apply (Ty.path "&mut") [] [ T ]
                                                              ] :=
                                                          M.alloc (|
                                                            M.call_closure (|
                                                              Ty.apply
                                                                (Ty.path "core::option::Option")
                                                                []
                                                                [ Ty.apply (Ty.path "&mut") [] [ T ]
                                                                ],
                                                              M.get_trait_method (|
                                                                "core::iter::traits::double_ended::DoubleEndedIterator",
                                                                Ty.apply
                                                                  (Ty.path
                                                                    "alloc::collections::linked_list::IterMut")
                                                                  []
                                                                  [ T ],
                                                                [],
                                                                [],
                                                                "next_back",
                                                                [],
                                                                []
                                                              |),
                                                              [
                                                                M.borrow (|
                                                                  Pointer.Kind.MutRef,
                                                                  iter
                                                                |)
                                                              ]
                                                            |)
                                                          |) in
                                                        M.alloc (| Value.Tuple [] |)))
                                                  ]
                                                |) in
                                              M.alloc (| Value.Tuple [] |)))
                                          |)))
                                    ]
                                  |)) in
                              M.SubPointer.get_struct_record_field (|
                                iter,
                                "alloc::collections::linked_list::IterMut",
                                "tail"
                              |)))
                        ]
                      |)
                    |) in
                  M.alloc (|
                    M.call_closure (|
                      Ty.apply (Ty.path "alloc::collections::linked_list::LinkedList") [] [ T; A ],
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "alloc::collections::linked_list::LinkedList")
                          []
                          [ T; A ],
                        "split_off_after_node",
                        [],
                        []
                      |),
                      [
                        M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |);
                        M.read (| split_node |);
                        M.read (| at_ |)
                      ]
                    |)
                  |)
                |)))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_split_off :
        forall (T A : Ty.t),
        M.IsAssociatedFunction.C (Self T A) "split_off" (split_off T A).
      Admitted.
      Global Typeclasses Opaque split_off.
      
      (*
          pub fn remove(&mut self, at: usize) -> T {
              let len = self.len();
              assert!(at < len, "Cannot remove at an index outside of the list bounds");
      
              // Below, we iterate towards the node at the given index, either from
              // the start or the end, depending on which would be faster.
              let offset_from_end = len - at - 1;
              if at <= offset_from_end {
                  let mut cursor = self.cursor_front_mut();
                  for _ in 0..at {
                      cursor.move_next();
                  }
                  cursor.remove_current().unwrap()
              } else {
                  let mut cursor = self.cursor_back_mut();
                  for _ in 0..offset_from_end {
                      cursor.move_prev();
                  }
                  cursor.remove_current().unwrap()
              }
          }
      *)
      Definition remove (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match ε, τ, α with
        | [], [], [ self; at_ ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let at_ := M.alloc (| at_ |) in
            M.read (|
              let~ len : Ty.path "usize" :=
                M.alloc (|
                  M.call_closure (|
                    Ty.path "usize",
                    M.get_associated_function (|
                      Ty.apply (Ty.path "alloc::collections::linked_list::LinkedList") [] [ T; A ],
                      "len",
                      [],
                      []
                    |),
                    [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                  |)
                |) in
              let~ _ : Ty.tuple [] :=
                M.match_operator (|
                  Some (Ty.tuple []),
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ :=
                          M.use
                            (M.alloc (|
                              UnOp.not (|
                                M.call_closure (|
                                  Ty.path "bool",
                                  BinOp.lt,
                                  [ M.read (| at_ |); M.read (| len |) ]
                                |)
                              |)
                            |)) in
                        let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        M.alloc (|
                          M.never_to_any (|
                            M.call_closure (|
                              Ty.path "never",
                              M.get_function (| "core::panicking::panic_fmt", [], [] |),
                              [
                                M.call_closure (|
                                  Ty.path "core::fmt::Arguments",
                                  M.get_associated_function (|
                                    Ty.path "core::fmt::Arguments",
                                    "new_const",
                                    [ Value.Integer IntegerKind.Usize 1 ],
                                    []
                                  |),
                                  [
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.deref (|
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.alloc (|
                                            Value.Array
                                              [
                                                mk_str (|
                                                  "Cannot remove at an index outside of the list bounds"
                                                |)
                                              ]
                                          |)
                                        |)
                                      |)
                                    |)
                                  ]
                                |)
                              ]
                            |)
                          |)
                        |)));
                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                  ]
                |) in
              let~ offset_from_end : Ty.path "usize" :=
                M.alloc (|
                  M.call_closure (|
                    Ty.path "usize",
                    BinOp.Wrap.sub,
                    [
                      M.call_closure (|
                        Ty.path "usize",
                        BinOp.Wrap.sub,
                        [ M.read (| len |); M.read (| at_ |) ]
                      |);
                      Value.Integer IntegerKind.Usize 1
                    ]
                  |)
                |) in
              M.match_operator (|
                Some T,
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            M.call_closure (|
                              Ty.path "bool",
                              BinOp.le,
                              [ M.read (| at_ |); M.read (| offset_from_end |) ]
                            |)
                          |)) in
                      let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      let~ cursor :
                          Ty.apply
                            (Ty.path "alloc::collections::linked_list::CursorMut")
                            []
                            [ T; A ] :=
                        M.alloc (|
                          M.call_closure (|
                            Ty.apply
                              (Ty.path "alloc::collections::linked_list::CursorMut")
                              []
                              [ T; A ],
                            M.get_associated_function (|
                              Ty.apply
                                (Ty.path "alloc::collections::linked_list::LinkedList")
                                []
                                [ T; A ],
                              "cursor_front_mut",
                              [],
                              []
                            |),
                            [ M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |) ]
                          |)
                        |) in
                      let~ _ : Ty.tuple [] :=
                        M.use
                          (M.match_operator (|
                            Some (Ty.tuple []),
                            M.alloc (|
                              M.call_closure (|
                                Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "usize" ],
                                M.get_trait_method (|
                                  "core::iter::traits::collect::IntoIterator",
                                  Ty.apply
                                    (Ty.path "core::ops::range::Range")
                                    []
                                    [ Ty.path "usize" ],
                                  [],
                                  [],
                                  "into_iter",
                                  [],
                                  []
                                |),
                                [
                                  Value.StructRecord
                                    "core::ops::range::Range"
                                    [
                                      ("start", Value.Integer IntegerKind.Usize 0);
                                      ("end_", M.read (| at_ |))
                                    ]
                                ]
                              |)
                            |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let iter := M.copy (| γ |) in
                                  M.loop (|
                                    Ty.tuple [],
                                    ltac:(M.monadic
                                      (let~ _ : Ty.tuple [] :=
                                        M.match_operator (|
                                          Some (Ty.tuple []),
                                          M.alloc (|
                                            M.call_closure (|
                                              Ty.apply
                                                (Ty.path "core::option::Option")
                                                []
                                                [ Ty.path "usize" ],
                                              M.get_trait_method (|
                                                "core::iter::traits::iterator::Iterator",
                                                Ty.apply
                                                  (Ty.path "core::ops::range::Range")
                                                  []
                                                  [ Ty.path "usize" ],
                                                [],
                                                [],
                                                "next",
                                                [],
                                                []
                                              |),
                                              [
                                                M.borrow (|
                                                  Pointer.Kind.MutRef,
                                                  M.deref (|
                                                    M.borrow (| Pointer.Kind.MutRef, iter |)
                                                  |)
                                                |)
                                              ]
                                            |)
                                          |),
                                          [
                                            fun γ =>
                                              ltac:(M.monadic
                                                (let _ :=
                                                  M.is_struct_tuple (|
                                                    γ,
                                                    "core::option::Option::None"
                                                  |) in
                                                M.alloc (|
                                                  M.never_to_any (| M.read (| M.break (||) |) |)
                                                |)));
                                            fun γ =>
                                              ltac:(M.monadic
                                                (let γ0_0 :=
                                                  M.SubPointer.get_struct_tuple_field (|
                                                    γ,
                                                    "core::option::Option::Some",
                                                    0
                                                  |) in
                                                let~ _ : Ty.tuple [] :=
                                                  M.alloc (|
                                                    M.call_closure (|
                                                      Ty.tuple [],
                                                      M.get_associated_function (|
                                                        Ty.apply
                                                          (Ty.path
                                                            "alloc::collections::linked_list::CursorMut")
                                                          []
                                                          [ T; A ],
                                                        "move_next",
                                                        [],
                                                        []
                                                      |),
                                                      [ M.borrow (| Pointer.Kind.MutRef, cursor |) ]
                                                    |)
                                                  |) in
                                                M.alloc (| Value.Tuple [] |)))
                                          ]
                                        |) in
                                      M.alloc (| Value.Tuple [] |)))
                                  |)))
                            ]
                          |)) in
                      M.alloc (|
                        M.call_closure (|
                          T,
                          M.get_associated_function (|
                            Ty.apply (Ty.path "core::option::Option") [] [ T ],
                            "unwrap",
                            [],
                            []
                          |),
                          [
                            M.call_closure (|
                              Ty.apply (Ty.path "core::option::Option") [] [ T ],
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "alloc::collections::linked_list::CursorMut")
                                  []
                                  [ T; A ],
                                "remove_current",
                                [],
                                []
                              |),
                              [ M.borrow (| Pointer.Kind.MutRef, cursor |) ]
                            |)
                          ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let~ cursor :
                          Ty.apply
                            (Ty.path "alloc::collections::linked_list::CursorMut")
                            []
                            [ T; A ] :=
                        M.alloc (|
                          M.call_closure (|
                            Ty.apply
                              (Ty.path "alloc::collections::linked_list::CursorMut")
                              []
                              [ T; A ],
                            M.get_associated_function (|
                              Ty.apply
                                (Ty.path "alloc::collections::linked_list::LinkedList")
                                []
                                [ T; A ],
                              "cursor_back_mut",
                              [],
                              []
                            |),
                            [ M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |) ]
                          |)
                        |) in
                      let~ _ : Ty.tuple [] :=
                        M.use
                          (M.match_operator (|
                            Some (Ty.tuple []),
                            M.alloc (|
                              M.call_closure (|
                                Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "usize" ],
                                M.get_trait_method (|
                                  "core::iter::traits::collect::IntoIterator",
                                  Ty.apply
                                    (Ty.path "core::ops::range::Range")
                                    []
                                    [ Ty.path "usize" ],
                                  [],
                                  [],
                                  "into_iter",
                                  [],
                                  []
                                |),
                                [
                                  Value.StructRecord
                                    "core::ops::range::Range"
                                    [
                                      ("start", Value.Integer IntegerKind.Usize 0);
                                      ("end_", M.read (| offset_from_end |))
                                    ]
                                ]
                              |)
                            |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let iter := M.copy (| γ |) in
                                  M.loop (|
                                    Ty.tuple [],
                                    ltac:(M.monadic
                                      (let~ _ : Ty.tuple [] :=
                                        M.match_operator (|
                                          Some (Ty.tuple []),
                                          M.alloc (|
                                            M.call_closure (|
                                              Ty.apply
                                                (Ty.path "core::option::Option")
                                                []
                                                [ Ty.path "usize" ],
                                              M.get_trait_method (|
                                                "core::iter::traits::iterator::Iterator",
                                                Ty.apply
                                                  (Ty.path "core::ops::range::Range")
                                                  []
                                                  [ Ty.path "usize" ],
                                                [],
                                                [],
                                                "next",
                                                [],
                                                []
                                              |),
                                              [
                                                M.borrow (|
                                                  Pointer.Kind.MutRef,
                                                  M.deref (|
                                                    M.borrow (| Pointer.Kind.MutRef, iter |)
                                                  |)
                                                |)
                                              ]
                                            |)
                                          |),
                                          [
                                            fun γ =>
                                              ltac:(M.monadic
                                                (let _ :=
                                                  M.is_struct_tuple (|
                                                    γ,
                                                    "core::option::Option::None"
                                                  |) in
                                                M.alloc (|
                                                  M.never_to_any (| M.read (| M.break (||) |) |)
                                                |)));
                                            fun γ =>
                                              ltac:(M.monadic
                                                (let γ0_0 :=
                                                  M.SubPointer.get_struct_tuple_field (|
                                                    γ,
                                                    "core::option::Option::Some",
                                                    0
                                                  |) in
                                                let~ _ : Ty.tuple [] :=
                                                  M.alloc (|
                                                    M.call_closure (|
                                                      Ty.tuple [],
                                                      M.get_associated_function (|
                                                        Ty.apply
                                                          (Ty.path
                                                            "alloc::collections::linked_list::CursorMut")
                                                          []
                                                          [ T; A ],
                                                        "move_prev",
                                                        [],
                                                        []
                                                      |),
                                                      [ M.borrow (| Pointer.Kind.MutRef, cursor |) ]
                                                    |)
                                                  |) in
                                                M.alloc (| Value.Tuple [] |)))
                                          ]
                                        |) in
                                      M.alloc (| Value.Tuple [] |)))
                                  |)))
                            ]
                          |)) in
                      M.alloc (|
                        M.call_closure (|
                          T,
                          M.get_associated_function (|
                            Ty.apply (Ty.path "core::option::Option") [] [ T ],
                            "unwrap",
                            [],
                            []
                          |),
                          [
                            M.call_closure (|
                              Ty.apply (Ty.path "core::option::Option") [] [ T ],
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "alloc::collections::linked_list::CursorMut")
                                  []
                                  [ T; A ],
                                "remove_current",
                                [],
                                []
                              |),
                              [ M.borrow (| Pointer.Kind.MutRef, cursor |) ]
                            |)
                          ]
                        |)
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_remove :
        forall (T A : Ty.t),
        M.IsAssociatedFunction.C (Self T A) "remove" (remove T A).
      Admitted.
      Global Typeclasses Opaque remove.
      
      (*
          pub fn retain<F>(&mut self, mut f: F)
          where
              F: FnMut(&T) -> bool,
          {
              self.retain_mut(|elem| f(elem));
          }
      *)
      Definition retain (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match ε, τ, α with
        | [], [ F ], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.read (|
              let~ _ : Ty.tuple [] :=
                M.alloc (|
                  M.call_closure (|
                    Ty.tuple [],
                    M.get_associated_function (|
                      Ty.apply (Ty.path "alloc::collections::linked_list::LinkedList") [] [ T; A ],
                      "retain_mut",
                      [],
                      [
                        Ty.function
                          [ Ty.tuple [ Ty.apply (Ty.path "&mut") [] [ T ] ] ]
                          (Ty.path "bool")
                      ]
                    |),
                    [
                      M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |);
                      M.closure
                        (fun γ =>
                          ltac:(M.monadic
                            match γ with
                            | [ α0 ] =>
                              ltac:(M.monadic
                                (M.match_operator (|
                                  Some
                                    (Ty.function
                                      [ Ty.tuple [ Ty.apply (Ty.path "&mut") [] [ T ] ] ]
                                      (Ty.path "bool")),
                                  M.alloc (| α0 |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let elem := M.copy (| γ |) in
                                        M.call_closure (|
                                          Ty.path "bool",
                                          M.get_trait_method (|
                                            "core::ops::function::FnMut",
                                            F,
                                            [],
                                            [ Ty.tuple [ Ty.apply (Ty.path "&") [] [ T ] ] ],
                                            "call_mut",
                                            [],
                                            []
                                          |),
                                          [
                                            M.borrow (| Pointer.Kind.MutRef, f |);
                                            Value.Tuple
                                              [
                                                M.borrow (|
                                                  Pointer.Kind.Ref,
                                                  M.deref (| M.read (| elem |) |)
                                                |)
                                              ]
                                          ]
                                        |)))
                                  ]
                                |)))
                            | _ => M.impossible "wrong number of arguments"
                            end))
                    ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_retain :
        forall (T A : Ty.t),
        M.IsAssociatedFunction.C (Self T A) "retain" (retain T A).
      Admitted.
      Global Typeclasses Opaque retain.
      
      (*
          pub fn retain_mut<F>(&mut self, mut f: F)
          where
              F: FnMut(&mut T) -> bool,
          {
              let mut cursor = self.cursor_front_mut();
              while let Some(node) = cursor.current() {
                  if !f(node) {
                      cursor.remove_current().unwrap();
                  } else {
                      cursor.move_next();
                  }
              }
          }
      *)
      Definition retain_mut
          (T A : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self T A in
        match ε, τ, α with
        | [], [ F ], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.read (|
              let~ cursor :
                  Ty.apply (Ty.path "alloc::collections::linked_list::CursorMut") [] [ T; A ] :=
                M.alloc (|
                  M.call_closure (|
                    Ty.apply (Ty.path "alloc::collections::linked_list::CursorMut") [] [ T; A ],
                    M.get_associated_function (|
                      Ty.apply (Ty.path "alloc::collections::linked_list::LinkedList") [] [ T; A ],
                      "cursor_front_mut",
                      [],
                      []
                    |),
                    [ M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |) ]
                  |)
                |) in
              M.loop (|
                Ty.tuple [],
                ltac:(M.monadic
                  (M.match_operator (|
                    Some (Ty.tuple []),
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.alloc (|
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "core::option::Option")
                                  []
                                  [ Ty.apply (Ty.path "&mut") [] [ T ] ],
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "alloc::collections::linked_list::CursorMut")
                                    []
                                    [ T; A ],
                                  "current",
                                  [],
                                  []
                                |),
                                [ M.borrow (| Pointer.Kind.MutRef, cursor |) ]
                              |)
                            |) in
                          let γ0_0 :=
                            M.SubPointer.get_struct_tuple_field (|
                              γ,
                              "core::option::Option::Some",
                              0
                            |) in
                          let node := M.copy (| γ0_0 |) in
                          M.match_operator (|
                            Some (Ty.tuple []),
                            M.alloc (| Value.Tuple [] |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ :=
                                    M.use
                                      (M.alloc (|
                                        UnOp.not (|
                                          M.call_closure (|
                                            Ty.path "bool",
                                            M.get_trait_method (|
                                              "core::ops::function::FnMut",
                                              F,
                                              [],
                                              [ Ty.tuple [ Ty.apply (Ty.path "&mut") [] [ T ] ] ],
                                              "call_mut",
                                              [],
                                              []
                                            |),
                                            [
                                              M.borrow (| Pointer.Kind.MutRef, f |);
                                              Value.Tuple
                                                [
                                                  M.borrow (|
                                                    Pointer.Kind.MutRef,
                                                    M.deref (| M.read (| node |) |)
                                                  |)
                                                ]
                                            ]
                                          |)
                                        |)
                                      |)) in
                                  let _ :=
                                    is_constant_or_break_match (|
                                      M.read (| γ |),
                                      Value.Bool true
                                    |) in
                                  let~ _ : T :=
                                    M.alloc (|
                                      M.call_closure (|
                                        T,
                                        M.get_associated_function (|
                                          Ty.apply (Ty.path "core::option::Option") [] [ T ],
                                          "unwrap",
                                          [],
                                          []
                                        |),
                                        [
                                          M.call_closure (|
                                            Ty.apply (Ty.path "core::option::Option") [] [ T ],
                                            M.get_associated_function (|
                                              Ty.apply
                                                (Ty.path
                                                  "alloc::collections::linked_list::CursorMut")
                                                []
                                                [ T; A ],
                                              "remove_current",
                                              [],
                                              []
                                            |),
                                            [ M.borrow (| Pointer.Kind.MutRef, cursor |) ]
                                          |)
                                        ]
                                      |)
                                    |) in
                                  M.alloc (| Value.Tuple [] |)));
                              fun γ =>
                                ltac:(M.monadic
                                  (let~ _ : Ty.tuple [] :=
                                    M.alloc (|
                                      M.call_closure (|
                                        Ty.tuple [],
                                        M.get_associated_function (|
                                          Ty.apply
                                            (Ty.path "alloc::collections::linked_list::CursorMut")
                                            []
                                            [ T; A ],
                                          "move_next",
                                          [],
                                          []
                                        |),
                                        [ M.borrow (| Pointer.Kind.MutRef, cursor |) ]
                                      |)
                                    |) in
                                  M.alloc (| Value.Tuple [] |)))
                            ]
                          |)));
                      fun γ =>
                        ltac:(M.monadic
                          (M.alloc (|
                            M.never_to_any (|
                              M.read (|
                                let~ _ : Ty.tuple [] :=
                                  M.alloc (| M.never_to_any (| M.read (| M.break (||) |) |) |) in
                                M.alloc (| Value.Tuple [] |)
                              |)
                            |)
                          |)))
                    ]
                  |)))
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_retain_mut :
        forall (T A : Ty.t),
        M.IsAssociatedFunction.C (Self T A) "retain_mut" (retain_mut T A).
      Admitted.
      Global Typeclasses Opaque retain_mut.
      
      (*
          pub fn extract_if<F>(&mut self, filter: F) -> ExtractIf<'_, T, F, A>
          where
              F: FnMut(&mut T) -> bool,
          {
              // avoid borrow issues.
              let it = self.head;
              let old_len = self.len;
      
              ExtractIf { list: self, it, pred: filter, idx: 0, old_len }
          }
      *)
      Definition extract_if
          (T A : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self T A in
        match ε, τ, α with
        | [], [ F ], [ self; filter ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let filter := M.alloc (| filter |) in
            M.read (|
              let~ it :
                  Ty.apply
                    (Ty.path "core::option::Option")
                    []
                    [
                      Ty.apply
                        (Ty.path "core::ptr::non_null::NonNull")
                        []
                        [ Ty.apply (Ty.path "alloc::collections::linked_list::Node") [] [ T ] ]
                    ] :=
                M.copy (|
                  M.SubPointer.get_struct_record_field (|
                    M.deref (| M.read (| self |) |),
                    "alloc::collections::linked_list::LinkedList",
                    "head"
                  |)
                |) in
              let~ old_len : Ty.path "usize" :=
                M.copy (|
                  M.SubPointer.get_struct_record_field (|
                    M.deref (| M.read (| self |) |),
                    "alloc::collections::linked_list::LinkedList",
                    "len"
                  |)
                |) in
              M.alloc (|
                Value.StructRecord
                  "alloc::collections::linked_list::ExtractIf"
                  [
                    ("list", M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |));
                    ("it", M.read (| it |));
                    ("pred", M.read (| filter |));
                    ("idx", Value.Integer IntegerKind.Usize 0);
                    ("old_len", M.read (| old_len |))
                  ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_extract_if :
        forall (T A : Ty.t),
        M.IsAssociatedFunction.C (Self T A) "extract_if" (extract_if T A).
      Admitted.
      Global Typeclasses Opaque extract_if.
    End Impl_alloc_collections_linked_list_LinkedList_T_A.
    
    Module Impl_core_default_Default_for_alloc_collections_linked_list_LinkedList_T_alloc_alloc_Global.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply
          (Ty.path "alloc::collections::linked_list::LinkedList")
          []
          [ T; Ty.path "alloc::alloc::Global" ].
      
      (*
          fn default() -> Self {
              Self::new()
          }
      *)
      Definition default (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [] =>
          ltac:(M.monadic
            (M.call_closure (|
              Ty.apply
                (Ty.path "alloc::collections::linked_list::LinkedList")
                []
                [ T; Ty.path "alloc::alloc::Global" ],
              M.get_associated_function (|
                Ty.apply
                  (Ty.path "alloc::collections::linked_list::LinkedList")
                  []
                  [ T; Ty.path "alloc::alloc::Global" ],
                "new",
                [],
                []
              |),
              []
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::default::Default"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T)
          (* Instance *) [ ("default", InstanceField.Method (default T)) ].
    End Impl_core_default_Default_for_alloc_collections_linked_list_LinkedList_T_alloc_alloc_Global.
    
    Module Impl_alloc_collections_linked_list_LinkedList_T_alloc_alloc_Global.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply
          (Ty.path "alloc::collections::linked_list::LinkedList")
          []
          [ T; Ty.path "alloc::alloc::Global" ].
      
      (*
          pub const fn new() -> Self {
              LinkedList { head: None, tail: None, len: 0, alloc: Global, marker: PhantomData }
          }
      *)
      Definition new (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [] =>
          ltac:(M.monadic
            (Value.StructRecord
              "alloc::collections::linked_list::LinkedList"
              [
                ("head", Value.StructTuple "core::option::Option::None" []);
                ("tail", Value.StructTuple "core::option::Option::None" []);
                ("len", Value.Integer IntegerKind.Usize 0);
                ("alloc", Value.StructTuple "alloc::alloc::Global" []);
                ("marker", Value.StructTuple "core::marker::PhantomData" [])
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_new :
        forall (T : Ty.t),
        M.IsAssociatedFunction.C (Self T) "new" (new T).
      Admitted.
      Global Typeclasses Opaque new.
      
      (*
          pub fn append(&mut self, other: &mut Self) {
              match self.tail {
                  None => mem::swap(self, other),
                  Some(mut tail) => {
                      // `as_mut` is okay here because we have exclusive access to the entirety
                      // of both lists.
                      if let Some(mut other_head) = other.head.take() {
                          unsafe {
                              tail.as_mut().next = Some(other_head);
                              other_head.as_mut().prev = Some(tail);
                          }
      
                          self.tail = other.tail.take();
                          self.len += mem::replace(&mut other.len, 0);
                      }
                  }
              }
          }
      *)
      Definition append (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              M.match_operator (|
                Some (Ty.tuple []),
                M.SubPointer.get_struct_record_field (|
                  M.deref (| M.read (| self |) |),
                  "alloc::collections::linked_list::LinkedList",
                  "tail"
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let _ := M.is_struct_tuple (| γ, "core::option::Option::None" |) in
                      M.alloc (|
                        M.call_closure (|
                          Ty.tuple [],
                          M.get_function (|
                            "core::mem::swap",
                            [],
                            [
                              Ty.apply
                                (Ty.path "alloc::collections::linked_list::LinkedList")
                                []
                                [ T; Ty.path "alloc::alloc::Global" ]
                            ]
                          |),
                          [
                            M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |);
                            M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| other |) |) |)
                          ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::option::Option::Some",
                          0
                        |) in
                      let tail := M.copy (| γ0_0 |) in
                      M.match_operator (|
                        Some (Ty.tuple []),
                        M.alloc (| Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.alloc (|
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "core::option::Option")
                                      []
                                      [
                                        Ty.apply
                                          (Ty.path "core::ptr::non_null::NonNull")
                                          []
                                          [
                                            Ty.apply
                                              (Ty.path "alloc::collections::linked_list::Node")
                                              []
                                              [ T ]
                                          ]
                                      ],
                                    M.get_associated_function (|
                                      Ty.apply
                                        (Ty.path "core::option::Option")
                                        []
                                        [
                                          Ty.apply
                                            (Ty.path "core::ptr::non_null::NonNull")
                                            []
                                            [
                                              Ty.apply
                                                (Ty.path "alloc::collections::linked_list::Node")
                                                []
                                                [ T ]
                                            ]
                                        ],
                                      "take",
                                      [],
                                      []
                                    |),
                                    [
                                      M.borrow (|
                                        Pointer.Kind.MutRef,
                                        M.SubPointer.get_struct_record_field (|
                                          M.deref (| M.read (| other |) |),
                                          "alloc::collections::linked_list::LinkedList",
                                          "head"
                                        |)
                                      |)
                                    ]
                                  |)
                                |) in
                              let γ0_0 :=
                                M.SubPointer.get_struct_tuple_field (|
                                  γ,
                                  "core::option::Option::Some",
                                  0
                                |) in
                              let other_head := M.copy (| γ0_0 |) in
                              let~ _ : Ty.tuple [] :=
                                let~ _ : Ty.tuple [] :=
                                  M.alloc (|
                                    M.write (|
                                      M.SubPointer.get_struct_record_field (|
                                        M.deref (|
                                          M.call_closure (|
                                            Ty.apply
                                              (Ty.path "&mut")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "alloc::collections::linked_list::Node")
                                                  []
                                                  [ T ]
                                              ],
                                            M.get_associated_function (|
                                              Ty.apply
                                                (Ty.path "core::ptr::non_null::NonNull")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path
                                                      "alloc::collections::linked_list::Node")
                                                    []
                                                    [ T ]
                                                ],
                                              "as_mut",
                                              [],
                                              []
                                            |),
                                            [ M.borrow (| Pointer.Kind.MutRef, tail |) ]
                                          |)
                                        |),
                                        "alloc::collections::linked_list::Node",
                                        "next"
                                      |),
                                      Value.StructTuple
                                        "core::option::Option::Some"
                                        [ M.read (| other_head |) ]
                                    |)
                                  |) in
                                let~ _ : Ty.tuple [] :=
                                  M.alloc (|
                                    M.write (|
                                      M.SubPointer.get_struct_record_field (|
                                        M.deref (|
                                          M.call_closure (|
                                            Ty.apply
                                              (Ty.path "&mut")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "alloc::collections::linked_list::Node")
                                                  []
                                                  [ T ]
                                              ],
                                            M.get_associated_function (|
                                              Ty.apply
                                                (Ty.path "core::ptr::non_null::NonNull")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path
                                                      "alloc::collections::linked_list::Node")
                                                    []
                                                    [ T ]
                                                ],
                                              "as_mut",
                                              [],
                                              []
                                            |),
                                            [ M.borrow (| Pointer.Kind.MutRef, other_head |) ]
                                          |)
                                        |),
                                        "alloc::collections::linked_list::Node",
                                        "prev"
                                      |),
                                      Value.StructTuple
                                        "core::option::Option::Some"
                                        [ M.read (| tail |) ]
                                    |)
                                  |) in
                                M.alloc (| Value.Tuple [] |) in
                              let~ _ : Ty.tuple [] :=
                                M.alloc (|
                                  M.write (|
                                    M.SubPointer.get_struct_record_field (|
                                      M.deref (| M.read (| self |) |),
                                      "alloc::collections::linked_list::LinkedList",
                                      "tail"
                                    |),
                                    M.call_closure (|
                                      Ty.apply
                                        (Ty.path "core::option::Option")
                                        []
                                        [
                                          Ty.apply
                                            (Ty.path "core::ptr::non_null::NonNull")
                                            []
                                            [
                                              Ty.apply
                                                (Ty.path "alloc::collections::linked_list::Node")
                                                []
                                                [ T ]
                                            ]
                                        ],
                                      M.get_associated_function (|
                                        Ty.apply
                                          (Ty.path "core::option::Option")
                                          []
                                          [
                                            Ty.apply
                                              (Ty.path "core::ptr::non_null::NonNull")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "alloc::collections::linked_list::Node")
                                                  []
                                                  [ T ]
                                              ]
                                          ],
                                        "take",
                                        [],
                                        []
                                      |),
                                      [
                                        M.borrow (|
                                          Pointer.Kind.MutRef,
                                          M.SubPointer.get_struct_record_field (|
                                            M.deref (| M.read (| other |) |),
                                            "alloc::collections::linked_list::LinkedList",
                                            "tail"
                                          |)
                                        |)
                                      ]
                                    |)
                                  |)
                                |) in
                              let~ _ : Ty.tuple [] :=
                                M.alloc (|
                                  let β :=
                                    M.SubPointer.get_struct_record_field (|
                                      M.deref (| M.read (| self |) |),
                                      "alloc::collections::linked_list::LinkedList",
                                      "len"
                                    |) in
                                  M.write (|
                                    β,
                                    M.call_closure (|
                                      Ty.path "usize",
                                      BinOp.Wrap.add,
                                      [
                                        M.read (| β |);
                                        M.call_closure (|
                                          Ty.path "usize",
                                          M.get_function (|
                                            "core::mem::replace",
                                            [],
                                            [ Ty.path "usize" ]
                                          |),
                                          [
                                            M.borrow (|
                                              Pointer.Kind.MutRef,
                                              M.deref (|
                                                M.borrow (|
                                                  Pointer.Kind.MutRef,
                                                  M.SubPointer.get_struct_record_field (|
                                                    M.deref (| M.read (| other |) |),
                                                    "alloc::collections::linked_list::LinkedList",
                                                    "len"
                                                  |)
                                                |)
                                              |)
                                            |);
                                            Value.Integer IntegerKind.Usize 0
                                          ]
                                        |)
                                      ]
                                    |)
                                  |)
                                |) in
                              M.alloc (| Value.Tuple [] |)));
                          fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                        ]
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_append :
        forall (T : Ty.t),
        M.IsAssociatedFunction.C (Self T) "append" (append T).
      Admitted.
      Global Typeclasses Opaque append.
    End Impl_alloc_collections_linked_list_LinkedList_T_alloc_alloc_Global.
    
    
    Module Impl_core_ops_drop_Drop_where_core_alloc_Allocator_A_for_alloc_collections_linked_list_LinkedList_T_A.
      Definition Self (T A : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "alloc::collections::linked_list::LinkedList") [] [ T; A ].
      
      (*
          fn drop(&mut self) {
              struct DropGuard<'a, T, A: Allocator>(&'a mut LinkedList<T, A>);
      
              impl<'a, T, A: Allocator> Drop for DropGuard<'a, T, A> {
                  fn drop(&mut self) {
                      // Continue the same loop we do below. This only runs when a destructor has
                      // panicked. If another one panics this will abort.
                      while self.0.pop_front_node().is_some() {}
                  }
              }
      
              // Wrap self so that if a destructor panics, we can try to keep looping
              let guard = DropGuard(self);
              while guard.0.pop_front_node().is_some() {}
              mem::forget(guard);
          }
      *)
      Definition drop (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              let~ guard :
                  Ty.apply
                    (Ty.path "alloc::collections::linked_list::drop::DropGuard")
                    []
                    [ T; A ] :=
                M.alloc (|
                  Value.StructTuple
                    "alloc::collections::linked_list::drop::DropGuard"
                    [ M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |) ]
                |) in
              let~ _ : Ty.tuple [] :=
                M.loop (|
                  Ty.tuple [],
                  ltac:(M.monadic
                    (M.match_operator (|
                      Some (Ty.tuple []),
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  M.call_closure (|
                                    Ty.path "bool",
                                    M.get_associated_function (|
                                      Ty.apply
                                        (Ty.path "core::option::Option")
                                        []
                                        [
                                          Ty.apply
                                            (Ty.path "alloc::boxed::Box")
                                            []
                                            [
                                              Ty.apply
                                                (Ty.path "alloc::collections::linked_list::Node")
                                                []
                                                [ T ];
                                              Ty.apply (Ty.path "&") [] [ A ]
                                            ]
                                        ],
                                      "is_some",
                                      [],
                                      []
                                    |),
                                    [
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.alloc (|
                                          M.call_closure (|
                                            Ty.apply
                                              (Ty.path "core::option::Option")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "alloc::boxed::Box")
                                                  []
                                                  [
                                                    Ty.apply
                                                      (Ty.path
                                                        "alloc::collections::linked_list::Node")
                                                      []
                                                      [ T ];
                                                    Ty.apply (Ty.path "&") [] [ A ]
                                                  ]
                                              ],
                                            M.get_associated_function (|
                                              Ty.apply
                                                (Ty.path
                                                  "alloc::collections::linked_list::LinkedList")
                                                []
                                                [ T; A ],
                                              "pop_front_node",
                                              [],
                                              []
                                            |),
                                            [
                                              M.borrow (|
                                                Pointer.Kind.MutRef,
                                                M.deref (|
                                                  M.read (|
                                                    M.SubPointer.get_struct_tuple_field (|
                                                      guard,
                                                      "alloc::collections::linked_list::drop::DropGuard",
                                                      0
                                                    |)
                                                  |)
                                                |)
                                              |)
                                            ]
                                          |)
                                        |)
                                      |)
                                    ]
                                  |)
                                |)) in
                            let _ :=
                              is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (| Value.Tuple [] |)));
                        fun γ =>
                          ltac:(M.monadic
                            (M.alloc (|
                              M.never_to_any (|
                                M.read (|
                                  let~ _ : Ty.tuple [] :=
                                    M.alloc (| M.never_to_any (| M.read (| M.break (||) |) |) |) in
                                  M.alloc (| Value.Tuple [] |)
                                |)
                              |)
                            |)))
                      ]
                    |)))
                |) in
              let~ _ : Ty.tuple [] :=
                M.alloc (|
                  M.call_closure (|
                    Ty.tuple [],
                    M.get_function (|
                      "core::mem::forget",
                      [],
                      [
                        Ty.apply
                          (Ty.path "alloc::collections::linked_list::drop::DropGuard")
                          []
                          [ T; A ]
                      ]
                    |),
                    [ M.read (| guard |) ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T A : Ty.t),
        M.IsTraitInstance
          "core::ops::drop::Drop"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T A)
          (* Instance *) [ ("drop", InstanceField.Method (drop T A)) ].
    End Impl_core_ops_drop_Drop_where_core_alloc_Allocator_A_for_alloc_collections_linked_list_LinkedList_T_A.
    
    Module Impl_core_iter_traits_iterator_Iterator_for_alloc_collections_linked_list_Iter_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "alloc::collections::linked_list::Iter") [] [ T ].
      
      (*     type Item = &'a T; *)
      Definition _Item (T : Ty.t) : Ty.t := Ty.apply (Ty.path "&") [] [ T ].
      
      (*
          fn next(&mut self) -> Option<&'a T> {
              if self.len == 0 {
                  None
              } else {
                  self.head.map(|node| unsafe {
                      // Need an unbound lifetime to get 'a
                      let node = &*node.as_ptr();
                      self.len -= 1;
                      self.head = node.next;
                      &node.element
                  })
              }
          }
      *)
      Definition next (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                Some
                  (Ty.apply
                    (Ty.path "core::option::Option")
                    []
                    [ Ty.apply (Ty.path "&") [] [ T ] ]),
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            M.call_closure (|
                              Ty.path "bool",
                              BinOp.eq,
                              [
                                M.read (|
                                  M.SubPointer.get_struct_record_field (|
                                    M.deref (| M.read (| self |) |),
                                    "alloc::collections::linked_list::Iter",
                                    "len"
                                  |)
                                |);
                                Value.Integer IntegerKind.Usize 0
                              ]
                            |)
                          |)) in
                      let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (|
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "core::option::Option")
                            []
                            [ Ty.apply (Ty.path "&") [] [ T ] ],
                          M.get_associated_function (|
                            Ty.apply
                              (Ty.path "core::option::Option")
                              []
                              [
                                Ty.apply
                                  (Ty.path "core::ptr::non_null::NonNull")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "alloc::collections::linked_list::Node")
                                      []
                                      [ T ]
                                  ]
                              ],
                            "map",
                            [],
                            [
                              Ty.apply (Ty.path "&") [] [ T ];
                              Ty.function
                                [
                                  Ty.tuple
                                    [
                                      Ty.apply
                                        (Ty.path "core::ptr::non_null::NonNull")
                                        []
                                        [
                                          Ty.apply
                                            (Ty.path "alloc::collections::linked_list::Node")
                                            []
                                            [ T ]
                                        ]
                                    ]
                                ]
                                (Ty.apply (Ty.path "&") [] [ T ])
                            ]
                          |),
                          [
                            M.read (|
                              M.SubPointer.get_struct_record_field (|
                                M.deref (| M.read (| self |) |),
                                "alloc::collections::linked_list::Iter",
                                "head"
                              |)
                            |);
                            M.closure
                              (fun γ =>
                                ltac:(M.monadic
                                  match γ with
                                  | [ α0 ] =>
                                    ltac:(M.monadic
                                      (M.match_operator (|
                                        Some
                                          (Ty.function
                                            [
                                              Ty.tuple
                                                [
                                                  Ty.apply
                                                    (Ty.path "core::ptr::non_null::NonNull")
                                                    []
                                                    [
                                                      Ty.apply
                                                        (Ty.path
                                                          "alloc::collections::linked_list::Node")
                                                        []
                                                        [ T ]
                                                    ]
                                                ]
                                            ]
                                            (Ty.apply (Ty.path "&") [] [ T ])),
                                        M.alloc (| α0 |),
                                        [
                                          fun γ =>
                                            ltac:(M.monadic
                                              (let node := M.copy (| γ |) in
                                              M.read (|
                                                let~ node :
                                                    Ty.apply
                                                      (Ty.path "&")
                                                      []
                                                      [
                                                        Ty.apply
                                                          (Ty.path
                                                            "alloc::collections::linked_list::Node")
                                                          []
                                                          [ T ]
                                                      ] :=
                                                  M.alloc (|
                                                    M.borrow (|
                                                      Pointer.Kind.Ref,
                                                      M.deref (|
                                                        M.call_closure (|
                                                          Ty.apply
                                                            (Ty.path "*mut")
                                                            []
                                                            [
                                                              Ty.apply
                                                                (Ty.path
                                                                  "alloc::collections::linked_list::Node")
                                                                []
                                                                [ T ]
                                                            ],
                                                          M.get_associated_function (|
                                                            Ty.apply
                                                              (Ty.path
                                                                "core::ptr::non_null::NonNull")
                                                              []
                                                              [
                                                                Ty.apply
                                                                  (Ty.path
                                                                    "alloc::collections::linked_list::Node")
                                                                  []
                                                                  [ T ]
                                                              ],
                                                            "as_ptr",
                                                            [],
                                                            []
                                                          |),
                                                          [ M.read (| node |) ]
                                                        |)
                                                      |)
                                                    |)
                                                  |) in
                                                let~ _ : Ty.tuple [] :=
                                                  M.alloc (|
                                                    let β :=
                                                      M.SubPointer.get_struct_record_field (|
                                                        M.deref (| M.read (| self |) |),
                                                        "alloc::collections::linked_list::Iter",
                                                        "len"
                                                      |) in
                                                    M.write (|
                                                      β,
                                                      M.call_closure (|
                                                        Ty.path "usize",
                                                        BinOp.Wrap.sub,
                                                        [
                                                          M.read (| β |);
                                                          Value.Integer IntegerKind.Usize 1
                                                        ]
                                                      |)
                                                    |)
                                                  |) in
                                                let~ _ : Ty.tuple [] :=
                                                  M.alloc (|
                                                    M.write (|
                                                      M.SubPointer.get_struct_record_field (|
                                                        M.deref (| M.read (| self |) |),
                                                        "alloc::collections::linked_list::Iter",
                                                        "head"
                                                      |),
                                                      M.read (|
                                                        M.SubPointer.get_struct_record_field (|
                                                          M.deref (| M.read (| node |) |),
                                                          "alloc::collections::linked_list::Node",
                                                          "next"
                                                        |)
                                                      |)
                                                    |)
                                                  |) in
                                                M.alloc (|
                                                  M.borrow (|
                                                    Pointer.Kind.Ref,
                                                    M.SubPointer.get_struct_record_field (|
                                                      M.deref (| M.read (| node |) |),
                                                      "alloc::collections::linked_list::Node",
                                                      "element"
                                                    |)
                                                  |)
                                                |)
                                              |)))
                                        ]
                                      |)))
                                  | _ => M.impossible "wrong number of arguments"
                                  end))
                          ]
                        |)
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn size_hint(&self) -> (usize, Option<usize>) {
              (self.len, Some(self.len))
          }
      *)
      Definition size_hint (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.Tuple
              [
                M.read (|
                  M.SubPointer.get_struct_record_field (|
                    M.deref (| M.read (| self |) |),
                    "alloc::collections::linked_list::Iter",
                    "len"
                  |)
                |);
                Value.StructTuple
                  "core::option::Option::Some"
                  [
                    M.read (|
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "alloc::collections::linked_list::Iter",
                        "len"
                      |)
                    |)
                  ]
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn last(mut self) -> Option<&'a T> {
              self.next_back()
          }
      *)
      Definition last (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.apply (Ty.path "core::option::Option") [] [ Ty.apply (Ty.path "&") [] [ T ] ],
              M.get_trait_method (|
                "core::iter::traits::double_ended::DoubleEndedIterator",
                Ty.apply (Ty.path "alloc::collections::linked_list::Iter") [] [ T ],
                [],
                [],
                "next_back",
                [],
                []
              |),
              [ M.borrow (| Pointer.Kind.MutRef, self |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::iterator::Iterator"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T)
          (* Instance *)
          [
            ("Item", InstanceField.Ty (_Item T));
            ("next", InstanceField.Method (next T));
            ("size_hint", InstanceField.Method (size_hint T));
            ("last", InstanceField.Method (last T))
          ].
    End Impl_core_iter_traits_iterator_Iterator_for_alloc_collections_linked_list_Iter_T.
    
    Module Impl_core_iter_traits_double_ended_DoubleEndedIterator_for_alloc_collections_linked_list_Iter_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "alloc::collections::linked_list::Iter") [] [ T ].
      
      (*
          fn next_back(&mut self) -> Option<&'a T> {
              if self.len == 0 {
                  None
              } else {
                  self.tail.map(|node| unsafe {
                      // Need an unbound lifetime to get 'a
                      let node = &*node.as_ptr();
                      self.len -= 1;
                      self.tail = node.prev;
                      &node.element
                  })
              }
          }
      *)
      Definition next_back (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                Some
                  (Ty.apply
                    (Ty.path "core::option::Option")
                    []
                    [ Ty.apply (Ty.path "&") [] [ T ] ]),
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            M.call_closure (|
                              Ty.path "bool",
                              BinOp.eq,
                              [
                                M.read (|
                                  M.SubPointer.get_struct_record_field (|
                                    M.deref (| M.read (| self |) |),
                                    "alloc::collections::linked_list::Iter",
                                    "len"
                                  |)
                                |);
                                Value.Integer IntegerKind.Usize 0
                              ]
                            |)
                          |)) in
                      let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (|
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "core::option::Option")
                            []
                            [ Ty.apply (Ty.path "&") [] [ T ] ],
                          M.get_associated_function (|
                            Ty.apply
                              (Ty.path "core::option::Option")
                              []
                              [
                                Ty.apply
                                  (Ty.path "core::ptr::non_null::NonNull")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "alloc::collections::linked_list::Node")
                                      []
                                      [ T ]
                                  ]
                              ],
                            "map",
                            [],
                            [
                              Ty.apply (Ty.path "&") [] [ T ];
                              Ty.function
                                [
                                  Ty.tuple
                                    [
                                      Ty.apply
                                        (Ty.path "core::ptr::non_null::NonNull")
                                        []
                                        [
                                          Ty.apply
                                            (Ty.path "alloc::collections::linked_list::Node")
                                            []
                                            [ T ]
                                        ]
                                    ]
                                ]
                                (Ty.apply (Ty.path "&") [] [ T ])
                            ]
                          |),
                          [
                            M.read (|
                              M.SubPointer.get_struct_record_field (|
                                M.deref (| M.read (| self |) |),
                                "alloc::collections::linked_list::Iter",
                                "tail"
                              |)
                            |);
                            M.closure
                              (fun γ =>
                                ltac:(M.monadic
                                  match γ with
                                  | [ α0 ] =>
                                    ltac:(M.monadic
                                      (M.match_operator (|
                                        Some
                                          (Ty.function
                                            [
                                              Ty.tuple
                                                [
                                                  Ty.apply
                                                    (Ty.path "core::ptr::non_null::NonNull")
                                                    []
                                                    [
                                                      Ty.apply
                                                        (Ty.path
                                                          "alloc::collections::linked_list::Node")
                                                        []
                                                        [ T ]
                                                    ]
                                                ]
                                            ]
                                            (Ty.apply (Ty.path "&") [] [ T ])),
                                        M.alloc (| α0 |),
                                        [
                                          fun γ =>
                                            ltac:(M.monadic
                                              (let node := M.copy (| γ |) in
                                              M.read (|
                                                let~ node :
                                                    Ty.apply
                                                      (Ty.path "&")
                                                      []
                                                      [
                                                        Ty.apply
                                                          (Ty.path
                                                            "alloc::collections::linked_list::Node")
                                                          []
                                                          [ T ]
                                                      ] :=
                                                  M.alloc (|
                                                    M.borrow (|
                                                      Pointer.Kind.Ref,
                                                      M.deref (|
                                                        M.call_closure (|
                                                          Ty.apply
                                                            (Ty.path "*mut")
                                                            []
                                                            [
                                                              Ty.apply
                                                                (Ty.path
                                                                  "alloc::collections::linked_list::Node")
                                                                []
                                                                [ T ]
                                                            ],
                                                          M.get_associated_function (|
                                                            Ty.apply
                                                              (Ty.path
                                                                "core::ptr::non_null::NonNull")
                                                              []
                                                              [
                                                                Ty.apply
                                                                  (Ty.path
                                                                    "alloc::collections::linked_list::Node")
                                                                  []
                                                                  [ T ]
                                                              ],
                                                            "as_ptr",
                                                            [],
                                                            []
                                                          |),
                                                          [ M.read (| node |) ]
                                                        |)
                                                      |)
                                                    |)
                                                  |) in
                                                let~ _ : Ty.tuple [] :=
                                                  M.alloc (|
                                                    let β :=
                                                      M.SubPointer.get_struct_record_field (|
                                                        M.deref (| M.read (| self |) |),
                                                        "alloc::collections::linked_list::Iter",
                                                        "len"
                                                      |) in
                                                    M.write (|
                                                      β,
                                                      M.call_closure (|
                                                        Ty.path "usize",
                                                        BinOp.Wrap.sub,
                                                        [
                                                          M.read (| β |);
                                                          Value.Integer IntegerKind.Usize 1
                                                        ]
                                                      |)
                                                    |)
                                                  |) in
                                                let~ _ : Ty.tuple [] :=
                                                  M.alloc (|
                                                    M.write (|
                                                      M.SubPointer.get_struct_record_field (|
                                                        M.deref (| M.read (| self |) |),
                                                        "alloc::collections::linked_list::Iter",
                                                        "tail"
                                                      |),
                                                      M.read (|
                                                        M.SubPointer.get_struct_record_field (|
                                                          M.deref (| M.read (| node |) |),
                                                          "alloc::collections::linked_list::Node",
                                                          "prev"
                                                        |)
                                                      |)
                                                    |)
                                                  |) in
                                                M.alloc (|
                                                  M.borrow (|
                                                    Pointer.Kind.Ref,
                                                    M.SubPointer.get_struct_record_field (|
                                                      M.deref (| M.read (| node |) |),
                                                      "alloc::collections::linked_list::Node",
                                                      "element"
                                                    |)
                                                  |)
                                                |)
                                              |)))
                                        ]
                                      |)))
                                  | _ => M.impossible "wrong number of arguments"
                                  end))
                          ]
                        |)
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::double_ended::DoubleEndedIterator"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T)
          (* Instance *) [ ("next_back", InstanceField.Method (next_back T)) ].
    End Impl_core_iter_traits_double_ended_DoubleEndedIterator_for_alloc_collections_linked_list_Iter_T.
    
    Module Impl_core_iter_traits_exact_size_ExactSizeIterator_for_alloc_collections_linked_list_Iter_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "alloc::collections::linked_list::Iter") [] [ T ].
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::exact_size::ExactSizeIterator"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T)
          (* Instance *) [].
    End Impl_core_iter_traits_exact_size_ExactSizeIterator_for_alloc_collections_linked_list_Iter_T.
    
    Module Impl_core_iter_traits_marker_FusedIterator_for_alloc_collections_linked_list_Iter_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "alloc::collections::linked_list::Iter") [] [ T ].
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::marker::FusedIterator"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T)
          (* Instance *) [].
    End Impl_core_iter_traits_marker_FusedIterator_for_alloc_collections_linked_list_Iter_T.
    
    Module Impl_core_default_Default_for_alloc_collections_linked_list_Iter_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "alloc::collections::linked_list::Iter") [] [ T ].
      
      (*
          fn default() -> Self {
              Iter { head: None, tail: None, len: 0, marker: Default::default() }
          }
      *)
      Definition default (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [] =>
          ltac:(M.monadic
            (Value.StructRecord
              "alloc::collections::linked_list::Iter"
              [
                ("head", Value.StructTuple "core::option::Option::None" []);
                ("tail", Value.StructTuple "core::option::Option::None" []);
                ("len", Value.Integer IntegerKind.Usize 0);
                ("marker",
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "core::marker::PhantomData")
                      []
                      [
                        Ty.apply
                          (Ty.path "&")
                          []
                          [ Ty.apply (Ty.path "alloc::collections::linked_list::Node") [] [ T ] ]
                      ],
                    M.get_trait_method (|
                      "core::default::Default",
                      Ty.apply
                        (Ty.path "core::marker::PhantomData")
                        []
                        [
                          Ty.apply
                            (Ty.path "&")
                            []
                            [ Ty.apply (Ty.path "alloc::collections::linked_list::Node") [] [ T ] ]
                        ],
                      [],
                      [],
                      "default",
                      [],
                      []
                    |),
                    []
                  |))
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::default::Default"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T)
          (* Instance *) [ ("default", InstanceField.Method (default T)) ].
    End Impl_core_default_Default_for_alloc_collections_linked_list_Iter_T.
    
    Module Impl_core_iter_traits_iterator_Iterator_for_alloc_collections_linked_list_IterMut_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "alloc::collections::linked_list::IterMut") [] [ T ].
      
      (*     type Item = &'a mut T; *)
      Definition _Item (T : Ty.t) : Ty.t := Ty.apply (Ty.path "&mut") [] [ T ].
      
      (*
          fn next(&mut self) -> Option<&'a mut T> {
              if self.len == 0 {
                  None
              } else {
                  self.head.map(|node| unsafe {
                      // Need an unbound lifetime to get 'a
                      let node = &mut *node.as_ptr();
                      self.len -= 1;
                      self.head = node.next;
                      &mut node.element
                  })
              }
          }
      *)
      Definition next (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                Some
                  (Ty.apply
                    (Ty.path "core::option::Option")
                    []
                    [ Ty.apply (Ty.path "&mut") [] [ T ] ]),
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            M.call_closure (|
                              Ty.path "bool",
                              BinOp.eq,
                              [
                                M.read (|
                                  M.SubPointer.get_struct_record_field (|
                                    M.deref (| M.read (| self |) |),
                                    "alloc::collections::linked_list::IterMut",
                                    "len"
                                  |)
                                |);
                                Value.Integer IntegerKind.Usize 0
                              ]
                            |)
                          |)) in
                      let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (|
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "core::option::Option")
                            []
                            [ Ty.apply (Ty.path "&mut") [] [ T ] ],
                          M.get_associated_function (|
                            Ty.apply
                              (Ty.path "core::option::Option")
                              []
                              [
                                Ty.apply
                                  (Ty.path "core::ptr::non_null::NonNull")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "alloc::collections::linked_list::Node")
                                      []
                                      [ T ]
                                  ]
                              ],
                            "map",
                            [],
                            [
                              Ty.apply (Ty.path "&mut") [] [ T ];
                              Ty.function
                                [
                                  Ty.tuple
                                    [
                                      Ty.apply
                                        (Ty.path "core::ptr::non_null::NonNull")
                                        []
                                        [
                                          Ty.apply
                                            (Ty.path "alloc::collections::linked_list::Node")
                                            []
                                            [ T ]
                                        ]
                                    ]
                                ]
                                (Ty.apply (Ty.path "&mut") [] [ T ])
                            ]
                          |),
                          [
                            M.read (|
                              M.SubPointer.get_struct_record_field (|
                                M.deref (| M.read (| self |) |),
                                "alloc::collections::linked_list::IterMut",
                                "head"
                              |)
                            |);
                            M.closure
                              (fun γ =>
                                ltac:(M.monadic
                                  match γ with
                                  | [ α0 ] =>
                                    ltac:(M.monadic
                                      (M.match_operator (|
                                        Some
                                          (Ty.function
                                            [
                                              Ty.tuple
                                                [
                                                  Ty.apply
                                                    (Ty.path "core::ptr::non_null::NonNull")
                                                    []
                                                    [
                                                      Ty.apply
                                                        (Ty.path
                                                          "alloc::collections::linked_list::Node")
                                                        []
                                                        [ T ]
                                                    ]
                                                ]
                                            ]
                                            (Ty.apply (Ty.path "&mut") [] [ T ])),
                                        M.alloc (| α0 |),
                                        [
                                          fun γ =>
                                            ltac:(M.monadic
                                              (let node := M.copy (| γ |) in
                                              M.borrow (|
                                                Pointer.Kind.MutRef,
                                                M.deref (|
                                                  M.read (|
                                                    let~ node :
                                                        Ty.apply
                                                          (Ty.path "&mut")
                                                          []
                                                          [
                                                            Ty.apply
                                                              (Ty.path
                                                                "alloc::collections::linked_list::Node")
                                                              []
                                                              [ T ]
                                                          ] :=
                                                      M.alloc (|
                                                        M.borrow (|
                                                          Pointer.Kind.MutRef,
                                                          M.deref (|
                                                            M.call_closure (|
                                                              Ty.apply
                                                                (Ty.path "*mut")
                                                                []
                                                                [
                                                                  Ty.apply
                                                                    (Ty.path
                                                                      "alloc::collections::linked_list::Node")
                                                                    []
                                                                    [ T ]
                                                                ],
                                                              M.get_associated_function (|
                                                                Ty.apply
                                                                  (Ty.path
                                                                    "core::ptr::non_null::NonNull")
                                                                  []
                                                                  [
                                                                    Ty.apply
                                                                      (Ty.path
                                                                        "alloc::collections::linked_list::Node")
                                                                      []
                                                                      [ T ]
                                                                  ],
                                                                "as_ptr",
                                                                [],
                                                                []
                                                              |),
                                                              [ M.read (| node |) ]
                                                            |)
                                                          |)
                                                        |)
                                                      |) in
                                                    let~ _ : Ty.tuple [] :=
                                                      M.alloc (|
                                                        let β :=
                                                          M.SubPointer.get_struct_record_field (|
                                                            M.deref (| M.read (| self |) |),
                                                            "alloc::collections::linked_list::IterMut",
                                                            "len"
                                                          |) in
                                                        M.write (|
                                                          β,
                                                          M.call_closure (|
                                                            Ty.path "usize",
                                                            BinOp.Wrap.sub,
                                                            [
                                                              M.read (| β |);
                                                              Value.Integer IntegerKind.Usize 1
                                                            ]
                                                          |)
                                                        |)
                                                      |) in
                                                    let~ _ : Ty.tuple [] :=
                                                      M.alloc (|
                                                        M.write (|
                                                          M.SubPointer.get_struct_record_field (|
                                                            M.deref (| M.read (| self |) |),
                                                            "alloc::collections::linked_list::IterMut",
                                                            "head"
                                                          |),
                                                          M.read (|
                                                            M.SubPointer.get_struct_record_field (|
                                                              M.deref (| M.read (| node |) |),
                                                              "alloc::collections::linked_list::Node",
                                                              "next"
                                                            |)
                                                          |)
                                                        |)
                                                      |) in
                                                    M.alloc (|
                                                      M.borrow (|
                                                        Pointer.Kind.MutRef,
                                                        M.SubPointer.get_struct_record_field (|
                                                          M.deref (| M.read (| node |) |),
                                                          "alloc::collections::linked_list::Node",
                                                          "element"
                                                        |)
                                                      |)
                                                    |)
                                                  |)
                                                |)
                                              |)))
                                        ]
                                      |)))
                                  | _ => M.impossible "wrong number of arguments"
                                  end))
                          ]
                        |)
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn size_hint(&self) -> (usize, Option<usize>) {
              (self.len, Some(self.len))
          }
      *)
      Definition size_hint (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.Tuple
              [
                M.read (|
                  M.SubPointer.get_struct_record_field (|
                    M.deref (| M.read (| self |) |),
                    "alloc::collections::linked_list::IterMut",
                    "len"
                  |)
                |);
                Value.StructTuple
                  "core::option::Option::Some"
                  [
                    M.read (|
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "alloc::collections::linked_list::IterMut",
                        "len"
                      |)
                    |)
                  ]
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn last(mut self) -> Option<&'a mut T> {
              self.next_back()
          }
      *)
      Definition last (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.apply (Ty.path "core::option::Option") [] [ Ty.apply (Ty.path "&mut") [] [ T ] ],
              M.get_trait_method (|
                "core::iter::traits::double_ended::DoubleEndedIterator",
                Ty.apply (Ty.path "alloc::collections::linked_list::IterMut") [] [ T ],
                [],
                [],
                "next_back",
                [],
                []
              |),
              [ M.borrow (| Pointer.Kind.MutRef, self |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::iterator::Iterator"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T)
          (* Instance *)
          [
            ("Item", InstanceField.Ty (_Item T));
            ("next", InstanceField.Method (next T));
            ("size_hint", InstanceField.Method (size_hint T));
            ("last", InstanceField.Method (last T))
          ].
    End Impl_core_iter_traits_iterator_Iterator_for_alloc_collections_linked_list_IterMut_T.
    
    Module Impl_core_iter_traits_double_ended_DoubleEndedIterator_for_alloc_collections_linked_list_IterMut_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "alloc::collections::linked_list::IterMut") [] [ T ].
      
      (*
          fn next_back(&mut self) -> Option<&'a mut T> {
              if self.len == 0 {
                  None
              } else {
                  self.tail.map(|node| unsafe {
                      // Need an unbound lifetime to get 'a
                      let node = &mut *node.as_ptr();
                      self.len -= 1;
                      self.tail = node.prev;
                      &mut node.element
                  })
              }
          }
      *)
      Definition next_back (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                Some
                  (Ty.apply
                    (Ty.path "core::option::Option")
                    []
                    [ Ty.apply (Ty.path "&mut") [] [ T ] ]),
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            M.call_closure (|
                              Ty.path "bool",
                              BinOp.eq,
                              [
                                M.read (|
                                  M.SubPointer.get_struct_record_field (|
                                    M.deref (| M.read (| self |) |),
                                    "alloc::collections::linked_list::IterMut",
                                    "len"
                                  |)
                                |);
                                Value.Integer IntegerKind.Usize 0
                              ]
                            |)
                          |)) in
                      let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (|
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "core::option::Option")
                            []
                            [ Ty.apply (Ty.path "&mut") [] [ T ] ],
                          M.get_associated_function (|
                            Ty.apply
                              (Ty.path "core::option::Option")
                              []
                              [
                                Ty.apply
                                  (Ty.path "core::ptr::non_null::NonNull")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "alloc::collections::linked_list::Node")
                                      []
                                      [ T ]
                                  ]
                              ],
                            "map",
                            [],
                            [
                              Ty.apply (Ty.path "&mut") [] [ T ];
                              Ty.function
                                [
                                  Ty.tuple
                                    [
                                      Ty.apply
                                        (Ty.path "core::ptr::non_null::NonNull")
                                        []
                                        [
                                          Ty.apply
                                            (Ty.path "alloc::collections::linked_list::Node")
                                            []
                                            [ T ]
                                        ]
                                    ]
                                ]
                                (Ty.apply (Ty.path "&mut") [] [ T ])
                            ]
                          |),
                          [
                            M.read (|
                              M.SubPointer.get_struct_record_field (|
                                M.deref (| M.read (| self |) |),
                                "alloc::collections::linked_list::IterMut",
                                "tail"
                              |)
                            |);
                            M.closure
                              (fun γ =>
                                ltac:(M.monadic
                                  match γ with
                                  | [ α0 ] =>
                                    ltac:(M.monadic
                                      (M.match_operator (|
                                        Some
                                          (Ty.function
                                            [
                                              Ty.tuple
                                                [
                                                  Ty.apply
                                                    (Ty.path "core::ptr::non_null::NonNull")
                                                    []
                                                    [
                                                      Ty.apply
                                                        (Ty.path
                                                          "alloc::collections::linked_list::Node")
                                                        []
                                                        [ T ]
                                                    ]
                                                ]
                                            ]
                                            (Ty.apply (Ty.path "&mut") [] [ T ])),
                                        M.alloc (| α0 |),
                                        [
                                          fun γ =>
                                            ltac:(M.monadic
                                              (let node := M.copy (| γ |) in
                                              M.borrow (|
                                                Pointer.Kind.MutRef,
                                                M.deref (|
                                                  M.read (|
                                                    let~ node :
                                                        Ty.apply
                                                          (Ty.path "&mut")
                                                          []
                                                          [
                                                            Ty.apply
                                                              (Ty.path
                                                                "alloc::collections::linked_list::Node")
                                                              []
                                                              [ T ]
                                                          ] :=
                                                      M.alloc (|
                                                        M.borrow (|
                                                          Pointer.Kind.MutRef,
                                                          M.deref (|
                                                            M.call_closure (|
                                                              Ty.apply
                                                                (Ty.path "*mut")
                                                                []
                                                                [
                                                                  Ty.apply
                                                                    (Ty.path
                                                                      "alloc::collections::linked_list::Node")
                                                                    []
                                                                    [ T ]
                                                                ],
                                                              M.get_associated_function (|
                                                                Ty.apply
                                                                  (Ty.path
                                                                    "core::ptr::non_null::NonNull")
                                                                  []
                                                                  [
                                                                    Ty.apply
                                                                      (Ty.path
                                                                        "alloc::collections::linked_list::Node")
                                                                      []
                                                                      [ T ]
                                                                  ],
                                                                "as_ptr",
                                                                [],
                                                                []
                                                              |),
                                                              [ M.read (| node |) ]
                                                            |)
                                                          |)
                                                        |)
                                                      |) in
                                                    let~ _ : Ty.tuple [] :=
                                                      M.alloc (|
                                                        let β :=
                                                          M.SubPointer.get_struct_record_field (|
                                                            M.deref (| M.read (| self |) |),
                                                            "alloc::collections::linked_list::IterMut",
                                                            "len"
                                                          |) in
                                                        M.write (|
                                                          β,
                                                          M.call_closure (|
                                                            Ty.path "usize",
                                                            BinOp.Wrap.sub,
                                                            [
                                                              M.read (| β |);
                                                              Value.Integer IntegerKind.Usize 1
                                                            ]
                                                          |)
                                                        |)
                                                      |) in
                                                    let~ _ : Ty.tuple [] :=
                                                      M.alloc (|
                                                        M.write (|
                                                          M.SubPointer.get_struct_record_field (|
                                                            M.deref (| M.read (| self |) |),
                                                            "alloc::collections::linked_list::IterMut",
                                                            "tail"
                                                          |),
                                                          M.read (|
                                                            M.SubPointer.get_struct_record_field (|
                                                              M.deref (| M.read (| node |) |),
                                                              "alloc::collections::linked_list::Node",
                                                              "prev"
                                                            |)
                                                          |)
                                                        |)
                                                      |) in
                                                    M.alloc (|
                                                      M.borrow (|
                                                        Pointer.Kind.MutRef,
                                                        M.SubPointer.get_struct_record_field (|
                                                          M.deref (| M.read (| node |) |),
                                                          "alloc::collections::linked_list::Node",
                                                          "element"
                                                        |)
                                                      |)
                                                    |)
                                                  |)
                                                |)
                                              |)))
                                        ]
                                      |)))
                                  | _ => M.impossible "wrong number of arguments"
                                  end))
                          ]
                        |)
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::double_ended::DoubleEndedIterator"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T)
          (* Instance *) [ ("next_back", InstanceField.Method (next_back T)) ].
    End Impl_core_iter_traits_double_ended_DoubleEndedIterator_for_alloc_collections_linked_list_IterMut_T.
    
    Module Impl_core_iter_traits_exact_size_ExactSizeIterator_for_alloc_collections_linked_list_IterMut_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "alloc::collections::linked_list::IterMut") [] [ T ].
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::exact_size::ExactSizeIterator"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T)
          (* Instance *) [].
    End Impl_core_iter_traits_exact_size_ExactSizeIterator_for_alloc_collections_linked_list_IterMut_T.
    
    Module Impl_core_iter_traits_marker_FusedIterator_for_alloc_collections_linked_list_IterMut_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "alloc::collections::linked_list::IterMut") [] [ T ].
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::marker::FusedIterator"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T)
          (* Instance *) [].
    End Impl_core_iter_traits_marker_FusedIterator_for_alloc_collections_linked_list_IterMut_T.
    
    Module Impl_core_default_Default_for_alloc_collections_linked_list_IterMut_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "alloc::collections::linked_list::IterMut") [] [ T ].
      
      (*
          fn default() -> Self {
              IterMut { head: None, tail: None, len: 0, marker: Default::default() }
          }
      *)
      Definition default (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [] =>
          ltac:(M.monadic
            (Value.StructRecord
              "alloc::collections::linked_list::IterMut"
              [
                ("head", Value.StructTuple "core::option::Option::None" []);
                ("tail", Value.StructTuple "core::option::Option::None" []);
                ("len", Value.Integer IntegerKind.Usize 0);
                ("marker",
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "core::marker::PhantomData")
                      []
                      [
                        Ty.apply
                          (Ty.path "&mut")
                          []
                          [ Ty.apply (Ty.path "alloc::collections::linked_list::Node") [] [ T ] ]
                      ],
                    M.get_trait_method (|
                      "core::default::Default",
                      Ty.apply
                        (Ty.path "core::marker::PhantomData")
                        []
                        [
                          Ty.apply
                            (Ty.path "&mut")
                            []
                            [ Ty.apply (Ty.path "alloc::collections::linked_list::Node") [] [ T ] ]
                        ],
                      [],
                      [],
                      "default",
                      [],
                      []
                    |),
                    []
                  |))
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::default::Default"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T)
          (* Instance *) [ ("default", InstanceField.Method (default T)) ].
    End Impl_core_default_Default_for_alloc_collections_linked_list_IterMut_T.
    
    (* StructRecord
      {
        name := "Cursor";
        const_params := [];
        ty_params := [ "T"; "A" ];
        fields :=
          [
            ("index", Ty.path "usize");
            ("current",
              Ty.apply
                (Ty.path "core::option::Option")
                []
                [
                  Ty.apply
                    (Ty.path "core::ptr::non_null::NonNull")
                    []
                    [ Ty.apply (Ty.path "alloc::collections::linked_list::Node") [] [ T ] ]
                ]);
            ("list",
              Ty.apply
                (Ty.path "&")
                []
                [ Ty.apply (Ty.path "alloc::collections::linked_list::LinkedList") [] [ T; A ] ])
          ];
      } *)
    
    Module Impl_core_clone_Clone_where_core_alloc_Allocator_A_for_alloc_collections_linked_list_Cursor_T_A.
      Definition Self (T A : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "alloc::collections::linked_list::Cursor") [] [ T; A ].
      
      (*
          fn clone(&self) -> Self {
              let Cursor { index, current, list } = *self;
              Cursor { index, current, list }
          }
      *)
      Definition clone (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                None,
                M.deref (| M.read (| self |) |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 :=
                        M.SubPointer.get_struct_record_field (|
                          γ,
                          "alloc::collections::linked_list::Cursor",
                          "index"
                        |) in
                      let γ0_1 :=
                        M.SubPointer.get_struct_record_field (|
                          γ,
                          "alloc::collections::linked_list::Cursor",
                          "current"
                        |) in
                      let γ0_2 :=
                        M.SubPointer.get_struct_record_field (|
                          γ,
                          "alloc::collections::linked_list::Cursor",
                          "list"
                        |) in
                      let index := M.copy (| γ0_0 |) in
                      let current := M.copy (| γ0_1 |) in
                      let list := M.copy (| γ0_2 |) in
                      M.alloc (|
                        Value.StructRecord
                          "alloc::collections::linked_list::Cursor"
                          [
                            ("index", M.read (| index |));
                            ("current", M.read (| current |));
                            ("list",
                              M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| list |) |) |))
                          ]
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T A : Ty.t),
        M.IsTraitInstance
          "core::clone::Clone"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T A)
          (* Instance *) [ ("clone", InstanceField.Method (clone T A)) ].
    End Impl_core_clone_Clone_where_core_alloc_Allocator_A_for_alloc_collections_linked_list_Cursor_T_A.
    
    Module Impl_core_fmt_Debug_where_core_fmt_Debug_T_where_core_alloc_Allocator_A_for_alloc_collections_linked_list_Cursor_T_A.
      Definition Self (T A : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "alloc::collections::linked_list::Cursor") [] [ T; A ].
      
      (*
          fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
              f.debug_tuple("Cursor").field(&self.list).field(&self.index()).finish()
          }
      *)
      Definition fmt (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match ε, τ, α with
        | [], [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "core::result::Result")
                []
                [ Ty.tuple []; Ty.path "core::fmt::Error" ],
              M.get_associated_function (|
                Ty.path "core::fmt::builders::DebugTuple",
                "finish",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.deref (|
                    M.call_closure (|
                      Ty.apply (Ty.path "&mut") [] [ Ty.path "core::fmt::builders::DebugTuple" ],
                      M.get_associated_function (|
                        Ty.path "core::fmt::builders::DebugTuple",
                        "field",
                        [],
                        []
                      |),
                      [
                        M.borrow (|
                          Pointer.Kind.MutRef,
                          M.deref (|
                            M.call_closure (|
                              Ty.apply
                                (Ty.path "&mut")
                                []
                                [ Ty.path "core::fmt::builders::DebugTuple" ],
                              M.get_associated_function (|
                                Ty.path "core::fmt::builders::DebugTuple",
                                "field",
                                [],
                                []
                              |),
                              [
                                M.borrow (|
                                  Pointer.Kind.MutRef,
                                  M.alloc (|
                                    M.call_closure (|
                                      Ty.path "core::fmt::builders::DebugTuple",
                                      M.get_associated_function (|
                                        Ty.path "core::fmt::Formatter",
                                        "debug_tuple",
                                        [],
                                        []
                                      |),
                                      [
                                        M.borrow (|
                                          Pointer.Kind.MutRef,
                                          M.deref (| M.read (| f |) |)
                                        |);
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.deref (| mk_str (| "Cursor" |) |)
                                        |)
                                      ]
                                    |)
                                  |)
                                |);
                                (* Unsize *)
                                M.pointer_coercion
                                  (M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (|
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.SubPointer.get_struct_record_field (|
                                          M.deref (| M.read (| self |) |),
                                          "alloc::collections::linked_list::Cursor",
                                          "list"
                                        |)
                                      |)
                                    |)
                                  |))
                              ]
                            |)
                          |)
                        |);
                        (* Unsize *)
                        M.pointer_coercion
                          (M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (|
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.alloc (|
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "core::option::Option")
                                      []
                                      [ Ty.path "usize" ],
                                    M.get_associated_function (|
                                      Ty.apply
                                        (Ty.path "alloc::collections::linked_list::Cursor")
                                        []
                                        [ T; A ],
                                      "index",
                                      [],
                                      []
                                    |),
                                    [
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.deref (| M.read (| self |) |)
                                      |)
                                    ]
                                  |)
                                |)
                              |)
                            |)
                          |))
                      ]
                    |)
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T A : Ty.t),
        M.IsTraitInstance
          "core::fmt::Debug"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T A)
          (* Instance *) [ ("fmt", InstanceField.Method (fmt T A)) ].
    End Impl_core_fmt_Debug_where_core_fmt_Debug_T_where_core_alloc_Allocator_A_for_alloc_collections_linked_list_Cursor_T_A.
    
    (* StructRecord
      {
        name := "CursorMut";
        const_params := [];
        ty_params := [ "T"; "A" ];
        fields :=
          [
            ("index", Ty.path "usize");
            ("current",
              Ty.apply
                (Ty.path "core::option::Option")
                []
                [
                  Ty.apply
                    (Ty.path "core::ptr::non_null::NonNull")
                    []
                    [ Ty.apply (Ty.path "alloc::collections::linked_list::Node") [] [ T ] ]
                ]);
            ("list",
              Ty.apply
                (Ty.path "&mut")
                []
                [ Ty.apply (Ty.path "alloc::collections::linked_list::LinkedList") [] [ T; A ] ])
          ];
      } *)
    
    Module Impl_core_fmt_Debug_where_core_fmt_Debug_T_where_core_alloc_Allocator_A_for_alloc_collections_linked_list_CursorMut_T_A.
      Definition Self (T A : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "alloc::collections::linked_list::CursorMut") [] [ T; A ].
      
      (*
          fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
              f.debug_tuple("CursorMut").field(&self.list).field(&self.index()).finish()
          }
      *)
      Definition fmt (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match ε, τ, α with
        | [], [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "core::result::Result")
                []
                [ Ty.tuple []; Ty.path "core::fmt::Error" ],
              M.get_associated_function (|
                Ty.path "core::fmt::builders::DebugTuple",
                "finish",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.deref (|
                    M.call_closure (|
                      Ty.apply (Ty.path "&mut") [] [ Ty.path "core::fmt::builders::DebugTuple" ],
                      M.get_associated_function (|
                        Ty.path "core::fmt::builders::DebugTuple",
                        "field",
                        [],
                        []
                      |),
                      [
                        M.borrow (|
                          Pointer.Kind.MutRef,
                          M.deref (|
                            M.call_closure (|
                              Ty.apply
                                (Ty.path "&mut")
                                []
                                [ Ty.path "core::fmt::builders::DebugTuple" ],
                              M.get_associated_function (|
                                Ty.path "core::fmt::builders::DebugTuple",
                                "field",
                                [],
                                []
                              |),
                              [
                                M.borrow (|
                                  Pointer.Kind.MutRef,
                                  M.alloc (|
                                    M.call_closure (|
                                      Ty.path "core::fmt::builders::DebugTuple",
                                      M.get_associated_function (|
                                        Ty.path "core::fmt::Formatter",
                                        "debug_tuple",
                                        [],
                                        []
                                      |),
                                      [
                                        M.borrow (|
                                          Pointer.Kind.MutRef,
                                          M.deref (| M.read (| f |) |)
                                        |);
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.deref (| mk_str (| "CursorMut" |) |)
                                        |)
                                      ]
                                    |)
                                  |)
                                |);
                                (* Unsize *)
                                M.pointer_coercion
                                  (M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (|
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.SubPointer.get_struct_record_field (|
                                          M.deref (| M.read (| self |) |),
                                          "alloc::collections::linked_list::CursorMut",
                                          "list"
                                        |)
                                      |)
                                    |)
                                  |))
                              ]
                            |)
                          |)
                        |);
                        (* Unsize *)
                        M.pointer_coercion
                          (M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (|
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.alloc (|
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "core::option::Option")
                                      []
                                      [ Ty.path "usize" ],
                                    M.get_associated_function (|
                                      Ty.apply
                                        (Ty.path "alloc::collections::linked_list::CursorMut")
                                        []
                                        [ T; A ],
                                      "index",
                                      [],
                                      []
                                    |),
                                    [
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.deref (| M.read (| self |) |)
                                      |)
                                    ]
                                  |)
                                |)
                              |)
                            |)
                          |))
                      ]
                    |)
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T A : Ty.t),
        M.IsTraitInstance
          "core::fmt::Debug"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T A)
          (* Instance *) [ ("fmt", InstanceField.Method (fmt T A)) ].
    End Impl_core_fmt_Debug_where_core_fmt_Debug_T_where_core_alloc_Allocator_A_for_alloc_collections_linked_list_CursorMut_T_A.
    
    Module Impl_alloc_collections_linked_list_Cursor_T_A.
      Definition Self (T A : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "alloc::collections::linked_list::Cursor") [] [ T; A ].
      
      (*
          pub fn index(&self) -> Option<usize> {
              let _ = self.current?;
              Some(self.index)
          }
      *)
      Definition index (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.read (|
                  M.match_operator (|
                    None,
                    M.match_operator (|
                      Some
                        (Ty.apply
                          (Ty.path "core::ptr::non_null::NonNull")
                          []
                          [ Ty.apply (Ty.path "alloc::collections::linked_list::Node") [] [ T ] ]),
                      M.alloc (|
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "core::ops::control_flow::ControlFlow")
                            []
                            [
                              Ty.apply
                                (Ty.path "core::option::Option")
                                []
                                [ Ty.path "core::convert::Infallible" ];
                              Ty.apply
                                (Ty.path "core::ptr::non_null::NonNull")
                                []
                                [
                                  Ty.apply
                                    (Ty.path "alloc::collections::linked_list::Node")
                                    []
                                    [ T ]
                                ]
                            ],
                          M.get_trait_method (|
                            "core::ops::try_trait::Try",
                            Ty.apply
                              (Ty.path "core::option::Option")
                              []
                              [
                                Ty.apply
                                  (Ty.path "core::ptr::non_null::NonNull")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "alloc::collections::linked_list::Node")
                                      []
                                      [ T ]
                                  ]
                              ],
                            [],
                            [],
                            "branch",
                            [],
                            []
                          |),
                          [
                            M.read (|
                              M.SubPointer.get_struct_record_field (|
                                M.deref (| M.read (| self |) |),
                                "alloc::collections::linked_list::Cursor",
                                "current"
                              |)
                            |)
                          ]
                        |)
                      |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "core::ops::control_flow::ControlFlow::Break",
                                0
                              |) in
                            let residual := M.copy (| γ0_0 |) in
                            M.alloc (|
                              M.never_to_any (|
                                M.read (|
                                  M.return_ (|
                                    M.call_closure (|
                                      Ty.apply
                                        (Ty.path "core::option::Option")
                                        []
                                        [ Ty.path "usize" ],
                                      M.get_trait_method (|
                                        "core::ops::try_trait::FromResidual",
                                        Ty.apply
                                          (Ty.path "core::option::Option")
                                          []
                                          [ Ty.path "usize" ],
                                        [],
                                        [
                                          Ty.apply
                                            (Ty.path "core::option::Option")
                                            []
                                            [ Ty.path "core::convert::Infallible" ]
                                        ],
                                        "from_residual",
                                        [],
                                        []
                                      |),
                                      [ M.read (| residual |) ]
                                    |)
                                  |)
                                |)
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "core::ops::control_flow::ControlFlow::Continue",
                                0
                              |) in
                            let val := M.copy (| γ0_0 |) in
                            val))
                      ]
                    |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (M.alloc (|
                            Value.StructTuple
                              "core::option::Option::Some"
                              [
                                M.read (|
                                  M.SubPointer.get_struct_record_field (|
                                    M.deref (| M.read (| self |) |),
                                    "alloc::collections::linked_list::Cursor",
                                    "index"
                                  |)
                                |)
                              ]
                          |)))
                    ]
                  |)
                |)))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_index :
        forall (T A : Ty.t),
        M.IsAssociatedFunction.C (Self T A) "index" (index T A).
      Admitted.
      Global Typeclasses Opaque index.
      
      (*
          pub fn move_next(&mut self) {
              match self.current.take() {
                  // We had no current element; the cursor was sitting at the start position
                  // Next element should be the head of the list
                  None => {
                      self.current = self.list.head;
                      self.index = 0;
                  }
                  // We had a previous element, so let's go to its next
                  Some(current) => unsafe {
                      self.current = current.as_ref().next;
                      self.index += 1;
                  },
              }
          }
      *)
      Definition move_next (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                Some (Ty.tuple []),
                M.alloc (|
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "core::option::Option")
                      []
                      [
                        Ty.apply
                          (Ty.path "core::ptr::non_null::NonNull")
                          []
                          [ Ty.apply (Ty.path "alloc::collections::linked_list::Node") [] [ T ] ]
                      ],
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "core::option::Option")
                        []
                        [
                          Ty.apply
                            (Ty.path "core::ptr::non_null::NonNull")
                            []
                            [ Ty.apply (Ty.path "alloc::collections::linked_list::Node") [] [ T ] ]
                        ],
                      "take",
                      [],
                      []
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.MutRef,
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "alloc::collections::linked_list::Cursor",
                          "current"
                        |)
                      |)
                    ]
                  |)
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let _ := M.is_struct_tuple (| γ, "core::option::Option::None" |) in
                      let~ _ : Ty.tuple [] :=
                        M.alloc (|
                          M.write (|
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| self |) |),
                              "alloc::collections::linked_list::Cursor",
                              "current"
                            |),
                            M.read (|
                              M.SubPointer.get_struct_record_field (|
                                M.deref (|
                                  M.read (|
                                    M.SubPointer.get_struct_record_field (|
                                      M.deref (| M.read (| self |) |),
                                      "alloc::collections::linked_list::Cursor",
                                      "list"
                                    |)
                                  |)
                                |),
                                "alloc::collections::linked_list::LinkedList",
                                "head"
                              |)
                            |)
                          |)
                        |) in
                      let~ _ : Ty.tuple [] :=
                        M.alloc (|
                          M.write (|
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| self |) |),
                              "alloc::collections::linked_list::Cursor",
                              "index"
                            |),
                            Value.Integer IntegerKind.Usize 0
                          |)
                        |) in
                      M.alloc (| Value.Tuple [] |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::option::Option::Some",
                          0
                        |) in
                      let current := M.copy (| γ0_0 |) in
                      let~ _ : Ty.tuple [] :=
                        M.alloc (|
                          M.write (|
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| self |) |),
                              "alloc::collections::linked_list::Cursor",
                              "current"
                            |),
                            M.read (|
                              M.SubPointer.get_struct_record_field (|
                                M.deref (|
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "&")
                                      []
                                      [
                                        Ty.apply
                                          (Ty.path "alloc::collections::linked_list::Node")
                                          []
                                          [ T ]
                                      ],
                                    M.get_associated_function (|
                                      Ty.apply
                                        (Ty.path "core::ptr::non_null::NonNull")
                                        []
                                        [
                                          Ty.apply
                                            (Ty.path "alloc::collections::linked_list::Node")
                                            []
                                            [ T ]
                                        ],
                                      "as_ref",
                                      [],
                                      []
                                    |),
                                    [ M.borrow (| Pointer.Kind.Ref, current |) ]
                                  |)
                                |),
                                "alloc::collections::linked_list::Node",
                                "next"
                              |)
                            |)
                          |)
                        |) in
                      let~ _ : Ty.tuple [] :=
                        M.alloc (|
                          let β :=
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| self |) |),
                              "alloc::collections::linked_list::Cursor",
                              "index"
                            |) in
                          M.write (|
                            β,
                            M.call_closure (|
                              Ty.path "usize",
                              BinOp.Wrap.add,
                              [ M.read (| β |); Value.Integer IntegerKind.Usize 1 ]
                            |)
                          |)
                        |) in
                      M.alloc (| Value.Tuple [] |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_move_next :
        forall (T A : Ty.t),
        M.IsAssociatedFunction.C (Self T A) "move_next" (move_next T A).
      Admitted.
      Global Typeclasses Opaque move_next.
      
      (*
          pub fn move_prev(&mut self) {
              match self.current.take() {
                  // No current. We're at the start of the list. Yield None and jump to the end.
                  None => {
                      self.current = self.list.tail;
                      self.index = self.list.len().checked_sub(1).unwrap_or(0);
                  }
                  // Have a prev. Yield it and go to the previous element.
                  Some(current) => unsafe {
                      self.current = current.as_ref().prev;
                      self.index = self.index.checked_sub(1).unwrap_or_else(|| self.list.len());
                  },
              }
          }
      *)
      Definition move_prev (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                Some (Ty.tuple []),
                M.alloc (|
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "core::option::Option")
                      []
                      [
                        Ty.apply
                          (Ty.path "core::ptr::non_null::NonNull")
                          []
                          [ Ty.apply (Ty.path "alloc::collections::linked_list::Node") [] [ T ] ]
                      ],
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "core::option::Option")
                        []
                        [
                          Ty.apply
                            (Ty.path "core::ptr::non_null::NonNull")
                            []
                            [ Ty.apply (Ty.path "alloc::collections::linked_list::Node") [] [ T ] ]
                        ],
                      "take",
                      [],
                      []
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.MutRef,
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "alloc::collections::linked_list::Cursor",
                          "current"
                        |)
                      |)
                    ]
                  |)
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let _ := M.is_struct_tuple (| γ, "core::option::Option::None" |) in
                      let~ _ : Ty.tuple [] :=
                        M.alloc (|
                          M.write (|
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| self |) |),
                              "alloc::collections::linked_list::Cursor",
                              "current"
                            |),
                            M.read (|
                              M.SubPointer.get_struct_record_field (|
                                M.deref (|
                                  M.read (|
                                    M.SubPointer.get_struct_record_field (|
                                      M.deref (| M.read (| self |) |),
                                      "alloc::collections::linked_list::Cursor",
                                      "list"
                                    |)
                                  |)
                                |),
                                "alloc::collections::linked_list::LinkedList",
                                "tail"
                              |)
                            |)
                          |)
                        |) in
                      let~ _ : Ty.tuple [] :=
                        M.alloc (|
                          M.write (|
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| self |) |),
                              "alloc::collections::linked_list::Cursor",
                              "index"
                            |),
                            M.call_closure (|
                              Ty.path "usize",
                              M.get_associated_function (|
                                Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "usize" ],
                                "unwrap_or",
                                [],
                                []
                              |),
                              [
                                M.call_closure (|
                                  Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "usize" ],
                                  M.get_associated_function (|
                                    Ty.path "usize",
                                    "checked_sub",
                                    [],
                                    []
                                  |),
                                  [
                                    M.call_closure (|
                                      Ty.path "usize",
                                      M.get_associated_function (|
                                        Ty.apply
                                          (Ty.path "alloc::collections::linked_list::LinkedList")
                                          []
                                          [ T; A ],
                                        "len",
                                        [],
                                        []
                                      |),
                                      [
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.deref (|
                                            M.read (|
                                              M.SubPointer.get_struct_record_field (|
                                                M.deref (| M.read (| self |) |),
                                                "alloc::collections::linked_list::Cursor",
                                                "list"
                                              |)
                                            |)
                                          |)
                                        |)
                                      ]
                                    |);
                                    Value.Integer IntegerKind.Usize 1
                                  ]
                                |);
                                Value.Integer IntegerKind.Usize 0
                              ]
                            |)
                          |)
                        |) in
                      M.alloc (| Value.Tuple [] |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::option::Option::Some",
                          0
                        |) in
                      let current := M.copy (| γ0_0 |) in
                      let~ _ : Ty.tuple [] :=
                        M.alloc (|
                          M.write (|
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| self |) |),
                              "alloc::collections::linked_list::Cursor",
                              "current"
                            |),
                            M.read (|
                              M.SubPointer.get_struct_record_field (|
                                M.deref (|
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "&")
                                      []
                                      [
                                        Ty.apply
                                          (Ty.path "alloc::collections::linked_list::Node")
                                          []
                                          [ T ]
                                      ],
                                    M.get_associated_function (|
                                      Ty.apply
                                        (Ty.path "core::ptr::non_null::NonNull")
                                        []
                                        [
                                          Ty.apply
                                            (Ty.path "alloc::collections::linked_list::Node")
                                            []
                                            [ T ]
                                        ],
                                      "as_ref",
                                      [],
                                      []
                                    |),
                                    [ M.borrow (| Pointer.Kind.Ref, current |) ]
                                  |)
                                |),
                                "alloc::collections::linked_list::Node",
                                "prev"
                              |)
                            |)
                          |)
                        |) in
                      let~ _ : Ty.tuple [] :=
                        M.alloc (|
                          M.write (|
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| self |) |),
                              "alloc::collections::linked_list::Cursor",
                              "index"
                            |),
                            M.call_closure (|
                              Ty.path "usize",
                              M.get_associated_function (|
                                Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "usize" ],
                                "unwrap_or_else",
                                [],
                                [ Ty.function [ Ty.tuple [] ] (Ty.path "usize") ]
                              |),
                              [
                                M.call_closure (|
                                  Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "usize" ],
                                  M.get_associated_function (|
                                    Ty.path "usize",
                                    "checked_sub",
                                    [],
                                    []
                                  |),
                                  [
                                    M.read (|
                                      M.SubPointer.get_struct_record_field (|
                                        M.deref (| M.read (| self |) |),
                                        "alloc::collections::linked_list::Cursor",
                                        "index"
                                      |)
                                    |);
                                    Value.Integer IntegerKind.Usize 1
                                  ]
                                |);
                                M.closure
                                  (fun γ =>
                                    ltac:(M.monadic
                                      match γ with
                                      | [ α0 ] =>
                                        ltac:(M.monadic
                                          (M.match_operator (|
                                            Some (Ty.function [ Ty.tuple [] ] (Ty.path "usize")),
                                            M.alloc (| α0 |),
                                            [
                                              fun γ =>
                                                ltac:(M.monadic
                                                  (M.call_closure (|
                                                    Ty.path "usize",
                                                    M.get_associated_function (|
                                                      Ty.apply
                                                        (Ty.path
                                                          "alloc::collections::linked_list::LinkedList")
                                                        []
                                                        [ T; A ],
                                                      "len",
                                                      [],
                                                      []
                                                    |),
                                                    [
                                                      M.borrow (|
                                                        Pointer.Kind.Ref,
                                                        M.deref (|
                                                          M.read (|
                                                            M.SubPointer.get_struct_record_field (|
                                                              M.deref (| M.read (| self |) |),
                                                              "alloc::collections::linked_list::Cursor",
                                                              "list"
                                                            |)
                                                          |)
                                                        |)
                                                      |)
                                                    ]
                                                  |)))
                                            ]
                                          |)))
                                      | _ => M.impossible "wrong number of arguments"
                                      end))
                              ]
                            |)
                          |)
                        |) in
                      M.alloc (| Value.Tuple [] |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_move_prev :
        forall (T A : Ty.t),
        M.IsAssociatedFunction.C (Self T A) "move_prev" (move_prev T A).
      Admitted.
      Global Typeclasses Opaque move_prev.
      
      (*
          pub fn current(&self) -> Option<&'a T> {
              unsafe { self.current.map(|current| &( *current.as_ptr()).element) }
          }
      *)
      Definition current (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.apply (Ty.path "core::option::Option") [] [ Ty.apply (Ty.path "&") [] [ T ] ],
              M.get_associated_function (|
                Ty.apply
                  (Ty.path "core::option::Option")
                  []
                  [
                    Ty.apply
                      (Ty.path "core::ptr::non_null::NonNull")
                      []
                      [ Ty.apply (Ty.path "alloc::collections::linked_list::Node") [] [ T ] ]
                  ],
                "map",
                [],
                [
                  Ty.apply (Ty.path "&") [] [ T ];
                  Ty.function
                    [
                      Ty.tuple
                        [
                          Ty.apply
                            (Ty.path "core::ptr::non_null::NonNull")
                            []
                            [ Ty.apply (Ty.path "alloc::collections::linked_list::Node") [] [ T ] ]
                        ]
                    ]
                    (Ty.apply (Ty.path "&") [] [ T ])
                ]
              |),
              [
                M.read (|
                  M.SubPointer.get_struct_record_field (|
                    M.deref (| M.read (| self |) |),
                    "alloc::collections::linked_list::Cursor",
                    "current"
                  |)
                |);
                M.closure
                  (fun γ =>
                    ltac:(M.monadic
                      match γ with
                      | [ α0 ] =>
                        ltac:(M.monadic
                          (M.match_operator (|
                            Some
                              (Ty.function
                                [
                                  Ty.tuple
                                    [
                                      Ty.apply
                                        (Ty.path "core::ptr::non_null::NonNull")
                                        []
                                        [
                                          Ty.apply
                                            (Ty.path "alloc::collections::linked_list::Node")
                                            []
                                            [ T ]
                                        ]
                                    ]
                                ]
                                (Ty.apply (Ty.path "&") [] [ T ])),
                            M.alloc (| α0 |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let current := M.copy (| γ |) in
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.SubPointer.get_struct_record_field (|
                                      M.deref (|
                                        M.call_closure (|
                                          Ty.apply
                                            (Ty.path "*mut")
                                            []
                                            [
                                              Ty.apply
                                                (Ty.path "alloc::collections::linked_list::Node")
                                                []
                                                [ T ]
                                            ],
                                          M.get_associated_function (|
                                            Ty.apply
                                              (Ty.path "core::ptr::non_null::NonNull")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "alloc::collections::linked_list::Node")
                                                  []
                                                  [ T ]
                                              ],
                                            "as_ptr",
                                            [],
                                            []
                                          |),
                                          [ M.read (| current |) ]
                                        |)
                                      |),
                                      "alloc::collections::linked_list::Node",
                                      "element"
                                    |)
                                  |)))
                            ]
                          |)))
                      | _ => M.impossible "wrong number of arguments"
                      end))
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_current :
        forall (T A : Ty.t),
        M.IsAssociatedFunction.C (Self T A) "current" (current T A).
      Admitted.
      Global Typeclasses Opaque current.
      
      (*
          pub fn peek_next(&self) -> Option<&'a T> {
              unsafe {
                  let next = match self.current {
                      None => self.list.head,
                      Some(current) => current.as_ref().next,
                  };
                  next.map(|next| &( *next.as_ptr()).element)
              }
          }
      *)
      Definition peek_next (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              let~ next :
                  Ty.apply
                    (Ty.path "core::option::Option")
                    []
                    [
                      Ty.apply
                        (Ty.path "core::ptr::non_null::NonNull")
                        []
                        [ Ty.apply (Ty.path "alloc::collections::linked_list::Node") [] [ T ] ]
                    ] :=
                M.copy (|
                  M.match_operator (|
                    Some
                      (Ty.apply
                        (Ty.path "core::option::Option")
                        []
                        [
                          Ty.apply
                            (Ty.path "core::ptr::non_null::NonNull")
                            []
                            [ Ty.apply (Ty.path "alloc::collections::linked_list::Node") [] [ T ] ]
                        ]),
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| self |) |),
                      "alloc::collections::linked_list::Cursor",
                      "current"
                    |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let _ := M.is_struct_tuple (| γ, "core::option::Option::None" |) in
                          M.SubPointer.get_struct_record_field (|
                            M.deref (|
                              M.read (|
                                M.SubPointer.get_struct_record_field (|
                                  M.deref (| M.read (| self |) |),
                                  "alloc::collections::linked_list::Cursor",
                                  "list"
                                |)
                              |)
                            |),
                            "alloc::collections::linked_list::LinkedList",
                            "head"
                          |)));
                      fun γ =>
                        ltac:(M.monadic
                          (let γ0_0 :=
                            M.SubPointer.get_struct_tuple_field (|
                              γ,
                              "core::option::Option::Some",
                              0
                            |) in
                          let current := M.copy (| γ0_0 |) in
                          M.SubPointer.get_struct_record_field (|
                            M.deref (|
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "&")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "alloc::collections::linked_list::Node")
                                      []
                                      [ T ]
                                  ],
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "core::ptr::non_null::NonNull")
                                    []
                                    [
                                      Ty.apply
                                        (Ty.path "alloc::collections::linked_list::Node")
                                        []
                                        [ T ]
                                    ],
                                  "as_ref",
                                  [],
                                  []
                                |),
                                [ M.borrow (| Pointer.Kind.Ref, current |) ]
                              |)
                            |),
                            "alloc::collections::linked_list::Node",
                            "next"
                          |)))
                    ]
                  |)
                |) in
              M.alloc (|
                M.call_closure (|
                  Ty.apply (Ty.path "core::option::Option") [] [ Ty.apply (Ty.path "&") [] [ T ] ],
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "core::option::Option")
                      []
                      [
                        Ty.apply
                          (Ty.path "core::ptr::non_null::NonNull")
                          []
                          [ Ty.apply (Ty.path "alloc::collections::linked_list::Node") [] [ T ] ]
                      ],
                    "map",
                    [],
                    [
                      Ty.apply (Ty.path "&") [] [ T ];
                      Ty.function
                        [
                          Ty.tuple
                            [
                              Ty.apply
                                (Ty.path "core::ptr::non_null::NonNull")
                                []
                                [
                                  Ty.apply
                                    (Ty.path "alloc::collections::linked_list::Node")
                                    []
                                    [ T ]
                                ]
                            ]
                        ]
                        (Ty.apply (Ty.path "&") [] [ T ])
                    ]
                  |),
                  [
                    M.read (| next |);
                    M.closure
                      (fun γ =>
                        ltac:(M.monadic
                          match γ with
                          | [ α0 ] =>
                            ltac:(M.monadic
                              (M.match_operator (|
                                Some
                                  (Ty.function
                                    [
                                      Ty.tuple
                                        [
                                          Ty.apply
                                            (Ty.path "core::ptr::non_null::NonNull")
                                            []
                                            [
                                              Ty.apply
                                                (Ty.path "alloc::collections::linked_list::Node")
                                                []
                                                [ T ]
                                            ]
                                        ]
                                    ]
                                    (Ty.apply (Ty.path "&") [] [ T ])),
                                M.alloc (| α0 |),
                                [
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let next := M.copy (| γ |) in
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.SubPointer.get_struct_record_field (|
                                          M.deref (|
                                            M.call_closure (|
                                              Ty.apply
                                                (Ty.path "*mut")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path
                                                      "alloc::collections::linked_list::Node")
                                                    []
                                                    [ T ]
                                                ],
                                              M.get_associated_function (|
                                                Ty.apply
                                                  (Ty.path "core::ptr::non_null::NonNull")
                                                  []
                                                  [
                                                    Ty.apply
                                                      (Ty.path
                                                        "alloc::collections::linked_list::Node")
                                                      []
                                                      [ T ]
                                                  ],
                                                "as_ptr",
                                                [],
                                                []
                                              |),
                                              [ M.read (| next |) ]
                                            |)
                                          |),
                                          "alloc::collections::linked_list::Node",
                                          "element"
                                        |)
                                      |)))
                                ]
                              |)))
                          | _ => M.impossible "wrong number of arguments"
                          end))
                  ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_peek_next :
        forall (T A : Ty.t),
        M.IsAssociatedFunction.C (Self T A) "peek_next" (peek_next T A).
      Admitted.
      Global Typeclasses Opaque peek_next.
      
      (*
          pub fn peek_prev(&self) -> Option<&'a T> {
              unsafe {
                  let prev = match self.current {
                      None => self.list.tail,
                      Some(current) => current.as_ref().prev,
                  };
                  prev.map(|prev| &( *prev.as_ptr()).element)
              }
          }
      *)
      Definition peek_prev (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              let~ prev :
                  Ty.apply
                    (Ty.path "core::option::Option")
                    []
                    [
                      Ty.apply
                        (Ty.path "core::ptr::non_null::NonNull")
                        []
                        [ Ty.apply (Ty.path "alloc::collections::linked_list::Node") [] [ T ] ]
                    ] :=
                M.copy (|
                  M.match_operator (|
                    Some
                      (Ty.apply
                        (Ty.path "core::option::Option")
                        []
                        [
                          Ty.apply
                            (Ty.path "core::ptr::non_null::NonNull")
                            []
                            [ Ty.apply (Ty.path "alloc::collections::linked_list::Node") [] [ T ] ]
                        ]),
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| self |) |),
                      "alloc::collections::linked_list::Cursor",
                      "current"
                    |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let _ := M.is_struct_tuple (| γ, "core::option::Option::None" |) in
                          M.SubPointer.get_struct_record_field (|
                            M.deref (|
                              M.read (|
                                M.SubPointer.get_struct_record_field (|
                                  M.deref (| M.read (| self |) |),
                                  "alloc::collections::linked_list::Cursor",
                                  "list"
                                |)
                              |)
                            |),
                            "alloc::collections::linked_list::LinkedList",
                            "tail"
                          |)));
                      fun γ =>
                        ltac:(M.monadic
                          (let γ0_0 :=
                            M.SubPointer.get_struct_tuple_field (|
                              γ,
                              "core::option::Option::Some",
                              0
                            |) in
                          let current := M.copy (| γ0_0 |) in
                          M.SubPointer.get_struct_record_field (|
                            M.deref (|
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "&")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "alloc::collections::linked_list::Node")
                                      []
                                      [ T ]
                                  ],
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "core::ptr::non_null::NonNull")
                                    []
                                    [
                                      Ty.apply
                                        (Ty.path "alloc::collections::linked_list::Node")
                                        []
                                        [ T ]
                                    ],
                                  "as_ref",
                                  [],
                                  []
                                |),
                                [ M.borrow (| Pointer.Kind.Ref, current |) ]
                              |)
                            |),
                            "alloc::collections::linked_list::Node",
                            "prev"
                          |)))
                    ]
                  |)
                |) in
              M.alloc (|
                M.call_closure (|
                  Ty.apply (Ty.path "core::option::Option") [] [ Ty.apply (Ty.path "&") [] [ T ] ],
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "core::option::Option")
                      []
                      [
                        Ty.apply
                          (Ty.path "core::ptr::non_null::NonNull")
                          []
                          [ Ty.apply (Ty.path "alloc::collections::linked_list::Node") [] [ T ] ]
                      ],
                    "map",
                    [],
                    [
                      Ty.apply (Ty.path "&") [] [ T ];
                      Ty.function
                        [
                          Ty.tuple
                            [
                              Ty.apply
                                (Ty.path "core::ptr::non_null::NonNull")
                                []
                                [
                                  Ty.apply
                                    (Ty.path "alloc::collections::linked_list::Node")
                                    []
                                    [ T ]
                                ]
                            ]
                        ]
                        (Ty.apply (Ty.path "&") [] [ T ])
                    ]
                  |),
                  [
                    M.read (| prev |);
                    M.closure
                      (fun γ =>
                        ltac:(M.monadic
                          match γ with
                          | [ α0 ] =>
                            ltac:(M.monadic
                              (M.match_operator (|
                                Some
                                  (Ty.function
                                    [
                                      Ty.tuple
                                        [
                                          Ty.apply
                                            (Ty.path "core::ptr::non_null::NonNull")
                                            []
                                            [
                                              Ty.apply
                                                (Ty.path "alloc::collections::linked_list::Node")
                                                []
                                                [ T ]
                                            ]
                                        ]
                                    ]
                                    (Ty.apply (Ty.path "&") [] [ T ])),
                                M.alloc (| α0 |),
                                [
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let prev := M.copy (| γ |) in
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.SubPointer.get_struct_record_field (|
                                          M.deref (|
                                            M.call_closure (|
                                              Ty.apply
                                                (Ty.path "*mut")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path
                                                      "alloc::collections::linked_list::Node")
                                                    []
                                                    [ T ]
                                                ],
                                              M.get_associated_function (|
                                                Ty.apply
                                                  (Ty.path "core::ptr::non_null::NonNull")
                                                  []
                                                  [
                                                    Ty.apply
                                                      (Ty.path
                                                        "alloc::collections::linked_list::Node")
                                                      []
                                                      [ T ]
                                                  ],
                                                "as_ptr",
                                                [],
                                                []
                                              |),
                                              [ M.read (| prev |) ]
                                            |)
                                          |),
                                          "alloc::collections::linked_list::Node",
                                          "element"
                                        |)
                                      |)))
                                ]
                              |)))
                          | _ => M.impossible "wrong number of arguments"
                          end))
                  ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_peek_prev :
        forall (T A : Ty.t),
        M.IsAssociatedFunction.C (Self T A) "peek_prev" (peek_prev T A).
      Admitted.
      Global Typeclasses Opaque peek_prev.
      
      (*
          pub fn front(&self) -> Option<&'a T> {
              self.list.front()
          }
      *)
      Definition front (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.apply (Ty.path "core::option::Option") [] [ Ty.apply (Ty.path "&") [] [ T ] ],
              M.get_associated_function (|
                Ty.apply (Ty.path "alloc::collections::linked_list::LinkedList") [] [ T; A ],
                "front",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.read (|
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "alloc::collections::linked_list::Cursor",
                        "list"
                      |)
                    |)
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_front :
        forall (T A : Ty.t),
        M.IsAssociatedFunction.C (Self T A) "front" (front T A).
      Admitted.
      Global Typeclasses Opaque front.
      
      (*
          pub fn back(&self) -> Option<&'a T> {
              self.list.back()
          }
      *)
      Definition back (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.apply (Ty.path "core::option::Option") [] [ Ty.apply (Ty.path "&") [] [ T ] ],
              M.get_associated_function (|
                Ty.apply (Ty.path "alloc::collections::linked_list::LinkedList") [] [ T; A ],
                "back",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.read (|
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "alloc::collections::linked_list::Cursor",
                        "list"
                      |)
                    |)
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_back :
        forall (T A : Ty.t),
        M.IsAssociatedFunction.C (Self T A) "back" (back T A).
      Admitted.
      Global Typeclasses Opaque back.
      
      (*
          pub fn as_list(&self) -> &'a LinkedList<T, A> {
              self.list
          }
      *)
      Definition as_list (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.SubPointer.get_struct_record_field (|
                M.deref (| M.read (| self |) |),
                "alloc::collections::linked_list::Cursor",
                "list"
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_as_list :
        forall (T A : Ty.t),
        M.IsAssociatedFunction.C (Self T A) "as_list" (as_list T A).
      Admitted.
      Global Typeclasses Opaque as_list.
    End Impl_alloc_collections_linked_list_Cursor_T_A.
    
    Module Impl_alloc_collections_linked_list_CursorMut_T_A.
      Definition Self (T A : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "alloc::collections::linked_list::CursorMut") [] [ T; A ].
      
      (*
          pub fn index(&self) -> Option<usize> {
              let _ = self.current?;
              Some(self.index)
          }
      *)
      Definition index (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.read (|
                  M.match_operator (|
                    None,
                    M.match_operator (|
                      Some
                        (Ty.apply
                          (Ty.path "core::ptr::non_null::NonNull")
                          []
                          [ Ty.apply (Ty.path "alloc::collections::linked_list::Node") [] [ T ] ]),
                      M.alloc (|
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "core::ops::control_flow::ControlFlow")
                            []
                            [
                              Ty.apply
                                (Ty.path "core::option::Option")
                                []
                                [ Ty.path "core::convert::Infallible" ];
                              Ty.apply
                                (Ty.path "core::ptr::non_null::NonNull")
                                []
                                [
                                  Ty.apply
                                    (Ty.path "alloc::collections::linked_list::Node")
                                    []
                                    [ T ]
                                ]
                            ],
                          M.get_trait_method (|
                            "core::ops::try_trait::Try",
                            Ty.apply
                              (Ty.path "core::option::Option")
                              []
                              [
                                Ty.apply
                                  (Ty.path "core::ptr::non_null::NonNull")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "alloc::collections::linked_list::Node")
                                      []
                                      [ T ]
                                  ]
                              ],
                            [],
                            [],
                            "branch",
                            [],
                            []
                          |),
                          [
                            M.read (|
                              M.SubPointer.get_struct_record_field (|
                                M.deref (| M.read (| self |) |),
                                "alloc::collections::linked_list::CursorMut",
                                "current"
                              |)
                            |)
                          ]
                        |)
                      |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "core::ops::control_flow::ControlFlow::Break",
                                0
                              |) in
                            let residual := M.copy (| γ0_0 |) in
                            M.alloc (|
                              M.never_to_any (|
                                M.read (|
                                  M.return_ (|
                                    M.call_closure (|
                                      Ty.apply
                                        (Ty.path "core::option::Option")
                                        []
                                        [ Ty.path "usize" ],
                                      M.get_trait_method (|
                                        "core::ops::try_trait::FromResidual",
                                        Ty.apply
                                          (Ty.path "core::option::Option")
                                          []
                                          [ Ty.path "usize" ],
                                        [],
                                        [
                                          Ty.apply
                                            (Ty.path "core::option::Option")
                                            []
                                            [ Ty.path "core::convert::Infallible" ]
                                        ],
                                        "from_residual",
                                        [],
                                        []
                                      |),
                                      [ M.read (| residual |) ]
                                    |)
                                  |)
                                |)
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "core::ops::control_flow::ControlFlow::Continue",
                                0
                              |) in
                            let val := M.copy (| γ0_0 |) in
                            val))
                      ]
                    |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (M.alloc (|
                            Value.StructTuple
                              "core::option::Option::Some"
                              [
                                M.read (|
                                  M.SubPointer.get_struct_record_field (|
                                    M.deref (| M.read (| self |) |),
                                    "alloc::collections::linked_list::CursorMut",
                                    "index"
                                  |)
                                |)
                              ]
                          |)))
                    ]
                  |)
                |)))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_index :
        forall (T A : Ty.t),
        M.IsAssociatedFunction.C (Self T A) "index" (index T A).
      Admitted.
      Global Typeclasses Opaque index.
      
      (*
          pub fn move_next(&mut self) {
              match self.current.take() {
                  // We had no current element; the cursor was sitting at the start position
                  // Next element should be the head of the list
                  None => {
                      self.current = self.list.head;
                      self.index = 0;
                  }
                  // We had a previous element, so let's go to its next
                  Some(current) => unsafe {
                      self.current = current.as_ref().next;
                      self.index += 1;
                  },
              }
          }
      *)
      Definition move_next (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                Some (Ty.tuple []),
                M.alloc (|
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "core::option::Option")
                      []
                      [
                        Ty.apply
                          (Ty.path "core::ptr::non_null::NonNull")
                          []
                          [ Ty.apply (Ty.path "alloc::collections::linked_list::Node") [] [ T ] ]
                      ],
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "core::option::Option")
                        []
                        [
                          Ty.apply
                            (Ty.path "core::ptr::non_null::NonNull")
                            []
                            [ Ty.apply (Ty.path "alloc::collections::linked_list::Node") [] [ T ] ]
                        ],
                      "take",
                      [],
                      []
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.MutRef,
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "alloc::collections::linked_list::CursorMut",
                          "current"
                        |)
                      |)
                    ]
                  |)
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let _ := M.is_struct_tuple (| γ, "core::option::Option::None" |) in
                      let~ _ : Ty.tuple [] :=
                        M.alloc (|
                          M.write (|
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| self |) |),
                              "alloc::collections::linked_list::CursorMut",
                              "current"
                            |),
                            M.read (|
                              M.SubPointer.get_struct_record_field (|
                                M.deref (|
                                  M.read (|
                                    M.SubPointer.get_struct_record_field (|
                                      M.deref (| M.read (| self |) |),
                                      "alloc::collections::linked_list::CursorMut",
                                      "list"
                                    |)
                                  |)
                                |),
                                "alloc::collections::linked_list::LinkedList",
                                "head"
                              |)
                            |)
                          |)
                        |) in
                      let~ _ : Ty.tuple [] :=
                        M.alloc (|
                          M.write (|
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| self |) |),
                              "alloc::collections::linked_list::CursorMut",
                              "index"
                            |),
                            Value.Integer IntegerKind.Usize 0
                          |)
                        |) in
                      M.alloc (| Value.Tuple [] |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::option::Option::Some",
                          0
                        |) in
                      let current := M.copy (| γ0_0 |) in
                      let~ _ : Ty.tuple [] :=
                        M.alloc (|
                          M.write (|
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| self |) |),
                              "alloc::collections::linked_list::CursorMut",
                              "current"
                            |),
                            M.read (|
                              M.SubPointer.get_struct_record_field (|
                                M.deref (|
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "&")
                                      []
                                      [
                                        Ty.apply
                                          (Ty.path "alloc::collections::linked_list::Node")
                                          []
                                          [ T ]
                                      ],
                                    M.get_associated_function (|
                                      Ty.apply
                                        (Ty.path "core::ptr::non_null::NonNull")
                                        []
                                        [
                                          Ty.apply
                                            (Ty.path "alloc::collections::linked_list::Node")
                                            []
                                            [ T ]
                                        ],
                                      "as_ref",
                                      [],
                                      []
                                    |),
                                    [ M.borrow (| Pointer.Kind.Ref, current |) ]
                                  |)
                                |),
                                "alloc::collections::linked_list::Node",
                                "next"
                              |)
                            |)
                          |)
                        |) in
                      let~ _ : Ty.tuple [] :=
                        M.alloc (|
                          let β :=
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| self |) |),
                              "alloc::collections::linked_list::CursorMut",
                              "index"
                            |) in
                          M.write (|
                            β,
                            M.call_closure (|
                              Ty.path "usize",
                              BinOp.Wrap.add,
                              [ M.read (| β |); Value.Integer IntegerKind.Usize 1 ]
                            |)
                          |)
                        |) in
                      M.alloc (| Value.Tuple [] |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_move_next :
        forall (T A : Ty.t),
        M.IsAssociatedFunction.C (Self T A) "move_next" (move_next T A).
      Admitted.
      Global Typeclasses Opaque move_next.
      
      (*
          pub fn move_prev(&mut self) {
              match self.current.take() {
                  // No current. We're at the start of the list. Yield None and jump to the end.
                  None => {
                      self.current = self.list.tail;
                      self.index = self.list.len().checked_sub(1).unwrap_or(0);
                  }
                  // Have a prev. Yield it and go to the previous element.
                  Some(current) => unsafe {
                      self.current = current.as_ref().prev;
                      self.index = self.index.checked_sub(1).unwrap_or_else(|| self.list.len());
                  },
              }
          }
      *)
      Definition move_prev (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                Some (Ty.tuple []),
                M.alloc (|
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "core::option::Option")
                      []
                      [
                        Ty.apply
                          (Ty.path "core::ptr::non_null::NonNull")
                          []
                          [ Ty.apply (Ty.path "alloc::collections::linked_list::Node") [] [ T ] ]
                      ],
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "core::option::Option")
                        []
                        [
                          Ty.apply
                            (Ty.path "core::ptr::non_null::NonNull")
                            []
                            [ Ty.apply (Ty.path "alloc::collections::linked_list::Node") [] [ T ] ]
                        ],
                      "take",
                      [],
                      []
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.MutRef,
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "alloc::collections::linked_list::CursorMut",
                          "current"
                        |)
                      |)
                    ]
                  |)
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let _ := M.is_struct_tuple (| γ, "core::option::Option::None" |) in
                      let~ _ : Ty.tuple [] :=
                        M.alloc (|
                          M.write (|
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| self |) |),
                              "alloc::collections::linked_list::CursorMut",
                              "current"
                            |),
                            M.read (|
                              M.SubPointer.get_struct_record_field (|
                                M.deref (|
                                  M.read (|
                                    M.SubPointer.get_struct_record_field (|
                                      M.deref (| M.read (| self |) |),
                                      "alloc::collections::linked_list::CursorMut",
                                      "list"
                                    |)
                                  |)
                                |),
                                "alloc::collections::linked_list::LinkedList",
                                "tail"
                              |)
                            |)
                          |)
                        |) in
                      let~ _ : Ty.tuple [] :=
                        M.alloc (|
                          M.write (|
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| self |) |),
                              "alloc::collections::linked_list::CursorMut",
                              "index"
                            |),
                            M.call_closure (|
                              Ty.path "usize",
                              M.get_associated_function (|
                                Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "usize" ],
                                "unwrap_or",
                                [],
                                []
                              |),
                              [
                                M.call_closure (|
                                  Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "usize" ],
                                  M.get_associated_function (|
                                    Ty.path "usize",
                                    "checked_sub",
                                    [],
                                    []
                                  |),
                                  [
                                    M.call_closure (|
                                      Ty.path "usize",
                                      M.get_associated_function (|
                                        Ty.apply
                                          (Ty.path "alloc::collections::linked_list::LinkedList")
                                          []
                                          [ T; A ],
                                        "len",
                                        [],
                                        []
                                      |),
                                      [
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.deref (|
                                            M.read (|
                                              M.SubPointer.get_struct_record_field (|
                                                M.deref (| M.read (| self |) |),
                                                "alloc::collections::linked_list::CursorMut",
                                                "list"
                                              |)
                                            |)
                                          |)
                                        |)
                                      ]
                                    |);
                                    Value.Integer IntegerKind.Usize 1
                                  ]
                                |);
                                Value.Integer IntegerKind.Usize 0
                              ]
                            |)
                          |)
                        |) in
                      M.alloc (| Value.Tuple [] |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::option::Option::Some",
                          0
                        |) in
                      let current := M.copy (| γ0_0 |) in
                      let~ _ : Ty.tuple [] :=
                        M.alloc (|
                          M.write (|
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| self |) |),
                              "alloc::collections::linked_list::CursorMut",
                              "current"
                            |),
                            M.read (|
                              M.SubPointer.get_struct_record_field (|
                                M.deref (|
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "&")
                                      []
                                      [
                                        Ty.apply
                                          (Ty.path "alloc::collections::linked_list::Node")
                                          []
                                          [ T ]
                                      ],
                                    M.get_associated_function (|
                                      Ty.apply
                                        (Ty.path "core::ptr::non_null::NonNull")
                                        []
                                        [
                                          Ty.apply
                                            (Ty.path "alloc::collections::linked_list::Node")
                                            []
                                            [ T ]
                                        ],
                                      "as_ref",
                                      [],
                                      []
                                    |),
                                    [ M.borrow (| Pointer.Kind.Ref, current |) ]
                                  |)
                                |),
                                "alloc::collections::linked_list::Node",
                                "prev"
                              |)
                            |)
                          |)
                        |) in
                      let~ _ : Ty.tuple [] :=
                        M.alloc (|
                          M.write (|
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| self |) |),
                              "alloc::collections::linked_list::CursorMut",
                              "index"
                            |),
                            M.call_closure (|
                              Ty.path "usize",
                              M.get_associated_function (|
                                Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "usize" ],
                                "unwrap_or_else",
                                [],
                                [ Ty.function [ Ty.tuple [] ] (Ty.path "usize") ]
                              |),
                              [
                                M.call_closure (|
                                  Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "usize" ],
                                  M.get_associated_function (|
                                    Ty.path "usize",
                                    "checked_sub",
                                    [],
                                    []
                                  |),
                                  [
                                    M.read (|
                                      M.SubPointer.get_struct_record_field (|
                                        M.deref (| M.read (| self |) |),
                                        "alloc::collections::linked_list::CursorMut",
                                        "index"
                                      |)
                                    |);
                                    Value.Integer IntegerKind.Usize 1
                                  ]
                                |);
                                M.closure
                                  (fun γ =>
                                    ltac:(M.monadic
                                      match γ with
                                      | [ α0 ] =>
                                        ltac:(M.monadic
                                          (M.match_operator (|
                                            Some (Ty.function [ Ty.tuple [] ] (Ty.path "usize")),
                                            M.alloc (| α0 |),
                                            [
                                              fun γ =>
                                                ltac:(M.monadic
                                                  (M.call_closure (|
                                                    Ty.path "usize",
                                                    M.get_associated_function (|
                                                      Ty.apply
                                                        (Ty.path
                                                          "alloc::collections::linked_list::LinkedList")
                                                        []
                                                        [ T; A ],
                                                      "len",
                                                      [],
                                                      []
                                                    |),
                                                    [
                                                      M.borrow (|
                                                        Pointer.Kind.Ref,
                                                        M.deref (|
                                                          M.read (|
                                                            M.SubPointer.get_struct_record_field (|
                                                              M.deref (| M.read (| self |) |),
                                                              "alloc::collections::linked_list::CursorMut",
                                                              "list"
                                                            |)
                                                          |)
                                                        |)
                                                      |)
                                                    ]
                                                  |)))
                                            ]
                                          |)))
                                      | _ => M.impossible "wrong number of arguments"
                                      end))
                              ]
                            |)
                          |)
                        |) in
                      M.alloc (| Value.Tuple [] |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_move_prev :
        forall (T A : Ty.t),
        M.IsAssociatedFunction.C (Self T A) "move_prev" (move_prev T A).
      Admitted.
      Global Typeclasses Opaque move_prev.
      
      (*
          pub fn current(&mut self) -> Option<&mut T> {
              unsafe { self.current.map(|current| &mut ( *current.as_ptr()).element) }
          }
      *)
      Definition current (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.apply (Ty.path "core::option::Option") [] [ Ty.apply (Ty.path "&mut") [] [ T ] ],
              M.get_associated_function (|
                Ty.apply
                  (Ty.path "core::option::Option")
                  []
                  [
                    Ty.apply
                      (Ty.path "core::ptr::non_null::NonNull")
                      []
                      [ Ty.apply (Ty.path "alloc::collections::linked_list::Node") [] [ T ] ]
                  ],
                "map",
                [],
                [
                  Ty.apply (Ty.path "&mut") [] [ T ];
                  Ty.function
                    [
                      Ty.tuple
                        [
                          Ty.apply
                            (Ty.path "core::ptr::non_null::NonNull")
                            []
                            [ Ty.apply (Ty.path "alloc::collections::linked_list::Node") [] [ T ] ]
                        ]
                    ]
                    (Ty.apply (Ty.path "&mut") [] [ T ])
                ]
              |),
              [
                M.read (|
                  M.SubPointer.get_struct_record_field (|
                    M.deref (| M.read (| self |) |),
                    "alloc::collections::linked_list::CursorMut",
                    "current"
                  |)
                |);
                M.closure
                  (fun γ =>
                    ltac:(M.monadic
                      match γ with
                      | [ α0 ] =>
                        ltac:(M.monadic
                          (M.match_operator (|
                            Some
                              (Ty.function
                                [
                                  Ty.tuple
                                    [
                                      Ty.apply
                                        (Ty.path "core::ptr::non_null::NonNull")
                                        []
                                        [
                                          Ty.apply
                                            (Ty.path "alloc::collections::linked_list::Node")
                                            []
                                            [ T ]
                                        ]
                                    ]
                                ]
                                (Ty.apply (Ty.path "&mut") [] [ T ])),
                            M.alloc (| α0 |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let current := M.copy (| γ |) in
                                  M.borrow (|
                                    Pointer.Kind.MutRef,
                                    M.SubPointer.get_struct_record_field (|
                                      M.deref (|
                                        M.call_closure (|
                                          Ty.apply
                                            (Ty.path "*mut")
                                            []
                                            [
                                              Ty.apply
                                                (Ty.path "alloc::collections::linked_list::Node")
                                                []
                                                [ T ]
                                            ],
                                          M.get_associated_function (|
                                            Ty.apply
                                              (Ty.path "core::ptr::non_null::NonNull")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "alloc::collections::linked_list::Node")
                                                  []
                                                  [ T ]
                                              ],
                                            "as_ptr",
                                            [],
                                            []
                                          |),
                                          [ M.read (| current |) ]
                                        |)
                                      |),
                                      "alloc::collections::linked_list::Node",
                                      "element"
                                    |)
                                  |)))
                            ]
                          |)))
                      | _ => M.impossible "wrong number of arguments"
                      end))
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_current :
        forall (T A : Ty.t),
        M.IsAssociatedFunction.C (Self T A) "current" (current T A).
      Admitted.
      Global Typeclasses Opaque current.
      
      (*
          pub fn peek_next(&mut self) -> Option<&mut T> {
              unsafe {
                  let next = match self.current {
                      None => self.list.head,
                      Some(current) => current.as_ref().next,
                  };
                  next.map(|next| &mut ( *next.as_ptr()).element)
              }
          }
      *)
      Definition peek_next (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              let~ next :
                  Ty.apply
                    (Ty.path "core::option::Option")
                    []
                    [
                      Ty.apply
                        (Ty.path "core::ptr::non_null::NonNull")
                        []
                        [ Ty.apply (Ty.path "alloc::collections::linked_list::Node") [] [ T ] ]
                    ] :=
                M.copy (|
                  M.match_operator (|
                    Some
                      (Ty.apply
                        (Ty.path "core::option::Option")
                        []
                        [
                          Ty.apply
                            (Ty.path "core::ptr::non_null::NonNull")
                            []
                            [ Ty.apply (Ty.path "alloc::collections::linked_list::Node") [] [ T ] ]
                        ]),
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| self |) |),
                      "alloc::collections::linked_list::CursorMut",
                      "current"
                    |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let _ := M.is_struct_tuple (| γ, "core::option::Option::None" |) in
                          M.SubPointer.get_struct_record_field (|
                            M.deref (|
                              M.read (|
                                M.SubPointer.get_struct_record_field (|
                                  M.deref (| M.read (| self |) |),
                                  "alloc::collections::linked_list::CursorMut",
                                  "list"
                                |)
                              |)
                            |),
                            "alloc::collections::linked_list::LinkedList",
                            "head"
                          |)));
                      fun γ =>
                        ltac:(M.monadic
                          (let γ0_0 :=
                            M.SubPointer.get_struct_tuple_field (|
                              γ,
                              "core::option::Option::Some",
                              0
                            |) in
                          let current := M.copy (| γ0_0 |) in
                          M.SubPointer.get_struct_record_field (|
                            M.deref (|
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "&")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "alloc::collections::linked_list::Node")
                                      []
                                      [ T ]
                                  ],
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "core::ptr::non_null::NonNull")
                                    []
                                    [
                                      Ty.apply
                                        (Ty.path "alloc::collections::linked_list::Node")
                                        []
                                        [ T ]
                                    ],
                                  "as_ref",
                                  [],
                                  []
                                |),
                                [ M.borrow (| Pointer.Kind.Ref, current |) ]
                              |)
                            |),
                            "alloc::collections::linked_list::Node",
                            "next"
                          |)))
                    ]
                  |)
                |) in
              M.alloc (|
                M.call_closure (|
                  Ty.apply
                    (Ty.path "core::option::Option")
                    []
                    [ Ty.apply (Ty.path "&mut") [] [ T ] ],
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "core::option::Option")
                      []
                      [
                        Ty.apply
                          (Ty.path "core::ptr::non_null::NonNull")
                          []
                          [ Ty.apply (Ty.path "alloc::collections::linked_list::Node") [] [ T ] ]
                      ],
                    "map",
                    [],
                    [
                      Ty.apply (Ty.path "&mut") [] [ T ];
                      Ty.function
                        [
                          Ty.tuple
                            [
                              Ty.apply
                                (Ty.path "core::ptr::non_null::NonNull")
                                []
                                [
                                  Ty.apply
                                    (Ty.path "alloc::collections::linked_list::Node")
                                    []
                                    [ T ]
                                ]
                            ]
                        ]
                        (Ty.apply (Ty.path "&mut") [] [ T ])
                    ]
                  |),
                  [
                    M.read (| next |);
                    M.closure
                      (fun γ =>
                        ltac:(M.monadic
                          match γ with
                          | [ α0 ] =>
                            ltac:(M.monadic
                              (M.match_operator (|
                                Some
                                  (Ty.function
                                    [
                                      Ty.tuple
                                        [
                                          Ty.apply
                                            (Ty.path "core::ptr::non_null::NonNull")
                                            []
                                            [
                                              Ty.apply
                                                (Ty.path "alloc::collections::linked_list::Node")
                                                []
                                                [ T ]
                                            ]
                                        ]
                                    ]
                                    (Ty.apply (Ty.path "&mut") [] [ T ])),
                                M.alloc (| α0 |),
                                [
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let next := M.copy (| γ |) in
                                      M.borrow (|
                                        Pointer.Kind.MutRef,
                                        M.SubPointer.get_struct_record_field (|
                                          M.deref (|
                                            M.call_closure (|
                                              Ty.apply
                                                (Ty.path "*mut")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path
                                                      "alloc::collections::linked_list::Node")
                                                    []
                                                    [ T ]
                                                ],
                                              M.get_associated_function (|
                                                Ty.apply
                                                  (Ty.path "core::ptr::non_null::NonNull")
                                                  []
                                                  [
                                                    Ty.apply
                                                      (Ty.path
                                                        "alloc::collections::linked_list::Node")
                                                      []
                                                      [ T ]
                                                  ],
                                                "as_ptr",
                                                [],
                                                []
                                              |),
                                              [ M.read (| next |) ]
                                            |)
                                          |),
                                          "alloc::collections::linked_list::Node",
                                          "element"
                                        |)
                                      |)))
                                ]
                              |)))
                          | _ => M.impossible "wrong number of arguments"
                          end))
                  ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_peek_next :
        forall (T A : Ty.t),
        M.IsAssociatedFunction.C (Self T A) "peek_next" (peek_next T A).
      Admitted.
      Global Typeclasses Opaque peek_next.
      
      (*
          pub fn peek_prev(&mut self) -> Option<&mut T> {
              unsafe {
                  let prev = match self.current {
                      None => self.list.tail,
                      Some(current) => current.as_ref().prev,
                  };
                  prev.map(|prev| &mut ( *prev.as_ptr()).element)
              }
          }
      *)
      Definition peek_prev (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              let~ prev :
                  Ty.apply
                    (Ty.path "core::option::Option")
                    []
                    [
                      Ty.apply
                        (Ty.path "core::ptr::non_null::NonNull")
                        []
                        [ Ty.apply (Ty.path "alloc::collections::linked_list::Node") [] [ T ] ]
                    ] :=
                M.copy (|
                  M.match_operator (|
                    Some
                      (Ty.apply
                        (Ty.path "core::option::Option")
                        []
                        [
                          Ty.apply
                            (Ty.path "core::ptr::non_null::NonNull")
                            []
                            [ Ty.apply (Ty.path "alloc::collections::linked_list::Node") [] [ T ] ]
                        ]),
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| self |) |),
                      "alloc::collections::linked_list::CursorMut",
                      "current"
                    |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let _ := M.is_struct_tuple (| γ, "core::option::Option::None" |) in
                          M.SubPointer.get_struct_record_field (|
                            M.deref (|
                              M.read (|
                                M.SubPointer.get_struct_record_field (|
                                  M.deref (| M.read (| self |) |),
                                  "alloc::collections::linked_list::CursorMut",
                                  "list"
                                |)
                              |)
                            |),
                            "alloc::collections::linked_list::LinkedList",
                            "tail"
                          |)));
                      fun γ =>
                        ltac:(M.monadic
                          (let γ0_0 :=
                            M.SubPointer.get_struct_tuple_field (|
                              γ,
                              "core::option::Option::Some",
                              0
                            |) in
                          let current := M.copy (| γ0_0 |) in
                          M.SubPointer.get_struct_record_field (|
                            M.deref (|
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "&")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "alloc::collections::linked_list::Node")
                                      []
                                      [ T ]
                                  ],
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "core::ptr::non_null::NonNull")
                                    []
                                    [
                                      Ty.apply
                                        (Ty.path "alloc::collections::linked_list::Node")
                                        []
                                        [ T ]
                                    ],
                                  "as_ref",
                                  [],
                                  []
                                |),
                                [ M.borrow (| Pointer.Kind.Ref, current |) ]
                              |)
                            |),
                            "alloc::collections::linked_list::Node",
                            "prev"
                          |)))
                    ]
                  |)
                |) in
              M.alloc (|
                M.call_closure (|
                  Ty.apply
                    (Ty.path "core::option::Option")
                    []
                    [ Ty.apply (Ty.path "&mut") [] [ T ] ],
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "core::option::Option")
                      []
                      [
                        Ty.apply
                          (Ty.path "core::ptr::non_null::NonNull")
                          []
                          [ Ty.apply (Ty.path "alloc::collections::linked_list::Node") [] [ T ] ]
                      ],
                    "map",
                    [],
                    [
                      Ty.apply (Ty.path "&mut") [] [ T ];
                      Ty.function
                        [
                          Ty.tuple
                            [
                              Ty.apply
                                (Ty.path "core::ptr::non_null::NonNull")
                                []
                                [
                                  Ty.apply
                                    (Ty.path "alloc::collections::linked_list::Node")
                                    []
                                    [ T ]
                                ]
                            ]
                        ]
                        (Ty.apply (Ty.path "&mut") [] [ T ])
                    ]
                  |),
                  [
                    M.read (| prev |);
                    M.closure
                      (fun γ =>
                        ltac:(M.monadic
                          match γ with
                          | [ α0 ] =>
                            ltac:(M.monadic
                              (M.match_operator (|
                                Some
                                  (Ty.function
                                    [
                                      Ty.tuple
                                        [
                                          Ty.apply
                                            (Ty.path "core::ptr::non_null::NonNull")
                                            []
                                            [
                                              Ty.apply
                                                (Ty.path "alloc::collections::linked_list::Node")
                                                []
                                                [ T ]
                                            ]
                                        ]
                                    ]
                                    (Ty.apply (Ty.path "&mut") [] [ T ])),
                                M.alloc (| α0 |),
                                [
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let prev := M.copy (| γ |) in
                                      M.borrow (|
                                        Pointer.Kind.MutRef,
                                        M.SubPointer.get_struct_record_field (|
                                          M.deref (|
                                            M.call_closure (|
                                              Ty.apply
                                                (Ty.path "*mut")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path
                                                      "alloc::collections::linked_list::Node")
                                                    []
                                                    [ T ]
                                                ],
                                              M.get_associated_function (|
                                                Ty.apply
                                                  (Ty.path "core::ptr::non_null::NonNull")
                                                  []
                                                  [
                                                    Ty.apply
                                                      (Ty.path
                                                        "alloc::collections::linked_list::Node")
                                                      []
                                                      [ T ]
                                                  ],
                                                "as_ptr",
                                                [],
                                                []
                                              |),
                                              [ M.read (| prev |) ]
                                            |)
                                          |),
                                          "alloc::collections::linked_list::Node",
                                          "element"
                                        |)
                                      |)))
                                ]
                              |)))
                          | _ => M.impossible "wrong number of arguments"
                          end))
                  ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_peek_prev :
        forall (T A : Ty.t),
        M.IsAssociatedFunction.C (Self T A) "peek_prev" (peek_prev T A).
      Admitted.
      Global Typeclasses Opaque peek_prev.
      
      (*
          pub fn as_cursor(&self) -> Cursor<'_, T, A> {
              Cursor { list: self.list, current: self.current, index: self.index }
          }
      *)
      Definition as_cursor (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructRecord
              "alloc::collections::linked_list::Cursor"
              [
                ("list",
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.read (|
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "alloc::collections::linked_list::CursorMut",
                          "list"
                        |)
                      |)
                    |)
                  |));
                ("current",
                  M.read (|
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| self |) |),
                      "alloc::collections::linked_list::CursorMut",
                      "current"
                    |)
                  |));
                ("index",
                  M.read (|
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| self |) |),
                      "alloc::collections::linked_list::CursorMut",
                      "index"
                    |)
                  |))
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_as_cursor :
        forall (T A : Ty.t),
        M.IsAssociatedFunction.C (Self T A) "as_cursor" (as_cursor T A).
      Admitted.
      Global Typeclasses Opaque as_cursor.
      
      (*
          pub fn as_list(&self) -> &LinkedList<T, A> {
              self.list
          }
      *)
      Definition as_list (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.borrow (|
              Pointer.Kind.Ref,
              M.deref (|
                M.read (|
                  M.SubPointer.get_struct_record_field (|
                    M.deref (| M.read (| self |) |),
                    "alloc::collections::linked_list::CursorMut",
                    "list"
                  |)
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_as_list :
        forall (T A : Ty.t),
        M.IsAssociatedFunction.C (Self T A) "as_list" (as_list T A).
      Admitted.
      Global Typeclasses Opaque as_list.
      (*
          pub fn insert_after(&mut self, item: T) {
              unsafe {
                  let spliced_node = Box::leak(Box::new_in(Node::new(item), &self.list.alloc)).into();
                  let node_next = match self.current {
                      None => self.list.head,
                      Some(node) => node.as_ref().next,
                  };
                  self.list.splice_nodes(self.current, node_next, spliced_node, spliced_node, 1);
                  if self.current.is_none() {
                      // The "ghost" non-element's index has changed.
                      self.index = self.list.len;
                  }
              }
          }
      *)
      Definition insert_after
          (T A : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self T A in
        match ε, τ, α with
        | [], [], [ self; item ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let item := M.alloc (| item |) in
            M.read (|
              let~ spliced_node :
                  Ty.apply
                    (Ty.path "core::ptr::non_null::NonNull")
                    []
                    [ Ty.apply (Ty.path "alloc::collections::linked_list::Node") [] [ T ] ] :=
                M.alloc (|
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "core::ptr::non_null::NonNull")
                      []
                      [ Ty.apply (Ty.path "alloc::collections::linked_list::Node") [] [ T ] ],
                    M.get_trait_method (|
                      "core::convert::Into",
                      Ty.apply
                        (Ty.path "&mut")
                        []
                        [ Ty.apply (Ty.path "alloc::collections::linked_list::Node") [] [ T ] ],
                      [],
                      [
                        Ty.apply
                          (Ty.path "core::ptr::non_null::NonNull")
                          []
                          [ Ty.apply (Ty.path "alloc::collections::linked_list::Node") [] [ T ] ]
                      ],
                      "into",
                      [],
                      []
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.MutRef,
                        M.deref (|
                          M.call_closure (|
                            Ty.apply
                              (Ty.path "&mut")
                              []
                              [ Ty.apply (Ty.path "alloc::collections::linked_list::Node") [] [ T ]
                              ],
                            M.get_associated_function (|
                              Ty.apply
                                (Ty.path "alloc::boxed::Box")
                                []
                                [
                                  Ty.apply
                                    (Ty.path "alloc::collections::linked_list::Node")
                                    []
                                    [ T ];
                                  Ty.apply (Ty.path "&") [] [ A ]
                                ],
                              "leak",
                              [],
                              []
                            |),
                            [
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "alloc::boxed::Box")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "alloc::collections::linked_list::Node")
                                      []
                                      [ T ];
                                    Ty.apply (Ty.path "&") [] [ A ]
                                  ],
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "alloc::boxed::Box")
                                    []
                                    [
                                      Ty.apply
                                        (Ty.path "alloc::collections::linked_list::Node")
                                        []
                                        [ T ];
                                      Ty.apply (Ty.path "&") [] [ A ]
                                    ],
                                  "new_in",
                                  [],
                                  []
                                |),
                                [
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "alloc::collections::linked_list::Node")
                                      []
                                      [ T ],
                                    M.get_associated_function (|
                                      Ty.apply
                                        (Ty.path "alloc::collections::linked_list::Node")
                                        []
                                        [ T ],
                                      "new",
                                      [],
                                      []
                                    |),
                                    [ M.read (| item |) ]
                                  |);
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.SubPointer.get_struct_record_field (|
                                      M.deref (|
                                        M.read (|
                                          M.SubPointer.get_struct_record_field (|
                                            M.deref (| M.read (| self |) |),
                                            "alloc::collections::linked_list::CursorMut",
                                            "list"
                                          |)
                                        |)
                                      |),
                                      "alloc::collections::linked_list::LinkedList",
                                      "alloc"
                                    |)
                                  |)
                                ]
                              |)
                            ]
                          |)
                        |)
                      |)
                    ]
                  |)
                |) in
              let~ node_next :
                  Ty.apply
                    (Ty.path "core::option::Option")
                    []
                    [
                      Ty.apply
                        (Ty.path "core::ptr::non_null::NonNull")
                        []
                        [ Ty.apply (Ty.path "alloc::collections::linked_list::Node") [] [ T ] ]
                    ] :=
                M.copy (|
                  M.match_operator (|
                    Some
                      (Ty.apply
                        (Ty.path "core::option::Option")
                        []
                        [
                          Ty.apply
                            (Ty.path "core::ptr::non_null::NonNull")
                            []
                            [ Ty.apply (Ty.path "alloc::collections::linked_list::Node") [] [ T ] ]
                        ]),
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| self |) |),
                      "alloc::collections::linked_list::CursorMut",
                      "current"
                    |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let _ := M.is_struct_tuple (| γ, "core::option::Option::None" |) in
                          M.SubPointer.get_struct_record_field (|
                            M.deref (|
                              M.read (|
                                M.SubPointer.get_struct_record_field (|
                                  M.deref (| M.read (| self |) |),
                                  "alloc::collections::linked_list::CursorMut",
                                  "list"
                                |)
                              |)
                            |),
                            "alloc::collections::linked_list::LinkedList",
                            "head"
                          |)));
                      fun γ =>
                        ltac:(M.monadic
                          (let γ0_0 :=
                            M.SubPointer.get_struct_tuple_field (|
                              γ,
                              "core::option::Option::Some",
                              0
                            |) in
                          let node := M.copy (| γ0_0 |) in
                          M.SubPointer.get_struct_record_field (|
                            M.deref (|
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "&")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "alloc::collections::linked_list::Node")
                                      []
                                      [ T ]
                                  ],
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "core::ptr::non_null::NonNull")
                                    []
                                    [
                                      Ty.apply
                                        (Ty.path "alloc::collections::linked_list::Node")
                                        []
                                        [ T ]
                                    ],
                                  "as_ref",
                                  [],
                                  []
                                |),
                                [ M.borrow (| Pointer.Kind.Ref, node |) ]
                              |)
                            |),
                            "alloc::collections::linked_list::Node",
                            "next"
                          |)))
                    ]
                  |)
                |) in
              let~ _ : Ty.tuple [] :=
                M.alloc (|
                  M.call_closure (|
                    Ty.tuple [],
                    M.get_associated_function (|
                      Ty.apply (Ty.path "alloc::collections::linked_list::LinkedList") [] [ T; A ],
                      "splice_nodes",
                      [],
                      []
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.MutRef,
                        M.deref (|
                          M.read (|
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| self |) |),
                              "alloc::collections::linked_list::CursorMut",
                              "list"
                            |)
                          |)
                        |)
                      |);
                      M.read (|
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "alloc::collections::linked_list::CursorMut",
                          "current"
                        |)
                      |);
                      M.read (| node_next |);
                      M.read (| spliced_node |);
                      M.read (| spliced_node |);
                      Value.Integer IntegerKind.Usize 1
                    ]
                  |)
                |) in
              M.match_operator (|
                Some (Ty.tuple []),
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            M.call_closure (|
                              Ty.path "bool",
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "core::option::Option")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "core::ptr::non_null::NonNull")
                                      []
                                      [
                                        Ty.apply
                                          (Ty.path "alloc::collections::linked_list::Node")
                                          []
                                          [ T ]
                                      ]
                                  ],
                                "is_none",
                                [],
                                []
                              |),
                              [
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.SubPointer.get_struct_record_field (|
                                    M.deref (| M.read (| self |) |),
                                    "alloc::collections::linked_list::CursorMut",
                                    "current"
                                  |)
                                |)
                              ]
                            |)
                          |)) in
                      let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      let~ _ : Ty.tuple [] :=
                        M.alloc (|
                          M.write (|
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| self |) |),
                              "alloc::collections::linked_list::CursorMut",
                              "index"
                            |),
                            M.read (|
                              M.SubPointer.get_struct_record_field (|
                                M.deref (|
                                  M.read (|
                                    M.SubPointer.get_struct_record_field (|
                                      M.deref (| M.read (| self |) |),
                                      "alloc::collections::linked_list::CursorMut",
                                      "list"
                                    |)
                                  |)
                                |),
                                "alloc::collections::linked_list::LinkedList",
                                "len"
                              |)
                            |)
                          |)
                        |) in
                      M.alloc (| Value.Tuple [] |)));
                  fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_insert_after :
        forall (T A : Ty.t),
        M.IsAssociatedFunction.C (Self T A) "insert_after" (insert_after T A).
      Admitted.
      Global Typeclasses Opaque insert_after.
      
      (*
          pub fn insert_before(&mut self, item: T) {
              unsafe {
                  let spliced_node = Box::leak(Box::new_in(Node::new(item), &self.list.alloc)).into();
                  let node_prev = match self.current {
                      None => self.list.tail,
                      Some(node) => node.as_ref().prev,
                  };
                  self.list.splice_nodes(node_prev, self.current, spliced_node, spliced_node, 1);
                  self.index += 1;
              }
          }
      *)
      Definition insert_before
          (T A : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self T A in
        match ε, τ, α with
        | [], [], [ self; item ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let item := M.alloc (| item |) in
            M.read (|
              let~ spliced_node :
                  Ty.apply
                    (Ty.path "core::ptr::non_null::NonNull")
                    []
                    [ Ty.apply (Ty.path "alloc::collections::linked_list::Node") [] [ T ] ] :=
                M.alloc (|
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "core::ptr::non_null::NonNull")
                      []
                      [ Ty.apply (Ty.path "alloc::collections::linked_list::Node") [] [ T ] ],
                    M.get_trait_method (|
                      "core::convert::Into",
                      Ty.apply
                        (Ty.path "&mut")
                        []
                        [ Ty.apply (Ty.path "alloc::collections::linked_list::Node") [] [ T ] ],
                      [],
                      [
                        Ty.apply
                          (Ty.path "core::ptr::non_null::NonNull")
                          []
                          [ Ty.apply (Ty.path "alloc::collections::linked_list::Node") [] [ T ] ]
                      ],
                      "into",
                      [],
                      []
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.MutRef,
                        M.deref (|
                          M.call_closure (|
                            Ty.apply
                              (Ty.path "&mut")
                              []
                              [ Ty.apply (Ty.path "alloc::collections::linked_list::Node") [] [ T ]
                              ],
                            M.get_associated_function (|
                              Ty.apply
                                (Ty.path "alloc::boxed::Box")
                                []
                                [
                                  Ty.apply
                                    (Ty.path "alloc::collections::linked_list::Node")
                                    []
                                    [ T ];
                                  Ty.apply (Ty.path "&") [] [ A ]
                                ],
                              "leak",
                              [],
                              []
                            |),
                            [
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "alloc::boxed::Box")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "alloc::collections::linked_list::Node")
                                      []
                                      [ T ];
                                    Ty.apply (Ty.path "&") [] [ A ]
                                  ],
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "alloc::boxed::Box")
                                    []
                                    [
                                      Ty.apply
                                        (Ty.path "alloc::collections::linked_list::Node")
                                        []
                                        [ T ];
                                      Ty.apply (Ty.path "&") [] [ A ]
                                    ],
                                  "new_in",
                                  [],
                                  []
                                |),
                                [
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "alloc::collections::linked_list::Node")
                                      []
                                      [ T ],
                                    M.get_associated_function (|
                                      Ty.apply
                                        (Ty.path "alloc::collections::linked_list::Node")
                                        []
                                        [ T ],
                                      "new",
                                      [],
                                      []
                                    |),
                                    [ M.read (| item |) ]
                                  |);
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.SubPointer.get_struct_record_field (|
                                      M.deref (|
                                        M.read (|
                                          M.SubPointer.get_struct_record_field (|
                                            M.deref (| M.read (| self |) |),
                                            "alloc::collections::linked_list::CursorMut",
                                            "list"
                                          |)
                                        |)
                                      |),
                                      "alloc::collections::linked_list::LinkedList",
                                      "alloc"
                                    |)
                                  |)
                                ]
                              |)
                            ]
                          |)
                        |)
                      |)
                    ]
                  |)
                |) in
              let~ node_prev :
                  Ty.apply
                    (Ty.path "core::option::Option")
                    []
                    [
                      Ty.apply
                        (Ty.path "core::ptr::non_null::NonNull")
                        []
                        [ Ty.apply (Ty.path "alloc::collections::linked_list::Node") [] [ T ] ]
                    ] :=
                M.copy (|
                  M.match_operator (|
                    Some
                      (Ty.apply
                        (Ty.path "core::option::Option")
                        []
                        [
                          Ty.apply
                            (Ty.path "core::ptr::non_null::NonNull")
                            []
                            [ Ty.apply (Ty.path "alloc::collections::linked_list::Node") [] [ T ] ]
                        ]),
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| self |) |),
                      "alloc::collections::linked_list::CursorMut",
                      "current"
                    |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let _ := M.is_struct_tuple (| γ, "core::option::Option::None" |) in
                          M.SubPointer.get_struct_record_field (|
                            M.deref (|
                              M.read (|
                                M.SubPointer.get_struct_record_field (|
                                  M.deref (| M.read (| self |) |),
                                  "alloc::collections::linked_list::CursorMut",
                                  "list"
                                |)
                              |)
                            |),
                            "alloc::collections::linked_list::LinkedList",
                            "tail"
                          |)));
                      fun γ =>
                        ltac:(M.monadic
                          (let γ0_0 :=
                            M.SubPointer.get_struct_tuple_field (|
                              γ,
                              "core::option::Option::Some",
                              0
                            |) in
                          let node := M.copy (| γ0_0 |) in
                          M.SubPointer.get_struct_record_field (|
                            M.deref (|
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "&")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "alloc::collections::linked_list::Node")
                                      []
                                      [ T ]
                                  ],
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "core::ptr::non_null::NonNull")
                                    []
                                    [
                                      Ty.apply
                                        (Ty.path "alloc::collections::linked_list::Node")
                                        []
                                        [ T ]
                                    ],
                                  "as_ref",
                                  [],
                                  []
                                |),
                                [ M.borrow (| Pointer.Kind.Ref, node |) ]
                              |)
                            |),
                            "alloc::collections::linked_list::Node",
                            "prev"
                          |)))
                    ]
                  |)
                |) in
              let~ _ : Ty.tuple [] :=
                M.alloc (|
                  M.call_closure (|
                    Ty.tuple [],
                    M.get_associated_function (|
                      Ty.apply (Ty.path "alloc::collections::linked_list::LinkedList") [] [ T; A ],
                      "splice_nodes",
                      [],
                      []
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.MutRef,
                        M.deref (|
                          M.read (|
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| self |) |),
                              "alloc::collections::linked_list::CursorMut",
                              "list"
                            |)
                          |)
                        |)
                      |);
                      M.read (| node_prev |);
                      M.read (|
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "alloc::collections::linked_list::CursorMut",
                          "current"
                        |)
                      |);
                      M.read (| spliced_node |);
                      M.read (| spliced_node |);
                      Value.Integer IntegerKind.Usize 1
                    ]
                  |)
                |) in
              let~ _ : Ty.tuple [] :=
                M.alloc (|
                  let β :=
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| self |) |),
                      "alloc::collections::linked_list::CursorMut",
                      "index"
                    |) in
                  M.write (|
                    β,
                    M.call_closure (|
                      Ty.path "usize",
                      BinOp.Wrap.add,
                      [ M.read (| β |); Value.Integer IntegerKind.Usize 1 ]
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_insert_before :
        forall (T A : Ty.t),
        M.IsAssociatedFunction.C (Self T A) "insert_before" (insert_before T A).
      Admitted.
      Global Typeclasses Opaque insert_before.
      
      (*
          pub fn remove_current(&mut self) -> Option<T> {
              let unlinked_node = self.current?;
              unsafe {
                  self.current = unlinked_node.as_ref().next;
                  self.list.unlink_node(unlinked_node);
                  let unlinked_node = Box::from_raw_in(unlinked_node.as_ptr(), &self.list.alloc);
                  Some(unlinked_node.element)
              }
          }
      *)
      Definition remove_current
          (T A : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self T A in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.read (|
                  let~ unlinked_node :
                      Ty.apply
                        (Ty.path "core::ptr::non_null::NonNull")
                        []
                        [ Ty.apply (Ty.path "alloc::collections::linked_list::Node") [] [ T ] ] :=
                    M.copy (|
                      M.match_operator (|
                        Some
                          (Ty.apply
                            (Ty.path "core::ptr::non_null::NonNull")
                            []
                            [ Ty.apply (Ty.path "alloc::collections::linked_list::Node") [] [ T ]
                            ]),
                        M.alloc (|
                          M.call_closure (|
                            Ty.apply
                              (Ty.path "core::ops::control_flow::ControlFlow")
                              []
                              [
                                Ty.apply
                                  (Ty.path "core::option::Option")
                                  []
                                  [ Ty.path "core::convert::Infallible" ];
                                Ty.apply
                                  (Ty.path "core::ptr::non_null::NonNull")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "alloc::collections::linked_list::Node")
                                      []
                                      [ T ]
                                  ]
                              ],
                            M.get_trait_method (|
                              "core::ops::try_trait::Try",
                              Ty.apply
                                (Ty.path "core::option::Option")
                                []
                                [
                                  Ty.apply
                                    (Ty.path "core::ptr::non_null::NonNull")
                                    []
                                    [
                                      Ty.apply
                                        (Ty.path "alloc::collections::linked_list::Node")
                                        []
                                        [ T ]
                                    ]
                                ],
                              [],
                              [],
                              "branch",
                              [],
                              []
                            |),
                            [
                              M.read (|
                                M.SubPointer.get_struct_record_field (|
                                  M.deref (| M.read (| self |) |),
                                  "alloc::collections::linked_list::CursorMut",
                                  "current"
                                |)
                              |)
                            ]
                          |)
                        |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 :=
                                M.SubPointer.get_struct_tuple_field (|
                                  γ,
                                  "core::ops::control_flow::ControlFlow::Break",
                                  0
                                |) in
                              let residual := M.copy (| γ0_0 |) in
                              M.alloc (|
                                M.never_to_any (|
                                  M.read (|
                                    M.return_ (|
                                      M.call_closure (|
                                        Ty.apply (Ty.path "core::option::Option") [] [ T ],
                                        M.get_trait_method (|
                                          "core::ops::try_trait::FromResidual",
                                          Ty.apply (Ty.path "core::option::Option") [] [ T ],
                                          [],
                                          [
                                            Ty.apply
                                              (Ty.path "core::option::Option")
                                              []
                                              [ Ty.path "core::convert::Infallible" ]
                                          ],
                                          "from_residual",
                                          [],
                                          []
                                        |),
                                        [ M.read (| residual |) ]
                                      |)
                                    |)
                                  |)
                                |)
                              |)));
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 :=
                                M.SubPointer.get_struct_tuple_field (|
                                  γ,
                                  "core::ops::control_flow::ControlFlow::Continue",
                                  0
                                |) in
                              let val := M.copy (| γ0_0 |) in
                              val))
                        ]
                      |)
                    |) in
                  let~ _ : Ty.tuple [] :=
                    M.alloc (|
                      M.write (|
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "alloc::collections::linked_list::CursorMut",
                          "current"
                        |),
                        M.read (|
                          M.SubPointer.get_struct_record_field (|
                            M.deref (|
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "&")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "alloc::collections::linked_list::Node")
                                      []
                                      [ T ]
                                  ],
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "core::ptr::non_null::NonNull")
                                    []
                                    [
                                      Ty.apply
                                        (Ty.path "alloc::collections::linked_list::Node")
                                        []
                                        [ T ]
                                    ],
                                  "as_ref",
                                  [],
                                  []
                                |),
                                [ M.borrow (| Pointer.Kind.Ref, unlinked_node |) ]
                              |)
                            |),
                            "alloc::collections::linked_list::Node",
                            "next"
                          |)
                        |)
                      |)
                    |) in
                  let~ _ : Ty.tuple [] :=
                    M.alloc (|
                      M.call_closure (|
                        Ty.tuple [],
                        M.get_associated_function (|
                          Ty.apply
                            (Ty.path "alloc::collections::linked_list::LinkedList")
                            []
                            [ T; A ],
                          "unlink_node",
                          [],
                          []
                        |),
                        [
                          M.borrow (|
                            Pointer.Kind.MutRef,
                            M.deref (|
                              M.read (|
                                M.SubPointer.get_struct_record_field (|
                                  M.deref (| M.read (| self |) |),
                                  "alloc::collections::linked_list::CursorMut",
                                  "list"
                                |)
                              |)
                            |)
                          |);
                          M.read (| unlinked_node |)
                        ]
                      |)
                    |) in
                  let~ unlinked_node :
                      Ty.apply
                        (Ty.path "alloc::boxed::Box")
                        []
                        [
                          Ty.apply (Ty.path "alloc::collections::linked_list::Node") [] [ T ];
                          Ty.apply (Ty.path "&") [] [ A ]
                        ] :=
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "alloc::boxed::Box")
                          []
                          [
                            Ty.apply (Ty.path "alloc::collections::linked_list::Node") [] [ T ];
                            Ty.apply (Ty.path "&") [] [ A ]
                          ],
                        M.get_associated_function (|
                          Ty.apply
                            (Ty.path "alloc::boxed::Box")
                            []
                            [
                              Ty.apply (Ty.path "alloc::collections::linked_list::Node") [] [ T ];
                              Ty.apply (Ty.path "&") [] [ A ]
                            ],
                          "from_raw_in",
                          [],
                          []
                        |),
                        [
                          M.call_closure (|
                            Ty.apply
                              (Ty.path "*mut")
                              []
                              [ Ty.apply (Ty.path "alloc::collections::linked_list::Node") [] [ T ]
                              ],
                            M.get_associated_function (|
                              Ty.apply
                                (Ty.path "core::ptr::non_null::NonNull")
                                []
                                [
                                  Ty.apply
                                    (Ty.path "alloc::collections::linked_list::Node")
                                    []
                                    [ T ]
                                ],
                              "as_ptr",
                              [],
                              []
                            |),
                            [ M.read (| unlinked_node |) ]
                          |);
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.SubPointer.get_struct_record_field (|
                              M.deref (|
                                M.read (|
                                  M.SubPointer.get_struct_record_field (|
                                    M.deref (| M.read (| self |) |),
                                    "alloc::collections::linked_list::CursorMut",
                                    "list"
                                  |)
                                |)
                              |),
                              "alloc::collections::linked_list::LinkedList",
                              "alloc"
                            |)
                          |)
                        ]
                      |)
                    |) in
                  M.alloc (|
                    Value.StructTuple
                      "core::option::Option::Some"
                      [
                        M.read (|
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| unlinked_node |) |),
                            "alloc::collections::linked_list::Node",
                            "element"
                          |)
                        |)
                      ]
                  |)
                |)))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_remove_current :
        forall (T A : Ty.t),
        M.IsAssociatedFunction.C (Self T A) "remove_current" (remove_current T A).
      Admitted.
      Global Typeclasses Opaque remove_current.
      
      (*
          pub fn remove_current_as_list(&mut self) -> Option<LinkedList<T, A>>
          where
              A: Clone,
          {
              let mut unlinked_node = self.current?;
              unsafe {
                  self.current = unlinked_node.as_ref().next;
                  self.list.unlink_node(unlinked_node);
      
                  unlinked_node.as_mut().prev = None;
                  unlinked_node.as_mut().next = None;
                  Some(LinkedList {
                      head: Some(unlinked_node),
                      tail: Some(unlinked_node),
                      len: 1,
                      alloc: self.list.alloc.clone(),
                      marker: PhantomData,
                  })
              }
          }
      *)
      Definition remove_current_as_list
          (T A : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self T A in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.read (|
                  let~ unlinked_node :
                      Ty.apply
                        (Ty.path "core::ptr::non_null::NonNull")
                        []
                        [ Ty.apply (Ty.path "alloc::collections::linked_list::Node") [] [ T ] ] :=
                    M.copy (|
                      M.match_operator (|
                        Some
                          (Ty.apply
                            (Ty.path "core::ptr::non_null::NonNull")
                            []
                            [ Ty.apply (Ty.path "alloc::collections::linked_list::Node") [] [ T ]
                            ]),
                        M.alloc (|
                          M.call_closure (|
                            Ty.apply
                              (Ty.path "core::ops::control_flow::ControlFlow")
                              []
                              [
                                Ty.apply
                                  (Ty.path "core::option::Option")
                                  []
                                  [ Ty.path "core::convert::Infallible" ];
                                Ty.apply
                                  (Ty.path "core::ptr::non_null::NonNull")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "alloc::collections::linked_list::Node")
                                      []
                                      [ T ]
                                  ]
                              ],
                            M.get_trait_method (|
                              "core::ops::try_trait::Try",
                              Ty.apply
                                (Ty.path "core::option::Option")
                                []
                                [
                                  Ty.apply
                                    (Ty.path "core::ptr::non_null::NonNull")
                                    []
                                    [
                                      Ty.apply
                                        (Ty.path "alloc::collections::linked_list::Node")
                                        []
                                        [ T ]
                                    ]
                                ],
                              [],
                              [],
                              "branch",
                              [],
                              []
                            |),
                            [
                              M.read (|
                                M.SubPointer.get_struct_record_field (|
                                  M.deref (| M.read (| self |) |),
                                  "alloc::collections::linked_list::CursorMut",
                                  "current"
                                |)
                              |)
                            ]
                          |)
                        |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 :=
                                M.SubPointer.get_struct_tuple_field (|
                                  γ,
                                  "core::ops::control_flow::ControlFlow::Break",
                                  0
                                |) in
                              let residual := M.copy (| γ0_0 |) in
                              M.alloc (|
                                M.never_to_any (|
                                  M.read (|
                                    M.return_ (|
                                      M.call_closure (|
                                        Ty.apply
                                          (Ty.path "core::option::Option")
                                          []
                                          [
                                            Ty.apply
                                              (Ty.path
                                                "alloc::collections::linked_list::LinkedList")
                                              []
                                              [ T; A ]
                                          ],
                                        M.get_trait_method (|
                                          "core::ops::try_trait::FromResidual",
                                          Ty.apply
                                            (Ty.path "core::option::Option")
                                            []
                                            [
                                              Ty.apply
                                                (Ty.path
                                                  "alloc::collections::linked_list::LinkedList")
                                                []
                                                [ T; A ]
                                            ],
                                          [],
                                          [
                                            Ty.apply
                                              (Ty.path "core::option::Option")
                                              []
                                              [ Ty.path "core::convert::Infallible" ]
                                          ],
                                          "from_residual",
                                          [],
                                          []
                                        |),
                                        [ M.read (| residual |) ]
                                      |)
                                    |)
                                  |)
                                |)
                              |)));
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 :=
                                M.SubPointer.get_struct_tuple_field (|
                                  γ,
                                  "core::ops::control_flow::ControlFlow::Continue",
                                  0
                                |) in
                              let val := M.copy (| γ0_0 |) in
                              val))
                        ]
                      |)
                    |) in
                  let~ _ : Ty.tuple [] :=
                    M.alloc (|
                      M.write (|
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "alloc::collections::linked_list::CursorMut",
                          "current"
                        |),
                        M.read (|
                          M.SubPointer.get_struct_record_field (|
                            M.deref (|
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "&")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "alloc::collections::linked_list::Node")
                                      []
                                      [ T ]
                                  ],
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "core::ptr::non_null::NonNull")
                                    []
                                    [
                                      Ty.apply
                                        (Ty.path "alloc::collections::linked_list::Node")
                                        []
                                        [ T ]
                                    ],
                                  "as_ref",
                                  [],
                                  []
                                |),
                                [ M.borrow (| Pointer.Kind.Ref, unlinked_node |) ]
                              |)
                            |),
                            "alloc::collections::linked_list::Node",
                            "next"
                          |)
                        |)
                      |)
                    |) in
                  let~ _ : Ty.tuple [] :=
                    M.alloc (|
                      M.call_closure (|
                        Ty.tuple [],
                        M.get_associated_function (|
                          Ty.apply
                            (Ty.path "alloc::collections::linked_list::LinkedList")
                            []
                            [ T; A ],
                          "unlink_node",
                          [],
                          []
                        |),
                        [
                          M.borrow (|
                            Pointer.Kind.MutRef,
                            M.deref (|
                              M.read (|
                                M.SubPointer.get_struct_record_field (|
                                  M.deref (| M.read (| self |) |),
                                  "alloc::collections::linked_list::CursorMut",
                                  "list"
                                |)
                              |)
                            |)
                          |);
                          M.read (| unlinked_node |)
                        ]
                      |)
                    |) in
                  let~ _ : Ty.tuple [] :=
                    M.alloc (|
                      M.write (|
                        M.SubPointer.get_struct_record_field (|
                          M.deref (|
                            M.call_closure (|
                              Ty.apply
                                (Ty.path "&mut")
                                []
                                [
                                  Ty.apply
                                    (Ty.path "alloc::collections::linked_list::Node")
                                    []
                                    [ T ]
                                ],
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "core::ptr::non_null::NonNull")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "alloc::collections::linked_list::Node")
                                      []
                                      [ T ]
                                  ],
                                "as_mut",
                                [],
                                []
                              |),
                              [ M.borrow (| Pointer.Kind.MutRef, unlinked_node |) ]
                            |)
                          |),
                          "alloc::collections::linked_list::Node",
                          "prev"
                        |),
                        Value.StructTuple "core::option::Option::None" []
                      |)
                    |) in
                  let~ _ : Ty.tuple [] :=
                    M.alloc (|
                      M.write (|
                        M.SubPointer.get_struct_record_field (|
                          M.deref (|
                            M.call_closure (|
                              Ty.apply
                                (Ty.path "&mut")
                                []
                                [
                                  Ty.apply
                                    (Ty.path "alloc::collections::linked_list::Node")
                                    []
                                    [ T ]
                                ],
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "core::ptr::non_null::NonNull")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "alloc::collections::linked_list::Node")
                                      []
                                      [ T ]
                                  ],
                                "as_mut",
                                [],
                                []
                              |),
                              [ M.borrow (| Pointer.Kind.MutRef, unlinked_node |) ]
                            |)
                          |),
                          "alloc::collections::linked_list::Node",
                          "next"
                        |),
                        Value.StructTuple "core::option::Option::None" []
                      |)
                    |) in
                  M.alloc (|
                    Value.StructTuple
                      "core::option::Option::Some"
                      [
                        Value.StructRecord
                          "alloc::collections::linked_list::LinkedList"
                          [
                            ("head",
                              Value.StructTuple
                                "core::option::Option::Some"
                                [ M.read (| unlinked_node |) ]);
                            ("tail",
                              Value.StructTuple
                                "core::option::Option::Some"
                                [ M.read (| unlinked_node |) ]);
                            ("len", Value.Integer IntegerKind.Usize 1);
                            ("alloc",
                              M.call_closure (|
                                A,
                                M.get_trait_method (|
                                  "core::clone::Clone",
                                  A,
                                  [],
                                  [],
                                  "clone",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.SubPointer.get_struct_record_field (|
                                      M.deref (|
                                        M.read (|
                                          M.SubPointer.get_struct_record_field (|
                                            M.deref (| M.read (| self |) |),
                                            "alloc::collections::linked_list::CursorMut",
                                            "list"
                                          |)
                                        |)
                                      |),
                                      "alloc::collections::linked_list::LinkedList",
                                      "alloc"
                                    |)
                                  |)
                                ]
                              |));
                            ("marker", Value.StructTuple "core::marker::PhantomData" [])
                          ]
                      ]
                  |)
                |)))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_remove_current_as_list :
        forall (T A : Ty.t),
        M.IsAssociatedFunction.C (Self T A) "remove_current_as_list" (remove_current_as_list T A).
      Admitted.
      Global Typeclasses Opaque remove_current_as_list.
      
      (*
          pub fn split_after(&mut self) -> LinkedList<T, A>
          where
              A: Clone,
          {
              let split_off_idx = if self.index == self.list.len { 0 } else { self.index + 1 };
              if self.index == self.list.len {
                  // The "ghost" non-element's index has changed to 0.
                  self.index = 0;
              }
              unsafe { self.list.split_off_after_node(self.current, split_off_idx) }
          }
      *)
      Definition split_after
          (T A : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self T A in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              let~ split_off_idx : Ty.path "usize" :=
                M.copy (|
                  M.match_operator (|
                    Some (Ty.path "usize"),
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                M.call_closure (|
                                  Ty.path "bool",
                                  BinOp.eq,
                                  [
                                    M.read (|
                                      M.SubPointer.get_struct_record_field (|
                                        M.deref (| M.read (| self |) |),
                                        "alloc::collections::linked_list::CursorMut",
                                        "index"
                                      |)
                                    |);
                                    M.read (|
                                      M.SubPointer.get_struct_record_field (|
                                        M.deref (|
                                          M.read (|
                                            M.SubPointer.get_struct_record_field (|
                                              M.deref (| M.read (| self |) |),
                                              "alloc::collections::linked_list::CursorMut",
                                              "list"
                                            |)
                                          |)
                                        |),
                                        "alloc::collections::linked_list::LinkedList",
                                        "len"
                                      |)
                                    |)
                                  ]
                                |)
                              |)) in
                          let _ :=
                            is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (| Value.Integer IntegerKind.Usize 0 |)));
                      fun γ =>
                        ltac:(M.monadic
                          (M.alloc (|
                            M.call_closure (|
                              Ty.path "usize",
                              BinOp.Wrap.add,
                              [
                                M.read (|
                                  M.SubPointer.get_struct_record_field (|
                                    M.deref (| M.read (| self |) |),
                                    "alloc::collections::linked_list::CursorMut",
                                    "index"
                                  |)
                                |);
                                Value.Integer IntegerKind.Usize 1
                              ]
                            |)
                          |)))
                    ]
                  |)
                |) in
              let~ _ : Ty.tuple [] :=
                M.match_operator (|
                  Some (Ty.tuple []),
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ :=
                          M.use
                            (M.alloc (|
                              M.call_closure (|
                                Ty.path "bool",
                                BinOp.eq,
                                [
                                  M.read (|
                                    M.SubPointer.get_struct_record_field (|
                                      M.deref (| M.read (| self |) |),
                                      "alloc::collections::linked_list::CursorMut",
                                      "index"
                                    |)
                                  |);
                                  M.read (|
                                    M.SubPointer.get_struct_record_field (|
                                      M.deref (|
                                        M.read (|
                                          M.SubPointer.get_struct_record_field (|
                                            M.deref (| M.read (| self |) |),
                                            "alloc::collections::linked_list::CursorMut",
                                            "list"
                                          |)
                                        |)
                                      |),
                                      "alloc::collections::linked_list::LinkedList",
                                      "len"
                                    |)
                                  |)
                                ]
                              |)
                            |)) in
                        let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        let~ _ : Ty.tuple [] :=
                          M.alloc (|
                            M.write (|
                              M.SubPointer.get_struct_record_field (|
                                M.deref (| M.read (| self |) |),
                                "alloc::collections::linked_list::CursorMut",
                                "index"
                              |),
                              Value.Integer IntegerKind.Usize 0
                            |)
                          |) in
                        M.alloc (| Value.Tuple [] |)));
                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                  ]
                |) in
              M.alloc (|
                M.call_closure (|
                  Ty.apply (Ty.path "alloc::collections::linked_list::LinkedList") [] [ T; A ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "alloc::collections::linked_list::LinkedList") [] [ T; A ],
                    "split_off_after_node",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.MutRef,
                      M.deref (|
                        M.read (|
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "alloc::collections::linked_list::CursorMut",
                            "list"
                          |)
                        |)
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "alloc::collections::linked_list::CursorMut",
                        "current"
                      |)
                    |);
                    M.read (| split_off_idx |)
                  ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_split_after :
        forall (T A : Ty.t),
        M.IsAssociatedFunction.C (Self T A) "split_after" (split_after T A).
      Admitted.
      Global Typeclasses Opaque split_after.
      
      (*
          pub fn split_before(&mut self) -> LinkedList<T, A>
          where
              A: Clone,
          {
              let split_off_idx = self.index;
              self.index = 0;
              unsafe { self.list.split_off_before_node(self.current, split_off_idx) }
          }
      *)
      Definition split_before
          (T A : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self T A in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              let~ split_off_idx : Ty.path "usize" :=
                M.copy (|
                  M.SubPointer.get_struct_record_field (|
                    M.deref (| M.read (| self |) |),
                    "alloc::collections::linked_list::CursorMut",
                    "index"
                  |)
                |) in
              let~ _ : Ty.tuple [] :=
                M.alloc (|
                  M.write (|
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| self |) |),
                      "alloc::collections::linked_list::CursorMut",
                      "index"
                    |),
                    Value.Integer IntegerKind.Usize 0
                  |)
                |) in
              M.alloc (|
                M.call_closure (|
                  Ty.apply (Ty.path "alloc::collections::linked_list::LinkedList") [] [ T; A ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "alloc::collections::linked_list::LinkedList") [] [ T; A ],
                    "split_off_before_node",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.MutRef,
                      M.deref (|
                        M.read (|
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "alloc::collections::linked_list::CursorMut",
                            "list"
                          |)
                        |)
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "alloc::collections::linked_list::CursorMut",
                        "current"
                      |)
                    |);
                    M.read (| split_off_idx |)
                  ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_split_before :
        forall (T A : Ty.t),
        M.IsAssociatedFunction.C (Self T A) "split_before" (split_before T A).
      Admitted.
      Global Typeclasses Opaque split_before.
      
      (*
          pub fn push_front(&mut self, elt: T) {
              // Safety: We know that `push_front` does not change the position in
              // memory of other nodes. This ensures that `self.current` remains
              // valid.
              self.list.push_front(elt);
              self.index += 1;
          }
      *)
      Definition push_front
          (T A : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self T A in
        match ε, τ, α with
        | [], [], [ self; elt ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let elt := M.alloc (| elt |) in
            M.read (|
              let~ _ : Ty.tuple [] :=
                M.alloc (|
                  M.call_closure (|
                    Ty.tuple [],
                    M.get_associated_function (|
                      Ty.apply (Ty.path "alloc::collections::linked_list::LinkedList") [] [ T; A ],
                      "push_front",
                      [],
                      []
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.MutRef,
                        M.deref (|
                          M.read (|
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| self |) |),
                              "alloc::collections::linked_list::CursorMut",
                              "list"
                            |)
                          |)
                        |)
                      |);
                      M.read (| elt |)
                    ]
                  |)
                |) in
              let~ _ : Ty.tuple [] :=
                M.alloc (|
                  let β :=
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| self |) |),
                      "alloc::collections::linked_list::CursorMut",
                      "index"
                    |) in
                  M.write (|
                    β,
                    M.call_closure (|
                      Ty.path "usize",
                      BinOp.Wrap.add,
                      [ M.read (| β |); Value.Integer IntegerKind.Usize 1 ]
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_push_front :
        forall (T A : Ty.t),
        M.IsAssociatedFunction.C (Self T A) "push_front" (push_front T A).
      Admitted.
      Global Typeclasses Opaque push_front.
      
      (*
          pub fn push_back(&mut self, elt: T) {
              // Safety: We know that `push_back` does not change the position in
              // memory of other nodes. This ensures that `self.current` remains
              // valid.
              self.list.push_back(elt);
              if self.current().is_none() {
                  // The index of "ghost" is the length of the list, so we just need
                  // to increment self.index to reflect the new length of the list.
                  self.index += 1;
              }
          }
      *)
      Definition push_back (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match ε, τ, α with
        | [], [], [ self; elt ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let elt := M.alloc (| elt |) in
            M.read (|
              let~ _ : Ty.tuple [] :=
                M.alloc (|
                  M.call_closure (|
                    Ty.tuple [],
                    M.get_associated_function (|
                      Ty.apply (Ty.path "alloc::collections::linked_list::LinkedList") [] [ T; A ],
                      "push_back",
                      [],
                      []
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.MutRef,
                        M.deref (|
                          M.read (|
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| self |) |),
                              "alloc::collections::linked_list::CursorMut",
                              "list"
                            |)
                          |)
                        |)
                      |);
                      M.read (| elt |)
                    ]
                  |)
                |) in
              M.match_operator (|
                Some (Ty.tuple []),
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            M.call_closure (|
                              Ty.path "bool",
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "core::option::Option")
                                  []
                                  [ Ty.apply (Ty.path "&mut") [] [ T ] ],
                                "is_none",
                                [],
                                []
                              |),
                              [
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.alloc (|
                                    M.call_closure (|
                                      Ty.apply
                                        (Ty.path "core::option::Option")
                                        []
                                        [ Ty.apply (Ty.path "&mut") [] [ T ] ],
                                      M.get_associated_function (|
                                        Ty.apply
                                          (Ty.path "alloc::collections::linked_list::CursorMut")
                                          []
                                          [ T; A ],
                                        "current",
                                        [],
                                        []
                                      |),
                                      [
                                        M.borrow (|
                                          Pointer.Kind.MutRef,
                                          M.deref (| M.read (| self |) |)
                                        |)
                                      ]
                                    |)
                                  |)
                                |)
                              ]
                            |)
                          |)) in
                      let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      let~ _ : Ty.tuple [] :=
                        M.alloc (|
                          let β :=
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| self |) |),
                              "alloc::collections::linked_list::CursorMut",
                              "index"
                            |) in
                          M.write (|
                            β,
                            M.call_closure (|
                              Ty.path "usize",
                              BinOp.Wrap.add,
                              [ M.read (| β |); Value.Integer IntegerKind.Usize 1 ]
                            |)
                          |)
                        |) in
                      M.alloc (| Value.Tuple [] |)));
                  fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_push_back :
        forall (T A : Ty.t),
        M.IsAssociatedFunction.C (Self T A) "push_back" (push_back T A).
      Admitted.
      Global Typeclasses Opaque push_back.
      
      (*
          pub fn pop_front(&mut self) -> Option<T> {
              // We can't check if current is empty, we must check the list directly.
              // It is possible for `self.current == None` and the list to be
              // non-empty.
              if self.list.is_empty() {
                  None
              } else {
                  // We can't point to the node that we pop. Copying the behavior of
                  // `remove_current`, we move on to the next node in the sequence.
                  // If the list is of length 1 then we end pointing to the "ghost"
                  // node at index 0, which is expected.
                  if self.list.head == self.current {
                      self.move_next();
                  } else {
                      self.index -= 1;
                  }
                  self.list.pop_front()
              }
          }
      *)
      Definition pop_front (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                Some (Ty.apply (Ty.path "core::option::Option") [] [ T ]),
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            M.call_closure (|
                              Ty.path "bool",
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "alloc::collections::linked_list::LinkedList")
                                  []
                                  [ T; A ],
                                "is_empty",
                                [],
                                []
                              |),
                              [
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.deref (|
                                    M.read (|
                                      M.SubPointer.get_struct_record_field (|
                                        M.deref (| M.read (| self |) |),
                                        "alloc::collections::linked_list::CursorMut",
                                        "list"
                                      |)
                                    |)
                                  |)
                                |)
                              ]
                            |)
                          |)) in
                      let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let~ _ : Ty.tuple [] :=
                        M.match_operator (|
                          Some (Ty.tuple []),
                          M.alloc (| Value.Tuple [] |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ :=
                                  M.use
                                    (M.alloc (|
                                      M.call_closure (|
                                        Ty.path "bool",
                                        M.get_trait_method (|
                                          "core::cmp::PartialEq",
                                          Ty.apply
                                            (Ty.path "core::option::Option")
                                            []
                                            [
                                              Ty.apply
                                                (Ty.path "core::ptr::non_null::NonNull")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path
                                                      "alloc::collections::linked_list::Node")
                                                    []
                                                    [ T ]
                                                ]
                                            ],
                                          [],
                                          [
                                            Ty.apply
                                              (Ty.path "core::option::Option")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "core::ptr::non_null::NonNull")
                                                  []
                                                  [
                                                    Ty.apply
                                                      (Ty.path
                                                        "alloc::collections::linked_list::Node")
                                                      []
                                                      [ T ]
                                                  ]
                                              ]
                                          ],
                                          "eq",
                                          [],
                                          []
                                        |),
                                        [
                                          M.borrow (|
                                            Pointer.Kind.Ref,
                                            M.SubPointer.get_struct_record_field (|
                                              M.deref (|
                                                M.read (|
                                                  M.SubPointer.get_struct_record_field (|
                                                    M.deref (| M.read (| self |) |),
                                                    "alloc::collections::linked_list::CursorMut",
                                                    "list"
                                                  |)
                                                |)
                                              |),
                                              "alloc::collections::linked_list::LinkedList",
                                              "head"
                                            |)
                                          |);
                                          M.borrow (|
                                            Pointer.Kind.Ref,
                                            M.SubPointer.get_struct_record_field (|
                                              M.deref (| M.read (| self |) |),
                                              "alloc::collections::linked_list::CursorMut",
                                              "current"
                                            |)
                                          |)
                                        ]
                                      |)
                                    |)) in
                                let _ :=
                                  is_constant_or_break_match (|
                                    M.read (| γ |),
                                    Value.Bool true
                                  |) in
                                let~ _ : Ty.tuple [] :=
                                  M.alloc (|
                                    M.call_closure (|
                                      Ty.tuple [],
                                      M.get_associated_function (|
                                        Ty.apply
                                          (Ty.path "alloc::collections::linked_list::CursorMut")
                                          []
                                          [ T; A ],
                                        "move_next",
                                        [],
                                        []
                                      |),
                                      [
                                        M.borrow (|
                                          Pointer.Kind.MutRef,
                                          M.deref (| M.read (| self |) |)
                                        |)
                                      ]
                                    |)
                                  |) in
                                M.alloc (| Value.Tuple [] |)));
                            fun γ =>
                              ltac:(M.monadic
                                (let~ _ : Ty.tuple [] :=
                                  M.alloc (|
                                    let β :=
                                      M.SubPointer.get_struct_record_field (|
                                        M.deref (| M.read (| self |) |),
                                        "alloc::collections::linked_list::CursorMut",
                                        "index"
                                      |) in
                                    M.write (|
                                      β,
                                      M.call_closure (|
                                        Ty.path "usize",
                                        BinOp.Wrap.sub,
                                        [ M.read (| β |); Value.Integer IntegerKind.Usize 1 ]
                                      |)
                                    |)
                                  |) in
                                M.alloc (| Value.Tuple [] |)))
                          ]
                        |) in
                      M.alloc (|
                        M.call_closure (|
                          Ty.apply (Ty.path "core::option::Option") [] [ T ],
                          M.get_associated_function (|
                            Ty.apply
                              (Ty.path "alloc::collections::linked_list::LinkedList")
                              []
                              [ T; A ],
                            "pop_front",
                            [],
                            []
                          |),
                          [
                            M.borrow (|
                              Pointer.Kind.MutRef,
                              M.deref (|
                                M.read (|
                                  M.SubPointer.get_struct_record_field (|
                                    M.deref (| M.read (| self |) |),
                                    "alloc::collections::linked_list::CursorMut",
                                    "list"
                                  |)
                                |)
                              |)
                            |)
                          ]
                        |)
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_pop_front :
        forall (T A : Ty.t),
        M.IsAssociatedFunction.C (Self T A) "pop_front" (pop_front T A).
      Admitted.
      Global Typeclasses Opaque pop_front.
      
      (*
          pub fn pop_back(&mut self) -> Option<T> {
              if self.list.is_empty() {
                  None
              } else {
                  if self.list.tail == self.current {
                      // The index now reflects the length of the list. It was the
                      // length of the list minus 1, but now the list is 1 smaller. No
                      // change is needed for `index`.
                      self.current = None;
                  } else if self.current.is_none() {
                      self.index = self.list.len - 1;
                  }
                  self.list.pop_back()
              }
          }
      *)
      Definition pop_back (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                Some (Ty.apply (Ty.path "core::option::Option") [] [ T ]),
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            M.call_closure (|
                              Ty.path "bool",
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "alloc::collections::linked_list::LinkedList")
                                  []
                                  [ T; A ],
                                "is_empty",
                                [],
                                []
                              |),
                              [
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.deref (|
                                    M.read (|
                                      M.SubPointer.get_struct_record_field (|
                                        M.deref (| M.read (| self |) |),
                                        "alloc::collections::linked_list::CursorMut",
                                        "list"
                                      |)
                                    |)
                                  |)
                                |)
                              ]
                            |)
                          |)) in
                      let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let~ _ : Ty.tuple [] :=
                        M.match_operator (|
                          Some (Ty.tuple []),
                          M.alloc (| Value.Tuple [] |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ :=
                                  M.use
                                    (M.alloc (|
                                      M.call_closure (|
                                        Ty.path "bool",
                                        M.get_trait_method (|
                                          "core::cmp::PartialEq",
                                          Ty.apply
                                            (Ty.path "core::option::Option")
                                            []
                                            [
                                              Ty.apply
                                                (Ty.path "core::ptr::non_null::NonNull")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path
                                                      "alloc::collections::linked_list::Node")
                                                    []
                                                    [ T ]
                                                ]
                                            ],
                                          [],
                                          [
                                            Ty.apply
                                              (Ty.path "core::option::Option")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "core::ptr::non_null::NonNull")
                                                  []
                                                  [
                                                    Ty.apply
                                                      (Ty.path
                                                        "alloc::collections::linked_list::Node")
                                                      []
                                                      [ T ]
                                                  ]
                                              ]
                                          ],
                                          "eq",
                                          [],
                                          []
                                        |),
                                        [
                                          M.borrow (|
                                            Pointer.Kind.Ref,
                                            M.SubPointer.get_struct_record_field (|
                                              M.deref (|
                                                M.read (|
                                                  M.SubPointer.get_struct_record_field (|
                                                    M.deref (| M.read (| self |) |),
                                                    "alloc::collections::linked_list::CursorMut",
                                                    "list"
                                                  |)
                                                |)
                                              |),
                                              "alloc::collections::linked_list::LinkedList",
                                              "tail"
                                            |)
                                          |);
                                          M.borrow (|
                                            Pointer.Kind.Ref,
                                            M.SubPointer.get_struct_record_field (|
                                              M.deref (| M.read (| self |) |),
                                              "alloc::collections::linked_list::CursorMut",
                                              "current"
                                            |)
                                          |)
                                        ]
                                      |)
                                    |)) in
                                let _ :=
                                  is_constant_or_break_match (|
                                    M.read (| γ |),
                                    Value.Bool true
                                  |) in
                                let~ _ : Ty.tuple [] :=
                                  M.alloc (|
                                    M.write (|
                                      M.SubPointer.get_struct_record_field (|
                                        M.deref (| M.read (| self |) |),
                                        "alloc::collections::linked_list::CursorMut",
                                        "current"
                                      |),
                                      Value.StructTuple "core::option::Option::None" []
                                    |)
                                  |) in
                                M.alloc (| Value.Tuple [] |)));
                            fun γ =>
                              ltac:(M.monadic
                                (M.match_operator (|
                                  Some (Ty.tuple []),
                                  M.alloc (| Value.Tuple [] |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ :=
                                          M.use
                                            (M.alloc (|
                                              M.call_closure (|
                                                Ty.path "bool",
                                                M.get_associated_function (|
                                                  Ty.apply
                                                    (Ty.path "core::option::Option")
                                                    []
                                                    [
                                                      Ty.apply
                                                        (Ty.path "core::ptr::non_null::NonNull")
                                                        []
                                                        [
                                                          Ty.apply
                                                            (Ty.path
                                                              "alloc::collections::linked_list::Node")
                                                            []
                                                            [ T ]
                                                        ]
                                                    ],
                                                  "is_none",
                                                  [],
                                                  []
                                                |),
                                                [
                                                  M.borrow (|
                                                    Pointer.Kind.Ref,
                                                    M.SubPointer.get_struct_record_field (|
                                                      M.deref (| M.read (| self |) |),
                                                      "alloc::collections::linked_list::CursorMut",
                                                      "current"
                                                    |)
                                                  |)
                                                ]
                                              |)
                                            |)) in
                                        let _ :=
                                          is_constant_or_break_match (|
                                            M.read (| γ |),
                                            Value.Bool true
                                          |) in
                                        let~ _ : Ty.tuple [] :=
                                          M.alloc (|
                                            M.write (|
                                              M.SubPointer.get_struct_record_field (|
                                                M.deref (| M.read (| self |) |),
                                                "alloc::collections::linked_list::CursorMut",
                                                "index"
                                              |),
                                              M.call_closure (|
                                                Ty.path "usize",
                                                BinOp.Wrap.sub,
                                                [
                                                  M.read (|
                                                    M.SubPointer.get_struct_record_field (|
                                                      M.deref (|
                                                        M.read (|
                                                          M.SubPointer.get_struct_record_field (|
                                                            M.deref (| M.read (| self |) |),
                                                            "alloc::collections::linked_list::CursorMut",
                                                            "list"
                                                          |)
                                                        |)
                                                      |),
                                                      "alloc::collections::linked_list::LinkedList",
                                                      "len"
                                                    |)
                                                  |);
                                                  Value.Integer IntegerKind.Usize 1
                                                ]
                                              |)
                                            |)
                                          |) in
                                        M.alloc (| Value.Tuple [] |)));
                                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                                  ]
                                |)))
                          ]
                        |) in
                      M.alloc (|
                        M.call_closure (|
                          Ty.apply (Ty.path "core::option::Option") [] [ T ],
                          M.get_associated_function (|
                            Ty.apply
                              (Ty.path "alloc::collections::linked_list::LinkedList")
                              []
                              [ T; A ],
                            "pop_back",
                            [],
                            []
                          |),
                          [
                            M.borrow (|
                              Pointer.Kind.MutRef,
                              M.deref (|
                                M.read (|
                                  M.SubPointer.get_struct_record_field (|
                                    M.deref (| M.read (| self |) |),
                                    "alloc::collections::linked_list::CursorMut",
                                    "list"
                                  |)
                                |)
                              |)
                            |)
                          ]
                        |)
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_pop_back :
        forall (T A : Ty.t),
        M.IsAssociatedFunction.C (Self T A) "pop_back" (pop_back T A).
      Admitted.
      Global Typeclasses Opaque pop_back.
      
      (*
          pub fn front(&self) -> Option<&T> {
              self.list.front()
          }
      *)
      Definition front (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.apply (Ty.path "core::option::Option") [] [ Ty.apply (Ty.path "&") [] [ T ] ],
              M.get_associated_function (|
                Ty.apply (Ty.path "alloc::collections::linked_list::LinkedList") [] [ T; A ],
                "front",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.read (|
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "alloc::collections::linked_list::CursorMut",
                        "list"
                      |)
                    |)
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_front :
        forall (T A : Ty.t),
        M.IsAssociatedFunction.C (Self T A) "front" (front T A).
      Admitted.
      Global Typeclasses Opaque front.
      
      (*
          pub fn front_mut(&mut self) -> Option<&mut T> {
              self.list.front_mut()
          }
      *)
      Definition front_mut (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.apply (Ty.path "core::option::Option") [] [ Ty.apply (Ty.path "&mut") [] [ T ] ],
              M.get_associated_function (|
                Ty.apply (Ty.path "alloc::collections::linked_list::LinkedList") [] [ T; A ],
                "front_mut",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.deref (|
                    M.read (|
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "alloc::collections::linked_list::CursorMut",
                        "list"
                      |)
                    |)
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_front_mut :
        forall (T A : Ty.t),
        M.IsAssociatedFunction.C (Self T A) "front_mut" (front_mut T A).
      Admitted.
      Global Typeclasses Opaque front_mut.
      
      (*
          pub fn back(&self) -> Option<&T> {
              self.list.back()
          }
      *)
      Definition back (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.apply (Ty.path "core::option::Option") [] [ Ty.apply (Ty.path "&") [] [ T ] ],
              M.get_associated_function (|
                Ty.apply (Ty.path "alloc::collections::linked_list::LinkedList") [] [ T; A ],
                "back",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.read (|
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "alloc::collections::linked_list::CursorMut",
                        "list"
                      |)
                    |)
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_back :
        forall (T A : Ty.t),
        M.IsAssociatedFunction.C (Self T A) "back" (back T A).
      Admitted.
      Global Typeclasses Opaque back.
      
      (*
          pub fn back_mut(&mut self) -> Option<&mut T> {
              self.list.back_mut()
          }
      *)
      Definition back_mut (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.apply (Ty.path "core::option::Option") [] [ Ty.apply (Ty.path "&mut") [] [ T ] ],
              M.get_associated_function (|
                Ty.apply (Ty.path "alloc::collections::linked_list::LinkedList") [] [ T; A ],
                "back_mut",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.deref (|
                    M.read (|
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "alloc::collections::linked_list::CursorMut",
                        "list"
                      |)
                    |)
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_back_mut :
        forall (T A : Ty.t),
        M.IsAssociatedFunction.C (Self T A) "back_mut" (back_mut T A).
      Admitted.
      Global Typeclasses Opaque back_mut.
    End Impl_alloc_collections_linked_list_CursorMut_T_A.
    
    Module Impl_alloc_collections_linked_list_CursorMut_T_alloc_alloc_Global.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply
          (Ty.path "alloc::collections::linked_list::CursorMut")
          []
          [ T; Ty.path "alloc::alloc::Global" ].
      
      (*
          pub fn splice_after(&mut self, list: LinkedList<T>) {
              unsafe {
                  let (splice_head, splice_tail, splice_len) = match list.detach_all_nodes() {
                      Some(parts) => parts,
                      _ => return,
                  };
                  let node_next = match self.current {
                      None => self.list.head,
                      Some(node) => node.as_ref().next,
                  };
                  self.list.splice_nodes(self.current, node_next, splice_head, splice_tail, splice_len);
                  if self.current.is_none() {
                      // The "ghost" non-element's index has changed.
                      self.index = self.list.len;
                  }
              }
          }
      *)
      Definition splice_after
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; list ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let list := M.alloc (| list |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.read (|
                  M.match_operator (|
                    None,
                    M.match_operator (|
                      Some
                        (Ty.tuple
                          [
                            Ty.apply
                              (Ty.path "core::ptr::non_null::NonNull")
                              []
                              [ Ty.apply (Ty.path "alloc::collections::linked_list::Node") [] [ T ]
                              ];
                            Ty.apply
                              (Ty.path "core::ptr::non_null::NonNull")
                              []
                              [ Ty.apply (Ty.path "alloc::collections::linked_list::Node") [] [ T ]
                              ];
                            Ty.path "usize"
                          ]),
                      M.alloc (|
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "core::option::Option")
                            []
                            [
                              Ty.tuple
                                [
                                  Ty.apply
                                    (Ty.path "core::ptr::non_null::NonNull")
                                    []
                                    [
                                      Ty.apply
                                        (Ty.path "alloc::collections::linked_list::Node")
                                        []
                                        [ T ]
                                    ];
                                  Ty.apply
                                    (Ty.path "core::ptr::non_null::NonNull")
                                    []
                                    [
                                      Ty.apply
                                        (Ty.path "alloc::collections::linked_list::Node")
                                        []
                                        [ T ]
                                    ];
                                  Ty.path "usize"
                                ]
                            ],
                          M.get_associated_function (|
                            Ty.apply
                              (Ty.path "alloc::collections::linked_list::LinkedList")
                              []
                              [ T; Ty.path "alloc::alloc::Global" ],
                            "detach_all_nodes",
                            [],
                            []
                          |),
                          [ M.read (| list |) ]
                        |)
                      |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "core::option::Option::Some",
                                0
                              |) in
                            let parts := M.copy (| γ0_0 |) in
                            parts));
                        fun γ =>
                          ltac:(M.monadic
                            (M.alloc (|
                              M.never_to_any (| M.read (| M.return_ (| Value.Tuple [] |) |) |)
                            |)))
                      ]
                    |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                          let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                          let γ0_2 := M.SubPointer.get_tuple_field (| γ, 2 |) in
                          let splice_head := M.copy (| γ0_0 |) in
                          let splice_tail := M.copy (| γ0_1 |) in
                          let splice_len := M.copy (| γ0_2 |) in
                          let~ node_next :
                              Ty.apply
                                (Ty.path "core::option::Option")
                                []
                                [
                                  Ty.apply
                                    (Ty.path "core::ptr::non_null::NonNull")
                                    []
                                    [
                                      Ty.apply
                                        (Ty.path "alloc::collections::linked_list::Node")
                                        []
                                        [ T ]
                                    ]
                                ] :=
                            M.copy (|
                              M.match_operator (|
                                Some
                                  (Ty.apply
                                    (Ty.path "core::option::Option")
                                    []
                                    [
                                      Ty.apply
                                        (Ty.path "core::ptr::non_null::NonNull")
                                        []
                                        [
                                          Ty.apply
                                            (Ty.path "alloc::collections::linked_list::Node")
                                            []
                                            [ T ]
                                        ]
                                    ]),
                                M.SubPointer.get_struct_record_field (|
                                  M.deref (| M.read (| self |) |),
                                  "alloc::collections::linked_list::CursorMut",
                                  "current"
                                |),
                                [
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let _ :=
                                        M.is_struct_tuple (| γ, "core::option::Option::None" |) in
                                      M.SubPointer.get_struct_record_field (|
                                        M.deref (|
                                          M.read (|
                                            M.SubPointer.get_struct_record_field (|
                                              M.deref (| M.read (| self |) |),
                                              "alloc::collections::linked_list::CursorMut",
                                              "list"
                                            |)
                                          |)
                                        |),
                                        "alloc::collections::linked_list::LinkedList",
                                        "head"
                                      |)));
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let γ0_0 :=
                                        M.SubPointer.get_struct_tuple_field (|
                                          γ,
                                          "core::option::Option::Some",
                                          0
                                        |) in
                                      let node := M.copy (| γ0_0 |) in
                                      M.SubPointer.get_struct_record_field (|
                                        M.deref (|
                                          M.call_closure (|
                                            Ty.apply
                                              (Ty.path "&")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "alloc::collections::linked_list::Node")
                                                  []
                                                  [ T ]
                                              ],
                                            M.get_associated_function (|
                                              Ty.apply
                                                (Ty.path "core::ptr::non_null::NonNull")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path
                                                      "alloc::collections::linked_list::Node")
                                                    []
                                                    [ T ]
                                                ],
                                              "as_ref",
                                              [],
                                              []
                                            |),
                                            [ M.borrow (| Pointer.Kind.Ref, node |) ]
                                          |)
                                        |),
                                        "alloc::collections::linked_list::Node",
                                        "next"
                                      |)))
                                ]
                              |)
                            |) in
                          let~ _ : Ty.tuple [] :=
                            M.alloc (|
                              M.call_closure (|
                                Ty.tuple [],
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "alloc::collections::linked_list::LinkedList")
                                    []
                                    [ T; Ty.path "alloc::alloc::Global" ],
                                  "splice_nodes",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (|
                                    Pointer.Kind.MutRef,
                                    M.deref (|
                                      M.read (|
                                        M.SubPointer.get_struct_record_field (|
                                          M.deref (| M.read (| self |) |),
                                          "alloc::collections::linked_list::CursorMut",
                                          "list"
                                        |)
                                      |)
                                    |)
                                  |);
                                  M.read (|
                                    M.SubPointer.get_struct_record_field (|
                                      M.deref (| M.read (| self |) |),
                                      "alloc::collections::linked_list::CursorMut",
                                      "current"
                                    |)
                                  |);
                                  M.read (| node_next |);
                                  M.read (| splice_head |);
                                  M.read (| splice_tail |);
                                  M.read (| splice_len |)
                                ]
                              |)
                            |) in
                          M.match_operator (|
                            Some (Ty.tuple []),
                            M.alloc (| Value.Tuple [] |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ :=
                                    M.use
                                      (M.alloc (|
                                        M.call_closure (|
                                          Ty.path "bool",
                                          M.get_associated_function (|
                                            Ty.apply
                                              (Ty.path "core::option::Option")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "core::ptr::non_null::NonNull")
                                                  []
                                                  [
                                                    Ty.apply
                                                      (Ty.path
                                                        "alloc::collections::linked_list::Node")
                                                      []
                                                      [ T ]
                                                  ]
                                              ],
                                            "is_none",
                                            [],
                                            []
                                          |),
                                          [
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.SubPointer.get_struct_record_field (|
                                                M.deref (| M.read (| self |) |),
                                                "alloc::collections::linked_list::CursorMut",
                                                "current"
                                              |)
                                            |)
                                          ]
                                        |)
                                      |)) in
                                  let _ :=
                                    is_constant_or_break_match (|
                                      M.read (| γ |),
                                      Value.Bool true
                                    |) in
                                  let~ _ : Ty.tuple [] :=
                                    M.alloc (|
                                      M.write (|
                                        M.SubPointer.get_struct_record_field (|
                                          M.deref (| M.read (| self |) |),
                                          "alloc::collections::linked_list::CursorMut",
                                          "index"
                                        |),
                                        M.read (|
                                          M.SubPointer.get_struct_record_field (|
                                            M.deref (|
                                              M.read (|
                                                M.SubPointer.get_struct_record_field (|
                                                  M.deref (| M.read (| self |) |),
                                                  "alloc::collections::linked_list::CursorMut",
                                                  "list"
                                                |)
                                              |)
                                            |),
                                            "alloc::collections::linked_list::LinkedList",
                                            "len"
                                          |)
                                        |)
                                      |)
                                    |) in
                                  M.alloc (| Value.Tuple [] |)));
                              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                            ]
                          |)))
                    ]
                  |)
                |)))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_splice_after :
        forall (T : Ty.t),
        M.IsAssociatedFunction.C (Self T) "splice_after" (splice_after T).
      Admitted.
      Global Typeclasses Opaque splice_after.
      
      (*
          pub fn splice_before(&mut self, list: LinkedList<T>) {
              unsafe {
                  let (splice_head, splice_tail, splice_len) = match list.detach_all_nodes() {
                      Some(parts) => parts,
                      _ => return,
                  };
                  let node_prev = match self.current {
                      None => self.list.tail,
                      Some(node) => node.as_ref().prev,
                  };
                  self.list.splice_nodes(node_prev, self.current, splice_head, splice_tail, splice_len);
                  self.index += splice_len;
              }
          }
      *)
      Definition splice_before
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; list ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let list := M.alloc (| list |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.read (|
                  M.match_operator (|
                    None,
                    M.match_operator (|
                      Some
                        (Ty.tuple
                          [
                            Ty.apply
                              (Ty.path "core::ptr::non_null::NonNull")
                              []
                              [ Ty.apply (Ty.path "alloc::collections::linked_list::Node") [] [ T ]
                              ];
                            Ty.apply
                              (Ty.path "core::ptr::non_null::NonNull")
                              []
                              [ Ty.apply (Ty.path "alloc::collections::linked_list::Node") [] [ T ]
                              ];
                            Ty.path "usize"
                          ]),
                      M.alloc (|
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "core::option::Option")
                            []
                            [
                              Ty.tuple
                                [
                                  Ty.apply
                                    (Ty.path "core::ptr::non_null::NonNull")
                                    []
                                    [
                                      Ty.apply
                                        (Ty.path "alloc::collections::linked_list::Node")
                                        []
                                        [ T ]
                                    ];
                                  Ty.apply
                                    (Ty.path "core::ptr::non_null::NonNull")
                                    []
                                    [
                                      Ty.apply
                                        (Ty.path "alloc::collections::linked_list::Node")
                                        []
                                        [ T ]
                                    ];
                                  Ty.path "usize"
                                ]
                            ],
                          M.get_associated_function (|
                            Ty.apply
                              (Ty.path "alloc::collections::linked_list::LinkedList")
                              []
                              [ T; Ty.path "alloc::alloc::Global" ],
                            "detach_all_nodes",
                            [],
                            []
                          |),
                          [ M.read (| list |) ]
                        |)
                      |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "core::option::Option::Some",
                                0
                              |) in
                            let parts := M.copy (| γ0_0 |) in
                            parts));
                        fun γ =>
                          ltac:(M.monadic
                            (M.alloc (|
                              M.never_to_any (| M.read (| M.return_ (| Value.Tuple [] |) |) |)
                            |)))
                      ]
                    |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                          let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                          let γ0_2 := M.SubPointer.get_tuple_field (| γ, 2 |) in
                          let splice_head := M.copy (| γ0_0 |) in
                          let splice_tail := M.copy (| γ0_1 |) in
                          let splice_len := M.copy (| γ0_2 |) in
                          let~ node_prev :
                              Ty.apply
                                (Ty.path "core::option::Option")
                                []
                                [
                                  Ty.apply
                                    (Ty.path "core::ptr::non_null::NonNull")
                                    []
                                    [
                                      Ty.apply
                                        (Ty.path "alloc::collections::linked_list::Node")
                                        []
                                        [ T ]
                                    ]
                                ] :=
                            M.copy (|
                              M.match_operator (|
                                Some
                                  (Ty.apply
                                    (Ty.path "core::option::Option")
                                    []
                                    [
                                      Ty.apply
                                        (Ty.path "core::ptr::non_null::NonNull")
                                        []
                                        [
                                          Ty.apply
                                            (Ty.path "alloc::collections::linked_list::Node")
                                            []
                                            [ T ]
                                        ]
                                    ]),
                                M.SubPointer.get_struct_record_field (|
                                  M.deref (| M.read (| self |) |),
                                  "alloc::collections::linked_list::CursorMut",
                                  "current"
                                |),
                                [
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let _ :=
                                        M.is_struct_tuple (| γ, "core::option::Option::None" |) in
                                      M.SubPointer.get_struct_record_field (|
                                        M.deref (|
                                          M.read (|
                                            M.SubPointer.get_struct_record_field (|
                                              M.deref (| M.read (| self |) |),
                                              "alloc::collections::linked_list::CursorMut",
                                              "list"
                                            |)
                                          |)
                                        |),
                                        "alloc::collections::linked_list::LinkedList",
                                        "tail"
                                      |)));
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let γ0_0 :=
                                        M.SubPointer.get_struct_tuple_field (|
                                          γ,
                                          "core::option::Option::Some",
                                          0
                                        |) in
                                      let node := M.copy (| γ0_0 |) in
                                      M.SubPointer.get_struct_record_field (|
                                        M.deref (|
                                          M.call_closure (|
                                            Ty.apply
                                              (Ty.path "&")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "alloc::collections::linked_list::Node")
                                                  []
                                                  [ T ]
                                              ],
                                            M.get_associated_function (|
                                              Ty.apply
                                                (Ty.path "core::ptr::non_null::NonNull")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path
                                                      "alloc::collections::linked_list::Node")
                                                    []
                                                    [ T ]
                                                ],
                                              "as_ref",
                                              [],
                                              []
                                            |),
                                            [ M.borrow (| Pointer.Kind.Ref, node |) ]
                                          |)
                                        |),
                                        "alloc::collections::linked_list::Node",
                                        "prev"
                                      |)))
                                ]
                              |)
                            |) in
                          let~ _ : Ty.tuple [] :=
                            M.alloc (|
                              M.call_closure (|
                                Ty.tuple [],
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "alloc::collections::linked_list::LinkedList")
                                    []
                                    [ T; Ty.path "alloc::alloc::Global" ],
                                  "splice_nodes",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (|
                                    Pointer.Kind.MutRef,
                                    M.deref (|
                                      M.read (|
                                        M.SubPointer.get_struct_record_field (|
                                          M.deref (| M.read (| self |) |),
                                          "alloc::collections::linked_list::CursorMut",
                                          "list"
                                        |)
                                      |)
                                    |)
                                  |);
                                  M.read (| node_prev |);
                                  M.read (|
                                    M.SubPointer.get_struct_record_field (|
                                      M.deref (| M.read (| self |) |),
                                      "alloc::collections::linked_list::CursorMut",
                                      "current"
                                    |)
                                  |);
                                  M.read (| splice_head |);
                                  M.read (| splice_tail |);
                                  M.read (| splice_len |)
                                ]
                              |)
                            |) in
                          let~ _ : Ty.tuple [] :=
                            M.alloc (|
                              let β :=
                                M.SubPointer.get_struct_record_field (|
                                  M.deref (| M.read (| self |) |),
                                  "alloc::collections::linked_list::CursorMut",
                                  "index"
                                |) in
                              M.write (|
                                β,
                                M.call_closure (|
                                  Ty.path "usize",
                                  BinOp.Wrap.add,
                                  [ M.read (| β |); M.read (| splice_len |) ]
                                |)
                              |)
                            |) in
                          M.alloc (| Value.Tuple [] |)))
                    ]
                  |)
                |)))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_splice_before :
        forall (T : Ty.t),
        M.IsAssociatedFunction.C (Self T) "splice_before" (splice_before T).
      Admitted.
      Global Typeclasses Opaque splice_before.
    End Impl_alloc_collections_linked_list_CursorMut_T_alloc_alloc_Global.
    
    
    (* StructRecord
      {
        name := "ExtractIf";
        const_params := [];
        ty_params := [ "T"; "F"; "A" ];
        fields :=
          [
            ("list",
              Ty.apply
                (Ty.path "&mut")
                []
                [ Ty.apply (Ty.path "alloc::collections::linked_list::LinkedList") [] [ T; A ] ]);
            ("it",
              Ty.apply
                (Ty.path "core::option::Option")
                []
                [
                  Ty.apply
                    (Ty.path "core::ptr::non_null::NonNull")
                    []
                    [ Ty.apply (Ty.path "alloc::collections::linked_list::Node") [] [ T ] ]
                ]);
            ("pred", F);
            ("idx", Ty.path "usize");
            ("old_len", Ty.path "usize")
          ];
      } *)
    
    Module Impl_core_iter_traits_iterator_Iterator_where_core_alloc_Allocator_A_where_core_ops_function_FnMut_F_Tuple_ref_mut_T__for_alloc_collections_linked_list_ExtractIf_T_F_A.
      Definition Self (T F A : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "alloc::collections::linked_list::ExtractIf") [] [ T; F; A ].
      
      (*     type Item = T; *)
      Definition _Item (T F A : Ty.t) : Ty.t := T.
      
      (*
          fn next(&mut self) -> Option<T> {
              while let Some(mut node) = self.it {
                  unsafe {
                      self.it = node.as_ref().next;
                      self.idx += 1;
      
                      if (self.pred)(&mut node.as_mut().element) {
                          // `unlink_node` is okay with aliasing `element` references.
                          self.list.unlink_node(node);
                          return Some(Box::from_raw_in(node.as_ptr(), &self.list.alloc).element);
                      }
                  }
              }
      
              None
          }
      *)
      Definition next (T F A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T F A in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.read (|
                  let~ _ : Ty.tuple [] :=
                    M.loop (|
                      Ty.tuple [],
                      ltac:(M.monadic
                        (M.match_operator (|
                          Some (Ty.tuple []),
                          M.alloc (| Value.Tuple [] |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ :=
                                  M.SubPointer.get_struct_record_field (|
                                    M.deref (| M.read (| self |) |),
                                    "alloc::collections::linked_list::ExtractIf",
                                    "it"
                                  |) in
                                let γ0_0 :=
                                  M.SubPointer.get_struct_tuple_field (|
                                    γ,
                                    "core::option::Option::Some",
                                    0
                                  |) in
                                let node := M.copy (| γ0_0 |) in
                                let~ _ : Ty.tuple [] :=
                                  M.alloc (|
                                    M.write (|
                                      M.SubPointer.get_struct_record_field (|
                                        M.deref (| M.read (| self |) |),
                                        "alloc::collections::linked_list::ExtractIf",
                                        "it"
                                      |),
                                      M.read (|
                                        M.SubPointer.get_struct_record_field (|
                                          M.deref (|
                                            M.call_closure (|
                                              Ty.apply
                                                (Ty.path "&")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path
                                                      "alloc::collections::linked_list::Node")
                                                    []
                                                    [ T ]
                                                ],
                                              M.get_associated_function (|
                                                Ty.apply
                                                  (Ty.path "core::ptr::non_null::NonNull")
                                                  []
                                                  [
                                                    Ty.apply
                                                      (Ty.path
                                                        "alloc::collections::linked_list::Node")
                                                      []
                                                      [ T ]
                                                  ],
                                                "as_ref",
                                                [],
                                                []
                                              |),
                                              [ M.borrow (| Pointer.Kind.Ref, node |) ]
                                            |)
                                          |),
                                          "alloc::collections::linked_list::Node",
                                          "next"
                                        |)
                                      |)
                                    |)
                                  |) in
                                let~ _ : Ty.tuple [] :=
                                  M.alloc (|
                                    let β :=
                                      M.SubPointer.get_struct_record_field (|
                                        M.deref (| M.read (| self |) |),
                                        "alloc::collections::linked_list::ExtractIf",
                                        "idx"
                                      |) in
                                    M.write (|
                                      β,
                                      M.call_closure (|
                                        Ty.path "usize",
                                        BinOp.Wrap.add,
                                        [ M.read (| β |); Value.Integer IntegerKind.Usize 1 ]
                                      |)
                                    |)
                                  |) in
                                M.match_operator (|
                                  Some (Ty.tuple []),
                                  M.alloc (| Value.Tuple [] |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ :=
                                          M.use
                                            (M.alloc (|
                                              M.call_closure (|
                                                Ty.path "bool",
                                                M.get_trait_method (|
                                                  "core::ops::function::FnMut",
                                                  F,
                                                  [],
                                                  [ Ty.tuple [ Ty.apply (Ty.path "&mut") [] [ T ] ]
                                                  ],
                                                  "call_mut",
                                                  [],
                                                  []
                                                |),
                                                [
                                                  M.borrow (|
                                                    Pointer.Kind.MutRef,
                                                    M.SubPointer.get_struct_record_field (|
                                                      M.deref (| M.read (| self |) |),
                                                      "alloc::collections::linked_list::ExtractIf",
                                                      "pred"
                                                    |)
                                                  |);
                                                  Value.Tuple
                                                    [
                                                      M.borrow (|
                                                        Pointer.Kind.MutRef,
                                                        M.deref (|
                                                          M.borrow (|
                                                            Pointer.Kind.MutRef,
                                                            M.SubPointer.get_struct_record_field (|
                                                              M.deref (|
                                                                M.call_closure (|
                                                                  Ty.apply
                                                                    (Ty.path "&mut")
                                                                    []
                                                                    [
                                                                      Ty.apply
                                                                        (Ty.path
                                                                          "alloc::collections::linked_list::Node")
                                                                        []
                                                                        [ T ]
                                                                    ],
                                                                  M.get_associated_function (|
                                                                    Ty.apply
                                                                      (Ty.path
                                                                        "core::ptr::non_null::NonNull")
                                                                      []
                                                                      [
                                                                        Ty.apply
                                                                          (Ty.path
                                                                            "alloc::collections::linked_list::Node")
                                                                          []
                                                                          [ T ]
                                                                      ],
                                                                    "as_mut",
                                                                    [],
                                                                    []
                                                                  |),
                                                                  [
                                                                    M.borrow (|
                                                                      Pointer.Kind.MutRef,
                                                                      node
                                                                    |)
                                                                  ]
                                                                |)
                                                              |),
                                                              "alloc::collections::linked_list::Node",
                                                              "element"
                                                            |)
                                                          |)
                                                        |)
                                                      |)
                                                    ]
                                                ]
                                              |)
                                            |)) in
                                        let _ :=
                                          is_constant_or_break_match (|
                                            M.read (| γ |),
                                            Value.Bool true
                                          |) in
                                        M.alloc (|
                                          M.never_to_any (|
                                            M.read (|
                                              let~ _ : Ty.tuple [] :=
                                                M.alloc (|
                                                  M.call_closure (|
                                                    Ty.tuple [],
                                                    M.get_associated_function (|
                                                      Ty.apply
                                                        (Ty.path
                                                          "alloc::collections::linked_list::LinkedList")
                                                        []
                                                        [ T; A ],
                                                      "unlink_node",
                                                      [],
                                                      []
                                                    |),
                                                    [
                                                      M.borrow (|
                                                        Pointer.Kind.MutRef,
                                                        M.deref (|
                                                          M.read (|
                                                            M.SubPointer.get_struct_record_field (|
                                                              M.deref (| M.read (| self |) |),
                                                              "alloc::collections::linked_list::ExtractIf",
                                                              "list"
                                                            |)
                                                          |)
                                                        |)
                                                      |);
                                                      M.read (| node |)
                                                    ]
                                                  |)
                                                |) in
                                              M.return_ (|
                                                Value.StructTuple
                                                  "core::option::Option::Some"
                                                  [
                                                    M.read (|
                                                      M.SubPointer.get_struct_record_field (|
                                                        M.deref (|
                                                          M.call_closure (|
                                                            Ty.apply
                                                              (Ty.path "alloc::boxed::Box")
                                                              []
                                                              [
                                                                Ty.apply
                                                                  (Ty.path
                                                                    "alloc::collections::linked_list::Node")
                                                                  []
                                                                  [ T ];
                                                                Ty.apply (Ty.path "&") [] [ A ]
                                                              ],
                                                            M.get_associated_function (|
                                                              Ty.apply
                                                                (Ty.path "alloc::boxed::Box")
                                                                []
                                                                [
                                                                  Ty.apply
                                                                    (Ty.path
                                                                      "alloc::collections::linked_list::Node")
                                                                    []
                                                                    [ T ];
                                                                  Ty.apply (Ty.path "&") [] [ A ]
                                                                ],
                                                              "from_raw_in",
                                                              [],
                                                              []
                                                            |),
                                                            [
                                                              M.call_closure (|
                                                                Ty.apply
                                                                  (Ty.path "*mut")
                                                                  []
                                                                  [
                                                                    Ty.apply
                                                                      (Ty.path
                                                                        "alloc::collections::linked_list::Node")
                                                                      []
                                                                      [ T ]
                                                                  ],
                                                                M.get_associated_function (|
                                                                  Ty.apply
                                                                    (Ty.path
                                                                      "core::ptr::non_null::NonNull")
                                                                    []
                                                                    [
                                                                      Ty.apply
                                                                        (Ty.path
                                                                          "alloc::collections::linked_list::Node")
                                                                        []
                                                                        [ T ]
                                                                    ],
                                                                  "as_ptr",
                                                                  [],
                                                                  []
                                                                |),
                                                                [ M.read (| node |) ]
                                                              |);
                                                              M.borrow (|
                                                                Pointer.Kind.Ref,
                                                                M.SubPointer.get_struct_record_field (|
                                                                  M.deref (|
                                                                    M.read (|
                                                                      M.SubPointer.get_struct_record_field (|
                                                                        M.deref (|
                                                                          M.read (| self |)
                                                                        |),
                                                                        "alloc::collections::linked_list::ExtractIf",
                                                                        "list"
                                                                      |)
                                                                    |)
                                                                  |),
                                                                  "alloc::collections::linked_list::LinkedList",
                                                                  "alloc"
                                                                |)
                                                              |)
                                                            ]
                                                          |)
                                                        |),
                                                        "alloc::collections::linked_list::Node",
                                                        "element"
                                                      |)
                                                    |)
                                                  ]
                                              |)
                                            |)
                                          |)
                                        |)));
                                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                                  ]
                                |)));
                            fun γ =>
                              ltac:(M.monadic
                                (M.alloc (|
                                  M.never_to_any (|
                                    M.read (|
                                      let~ _ : Ty.tuple [] :=
                                        M.alloc (|
                                          M.never_to_any (| M.read (| M.break (||) |) |)
                                        |) in
                                      M.alloc (| Value.Tuple [] |)
                                    |)
                                  |)
                                |)))
                          ]
                        |)))
                    |) in
                  M.alloc (| Value.StructTuple "core::option::Option::None" [] |)
                |)))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn size_hint(&self) -> (usize, Option<usize>) {
              (0, Some(self.old_len - self.idx))
          }
      *)
      Definition size_hint
          (T F A : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self T F A in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.Tuple
              [
                Value.Integer IntegerKind.Usize 0;
                Value.StructTuple
                  "core::option::Option::Some"
                  [
                    M.call_closure (|
                      Ty.path "usize",
                      BinOp.Wrap.sub,
                      [
                        M.read (|
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "alloc::collections::linked_list::ExtractIf",
                            "old_len"
                          |)
                        |);
                        M.read (|
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "alloc::collections::linked_list::ExtractIf",
                            "idx"
                          |)
                        |)
                      ]
                    |)
                  ]
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T F A : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::iterator::Iterator"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T F A)
          (* Instance *)
          [
            ("Item", InstanceField.Ty (_Item T F A));
            ("next", InstanceField.Method (next T F A));
            ("size_hint", InstanceField.Method (size_hint T F A))
          ].
    End Impl_core_iter_traits_iterator_Iterator_where_core_alloc_Allocator_A_where_core_ops_function_FnMut_F_Tuple_ref_mut_T__for_alloc_collections_linked_list_ExtractIf_T_F_A.
    
    Module Impl_core_fmt_Debug_where_core_fmt_Debug_T_where_core_ops_function_FnMut_F_Tuple_ref_mut_T__for_alloc_collections_linked_list_ExtractIf_T_F_alloc_alloc_Global.
      Definition Self (T F : Ty.t) : Ty.t :=
        Ty.apply
          (Ty.path "alloc::collections::linked_list::ExtractIf")
          []
          [ T; F; Ty.path "alloc::alloc::Global" ].
      
      (*
          fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
              f.debug_tuple("ExtractIf").field(&self.list).finish()
          }
      *)
      Definition fmt (T F : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T F in
        match ε, τ, α with
        | [], [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "core::result::Result")
                []
                [ Ty.tuple []; Ty.path "core::fmt::Error" ],
              M.get_associated_function (|
                Ty.path "core::fmt::builders::DebugTuple",
                "finish",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.deref (|
                    M.call_closure (|
                      Ty.apply (Ty.path "&mut") [] [ Ty.path "core::fmt::builders::DebugTuple" ],
                      M.get_associated_function (|
                        Ty.path "core::fmt::builders::DebugTuple",
                        "field",
                        [],
                        []
                      |),
                      [
                        M.borrow (|
                          Pointer.Kind.MutRef,
                          M.alloc (|
                            M.call_closure (|
                              Ty.path "core::fmt::builders::DebugTuple",
                              M.get_associated_function (|
                                Ty.path "core::fmt::Formatter",
                                "debug_tuple",
                                [],
                                []
                              |),
                              [
                                M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.deref (| mk_str (| "ExtractIf" |) |)
                                |)
                              ]
                            |)
                          |)
                        |);
                        (* Unsize *)
                        M.pointer_coercion
                          (M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (|
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.SubPointer.get_struct_record_field (|
                                  M.deref (| M.read (| self |) |),
                                  "alloc::collections::linked_list::ExtractIf",
                                  "list"
                                |)
                              |)
                            |)
                          |))
                      ]
                    |)
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T F : Ty.t),
        M.IsTraitInstance
          "core::fmt::Debug"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T F)
          (* Instance *) [ ("fmt", InstanceField.Method (fmt T F)) ].
    End Impl_core_fmt_Debug_where_core_fmt_Debug_T_where_core_ops_function_FnMut_F_Tuple_ref_mut_T__for_alloc_collections_linked_list_ExtractIf_T_F_alloc_alloc_Global.
    
    Module Impl_core_iter_traits_iterator_Iterator_where_core_alloc_Allocator_A_for_alloc_collections_linked_list_IntoIter_T_A.
      Definition Self (T A : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "alloc::collections::linked_list::IntoIter") [] [ T; A ].
      
      (*     type Item = T; *)
      Definition _Item (T A : Ty.t) : Ty.t := T.
      
      (*
          fn next(&mut self) -> Option<T> {
              self.list.pop_front()
          }
      *)
      Definition next (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.apply (Ty.path "core::option::Option") [] [ T ],
              M.get_associated_function (|
                Ty.apply (Ty.path "alloc::collections::linked_list::LinkedList") [] [ T; A ],
                "pop_front",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.SubPointer.get_struct_record_field (|
                    M.deref (| M.read (| self |) |),
                    "alloc::collections::linked_list::IntoIter",
                    "list"
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn size_hint(&self) -> (usize, Option<usize>) {
              (self.list.len, Some(self.list.len))
          }
      *)
      Definition size_hint (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.Tuple
              [
                M.read (|
                  M.SubPointer.get_struct_record_field (|
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| self |) |),
                      "alloc::collections::linked_list::IntoIter",
                      "list"
                    |),
                    "alloc::collections::linked_list::LinkedList",
                    "len"
                  |)
                |);
                Value.StructTuple
                  "core::option::Option::Some"
                  [
                    M.read (|
                      M.SubPointer.get_struct_record_field (|
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "alloc::collections::linked_list::IntoIter",
                          "list"
                        |),
                        "alloc::collections::linked_list::LinkedList",
                        "len"
                      |)
                    |)
                  ]
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T A : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::iterator::Iterator"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T A)
          (* Instance *)
          [
            ("Item", InstanceField.Ty (_Item T A));
            ("next", InstanceField.Method (next T A));
            ("size_hint", InstanceField.Method (size_hint T A))
          ].
    End Impl_core_iter_traits_iterator_Iterator_where_core_alloc_Allocator_A_for_alloc_collections_linked_list_IntoIter_T_A.
    
    Module Impl_core_iter_traits_double_ended_DoubleEndedIterator_where_core_alloc_Allocator_A_for_alloc_collections_linked_list_IntoIter_T_A.
      Definition Self (T A : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "alloc::collections::linked_list::IntoIter") [] [ T; A ].
      
      (*
          fn next_back(&mut self) -> Option<T> {
              self.list.pop_back()
          }
      *)
      Definition next_back (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.apply (Ty.path "core::option::Option") [] [ T ],
              M.get_associated_function (|
                Ty.apply (Ty.path "alloc::collections::linked_list::LinkedList") [] [ T; A ],
                "pop_back",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.SubPointer.get_struct_record_field (|
                    M.deref (| M.read (| self |) |),
                    "alloc::collections::linked_list::IntoIter",
                    "list"
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T A : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::double_ended::DoubleEndedIterator"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T A)
          (* Instance *) [ ("next_back", InstanceField.Method (next_back T A)) ].
    End Impl_core_iter_traits_double_ended_DoubleEndedIterator_where_core_alloc_Allocator_A_for_alloc_collections_linked_list_IntoIter_T_A.
    
    Module Impl_core_iter_traits_exact_size_ExactSizeIterator_where_core_alloc_Allocator_A_for_alloc_collections_linked_list_IntoIter_T_A.
      Definition Self (T A : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "alloc::collections::linked_list::IntoIter") [] [ T; A ].
      
      Axiom Implements :
        forall (T A : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::exact_size::ExactSizeIterator"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T A)
          (* Instance *) [].
    End Impl_core_iter_traits_exact_size_ExactSizeIterator_where_core_alloc_Allocator_A_for_alloc_collections_linked_list_IntoIter_T_A.
    
    Module Impl_core_iter_traits_marker_FusedIterator_where_core_alloc_Allocator_A_for_alloc_collections_linked_list_IntoIter_T_A.
      Definition Self (T A : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "alloc::collections::linked_list::IntoIter") [] [ T; A ].
      
      Axiom Implements :
        forall (T A : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::marker::FusedIterator"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T A)
          (* Instance *) [].
    End Impl_core_iter_traits_marker_FusedIterator_where_core_alloc_Allocator_A_for_alloc_collections_linked_list_IntoIter_T_A.
    
    Module Impl_core_default_Default_for_alloc_collections_linked_list_IntoIter_T_alloc_alloc_Global.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply
          (Ty.path "alloc::collections::linked_list::IntoIter")
          []
          [ T; Ty.path "alloc::alloc::Global" ].
      
      (*
          fn default() -> Self {
              LinkedList::new().into_iter()
          }
      *)
      Definition default (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [] =>
          ltac:(M.monadic
            (M.call_closure (|
              Ty.apply
                (Ty.path "alloc::collections::linked_list::IntoIter")
                []
                [ T; Ty.path "alloc::alloc::Global" ],
              M.get_trait_method (|
                "core::iter::traits::collect::IntoIterator",
                Ty.apply
                  (Ty.path "alloc::collections::linked_list::LinkedList")
                  []
                  [ T; Ty.path "alloc::alloc::Global" ],
                [],
                [],
                "into_iter",
                [],
                []
              |),
              [
                M.call_closure (|
                  Ty.apply
                    (Ty.path "alloc::collections::linked_list::LinkedList")
                    []
                    [ T; Ty.path "alloc::alloc::Global" ],
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "alloc::collections::linked_list::LinkedList")
                      []
                      [ T; Ty.path "alloc::alloc::Global" ],
                    "new",
                    [],
                    []
                  |),
                  []
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::default::Default"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T)
          (* Instance *) [ ("default", InstanceField.Method (default T)) ].
    End Impl_core_default_Default_for_alloc_collections_linked_list_IntoIter_T_alloc_alloc_Global.
    
    Module Impl_core_iter_traits_collect_FromIterator_T_for_alloc_collections_linked_list_LinkedList_T_alloc_alloc_Global.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply
          (Ty.path "alloc::collections::linked_list::LinkedList")
          []
          [ T; Ty.path "alloc::alloc::Global" ].
      
      (*
          fn from_iter<I: IntoIterator<Item = T>>(iter: I) -> Self {
              let mut list = Self::new();
              list.extend(iter);
              list
          }
      *)
      Definition from_iter (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [ _ as I ], [ iter ] =>
          ltac:(M.monadic
            (let iter := M.alloc (| iter |) in
            M.read (|
              let~ list :
                  Ty.apply
                    (Ty.path "alloc::collections::linked_list::LinkedList")
                    []
                    [ T; Ty.path "alloc::alloc::Global" ] :=
                M.alloc (|
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "alloc::collections::linked_list::LinkedList")
                      []
                      [ T; Ty.path "alloc::alloc::Global" ],
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "alloc::collections::linked_list::LinkedList")
                        []
                        [ T; Ty.path "alloc::alloc::Global" ],
                      "new",
                      [],
                      []
                    |),
                    []
                  |)
                |) in
              let~ _ : Ty.tuple [] :=
                M.alloc (|
                  M.call_closure (|
                    Ty.tuple [],
                    M.get_trait_method (|
                      "core::iter::traits::collect::Extend",
                      Ty.apply
                        (Ty.path "alloc::collections::linked_list::LinkedList")
                        []
                        [ T; Ty.path "alloc::alloc::Global" ],
                      [],
                      [ T ],
                      "extend",
                      [],
                      [ I ]
                    |),
                    [ M.borrow (| Pointer.Kind.MutRef, list |); M.read (| iter |) ]
                  |)
                |) in
              list
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::collect::FromIterator"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ T ]
          (Self T)
          (* Instance *) [ ("from_iter", InstanceField.Method (from_iter T)) ].
    End Impl_core_iter_traits_collect_FromIterator_T_for_alloc_collections_linked_list_LinkedList_T_alloc_alloc_Global.
    
    Module Impl_core_iter_traits_collect_IntoIterator_where_core_alloc_Allocator_A_for_alloc_collections_linked_list_LinkedList_T_A.
      Definition Self (T A : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "alloc::collections::linked_list::LinkedList") [] [ T; A ].
      
      (*     type Item = T; *)
      Definition _Item (T A : Ty.t) : Ty.t := T.
      
      (*     type IntoIter = IntoIter<T, A>; *)
      Definition _IntoIter (T A : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "alloc::collections::linked_list::IntoIter") [] [ T; A ].
      
      (*
          fn into_iter(self) -> IntoIter<T, A> {
              IntoIter { list: self }
          }
      *)
      Definition into_iter (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructRecord
              "alloc::collections::linked_list::IntoIter"
              [ ("list", M.read (| self |)) ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T A : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::collect::IntoIterator"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T A)
          (* Instance *)
          [
            ("Item", InstanceField.Ty (_Item T A));
            ("IntoIter", InstanceField.Ty (_IntoIter T A));
            ("into_iter", InstanceField.Method (into_iter T A))
          ].
    End Impl_core_iter_traits_collect_IntoIterator_where_core_alloc_Allocator_A_for_alloc_collections_linked_list_LinkedList_T_A.
    
    Module Impl_core_iter_traits_collect_IntoIterator_where_core_alloc_Allocator_A_for_ref__alloc_collections_linked_list_LinkedList_T_A.
      Definition Self (T A : Ty.t) : Ty.t :=
        Ty.apply
          (Ty.path "&")
          []
          [ Ty.apply (Ty.path "alloc::collections::linked_list::LinkedList") [] [ T; A ] ].
      
      (*     type Item = &'a T; *)
      Definition _Item (T A : Ty.t) : Ty.t := Ty.apply (Ty.path "&") [] [ T ].
      
      (*     type IntoIter = Iter<'a, T>; *)
      Definition _IntoIter (T A : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "alloc::collections::linked_list::Iter") [] [ T ].
      
      (*
          fn into_iter(self) -> Iter<'a, T> {
              self.iter()
          }
      *)
      Definition into_iter (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.apply (Ty.path "alloc::collections::linked_list::Iter") [] [ T ],
              M.get_associated_function (|
                Ty.apply (Ty.path "alloc::collections::linked_list::LinkedList") [] [ T; A ],
                "iter",
                [],
                []
              |),
              [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T A : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::collect::IntoIterator"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T A)
          (* Instance *)
          [
            ("Item", InstanceField.Ty (_Item T A));
            ("IntoIter", InstanceField.Ty (_IntoIter T A));
            ("into_iter", InstanceField.Method (into_iter T A))
          ].
    End Impl_core_iter_traits_collect_IntoIterator_where_core_alloc_Allocator_A_for_ref__alloc_collections_linked_list_LinkedList_T_A.
    
    Module Impl_core_iter_traits_collect_IntoIterator_where_core_alloc_Allocator_A_for_ref_mut_alloc_collections_linked_list_LinkedList_T_A.
      Definition Self (T A : Ty.t) : Ty.t :=
        Ty.apply
          (Ty.path "&mut")
          []
          [ Ty.apply (Ty.path "alloc::collections::linked_list::LinkedList") [] [ T; A ] ].
      
      (*     type Item = &'a mut T; *)
      Definition _Item (T A : Ty.t) : Ty.t := Ty.apply (Ty.path "&mut") [] [ T ].
      
      (*     type IntoIter = IterMut<'a, T>; *)
      Definition _IntoIter (T A : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "alloc::collections::linked_list::IterMut") [] [ T ].
      
      (*
          fn into_iter(self) -> IterMut<'a, T> {
              self.iter_mut()
          }
      *)
      Definition into_iter (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.apply (Ty.path "alloc::collections::linked_list::IterMut") [] [ T ],
              M.get_associated_function (|
                Ty.apply (Ty.path "alloc::collections::linked_list::LinkedList") [] [ T; A ],
                "iter_mut",
                [],
                []
              |),
              [ M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T A : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::collect::IntoIterator"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T A)
          (* Instance *)
          [
            ("Item", InstanceField.Ty (_Item T A));
            ("IntoIter", InstanceField.Ty (_IntoIter T A));
            ("into_iter", InstanceField.Method (into_iter T A))
          ].
    End Impl_core_iter_traits_collect_IntoIterator_where_core_alloc_Allocator_A_for_ref_mut_alloc_collections_linked_list_LinkedList_T_A.
    
    Module Impl_core_iter_traits_collect_Extend_where_core_alloc_Allocator_A_T_for_alloc_collections_linked_list_LinkedList_T_A.
      Definition Self (T A : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "alloc::collections::linked_list::LinkedList") [] [ T; A ].
      
      (*
          fn extend<I: IntoIterator<Item = T>>(&mut self, iter: I) {
              <Self as SpecExtend<I>>::spec_extend(self, iter);
          }
      *)
      Definition extend (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match ε, τ, α with
        | [], [ _ as I ], [ self; iter ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let iter := M.alloc (| iter |) in
            M.read (|
              let~ _ : Ty.tuple [] :=
                M.alloc (|
                  M.call_closure (|
                    Ty.tuple [],
                    M.get_trait_method (|
                      "alloc::collections::SpecExtend",
                      Ty.apply (Ty.path "alloc::collections::linked_list::LinkedList") [] [ T; A ],
                      [],
                      [ I ],
                      "spec_extend",
                      [],
                      []
                    |),
                    [
                      M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |);
                      M.read (| iter |)
                    ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn extend_one(&mut self, elem: T) {
              self.push_back(elem);
          }
      *)
      Definition extend_one
          (T A : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self T A in
        match ε, τ, α with
        | [], [], [ self; elem ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let elem := M.alloc (| elem |) in
            M.read (|
              let~ _ : Ty.tuple [] :=
                M.alloc (|
                  M.call_closure (|
                    Ty.tuple [],
                    M.get_associated_function (|
                      Ty.apply (Ty.path "alloc::collections::linked_list::LinkedList") [] [ T; A ],
                      "push_back",
                      [],
                      []
                    |),
                    [
                      M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |);
                      M.read (| elem |)
                    ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T A : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::collect::Extend"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ T ]
          (Self T A)
          (* Instance *)
          [
            ("extend", InstanceField.Method (extend T A));
            ("extend_one", InstanceField.Method (extend_one T A))
          ].
    End Impl_core_iter_traits_collect_Extend_where_core_alloc_Allocator_A_T_for_alloc_collections_linked_list_LinkedList_T_A.
    
    Module Impl_alloc_collections_SpecExtend_where_core_iter_traits_collect_IntoIterator_I_where_core_alloc_Allocator_A_I_for_alloc_collections_linked_list_LinkedList_associated_in_trait_core_iter_traits_collect_IntoIterator___I_Item_A.
      Definition Self (I A : Ty.t) : Ty.t :=
        Ty.apply
          (Ty.path "alloc::collections::linked_list::LinkedList")
          []
          [ Ty.associated_in_trait "core::iter::traits::collect::IntoIterator" [] [] I "Item"; A ].
      
      (*
          default fn spec_extend(&mut self, iter: I) {
              iter.into_iter().for_each(move |elt| self.push_back(elt));
          }
      *)
      Definition spec_extend
          (I A : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self I A in
        match ε, τ, α with
        | [], [], [ self; iter ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let iter := M.alloc (| iter |) in
            M.read (|
              let~ _ : Ty.tuple [] :=
                M.alloc (|
                  M.call_closure (|
                    Ty.tuple [],
                    M.get_trait_method (|
                      "core::iter::traits::iterator::Iterator",
                      Ty.associated_in_trait
                        "core::iter::traits::collect::IntoIterator"
                        []
                        []
                        I
                        "IntoIter",
                      [],
                      [],
                      "for_each",
                      [],
                      [
                        Ty.function
                          [
                            Ty.tuple
                              [
                                Ty.associated_in_trait
                                  "core::iter::traits::collect::IntoIterator"
                                  []
                                  []
                                  I
                                  "Item"
                              ]
                          ]
                          (Ty.tuple [])
                      ]
                    |),
                    [
                      M.call_closure (|
                        Ty.associated_in_trait
                          "core::iter::traits::collect::IntoIterator"
                          []
                          []
                          I
                          "IntoIter",
                        M.get_trait_method (|
                          "core::iter::traits::collect::IntoIterator",
                          I,
                          [],
                          [],
                          "into_iter",
                          [],
                          []
                        |),
                        [ M.read (| iter |) ]
                      |);
                      M.closure
                        (fun γ =>
                          ltac:(M.monadic
                            match γ with
                            | [ α0 ] =>
                              ltac:(M.monadic
                                (M.match_operator (|
                                  Some
                                    (Ty.function
                                      [
                                        Ty.tuple
                                          [
                                            Ty.associated_in_trait
                                              "core::iter::traits::collect::IntoIterator"
                                              []
                                              []
                                              I
                                              "Item"
                                          ]
                                      ]
                                      (Ty.tuple [])),
                                  M.alloc (| α0 |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let elt := M.copy (| γ |) in
                                        M.call_closure (|
                                          Ty.tuple [],
                                          M.get_associated_function (|
                                            Ty.apply
                                              (Ty.path
                                                "alloc::collections::linked_list::LinkedList")
                                              []
                                              [
                                                Ty.associated_in_trait
                                                  "core::iter::traits::collect::IntoIterator"
                                                  []
                                                  []
                                                  I
                                                  "Item";
                                                A
                                              ],
                                            "push_back",
                                            [],
                                            []
                                          |),
                                          [
                                            M.borrow (|
                                              Pointer.Kind.MutRef,
                                              M.deref (| M.read (| self |) |)
                                            |);
                                            M.read (| elt |)
                                          ]
                                        |)))
                                  ]
                                |)))
                            | _ => M.impossible "wrong number of arguments"
                            end))
                    ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (I A : Ty.t),
        M.IsTraitInstance
          "alloc::collections::SpecExtend"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ I ]
          (Self I A)
          (* Instance *) [ ("spec_extend", InstanceField.Method (spec_extend I A)) ].
    End Impl_alloc_collections_SpecExtend_where_core_iter_traits_collect_IntoIterator_I_where_core_alloc_Allocator_A_I_for_alloc_collections_linked_list_LinkedList_associated_in_trait_core_iter_traits_collect_IntoIterator___I_Item_A.
    
    Module Impl_alloc_collections_SpecExtend_alloc_collections_linked_list_LinkedList_T_alloc_alloc_Global_for_alloc_collections_linked_list_LinkedList_T_alloc_alloc_Global.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply
          (Ty.path "alloc::collections::linked_list::LinkedList")
          []
          [ T; Ty.path "alloc::alloc::Global" ].
      
      (*
          fn spec_extend(&mut self, ref mut other: LinkedList<T>) {
              self.append(other);
          }
      *)
      Definition spec_extend (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; β1 ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let β1 := M.alloc (| β1 |) in
            M.match_operator (|
              None,
              β1,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let other := M.alloc (| γ |) in
                    M.read (|
                      let~ _ : Ty.tuple [] :=
                        M.alloc (|
                          M.call_closure (|
                            Ty.tuple [],
                            M.get_associated_function (|
                              Ty.apply
                                (Ty.path "alloc::collections::linked_list::LinkedList")
                                []
                                [ T; Ty.path "alloc::alloc::Global" ],
                              "append",
                              [],
                              []
                            |),
                            [
                              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |);
                              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| other |) |) |)
                            ]
                          |)
                        |) in
                      M.alloc (| Value.Tuple [] |)
                    |)))
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "alloc::collections::SpecExtend"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [
            Ty.apply
              (Ty.path "alloc::collections::linked_list::LinkedList")
              []
              [ T; Ty.path "alloc::alloc::Global" ]
          ]
          (Self T)
          (* Instance *) [ ("spec_extend", InstanceField.Method (spec_extend T)) ].
    End Impl_alloc_collections_SpecExtend_alloc_collections_linked_list_LinkedList_T_alloc_alloc_Global_for_alloc_collections_linked_list_LinkedList_T_alloc_alloc_Global.
    
    Module Impl_core_iter_traits_collect_Extend_where_core_marker_Copy_T_where_core_alloc_Allocator_A_ref__T_for_alloc_collections_linked_list_LinkedList_T_A.
      Definition Self (T A : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "alloc::collections::linked_list::LinkedList") [] [ T; A ].
      
      (*
          fn extend<I: IntoIterator<Item = &'a T>>(&mut self, iter: I) {
              self.extend(iter.into_iter().cloned());
          }
      *)
      Definition extend (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match ε, τ, α with
        | [], [ _ as I ], [ self; iter ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let iter := M.alloc (| iter |) in
            M.read (|
              let~ _ : Ty.tuple [] :=
                M.alloc (|
                  M.call_closure (|
                    Ty.tuple [],
                    M.get_trait_method (|
                      "core::iter::traits::collect::Extend",
                      Ty.apply (Ty.path "alloc::collections::linked_list::LinkedList") [] [ T; A ],
                      [],
                      [ T ],
                      "extend",
                      [],
                      [
                        Ty.apply
                          (Ty.path "core::iter::adapters::cloned::Cloned")
                          []
                          [
                            Ty.associated_in_trait
                              "core::iter::traits::collect::IntoIterator"
                              []
                              []
                              I
                              "IntoIter"
                          ]
                      ]
                    |),
                    [
                      M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |);
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::iter::adapters::cloned::Cloned")
                          []
                          [
                            Ty.associated_in_trait
                              "core::iter::traits::collect::IntoIterator"
                              []
                              []
                              I
                              "IntoIter"
                          ],
                        M.get_trait_method (|
                          "core::iter::traits::iterator::Iterator",
                          Ty.associated_in_trait
                            "core::iter::traits::collect::IntoIterator"
                            []
                            []
                            I
                            "IntoIter",
                          [],
                          [],
                          "cloned",
                          [],
                          [ T ]
                        |),
                        [
                          M.call_closure (|
                            Ty.associated_in_trait
                              "core::iter::traits::collect::IntoIterator"
                              []
                              []
                              I
                              "IntoIter",
                            M.get_trait_method (|
                              "core::iter::traits::collect::IntoIterator",
                              I,
                              [],
                              [],
                              "into_iter",
                              [],
                              []
                            |),
                            [ M.read (| iter |) ]
                          |)
                        ]
                      |)
                    ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn extend_one(&mut self, &elem: &'a T) {
              self.push_back(elem);
          }
      *)
      Definition extend_one
          (T A : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self T A in
        match ε, τ, α with
        | [], [], [ self; β1 ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let β1 := M.alloc (| β1 |) in
            M.match_operator (|
              None,
              β1,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let elem := M.copy (| γ |) in
                    M.read (|
                      let~ _ : Ty.tuple [] :=
                        M.alloc (|
                          M.call_closure (|
                            Ty.tuple [],
                            M.get_associated_function (|
                              Ty.apply
                                (Ty.path "alloc::collections::linked_list::LinkedList")
                                []
                                [ T; A ],
                              "push_back",
                              [],
                              []
                            |),
                            [
                              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |);
                              M.read (| elem |)
                            ]
                          |)
                        |) in
                      M.alloc (| Value.Tuple [] |)
                    |)))
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T A : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::collect::Extend"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.apply (Ty.path "&") [] [ T ] ]
          (Self T A)
          (* Instance *)
          [
            ("extend", InstanceField.Method (extend T A));
            ("extend_one", InstanceField.Method (extend_one T A))
          ].
    End Impl_core_iter_traits_collect_Extend_where_core_marker_Copy_T_where_core_alloc_Allocator_A_ref__T_for_alloc_collections_linked_list_LinkedList_T_A.
    
    Module Impl_core_cmp_PartialEq_where_core_cmp_PartialEq_T_where_core_alloc_Allocator_A_alloc_collections_linked_list_LinkedList_T_A_for_alloc_collections_linked_list_LinkedList_T_A.
      Definition Self (T A : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "alloc::collections::linked_list::LinkedList") [] [ T; A ].
      
      (*
          fn eq(&self, other: &Self) -> bool {
              self.len() == other.len() && self.iter().eq(other)
          }
      *)
      Definition eq (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            LogicalOp.and (|
              M.call_closure (|
                Ty.path "bool",
                BinOp.eq,
                [
                  M.call_closure (|
                    Ty.path "usize",
                    M.get_associated_function (|
                      Ty.apply (Ty.path "alloc::collections::linked_list::LinkedList") [] [ T; A ],
                      "len",
                      [],
                      []
                    |),
                    [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                  |);
                  M.call_closure (|
                    Ty.path "usize",
                    M.get_associated_function (|
                      Ty.apply (Ty.path "alloc::collections::linked_list::LinkedList") [] [ T; A ],
                      "len",
                      [],
                      []
                    |),
                    [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| other |) |) |) ]
                  |)
                ]
              |),
              ltac:(M.monadic
                (M.call_closure (|
                  Ty.path "bool",
                  M.get_trait_method (|
                    "core::iter::traits::iterator::Iterator",
                    Ty.apply (Ty.path "alloc::collections::linked_list::Iter") [] [ T ],
                    [],
                    [],
                    "eq",
                    [],
                    [
                      Ty.apply
                        (Ty.path "&")
                        []
                        [
                          Ty.apply
                            (Ty.path "alloc::collections::linked_list::LinkedList")
                            []
                            [ T; A ]
                        ]
                    ]
                  |),
                  [
                    M.call_closure (|
                      Ty.apply (Ty.path "alloc::collections::linked_list::Iter") [] [ T ],
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "alloc::collections::linked_list::LinkedList")
                          []
                          [ T; A ],
                        "iter",
                        [],
                        []
                      |),
                      [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                    |);
                    M.read (| other |)
                  ]
                |)))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn ne(&self, other: &Self) -> bool {
              self.len() != other.len() || self.iter().ne(other)
          }
      *)
      Definition ne (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            LogicalOp.or (|
              M.call_closure (|
                Ty.path "bool",
                BinOp.ne,
                [
                  M.call_closure (|
                    Ty.path "usize",
                    M.get_associated_function (|
                      Ty.apply (Ty.path "alloc::collections::linked_list::LinkedList") [] [ T; A ],
                      "len",
                      [],
                      []
                    |),
                    [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                  |);
                  M.call_closure (|
                    Ty.path "usize",
                    M.get_associated_function (|
                      Ty.apply (Ty.path "alloc::collections::linked_list::LinkedList") [] [ T; A ],
                      "len",
                      [],
                      []
                    |),
                    [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| other |) |) |) ]
                  |)
                ]
              |),
              ltac:(M.monadic
                (M.call_closure (|
                  Ty.path "bool",
                  M.get_trait_method (|
                    "core::iter::traits::iterator::Iterator",
                    Ty.apply (Ty.path "alloc::collections::linked_list::Iter") [] [ T ],
                    [],
                    [],
                    "ne",
                    [],
                    [
                      Ty.apply
                        (Ty.path "&")
                        []
                        [
                          Ty.apply
                            (Ty.path "alloc::collections::linked_list::LinkedList")
                            []
                            [ T; A ]
                        ]
                    ]
                  |),
                  [
                    M.call_closure (|
                      Ty.apply (Ty.path "alloc::collections::linked_list::Iter") [] [ T ],
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "alloc::collections::linked_list::LinkedList")
                          []
                          [ T; A ],
                        "iter",
                        [],
                        []
                      |),
                      [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                    |);
                    M.read (| other |)
                  ]
                |)))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T A : Ty.t),
        M.IsTraitInstance
          "core::cmp::PartialEq"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "alloc::collections::linked_list::LinkedList") [] [ T; A ] ]
          (Self T A)
          (* Instance *)
          [ ("eq", InstanceField.Method (eq T A)); ("ne", InstanceField.Method (ne T A)) ].
    End Impl_core_cmp_PartialEq_where_core_cmp_PartialEq_T_where_core_alloc_Allocator_A_alloc_collections_linked_list_LinkedList_T_A_for_alloc_collections_linked_list_LinkedList_T_A.
    
    Module Impl_core_cmp_Eq_where_core_cmp_Eq_T_where_core_alloc_Allocator_A_for_alloc_collections_linked_list_LinkedList_T_A.
      Definition Self (T A : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "alloc::collections::linked_list::LinkedList") [] [ T; A ].
      
      Axiom Implements :
        forall (T A : Ty.t),
        M.IsTraitInstance
          "core::cmp::Eq"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T A)
          (* Instance *) [].
    End Impl_core_cmp_Eq_where_core_cmp_Eq_T_where_core_alloc_Allocator_A_for_alloc_collections_linked_list_LinkedList_T_A.
    
    Module Impl_core_cmp_PartialOrd_where_core_cmp_PartialOrd_T_where_core_alloc_Allocator_A_alloc_collections_linked_list_LinkedList_T_A_for_alloc_collections_linked_list_LinkedList_T_A.
      Definition Self (T A : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "alloc::collections::linked_list::LinkedList") [] [ T; A ].
      
      (*
          fn partial_cmp(&self, other: &Self) -> Option<Ordering> {
              self.iter().partial_cmp(other)
          }
      *)
      Definition partial_cmp
          (T A : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self T A in
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "core::cmp::Ordering" ],
              M.get_trait_method (|
                "core::iter::traits::iterator::Iterator",
                Ty.apply (Ty.path "alloc::collections::linked_list::Iter") [] [ T ],
                [],
                [],
                "partial_cmp",
                [],
                [
                  Ty.apply
                    (Ty.path "&")
                    []
                    [ Ty.apply (Ty.path "alloc::collections::linked_list::LinkedList") [] [ T; A ] ]
                ]
              |),
              [
                M.call_closure (|
                  Ty.apply (Ty.path "alloc::collections::linked_list::Iter") [] [ T ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "alloc::collections::linked_list::LinkedList") [] [ T; A ],
                    "iter",
                    [],
                    []
                  |),
                  [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                |);
                M.read (| other |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T A : Ty.t),
        M.IsTraitInstance
          "core::cmp::PartialOrd"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "alloc::collections::linked_list::LinkedList") [] [ T; A ] ]
          (Self T A)
          (* Instance *) [ ("partial_cmp", InstanceField.Method (partial_cmp T A)) ].
    End Impl_core_cmp_PartialOrd_where_core_cmp_PartialOrd_T_where_core_alloc_Allocator_A_alloc_collections_linked_list_LinkedList_T_A_for_alloc_collections_linked_list_LinkedList_T_A.
    
    Module Impl_core_cmp_Ord_where_core_cmp_Ord_T_where_core_alloc_Allocator_A_for_alloc_collections_linked_list_LinkedList_T_A.
      Definition Self (T A : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "alloc::collections::linked_list::LinkedList") [] [ T; A ].
      
      (*
          fn cmp(&self, other: &Self) -> Ordering {
              self.iter().cmp(other)
          }
      *)
      Definition cmp (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              Ty.path "core::cmp::Ordering",
              M.get_trait_method (|
                "core::iter::traits::iterator::Iterator",
                Ty.apply (Ty.path "alloc::collections::linked_list::Iter") [] [ T ],
                [],
                [],
                "cmp",
                [],
                [
                  Ty.apply
                    (Ty.path "&")
                    []
                    [ Ty.apply (Ty.path "alloc::collections::linked_list::LinkedList") [] [ T; A ] ]
                ]
              |),
              [
                M.call_closure (|
                  Ty.apply (Ty.path "alloc::collections::linked_list::Iter") [] [ T ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "alloc::collections::linked_list::LinkedList") [] [ T; A ],
                    "iter",
                    [],
                    []
                  |),
                  [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                |);
                M.read (| other |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T A : Ty.t),
        M.IsTraitInstance
          "core::cmp::Ord"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T A)
          (* Instance *) [ ("cmp", InstanceField.Method (cmp T A)) ].
    End Impl_core_cmp_Ord_where_core_cmp_Ord_T_where_core_alloc_Allocator_A_for_alloc_collections_linked_list_LinkedList_T_A.
    
    Module Impl_core_clone_Clone_where_core_clone_Clone_T_where_core_alloc_Allocator_A_where_core_clone_Clone_A_for_alloc_collections_linked_list_LinkedList_T_A.
      Definition Self (T A : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "alloc::collections::linked_list::LinkedList") [] [ T; A ].
      
      (*
          fn clone(&self) -> Self {
              let mut list = Self::new_in(self.alloc.clone());
              list.extend(self.iter().cloned());
              list
          }
      *)
      Definition clone (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              let~ list :
                  Ty.apply (Ty.path "alloc::collections::linked_list::LinkedList") [] [ T; A ] :=
                M.alloc (|
                  M.call_closure (|
                    Ty.apply (Ty.path "alloc::collections::linked_list::LinkedList") [] [ T; A ],
                    M.get_associated_function (|
                      Ty.apply (Ty.path "alloc::collections::linked_list::LinkedList") [] [ T; A ],
                      "new_in",
                      [],
                      []
                    |),
                    [
                      M.call_closure (|
                        A,
                        M.get_trait_method (| "core::clone::Clone", A, [], [], "clone", [], [] |),
                        [
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| self |) |),
                              "alloc::collections::linked_list::LinkedList",
                              "alloc"
                            |)
                          |)
                        ]
                      |)
                    ]
                  |)
                |) in
              let~ _ : Ty.tuple [] :=
                M.alloc (|
                  M.call_closure (|
                    Ty.tuple [],
                    M.get_trait_method (|
                      "core::iter::traits::collect::Extend",
                      Ty.apply (Ty.path "alloc::collections::linked_list::LinkedList") [] [ T; A ],
                      [],
                      [ T ],
                      "extend",
                      [],
                      [
                        Ty.apply
                          (Ty.path "core::iter::adapters::cloned::Cloned")
                          []
                          [ Ty.apply (Ty.path "alloc::collections::linked_list::Iter") [] [ T ] ]
                      ]
                    |),
                    [
                      M.borrow (| Pointer.Kind.MutRef, list |);
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::iter::adapters::cloned::Cloned")
                          []
                          [ Ty.apply (Ty.path "alloc::collections::linked_list::Iter") [] [ T ] ],
                        M.get_trait_method (|
                          "core::iter::traits::iterator::Iterator",
                          Ty.apply (Ty.path "alloc::collections::linked_list::Iter") [] [ T ],
                          [],
                          [],
                          "cloned",
                          [],
                          [ T ]
                        |),
                        [
                          M.call_closure (|
                            Ty.apply (Ty.path "alloc::collections::linked_list::Iter") [] [ T ],
                            M.get_associated_function (|
                              Ty.apply
                                (Ty.path "alloc::collections::linked_list::LinkedList")
                                []
                                [ T; A ],
                              "iter",
                              [],
                              []
                            |),
                            [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                          |)
                        ]
                      |)
                    ]
                  |)
                |) in
              list
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn clone_from(&mut self, source: &Self) {
              let mut source_iter = source.iter();
              if self.len() > source.len() {
                  self.split_off(source.len());
              }
              for (elem, source_elem) in self.iter_mut().zip(&mut source_iter) {
                  elem.clone_from(source_elem);
              }
              if !source_iter.is_empty() {
                  self.extend(source_iter.cloned());
              }
          }
      *)
      Definition clone_from
          (T A : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self T A in
        match ε, τ, α with
        | [], [], [ self; source ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let source := M.alloc (| source |) in
            M.read (|
              let~ source_iter :
                  Ty.apply (Ty.path "alloc::collections::linked_list::Iter") [] [ T ] :=
                M.alloc (|
                  M.call_closure (|
                    Ty.apply (Ty.path "alloc::collections::linked_list::Iter") [] [ T ],
                    M.get_associated_function (|
                      Ty.apply (Ty.path "alloc::collections::linked_list::LinkedList") [] [ T; A ],
                      "iter",
                      [],
                      []
                    |),
                    [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| source |) |) |) ]
                  |)
                |) in
              let~ _ : Ty.tuple [] :=
                M.match_operator (|
                  Some (Ty.tuple []),
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ :=
                          M.use
                            (M.alloc (|
                              M.call_closure (|
                                Ty.path "bool",
                                BinOp.gt,
                                [
                                  M.call_closure (|
                                    Ty.path "usize",
                                    M.get_associated_function (|
                                      Ty.apply
                                        (Ty.path "alloc::collections::linked_list::LinkedList")
                                        []
                                        [ T; A ],
                                      "len",
                                      [],
                                      []
                                    |),
                                    [
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.deref (| M.read (| self |) |)
                                      |)
                                    ]
                                  |);
                                  M.call_closure (|
                                    Ty.path "usize",
                                    M.get_associated_function (|
                                      Ty.apply
                                        (Ty.path "alloc::collections::linked_list::LinkedList")
                                        []
                                        [ T; A ],
                                      "len",
                                      [],
                                      []
                                    |),
                                    [
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.deref (| M.read (| source |) |)
                                      |)
                                    ]
                                  |)
                                ]
                              |)
                            |)) in
                        let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        let~ _ :
                            Ty.apply
                              (Ty.path "alloc::collections::linked_list::LinkedList")
                              []
                              [ T; A ] :=
                          M.alloc (|
                            M.call_closure (|
                              Ty.apply
                                (Ty.path "alloc::collections::linked_list::LinkedList")
                                []
                                [ T; A ],
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "alloc::collections::linked_list::LinkedList")
                                  []
                                  [ T; A ],
                                "split_off",
                                [],
                                []
                              |),
                              [
                                M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |);
                                M.call_closure (|
                                  Ty.path "usize",
                                  M.get_associated_function (|
                                    Ty.apply
                                      (Ty.path "alloc::collections::linked_list::LinkedList")
                                      []
                                      [ T; A ],
                                    "len",
                                    [],
                                    []
                                  |),
                                  [
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.deref (| M.read (| source |) |)
                                    |)
                                  ]
                                |)
                              ]
                            |)
                          |) in
                        M.alloc (| Value.Tuple [] |)));
                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                  ]
                |) in
              let~ _ : Ty.tuple [] :=
                M.use
                  (M.match_operator (|
                    Some (Ty.tuple []),
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::iter::adapters::zip::Zip")
                          []
                          [
                            Ty.apply (Ty.path "alloc::collections::linked_list::IterMut") [] [ T ];
                            Ty.apply
                              (Ty.path "&mut")
                              []
                              [ Ty.apply (Ty.path "alloc::collections::linked_list::Iter") [] [ T ]
                              ]
                          ],
                        M.get_trait_method (|
                          "core::iter::traits::collect::IntoIterator",
                          Ty.apply
                            (Ty.path "core::iter::adapters::zip::Zip")
                            []
                            [
                              Ty.apply
                                (Ty.path "alloc::collections::linked_list::IterMut")
                                []
                                [ T ];
                              Ty.apply
                                (Ty.path "&mut")
                                []
                                [
                                  Ty.apply
                                    (Ty.path "alloc::collections::linked_list::Iter")
                                    []
                                    [ T ]
                                ]
                            ],
                          [],
                          [],
                          "into_iter",
                          [],
                          []
                        |),
                        [
                          M.call_closure (|
                            Ty.apply
                              (Ty.path "core::iter::adapters::zip::Zip")
                              []
                              [
                                Ty.apply
                                  (Ty.path "alloc::collections::linked_list::IterMut")
                                  []
                                  [ T ];
                                Ty.apply
                                  (Ty.path "&mut")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "alloc::collections::linked_list::Iter")
                                      []
                                      [ T ]
                                  ]
                              ],
                            M.get_trait_method (|
                              "core::iter::traits::iterator::Iterator",
                              Ty.apply
                                (Ty.path "alloc::collections::linked_list::IterMut")
                                []
                                [ T ],
                              [],
                              [],
                              "zip",
                              [],
                              [
                                Ty.apply
                                  (Ty.path "&mut")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "alloc::collections::linked_list::Iter")
                                      []
                                      [ T ]
                                  ]
                              ]
                            |),
                            [
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "alloc::collections::linked_list::IterMut")
                                  []
                                  [ T ],
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "alloc::collections::linked_list::LinkedList")
                                    []
                                    [ T; A ],
                                  "iter_mut",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (|
                                    Pointer.Kind.MutRef,
                                    M.deref (| M.read (| self |) |)
                                  |)
                                ]
                              |);
                              M.borrow (| Pointer.Kind.MutRef, source_iter |)
                            ]
                          |)
                        ]
                      |)
                    |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let iter := M.copy (| γ |) in
                          M.loop (|
                            Ty.tuple [],
                            ltac:(M.monadic
                              (let~ _ : Ty.tuple [] :=
                                M.match_operator (|
                                  Some (Ty.tuple []),
                                  M.alloc (|
                                    M.call_closure (|
                                      Ty.apply
                                        (Ty.path "core::option::Option")
                                        []
                                        [
                                          Ty.tuple
                                            [
                                              Ty.apply (Ty.path "&mut") [] [ T ];
                                              Ty.apply (Ty.path "&") [] [ T ]
                                            ]
                                        ],
                                      M.get_trait_method (|
                                        "core::iter::traits::iterator::Iterator",
                                        Ty.apply
                                          (Ty.path "core::iter::adapters::zip::Zip")
                                          []
                                          [
                                            Ty.apply
                                              (Ty.path "alloc::collections::linked_list::IterMut")
                                              []
                                              [ T ];
                                            Ty.apply
                                              (Ty.path "&mut")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "alloc::collections::linked_list::Iter")
                                                  []
                                                  [ T ]
                                              ]
                                          ],
                                        [],
                                        [],
                                        "next",
                                        [],
                                        []
                                      |),
                                      [
                                        M.borrow (|
                                          Pointer.Kind.MutRef,
                                          M.deref (| M.borrow (| Pointer.Kind.MutRef, iter |) |)
                                        |)
                                      ]
                                    |)
                                  |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let _ :=
                                          M.is_struct_tuple (| γ, "core::option::Option::None" |) in
                                        M.alloc (|
                                          M.never_to_any (| M.read (| M.break (||) |) |)
                                        |)));
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ0_0 :=
                                          M.SubPointer.get_struct_tuple_field (|
                                            γ,
                                            "core::option::Option::Some",
                                            0
                                          |) in
                                        let γ1_0 := M.SubPointer.get_tuple_field (| γ0_0, 0 |) in
                                        let γ1_1 := M.SubPointer.get_tuple_field (| γ0_0, 1 |) in
                                        let elem := M.copy (| γ1_0 |) in
                                        let source_elem := M.copy (| γ1_1 |) in
                                        let~ _ : Ty.tuple [] :=
                                          M.alloc (|
                                            M.call_closure (|
                                              Ty.tuple [],
                                              M.get_trait_method (|
                                                "core::clone::Clone",
                                                T,
                                                [],
                                                [],
                                                "clone_from",
                                                [],
                                                []
                                              |),
                                              [
                                                M.borrow (|
                                                  Pointer.Kind.MutRef,
                                                  M.deref (| M.read (| elem |) |)
                                                |);
                                                M.borrow (|
                                                  Pointer.Kind.Ref,
                                                  M.deref (| M.read (| source_elem |) |)
                                                |)
                                              ]
                                            |)
                                          |) in
                                        M.alloc (| Value.Tuple [] |)))
                                  ]
                                |) in
                              M.alloc (| Value.Tuple [] |)))
                          |)))
                    ]
                  |)) in
              M.match_operator (|
                Some (Ty.tuple []),
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            UnOp.not (|
                              M.call_closure (|
                                Ty.path "bool",
                                M.get_trait_method (|
                                  "core::iter::traits::exact_size::ExactSizeIterator",
                                  Ty.apply
                                    (Ty.path "alloc::collections::linked_list::Iter")
                                    []
                                    [ T ],
                                  [],
                                  [],
                                  "is_empty",
                                  [],
                                  []
                                |),
                                [ M.borrow (| Pointer.Kind.Ref, source_iter |) ]
                              |)
                            |)
                          |)) in
                      let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      let~ _ : Ty.tuple [] :=
                        M.alloc (|
                          M.call_closure (|
                            Ty.tuple [],
                            M.get_trait_method (|
                              "core::iter::traits::collect::Extend",
                              Ty.apply
                                (Ty.path "alloc::collections::linked_list::LinkedList")
                                []
                                [ T; A ],
                              [],
                              [ T ],
                              "extend",
                              [],
                              [
                                Ty.apply
                                  (Ty.path "core::iter::adapters::cloned::Cloned")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "alloc::collections::linked_list::Iter")
                                      []
                                      [ T ]
                                  ]
                              ]
                            |),
                            [
                              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |);
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "core::iter::adapters::cloned::Cloned")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "alloc::collections::linked_list::Iter")
                                      []
                                      [ T ]
                                  ],
                                M.get_trait_method (|
                                  "core::iter::traits::iterator::Iterator",
                                  Ty.apply
                                    (Ty.path "alloc::collections::linked_list::Iter")
                                    []
                                    [ T ],
                                  [],
                                  [],
                                  "cloned",
                                  [],
                                  [ T ]
                                |),
                                [ M.read (| source_iter |) ]
                              |)
                            ]
                          |)
                        |) in
                      M.alloc (| Value.Tuple [] |)));
                  fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T A : Ty.t),
        M.IsTraitInstance
          "core::clone::Clone"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T A)
          (* Instance *)
          [
            ("clone", InstanceField.Method (clone T A));
            ("clone_from", InstanceField.Method (clone_from T A))
          ].
    End Impl_core_clone_Clone_where_core_clone_Clone_T_where_core_alloc_Allocator_A_where_core_clone_Clone_A_for_alloc_collections_linked_list_LinkedList_T_A.
    
    Module Impl_core_fmt_Debug_where_core_fmt_Debug_T_where_core_alloc_Allocator_A_for_alloc_collections_linked_list_LinkedList_T_A.
      Definition Self (T A : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "alloc::collections::linked_list::LinkedList") [] [ T; A ].
      
      (*
          fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
              f.debug_list().entries(self).finish()
          }
      *)
      Definition fmt (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match ε, τ, α with
        | [], [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "core::result::Result")
                []
                [ Ty.tuple []; Ty.path "core::fmt::Error" ],
              M.get_associated_function (|
                Ty.path "core::fmt::builders::DebugList",
                "finish",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.deref (|
                    M.call_closure (|
                      Ty.apply (Ty.path "&mut") [] [ Ty.path "core::fmt::builders::DebugList" ],
                      M.get_associated_function (|
                        Ty.path "core::fmt::builders::DebugList",
                        "entries",
                        [],
                        [
                          Ty.apply (Ty.path "&") [] [ T ];
                          Ty.apply
                            (Ty.path "&")
                            []
                            [
                              Ty.apply
                                (Ty.path "alloc::collections::linked_list::LinkedList")
                                []
                                [ T; A ]
                            ]
                        ]
                      |),
                      [
                        M.borrow (|
                          Pointer.Kind.MutRef,
                          M.alloc (|
                            M.call_closure (|
                              Ty.path "core::fmt::builders::DebugList",
                              M.get_associated_function (|
                                Ty.path "core::fmt::Formatter",
                                "debug_list",
                                [],
                                []
                              |),
                              [ M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |) ]
                            |)
                          |)
                        |);
                        M.read (| self |)
                      ]
                    |)
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T A : Ty.t),
        M.IsTraitInstance
          "core::fmt::Debug"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T A)
          (* Instance *) [ ("fmt", InstanceField.Method (fmt T A)) ].
    End Impl_core_fmt_Debug_where_core_fmt_Debug_T_where_core_alloc_Allocator_A_for_alloc_collections_linked_list_LinkedList_T_A.
    
    Module Impl_core_hash_Hash_where_core_hash_Hash_T_where_core_alloc_Allocator_A_for_alloc_collections_linked_list_LinkedList_T_A.
      Definition Self (T A : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "alloc::collections::linked_list::LinkedList") [] [ T; A ].
      
      (*
          fn hash<H: Hasher>(&self, state: &mut H) {
              state.write_length_prefix(self.len());
              for elt in self {
                  elt.hash(state);
              }
          }
      *)
      Definition hash (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match ε, τ, α with
        | [], [ H ], [ self; state ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let state := M.alloc (| state |) in
            M.read (|
              let~ _ : Ty.tuple [] :=
                M.alloc (|
                  M.call_closure (|
                    Ty.tuple [],
                    M.get_trait_method (|
                      "core::hash::Hasher",
                      H,
                      [],
                      [],
                      "write_length_prefix",
                      [],
                      []
                    |),
                    [
                      M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |);
                      M.call_closure (|
                        Ty.path "usize",
                        M.get_associated_function (|
                          Ty.apply
                            (Ty.path "alloc::collections::linked_list::LinkedList")
                            []
                            [ T; A ],
                          "len",
                          [],
                          []
                        |),
                        [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                      |)
                    ]
                  |)
                |) in
              M.use
                (M.match_operator (|
                  Some (Ty.tuple []),
                  M.alloc (|
                    M.call_closure (|
                      Ty.apply (Ty.path "alloc::collections::linked_list::Iter") [] [ T ],
                      M.get_trait_method (|
                        "core::iter::traits::collect::IntoIterator",
                        Ty.apply
                          (Ty.path "&")
                          []
                          [
                            Ty.apply
                              (Ty.path "alloc::collections::linked_list::LinkedList")
                              []
                              [ T; A ]
                          ],
                        [],
                        [],
                        "into_iter",
                        [],
                        []
                      |),
                      [ M.read (| self |) ]
                    |)
                  |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let iter := M.copy (| γ |) in
                        M.loop (|
                          Ty.tuple [],
                          ltac:(M.monadic
                            (let~ _ : Ty.tuple [] :=
                              M.match_operator (|
                                Some (Ty.tuple []),
                                M.alloc (|
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "core::option::Option")
                                      []
                                      [ Ty.apply (Ty.path "&") [] [ T ] ],
                                    M.get_trait_method (|
                                      "core::iter::traits::iterator::Iterator",
                                      Ty.apply
                                        (Ty.path "alloc::collections::linked_list::Iter")
                                        []
                                        [ T ],
                                      [],
                                      [],
                                      "next",
                                      [],
                                      []
                                    |),
                                    [
                                      M.borrow (|
                                        Pointer.Kind.MutRef,
                                        M.deref (| M.borrow (| Pointer.Kind.MutRef, iter |) |)
                                      |)
                                    ]
                                  |)
                                |),
                                [
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let _ :=
                                        M.is_struct_tuple (| γ, "core::option::Option::None" |) in
                                      M.alloc (|
                                        M.never_to_any (| M.read (| M.break (||) |) |)
                                      |)));
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let γ0_0 :=
                                        M.SubPointer.get_struct_tuple_field (|
                                          γ,
                                          "core::option::Option::Some",
                                          0
                                        |) in
                                      let elt := M.copy (| γ0_0 |) in
                                      let~ _ : Ty.tuple [] :=
                                        M.alloc (|
                                          M.call_closure (|
                                            Ty.tuple [],
                                            M.get_trait_method (|
                                              "core::hash::Hash",
                                              T,
                                              [],
                                              [],
                                              "hash",
                                              [],
                                              [ H ]
                                            |),
                                            [
                                              M.borrow (|
                                                Pointer.Kind.Ref,
                                                M.deref (| M.read (| elt |) |)
                                              |);
                                              M.borrow (|
                                                Pointer.Kind.MutRef,
                                                M.deref (| M.read (| state |) |)
                                              |)
                                            ]
                                          |)
                                        |) in
                                      M.alloc (| Value.Tuple [] |)))
                                ]
                              |) in
                            M.alloc (| Value.Tuple [] |)))
                        |)))
                  ]
                |))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T A : Ty.t),
        M.IsTraitInstance
          "core::hash::Hash"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T A)
          (* Instance *) [ ("hash", InstanceField.Method (hash T A)) ].
    End Impl_core_hash_Hash_where_core_hash_Hash_T_where_core_alloc_Allocator_A_for_alloc_collections_linked_list_LinkedList_T_A.
    
    Module Impl_core_convert_From_array_N_T_for_alloc_collections_linked_list_LinkedList_T_alloc_alloc_Global.
      Definition Self (N : Value.t) (T : Ty.t) : Ty.t :=
        Ty.apply
          (Ty.path "alloc::collections::linked_list::LinkedList")
          []
          [ T; Ty.path "alloc::alloc::Global" ].
      
      (*
          fn from(arr: [T; N]) -> Self {
              Self::from_iter(arr)
          }
      *)
      Definition from
          (N : Value.t)
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self N T in
        match ε, τ, α with
        | [], [], [ arr ] =>
          ltac:(M.monadic
            (let arr := M.alloc (| arr |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "alloc::collections::linked_list::LinkedList")
                []
                [ T; Ty.path "alloc::alloc::Global" ],
              M.get_trait_method (|
                "core::iter::traits::collect::FromIterator",
                Ty.apply
                  (Ty.path "alloc::collections::linked_list::LinkedList")
                  []
                  [ T; Ty.path "alloc::alloc::Global" ],
                [],
                [ T ],
                "from_iter",
                [],
                [ Ty.apply (Ty.path "array") [ N ] [ T ] ]
              |),
              [ M.read (| arr |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (N : Value.t) (T : Ty.t),
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.apply (Ty.path "array") [ N ] [ T ] ]
          (Self N T)
          (* Instance *) [ ("from", InstanceField.Method (from N T)) ].
    End Impl_core_convert_From_array_N_T_for_alloc_collections_linked_list_LinkedList_T_alloc_alloc_Global.
    
    (*
    fn assert_covariance() {
        fn a<'a>(x: LinkedList<&'static str>) -> LinkedList<&'a str> {
            x
        }
        fn b<'i, 'a>(x: Iter<'i, &'static str>) -> Iter<'i, &'a str> {
            x
        }
        fn c<'a>(x: IntoIter<&'static str>) -> IntoIter<&'a str> {
            x
        }
    }
    *)
    Definition assert_covariance (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [] => ltac:(M.monadic (Value.Tuple []))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance Instance_IsFunction_assert_covariance :
      M.IsFunction.C "alloc::collections::linked_list::assert_covariance" assert_covariance.
    Admitted.
    Global Typeclasses Opaque assert_covariance.
    
    Module assert_covariance.
      (*
          fn a<'a>(x: LinkedList<&'static str>) -> LinkedList<&'a str> {
              x
          }
      *)
      Definition a (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ x ] =>
          ltac:(M.monadic
            (let x := M.alloc (| x |) in
            M.read (| x |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance Instance_IsFunction_a :
        M.IsFunction.C "alloc::collections::linked_list::assert_covariance::a" a.
      Admitted.
      Global Typeclasses Opaque a.
      
      (*
          fn b<'i, 'a>(x: Iter<'i, &'static str>) -> Iter<'i, &'a str> {
              x
          }
      *)
      Definition b (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ x ] =>
          ltac:(M.monadic
            (let x := M.alloc (| x |) in
            M.read (| x |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance Instance_IsFunction_b :
        M.IsFunction.C "alloc::collections::linked_list::assert_covariance::b" b.
      Admitted.
      Global Typeclasses Opaque b.
      
      (*
          fn c<'a>(x: IntoIter<&'static str>) -> IntoIter<&'a str> {
              x
          }
      *)
      Definition c (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ x ] =>
          ltac:(M.monadic
            (let x := M.alloc (| x |) in
            M.read (| x |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance Instance_IsFunction_c :
        M.IsFunction.C "alloc::collections::linked_list::assert_covariance::c" c.
      Admitted.
      Global Typeclasses Opaque c.
    End assert_covariance.
    
    Module Impl_core_marker_Send_where_core_marker_Send_T_where_core_alloc_Allocator_A_where_core_marker_Send_A_for_alloc_collections_linked_list_LinkedList_T_A.
      Definition Self (T A : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "alloc::collections::linked_list::LinkedList") [] [ T; A ].
      
      Axiom Implements :
        forall (T A : Ty.t),
        M.IsTraitInstance
          "core::marker::Send"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T A)
          (* Instance *) [].
    End Impl_core_marker_Send_where_core_marker_Send_T_where_core_alloc_Allocator_A_where_core_marker_Send_A_for_alloc_collections_linked_list_LinkedList_T_A.
    
    Module Impl_core_marker_Sync_where_core_marker_Sync_T_where_core_alloc_Allocator_A_where_core_marker_Sync_A_for_alloc_collections_linked_list_LinkedList_T_A.
      Definition Self (T A : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "alloc::collections::linked_list::LinkedList") [] [ T; A ].
      
      Axiom Implements :
        forall (T A : Ty.t),
        M.IsTraitInstance
          "core::marker::Sync"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T A)
          (* Instance *) [].
    End Impl_core_marker_Sync_where_core_marker_Sync_T_where_core_alloc_Allocator_A_where_core_marker_Sync_A_for_alloc_collections_linked_list_LinkedList_T_A.
    
    Module Impl_core_marker_Send_where_core_marker_Sync_T_for_alloc_collections_linked_list_Iter_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "alloc::collections::linked_list::Iter") [] [ T ].
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::marker::Send"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T)
          (* Instance *) [].
    End Impl_core_marker_Send_where_core_marker_Sync_T_for_alloc_collections_linked_list_Iter_T.
    
    Module Impl_core_marker_Sync_where_core_marker_Sync_T_for_alloc_collections_linked_list_Iter_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "alloc::collections::linked_list::Iter") [] [ T ].
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::marker::Sync"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T)
          (* Instance *) [].
    End Impl_core_marker_Sync_where_core_marker_Sync_T_for_alloc_collections_linked_list_Iter_T.
    
    Module Impl_core_marker_Send_where_core_marker_Send_T_for_alloc_collections_linked_list_IterMut_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "alloc::collections::linked_list::IterMut") [] [ T ].
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::marker::Send"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T)
          (* Instance *) [].
    End Impl_core_marker_Send_where_core_marker_Send_T_for_alloc_collections_linked_list_IterMut_T.
    
    Module Impl_core_marker_Sync_where_core_marker_Sync_T_for_alloc_collections_linked_list_IterMut_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "alloc::collections::linked_list::IterMut") [] [ T ].
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::marker::Sync"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T)
          (* Instance *) [].
    End Impl_core_marker_Sync_where_core_marker_Sync_T_for_alloc_collections_linked_list_IterMut_T.
    
    Module Impl_core_marker_Send_where_core_marker_Sync_T_where_core_alloc_Allocator_A_where_core_marker_Sync_A_for_alloc_collections_linked_list_Cursor_T_A.
      Definition Self (T A : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "alloc::collections::linked_list::Cursor") [] [ T; A ].
      
      Axiom Implements :
        forall (T A : Ty.t),
        M.IsTraitInstance
          "core::marker::Send"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T A)
          (* Instance *) [].
    End Impl_core_marker_Send_where_core_marker_Sync_T_where_core_alloc_Allocator_A_where_core_marker_Sync_A_for_alloc_collections_linked_list_Cursor_T_A.
    
    Module Impl_core_marker_Sync_where_core_marker_Sync_T_where_core_alloc_Allocator_A_where_core_marker_Sync_A_for_alloc_collections_linked_list_Cursor_T_A.
      Definition Self (T A : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "alloc::collections::linked_list::Cursor") [] [ T; A ].
      
      Axiom Implements :
        forall (T A : Ty.t),
        M.IsTraitInstance
          "core::marker::Sync"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T A)
          (* Instance *) [].
    End Impl_core_marker_Sync_where_core_marker_Sync_T_where_core_alloc_Allocator_A_where_core_marker_Sync_A_for_alloc_collections_linked_list_Cursor_T_A.
    
    Module Impl_core_marker_Send_where_core_marker_Send_T_where_core_alloc_Allocator_A_where_core_marker_Send_A_for_alloc_collections_linked_list_CursorMut_T_A.
      Definition Self (T A : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "alloc::collections::linked_list::CursorMut") [] [ T; A ].
      
      Axiom Implements :
        forall (T A : Ty.t),
        M.IsTraitInstance
          "core::marker::Send"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T A)
          (* Instance *) [].
    End Impl_core_marker_Send_where_core_marker_Send_T_where_core_alloc_Allocator_A_where_core_marker_Send_A_for_alloc_collections_linked_list_CursorMut_T_A.
    
    Module Impl_core_marker_Sync_where_core_marker_Sync_T_where_core_alloc_Allocator_A_where_core_marker_Sync_A_for_alloc_collections_linked_list_CursorMut_T_A.
      Definition Self (T A : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "alloc::collections::linked_list::CursorMut") [] [ T; A ].
      
      Axiom Implements :
        forall (T A : Ty.t),
        M.IsTraitInstance
          "core::marker::Sync"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T A)
          (* Instance *) [].
    End Impl_core_marker_Sync_where_core_marker_Sync_T_where_core_alloc_Allocator_A_where_core_marker_Sync_A_for_alloc_collections_linked_list_CursorMut_T_A.
  End linked_list.
End collections.
