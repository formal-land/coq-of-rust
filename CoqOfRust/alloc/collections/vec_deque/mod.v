(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module collections.
  Module vec_deque.
    (* StructRecord
      {
        name := "VecDeque";
        ty_params := [ "T"; "A" ];
        fields :=
          [
            ("head", Ty.path "usize");
            ("len", Ty.path "usize");
            ("buf", Ty.apply (Ty.path "alloc::raw_vec::RawVec") [ T; A ])
          ];
      } *)
    
    Module Impl_core_clone_Clone_where_core_clone_Clone_T_where_core_alloc_Allocator_A_where_core_clone_Clone_A_for_alloc_collections_vec_deque_VecDeque_T_A.
      Definition Self (T A : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "alloc::collections::vec_deque::VecDeque") [ T; A ].
      
      (*
          fn clone(&self) -> Self {
              let mut deq = Self::with_capacity_in(self.len(), self.allocator().clone());
              deq.extend(self.iter().cloned());
              deq
          }
      *)
      Definition clone (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              let deq :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply (Ty.path "alloc::collections::vec_deque::VecDeque") [ T; A ],
                      "with_capacity_in",
                      []
                    |),
                    [
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "alloc::collections::vec_deque::VecDeque") [ T; A ],
                          "len",
                          []
                        |),
                        [ M.read (| self |) ]
                      |);
                      M.call_closure (|
                        M.get_trait_method (| "core::clone::Clone", A, [], "clone", [] |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply (Ty.path "alloc::collections::vec_deque::VecDeque") [ T; A ],
                              "allocator",
                              []
                            |),
                            [ M.read (| self |) ]
                          |)
                        ]
                      |)
                    ]
                  |)
                |) in
              let _ :=
                M.alloc (|
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::iter::traits::collect::Extend",
                      Ty.apply (Ty.path "alloc::collections::vec_deque::VecDeque") [ T; A ],
                      [ T ],
                      "extend",
                      [
                        Ty.apply
                          (Ty.path "core::iter::adapters::cloned::Cloned")
                          [ Ty.apply (Ty.path "alloc::collections::vec_deque::iter::Iter") [ T ] ]
                      ]
                    |),
                    [
                      deq;
                      M.call_closure (|
                        M.get_trait_method (|
                          "core::iter::traits::iterator::Iterator",
                          Ty.apply (Ty.path "alloc::collections::vec_deque::iter::Iter") [ T ],
                          [],
                          "cloned",
                          [ T ]
                        |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply (Ty.path "alloc::collections::vec_deque::VecDeque") [ T; A ],
                              "iter",
                              []
                            |),
                            [ M.read (| self |) ]
                          |)
                        ]
                      |)
                    ]
                  |)
                |) in
              deq
            |)))
        | _, _ => M.impossible
        end.
      
      (*
          fn clone_from(&mut self, other: &Self) {
              self.clear();
              self.extend(other.iter().cloned());
          }
      *)
      Definition clone_from (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let _ :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply (Ty.path "alloc::collections::vec_deque::VecDeque") [ T; A ],
                      "clear",
                      []
                    |),
                    [ M.read (| self |) ]
                  |)
                |) in
              let _ :=
                M.alloc (|
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::iter::traits::collect::Extend",
                      Ty.apply (Ty.path "alloc::collections::vec_deque::VecDeque") [ T; A ],
                      [ T ],
                      "extend",
                      [
                        Ty.apply
                          (Ty.path "core::iter::adapters::cloned::Cloned")
                          [ Ty.apply (Ty.path "alloc::collections::vec_deque::iter::Iter") [ T ] ]
                      ]
                    |),
                    [
                      M.read (| self |);
                      M.call_closure (|
                        M.get_trait_method (|
                          "core::iter::traits::iterator::Iterator",
                          Ty.apply (Ty.path "alloc::collections::vec_deque::iter::Iter") [ T ],
                          [],
                          "cloned",
                          [ T ]
                        |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply (Ty.path "alloc::collections::vec_deque::VecDeque") [ T; A ],
                              "iter",
                              []
                            |),
                            [ M.read (| other |) ]
                          |)
                        ]
                      |)
                    ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (T A : Ty.t),
        M.IsTraitInstance
          "core::clone::Clone"
          (Self T A)
          (* Trait polymorphic types *) []
          (* Instance *)
          [
            ("clone", InstanceField.Method (clone T A));
            ("clone_from", InstanceField.Method (clone_from T A))
          ].
    End Impl_core_clone_Clone_where_core_clone_Clone_T_where_core_alloc_Allocator_A_where_core_clone_Clone_A_for_alloc_collections_vec_deque_VecDeque_T_A.
    
    Module Impl_core_ops_drop_Drop_where_core_alloc_Allocator_A_for_alloc_collections_vec_deque_VecDeque_T_A.
      Definition Self (T A : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "alloc::collections::vec_deque::VecDeque") [ T; A ].
      
      (*
          fn drop(&mut self) {
              /// Runs the destructor for all items in the slice when it gets dropped (normally or
              /// during unwinding).
              struct Dropper<'a, T>(&'a mut [T]);
      
              impl<'a, T> Drop for Dropper<'a, T> {
                  fn drop(&mut self) {
                      unsafe {
                          ptr::drop_in_place(self.0);
                      }
                  }
              }
      
              let (front, back) = self.as_mut_slices();
              unsafe {
                  let _back_dropper = Dropper(back);
                  // use drop for [T]
                  ptr::drop_in_place(front);
              }
              // RawVec handles deallocation
          }
      *)
      Definition drop (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply (Ty.path "alloc::collections::vec_deque::VecDeque") [ T; A ],
                      "as_mut_slices",
                      []
                    |),
                    [ M.read (| self |) ]
                  |)
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      let front := M.copy (| γ0_0 |) in
                      let back := M.copy (| γ0_1 |) in
                      let _back_dropper :=
                        M.alloc (|
                          Value.StructTuple
                            "alloc::collections::vec_deque::drop::Dropper"
                            [ M.read (| back |) ]
                        |) in
                      let _ :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_function (|
                              "core::ptr::drop_in_place",
                              [ Ty.apply (Ty.path "slice") [ T ] ]
                            |),
                            [ M.read (| front |) ]
                          |)
                        |) in
                      M.alloc (| Value.Tuple [] |)))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (T A : Ty.t),
        M.IsTraitInstance
          "core::ops::drop::Drop"
          (Self T A)
          (* Trait polymorphic types *) []
          (* Instance *) [ ("drop", InstanceField.Method (drop T A)) ].
    End Impl_core_ops_drop_Drop_where_core_alloc_Allocator_A_for_alloc_collections_vec_deque_VecDeque_T_A.
    
    Module Impl_core_default_Default_for_alloc_collections_vec_deque_VecDeque_T_alloc_alloc_Global.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply
          (Ty.path "alloc::collections::vec_deque::VecDeque")
          [ T; Ty.path "alloc::alloc::Global" ].
      
      (*
          fn default() -> VecDeque<T> {
              VecDeque::new()
          }
      *)
      Definition default (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [] =>
          ltac:(M.monadic
            (M.call_closure (|
              M.get_associated_function (|
                Ty.apply
                  (Ty.path "alloc::collections::vec_deque::VecDeque")
                  [ T; Ty.path "alloc::alloc::Global" ],
                "new",
                []
              |),
              []
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::default::Default"
          (Self T)
          (* Trait polymorphic types *) []
          (* Instance *) [ ("default", InstanceField.Method (default T)) ].
    End Impl_core_default_Default_for_alloc_collections_vec_deque_VecDeque_T_alloc_alloc_Global.
    
    Module Impl_alloc_collections_vec_deque_VecDeque_T_A.
      Definition Self (T A : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "alloc::collections::vec_deque::VecDeque") [ T; A ].
      
      (*
          fn ptr(&self) -> *mut T {
              self.buf.ptr()
          }
      *)
      Definition ptr (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply (Ty.path "alloc::raw_vec::RawVec") [ T; A ],
                "ptr",
                []
              |),
              [
                M.SubPointer.get_struct_record_field (|
                  M.read (| self |),
                  "alloc::collections::vec_deque::VecDeque",
                  "buf"
                |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_ptr :
        forall (T A : Ty.t),
        M.IsAssociatedFunction (Self T A) "ptr" (ptr T A).
      
      (*
          unsafe fn buffer_read(&mut self, off: usize) -> T {
              unsafe { ptr::read(self.ptr().add(off)) }
          }
      *)
      Definition buffer_read (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match τ, α with
        | [], [ self; off ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let off := M.alloc (| off |) in
            M.call_closure (|
              M.get_function (| "core::ptr::read", [ T ] |),
              [
                (* MutToConstPointer *)
                M.pointer_coercion
                  (M.call_closure (|
                    M.get_associated_function (| Ty.apply (Ty.path "*mut") [ T ], "add", [] |),
                    [
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "alloc::collections::vec_deque::VecDeque") [ T; A ],
                          "ptr",
                          []
                        |),
                        [ M.read (| self |) ]
                      |);
                      M.read (| off |)
                    ]
                  |))
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_buffer_read :
        forall (T A : Ty.t),
        M.IsAssociatedFunction (Self T A) "buffer_read" (buffer_read T A).
      
      (*
          unsafe fn buffer_write(&mut self, off: usize, value: T) {
              unsafe {
                  ptr::write(self.ptr().add(off), value);
              }
          }
      *)
      Definition buffer_write (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match τ, α with
        | [], [ self; off; value ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let off := M.alloc (| off |) in
            let value := M.alloc (| value |) in
            M.read (|
              let _ :=
                M.alloc (|
                  M.call_closure (|
                    M.get_function (| "core::ptr::write", [ T ] |),
                    [
                      M.call_closure (|
                        M.get_associated_function (| Ty.apply (Ty.path "*mut") [ T ], "add", [] |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply (Ty.path "alloc::collections::vec_deque::VecDeque") [ T; A ],
                              "ptr",
                              []
                            |),
                            [ M.read (| self |) ]
                          |);
                          M.read (| off |)
                        ]
                      |);
                      M.read (| value |)
                    ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_buffer_write :
        forall (T A : Ty.t),
        M.IsAssociatedFunction (Self T A) "buffer_write" (buffer_write T A).
      
      (*
          unsafe fn buffer_range(&self, range: Range<usize>) -> *mut [T] {
              unsafe {
                  ptr::slice_from_raw_parts_mut(self.ptr().add(range.start), range.end - range.start)
              }
          }
      *)
      Definition buffer_range (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match τ, α with
        | [], [ self; range ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let range := M.alloc (| range |) in
            M.call_closure (|
              M.get_function (| "core::ptr::slice_from_raw_parts_mut", [ T ] |),
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.apply (Ty.path "*mut") [ T ], "add", [] |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "alloc::collections::vec_deque::VecDeque") [ T; A ],
                        "ptr",
                        []
                      |),
                      [ M.read (| self |) ]
                    |);
                    M.read (|
                      M.SubPointer.get_struct_record_field (|
                        range,
                        "core::ops::range::Range",
                        "start"
                      |)
                    |)
                  ]
                |);
                BinOp.Panic.sub (|
                  Integer.Usize,
                  M.read (|
                    M.SubPointer.get_struct_record_field (|
                      range,
                      "core::ops::range::Range",
                      "end"
                    |)
                  |),
                  M.read (|
                    M.SubPointer.get_struct_record_field (|
                      range,
                      "core::ops::range::Range",
                      "start"
                    |)
                  |)
                |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_buffer_range :
        forall (T A : Ty.t),
        M.IsAssociatedFunction (Self T A) "buffer_range" (buffer_range T A).
      
      (*
          fn is_full(&self) -> bool {
              self.len == self.capacity()
          }
      *)
      Definition is_full (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            BinOp.Pure.eq
              (M.read (|
                M.SubPointer.get_struct_record_field (|
                  M.read (| self |),
                  "alloc::collections::vec_deque::VecDeque",
                  "len"
                |)
              |))
              (M.call_closure (|
                M.get_associated_function (|
                  Ty.apply (Ty.path "alloc::collections::vec_deque::VecDeque") [ T; A ],
                  "capacity",
                  []
                |),
                [ M.read (| self |) ]
              |))))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_is_full :
        forall (T A : Ty.t),
        M.IsAssociatedFunction (Self T A) "is_full" (is_full T A).
      
      (*
          fn wrap_add(&self, idx: usize, addend: usize) -> usize {
              wrap_index(idx.wrapping_add(addend), self.capacity())
          }
      *)
      Definition wrap_add (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match τ, α with
        | [], [ self; idx; addend ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let idx := M.alloc (| idx |) in
            let addend := M.alloc (| addend |) in
            M.call_closure (|
              M.get_function (| "alloc::collections::vec_deque::wrap_index", [] |),
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "usize", "wrapping_add", [] |),
                  [ M.read (| idx |); M.read (| addend |) ]
                |);
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "alloc::collections::vec_deque::VecDeque") [ T; A ],
                    "capacity",
                    []
                  |),
                  [ M.read (| self |) ]
                |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_wrap_add :
        forall (T A : Ty.t),
        M.IsAssociatedFunction (Self T A) "wrap_add" (wrap_add T A).
      
      (*
          fn to_physical_idx(&self, idx: usize) -> usize {
              self.wrap_add(self.head, idx)
          }
      *)
      Definition to_physical_idx (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match τ, α with
        | [], [ self; idx ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let idx := M.alloc (| idx |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply (Ty.path "alloc::collections::vec_deque::VecDeque") [ T; A ],
                "wrap_add",
                []
              |),
              [
                M.read (| self |);
                M.read (|
                  M.SubPointer.get_struct_record_field (|
                    M.read (| self |),
                    "alloc::collections::vec_deque::VecDeque",
                    "head"
                  |)
                |);
                M.read (| idx |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_to_physical_idx :
        forall (T A : Ty.t),
        M.IsAssociatedFunction (Self T A) "to_physical_idx" (to_physical_idx T A).
      
      (*
          fn wrap_sub(&self, idx: usize, subtrahend: usize) -> usize {
              wrap_index(idx.wrapping_sub(subtrahend).wrapping_add(self.capacity()), self.capacity())
          }
      *)
      Definition wrap_sub (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match τ, α with
        | [], [ self; idx; subtrahend ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let idx := M.alloc (| idx |) in
            let subtrahend := M.alloc (| subtrahend |) in
            M.call_closure (|
              M.get_function (| "alloc::collections::vec_deque::wrap_index", [] |),
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "usize", "wrapping_add", [] |),
                  [
                    M.call_closure (|
                      M.get_associated_function (| Ty.path "usize", "wrapping_sub", [] |),
                      [ M.read (| idx |); M.read (| subtrahend |) ]
                    |);
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "alloc::collections::vec_deque::VecDeque") [ T; A ],
                        "capacity",
                        []
                      |),
                      [ M.read (| self |) ]
                    |)
                  ]
                |);
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "alloc::collections::vec_deque::VecDeque") [ T; A ],
                    "capacity",
                    []
                  |),
                  [ M.read (| self |) ]
                |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_wrap_sub :
        forall (T A : Ty.t),
        M.IsAssociatedFunction (Self T A) "wrap_sub" (wrap_sub T A).
      
      (*
          unsafe fn copy(&mut self, src: usize, dst: usize, len: usize) {
              debug_assert!(
                  dst + len <= self.capacity(),
                  "cpy dst={} src={} len={} cap={}",
                  dst,
                  src,
                  len,
                  self.capacity()
              );
              debug_assert!(
                  src + len <= self.capacity(),
                  "cpy dst={} src={} len={} cap={}",
                  dst,
                  src,
                  len,
                  self.capacity()
              );
              unsafe {
                  ptr::copy(self.ptr().add(src), self.ptr().add(dst), len);
              }
          }
      *)
      Definition copy (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match τ, α with
        | [], [ self; src; dst; len ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let src := M.alloc (| src |) in
            let dst := M.alloc (| dst |) in
            let len := M.alloc (| len |) in
            M.read (|
              let _ :=
                M.match_operator (|
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.use (M.alloc (| Value.Bool true |)) in
                        let _ :=
                          M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        let _ :=
                          M.match_operator (|
                            M.alloc (| Value.Tuple [] |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ :=
                                    M.use
                                      (M.alloc (|
                                        UnOp.Pure.not
                                          (BinOp.Pure.le
                                            (BinOp.Panic.add (|
                                              Integer.Usize,
                                              M.read (| dst |),
                                              M.read (| len |)
                                            |))
                                            (M.call_closure (|
                                              M.get_associated_function (|
                                                Ty.apply
                                                  (Ty.path
                                                    "alloc::collections::vec_deque::VecDeque")
                                                  [ T; A ],
                                                "capacity",
                                                []
                                              |),
                                              [ M.read (| self |) ]
                                            |)))
                                      |)) in
                                  let _ :=
                                    M.is_constant_or_break_match (|
                                      M.read (| γ |),
                                      Value.Bool true
                                    |) in
                                  M.alloc (|
                                    M.never_to_any (|
                                      M.call_closure (|
                                        M.get_function (| "core::panicking::panic_fmt", [] |),
                                        [
                                          M.call_closure (|
                                            M.get_associated_function (|
                                              Ty.path "core::fmt::Arguments",
                                              "new_v1",
                                              []
                                            |),
                                            [
                                              (* Unsize *)
                                              M.pointer_coercion
                                                (M.alloc (|
                                                  Value.Array
                                                    [
                                                      M.read (| Value.String "cpy dst=" |);
                                                      M.read (| Value.String " src=" |);
                                                      M.read (| Value.String " len=" |);
                                                      M.read (| Value.String " cap=" |)
                                                    ]
                                                |));
                                              (* Unsize *)
                                              M.pointer_coercion
                                                (M.alloc (|
                                                  Value.Array
                                                    [
                                                      M.call_closure (|
                                                        M.get_associated_function (|
                                                          Ty.path "core::fmt::rt::Argument",
                                                          "new_display",
                                                          [ Ty.path "usize" ]
                                                        |),
                                                        [ dst ]
                                                      |);
                                                      M.call_closure (|
                                                        M.get_associated_function (|
                                                          Ty.path "core::fmt::rt::Argument",
                                                          "new_display",
                                                          [ Ty.path "usize" ]
                                                        |),
                                                        [ src ]
                                                      |);
                                                      M.call_closure (|
                                                        M.get_associated_function (|
                                                          Ty.path "core::fmt::rt::Argument",
                                                          "new_display",
                                                          [ Ty.path "usize" ]
                                                        |),
                                                        [ len ]
                                                      |);
                                                      M.call_closure (|
                                                        M.get_associated_function (|
                                                          Ty.path "core::fmt::rt::Argument",
                                                          "new_display",
                                                          [ Ty.path "usize" ]
                                                        |),
                                                        [
                                                          M.alloc (|
                                                            M.call_closure (|
                                                              M.get_associated_function (|
                                                                Ty.apply
                                                                  (Ty.path
                                                                    "alloc::collections::vec_deque::VecDeque")
                                                                  [ T; A ],
                                                                "capacity",
                                                                []
                                                              |),
                                                              [ M.read (| self |) ]
                                                            |)
                                                          |)
                                                        ]
                                                      |)
                                                    ]
                                                |))
                                            ]
                                          |)
                                        ]
                                      |)
                                    |)
                                  |)));
                              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                            ]
                          |) in
                        M.alloc (| Value.Tuple [] |)));
                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                  ]
                |) in
              let _ :=
                M.match_operator (|
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.use (M.alloc (| Value.Bool true |)) in
                        let _ :=
                          M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        let _ :=
                          M.match_operator (|
                            M.alloc (| Value.Tuple [] |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ :=
                                    M.use
                                      (M.alloc (|
                                        UnOp.Pure.not
                                          (BinOp.Pure.le
                                            (BinOp.Panic.add (|
                                              Integer.Usize,
                                              M.read (| src |),
                                              M.read (| len |)
                                            |))
                                            (M.call_closure (|
                                              M.get_associated_function (|
                                                Ty.apply
                                                  (Ty.path
                                                    "alloc::collections::vec_deque::VecDeque")
                                                  [ T; A ],
                                                "capacity",
                                                []
                                              |),
                                              [ M.read (| self |) ]
                                            |)))
                                      |)) in
                                  let _ :=
                                    M.is_constant_or_break_match (|
                                      M.read (| γ |),
                                      Value.Bool true
                                    |) in
                                  M.alloc (|
                                    M.never_to_any (|
                                      M.call_closure (|
                                        M.get_function (| "core::panicking::panic_fmt", [] |),
                                        [
                                          M.call_closure (|
                                            M.get_associated_function (|
                                              Ty.path "core::fmt::Arguments",
                                              "new_v1",
                                              []
                                            |),
                                            [
                                              (* Unsize *)
                                              M.pointer_coercion
                                                (M.alloc (|
                                                  Value.Array
                                                    [
                                                      M.read (| Value.String "cpy dst=" |);
                                                      M.read (| Value.String " src=" |);
                                                      M.read (| Value.String " len=" |);
                                                      M.read (| Value.String " cap=" |)
                                                    ]
                                                |));
                                              (* Unsize *)
                                              M.pointer_coercion
                                                (M.alloc (|
                                                  Value.Array
                                                    [
                                                      M.call_closure (|
                                                        M.get_associated_function (|
                                                          Ty.path "core::fmt::rt::Argument",
                                                          "new_display",
                                                          [ Ty.path "usize" ]
                                                        |),
                                                        [ dst ]
                                                      |);
                                                      M.call_closure (|
                                                        M.get_associated_function (|
                                                          Ty.path "core::fmt::rt::Argument",
                                                          "new_display",
                                                          [ Ty.path "usize" ]
                                                        |),
                                                        [ src ]
                                                      |);
                                                      M.call_closure (|
                                                        M.get_associated_function (|
                                                          Ty.path "core::fmt::rt::Argument",
                                                          "new_display",
                                                          [ Ty.path "usize" ]
                                                        |),
                                                        [ len ]
                                                      |);
                                                      M.call_closure (|
                                                        M.get_associated_function (|
                                                          Ty.path "core::fmt::rt::Argument",
                                                          "new_display",
                                                          [ Ty.path "usize" ]
                                                        |),
                                                        [
                                                          M.alloc (|
                                                            M.call_closure (|
                                                              M.get_associated_function (|
                                                                Ty.apply
                                                                  (Ty.path
                                                                    "alloc::collections::vec_deque::VecDeque")
                                                                  [ T; A ],
                                                                "capacity",
                                                                []
                                                              |),
                                                              [ M.read (| self |) ]
                                                            |)
                                                          |)
                                                        ]
                                                      |)
                                                    ]
                                                |))
                                            ]
                                          |)
                                        ]
                                      |)
                                    |)
                                  |)));
                              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                            ]
                          |) in
                        M.alloc (| Value.Tuple [] |)));
                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                  ]
                |) in
              let _ :=
                M.alloc (|
                  M.call_closure (|
                    M.get_function (| "core::intrinsics::copy", [ T ] |),
                    [
                      (* MutToConstPointer *)
                      M.pointer_coercion
                        (M.call_closure (|
                          M.get_associated_function (|
                            Ty.apply (Ty.path "*mut") [ T ],
                            "add",
                            []
                          |),
                          [
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "alloc::collections::vec_deque::VecDeque")
                                  [ T; A ],
                                "ptr",
                                []
                              |),
                              [ M.read (| self |) ]
                            |);
                            M.read (| src |)
                          ]
                        |));
                      M.call_closure (|
                        M.get_associated_function (| Ty.apply (Ty.path "*mut") [ T ], "add", [] |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply (Ty.path "alloc::collections::vec_deque::VecDeque") [ T; A ],
                              "ptr",
                              []
                            |),
                            [ M.read (| self |) ]
                          |);
                          M.read (| dst |)
                        ]
                      |);
                      M.read (| len |)
                    ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_copy :
        forall (T A : Ty.t),
        M.IsAssociatedFunction (Self T A) "copy" (copy T A).
      
      (*
          unsafe fn copy_nonoverlapping(&mut self, src: usize, dst: usize, len: usize) {
              debug_assert!(
                  dst + len <= self.capacity(),
                  "cno dst={} src={} len={} cap={}",
                  dst,
                  src,
                  len,
                  self.capacity()
              );
              debug_assert!(
                  src + len <= self.capacity(),
                  "cno dst={} src={} len={} cap={}",
                  dst,
                  src,
                  len,
                  self.capacity()
              );
              unsafe {
                  ptr::copy_nonoverlapping(self.ptr().add(src), self.ptr().add(dst), len);
              }
          }
      *)
      Definition copy_nonoverlapping (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match τ, α with
        | [], [ self; src; dst; len ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let src := M.alloc (| src |) in
            let dst := M.alloc (| dst |) in
            let len := M.alloc (| len |) in
            M.read (|
              let _ :=
                M.match_operator (|
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.use (M.alloc (| Value.Bool true |)) in
                        let _ :=
                          M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        let _ :=
                          M.match_operator (|
                            M.alloc (| Value.Tuple [] |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ :=
                                    M.use
                                      (M.alloc (|
                                        UnOp.Pure.not
                                          (BinOp.Pure.le
                                            (BinOp.Panic.add (|
                                              Integer.Usize,
                                              M.read (| dst |),
                                              M.read (| len |)
                                            |))
                                            (M.call_closure (|
                                              M.get_associated_function (|
                                                Ty.apply
                                                  (Ty.path
                                                    "alloc::collections::vec_deque::VecDeque")
                                                  [ T; A ],
                                                "capacity",
                                                []
                                              |),
                                              [ M.read (| self |) ]
                                            |)))
                                      |)) in
                                  let _ :=
                                    M.is_constant_or_break_match (|
                                      M.read (| γ |),
                                      Value.Bool true
                                    |) in
                                  M.alloc (|
                                    M.never_to_any (|
                                      M.call_closure (|
                                        M.get_function (| "core::panicking::panic_fmt", [] |),
                                        [
                                          M.call_closure (|
                                            M.get_associated_function (|
                                              Ty.path "core::fmt::Arguments",
                                              "new_v1",
                                              []
                                            |),
                                            [
                                              (* Unsize *)
                                              M.pointer_coercion
                                                (M.alloc (|
                                                  Value.Array
                                                    [
                                                      M.read (| Value.String "cno dst=" |);
                                                      M.read (| Value.String " src=" |);
                                                      M.read (| Value.String " len=" |);
                                                      M.read (| Value.String " cap=" |)
                                                    ]
                                                |));
                                              (* Unsize *)
                                              M.pointer_coercion
                                                (M.alloc (|
                                                  Value.Array
                                                    [
                                                      M.call_closure (|
                                                        M.get_associated_function (|
                                                          Ty.path "core::fmt::rt::Argument",
                                                          "new_display",
                                                          [ Ty.path "usize" ]
                                                        |),
                                                        [ dst ]
                                                      |);
                                                      M.call_closure (|
                                                        M.get_associated_function (|
                                                          Ty.path "core::fmt::rt::Argument",
                                                          "new_display",
                                                          [ Ty.path "usize" ]
                                                        |),
                                                        [ src ]
                                                      |);
                                                      M.call_closure (|
                                                        M.get_associated_function (|
                                                          Ty.path "core::fmt::rt::Argument",
                                                          "new_display",
                                                          [ Ty.path "usize" ]
                                                        |),
                                                        [ len ]
                                                      |);
                                                      M.call_closure (|
                                                        M.get_associated_function (|
                                                          Ty.path "core::fmt::rt::Argument",
                                                          "new_display",
                                                          [ Ty.path "usize" ]
                                                        |),
                                                        [
                                                          M.alloc (|
                                                            M.call_closure (|
                                                              M.get_associated_function (|
                                                                Ty.apply
                                                                  (Ty.path
                                                                    "alloc::collections::vec_deque::VecDeque")
                                                                  [ T; A ],
                                                                "capacity",
                                                                []
                                                              |),
                                                              [ M.read (| self |) ]
                                                            |)
                                                          |)
                                                        ]
                                                      |)
                                                    ]
                                                |))
                                            ]
                                          |)
                                        ]
                                      |)
                                    |)
                                  |)));
                              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                            ]
                          |) in
                        M.alloc (| Value.Tuple [] |)));
                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                  ]
                |) in
              let _ :=
                M.match_operator (|
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.use (M.alloc (| Value.Bool true |)) in
                        let _ :=
                          M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        let _ :=
                          M.match_operator (|
                            M.alloc (| Value.Tuple [] |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ :=
                                    M.use
                                      (M.alloc (|
                                        UnOp.Pure.not
                                          (BinOp.Pure.le
                                            (BinOp.Panic.add (|
                                              Integer.Usize,
                                              M.read (| src |),
                                              M.read (| len |)
                                            |))
                                            (M.call_closure (|
                                              M.get_associated_function (|
                                                Ty.apply
                                                  (Ty.path
                                                    "alloc::collections::vec_deque::VecDeque")
                                                  [ T; A ],
                                                "capacity",
                                                []
                                              |),
                                              [ M.read (| self |) ]
                                            |)))
                                      |)) in
                                  let _ :=
                                    M.is_constant_or_break_match (|
                                      M.read (| γ |),
                                      Value.Bool true
                                    |) in
                                  M.alloc (|
                                    M.never_to_any (|
                                      M.call_closure (|
                                        M.get_function (| "core::panicking::panic_fmt", [] |),
                                        [
                                          M.call_closure (|
                                            M.get_associated_function (|
                                              Ty.path "core::fmt::Arguments",
                                              "new_v1",
                                              []
                                            |),
                                            [
                                              (* Unsize *)
                                              M.pointer_coercion
                                                (M.alloc (|
                                                  Value.Array
                                                    [
                                                      M.read (| Value.String "cno dst=" |);
                                                      M.read (| Value.String " src=" |);
                                                      M.read (| Value.String " len=" |);
                                                      M.read (| Value.String " cap=" |)
                                                    ]
                                                |));
                                              (* Unsize *)
                                              M.pointer_coercion
                                                (M.alloc (|
                                                  Value.Array
                                                    [
                                                      M.call_closure (|
                                                        M.get_associated_function (|
                                                          Ty.path "core::fmt::rt::Argument",
                                                          "new_display",
                                                          [ Ty.path "usize" ]
                                                        |),
                                                        [ dst ]
                                                      |);
                                                      M.call_closure (|
                                                        M.get_associated_function (|
                                                          Ty.path "core::fmt::rt::Argument",
                                                          "new_display",
                                                          [ Ty.path "usize" ]
                                                        |),
                                                        [ src ]
                                                      |);
                                                      M.call_closure (|
                                                        M.get_associated_function (|
                                                          Ty.path "core::fmt::rt::Argument",
                                                          "new_display",
                                                          [ Ty.path "usize" ]
                                                        |),
                                                        [ len ]
                                                      |);
                                                      M.call_closure (|
                                                        M.get_associated_function (|
                                                          Ty.path "core::fmt::rt::Argument",
                                                          "new_display",
                                                          [ Ty.path "usize" ]
                                                        |),
                                                        [
                                                          M.alloc (|
                                                            M.call_closure (|
                                                              M.get_associated_function (|
                                                                Ty.apply
                                                                  (Ty.path
                                                                    "alloc::collections::vec_deque::VecDeque")
                                                                  [ T; A ],
                                                                "capacity",
                                                                []
                                                              |),
                                                              [ M.read (| self |) ]
                                                            |)
                                                          |)
                                                        ]
                                                      |)
                                                    ]
                                                |))
                                            ]
                                          |)
                                        ]
                                      |)
                                    |)
                                  |)));
                              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                            ]
                          |) in
                        M.alloc (| Value.Tuple [] |)));
                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                  ]
                |) in
              let _ :=
                M.alloc (|
                  M.call_closure (|
                    M.get_function (| "core::intrinsics::copy_nonoverlapping", [ T ] |),
                    [
                      (* MutToConstPointer *)
                      M.pointer_coercion
                        (M.call_closure (|
                          M.get_associated_function (|
                            Ty.apply (Ty.path "*mut") [ T ],
                            "add",
                            []
                          |),
                          [
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "alloc::collections::vec_deque::VecDeque")
                                  [ T; A ],
                                "ptr",
                                []
                              |),
                              [ M.read (| self |) ]
                            |);
                            M.read (| src |)
                          ]
                        |));
                      M.call_closure (|
                        M.get_associated_function (| Ty.apply (Ty.path "*mut") [ T ], "add", [] |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply (Ty.path "alloc::collections::vec_deque::VecDeque") [ T; A ],
                              "ptr",
                              []
                            |),
                            [ M.read (| self |) ]
                          |);
                          M.read (| dst |)
                        ]
                      |);
                      M.read (| len |)
                    ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_copy_nonoverlapping :
        forall (T A : Ty.t),
        M.IsAssociatedFunction (Self T A) "copy_nonoverlapping" (copy_nonoverlapping T A).
      
      (*
          unsafe fn wrap_copy(&mut self, src: usize, dst: usize, len: usize) {
              debug_assert!(
                  cmp::min(src.abs_diff(dst), self.capacity() - src.abs_diff(dst)) + len
                      <= self.capacity(),
                  "wrc dst={} src={} len={} cap={}",
                  dst,
                  src,
                  len,
                  self.capacity()
              );
      
              // If T is a ZST, don't do any copying.
              if T::IS_ZST || src == dst || len == 0 {
                  return;
              }
      
              let dst_after_src = self.wrap_sub(dst, src) < len;
      
              let src_pre_wrap_len = self.capacity() - src;
              let dst_pre_wrap_len = self.capacity() - dst;
              let src_wraps = src_pre_wrap_len < len;
              let dst_wraps = dst_pre_wrap_len < len;
      
              match (dst_after_src, src_wraps, dst_wraps) {
                  (_, false, false) => {
                      // src doesn't wrap, dst doesn't wrap
                      //
                      //        S . . .
                      // 1 [_ _ A A B B C C _]
                      // 2 [_ _ A A A A B B _]
                      //            D . . .
                      //
                      unsafe {
                          self.copy(src, dst, len);
                      }
                  }
                  (false, false, true) => {
                      // dst before src, src doesn't wrap, dst wraps
                      //
                      //    S . . .
                      // 1 [A A B B _ _ _ C C]
                      // 2 [A A B B _ _ _ A A]
                      // 3 [B B B B _ _ _ A A]
                      //    . .           D .
                      //
                      unsafe {
                          self.copy(src, dst, dst_pre_wrap_len);
                          self.copy(src + dst_pre_wrap_len, 0, len - dst_pre_wrap_len);
                      }
                  }
                  (true, false, true) => {
                      // src before dst, src doesn't wrap, dst wraps
                      //
                      //              S . . .
                      // 1 [C C _ _ _ A A B B]
                      // 2 [B B _ _ _ A A B B]
                      // 3 [B B _ _ _ A A A A]
                      //    . .           D .
                      //
                      unsafe {
                          self.copy(src + dst_pre_wrap_len, 0, len - dst_pre_wrap_len);
                          self.copy(src, dst, dst_pre_wrap_len);
                      }
                  }
                  (false, true, false) => {
                      // dst before src, src wraps, dst doesn't wrap
                      //
                      //    . .           S .
                      // 1 [C C _ _ _ A A B B]
                      // 2 [C C _ _ _ B B B B]
                      // 3 [C C _ _ _ B B C C]
                      //              D . . .
                      //
                      unsafe {
                          self.copy(src, dst, src_pre_wrap_len);
                          self.copy(0, dst + src_pre_wrap_len, len - src_pre_wrap_len);
                      }
                  }
                  (true, true, false) => {
                      // src before dst, src wraps, dst doesn't wrap
                      //
                      //    . .           S .
                      // 1 [A A B B _ _ _ C C]
                      // 2 [A A A A _ _ _ C C]
                      // 3 [C C A A _ _ _ C C]
                      //    D . . .
                      //
                      unsafe {
                          self.copy(0, dst + src_pre_wrap_len, len - src_pre_wrap_len);
                          self.copy(src, dst, src_pre_wrap_len);
                      }
                  }
                  (false, true, true) => {
                      // dst before src, src wraps, dst wraps
                      //
                      //    . . .         S .
                      // 1 [A B C D _ E F G H]
                      // 2 [A B C D _ E G H H]
                      // 3 [A B C D _ E G H A]
                      // 4 [B C C D _ E G H A]
                      //    . .         D . .
                      //
                      debug_assert!(dst_pre_wrap_len > src_pre_wrap_len);
                      let delta = dst_pre_wrap_len - src_pre_wrap_len;
                      unsafe {
                          self.copy(src, dst, src_pre_wrap_len);
                          self.copy(0, dst + src_pre_wrap_len, delta);
                          self.copy(delta, 0, len - dst_pre_wrap_len);
                      }
                  }
                  (true, true, true) => {
                      // src before dst, src wraps, dst wraps
                      //
                      //    . .         S . .
                      // 1 [A B C D _ E F G H]
                      // 2 [A A B D _ E F G H]
                      // 3 [H A B D _ E F G H]
                      // 4 [H A B D _ E F F G]
                      //    . . .         D .
                      //
                      debug_assert!(src_pre_wrap_len > dst_pre_wrap_len);
                      let delta = src_pre_wrap_len - dst_pre_wrap_len;
                      unsafe {
                          self.copy(0, delta, len - src_pre_wrap_len);
                          self.copy(self.capacity() - delta, 0, delta);
                          self.copy(src, dst, dst_pre_wrap_len);
                      }
                  }
              }
          }
      *)
      Definition wrap_copy (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match τ, α with
        | [], [ self; src; dst; len ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let src := M.alloc (| src |) in
            let dst := M.alloc (| dst |) in
            let len := M.alloc (| len |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.read (|
                  let _ :=
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ := M.use (M.alloc (| Value.Bool true |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            let _ :=
                              M.match_operator (|
                                M.alloc (| Value.Tuple [] |),
                                [
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let γ :=
                                        M.use
                                          (M.alloc (|
                                            UnOp.Pure.not
                                              (BinOp.Pure.le
                                                (BinOp.Panic.add (|
                                                  Integer.Usize,
                                                  M.call_closure (|
                                                    M.get_function (|
                                                      "core::cmp::min",
                                                      [ Ty.path "usize" ]
                                                    |),
                                                    [
                                                      M.call_closure (|
                                                        M.get_associated_function (|
                                                          Ty.path "usize",
                                                          "abs_diff",
                                                          []
                                                        |),
                                                        [ M.read (| src |); M.read (| dst |) ]
                                                      |);
                                                      BinOp.Panic.sub (|
                                                        Integer.Usize,
                                                        M.call_closure (|
                                                          M.get_associated_function (|
                                                            Ty.apply
                                                              (Ty.path
                                                                "alloc::collections::vec_deque::VecDeque")
                                                              [ T; A ],
                                                            "capacity",
                                                            []
                                                          |),
                                                          [ M.read (| self |) ]
                                                        |),
                                                        M.call_closure (|
                                                          M.get_associated_function (|
                                                            Ty.path "usize",
                                                            "abs_diff",
                                                            []
                                                          |),
                                                          [ M.read (| src |); M.read (| dst |) ]
                                                        |)
                                                      |)
                                                    ]
                                                  |),
                                                  M.read (| len |)
                                                |))
                                                (M.call_closure (|
                                                  M.get_associated_function (|
                                                    Ty.apply
                                                      (Ty.path
                                                        "alloc::collections::vec_deque::VecDeque")
                                                      [ T; A ],
                                                    "capacity",
                                                    []
                                                  |),
                                                  [ M.read (| self |) ]
                                                |)))
                                          |)) in
                                      let _ :=
                                        M.is_constant_or_break_match (|
                                          M.read (| γ |),
                                          Value.Bool true
                                        |) in
                                      M.alloc (|
                                        M.never_to_any (|
                                          M.call_closure (|
                                            M.get_function (| "core::panicking::panic_fmt", [] |),
                                            [
                                              M.call_closure (|
                                                M.get_associated_function (|
                                                  Ty.path "core::fmt::Arguments",
                                                  "new_v1",
                                                  []
                                                |),
                                                [
                                                  (* Unsize *)
                                                  M.pointer_coercion
                                                    (M.alloc (|
                                                      Value.Array
                                                        [
                                                          M.read (| Value.String "wrc dst=" |);
                                                          M.read (| Value.String " src=" |);
                                                          M.read (| Value.String " len=" |);
                                                          M.read (| Value.String " cap=" |)
                                                        ]
                                                    |));
                                                  (* Unsize *)
                                                  M.pointer_coercion
                                                    (M.alloc (|
                                                      Value.Array
                                                        [
                                                          M.call_closure (|
                                                            M.get_associated_function (|
                                                              Ty.path "core::fmt::rt::Argument",
                                                              "new_display",
                                                              [ Ty.path "usize" ]
                                                            |),
                                                            [ dst ]
                                                          |);
                                                          M.call_closure (|
                                                            M.get_associated_function (|
                                                              Ty.path "core::fmt::rt::Argument",
                                                              "new_display",
                                                              [ Ty.path "usize" ]
                                                            |),
                                                            [ src ]
                                                          |);
                                                          M.call_closure (|
                                                            M.get_associated_function (|
                                                              Ty.path "core::fmt::rt::Argument",
                                                              "new_display",
                                                              [ Ty.path "usize" ]
                                                            |),
                                                            [ len ]
                                                          |);
                                                          M.call_closure (|
                                                            M.get_associated_function (|
                                                              Ty.path "core::fmt::rt::Argument",
                                                              "new_display",
                                                              [ Ty.path "usize" ]
                                                            |),
                                                            [
                                                              M.alloc (|
                                                                M.call_closure (|
                                                                  M.get_associated_function (|
                                                                    Ty.apply
                                                                      (Ty.path
                                                                        "alloc::collections::vec_deque::VecDeque")
                                                                      [ T; A ],
                                                                    "capacity",
                                                                    []
                                                                  |),
                                                                  [ M.read (| self |) ]
                                                                |)
                                                              |)
                                                            ]
                                                          |)
                                                        ]
                                                    |))
                                                ]
                                              |)
                                            ]
                                          |)
                                        |)
                                      |)));
                                  fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                                ]
                              |) in
                            M.alloc (| Value.Tuple [] |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                      ]
                    |) in
                  let _ :=
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  LogicalOp.or (|
                                    LogicalOp.or (|
                                      M.read (|
                                        M.get_constant (|
                                          "core::mem::SizedTypeProperties::IS_ZST"
                                        |)
                                      |),
                                      ltac:(M.monadic
                                        (BinOp.Pure.eq (M.read (| src |)) (M.read (| dst |))))
                                    |),
                                    ltac:(M.monadic
                                      (BinOp.Pure.eq (M.read (| len |)) (Value.Integer 0)))
                                  |)
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (|
                              M.never_to_any (| M.read (| M.return_ (| Value.Tuple [] |) |) |)
                            |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                      ]
                    |) in
                  let dst_after_src :=
                    M.alloc (|
                      BinOp.Pure.lt
                        (M.call_closure (|
                          M.get_associated_function (|
                            Ty.apply (Ty.path "alloc::collections::vec_deque::VecDeque") [ T; A ],
                            "wrap_sub",
                            []
                          |),
                          [ M.read (| self |); M.read (| dst |); M.read (| src |) ]
                        |))
                        (M.read (| len |))
                    |) in
                  let src_pre_wrap_len :=
                    M.alloc (|
                      BinOp.Panic.sub (|
                        Integer.Usize,
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.apply (Ty.path "alloc::collections::vec_deque::VecDeque") [ T; A ],
                            "capacity",
                            []
                          |),
                          [ M.read (| self |) ]
                        |),
                        M.read (| src |)
                      |)
                    |) in
                  let dst_pre_wrap_len :=
                    M.alloc (|
                      BinOp.Panic.sub (|
                        Integer.Usize,
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.apply (Ty.path "alloc::collections::vec_deque::VecDeque") [ T; A ],
                            "capacity",
                            []
                          |),
                          [ M.read (| self |) ]
                        |),
                        M.read (| dst |)
                      |)
                    |) in
                  let src_wraps :=
                    M.alloc (|
                      BinOp.Pure.lt (M.read (| src_pre_wrap_len |)) (M.read (| len |))
                    |) in
                  let dst_wraps :=
                    M.alloc (|
                      BinOp.Pure.lt (M.read (| dst_pre_wrap_len |)) (M.read (| len |))
                    |) in
                  M.match_operator (|
                    M.alloc (|
                      Value.Tuple
                        [ M.read (| dst_after_src |); M.read (| src_wraps |); M.read (| dst_wraps |)
                        ]
                    |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                          let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                          let γ0_2 := M.SubPointer.get_tuple_field (| γ, 2 |) in
                          let _ :=
                            M.is_constant_or_break_match (|
                              M.read (| γ0_1 |),
                              Value.Bool false
                            |) in
                          let _ :=
                            M.is_constant_or_break_match (|
                              M.read (| γ0_2 |),
                              Value.Bool false
                            |) in
                          let _ :=
                            M.alloc (|
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "alloc::collections::vec_deque::VecDeque")
                                    [ T; A ],
                                  "copy",
                                  []
                                |),
                                [
                                  M.read (| self |);
                                  M.read (| src |);
                                  M.read (| dst |);
                                  M.read (| len |)
                                ]
                              |)
                            |) in
                          M.alloc (| Value.Tuple [] |)));
                      fun γ =>
                        ltac:(M.monadic
                          (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                          let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                          let γ0_2 := M.SubPointer.get_tuple_field (| γ, 2 |) in
                          let _ :=
                            M.is_constant_or_break_match (|
                              M.read (| γ0_0 |),
                              Value.Bool false
                            |) in
                          let _ :=
                            M.is_constant_or_break_match (|
                              M.read (| γ0_1 |),
                              Value.Bool false
                            |) in
                          let _ :=
                            M.is_constant_or_break_match (| M.read (| γ0_2 |), Value.Bool true |) in
                          let _ :=
                            M.alloc (|
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "alloc::collections::vec_deque::VecDeque")
                                    [ T; A ],
                                  "copy",
                                  []
                                |),
                                [
                                  M.read (| self |);
                                  M.read (| src |);
                                  M.read (| dst |);
                                  M.read (| dst_pre_wrap_len |)
                                ]
                              |)
                            |) in
                          let _ :=
                            M.alloc (|
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "alloc::collections::vec_deque::VecDeque")
                                    [ T; A ],
                                  "copy",
                                  []
                                |),
                                [
                                  M.read (| self |);
                                  BinOp.Panic.add (|
                                    Integer.Usize,
                                    M.read (| src |),
                                    M.read (| dst_pre_wrap_len |)
                                  |);
                                  Value.Integer 0;
                                  BinOp.Panic.sub (|
                                    Integer.Usize,
                                    M.read (| len |),
                                    M.read (| dst_pre_wrap_len |)
                                  |)
                                ]
                              |)
                            |) in
                          M.alloc (| Value.Tuple [] |)));
                      fun γ =>
                        ltac:(M.monadic
                          (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                          let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                          let γ0_2 := M.SubPointer.get_tuple_field (| γ, 2 |) in
                          let _ :=
                            M.is_constant_or_break_match (| M.read (| γ0_0 |), Value.Bool true |) in
                          let _ :=
                            M.is_constant_or_break_match (|
                              M.read (| γ0_1 |),
                              Value.Bool false
                            |) in
                          let _ :=
                            M.is_constant_or_break_match (| M.read (| γ0_2 |), Value.Bool true |) in
                          let _ :=
                            M.alloc (|
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "alloc::collections::vec_deque::VecDeque")
                                    [ T; A ],
                                  "copy",
                                  []
                                |),
                                [
                                  M.read (| self |);
                                  BinOp.Panic.add (|
                                    Integer.Usize,
                                    M.read (| src |),
                                    M.read (| dst_pre_wrap_len |)
                                  |);
                                  Value.Integer 0;
                                  BinOp.Panic.sub (|
                                    Integer.Usize,
                                    M.read (| len |),
                                    M.read (| dst_pre_wrap_len |)
                                  |)
                                ]
                              |)
                            |) in
                          let _ :=
                            M.alloc (|
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "alloc::collections::vec_deque::VecDeque")
                                    [ T; A ],
                                  "copy",
                                  []
                                |),
                                [
                                  M.read (| self |);
                                  M.read (| src |);
                                  M.read (| dst |);
                                  M.read (| dst_pre_wrap_len |)
                                ]
                              |)
                            |) in
                          M.alloc (| Value.Tuple [] |)));
                      fun γ =>
                        ltac:(M.monadic
                          (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                          let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                          let γ0_2 := M.SubPointer.get_tuple_field (| γ, 2 |) in
                          let _ :=
                            M.is_constant_or_break_match (|
                              M.read (| γ0_0 |),
                              Value.Bool false
                            |) in
                          let _ :=
                            M.is_constant_or_break_match (| M.read (| γ0_1 |), Value.Bool true |) in
                          let _ :=
                            M.is_constant_or_break_match (|
                              M.read (| γ0_2 |),
                              Value.Bool false
                            |) in
                          let _ :=
                            M.alloc (|
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "alloc::collections::vec_deque::VecDeque")
                                    [ T; A ],
                                  "copy",
                                  []
                                |),
                                [
                                  M.read (| self |);
                                  M.read (| src |);
                                  M.read (| dst |);
                                  M.read (| src_pre_wrap_len |)
                                ]
                              |)
                            |) in
                          let _ :=
                            M.alloc (|
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "alloc::collections::vec_deque::VecDeque")
                                    [ T; A ],
                                  "copy",
                                  []
                                |),
                                [
                                  M.read (| self |);
                                  Value.Integer 0;
                                  BinOp.Panic.add (|
                                    Integer.Usize,
                                    M.read (| dst |),
                                    M.read (| src_pre_wrap_len |)
                                  |);
                                  BinOp.Panic.sub (|
                                    Integer.Usize,
                                    M.read (| len |),
                                    M.read (| src_pre_wrap_len |)
                                  |)
                                ]
                              |)
                            |) in
                          M.alloc (| Value.Tuple [] |)));
                      fun γ =>
                        ltac:(M.monadic
                          (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                          let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                          let γ0_2 := M.SubPointer.get_tuple_field (| γ, 2 |) in
                          let _ :=
                            M.is_constant_or_break_match (| M.read (| γ0_0 |), Value.Bool true |) in
                          let _ :=
                            M.is_constant_or_break_match (| M.read (| γ0_1 |), Value.Bool true |) in
                          let _ :=
                            M.is_constant_or_break_match (|
                              M.read (| γ0_2 |),
                              Value.Bool false
                            |) in
                          let _ :=
                            M.alloc (|
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "alloc::collections::vec_deque::VecDeque")
                                    [ T; A ],
                                  "copy",
                                  []
                                |),
                                [
                                  M.read (| self |);
                                  Value.Integer 0;
                                  BinOp.Panic.add (|
                                    Integer.Usize,
                                    M.read (| dst |),
                                    M.read (| src_pre_wrap_len |)
                                  |);
                                  BinOp.Panic.sub (|
                                    Integer.Usize,
                                    M.read (| len |),
                                    M.read (| src_pre_wrap_len |)
                                  |)
                                ]
                              |)
                            |) in
                          let _ :=
                            M.alloc (|
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "alloc::collections::vec_deque::VecDeque")
                                    [ T; A ],
                                  "copy",
                                  []
                                |),
                                [
                                  M.read (| self |);
                                  M.read (| src |);
                                  M.read (| dst |);
                                  M.read (| src_pre_wrap_len |)
                                ]
                              |)
                            |) in
                          M.alloc (| Value.Tuple [] |)));
                      fun γ =>
                        ltac:(M.monadic
                          (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                          let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                          let γ0_2 := M.SubPointer.get_tuple_field (| γ, 2 |) in
                          let _ :=
                            M.is_constant_or_break_match (|
                              M.read (| γ0_0 |),
                              Value.Bool false
                            |) in
                          let _ :=
                            M.is_constant_or_break_match (| M.read (| γ0_1 |), Value.Bool true |) in
                          let _ :=
                            M.is_constant_or_break_match (| M.read (| γ0_2 |), Value.Bool true |) in
                          let _ :=
                            M.match_operator (|
                              M.alloc (| Value.Tuple [] |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let γ := M.use (M.alloc (| Value.Bool true |)) in
                                    let _ :=
                                      M.is_constant_or_break_match (|
                                        M.read (| γ |),
                                        Value.Bool true
                                      |) in
                                    let _ :=
                                      M.match_operator (|
                                        M.alloc (| Value.Tuple [] |),
                                        [
                                          fun γ =>
                                            ltac:(M.monadic
                                              (let γ :=
                                                M.use
                                                  (M.alloc (|
                                                    UnOp.Pure.not
                                                      (BinOp.Pure.gt
                                                        (M.read (| dst_pre_wrap_len |))
                                                        (M.read (| src_pre_wrap_len |)))
                                                  |)) in
                                              let _ :=
                                                M.is_constant_or_break_match (|
                                                  M.read (| γ |),
                                                  Value.Bool true
                                                |) in
                                              M.alloc (|
                                                M.never_to_any (|
                                                  M.call_closure (|
                                                    M.get_function (|
                                                      "core::panicking::panic",
                                                      []
                                                    |),
                                                    [
                                                      M.read (|
                                                        Value.String
                                                          "assertion failed: dst_pre_wrap_len > src_pre_wrap_len"
                                                      |)
                                                    ]
                                                  |)
                                                |)
                                              |)));
                                          fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                                        ]
                                      |) in
                                    M.alloc (| Value.Tuple [] |)));
                                fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                              ]
                            |) in
                          let delta :=
                            M.alloc (|
                              BinOp.Panic.sub (|
                                Integer.Usize,
                                M.read (| dst_pre_wrap_len |),
                                M.read (| src_pre_wrap_len |)
                              |)
                            |) in
                          let _ :=
                            M.alloc (|
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "alloc::collections::vec_deque::VecDeque")
                                    [ T; A ],
                                  "copy",
                                  []
                                |),
                                [
                                  M.read (| self |);
                                  M.read (| src |);
                                  M.read (| dst |);
                                  M.read (| src_pre_wrap_len |)
                                ]
                              |)
                            |) in
                          let _ :=
                            M.alloc (|
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "alloc::collections::vec_deque::VecDeque")
                                    [ T; A ],
                                  "copy",
                                  []
                                |),
                                [
                                  M.read (| self |);
                                  Value.Integer 0;
                                  BinOp.Panic.add (|
                                    Integer.Usize,
                                    M.read (| dst |),
                                    M.read (| src_pre_wrap_len |)
                                  |);
                                  M.read (| delta |)
                                ]
                              |)
                            |) in
                          let _ :=
                            M.alloc (|
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "alloc::collections::vec_deque::VecDeque")
                                    [ T; A ],
                                  "copy",
                                  []
                                |),
                                [
                                  M.read (| self |);
                                  M.read (| delta |);
                                  Value.Integer 0;
                                  BinOp.Panic.sub (|
                                    Integer.Usize,
                                    M.read (| len |),
                                    M.read (| dst_pre_wrap_len |)
                                  |)
                                ]
                              |)
                            |) in
                          M.alloc (| Value.Tuple [] |)));
                      fun γ =>
                        ltac:(M.monadic
                          (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                          let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                          let γ0_2 := M.SubPointer.get_tuple_field (| γ, 2 |) in
                          let _ :=
                            M.is_constant_or_break_match (| M.read (| γ0_0 |), Value.Bool true |) in
                          let _ :=
                            M.is_constant_or_break_match (| M.read (| γ0_1 |), Value.Bool true |) in
                          let _ :=
                            M.is_constant_or_break_match (| M.read (| γ0_2 |), Value.Bool true |) in
                          let _ :=
                            M.match_operator (|
                              M.alloc (| Value.Tuple [] |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let γ := M.use (M.alloc (| Value.Bool true |)) in
                                    let _ :=
                                      M.is_constant_or_break_match (|
                                        M.read (| γ |),
                                        Value.Bool true
                                      |) in
                                    let _ :=
                                      M.match_operator (|
                                        M.alloc (| Value.Tuple [] |),
                                        [
                                          fun γ =>
                                            ltac:(M.monadic
                                              (let γ :=
                                                M.use
                                                  (M.alloc (|
                                                    UnOp.Pure.not
                                                      (BinOp.Pure.gt
                                                        (M.read (| src_pre_wrap_len |))
                                                        (M.read (| dst_pre_wrap_len |)))
                                                  |)) in
                                              let _ :=
                                                M.is_constant_or_break_match (|
                                                  M.read (| γ |),
                                                  Value.Bool true
                                                |) in
                                              M.alloc (|
                                                M.never_to_any (|
                                                  M.call_closure (|
                                                    M.get_function (|
                                                      "core::panicking::panic",
                                                      []
                                                    |),
                                                    [
                                                      M.read (|
                                                        Value.String
                                                          "assertion failed: src_pre_wrap_len > dst_pre_wrap_len"
                                                      |)
                                                    ]
                                                  |)
                                                |)
                                              |)));
                                          fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                                        ]
                                      |) in
                                    M.alloc (| Value.Tuple [] |)));
                                fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                              ]
                            |) in
                          let delta :=
                            M.alloc (|
                              BinOp.Panic.sub (|
                                Integer.Usize,
                                M.read (| src_pre_wrap_len |),
                                M.read (| dst_pre_wrap_len |)
                              |)
                            |) in
                          let _ :=
                            M.alloc (|
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "alloc::collections::vec_deque::VecDeque")
                                    [ T; A ],
                                  "copy",
                                  []
                                |),
                                [
                                  M.read (| self |);
                                  Value.Integer 0;
                                  M.read (| delta |);
                                  BinOp.Panic.sub (|
                                    Integer.Usize,
                                    M.read (| len |),
                                    M.read (| src_pre_wrap_len |)
                                  |)
                                ]
                              |)
                            |) in
                          let _ :=
                            M.alloc (|
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "alloc::collections::vec_deque::VecDeque")
                                    [ T; A ],
                                  "copy",
                                  []
                                |),
                                [
                                  M.read (| self |);
                                  BinOp.Panic.sub (|
                                    Integer.Usize,
                                    M.call_closure (|
                                      M.get_associated_function (|
                                        Ty.apply
                                          (Ty.path "alloc::collections::vec_deque::VecDeque")
                                          [ T; A ],
                                        "capacity",
                                        []
                                      |),
                                      [ M.read (| self |) ]
                                    |),
                                    M.read (| delta |)
                                  |);
                                  Value.Integer 0;
                                  M.read (| delta |)
                                ]
                              |)
                            |) in
                          let _ :=
                            M.alloc (|
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "alloc::collections::vec_deque::VecDeque")
                                    [ T; A ],
                                  "copy",
                                  []
                                |),
                                [
                                  M.read (| self |);
                                  M.read (| src |);
                                  M.read (| dst |);
                                  M.read (| dst_pre_wrap_len |)
                                ]
                              |)
                            |) in
                          M.alloc (| Value.Tuple [] |)))
                    ]
                  |)
                |)))
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_wrap_copy :
        forall (T A : Ty.t),
        M.IsAssociatedFunction (Self T A) "wrap_copy" (wrap_copy T A).
      
      (*
          unsafe fn copy_slice(&mut self, dst: usize, src: &[T]) {
              debug_assert!(src.len() <= self.capacity());
              let head_room = self.capacity() - dst;
              if src.len() <= head_room {
                  unsafe {
                      ptr::copy_nonoverlapping(src.as_ptr(), self.ptr().add(dst), src.len());
                  }
              } else {
                  let (left, right) = src.split_at(head_room);
                  unsafe {
                      ptr::copy_nonoverlapping(left.as_ptr(), self.ptr().add(dst), left.len());
                      ptr::copy_nonoverlapping(right.as_ptr(), self.ptr(), right.len());
                  }
              }
          }
      *)
      Definition copy_slice (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match τ, α with
        | [], [ self; dst; src ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let dst := M.alloc (| dst |) in
            let src := M.alloc (| src |) in
            M.read (|
              let _ :=
                M.match_operator (|
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.use (M.alloc (| Value.Bool true |)) in
                        let _ :=
                          M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        let _ :=
                          M.match_operator (|
                            M.alloc (| Value.Tuple [] |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ :=
                                    M.use
                                      (M.alloc (|
                                        UnOp.Pure.not
                                          (BinOp.Pure.le
                                            (M.call_closure (|
                                              M.get_associated_function (|
                                                Ty.apply (Ty.path "slice") [ T ],
                                                "len",
                                                []
                                              |),
                                              [ M.read (| src |) ]
                                            |))
                                            (M.call_closure (|
                                              M.get_associated_function (|
                                                Ty.apply
                                                  (Ty.path
                                                    "alloc::collections::vec_deque::VecDeque")
                                                  [ T; A ],
                                                "capacity",
                                                []
                                              |),
                                              [ M.read (| self |) ]
                                            |)))
                                      |)) in
                                  let _ :=
                                    M.is_constant_or_break_match (|
                                      M.read (| γ |),
                                      Value.Bool true
                                    |) in
                                  M.alloc (|
                                    M.never_to_any (|
                                      M.call_closure (|
                                        M.get_function (| "core::panicking::panic", [] |),
                                        [
                                          M.read (|
                                            Value.String
                                              "assertion failed: src.len() <= self.capacity()"
                                          |)
                                        ]
                                      |)
                                    |)
                                  |)));
                              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                            ]
                          |) in
                        M.alloc (| Value.Tuple [] |)));
                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                  ]
                |) in
              let head_room :=
                M.alloc (|
                  BinOp.Panic.sub (|
                    Integer.Usize,
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "alloc::collections::vec_deque::VecDeque") [ T; A ],
                        "capacity",
                        []
                      |),
                      [ M.read (| self |) ]
                    |),
                    M.read (| dst |)
                  |)
                |) in
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            BinOp.Pure.le
                              (M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "slice") [ T ],
                                  "len",
                                  []
                                |),
                                [ M.read (| src |) ]
                              |))
                              (M.read (| head_room |))
                          |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      let _ :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_function (| "core::intrinsics::copy_nonoverlapping", [ T ] |),
                            [
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "slice") [ T ],
                                  "as_ptr",
                                  []
                                |),
                                [ M.read (| src |) ]
                              |);
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "*mut") [ T ],
                                  "add",
                                  []
                                |),
                                [
                                  M.call_closure (|
                                    M.get_associated_function (|
                                      Ty.apply
                                        (Ty.path "alloc::collections::vec_deque::VecDeque")
                                        [ T; A ],
                                      "ptr",
                                      []
                                    |),
                                    [ M.read (| self |) ]
                                  |);
                                  M.read (| dst |)
                                ]
                              |);
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "slice") [ T ],
                                  "len",
                                  []
                                |),
                                [ M.read (| src |) ]
                              |)
                            ]
                          |)
                        |) in
                      M.alloc (| Value.Tuple [] |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.match_operator (|
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply (Ty.path "slice") [ T ],
                              "split_at",
                              []
                            |),
                            [ M.read (| src |); M.read (| head_room |) ]
                          |)
                        |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                              let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                              let left := M.copy (| γ0_0 |) in
                              let right := M.copy (| γ0_1 |) in
                              let _ :=
                                M.alloc (|
                                  M.call_closure (|
                                    M.get_function (|
                                      "core::intrinsics::copy_nonoverlapping",
                                      [ T ]
                                    |),
                                    [
                                      M.call_closure (|
                                        M.get_associated_function (|
                                          Ty.apply (Ty.path "slice") [ T ],
                                          "as_ptr",
                                          []
                                        |),
                                        [ M.read (| left |) ]
                                      |);
                                      M.call_closure (|
                                        M.get_associated_function (|
                                          Ty.apply (Ty.path "*mut") [ T ],
                                          "add",
                                          []
                                        |),
                                        [
                                          M.call_closure (|
                                            M.get_associated_function (|
                                              Ty.apply
                                                (Ty.path "alloc::collections::vec_deque::VecDeque")
                                                [ T; A ],
                                              "ptr",
                                              []
                                            |),
                                            [ M.read (| self |) ]
                                          |);
                                          M.read (| dst |)
                                        ]
                                      |);
                                      M.call_closure (|
                                        M.get_associated_function (|
                                          Ty.apply (Ty.path "slice") [ T ],
                                          "len",
                                          []
                                        |),
                                        [ M.read (| left |) ]
                                      |)
                                    ]
                                  |)
                                |) in
                              let _ :=
                                M.alloc (|
                                  M.call_closure (|
                                    M.get_function (|
                                      "core::intrinsics::copy_nonoverlapping",
                                      [ T ]
                                    |),
                                    [
                                      M.call_closure (|
                                        M.get_associated_function (|
                                          Ty.apply (Ty.path "slice") [ T ],
                                          "as_ptr",
                                          []
                                        |),
                                        [ M.read (| right |) ]
                                      |);
                                      M.call_closure (|
                                        M.get_associated_function (|
                                          Ty.apply
                                            (Ty.path "alloc::collections::vec_deque::VecDeque")
                                            [ T; A ],
                                          "ptr",
                                          []
                                        |),
                                        [ M.read (| self |) ]
                                      |);
                                      M.call_closure (|
                                        M.get_associated_function (|
                                          Ty.apply (Ty.path "slice") [ T ],
                                          "len",
                                          []
                                        |),
                                        [ M.read (| right |) ]
                                      |)
                                    ]
                                  |)
                                |) in
                              M.alloc (| Value.Tuple [] |)))
                        ]
                      |)))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_copy_slice :
        forall (T A : Ty.t),
        M.IsAssociatedFunction (Self T A) "copy_slice" (copy_slice T A).
      
      (*
          unsafe fn write_iter(
              &mut self,
              dst: usize,
              iter: impl Iterator<Item = T>,
              written: &mut usize,
          ) {
              iter.enumerate().for_each(|(i, element)| unsafe {
                  self.buffer_write(dst + i, element);
                  *written += 1;
              });
          }
      *)
      Definition write_iter (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match τ, α with
        | [ impl_Iterator_Item___T_ ], [ self; dst; iter; written ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let dst := M.alloc (| dst |) in
            let iter := M.alloc (| iter |) in
            let written := M.alloc (| written |) in
            M.read (|
              let _ :=
                M.alloc (|
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::iter::traits::iterator::Iterator",
                      Ty.apply
                        (Ty.path "core::iter::adapters::enumerate::Enumerate")
                        [ impl_Iterator_Item___T_ ],
                      [],
                      "for_each",
                      [ Ty.function [ Ty.tuple [ Ty.tuple [ Ty.path "usize"; T ] ] ] (Ty.tuple []) ]
                    |),
                    [
                      M.call_closure (|
                        M.get_trait_method (|
                          "core::iter::traits::iterator::Iterator",
                          impl_Iterator_Item___T_,
                          [],
                          "enumerate",
                          []
                        |),
                        [ M.read (| iter |) ]
                      |);
                      M.closure
                        (fun γ =>
                          ltac:(M.monadic
                            match γ with
                            | [ α0 ] =>
                              M.match_operator (|
                                M.alloc (| α0 |),
                                [
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                      let i := M.copy (| γ0_0 |) in
                                      let element := M.copy (| γ0_1 |) in
                                      M.read (|
                                        let _ :=
                                          M.alloc (|
                                            M.call_closure (|
                                              M.get_associated_function (|
                                                Ty.apply
                                                  (Ty.path
                                                    "alloc::collections::vec_deque::VecDeque")
                                                  [ T; A ],
                                                "buffer_write",
                                                []
                                              |),
                                              [
                                                M.read (| self |);
                                                BinOp.Panic.add (|
                                                  Integer.Usize,
                                                  M.read (| dst |),
                                                  M.read (| i |)
                                                |);
                                                M.read (| element |)
                                              ]
                                            |)
                                          |) in
                                        let _ :=
                                          let β := M.read (| written |) in
                                          M.write (|
                                            β,
                                            BinOp.Panic.add (|
                                              Integer.Usize,
                                              M.read (| β |),
                                              Value.Integer 1
                                            |)
                                          |) in
                                        M.alloc (| Value.Tuple [] |)
                                      |)))
                                ]
                              |)
                            | _ => M.impossible (||)
                            end))
                    ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_write_iter :
        forall (T A : Ty.t),
        M.IsAssociatedFunction (Self T A) "write_iter" (write_iter T A).
      
      (*
          unsafe fn write_iter_wrapping(
              &mut self,
              dst: usize,
              mut iter: impl Iterator<Item = T>,
              len: usize,
          ) -> usize {
              struct Guard<'a, T, A: Allocator> {
                  deque: &'a mut VecDeque<T, A>,
                  written: usize,
              }
      
              impl<'a, T, A: Allocator> Drop for Guard<'a, T, A> {
                  fn drop(&mut self) {
                      self.deque.len += self.written;
                  }
              }
      
              let head_room = self.capacity() - dst;
      
              let mut guard = Guard { deque: self, written: 0 };
      
              if head_room >= len {
                  unsafe { guard.deque.write_iter(dst, iter, &mut guard.written) };
              } else {
                  unsafe {
                      guard.deque.write_iter(
                          dst,
                          ByRefSized(&mut iter).take(head_room),
                          &mut guard.written,
                      );
                      guard.deque.write_iter(0, iter, &mut guard.written)
                  };
              }
      
              guard.written
          }
      *)
      Definition write_iter_wrapping (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match τ, α with
        | [ impl_Iterator_Item___T_ ], [ self; dst; iter; len ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let dst := M.alloc (| dst |) in
            let iter := M.alloc (| iter |) in
            let len := M.alloc (| len |) in
            M.read (|
              let head_room :=
                M.alloc (|
                  BinOp.Panic.sub (|
                    Integer.Usize,
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "alloc::collections::vec_deque::VecDeque") [ T; A ],
                        "capacity",
                        []
                      |),
                      [ M.read (| self |) ]
                    |),
                    M.read (| dst |)
                  |)
                |) in
              let guard :=
                M.alloc (|
                  Value.StructRecord
                    "alloc::collections::vec_deque::write_iter_wrapping::Guard"
                    [ ("deque", M.read (| self |)); ("written", Value.Integer 0) ]
                |) in
              let _ :=
                M.match_operator (|
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ :=
                          M.use
                            (M.alloc (|
                              BinOp.Pure.ge (M.read (| head_room |)) (M.read (| len |))
                            |)) in
                        let _ :=
                          M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        let _ :=
                          M.alloc (|
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "alloc::collections::vec_deque::VecDeque")
                                  [ T; A ],
                                "write_iter",
                                [ impl_Iterator_Item___T_ ]
                              |),
                              [
                                M.read (|
                                  M.SubPointer.get_struct_record_field (|
                                    guard,
                                    "alloc::collections::vec_deque::write_iter_wrapping::Guard",
                                    "deque"
                                  |)
                                |);
                                M.read (| dst |);
                                M.read (| iter |);
                                M.SubPointer.get_struct_record_field (|
                                  guard,
                                  "alloc::collections::vec_deque::write_iter_wrapping::Guard",
                                  "written"
                                |)
                              ]
                            |)
                          |) in
                        M.alloc (| Value.Tuple [] |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let _ :=
                          let _ :=
                            M.alloc (|
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "alloc::collections::vec_deque::VecDeque")
                                    [ T; A ],
                                  "write_iter",
                                  [
                                    Ty.apply
                                      (Ty.path "core::iter::adapters::take::Take")
                                      [
                                        Ty.apply
                                          (Ty.path "core::iter::adapters::by_ref_sized::ByRefSized")
                                          [ impl_Iterator_Item___T_ ]
                                      ]
                                  ]
                                |),
                                [
                                  M.read (|
                                    M.SubPointer.get_struct_record_field (|
                                      guard,
                                      "alloc::collections::vec_deque::write_iter_wrapping::Guard",
                                      "deque"
                                    |)
                                  |);
                                  M.read (| dst |);
                                  M.call_closure (|
                                    M.get_trait_method (|
                                      "core::iter::traits::iterator::Iterator",
                                      Ty.apply
                                        (Ty.path "core::iter::adapters::by_ref_sized::ByRefSized")
                                        [ impl_Iterator_Item___T_ ],
                                      [],
                                      "take",
                                      []
                                    |),
                                    [
                                      Value.StructTuple
                                        "core::iter::adapters::by_ref_sized::ByRefSized"
                                        [ iter ];
                                      M.read (| head_room |)
                                    ]
                                  |);
                                  M.SubPointer.get_struct_record_field (|
                                    guard,
                                    "alloc::collections::vec_deque::write_iter_wrapping::Guard",
                                    "written"
                                  |)
                                ]
                              |)
                            |) in
                          M.alloc (|
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "alloc::collections::vec_deque::VecDeque")
                                  [ T; A ],
                                "write_iter",
                                [ impl_Iterator_Item___T_ ]
                              |),
                              [
                                M.read (|
                                  M.SubPointer.get_struct_record_field (|
                                    guard,
                                    "alloc::collections::vec_deque::write_iter_wrapping::Guard",
                                    "deque"
                                  |)
                                |);
                                Value.Integer 0;
                                M.read (| iter |);
                                M.SubPointer.get_struct_record_field (|
                                  guard,
                                  "alloc::collections::vec_deque::write_iter_wrapping::Guard",
                                  "written"
                                |)
                              ]
                            |)
                          |) in
                        M.alloc (| Value.Tuple [] |)))
                  ]
                |) in
              M.SubPointer.get_struct_record_field (|
                guard,
                "alloc::collections::vec_deque::write_iter_wrapping::Guard",
                "written"
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_write_iter_wrapping :
        forall (T A : Ty.t),
        M.IsAssociatedFunction (Self T A) "write_iter_wrapping" (write_iter_wrapping T A).
      
      (*
          unsafe fn handle_capacity_increase(&mut self, old_capacity: usize) {
              let new_capacity = self.capacity();
              debug_assert!(new_capacity >= old_capacity);
      
              // Move the shortest contiguous section of the ring buffer
              //
              // H := head
              // L := last element (`self.to_physical_idx(self.len - 1)`)
              //
              //    H           L
              //   [o o o o o o o . ]
              //    H           L
              // A [o o o o o o o . . . . . . . . . ]
              //        L H
              //   [o o o o o o o o ]
              //          H           L
              // B [. . . o o o o o o o . . . . . . ]
              //              L H
              //   [o o o o o o o o ]
              //            L                   H
              // C [o o o o o . . . . . . . . . o o ]
      
              // can't use is_contiguous() because the capacity is already updated.
              if self.head <= old_capacity - self.len {
                  // A
                  // Nop
              } else {
                  let head_len = old_capacity - self.head;
                  let tail_len = self.len - head_len;
                  if head_len > tail_len && new_capacity - old_capacity >= tail_len {
                      // B
                      unsafe {
                          self.copy_nonoverlapping(0, old_capacity, tail_len);
                      }
                  } else {
                      // C
                      let new_head = new_capacity - head_len;
                      unsafe {
                          // can't use copy_nonoverlapping here, because if e.g. head_len = 2
                          // and new_capacity = old_capacity + 1, then the heads overlap.
                          self.copy(self.head, new_head, head_len);
                      }
                      self.head = new_head;
                  }
              }
              debug_assert!(self.head < self.capacity() || self.capacity() == 0);
          }
      *)
      Definition handle_capacity_increase (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match τ, α with
        | [], [ self; old_capacity ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let old_capacity := M.alloc (| old_capacity |) in
            M.read (|
              let new_capacity :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply (Ty.path "alloc::collections::vec_deque::VecDeque") [ T; A ],
                      "capacity",
                      []
                    |),
                    [ M.read (| self |) ]
                  |)
                |) in
              let _ :=
                M.match_operator (|
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.use (M.alloc (| Value.Bool true |)) in
                        let _ :=
                          M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        let _ :=
                          M.match_operator (|
                            M.alloc (| Value.Tuple [] |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ :=
                                    M.use
                                      (M.alloc (|
                                        UnOp.Pure.not
                                          (BinOp.Pure.ge
                                            (M.read (| new_capacity |))
                                            (M.read (| old_capacity |)))
                                      |)) in
                                  let _ :=
                                    M.is_constant_or_break_match (|
                                      M.read (| γ |),
                                      Value.Bool true
                                    |) in
                                  M.alloc (|
                                    M.never_to_any (|
                                      M.call_closure (|
                                        M.get_function (| "core::panicking::panic", [] |),
                                        [
                                          M.read (|
                                            Value.String
                                              "assertion failed: new_capacity >= old_capacity"
                                          |)
                                        ]
                                      |)
                                    |)
                                  |)));
                              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                            ]
                          |) in
                        M.alloc (| Value.Tuple [] |)));
                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                  ]
                |) in
              let _ :=
                M.match_operator (|
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ :=
                          M.use
                            (M.alloc (|
                              BinOp.Pure.le
                                (M.read (|
                                  M.SubPointer.get_struct_record_field (|
                                    M.read (| self |),
                                    "alloc::collections::vec_deque::VecDeque",
                                    "head"
                                  |)
                                |))
                                (BinOp.Panic.sub (|
                                  Integer.Usize,
                                  M.read (| old_capacity |),
                                  M.read (|
                                    M.SubPointer.get_struct_record_field (|
                                      M.read (| self |),
                                      "alloc::collections::vec_deque::VecDeque",
                                      "len"
                                    |)
                                  |)
                                |))
                            |)) in
                        let _ :=
                          M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        M.alloc (| Value.Tuple [] |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let head_len :=
                          M.alloc (|
                            BinOp.Panic.sub (|
                              Integer.Usize,
                              M.read (| old_capacity |),
                              M.read (|
                                M.SubPointer.get_struct_record_field (|
                                  M.read (| self |),
                                  "alloc::collections::vec_deque::VecDeque",
                                  "head"
                                |)
                              |)
                            |)
                          |) in
                        let tail_len :=
                          M.alloc (|
                            BinOp.Panic.sub (|
                              Integer.Usize,
                              M.read (|
                                M.SubPointer.get_struct_record_field (|
                                  M.read (| self |),
                                  "alloc::collections::vec_deque::VecDeque",
                                  "len"
                                |)
                              |),
                              M.read (| head_len |)
                            |)
                          |) in
                        M.match_operator (|
                          M.alloc (| Value.Tuple [] |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ :=
                                  M.use
                                    (M.alloc (|
                                      LogicalOp.and (|
                                        BinOp.Pure.gt
                                          (M.read (| head_len |))
                                          (M.read (| tail_len |)),
                                        ltac:(M.monadic
                                          (BinOp.Pure.ge
                                            (BinOp.Panic.sub (|
                                              Integer.Usize,
                                              M.read (| new_capacity |),
                                              M.read (| old_capacity |)
                                            |))
                                            (M.read (| tail_len |))))
                                      |)
                                    |)) in
                                let _ :=
                                  M.is_constant_or_break_match (|
                                    M.read (| γ |),
                                    Value.Bool true
                                  |) in
                                let _ :=
                                  M.alloc (|
                                    M.call_closure (|
                                      M.get_associated_function (|
                                        Ty.apply
                                          (Ty.path "alloc::collections::vec_deque::VecDeque")
                                          [ T; A ],
                                        "copy_nonoverlapping",
                                        []
                                      |),
                                      [
                                        M.read (| self |);
                                        Value.Integer 0;
                                        M.read (| old_capacity |);
                                        M.read (| tail_len |)
                                      ]
                                    |)
                                  |) in
                                M.alloc (| Value.Tuple [] |)));
                            fun γ =>
                              ltac:(M.monadic
                                (let new_head :=
                                  M.alloc (|
                                    BinOp.Panic.sub (|
                                      Integer.Usize,
                                      M.read (| new_capacity |),
                                      M.read (| head_len |)
                                    |)
                                  |) in
                                let _ :=
                                  let _ :=
                                    M.alloc (|
                                      M.call_closure (|
                                        M.get_associated_function (|
                                          Ty.apply
                                            (Ty.path "alloc::collections::vec_deque::VecDeque")
                                            [ T; A ],
                                          "copy",
                                          []
                                        |),
                                        [
                                          M.read (| self |);
                                          M.read (|
                                            M.SubPointer.get_struct_record_field (|
                                              M.read (| self |),
                                              "alloc::collections::vec_deque::VecDeque",
                                              "head"
                                            |)
                                          |);
                                          M.read (| new_head |);
                                          M.read (| head_len |)
                                        ]
                                      |)
                                    |) in
                                  M.alloc (| Value.Tuple [] |) in
                                let _ :=
                                  M.write (|
                                    M.SubPointer.get_struct_record_field (|
                                      M.read (| self |),
                                      "alloc::collections::vec_deque::VecDeque",
                                      "head"
                                    |),
                                    M.read (| new_head |)
                                  |) in
                                M.alloc (| Value.Tuple [] |)))
                          ]
                        |)))
                  ]
                |) in
              let _ :=
                M.match_operator (|
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.use (M.alloc (| Value.Bool true |)) in
                        let _ :=
                          M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        let _ :=
                          M.match_operator (|
                            M.alloc (| Value.Tuple [] |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ :=
                                    M.use
                                      (M.alloc (|
                                        UnOp.Pure.not
                                          (LogicalOp.or (|
                                            BinOp.Pure.lt
                                              (M.read (|
                                                M.SubPointer.get_struct_record_field (|
                                                  M.read (| self |),
                                                  "alloc::collections::vec_deque::VecDeque",
                                                  "head"
                                                |)
                                              |))
                                              (M.call_closure (|
                                                M.get_associated_function (|
                                                  Ty.apply
                                                    (Ty.path
                                                      "alloc::collections::vec_deque::VecDeque")
                                                    [ T; A ],
                                                  "capacity",
                                                  []
                                                |),
                                                [ M.read (| self |) ]
                                              |)),
                                            ltac:(M.monadic
                                              (BinOp.Pure.eq
                                                (M.call_closure (|
                                                  M.get_associated_function (|
                                                    Ty.apply
                                                      (Ty.path
                                                        "alloc::collections::vec_deque::VecDeque")
                                                      [ T; A ],
                                                    "capacity",
                                                    []
                                                  |),
                                                  [ M.read (| self |) ]
                                                |))
                                                (Value.Integer 0)))
                                          |))
                                      |)) in
                                  let _ :=
                                    M.is_constant_or_break_match (|
                                      M.read (| γ |),
                                      Value.Bool true
                                    |) in
                                  M.alloc (|
                                    M.never_to_any (|
                                      M.call_closure (|
                                        M.get_function (| "core::panicking::panic", [] |),
                                        [
                                          M.read (|
                                            Value.String
                                              "assertion failed: self.head < self.capacity() || self.capacity() == 0"
                                          |)
                                        ]
                                      |)
                                    |)
                                  |)));
                              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                            ]
                          |) in
                        M.alloc (| Value.Tuple [] |)));
                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                  ]
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_handle_capacity_increase :
        forall (T A : Ty.t),
        M.IsAssociatedFunction (Self T A) "handle_capacity_increase" (handle_capacity_increase T A).
      (*
          pub const fn new_in(alloc: A) -> VecDeque<T, A> {
              VecDeque { head: 0, len: 0, buf: RawVec::new_in(alloc) }
          }
      *)
      Definition new_in (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match τ, α with
        | [], [ alloc ] =>
          ltac:(M.monadic
            (let alloc := M.alloc (| alloc |) in
            Value.StructRecord
              "alloc::collections::vec_deque::VecDeque"
              [
                ("head", Value.Integer 0);
                ("len", Value.Integer 0);
                ("buf",
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply (Ty.path "alloc::raw_vec::RawVec") [ T; A ],
                      "new_in",
                      []
                    |),
                    [ M.read (| alloc |) ]
                  |))
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_new_in :
        forall (T A : Ty.t),
        M.IsAssociatedFunction (Self T A) "new_in" (new_in T A).
      
      (*
          pub fn with_capacity_in(capacity: usize, alloc: A) -> VecDeque<T, A> {
              VecDeque { head: 0, len: 0, buf: RawVec::with_capacity_in(capacity, alloc) }
          }
      *)
      Definition with_capacity_in (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match τ, α with
        | [], [ capacity; alloc ] =>
          ltac:(M.monadic
            (let capacity := M.alloc (| capacity |) in
            let alloc := M.alloc (| alloc |) in
            Value.StructRecord
              "alloc::collections::vec_deque::VecDeque"
              [
                ("head", Value.Integer 0);
                ("len", Value.Integer 0);
                ("buf",
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply (Ty.path "alloc::raw_vec::RawVec") [ T; A ],
                      "with_capacity_in",
                      []
                    |),
                    [ M.read (| capacity |); M.read (| alloc |) ]
                  |))
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_with_capacity_in :
        forall (T A : Ty.t),
        M.IsAssociatedFunction (Self T A) "with_capacity_in" (with_capacity_in T A).
      
      (*
          pub(crate) unsafe fn from_contiguous_raw_parts_in(
              ptr: *mut T,
              initialized: Range<usize>,
              capacity: usize,
              alloc: A,
          ) -> Self {
              debug_assert!(initialized.start <= initialized.end);
              debug_assert!(initialized.end <= capacity);
      
              // SAFETY: Our safety precondition guarantees the range length won't wrap,
              // and that the allocation is valid for use in `RawVec`.
              unsafe {
                  VecDeque {
                      head: initialized.start,
                      len: initialized.end.unchecked_sub(initialized.start),
                      buf: RawVec::from_raw_parts_in(ptr, capacity, alloc),
                  }
              }
          }
      *)
      Definition from_contiguous_raw_parts_in (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match τ, α with
        | [], [ ptr; initialized; capacity; alloc ] =>
          ltac:(M.monadic
            (let ptr := M.alloc (| ptr |) in
            let initialized := M.alloc (| initialized |) in
            let capacity := M.alloc (| capacity |) in
            let alloc := M.alloc (| alloc |) in
            M.read (|
              let _ :=
                M.match_operator (|
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.use (M.alloc (| Value.Bool true |)) in
                        let _ :=
                          M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        let _ :=
                          M.match_operator (|
                            M.alloc (| Value.Tuple [] |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ :=
                                    M.use
                                      (M.alloc (|
                                        UnOp.Pure.not
                                          (BinOp.Pure.le
                                            (M.read (|
                                              M.SubPointer.get_struct_record_field (|
                                                initialized,
                                                "core::ops::range::Range",
                                                "start"
                                              |)
                                            |))
                                            (M.read (|
                                              M.SubPointer.get_struct_record_field (|
                                                initialized,
                                                "core::ops::range::Range",
                                                "end"
                                              |)
                                            |)))
                                      |)) in
                                  let _ :=
                                    M.is_constant_or_break_match (|
                                      M.read (| γ |),
                                      Value.Bool true
                                    |) in
                                  M.alloc (|
                                    M.never_to_any (|
                                      M.call_closure (|
                                        M.get_function (| "core::panicking::panic", [] |),
                                        [
                                          M.read (|
                                            Value.String
                                              "assertion failed: initialized.start <= initialized.end"
                                          |)
                                        ]
                                      |)
                                    |)
                                  |)));
                              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                            ]
                          |) in
                        M.alloc (| Value.Tuple [] |)));
                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                  ]
                |) in
              let _ :=
                M.match_operator (|
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.use (M.alloc (| Value.Bool true |)) in
                        let _ :=
                          M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        let _ :=
                          M.match_operator (|
                            M.alloc (| Value.Tuple [] |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ :=
                                    M.use
                                      (M.alloc (|
                                        UnOp.Pure.not
                                          (BinOp.Pure.le
                                            (M.read (|
                                              M.SubPointer.get_struct_record_field (|
                                                initialized,
                                                "core::ops::range::Range",
                                                "end"
                                              |)
                                            |))
                                            (M.read (| capacity |)))
                                      |)) in
                                  let _ :=
                                    M.is_constant_or_break_match (|
                                      M.read (| γ |),
                                      Value.Bool true
                                    |) in
                                  M.alloc (|
                                    M.never_to_any (|
                                      M.call_closure (|
                                        M.get_function (| "core::panicking::panic", [] |),
                                        [
                                          M.read (|
                                            Value.String
                                              "assertion failed: initialized.end <= capacity"
                                          |)
                                        ]
                                      |)
                                    |)
                                  |)));
                              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                            ]
                          |) in
                        M.alloc (| Value.Tuple [] |)));
                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                  ]
                |) in
              M.alloc (|
                Value.StructRecord
                  "alloc::collections::vec_deque::VecDeque"
                  [
                    ("head",
                      M.read (|
                        M.SubPointer.get_struct_record_field (|
                          initialized,
                          "core::ops::range::Range",
                          "start"
                        |)
                      |));
                    ("len",
                      M.call_closure (|
                        M.get_associated_function (| Ty.path "usize", "unchecked_sub", [] |),
                        [
                          M.read (|
                            M.SubPointer.get_struct_record_field (|
                              initialized,
                              "core::ops::range::Range",
                              "end"
                            |)
                          |);
                          M.read (|
                            M.SubPointer.get_struct_record_field (|
                              initialized,
                              "core::ops::range::Range",
                              "start"
                            |)
                          |)
                        ]
                      |));
                    ("buf",
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "alloc::raw_vec::RawVec") [ T; A ],
                          "from_raw_parts_in",
                          []
                        |),
                        [ M.read (| ptr |); M.read (| capacity |); M.read (| alloc |) ]
                      |))
                  ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_from_contiguous_raw_parts_in :
        forall (T A : Ty.t),
        M.IsAssociatedFunction
          (Self T A)
          "from_contiguous_raw_parts_in"
          (from_contiguous_raw_parts_in T A).
      
      (*
          pub fn get(&self, index: usize) -> Option<&T> {
              if index < self.len {
                  let idx = self.to_physical_idx(index);
                  unsafe { Some(&*self.ptr().add(idx)) }
              } else {
                  None
              }
          }
      *)
      Definition get (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match τ, α with
        | [], [ self; index ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let index := M.alloc (| index |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            BinOp.Pure.lt
                              (M.read (| index |))
                              (M.read (|
                                M.SubPointer.get_struct_record_field (|
                                  M.read (| self |),
                                  "alloc::collections::vec_deque::VecDeque",
                                  "len"
                                |)
                              |))
                          |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      let idx :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply (Ty.path "alloc::collections::vec_deque::VecDeque") [ T; A ],
                              "to_physical_idx",
                              []
                            |),
                            [ M.read (| self |); M.read (| index |) ]
                          |)
                        |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::option::Option::Some"
                          [
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply (Ty.path "*mut") [ T ],
                                "add",
                                []
                              |),
                              [
                                M.call_closure (|
                                  M.get_associated_function (|
                                    Ty.apply
                                      (Ty.path "alloc::collections::vec_deque::VecDeque")
                                      [ T; A ],
                                    "ptr",
                                    []
                                  |),
                                  [ M.read (| self |) ]
                                |);
                                M.read (| idx |)
                              ]
                            |)
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_get :
        forall (T A : Ty.t),
        M.IsAssociatedFunction (Self T A) "get" (get T A).
      
      (*
          pub fn get_mut(&mut self, index: usize) -> Option<&mut T> {
              if index < self.len {
                  let idx = self.to_physical_idx(index);
                  unsafe { Some(&mut *self.ptr().add(idx)) }
              } else {
                  None
              }
          }
      *)
      Definition get_mut (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match τ, α with
        | [], [ self; index ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let index := M.alloc (| index |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            BinOp.Pure.lt
                              (M.read (| index |))
                              (M.read (|
                                M.SubPointer.get_struct_record_field (|
                                  M.read (| self |),
                                  "alloc::collections::vec_deque::VecDeque",
                                  "len"
                                |)
                              |))
                          |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      let idx :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply (Ty.path "alloc::collections::vec_deque::VecDeque") [ T; A ],
                              "to_physical_idx",
                              []
                            |),
                            [ M.read (| self |); M.read (| index |) ]
                          |)
                        |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::option::Option::Some"
                          [
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply (Ty.path "*mut") [ T ],
                                "add",
                                []
                              |),
                              [
                                M.call_closure (|
                                  M.get_associated_function (|
                                    Ty.apply
                                      (Ty.path "alloc::collections::vec_deque::VecDeque")
                                      [ T; A ],
                                    "ptr",
                                    []
                                  |),
                                  [ M.read (| self |) ]
                                |);
                                M.read (| idx |)
                              ]
                            |)
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_get_mut :
        forall (T A : Ty.t),
        M.IsAssociatedFunction (Self T A) "get_mut" (get_mut T A).
      
      (*
          pub fn swap(&mut self, i: usize, j: usize) {
              assert!(i < self.len());
              assert!(j < self.len());
              let ri = self.to_physical_idx(i);
              let rj = self.to_physical_idx(j);
              unsafe { ptr::swap(self.ptr().add(ri), self.ptr().add(rj)) }
          }
      *)
      Definition swap (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match τ, α with
        | [], [ self; i; j ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let i := M.alloc (| i |) in
            let j := M.alloc (| j |) in
            M.read (|
              let _ :=
                M.match_operator (|
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ :=
                          M.use
                            (M.alloc (|
                              UnOp.Pure.not
                                (BinOp.Pure.lt
                                  (M.read (| i |))
                                  (M.call_closure (|
                                    M.get_associated_function (|
                                      Ty.apply
                                        (Ty.path "alloc::collections::vec_deque::VecDeque")
                                        [ T; A ],
                                      "len",
                                      []
                                    |),
                                    [ M.read (| self |) ]
                                  |)))
                            |)) in
                        let _ :=
                          M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        M.alloc (|
                          M.never_to_any (|
                            M.call_closure (|
                              M.get_function (| "core::panicking::panic", [] |),
                              [ M.read (| Value.String "assertion failed: i < self.len()" |) ]
                            |)
                          |)
                        |)));
                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                  ]
                |) in
              let _ :=
                M.match_operator (|
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ :=
                          M.use
                            (M.alloc (|
                              UnOp.Pure.not
                                (BinOp.Pure.lt
                                  (M.read (| j |))
                                  (M.call_closure (|
                                    M.get_associated_function (|
                                      Ty.apply
                                        (Ty.path "alloc::collections::vec_deque::VecDeque")
                                        [ T; A ],
                                      "len",
                                      []
                                    |),
                                    [ M.read (| self |) ]
                                  |)))
                            |)) in
                        let _ :=
                          M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        M.alloc (|
                          M.never_to_any (|
                            M.call_closure (|
                              M.get_function (| "core::panicking::panic", [] |),
                              [ M.read (| Value.String "assertion failed: j < self.len()" |) ]
                            |)
                          |)
                        |)));
                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                  ]
                |) in
              let ri :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply (Ty.path "alloc::collections::vec_deque::VecDeque") [ T; A ],
                      "to_physical_idx",
                      []
                    |),
                    [ M.read (| self |); M.read (| i |) ]
                  |)
                |) in
              let rj :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply (Ty.path "alloc::collections::vec_deque::VecDeque") [ T; A ],
                      "to_physical_idx",
                      []
                    |),
                    [ M.read (| self |); M.read (| j |) ]
                  |)
                |) in
              M.alloc (|
                M.call_closure (|
                  M.get_function (| "core::ptr::swap", [ T ] |),
                  [
                    M.call_closure (|
                      M.get_associated_function (| Ty.apply (Ty.path "*mut") [ T ], "add", [] |),
                      [
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.apply (Ty.path "alloc::collections::vec_deque::VecDeque") [ T; A ],
                            "ptr",
                            []
                          |),
                          [ M.read (| self |) ]
                        |);
                        M.read (| ri |)
                      ]
                    |);
                    M.call_closure (|
                      M.get_associated_function (| Ty.apply (Ty.path "*mut") [ T ], "add", [] |),
                      [
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.apply (Ty.path "alloc::collections::vec_deque::VecDeque") [ T; A ],
                            "ptr",
                            []
                          |),
                          [ M.read (| self |) ]
                        |);
                        M.read (| rj |)
                      ]
                    |)
                  ]
                |)
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_swap :
        forall (T A : Ty.t),
        M.IsAssociatedFunction (Self T A) "swap" (swap T A).
      
      (*
          pub fn capacity(&self) -> usize {
              if T::IS_ZST { usize::MAX } else { self.buf.capacity() }
          }
      *)
      Definition capacity (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use (M.get_constant (| "core::mem::SizedTypeProperties::IS_ZST" |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.get_constant (| "core::num::MAX" |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.apply (Ty.path "alloc::raw_vec::RawVec") [ T; A ],
                            "capacity",
                            []
                          |),
                          [
                            M.SubPointer.get_struct_record_field (|
                              M.read (| self |),
                              "alloc::collections::vec_deque::VecDeque",
                              "buf"
                            |)
                          ]
                        |)
                      |)))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_capacity :
        forall (T A : Ty.t),
        M.IsAssociatedFunction (Self T A) "capacity" (capacity T A).
      
      (*
          pub fn reserve_exact(&mut self, additional: usize) {
              let new_cap = self.len.checked_add(additional).expect("capacity overflow");
              let old_cap = self.capacity();
      
              if new_cap > old_cap {
                  self.buf.reserve_exact(self.len, additional);
                  unsafe {
                      self.handle_capacity_increase(old_cap);
                  }
              }
          }
      *)
      Definition reserve_exact (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match τ, α with
        | [], [ self; additional ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let additional := M.alloc (| additional |) in
            M.read (|
              let new_cap :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply (Ty.path "core::option::Option") [ Ty.path "usize" ],
                      "expect",
                      []
                    |),
                    [
                      M.call_closure (|
                        M.get_associated_function (| Ty.path "usize", "checked_add", [] |),
                        [
                          M.read (|
                            M.SubPointer.get_struct_record_field (|
                              M.read (| self |),
                              "alloc::collections::vec_deque::VecDeque",
                              "len"
                            |)
                          |);
                          M.read (| additional |)
                        ]
                      |);
                      M.read (| Value.String "capacity overflow" |)
                    ]
                  |)
                |) in
              let old_cap :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply (Ty.path "alloc::collections::vec_deque::VecDeque") [ T; A ],
                      "capacity",
                      []
                    |),
                    [ M.read (| self |) ]
                  |)
                |) in
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            BinOp.Pure.gt (M.read (| new_cap |)) (M.read (| old_cap |))
                          |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      let _ :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply (Ty.path "alloc::raw_vec::RawVec") [ T; A ],
                              "reserve_exact",
                              []
                            |),
                            [
                              M.SubPointer.get_struct_record_field (|
                                M.read (| self |),
                                "alloc::collections::vec_deque::VecDeque",
                                "buf"
                              |);
                              M.read (|
                                M.SubPointer.get_struct_record_field (|
                                  M.read (| self |),
                                  "alloc::collections::vec_deque::VecDeque",
                                  "len"
                                |)
                              |);
                              M.read (| additional |)
                            ]
                          |)
                        |) in
                      let _ :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply (Ty.path "alloc::collections::vec_deque::VecDeque") [ T; A ],
                              "handle_capacity_increase",
                              []
                            |),
                            [ M.read (| self |); M.read (| old_cap |) ]
                          |)
                        |) in
                      M.alloc (| Value.Tuple [] |)));
                  fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_reserve_exact :
        forall (T A : Ty.t),
        M.IsAssociatedFunction (Self T A) "reserve_exact" (reserve_exact T A).
      
      (*
          pub fn reserve(&mut self, additional: usize) {
              let new_cap = self.len.checked_add(additional).expect("capacity overflow");
              let old_cap = self.capacity();
      
              if new_cap > old_cap {
                  // we don't need to reserve_exact(), as the size doesn't have
                  // to be a power of 2.
                  self.buf.reserve(self.len, additional);
                  unsafe {
                      self.handle_capacity_increase(old_cap);
                  }
              }
          }
      *)
      Definition reserve (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match τ, α with
        | [], [ self; additional ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let additional := M.alloc (| additional |) in
            M.read (|
              let new_cap :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply (Ty.path "core::option::Option") [ Ty.path "usize" ],
                      "expect",
                      []
                    |),
                    [
                      M.call_closure (|
                        M.get_associated_function (| Ty.path "usize", "checked_add", [] |),
                        [
                          M.read (|
                            M.SubPointer.get_struct_record_field (|
                              M.read (| self |),
                              "alloc::collections::vec_deque::VecDeque",
                              "len"
                            |)
                          |);
                          M.read (| additional |)
                        ]
                      |);
                      M.read (| Value.String "capacity overflow" |)
                    ]
                  |)
                |) in
              let old_cap :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply (Ty.path "alloc::collections::vec_deque::VecDeque") [ T; A ],
                      "capacity",
                      []
                    |),
                    [ M.read (| self |) ]
                  |)
                |) in
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            BinOp.Pure.gt (M.read (| new_cap |)) (M.read (| old_cap |))
                          |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      let _ :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply (Ty.path "alloc::raw_vec::RawVec") [ T; A ],
                              "reserve",
                              []
                            |),
                            [
                              M.SubPointer.get_struct_record_field (|
                                M.read (| self |),
                                "alloc::collections::vec_deque::VecDeque",
                                "buf"
                              |);
                              M.read (|
                                M.SubPointer.get_struct_record_field (|
                                  M.read (| self |),
                                  "alloc::collections::vec_deque::VecDeque",
                                  "len"
                                |)
                              |);
                              M.read (| additional |)
                            ]
                          |)
                        |) in
                      let _ :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply (Ty.path "alloc::collections::vec_deque::VecDeque") [ T; A ],
                              "handle_capacity_increase",
                              []
                            |),
                            [ M.read (| self |); M.read (| old_cap |) ]
                          |)
                        |) in
                      M.alloc (| Value.Tuple [] |)));
                  fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_reserve :
        forall (T A : Ty.t),
        M.IsAssociatedFunction (Self T A) "reserve" (reserve T A).
      
      (*
          pub fn try_reserve_exact(&mut self, additional: usize) -> Result<(), TryReserveError> {
              let new_cap =
                  self.len.checked_add(additional).ok_or(TryReserveErrorKind::CapacityOverflow)?;
              let old_cap = self.capacity();
      
              if new_cap > old_cap {
                  self.buf.try_reserve_exact(self.len, additional)?;
                  unsafe {
                      self.handle_capacity_increase(old_cap);
                  }
              }
              Ok(())
          }
      *)
      Definition try_reserve_exact (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match τ, α with
        | [], [ self; additional ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let additional := M.alloc (| additional |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.read (|
                  let new_cap :=
                    M.copy (|
                      M.match_operator (|
                        M.alloc (|
                          M.call_closure (|
                            M.get_trait_method (|
                              "core::ops::try_trait::Try",
                              Ty.apply
                                (Ty.path "core::result::Result")
                                [ Ty.path "usize"; Ty.path "alloc::collections::TryReserveErrorKind"
                                ],
                              [],
                              "branch",
                              []
                            |),
                            [
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "core::option::Option") [ Ty.path "usize" ],
                                  "ok_or",
                                  [ Ty.path "alloc::collections::TryReserveErrorKind" ]
                                |),
                                [
                                  M.call_closure (|
                                    M.get_associated_function (|
                                      Ty.path "usize",
                                      "checked_add",
                                      []
                                    |),
                                    [
                                      M.read (|
                                        M.SubPointer.get_struct_record_field (|
                                          M.read (| self |),
                                          "alloc::collections::vec_deque::VecDeque",
                                          "len"
                                        |)
                                      |);
                                      M.read (| additional |)
                                    ]
                                  |);
                                  Value.StructTuple
                                    "alloc::collections::TryReserveErrorKind::CapacityOverflow"
                                    []
                                ]
                              |)
                            ]
                          |)
                        |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 :=
                                M.SubPointer.get_struct_tuple_field (|
                                  γ,
                                  "core::ops::control_flow::ControlFlow::Break",
                                  0
                                |) in
                              let residual := M.copy (| γ0_0 |) in
                              M.alloc (|
                                M.never_to_any (|
                                  M.read (|
                                    M.return_ (|
                                      M.call_closure (|
                                        M.get_trait_method (|
                                          "core::ops::try_trait::FromResidual",
                                          Ty.apply
                                            (Ty.path "core::result::Result")
                                            [
                                              Ty.tuple [];
                                              Ty.path "alloc::collections::TryReserveError"
                                            ],
                                          [
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              [
                                                Ty.path "core::convert::Infallible";
                                                Ty.path "alloc::collections::TryReserveErrorKind"
                                              ]
                                          ],
                                          "from_residual",
                                          []
                                        |),
                                        [ M.read (| residual |) ]
                                      |)
                                    |)
                                  |)
                                |)
                              |)));
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 :=
                                M.SubPointer.get_struct_tuple_field (|
                                  γ,
                                  "core::ops::control_flow::ControlFlow::Continue",
                                  0
                                |) in
                              let val := M.copy (| γ0_0 |) in
                              val))
                        ]
                      |)
                    |) in
                  let old_cap :=
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "alloc::collections::vec_deque::VecDeque") [ T; A ],
                          "capacity",
                          []
                        |),
                        [ M.read (| self |) ]
                      |)
                    |) in
                  let _ :=
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  BinOp.Pure.gt (M.read (| new_cap |)) (M.read (| old_cap |))
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            let _ :=
                              M.match_operator (|
                                M.alloc (|
                                  M.call_closure (|
                                    M.get_trait_method (|
                                      "core::ops::try_trait::Try",
                                      Ty.apply
                                        (Ty.path "core::result::Result")
                                        [ Ty.tuple []; Ty.path "alloc::collections::TryReserveError"
                                        ],
                                      [],
                                      "branch",
                                      []
                                    |),
                                    [
                                      M.call_closure (|
                                        M.get_associated_function (|
                                          Ty.apply (Ty.path "alloc::raw_vec::RawVec") [ T; A ],
                                          "try_reserve_exact",
                                          []
                                        |),
                                        [
                                          M.SubPointer.get_struct_record_field (|
                                            M.read (| self |),
                                            "alloc::collections::vec_deque::VecDeque",
                                            "buf"
                                          |);
                                          M.read (|
                                            M.SubPointer.get_struct_record_field (|
                                              M.read (| self |),
                                              "alloc::collections::vec_deque::VecDeque",
                                              "len"
                                            |)
                                          |);
                                          M.read (| additional |)
                                        ]
                                      |)
                                    ]
                                  |)
                                |),
                                [
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let γ0_0 :=
                                        M.SubPointer.get_struct_tuple_field (|
                                          γ,
                                          "core::ops::control_flow::ControlFlow::Break",
                                          0
                                        |) in
                                      let residual := M.copy (| γ0_0 |) in
                                      M.alloc (|
                                        M.never_to_any (|
                                          M.read (|
                                            M.return_ (|
                                              M.call_closure (|
                                                M.get_trait_method (|
                                                  "core::ops::try_trait::FromResidual",
                                                  Ty.apply
                                                    (Ty.path "core::result::Result")
                                                    [
                                                      Ty.tuple [];
                                                      Ty.path "alloc::collections::TryReserveError"
                                                    ],
                                                  [
                                                    Ty.apply
                                                      (Ty.path "core::result::Result")
                                                      [
                                                        Ty.path "core::convert::Infallible";
                                                        Ty.path
                                                          "alloc::collections::TryReserveError"
                                                      ]
                                                  ],
                                                  "from_residual",
                                                  []
                                                |),
                                                [ M.read (| residual |) ]
                                              |)
                                            |)
                                          |)
                                        |)
                                      |)));
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let γ0_0 :=
                                        M.SubPointer.get_struct_tuple_field (|
                                          γ,
                                          "core::ops::control_flow::ControlFlow::Continue",
                                          0
                                        |) in
                                      let val := M.copy (| γ0_0 |) in
                                      val))
                                ]
                              |) in
                            let _ :=
                              M.alloc (|
                                M.call_closure (|
                                  M.get_associated_function (|
                                    Ty.apply
                                      (Ty.path "alloc::collections::vec_deque::VecDeque")
                                      [ T; A ],
                                    "handle_capacity_increase",
                                    []
                                  |),
                                  [ M.read (| self |); M.read (| old_cap |) ]
                                |)
                              |) in
                            M.alloc (| Value.Tuple [] |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                      ]
                    |) in
                  M.alloc (| Value.StructTuple "core::result::Result::Ok" [ Value.Tuple [] ] |)
                |)))
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_try_reserve_exact :
        forall (T A : Ty.t),
        M.IsAssociatedFunction (Self T A) "try_reserve_exact" (try_reserve_exact T A).
      
      (*
          pub fn try_reserve(&mut self, additional: usize) -> Result<(), TryReserveError> {
              let new_cap =
                  self.len.checked_add(additional).ok_or(TryReserveErrorKind::CapacityOverflow)?;
              let old_cap = self.capacity();
      
              if new_cap > old_cap {
                  self.buf.try_reserve(self.len, additional)?;
                  unsafe {
                      self.handle_capacity_increase(old_cap);
                  }
              }
              Ok(())
          }
      *)
      Definition try_reserve (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match τ, α with
        | [], [ self; additional ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let additional := M.alloc (| additional |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.read (|
                  let new_cap :=
                    M.copy (|
                      M.match_operator (|
                        M.alloc (|
                          M.call_closure (|
                            M.get_trait_method (|
                              "core::ops::try_trait::Try",
                              Ty.apply
                                (Ty.path "core::result::Result")
                                [ Ty.path "usize"; Ty.path "alloc::collections::TryReserveErrorKind"
                                ],
                              [],
                              "branch",
                              []
                            |),
                            [
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "core::option::Option") [ Ty.path "usize" ],
                                  "ok_or",
                                  [ Ty.path "alloc::collections::TryReserveErrorKind" ]
                                |),
                                [
                                  M.call_closure (|
                                    M.get_associated_function (|
                                      Ty.path "usize",
                                      "checked_add",
                                      []
                                    |),
                                    [
                                      M.read (|
                                        M.SubPointer.get_struct_record_field (|
                                          M.read (| self |),
                                          "alloc::collections::vec_deque::VecDeque",
                                          "len"
                                        |)
                                      |);
                                      M.read (| additional |)
                                    ]
                                  |);
                                  Value.StructTuple
                                    "alloc::collections::TryReserveErrorKind::CapacityOverflow"
                                    []
                                ]
                              |)
                            ]
                          |)
                        |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 :=
                                M.SubPointer.get_struct_tuple_field (|
                                  γ,
                                  "core::ops::control_flow::ControlFlow::Break",
                                  0
                                |) in
                              let residual := M.copy (| γ0_0 |) in
                              M.alloc (|
                                M.never_to_any (|
                                  M.read (|
                                    M.return_ (|
                                      M.call_closure (|
                                        M.get_trait_method (|
                                          "core::ops::try_trait::FromResidual",
                                          Ty.apply
                                            (Ty.path "core::result::Result")
                                            [
                                              Ty.tuple [];
                                              Ty.path "alloc::collections::TryReserveError"
                                            ],
                                          [
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              [
                                                Ty.path "core::convert::Infallible";
                                                Ty.path "alloc::collections::TryReserveErrorKind"
                                              ]
                                          ],
                                          "from_residual",
                                          []
                                        |),
                                        [ M.read (| residual |) ]
                                      |)
                                    |)
                                  |)
                                |)
                              |)));
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 :=
                                M.SubPointer.get_struct_tuple_field (|
                                  γ,
                                  "core::ops::control_flow::ControlFlow::Continue",
                                  0
                                |) in
                              let val := M.copy (| γ0_0 |) in
                              val))
                        ]
                      |)
                    |) in
                  let old_cap :=
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "alloc::collections::vec_deque::VecDeque") [ T; A ],
                          "capacity",
                          []
                        |),
                        [ M.read (| self |) ]
                      |)
                    |) in
                  let _ :=
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  BinOp.Pure.gt (M.read (| new_cap |)) (M.read (| old_cap |))
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            let _ :=
                              M.match_operator (|
                                M.alloc (|
                                  M.call_closure (|
                                    M.get_trait_method (|
                                      "core::ops::try_trait::Try",
                                      Ty.apply
                                        (Ty.path "core::result::Result")
                                        [ Ty.tuple []; Ty.path "alloc::collections::TryReserveError"
                                        ],
                                      [],
                                      "branch",
                                      []
                                    |),
                                    [
                                      M.call_closure (|
                                        M.get_associated_function (|
                                          Ty.apply (Ty.path "alloc::raw_vec::RawVec") [ T; A ],
                                          "try_reserve",
                                          []
                                        |),
                                        [
                                          M.SubPointer.get_struct_record_field (|
                                            M.read (| self |),
                                            "alloc::collections::vec_deque::VecDeque",
                                            "buf"
                                          |);
                                          M.read (|
                                            M.SubPointer.get_struct_record_field (|
                                              M.read (| self |),
                                              "alloc::collections::vec_deque::VecDeque",
                                              "len"
                                            |)
                                          |);
                                          M.read (| additional |)
                                        ]
                                      |)
                                    ]
                                  |)
                                |),
                                [
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let γ0_0 :=
                                        M.SubPointer.get_struct_tuple_field (|
                                          γ,
                                          "core::ops::control_flow::ControlFlow::Break",
                                          0
                                        |) in
                                      let residual := M.copy (| γ0_0 |) in
                                      M.alloc (|
                                        M.never_to_any (|
                                          M.read (|
                                            M.return_ (|
                                              M.call_closure (|
                                                M.get_trait_method (|
                                                  "core::ops::try_trait::FromResidual",
                                                  Ty.apply
                                                    (Ty.path "core::result::Result")
                                                    [
                                                      Ty.tuple [];
                                                      Ty.path "alloc::collections::TryReserveError"
                                                    ],
                                                  [
                                                    Ty.apply
                                                      (Ty.path "core::result::Result")
                                                      [
                                                        Ty.path "core::convert::Infallible";
                                                        Ty.path
                                                          "alloc::collections::TryReserveError"
                                                      ]
                                                  ],
                                                  "from_residual",
                                                  []
                                                |),
                                                [ M.read (| residual |) ]
                                              |)
                                            |)
                                          |)
                                        |)
                                      |)));
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let γ0_0 :=
                                        M.SubPointer.get_struct_tuple_field (|
                                          γ,
                                          "core::ops::control_flow::ControlFlow::Continue",
                                          0
                                        |) in
                                      let val := M.copy (| γ0_0 |) in
                                      val))
                                ]
                              |) in
                            let _ :=
                              M.alloc (|
                                M.call_closure (|
                                  M.get_associated_function (|
                                    Ty.apply
                                      (Ty.path "alloc::collections::vec_deque::VecDeque")
                                      [ T; A ],
                                    "handle_capacity_increase",
                                    []
                                  |),
                                  [ M.read (| self |); M.read (| old_cap |) ]
                                |)
                              |) in
                            M.alloc (| Value.Tuple [] |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                      ]
                    |) in
                  M.alloc (| Value.StructTuple "core::result::Result::Ok" [ Value.Tuple [] ] |)
                |)))
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_try_reserve :
        forall (T A : Ty.t),
        M.IsAssociatedFunction (Self T A) "try_reserve" (try_reserve T A).
      
      (*
          pub fn shrink_to_fit(&mut self) {
              self.shrink_to(0);
          }
      *)
      Definition shrink_to_fit (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              let _ :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply (Ty.path "alloc::collections::vec_deque::VecDeque") [ T; A ],
                      "shrink_to",
                      []
                    |),
                    [ M.read (| self |); Value.Integer 0 ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_shrink_to_fit :
        forall (T A : Ty.t),
        M.IsAssociatedFunction (Self T A) "shrink_to_fit" (shrink_to_fit T A).
      
      (*
          pub fn shrink_to(&mut self, min_capacity: usize) {
              let target_cap = min_capacity.max(self.len);
      
              // never shrink ZSTs
              if T::IS_ZST || self.capacity() <= target_cap {
                  return;
              }
      
              // There are three cases of interest:
              //   All elements are out of desired bounds
              //   Elements are contiguous, and tail is out of desired bounds
              //   Elements are discontiguous
              //
              // At all other times, element positions are unaffected.
      
              // `head` and `len` are at most `isize::MAX` and `target_cap < self.capacity()`, so nothing can
              // overflow.
              let tail_outside = (target_cap + 1..=self.capacity()).contains(&(self.head + self.len));
      
              if self.len == 0 {
                  self.head = 0;
              } else if self.head >= target_cap && tail_outside {
                  // Head and tail are both out of bounds, so copy all of them to the front.
                  //
                  //  H := head
                  //  L := last element
                  //                    H           L
                  //   [. . . . . . . . o o o o o o o . ]
                  //    H           L
                  //   [o o o o o o o . ]
                  unsafe {
                      // nonoverlapping because `self.head >= target_cap >= self.len`.
                      self.copy_nonoverlapping(self.head, 0, self.len);
                  }
                  self.head = 0;
              } else if self.head < target_cap && tail_outside {
                  // Head is in bounds, tail is out of bounds.
                  // Copy the overflowing part to the beginning of the
                  // buffer. This won't overlap because `target_cap >= self.len`.
                  //
                  //  H := head
                  //  L := last element
                  //          H           L
                  //   [. . . o o o o o o o . . . . . . ]
                  //      L   H
                  //   [o o . o o o o o ]
                  let len = self.head + self.len - target_cap;
                  unsafe {
                      self.copy_nonoverlapping(target_cap, 0, len);
                  }
              } else if !self.is_contiguous() {
                  // The head slice is at least partially out of bounds, tail is in bounds.
                  // Copy the head backwards so it lines up with the target capacity.
                  // This won't overlap because `target_cap >= self.len`.
                  //
                  //  H := head
                  //  L := last element
                  //            L                   H
                  //   [o o o o o . . . . . . . . . o o ]
                  //            L   H
                  //   [o o o o o . o o ]
                  let head_len = self.capacity() - self.head;
                  let new_head = target_cap - head_len;
                  unsafe {
                      // can't use `copy_nonoverlapping()` here because the new and old
                      // regions for the head might overlap.
                      self.copy(self.head, new_head, head_len);
                  }
                  self.head = new_head;
              }
              self.buf.shrink_to_fit(target_cap);
      
              debug_assert!(self.head < self.capacity() || self.capacity() == 0);
              debug_assert!(self.len <= self.capacity());
          }
      *)
      Definition shrink_to (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match τ, α with
        | [], [ self; min_capacity ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let min_capacity := M.alloc (| min_capacity |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.read (|
                  let target_cap :=
                    M.alloc (|
                      M.call_closure (|
                        M.get_trait_method (| "core::cmp::Ord", Ty.path "usize", [], "max", [] |),
                        [
                          M.read (| min_capacity |);
                          M.read (|
                            M.SubPointer.get_struct_record_field (|
                              M.read (| self |),
                              "alloc::collections::vec_deque::VecDeque",
                              "len"
                            |)
                          |)
                        ]
                      |)
                    |) in
                  let _ :=
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  LogicalOp.or (|
                                    M.read (|
                                      M.get_constant (| "core::mem::SizedTypeProperties::IS_ZST" |)
                                    |),
                                    ltac:(M.monadic
                                      (BinOp.Pure.le
                                        (M.call_closure (|
                                          M.get_associated_function (|
                                            Ty.apply
                                              (Ty.path "alloc::collections::vec_deque::VecDeque")
                                              [ T; A ],
                                            "capacity",
                                            []
                                          |),
                                          [ M.read (| self |) ]
                                        |))
                                        (M.read (| target_cap |))))
                                  |)
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (|
                              M.never_to_any (| M.read (| M.return_ (| Value.Tuple [] |) |) |)
                            |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                      ]
                    |) in
                  let tail_outside :=
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "core::ops::range::RangeInclusive") [ Ty.path "usize" ],
                          "contains",
                          [ Ty.path "usize" ]
                        |),
                        [
                          M.alloc (|
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "core::ops::range::RangeInclusive")
                                  [ Ty.path "usize" ],
                                "new",
                                []
                              |),
                              [
                                BinOp.Panic.add (|
                                  Integer.Usize,
                                  M.read (| target_cap |),
                                  Value.Integer 1
                                |);
                                M.call_closure (|
                                  M.get_associated_function (|
                                    Ty.apply
                                      (Ty.path "alloc::collections::vec_deque::VecDeque")
                                      [ T; A ],
                                    "capacity",
                                    []
                                  |),
                                  [ M.read (| self |) ]
                                |)
                              ]
                            |)
                          |);
                          M.alloc (|
                            BinOp.Panic.add (|
                              Integer.Usize,
                              M.read (|
                                M.SubPointer.get_struct_record_field (|
                                  M.read (| self |),
                                  "alloc::collections::vec_deque::VecDeque",
                                  "head"
                                |)
                              |),
                              M.read (|
                                M.SubPointer.get_struct_record_field (|
                                  M.read (| self |),
                                  "alloc::collections::vec_deque::VecDeque",
                                  "len"
                                |)
                              |)
                            |)
                          |)
                        ]
                      |)
                    |) in
                  let _ :=
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  BinOp.Pure.eq
                                    (M.read (|
                                      M.SubPointer.get_struct_record_field (|
                                        M.read (| self |),
                                        "alloc::collections::vec_deque::VecDeque",
                                        "len"
                                      |)
                                    |))
                                    (Value.Integer 0)
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            let _ :=
                              M.write (|
                                M.SubPointer.get_struct_record_field (|
                                  M.read (| self |),
                                  "alloc::collections::vec_deque::VecDeque",
                                  "head"
                                |),
                                Value.Integer 0
                              |) in
                            M.alloc (| Value.Tuple [] |)));
                        fun γ =>
                          ltac:(M.monadic
                            (M.match_operator (|
                              M.alloc (| Value.Tuple [] |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let γ :=
                                      M.use
                                        (M.alloc (|
                                          LogicalOp.and (|
                                            BinOp.Pure.ge
                                              (M.read (|
                                                M.SubPointer.get_struct_record_field (|
                                                  M.read (| self |),
                                                  "alloc::collections::vec_deque::VecDeque",
                                                  "head"
                                                |)
                                              |))
                                              (M.read (| target_cap |)),
                                            ltac:(M.monadic (M.read (| tail_outside |)))
                                          |)
                                        |)) in
                                    let _ :=
                                      M.is_constant_or_break_match (|
                                        M.read (| γ |),
                                        Value.Bool true
                                      |) in
                                    let _ :=
                                      let _ :=
                                        M.alloc (|
                                          M.call_closure (|
                                            M.get_associated_function (|
                                              Ty.apply
                                                (Ty.path "alloc::collections::vec_deque::VecDeque")
                                                [ T; A ],
                                              "copy_nonoverlapping",
                                              []
                                            |),
                                            [
                                              M.read (| self |);
                                              M.read (|
                                                M.SubPointer.get_struct_record_field (|
                                                  M.read (| self |),
                                                  "alloc::collections::vec_deque::VecDeque",
                                                  "head"
                                                |)
                                              |);
                                              Value.Integer 0;
                                              M.read (|
                                                M.SubPointer.get_struct_record_field (|
                                                  M.read (| self |),
                                                  "alloc::collections::vec_deque::VecDeque",
                                                  "len"
                                                |)
                                              |)
                                            ]
                                          |)
                                        |) in
                                      M.alloc (| Value.Tuple [] |) in
                                    let _ :=
                                      M.write (|
                                        M.SubPointer.get_struct_record_field (|
                                          M.read (| self |),
                                          "alloc::collections::vec_deque::VecDeque",
                                          "head"
                                        |),
                                        Value.Integer 0
                                      |) in
                                    M.alloc (| Value.Tuple [] |)));
                                fun γ =>
                                  ltac:(M.monadic
                                    (M.match_operator (|
                                      M.alloc (| Value.Tuple [] |),
                                      [
                                        fun γ =>
                                          ltac:(M.monadic
                                            (let γ :=
                                              M.use
                                                (M.alloc (|
                                                  LogicalOp.and (|
                                                    BinOp.Pure.lt
                                                      (M.read (|
                                                        M.SubPointer.get_struct_record_field (|
                                                          M.read (| self |),
                                                          "alloc::collections::vec_deque::VecDeque",
                                                          "head"
                                                        |)
                                                      |))
                                                      (M.read (| target_cap |)),
                                                    ltac:(M.monadic (M.read (| tail_outside |)))
                                                  |)
                                                |)) in
                                            let _ :=
                                              M.is_constant_or_break_match (|
                                                M.read (| γ |),
                                                Value.Bool true
                                              |) in
                                            let len :=
                                              M.alloc (|
                                                BinOp.Panic.sub (|
                                                  Integer.Usize,
                                                  BinOp.Panic.add (|
                                                    Integer.Usize,
                                                    M.read (|
                                                      M.SubPointer.get_struct_record_field (|
                                                        M.read (| self |),
                                                        "alloc::collections::vec_deque::VecDeque",
                                                        "head"
                                                      |)
                                                    |),
                                                    M.read (|
                                                      M.SubPointer.get_struct_record_field (|
                                                        M.read (| self |),
                                                        "alloc::collections::vec_deque::VecDeque",
                                                        "len"
                                                      |)
                                                    |)
                                                  |),
                                                  M.read (| target_cap |)
                                                |)
                                              |) in
                                            let _ :=
                                              M.alloc (|
                                                M.call_closure (|
                                                  M.get_associated_function (|
                                                    Ty.apply
                                                      (Ty.path
                                                        "alloc::collections::vec_deque::VecDeque")
                                                      [ T; A ],
                                                    "copy_nonoverlapping",
                                                    []
                                                  |),
                                                  [
                                                    M.read (| self |);
                                                    M.read (| target_cap |);
                                                    Value.Integer 0;
                                                    M.read (| len |)
                                                  ]
                                                |)
                                              |) in
                                            M.alloc (| Value.Tuple [] |)));
                                        fun γ =>
                                          ltac:(M.monadic
                                            (M.match_operator (|
                                              M.alloc (| Value.Tuple [] |),
                                              [
                                                fun γ =>
                                                  ltac:(M.monadic
                                                    (let γ :=
                                                      M.use
                                                        (M.alloc (|
                                                          UnOp.Pure.not
                                                            (M.call_closure (|
                                                              M.get_associated_function (|
                                                                Ty.apply
                                                                  (Ty.path
                                                                    "alloc::collections::vec_deque::VecDeque")
                                                                  [ T; A ],
                                                                "is_contiguous",
                                                                []
                                                              |),
                                                              [ M.read (| self |) ]
                                                            |))
                                                        |)) in
                                                    let _ :=
                                                      M.is_constant_or_break_match (|
                                                        M.read (| γ |),
                                                        Value.Bool true
                                                      |) in
                                                    let head_len :=
                                                      M.alloc (|
                                                        BinOp.Panic.sub (|
                                                          Integer.Usize,
                                                          M.call_closure (|
                                                            M.get_associated_function (|
                                                              Ty.apply
                                                                (Ty.path
                                                                  "alloc::collections::vec_deque::VecDeque")
                                                                [ T; A ],
                                                              "capacity",
                                                              []
                                                            |),
                                                            [ M.read (| self |) ]
                                                          |),
                                                          M.read (|
                                                            M.SubPointer.get_struct_record_field (|
                                                              M.read (| self |),
                                                              "alloc::collections::vec_deque::VecDeque",
                                                              "head"
                                                            |)
                                                          |)
                                                        |)
                                                      |) in
                                                    let new_head :=
                                                      M.alloc (|
                                                        BinOp.Panic.sub (|
                                                          Integer.Usize,
                                                          M.read (| target_cap |),
                                                          M.read (| head_len |)
                                                        |)
                                                      |) in
                                                    let _ :=
                                                      let _ :=
                                                        M.alloc (|
                                                          M.call_closure (|
                                                            M.get_associated_function (|
                                                              Ty.apply
                                                                (Ty.path
                                                                  "alloc::collections::vec_deque::VecDeque")
                                                                [ T; A ],
                                                              "copy",
                                                              []
                                                            |),
                                                            [
                                                              M.read (| self |);
                                                              M.read (|
                                                                M.SubPointer.get_struct_record_field (|
                                                                  M.read (| self |),
                                                                  "alloc::collections::vec_deque::VecDeque",
                                                                  "head"
                                                                |)
                                                              |);
                                                              M.read (| new_head |);
                                                              M.read (| head_len |)
                                                            ]
                                                          |)
                                                        |) in
                                                      M.alloc (| Value.Tuple [] |) in
                                                    let _ :=
                                                      M.write (|
                                                        M.SubPointer.get_struct_record_field (|
                                                          M.read (| self |),
                                                          "alloc::collections::vec_deque::VecDeque",
                                                          "head"
                                                        |),
                                                        M.read (| new_head |)
                                                      |) in
                                                    M.alloc (| Value.Tuple [] |)));
                                                fun γ =>
                                                  ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                                              ]
                                            |)))
                                      ]
                                    |)))
                              ]
                            |)))
                      ]
                    |) in
                  let _ :=
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "alloc::raw_vec::RawVec") [ T; A ],
                          "shrink_to_fit",
                          []
                        |),
                        [
                          M.SubPointer.get_struct_record_field (|
                            M.read (| self |),
                            "alloc::collections::vec_deque::VecDeque",
                            "buf"
                          |);
                          M.read (| target_cap |)
                        ]
                      |)
                    |) in
                  let _ :=
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ := M.use (M.alloc (| Value.Bool true |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            let _ :=
                              M.match_operator (|
                                M.alloc (| Value.Tuple [] |),
                                [
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let γ :=
                                        M.use
                                          (M.alloc (|
                                            UnOp.Pure.not
                                              (LogicalOp.or (|
                                                BinOp.Pure.lt
                                                  (M.read (|
                                                    M.SubPointer.get_struct_record_field (|
                                                      M.read (| self |),
                                                      "alloc::collections::vec_deque::VecDeque",
                                                      "head"
                                                    |)
                                                  |))
                                                  (M.call_closure (|
                                                    M.get_associated_function (|
                                                      Ty.apply
                                                        (Ty.path
                                                          "alloc::collections::vec_deque::VecDeque")
                                                        [ T; A ],
                                                      "capacity",
                                                      []
                                                    |),
                                                    [ M.read (| self |) ]
                                                  |)),
                                                ltac:(M.monadic
                                                  (BinOp.Pure.eq
                                                    (M.call_closure (|
                                                      M.get_associated_function (|
                                                        Ty.apply
                                                          (Ty.path
                                                            "alloc::collections::vec_deque::VecDeque")
                                                          [ T; A ],
                                                        "capacity",
                                                        []
                                                      |),
                                                      [ M.read (| self |) ]
                                                    |))
                                                    (Value.Integer 0)))
                                              |))
                                          |)) in
                                      let _ :=
                                        M.is_constant_or_break_match (|
                                          M.read (| γ |),
                                          Value.Bool true
                                        |) in
                                      M.alloc (|
                                        M.never_to_any (|
                                          M.call_closure (|
                                            M.get_function (| "core::panicking::panic", [] |),
                                            [
                                              M.read (|
                                                Value.String
                                                  "assertion failed: self.head < self.capacity() || self.capacity() == 0"
                                              |)
                                            ]
                                          |)
                                        |)
                                      |)));
                                  fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                                ]
                              |) in
                            M.alloc (| Value.Tuple [] |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                      ]
                    |) in
                  let _ :=
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ := M.use (M.alloc (| Value.Bool true |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            let _ :=
                              M.match_operator (|
                                M.alloc (| Value.Tuple [] |),
                                [
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let γ :=
                                        M.use
                                          (M.alloc (|
                                            UnOp.Pure.not
                                              (BinOp.Pure.le
                                                (M.read (|
                                                  M.SubPointer.get_struct_record_field (|
                                                    M.read (| self |),
                                                    "alloc::collections::vec_deque::VecDeque",
                                                    "len"
                                                  |)
                                                |))
                                                (M.call_closure (|
                                                  M.get_associated_function (|
                                                    Ty.apply
                                                      (Ty.path
                                                        "alloc::collections::vec_deque::VecDeque")
                                                      [ T; A ],
                                                    "capacity",
                                                    []
                                                  |),
                                                  [ M.read (| self |) ]
                                                |)))
                                          |)) in
                                      let _ :=
                                        M.is_constant_or_break_match (|
                                          M.read (| γ |),
                                          Value.Bool true
                                        |) in
                                      M.alloc (|
                                        M.never_to_any (|
                                          M.call_closure (|
                                            M.get_function (| "core::panicking::panic", [] |),
                                            [
                                              M.read (|
                                                Value.String
                                                  "assertion failed: self.len <= self.capacity()"
                                              |)
                                            ]
                                          |)
                                        |)
                                      |)));
                                  fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                                ]
                              |) in
                            M.alloc (| Value.Tuple [] |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                      ]
                    |) in
                  M.alloc (| Value.Tuple [] |)
                |)))
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_shrink_to :
        forall (T A : Ty.t),
        M.IsAssociatedFunction (Self T A) "shrink_to" (shrink_to T A).
      
      (*
          pub fn truncate(&mut self, len: usize) {
              /// Runs the destructor for all items in the slice when it gets dropped (normally or
              /// during unwinding).
              struct Dropper<'a, T>(&'a mut [T]);
      
              impl<'a, T> Drop for Dropper<'a, T> {
                  fn drop(&mut self) {
                      unsafe {
                          ptr::drop_in_place(self.0);
                      }
                  }
              }
      
              // Safe because:
              //
              // * Any slice passed to `drop_in_place` is valid; the second case has
              //   `len <= front.len()` and returning on `len > self.len()` ensures
              //   `begin <= back.len()` in the first case
              // * The head of the VecDeque is moved before calling `drop_in_place`,
              //   so no value is dropped twice if `drop_in_place` panics
              unsafe {
                  if len >= self.len {
                      return;
                  }
      
                  let (front, back) = self.as_mut_slices();
                  if len > front.len() {
                      let begin = len - front.len();
                      let drop_back = back.get_unchecked_mut(begin..) as *mut _;
                      self.len = len;
                      ptr::drop_in_place(drop_back);
                  } else {
                      let drop_back = back as *mut _;
                      let drop_front = front.get_unchecked_mut(len..) as *mut _;
                      self.len = len;
      
                      // Make sure the second half is dropped even when a destructor
                      // in the first one panics.
                      let _back_dropper = Dropper(&mut *drop_back);
                      ptr::drop_in_place(drop_front);
                  }
              }
          }
      *)
      Definition truncate (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match τ, α with
        | [], [ self; len ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let len := M.alloc (| len |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.read (|
                  let _ :=
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  BinOp.Pure.ge
                                    (M.read (| len |))
                                    (M.read (|
                                      M.SubPointer.get_struct_record_field (|
                                        M.read (| self |),
                                        "alloc::collections::vec_deque::VecDeque",
                                        "len"
                                      |)
                                    |))
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (|
                              M.never_to_any (| M.read (| M.return_ (| Value.Tuple [] |) |) |)
                            |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                      ]
                    |) in
                  M.match_operator (|
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "alloc::collections::vec_deque::VecDeque") [ T; A ],
                          "as_mut_slices",
                          []
                        |),
                        [ M.read (| self |) ]
                      |)
                    |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                          let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                          let front := M.copy (| γ0_0 |) in
                          let back := M.copy (| γ0_1 |) in
                          M.match_operator (|
                            M.alloc (| Value.Tuple [] |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ :=
                                    M.use
                                      (M.alloc (|
                                        BinOp.Pure.gt
                                          (M.read (| len |))
                                          (M.call_closure (|
                                            M.get_associated_function (|
                                              Ty.apply (Ty.path "slice") [ T ],
                                              "len",
                                              []
                                            |),
                                            [ M.read (| front |) ]
                                          |))
                                      |)) in
                                  let _ :=
                                    M.is_constant_or_break_match (|
                                      M.read (| γ |),
                                      Value.Bool true
                                    |) in
                                  let begin :=
                                    M.alloc (|
                                      BinOp.Panic.sub (|
                                        Integer.Usize,
                                        M.read (| len |),
                                        M.call_closure (|
                                          M.get_associated_function (|
                                            Ty.apply (Ty.path "slice") [ T ],
                                            "len",
                                            []
                                          |),
                                          [ M.read (| front |) ]
                                        |)
                                      |)
                                    |) in
                                  let drop_back :=
                                    M.copy (|
                                      M.use
                                        (M.alloc (|
                                          M.call_closure (|
                                            M.get_associated_function (|
                                              Ty.apply (Ty.path "slice") [ T ],
                                              "get_unchecked_mut",
                                              [
                                                Ty.apply
                                                  (Ty.path "core::ops::range::RangeFrom")
                                                  [ Ty.path "usize" ]
                                              ]
                                            |),
                                            [
                                              M.read (| back |);
                                              Value.StructRecord
                                                "core::ops::range::RangeFrom"
                                                [ ("start", M.read (| begin |)) ]
                                            ]
                                          |)
                                        |))
                                    |) in
                                  let _ :=
                                    M.write (|
                                      M.SubPointer.get_struct_record_field (|
                                        M.read (| self |),
                                        "alloc::collections::vec_deque::VecDeque",
                                        "len"
                                      |),
                                      M.read (| len |)
                                    |) in
                                  let _ :=
                                    M.alloc (|
                                      M.call_closure (|
                                        M.get_function (|
                                          "core::ptr::drop_in_place",
                                          [ Ty.apply (Ty.path "slice") [ T ] ]
                                        |),
                                        [ M.read (| drop_back |) ]
                                      |)
                                    |) in
                                  M.alloc (| Value.Tuple [] |)));
                              fun γ =>
                                ltac:(M.monadic
                                  (let drop_back :=
                                    M.copy (| M.use (M.alloc (| M.read (| back |) |)) |) in
                                  let drop_front :=
                                    M.copy (|
                                      M.use
                                        (M.alloc (|
                                          M.call_closure (|
                                            M.get_associated_function (|
                                              Ty.apply (Ty.path "slice") [ T ],
                                              "get_unchecked_mut",
                                              [
                                                Ty.apply
                                                  (Ty.path "core::ops::range::RangeFrom")
                                                  [ Ty.path "usize" ]
                                              ]
                                            |),
                                            [
                                              M.read (| front |);
                                              Value.StructRecord
                                                "core::ops::range::RangeFrom"
                                                [ ("start", M.read (| len |)) ]
                                            ]
                                          |)
                                        |))
                                    |) in
                                  let _ :=
                                    M.write (|
                                      M.SubPointer.get_struct_record_field (|
                                        M.read (| self |),
                                        "alloc::collections::vec_deque::VecDeque",
                                        "len"
                                      |),
                                      M.read (| len |)
                                    |) in
                                  let _back_dropper :=
                                    M.alloc (|
                                      Value.StructTuple
                                        "alloc::collections::vec_deque::truncate::Dropper"
                                        [ M.read (| drop_back |) ]
                                    |) in
                                  let _ :=
                                    M.alloc (|
                                      M.call_closure (|
                                        M.get_function (|
                                          "core::ptr::drop_in_place",
                                          [ Ty.apply (Ty.path "slice") [ T ] ]
                                        |),
                                        [ M.read (| drop_front |) ]
                                      |)
                                    |) in
                                  M.alloc (| Value.Tuple [] |)))
                            ]
                          |)))
                    ]
                  |)
                |)))
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_truncate :
        forall (T A : Ty.t),
        M.IsAssociatedFunction (Self T A) "truncate" (truncate T A).
      
      (*
          pub fn allocator(&self) -> &A {
              self.buf.allocator()
          }
      *)
      Definition allocator (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply (Ty.path "alloc::raw_vec::RawVec") [ T; A ],
                "allocator",
                []
              |),
              [
                M.SubPointer.get_struct_record_field (|
                  M.read (| self |),
                  "alloc::collections::vec_deque::VecDeque",
                  "buf"
                |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_allocator :
        forall (T A : Ty.t),
        M.IsAssociatedFunction (Self T A) "allocator" (allocator T A).
      
      (*
          pub fn iter(&self) -> Iter<'_, T> {
              let (a, b) = self.as_slices();
              Iter::new(a.iter(), b.iter())
          }
      *)
      Definition iter (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply (Ty.path "alloc::collections::vec_deque::VecDeque") [ T; A ],
                      "as_slices",
                      []
                    |),
                    [ M.read (| self |) ]
                  |)
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      let a := M.copy (| γ0_0 |) in
                      let b := M.copy (| γ0_1 |) in
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.apply (Ty.path "alloc::collections::vec_deque::iter::Iter") [ T ],
                            "new",
                            []
                          |),
                          [
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply (Ty.path "slice") [ T ],
                                "iter",
                                []
                              |),
                              [ M.read (| a |) ]
                            |);
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply (Ty.path "slice") [ T ],
                                "iter",
                                []
                              |),
                              [ M.read (| b |) ]
                            |)
                          ]
                        |)
                      |)))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_iter :
        forall (T A : Ty.t),
        M.IsAssociatedFunction (Self T A) "iter" (iter T A).
      
      (*
          pub fn iter_mut(&mut self) -> IterMut<'_, T> {
              let (a, b) = self.as_mut_slices();
              IterMut::new(a.iter_mut(), b.iter_mut())
          }
      *)
      Definition iter_mut (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply (Ty.path "alloc::collections::vec_deque::VecDeque") [ T; A ],
                      "as_mut_slices",
                      []
                    |),
                    [ M.read (| self |) ]
                  |)
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      let a := M.copy (| γ0_0 |) in
                      let b := M.copy (| γ0_1 |) in
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.apply
                              (Ty.path "alloc::collections::vec_deque::iter_mut::IterMut")
                              [ T ],
                            "new",
                            []
                          |),
                          [
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply (Ty.path "slice") [ T ],
                                "iter_mut",
                                []
                              |),
                              [ M.read (| a |) ]
                            |);
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply (Ty.path "slice") [ T ],
                                "iter_mut",
                                []
                              |),
                              [ M.read (| b |) ]
                            |)
                          ]
                        |)
                      |)))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_iter_mut :
        forall (T A : Ty.t),
        M.IsAssociatedFunction (Self T A) "iter_mut" (iter_mut T A).
      
      (*
          pub fn as_slices(&self) -> (&[T], &[T]) {
              let (a_range, b_range) = self.slice_ranges(.., self.len);
              // SAFETY: `slice_ranges` always returns valid ranges into
              // the physical buffer.
              unsafe { (&*self.buffer_range(a_range), &*self.buffer_range(b_range)) }
          }
      *)
      Definition as_slices (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply (Ty.path "alloc::collections::vec_deque::VecDeque") [ T; A ],
                      "slice_ranges",
                      [ Ty.path "core::ops::range::RangeFull" ]
                    |),
                    [
                      M.read (| self |);
                      Value.StructTuple "core::ops::range::RangeFull" [];
                      M.read (|
                        M.SubPointer.get_struct_record_field (|
                          M.read (| self |),
                          "alloc::collections::vec_deque::VecDeque",
                          "len"
                        |)
                      |)
                    ]
                  |)
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      let a_range := M.copy (| γ0_0 |) in
                      let b_range := M.copy (| γ0_1 |) in
                      M.alloc (|
                        Value.Tuple
                          [
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "alloc::collections::vec_deque::VecDeque")
                                  [ T; A ],
                                "buffer_range",
                                []
                              |),
                              [ M.read (| self |); M.read (| a_range |) ]
                            |);
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "alloc::collections::vec_deque::VecDeque")
                                  [ T; A ],
                                "buffer_range",
                                []
                              |),
                              [ M.read (| self |); M.read (| b_range |) ]
                            |)
                          ]
                      |)))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_as_slices :
        forall (T A : Ty.t),
        M.IsAssociatedFunction (Self T A) "as_slices" (as_slices T A).
      
      (*
          pub fn as_mut_slices(&mut self) -> (&mut [T], &mut [T]) {
              let (a_range, b_range) = self.slice_ranges(.., self.len);
              // SAFETY: `slice_ranges` always returns valid ranges into
              // the physical buffer.
              unsafe { (&mut *self.buffer_range(a_range), &mut *self.buffer_range(b_range)) }
          }
      *)
      Definition as_mut_slices (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply (Ty.path "alloc::collections::vec_deque::VecDeque") [ T; A ],
                      "slice_ranges",
                      [ Ty.path "core::ops::range::RangeFull" ]
                    |),
                    [
                      M.read (| self |);
                      Value.StructTuple "core::ops::range::RangeFull" [];
                      M.read (|
                        M.SubPointer.get_struct_record_field (|
                          M.read (| self |),
                          "alloc::collections::vec_deque::VecDeque",
                          "len"
                        |)
                      |)
                    ]
                  |)
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      let a_range := M.copy (| γ0_0 |) in
                      let b_range := M.copy (| γ0_1 |) in
                      M.alloc (|
                        Value.Tuple
                          [
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "alloc::collections::vec_deque::VecDeque")
                                  [ T; A ],
                                "buffer_range",
                                []
                              |),
                              [ M.read (| self |); M.read (| a_range |) ]
                            |);
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "alloc::collections::vec_deque::VecDeque")
                                  [ T; A ],
                                "buffer_range",
                                []
                              |),
                              [ M.read (| self |); M.read (| b_range |) ]
                            |)
                          ]
                      |)))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_as_mut_slices :
        forall (T A : Ty.t),
        M.IsAssociatedFunction (Self T A) "as_mut_slices" (as_mut_slices T A).
      
      (*
          pub fn len(&self) -> usize {
              self.len
          }
      *)
      Definition len (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.SubPointer.get_struct_record_field (|
                M.read (| self |),
                "alloc::collections::vec_deque::VecDeque",
                "len"
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_len :
        forall (T A : Ty.t),
        M.IsAssociatedFunction (Self T A) "len" (len T A).
      
      (*
          pub fn is_empty(&self) -> bool {
              self.len == 0
          }
      *)
      Definition is_empty (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            BinOp.Pure.eq
              (M.read (|
                M.SubPointer.get_struct_record_field (|
                  M.read (| self |),
                  "alloc::collections::vec_deque::VecDeque",
                  "len"
                |)
              |))
              (Value.Integer 0)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_is_empty :
        forall (T A : Ty.t),
        M.IsAssociatedFunction (Self T A) "is_empty" (is_empty T A).
      
      (*
          fn slice_ranges<R>(&self, range: R, len: usize) -> (Range<usize>, Range<usize>)
          where
              R: RangeBounds<usize>,
          {
              let Range { start, end } = slice::range(range, ..len);
              let len = end - start;
      
              if len == 0 {
                  (0..0, 0..0)
              } else {
                  // `slice::range` guarantees that `start <= end <= len`.
                  // because `len != 0`, we know that `start < end`, so `start < len`
                  // and the indexing is valid.
                  let wrapped_start = self.to_physical_idx(start);
      
                  // this subtraction can never overflow because `wrapped_start` is
                  // at most `self.capacity()` (and if `self.capacity != 0`, then `wrapped_start` is strictly less
                  // than `self.capacity`).
                  let head_len = self.capacity() - wrapped_start;
      
                  if head_len >= len {
                      // we know that `len + wrapped_start <= self.capacity <= usize::MAX`, so this addition can't overflow
                      (wrapped_start..wrapped_start + len, 0..0)
                  } else {
                      // can't overflow because of the if condition
                      let tail_len = len - head_len;
                      (wrapped_start..self.capacity(), 0..tail_len)
                  }
              }
          }
      *)
      Definition slice_ranges (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match τ, α with
        | [ R ], [ self; range; len ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let range := M.alloc (| range |) in
            let len := M.alloc (| len |) in
            M.read (|
              M.match_operator (|
                M.alloc (|
                  M.call_closure (|
                    M.get_function (| "core::slice::index::range", [ R ] |),
                    [
                      M.read (| range |);
                      Value.StructRecord "core::ops::range::RangeTo" [ ("end_", M.read (| len |)) ]
                    ]
                  |)
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 :=
                        M.SubPointer.get_struct_record_field (|
                          γ,
                          "core::ops::range::Range",
                          "start"
                        |) in
                      let γ0_1 :=
                        M.SubPointer.get_struct_record_field (|
                          γ,
                          "core::ops::range::Range",
                          "end"
                        |) in
                      let start := M.copy (| γ0_0 |) in
                      let end_ := M.copy (| γ0_1 |) in
                      let len :=
                        M.alloc (|
                          BinOp.Panic.sub (| Integer.Usize, M.read (| end_ |), M.read (| start |) |)
                        |) in
                      M.match_operator (|
                        M.alloc (| Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.use
                                  (M.alloc (|
                                    BinOp.Pure.eq (M.read (| len |)) (Value.Integer 0)
                                  |)) in
                              let _ :=
                                M.is_constant_or_break_match (|
                                  M.read (| γ |),
                                  Value.Bool true
                                |) in
                              M.alloc (|
                                Value.Tuple
                                  [
                                    Value.StructRecord
                                      "core::ops::range::Range"
                                      [ ("start", Value.Integer 0); ("end_", Value.Integer 0) ];
                                    Value.StructRecord
                                      "core::ops::range::Range"
                                      [ ("start", Value.Integer 0); ("end_", Value.Integer 0) ]
                                  ]
                              |)));
                          fun γ =>
                            ltac:(M.monadic
                              (let wrapped_start :=
                                M.alloc (|
                                  M.call_closure (|
                                    M.get_associated_function (|
                                      Ty.apply
                                        (Ty.path "alloc::collections::vec_deque::VecDeque")
                                        [ T; A ],
                                      "to_physical_idx",
                                      []
                                    |),
                                    [ M.read (| self |); M.read (| start |) ]
                                  |)
                                |) in
                              let head_len :=
                                M.alloc (|
                                  BinOp.Panic.sub (|
                                    Integer.Usize,
                                    M.call_closure (|
                                      M.get_associated_function (|
                                        Ty.apply
                                          (Ty.path "alloc::collections::vec_deque::VecDeque")
                                          [ T; A ],
                                        "capacity",
                                        []
                                      |),
                                      [ M.read (| self |) ]
                                    |),
                                    M.read (| wrapped_start |)
                                  |)
                                |) in
                              M.match_operator (|
                                M.alloc (| Value.Tuple [] |),
                                [
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let γ :=
                                        M.use
                                          (M.alloc (|
                                            BinOp.Pure.ge (M.read (| head_len |)) (M.read (| len |))
                                          |)) in
                                      let _ :=
                                        M.is_constant_or_break_match (|
                                          M.read (| γ |),
                                          Value.Bool true
                                        |) in
                                      M.alloc (|
                                        Value.Tuple
                                          [
                                            Value.StructRecord
                                              "core::ops::range::Range"
                                              [
                                                ("start", M.read (| wrapped_start |));
                                                ("end_",
                                                  BinOp.Panic.add (|
                                                    Integer.Usize,
                                                    M.read (| wrapped_start |),
                                                    M.read (| len |)
                                                  |))
                                              ];
                                            Value.StructRecord
                                              "core::ops::range::Range"
                                              [
                                                ("start", Value.Integer 0);
                                                ("end_", Value.Integer 0)
                                              ]
                                          ]
                                      |)));
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let tail_len :=
                                        M.alloc (|
                                          BinOp.Panic.sub (|
                                            Integer.Usize,
                                            M.read (| len |),
                                            M.read (| head_len |)
                                          |)
                                        |) in
                                      M.alloc (|
                                        Value.Tuple
                                          [
                                            Value.StructRecord
                                              "core::ops::range::Range"
                                              [
                                                ("start", M.read (| wrapped_start |));
                                                ("end_",
                                                  M.call_closure (|
                                                    M.get_associated_function (|
                                                      Ty.apply
                                                        (Ty.path
                                                          "alloc::collections::vec_deque::VecDeque")
                                                        [ T; A ],
                                                      "capacity",
                                                      []
                                                    |),
                                                    [ M.read (| self |) ]
                                                  |))
                                              ];
                                            Value.StructRecord
                                              "core::ops::range::Range"
                                              [
                                                ("start", Value.Integer 0);
                                                ("end_", M.read (| tail_len |))
                                              ]
                                          ]
                                      |)))
                                ]
                              |)))
                        ]
                      |)))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_slice_ranges :
        forall (T A : Ty.t),
        M.IsAssociatedFunction (Self T A) "slice_ranges" (slice_ranges T A).
      
      (*
          pub fn range<R>(&self, range: R) -> Iter<'_, T>
          where
              R: RangeBounds<usize>,
          {
              let (a_range, b_range) = self.slice_ranges(range, self.len);
              // SAFETY: The ranges returned by `slice_ranges`
              // are valid ranges into the physical buffer, so
              // it's ok to pass them to `buffer_range` and
              // dereference the result.
              let a = unsafe { &*self.buffer_range(a_range) };
              let b = unsafe { &*self.buffer_range(b_range) };
              Iter::new(a.iter(), b.iter())
          }
      *)
      Definition range (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match τ, α with
        | [ R ], [ self; range ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let range := M.alloc (| range |) in
            M.read (|
              M.match_operator (|
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply (Ty.path "alloc::collections::vec_deque::VecDeque") [ T; A ],
                      "slice_ranges",
                      [ R ]
                    |),
                    [
                      M.read (| self |);
                      M.read (| range |);
                      M.read (|
                        M.SubPointer.get_struct_record_field (|
                          M.read (| self |),
                          "alloc::collections::vec_deque::VecDeque",
                          "len"
                        |)
                      |)
                    ]
                  |)
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      let a_range := M.copy (| γ0_0 |) in
                      let b_range := M.copy (| γ0_1 |) in
                      let a :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply (Ty.path "alloc::collections::vec_deque::VecDeque") [ T; A ],
                              "buffer_range",
                              []
                            |),
                            [ M.read (| self |); M.read (| a_range |) ]
                          |)
                        |) in
                      let b :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply (Ty.path "alloc::collections::vec_deque::VecDeque") [ T; A ],
                              "buffer_range",
                              []
                            |),
                            [ M.read (| self |); M.read (| b_range |) ]
                          |)
                        |) in
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.apply (Ty.path "alloc::collections::vec_deque::iter::Iter") [ T ],
                            "new",
                            []
                          |),
                          [
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply (Ty.path "slice") [ T ],
                                "iter",
                                []
                              |),
                              [ M.read (| a |) ]
                            |);
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply (Ty.path "slice") [ T ],
                                "iter",
                                []
                              |),
                              [ M.read (| b |) ]
                            |)
                          ]
                        |)
                      |)))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_range :
        forall (T A : Ty.t),
        M.IsAssociatedFunction (Self T A) "range" (range T A).
      
      (*
          pub fn range_mut<R>(&mut self, range: R) -> IterMut<'_, T>
          where
              R: RangeBounds<usize>,
          {
              let (a_range, b_range) = self.slice_ranges(range, self.len);
              // SAFETY: The ranges returned by `slice_ranges`
              // are valid ranges into the physical buffer, so
              // it's ok to pass them to `buffer_range` and
              // dereference the result.
              let a = unsafe { &mut *self.buffer_range(a_range) };
              let b = unsafe { &mut *self.buffer_range(b_range) };
              IterMut::new(a.iter_mut(), b.iter_mut())
          }
      *)
      Definition range_mut (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match τ, α with
        | [ R ], [ self; range ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let range := M.alloc (| range |) in
            M.read (|
              M.match_operator (|
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply (Ty.path "alloc::collections::vec_deque::VecDeque") [ T; A ],
                      "slice_ranges",
                      [ R ]
                    |),
                    [
                      M.read (| self |);
                      M.read (| range |);
                      M.read (|
                        M.SubPointer.get_struct_record_field (|
                          M.read (| self |),
                          "alloc::collections::vec_deque::VecDeque",
                          "len"
                        |)
                      |)
                    ]
                  |)
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      let a_range := M.copy (| γ0_0 |) in
                      let b_range := M.copy (| γ0_1 |) in
                      let a :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply (Ty.path "alloc::collections::vec_deque::VecDeque") [ T; A ],
                              "buffer_range",
                              []
                            |),
                            [ M.read (| self |); M.read (| a_range |) ]
                          |)
                        |) in
                      let b :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply (Ty.path "alloc::collections::vec_deque::VecDeque") [ T; A ],
                              "buffer_range",
                              []
                            |),
                            [ M.read (| self |); M.read (| b_range |) ]
                          |)
                        |) in
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.apply
                              (Ty.path "alloc::collections::vec_deque::iter_mut::IterMut")
                              [ T ],
                            "new",
                            []
                          |),
                          [
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply (Ty.path "slice") [ T ],
                                "iter_mut",
                                []
                              |),
                              [ M.read (| a |) ]
                            |);
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply (Ty.path "slice") [ T ],
                                "iter_mut",
                                []
                              |),
                              [ M.read (| b |) ]
                            |)
                          ]
                        |)
                      |)))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_range_mut :
        forall (T A : Ty.t),
        M.IsAssociatedFunction (Self T A) "range_mut" (range_mut T A).
      
      (*
          pub fn drain<R>(&mut self, range: R) -> Drain<'_, T, A>
          where
              R: RangeBounds<usize>,
          {
              // Memory safety
              //
              // When the Drain is first created, the source deque is shortened to
              // make sure no uninitialized or moved-from elements are accessible at
              // all if the Drain's destructor never gets to run.
              //
              // Drain will ptr::read out the values to remove.
              // When finished, the remaining data will be copied back to cover the hole,
              // and the head/tail values will be restored correctly.
              //
              let Range { start, end } = slice::range(range, ..self.len);
              let drain_start = start;
              let drain_len = end - start;
      
              // The deque's elements are parted into three segments:
              // * 0  -> drain_start
              // * drain_start -> drain_start+drain_len
              // * drain_start+drain_len -> self.len
              //
              // H = self.head; T = self.head+self.len; t = drain_start+drain_len; h = drain_head
              //
              // We store drain_start as self.len, and drain_len and self.len as
              // drain_len and orig_len respectively on the Drain. This also
              // truncates the effective array such that if the Drain is leaked, we
              // have forgotten about the potentially moved values after the start of
              // the drain.
              //
              //        H   h   t   T
              // [. . . o o x x o o . . .]
              //
              // "forget" about the values after the start of the drain until after
              // the drain is complete and the Drain destructor is run.
      
              unsafe { Drain::new(self, drain_start, drain_len) }
          }
      *)
      Definition drain (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match τ, α with
        | [ R ], [ self; range ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let range := M.alloc (| range |) in
            M.read (|
              M.match_operator (|
                M.alloc (|
                  M.call_closure (|
                    M.get_function (| "core::slice::index::range", [ R ] |),
                    [
                      M.read (| range |);
                      Value.StructRecord
                        "core::ops::range::RangeTo"
                        [
                          ("end_",
                            M.read (|
                              M.SubPointer.get_struct_record_field (|
                                M.read (| self |),
                                "alloc::collections::vec_deque::VecDeque",
                                "len"
                              |)
                            |))
                        ]
                    ]
                  |)
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 :=
                        M.SubPointer.get_struct_record_field (|
                          γ,
                          "core::ops::range::Range",
                          "start"
                        |) in
                      let γ0_1 :=
                        M.SubPointer.get_struct_record_field (|
                          γ,
                          "core::ops::range::Range",
                          "end"
                        |) in
                      let start := M.copy (| γ0_0 |) in
                      let end_ := M.copy (| γ0_1 |) in
                      let drain_start := M.copy (| start |) in
                      let drain_len :=
                        M.alloc (|
                          BinOp.Panic.sub (| Integer.Usize, M.read (| end_ |), M.read (| start |) |)
                        |) in
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.apply
                              (Ty.path "alloc::collections::vec_deque::drain::Drain")
                              [ T; A ],
                            "new",
                            []
                          |),
                          [ M.read (| self |); M.read (| drain_start |); M.read (| drain_len |) ]
                        |)
                      |)))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_drain :
        forall (T A : Ty.t),
        M.IsAssociatedFunction (Self T A) "drain" (drain T A).
      
      (*
          pub fn clear(&mut self) {
              self.truncate(0);
              // Not strictly necessary, but leaves things in a more consistent/predictable state.
              self.head = 0;
          }
      *)
      Definition clear (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              let _ :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply (Ty.path "alloc::collections::vec_deque::VecDeque") [ T; A ],
                      "truncate",
                      []
                    |),
                    [ M.read (| self |); Value.Integer 0 ]
                  |)
                |) in
              let _ :=
                M.write (|
                  M.SubPointer.get_struct_record_field (|
                    M.read (| self |),
                    "alloc::collections::vec_deque::VecDeque",
                    "head"
                  |),
                  Value.Integer 0
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_clear :
        forall (T A : Ty.t),
        M.IsAssociatedFunction (Self T A) "clear" (clear T A).
      
      (*
          pub fn contains(&self, x: &T) -> bool
          where
              T: PartialEq<T>,
          {
              let (a, b) = self.as_slices();
              a.contains(x) || b.contains(x)
          }
      *)
      Definition contains (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match τ, α with
        | [], [ self; x ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let x := M.alloc (| x |) in
            M.read (|
              M.match_operator (|
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply (Ty.path "alloc::collections::vec_deque::VecDeque") [ T; A ],
                      "as_slices",
                      []
                    |),
                    [ M.read (| self |) ]
                  |)
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      let a := M.copy (| γ0_0 |) in
                      let b := M.copy (| γ0_1 |) in
                      M.alloc (|
                        LogicalOp.or (|
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply (Ty.path "slice") [ T ],
                              "contains",
                              []
                            |),
                            [ M.read (| a |); M.read (| x |) ]
                          |),
                          ltac:(M.monadic
                            (M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply (Ty.path "slice") [ T ],
                                "contains",
                                []
                              |),
                              [ M.read (| b |); M.read (| x |) ]
                            |)))
                        |)
                      |)))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_contains :
        forall (T A : Ty.t),
        M.IsAssociatedFunction (Self T A) "contains" (contains T A).
      
      (*
          pub fn front(&self) -> Option<&T> {
              self.get(0)
          }
      *)
      Definition front (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply (Ty.path "alloc::collections::vec_deque::VecDeque") [ T; A ],
                "get",
                []
              |),
              [ M.read (| self |); Value.Integer 0 ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_front :
        forall (T A : Ty.t),
        M.IsAssociatedFunction (Self T A) "front" (front T A).
      
      (*
          pub fn front_mut(&mut self) -> Option<&mut T> {
              self.get_mut(0)
          }
      *)
      Definition front_mut (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply (Ty.path "alloc::collections::vec_deque::VecDeque") [ T; A ],
                "get_mut",
                []
              |),
              [ M.read (| self |); Value.Integer 0 ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_front_mut :
        forall (T A : Ty.t),
        M.IsAssociatedFunction (Self T A) "front_mut" (front_mut T A).
      
      (*
          pub fn back(&self) -> Option<&T> {
              self.get(self.len.wrapping_sub(1))
          }
      *)
      Definition back (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply (Ty.path "alloc::collections::vec_deque::VecDeque") [ T; A ],
                "get",
                []
              |),
              [
                M.read (| self |);
                M.call_closure (|
                  M.get_associated_function (| Ty.path "usize", "wrapping_sub", [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "alloc::collections::vec_deque::VecDeque",
                        "len"
                      |)
                    |);
                    Value.Integer 1
                  ]
                |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_back :
        forall (T A : Ty.t),
        M.IsAssociatedFunction (Self T A) "back" (back T A).
      
      (*
          pub fn back_mut(&mut self) -> Option<&mut T> {
              self.get_mut(self.len.wrapping_sub(1))
          }
      *)
      Definition back_mut (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply (Ty.path "alloc::collections::vec_deque::VecDeque") [ T; A ],
                "get_mut",
                []
              |),
              [
                M.read (| self |);
                M.call_closure (|
                  M.get_associated_function (| Ty.path "usize", "wrapping_sub", [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "alloc::collections::vec_deque::VecDeque",
                        "len"
                      |)
                    |);
                    Value.Integer 1
                  ]
                |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_back_mut :
        forall (T A : Ty.t),
        M.IsAssociatedFunction (Self T A) "back_mut" (back_mut T A).
      
      (*
          pub fn pop_front(&mut self) -> Option<T> {
              if self.is_empty() {
                  None
              } else {
                  let old_head = self.head;
                  self.head = self.to_physical_idx(1);
                  self.len -= 1;
                  Some(unsafe { self.buffer_read(old_head) })
              }
          }
      *)
      Definition pop_front (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "alloc::collections::vec_deque::VecDeque")
                                  [ T; A ],
                                "is_empty",
                                []
                              |),
                              [ M.read (| self |) ]
                            |)
                          |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let old_head :=
                        M.copy (|
                          M.SubPointer.get_struct_record_field (|
                            M.read (| self |),
                            "alloc::collections::vec_deque::VecDeque",
                            "head"
                          |)
                        |) in
                      let _ :=
                        M.write (|
                          M.SubPointer.get_struct_record_field (|
                            M.read (| self |),
                            "alloc::collections::vec_deque::VecDeque",
                            "head"
                          |),
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply (Ty.path "alloc::collections::vec_deque::VecDeque") [ T; A ],
                              "to_physical_idx",
                              []
                            |),
                            [ M.read (| self |); Value.Integer 1 ]
                          |)
                        |) in
                      let _ :=
                        let β :=
                          M.SubPointer.get_struct_record_field (|
                            M.read (| self |),
                            "alloc::collections::vec_deque::VecDeque",
                            "len"
                          |) in
                        M.write (|
                          β,
                          BinOp.Panic.sub (| Integer.Usize, M.read (| β |), Value.Integer 1 |)
                        |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::option::Option::Some"
                          [
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "alloc::collections::vec_deque::VecDeque")
                                  [ T; A ],
                                "buffer_read",
                                []
                              |),
                              [ M.read (| self |); M.read (| old_head |) ]
                            |)
                          ]
                      |)))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_pop_front :
        forall (T A : Ty.t),
        M.IsAssociatedFunction (Self T A) "pop_front" (pop_front T A).
      
      (*
          pub fn pop_back(&mut self) -> Option<T> {
              if self.is_empty() {
                  None
              } else {
                  self.len -= 1;
                  Some(unsafe { self.buffer_read(self.to_physical_idx(self.len)) })
              }
          }
      *)
      Definition pop_back (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "alloc::collections::vec_deque::VecDeque")
                                  [ T; A ],
                                "is_empty",
                                []
                              |),
                              [ M.read (| self |) ]
                            |)
                          |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let _ :=
                        let β :=
                          M.SubPointer.get_struct_record_field (|
                            M.read (| self |),
                            "alloc::collections::vec_deque::VecDeque",
                            "len"
                          |) in
                        M.write (|
                          β,
                          BinOp.Panic.sub (| Integer.Usize, M.read (| β |), Value.Integer 1 |)
                        |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::option::Option::Some"
                          [
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "alloc::collections::vec_deque::VecDeque")
                                  [ T; A ],
                                "buffer_read",
                                []
                              |),
                              [
                                M.read (| self |);
                                M.call_closure (|
                                  M.get_associated_function (|
                                    Ty.apply
                                      (Ty.path "alloc::collections::vec_deque::VecDeque")
                                      [ T; A ],
                                    "to_physical_idx",
                                    []
                                  |),
                                  [
                                    M.read (| self |);
                                    M.read (|
                                      M.SubPointer.get_struct_record_field (|
                                        M.read (| self |),
                                        "alloc::collections::vec_deque::VecDeque",
                                        "len"
                                      |)
                                    |)
                                  ]
                                |)
                              ]
                            |)
                          ]
                      |)))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_pop_back :
        forall (T A : Ty.t),
        M.IsAssociatedFunction (Self T A) "pop_back" (pop_back T A).
      
      (*
          pub fn push_front(&mut self, value: T) {
              if self.is_full() {
                  self.grow();
              }
      
              self.head = self.wrap_sub(self.head, 1);
              self.len += 1;
      
              unsafe {
                  self.buffer_write(self.head, value);
              }
          }
      *)
      Definition push_front (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match τ, α with
        | [], [ self; value ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let value := M.alloc (| value |) in
            M.read (|
              let _ :=
                M.match_operator (|
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ :=
                          M.use
                            (M.alloc (|
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "alloc::collections::vec_deque::VecDeque")
                                    [ T; A ],
                                  "is_full",
                                  []
                                |),
                                [ M.read (| self |) ]
                              |)
                            |)) in
                        let _ :=
                          M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        let _ :=
                          M.alloc (|
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "alloc::collections::vec_deque::VecDeque")
                                  [ T; A ],
                                "grow",
                                []
                              |),
                              [ M.read (| self |) ]
                            |)
                          |) in
                        M.alloc (| Value.Tuple [] |)));
                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                  ]
                |) in
              let _ :=
                M.write (|
                  M.SubPointer.get_struct_record_field (|
                    M.read (| self |),
                    "alloc::collections::vec_deque::VecDeque",
                    "head"
                  |),
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply (Ty.path "alloc::collections::vec_deque::VecDeque") [ T; A ],
                      "wrap_sub",
                      []
                    |),
                    [
                      M.read (| self |);
                      M.read (|
                        M.SubPointer.get_struct_record_field (|
                          M.read (| self |),
                          "alloc::collections::vec_deque::VecDeque",
                          "head"
                        |)
                      |);
                      Value.Integer 1
                    ]
                  |)
                |) in
              let _ :=
                let β :=
                  M.SubPointer.get_struct_record_field (|
                    M.read (| self |),
                    "alloc::collections::vec_deque::VecDeque",
                    "len"
                  |) in
                M.write (|
                  β,
                  BinOp.Panic.add (| Integer.Usize, M.read (| β |), Value.Integer 1 |)
                |) in
              let _ :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply (Ty.path "alloc::collections::vec_deque::VecDeque") [ T; A ],
                      "buffer_write",
                      []
                    |),
                    [
                      M.read (| self |);
                      M.read (|
                        M.SubPointer.get_struct_record_field (|
                          M.read (| self |),
                          "alloc::collections::vec_deque::VecDeque",
                          "head"
                        |)
                      |);
                      M.read (| value |)
                    ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_push_front :
        forall (T A : Ty.t),
        M.IsAssociatedFunction (Self T A) "push_front" (push_front T A).
      
      (*
          pub fn push_back(&mut self, value: T) {
              if self.is_full() {
                  self.grow();
              }
      
              unsafe { self.buffer_write(self.to_physical_idx(self.len), value) }
              self.len += 1;
          }
      *)
      Definition push_back (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match τ, α with
        | [], [ self; value ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let value := M.alloc (| value |) in
            M.read (|
              let _ :=
                M.match_operator (|
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ :=
                          M.use
                            (M.alloc (|
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "alloc::collections::vec_deque::VecDeque")
                                    [ T; A ],
                                  "is_full",
                                  []
                                |),
                                [ M.read (| self |) ]
                              |)
                            |)) in
                        let _ :=
                          M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        let _ :=
                          M.alloc (|
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "alloc::collections::vec_deque::VecDeque")
                                  [ T; A ],
                                "grow",
                                []
                              |),
                              [ M.read (| self |) ]
                            |)
                          |) in
                        M.alloc (| Value.Tuple [] |)));
                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                  ]
                |) in
              let _ :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply (Ty.path "alloc::collections::vec_deque::VecDeque") [ T; A ],
                      "buffer_write",
                      []
                    |),
                    [
                      M.read (| self |);
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "alloc::collections::vec_deque::VecDeque") [ T; A ],
                          "to_physical_idx",
                          []
                        |),
                        [
                          M.read (| self |);
                          M.read (|
                            M.SubPointer.get_struct_record_field (|
                              M.read (| self |),
                              "alloc::collections::vec_deque::VecDeque",
                              "len"
                            |)
                          |)
                        ]
                      |);
                      M.read (| value |)
                    ]
                  |)
                |) in
              let _ :=
                let β :=
                  M.SubPointer.get_struct_record_field (|
                    M.read (| self |),
                    "alloc::collections::vec_deque::VecDeque",
                    "len"
                  |) in
                M.write (|
                  β,
                  BinOp.Panic.add (| Integer.Usize, M.read (| β |), Value.Integer 1 |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_push_back :
        forall (T A : Ty.t),
        M.IsAssociatedFunction (Self T A) "push_back" (push_back T A).
      
      (*
          fn is_contiguous(&self) -> bool {
              // Do the calculation like this to avoid overflowing if len + head > usize::MAX
              self.head <= self.capacity() - self.len
          }
      *)
      Definition is_contiguous (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            BinOp.Pure.le
              (M.read (|
                M.SubPointer.get_struct_record_field (|
                  M.read (| self |),
                  "alloc::collections::vec_deque::VecDeque",
                  "head"
                |)
              |))
              (BinOp.Panic.sub (|
                Integer.Usize,
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "alloc::collections::vec_deque::VecDeque") [ T; A ],
                    "capacity",
                    []
                  |),
                  [ M.read (| self |) ]
                |),
                M.read (|
                  M.SubPointer.get_struct_record_field (|
                    M.read (| self |),
                    "alloc::collections::vec_deque::VecDeque",
                    "len"
                  |)
                |)
              |))))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_is_contiguous :
        forall (T A : Ty.t),
        M.IsAssociatedFunction (Self T A) "is_contiguous" (is_contiguous T A).
      
      (*
          pub fn swap_remove_front(&mut self, index: usize) -> Option<T> {
              let length = self.len;
              if index < length && index != 0 {
                  self.swap(index, 0);
              } else if index >= length {
                  return None;
              }
              self.pop_front()
          }
      *)
      Definition swap_remove_front (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match τ, α with
        | [], [ self; index ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let index := M.alloc (| index |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.read (|
                  let length :=
                    M.copy (|
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "alloc::collections::vec_deque::VecDeque",
                        "len"
                      |)
                    |) in
                  let _ :=
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  LogicalOp.and (|
                                    BinOp.Pure.lt (M.read (| index |)) (M.read (| length |)),
                                    ltac:(M.monadic
                                      (BinOp.Pure.ne (M.read (| index |)) (Value.Integer 0)))
                                  |)
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            let _ :=
                              M.alloc (|
                                M.call_closure (|
                                  M.get_associated_function (|
                                    Ty.apply
                                      (Ty.path "alloc::collections::vec_deque::VecDeque")
                                      [ T; A ],
                                    "swap",
                                    []
                                  |),
                                  [ M.read (| self |); M.read (| index |); Value.Integer 0 ]
                                |)
                              |) in
                            M.alloc (| Value.Tuple [] |)));
                        fun γ =>
                          ltac:(M.monadic
                            (M.match_operator (|
                              M.alloc (| Value.Tuple [] |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let γ :=
                                      M.use
                                        (M.alloc (|
                                          BinOp.Pure.ge (M.read (| index |)) (M.read (| length |))
                                        |)) in
                                    let _ :=
                                      M.is_constant_or_break_match (|
                                        M.read (| γ |),
                                        Value.Bool true
                                      |) in
                                    M.alloc (|
                                      M.never_to_any (|
                                        M.read (|
                                          M.return_ (|
                                            Value.StructTuple "core::option::Option::None" []
                                          |)
                                        |)
                                      |)
                                    |)));
                                fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                              ]
                            |)))
                      ]
                    |) in
                  M.alloc (|
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "alloc::collections::vec_deque::VecDeque") [ T; A ],
                        "pop_front",
                        []
                      |),
                      [ M.read (| self |) ]
                    |)
                  |)
                |)))
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_swap_remove_front :
        forall (T A : Ty.t),
        M.IsAssociatedFunction (Self T A) "swap_remove_front" (swap_remove_front T A).
      
      (*
          pub fn swap_remove_back(&mut self, index: usize) -> Option<T> {
              let length = self.len;
              if length > 0 && index < length - 1 {
                  self.swap(index, length - 1);
              } else if index >= length {
                  return None;
              }
              self.pop_back()
          }
      *)
      Definition swap_remove_back (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match τ, α with
        | [], [ self; index ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let index := M.alloc (| index |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.read (|
                  let length :=
                    M.copy (|
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "alloc::collections::vec_deque::VecDeque",
                        "len"
                      |)
                    |) in
                  let _ :=
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  LogicalOp.and (|
                                    BinOp.Pure.gt (M.read (| length |)) (Value.Integer 0),
                                    ltac:(M.monadic
                                      (BinOp.Pure.lt
                                        (M.read (| index |))
                                        (BinOp.Panic.sub (|
                                          Integer.Usize,
                                          M.read (| length |),
                                          Value.Integer 1
                                        |))))
                                  |)
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            let _ :=
                              M.alloc (|
                                M.call_closure (|
                                  M.get_associated_function (|
                                    Ty.apply
                                      (Ty.path "alloc::collections::vec_deque::VecDeque")
                                      [ T; A ],
                                    "swap",
                                    []
                                  |),
                                  [
                                    M.read (| self |);
                                    M.read (| index |);
                                    BinOp.Panic.sub (|
                                      Integer.Usize,
                                      M.read (| length |),
                                      Value.Integer 1
                                    |)
                                  ]
                                |)
                              |) in
                            M.alloc (| Value.Tuple [] |)));
                        fun γ =>
                          ltac:(M.monadic
                            (M.match_operator (|
                              M.alloc (| Value.Tuple [] |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let γ :=
                                      M.use
                                        (M.alloc (|
                                          BinOp.Pure.ge (M.read (| index |)) (M.read (| length |))
                                        |)) in
                                    let _ :=
                                      M.is_constant_or_break_match (|
                                        M.read (| γ |),
                                        Value.Bool true
                                      |) in
                                    M.alloc (|
                                      M.never_to_any (|
                                        M.read (|
                                          M.return_ (|
                                            Value.StructTuple "core::option::Option::None" []
                                          |)
                                        |)
                                      |)
                                    |)));
                                fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                              ]
                            |)))
                      ]
                    |) in
                  M.alloc (|
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "alloc::collections::vec_deque::VecDeque") [ T; A ],
                        "pop_back",
                        []
                      |),
                      [ M.read (| self |) ]
                    |)
                  |)
                |)))
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_swap_remove_back :
        forall (T A : Ty.t),
        M.IsAssociatedFunction (Self T A) "swap_remove_back" (swap_remove_back T A).
      
      (*
          pub fn insert(&mut self, index: usize, value: T) {
              assert!(index <= self.len(), "index out of bounds");
              if self.is_full() {
                  self.grow();
              }
      
              let k = self.len - index;
              if k < index {
                  // `index + 1` can't overflow, because if index was usize::MAX, then either the
                  // assert would've failed, or the deque would've tried to grow past usize::MAX
                  // and panicked.
                  unsafe {
                      // see `remove()` for explanation why this wrap_copy() call is safe.
                      self.wrap_copy(self.to_physical_idx(index), self.to_physical_idx(index + 1), k);
                      self.buffer_write(self.to_physical_idx(index), value);
                      self.len += 1;
                  }
              } else {
                  let old_head = self.head;
                  self.head = self.wrap_sub(self.head, 1);
                  unsafe {
                      self.wrap_copy(old_head, self.head, index);
                      self.buffer_write(self.to_physical_idx(index), value);
                      self.len += 1;
                  }
              }
          }
      *)
      Definition insert (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match τ, α with
        | [], [ self; index; value ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let index := M.alloc (| index |) in
            let value := M.alloc (| value |) in
            M.read (|
              let _ :=
                M.match_operator (|
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ :=
                          M.use
                            (M.alloc (|
                              UnOp.Pure.not
                                (BinOp.Pure.le
                                  (M.read (| index |))
                                  (M.call_closure (|
                                    M.get_associated_function (|
                                      Ty.apply
                                        (Ty.path "alloc::collections::vec_deque::VecDeque")
                                        [ T; A ],
                                      "len",
                                      []
                                    |),
                                    [ M.read (| self |) ]
                                  |)))
                            |)) in
                        let _ :=
                          M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        M.alloc (|
                          M.never_to_any (|
                            M.call_closure (|
                              M.get_function (| "core::panicking::panic_fmt", [] |),
                              [
                                M.call_closure (|
                                  M.get_associated_function (|
                                    Ty.path "core::fmt::Arguments",
                                    "new_const",
                                    []
                                  |),
                                  [
                                    (* Unsize *)
                                    M.pointer_coercion
                                      (M.alloc (|
                                        Value.Array
                                          [ M.read (| Value.String "index out of bounds" |) ]
                                      |))
                                  ]
                                |)
                              ]
                            |)
                          |)
                        |)));
                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                  ]
                |) in
              let _ :=
                M.match_operator (|
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ :=
                          M.use
                            (M.alloc (|
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "alloc::collections::vec_deque::VecDeque")
                                    [ T; A ],
                                  "is_full",
                                  []
                                |),
                                [ M.read (| self |) ]
                              |)
                            |)) in
                        let _ :=
                          M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        let _ :=
                          M.alloc (|
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "alloc::collections::vec_deque::VecDeque")
                                  [ T; A ],
                                "grow",
                                []
                              |),
                              [ M.read (| self |) ]
                            |)
                          |) in
                        M.alloc (| Value.Tuple [] |)));
                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                  ]
                |) in
              let k :=
                M.alloc (|
                  BinOp.Panic.sub (|
                    Integer.Usize,
                    M.read (|
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "alloc::collections::vec_deque::VecDeque",
                        "len"
                      |)
                    |),
                    M.read (| index |)
                  |)
                |) in
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use (M.alloc (| BinOp.Pure.lt (M.read (| k |)) (M.read (| index |)) |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      let _ :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply (Ty.path "alloc::collections::vec_deque::VecDeque") [ T; A ],
                              "wrap_copy",
                              []
                            |),
                            [
                              M.read (| self |);
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "alloc::collections::vec_deque::VecDeque")
                                    [ T; A ],
                                  "to_physical_idx",
                                  []
                                |),
                                [ M.read (| self |); M.read (| index |) ]
                              |);
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "alloc::collections::vec_deque::VecDeque")
                                    [ T; A ],
                                  "to_physical_idx",
                                  []
                                |),
                                [
                                  M.read (| self |);
                                  BinOp.Panic.add (|
                                    Integer.Usize,
                                    M.read (| index |),
                                    Value.Integer 1
                                  |)
                                ]
                              |);
                              M.read (| k |)
                            ]
                          |)
                        |) in
                      let _ :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply (Ty.path "alloc::collections::vec_deque::VecDeque") [ T; A ],
                              "buffer_write",
                              []
                            |),
                            [
                              M.read (| self |);
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "alloc::collections::vec_deque::VecDeque")
                                    [ T; A ],
                                  "to_physical_idx",
                                  []
                                |),
                                [ M.read (| self |); M.read (| index |) ]
                              |);
                              M.read (| value |)
                            ]
                          |)
                        |) in
                      let _ :=
                        let β :=
                          M.SubPointer.get_struct_record_field (|
                            M.read (| self |),
                            "alloc::collections::vec_deque::VecDeque",
                            "len"
                          |) in
                        M.write (|
                          β,
                          BinOp.Panic.add (| Integer.Usize, M.read (| β |), Value.Integer 1 |)
                        |) in
                      M.alloc (| Value.Tuple [] |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let old_head :=
                        M.copy (|
                          M.SubPointer.get_struct_record_field (|
                            M.read (| self |),
                            "alloc::collections::vec_deque::VecDeque",
                            "head"
                          |)
                        |) in
                      let _ :=
                        M.write (|
                          M.SubPointer.get_struct_record_field (|
                            M.read (| self |),
                            "alloc::collections::vec_deque::VecDeque",
                            "head"
                          |),
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply (Ty.path "alloc::collections::vec_deque::VecDeque") [ T; A ],
                              "wrap_sub",
                              []
                            |),
                            [
                              M.read (| self |);
                              M.read (|
                                M.SubPointer.get_struct_record_field (|
                                  M.read (| self |),
                                  "alloc::collections::vec_deque::VecDeque",
                                  "head"
                                |)
                              |);
                              Value.Integer 1
                            ]
                          |)
                        |) in
                      let _ :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply (Ty.path "alloc::collections::vec_deque::VecDeque") [ T; A ],
                              "wrap_copy",
                              []
                            |),
                            [
                              M.read (| self |);
                              M.read (| old_head |);
                              M.read (|
                                M.SubPointer.get_struct_record_field (|
                                  M.read (| self |),
                                  "alloc::collections::vec_deque::VecDeque",
                                  "head"
                                |)
                              |);
                              M.read (| index |)
                            ]
                          |)
                        |) in
                      let _ :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply (Ty.path "alloc::collections::vec_deque::VecDeque") [ T; A ],
                              "buffer_write",
                              []
                            |),
                            [
                              M.read (| self |);
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "alloc::collections::vec_deque::VecDeque")
                                    [ T; A ],
                                  "to_physical_idx",
                                  []
                                |),
                                [ M.read (| self |); M.read (| index |) ]
                              |);
                              M.read (| value |)
                            ]
                          |)
                        |) in
                      let _ :=
                        let β :=
                          M.SubPointer.get_struct_record_field (|
                            M.read (| self |),
                            "alloc::collections::vec_deque::VecDeque",
                            "len"
                          |) in
                        M.write (|
                          β,
                          BinOp.Panic.add (| Integer.Usize, M.read (| β |), Value.Integer 1 |)
                        |) in
                      M.alloc (| Value.Tuple [] |)))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_insert :
        forall (T A : Ty.t),
        M.IsAssociatedFunction (Self T A) "insert" (insert T A).
      
      (*
          pub fn remove(&mut self, index: usize) -> Option<T> {
              if self.len <= index {
                  return None;
              }
      
              let wrapped_idx = self.to_physical_idx(index);
      
              let elem = unsafe { Some(self.buffer_read(wrapped_idx)) };
      
              let k = self.len - index - 1;
              // safety: due to the nature of the if-condition, whichever wrap_copy gets called,
              // its length argument will be at most `self.len / 2`, so there can't be more than
              // one overlapping area.
              if k < index {
                  unsafe { self.wrap_copy(self.wrap_add(wrapped_idx, 1), wrapped_idx, k) };
                  self.len -= 1;
              } else {
                  let old_head = self.head;
                  self.head = self.to_physical_idx(1);
                  unsafe { self.wrap_copy(old_head, self.head, index) };
                  self.len -= 1;
              }
      
              elem
          }
      *)
      Definition remove (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match τ, α with
        | [], [ self; index ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let index := M.alloc (| index |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.read (|
                  let _ :=
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  BinOp.Pure.le
                                    (M.read (|
                                      M.SubPointer.get_struct_record_field (|
                                        M.read (| self |),
                                        "alloc::collections::vec_deque::VecDeque",
                                        "len"
                                      |)
                                    |))
                                    (M.read (| index |))
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (|
                              M.never_to_any (|
                                M.read (|
                                  M.return_ (| Value.StructTuple "core::option::Option::None" [] |)
                                |)
                              |)
                            |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                      ]
                    |) in
                  let wrapped_idx :=
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "alloc::collections::vec_deque::VecDeque") [ T; A ],
                          "to_physical_idx",
                          []
                        |),
                        [ M.read (| self |); M.read (| index |) ]
                      |)
                    |) in
                  let elem :=
                    M.alloc (|
                      Value.StructTuple
                        "core::option::Option::Some"
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply (Ty.path "alloc::collections::vec_deque::VecDeque") [ T; A ],
                              "buffer_read",
                              []
                            |),
                            [ M.read (| self |); M.read (| wrapped_idx |) ]
                          |)
                        ]
                    |) in
                  let k :=
                    M.alloc (|
                      BinOp.Panic.sub (|
                        Integer.Usize,
                        BinOp.Panic.sub (|
                          Integer.Usize,
                          M.read (|
                            M.SubPointer.get_struct_record_field (|
                              M.read (| self |),
                              "alloc::collections::vec_deque::VecDeque",
                              "len"
                            |)
                          |),
                          M.read (| index |)
                        |),
                        Value.Integer 1
                      |)
                    |) in
                  let _ :=
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  BinOp.Pure.lt (M.read (| k |)) (M.read (| index |))
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            let _ :=
                              M.alloc (|
                                M.call_closure (|
                                  M.get_associated_function (|
                                    Ty.apply
                                      (Ty.path "alloc::collections::vec_deque::VecDeque")
                                      [ T; A ],
                                    "wrap_copy",
                                    []
                                  |),
                                  [
                                    M.read (| self |);
                                    M.call_closure (|
                                      M.get_associated_function (|
                                        Ty.apply
                                          (Ty.path "alloc::collections::vec_deque::VecDeque")
                                          [ T; A ],
                                        "wrap_add",
                                        []
                                      |),
                                      [ M.read (| self |); M.read (| wrapped_idx |); Value.Integer 1
                                      ]
                                    |);
                                    M.read (| wrapped_idx |);
                                    M.read (| k |)
                                  ]
                                |)
                              |) in
                            let _ :=
                              let β :=
                                M.SubPointer.get_struct_record_field (|
                                  M.read (| self |),
                                  "alloc::collections::vec_deque::VecDeque",
                                  "len"
                                |) in
                              M.write (|
                                β,
                                BinOp.Panic.sub (| Integer.Usize, M.read (| β |), Value.Integer 1 |)
                              |) in
                            M.alloc (| Value.Tuple [] |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let old_head :=
                              M.copy (|
                                M.SubPointer.get_struct_record_field (|
                                  M.read (| self |),
                                  "alloc::collections::vec_deque::VecDeque",
                                  "head"
                                |)
                              |) in
                            let _ :=
                              M.write (|
                                M.SubPointer.get_struct_record_field (|
                                  M.read (| self |),
                                  "alloc::collections::vec_deque::VecDeque",
                                  "head"
                                |),
                                M.call_closure (|
                                  M.get_associated_function (|
                                    Ty.apply
                                      (Ty.path "alloc::collections::vec_deque::VecDeque")
                                      [ T; A ],
                                    "to_physical_idx",
                                    []
                                  |),
                                  [ M.read (| self |); Value.Integer 1 ]
                                |)
                              |) in
                            let _ :=
                              M.alloc (|
                                M.call_closure (|
                                  M.get_associated_function (|
                                    Ty.apply
                                      (Ty.path "alloc::collections::vec_deque::VecDeque")
                                      [ T; A ],
                                    "wrap_copy",
                                    []
                                  |),
                                  [
                                    M.read (| self |);
                                    M.read (| old_head |);
                                    M.read (|
                                      M.SubPointer.get_struct_record_field (|
                                        M.read (| self |),
                                        "alloc::collections::vec_deque::VecDeque",
                                        "head"
                                      |)
                                    |);
                                    M.read (| index |)
                                  ]
                                |)
                              |) in
                            let _ :=
                              let β :=
                                M.SubPointer.get_struct_record_field (|
                                  M.read (| self |),
                                  "alloc::collections::vec_deque::VecDeque",
                                  "len"
                                |) in
                              M.write (|
                                β,
                                BinOp.Panic.sub (| Integer.Usize, M.read (| β |), Value.Integer 1 |)
                              |) in
                            M.alloc (| Value.Tuple [] |)))
                      ]
                    |) in
                  elem
                |)))
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_remove :
        forall (T A : Ty.t),
        M.IsAssociatedFunction (Self T A) "remove" (remove T A).
      
      (*
          pub fn split_off(&mut self, at: usize) -> Self
          where
              A: Clone,
          {
              let len = self.len;
              assert!(at <= len, "`at` out of bounds");
      
              let other_len = len - at;
              let mut other = VecDeque::with_capacity_in(other_len, self.allocator().clone());
      
              unsafe {
                  let (first_half, second_half) = self.as_slices();
      
                  let first_len = first_half.len();
                  let second_len = second_half.len();
                  if at < first_len {
                      // `at` lies in the first half.
                      let amount_in_first = first_len - at;
      
                      ptr::copy_nonoverlapping(first_half.as_ptr().add(at), other.ptr(), amount_in_first);
      
                      // just take all of the second half.
                      ptr::copy_nonoverlapping(
                          second_half.as_ptr(),
                          other.ptr().add(amount_in_first),
                          second_len,
                      );
                  } else {
                      // `at` lies in the second half, need to factor in the elements we skipped
                      // in the first half.
                      let offset = at - first_len;
                      let amount_in_second = second_len - offset;
                      ptr::copy_nonoverlapping(
                          second_half.as_ptr().add(offset),
                          other.ptr(),
                          amount_in_second,
                      );
                  }
              }
      
              // Cleanup where the ends of the buffers are
              self.len = at;
              other.len = other_len;
      
              other
          }
      *)
      Definition split_off (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match τ, α with
        | [], [ self; at_ ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let at_ := M.alloc (| at_ |) in
            M.read (|
              let len :=
                M.copy (|
                  M.SubPointer.get_struct_record_field (|
                    M.read (| self |),
                    "alloc::collections::vec_deque::VecDeque",
                    "len"
                  |)
                |) in
              let _ :=
                M.match_operator (|
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ :=
                          M.use
                            (M.alloc (|
                              UnOp.Pure.not (BinOp.Pure.le (M.read (| at_ |)) (M.read (| len |)))
                            |)) in
                        let _ :=
                          M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        M.alloc (|
                          M.never_to_any (|
                            M.call_closure (|
                              M.get_function (| "core::panicking::panic_fmt", [] |),
                              [
                                M.call_closure (|
                                  M.get_associated_function (|
                                    Ty.path "core::fmt::Arguments",
                                    "new_const",
                                    []
                                  |),
                                  [
                                    (* Unsize *)
                                    M.pointer_coercion
                                      (M.alloc (|
                                        Value.Array
                                          [ M.read (| Value.String "`at` out of bounds" |) ]
                                      |))
                                  ]
                                |)
                              ]
                            |)
                          |)
                        |)));
                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                  ]
                |) in
              let other_len :=
                M.alloc (|
                  BinOp.Panic.sub (| Integer.Usize, M.read (| len |), M.read (| at_ |) |)
                |) in
              let other :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply (Ty.path "alloc::collections::vec_deque::VecDeque") [ T; A ],
                      "with_capacity_in",
                      []
                    |),
                    [
                      M.read (| other_len |);
                      M.call_closure (|
                        M.get_trait_method (| "core::clone::Clone", A, [], "clone", [] |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply (Ty.path "alloc::collections::vec_deque::VecDeque") [ T; A ],
                              "allocator",
                              []
                            |),
                            [ M.read (| self |) ]
                          |)
                        ]
                      |)
                    ]
                  |)
                |) in
              let _ :=
                M.match_operator (|
                  M.alloc (|
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "alloc::collections::vec_deque::VecDeque") [ T; A ],
                        "as_slices",
                        []
                      |),
                      [ M.read (| self |) ]
                    |)
                  |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                        let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                        let first_half := M.copy (| γ0_0 |) in
                        let second_half := M.copy (| γ0_1 |) in
                        let first_len :=
                          M.alloc (|
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply (Ty.path "slice") [ T ],
                                "len",
                                []
                              |),
                              [ M.read (| first_half |) ]
                            |)
                          |) in
                        let second_len :=
                          M.alloc (|
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply (Ty.path "slice") [ T ],
                                "len",
                                []
                              |),
                              [ M.read (| second_half |) ]
                            |)
                          |) in
                        M.match_operator (|
                          M.alloc (| Value.Tuple [] |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ :=
                                  M.use
                                    (M.alloc (|
                                      BinOp.Pure.lt (M.read (| at_ |)) (M.read (| first_len |))
                                    |)) in
                                let _ :=
                                  M.is_constant_or_break_match (|
                                    M.read (| γ |),
                                    Value.Bool true
                                  |) in
                                let amount_in_first :=
                                  M.alloc (|
                                    BinOp.Panic.sub (|
                                      Integer.Usize,
                                      M.read (| first_len |),
                                      M.read (| at_ |)
                                    |)
                                  |) in
                                let _ :=
                                  M.alloc (|
                                    M.call_closure (|
                                      M.get_function (|
                                        "core::intrinsics::copy_nonoverlapping",
                                        [ T ]
                                      |),
                                      [
                                        M.call_closure (|
                                          M.get_associated_function (|
                                            Ty.apply (Ty.path "*const") [ T ],
                                            "add",
                                            []
                                          |),
                                          [
                                            M.call_closure (|
                                              M.get_associated_function (|
                                                Ty.apply (Ty.path "slice") [ T ],
                                                "as_ptr",
                                                []
                                              |),
                                              [ M.read (| first_half |) ]
                                            |);
                                            M.read (| at_ |)
                                          ]
                                        |);
                                        M.call_closure (|
                                          M.get_associated_function (|
                                            Ty.apply
                                              (Ty.path "alloc::collections::vec_deque::VecDeque")
                                              [ T; A ],
                                            "ptr",
                                            []
                                          |),
                                          [ other ]
                                        |);
                                        M.read (| amount_in_first |)
                                      ]
                                    |)
                                  |) in
                                let _ :=
                                  M.alloc (|
                                    M.call_closure (|
                                      M.get_function (|
                                        "core::intrinsics::copy_nonoverlapping",
                                        [ T ]
                                      |),
                                      [
                                        M.call_closure (|
                                          M.get_associated_function (|
                                            Ty.apply (Ty.path "slice") [ T ],
                                            "as_ptr",
                                            []
                                          |),
                                          [ M.read (| second_half |) ]
                                        |);
                                        M.call_closure (|
                                          M.get_associated_function (|
                                            Ty.apply (Ty.path "*mut") [ T ],
                                            "add",
                                            []
                                          |),
                                          [
                                            M.call_closure (|
                                              M.get_associated_function (|
                                                Ty.apply
                                                  (Ty.path
                                                    "alloc::collections::vec_deque::VecDeque")
                                                  [ T; A ],
                                                "ptr",
                                                []
                                              |),
                                              [ other ]
                                            |);
                                            M.read (| amount_in_first |)
                                          ]
                                        |);
                                        M.read (| second_len |)
                                      ]
                                    |)
                                  |) in
                                M.alloc (| Value.Tuple [] |)));
                            fun γ =>
                              ltac:(M.monadic
                                (let offset :=
                                  M.alloc (|
                                    BinOp.Panic.sub (|
                                      Integer.Usize,
                                      M.read (| at_ |),
                                      M.read (| first_len |)
                                    |)
                                  |) in
                                let amount_in_second :=
                                  M.alloc (|
                                    BinOp.Panic.sub (|
                                      Integer.Usize,
                                      M.read (| second_len |),
                                      M.read (| offset |)
                                    |)
                                  |) in
                                let _ :=
                                  M.alloc (|
                                    M.call_closure (|
                                      M.get_function (|
                                        "core::intrinsics::copy_nonoverlapping",
                                        [ T ]
                                      |),
                                      [
                                        M.call_closure (|
                                          M.get_associated_function (|
                                            Ty.apply (Ty.path "*const") [ T ],
                                            "add",
                                            []
                                          |),
                                          [
                                            M.call_closure (|
                                              M.get_associated_function (|
                                                Ty.apply (Ty.path "slice") [ T ],
                                                "as_ptr",
                                                []
                                              |),
                                              [ M.read (| second_half |) ]
                                            |);
                                            M.read (| offset |)
                                          ]
                                        |);
                                        M.call_closure (|
                                          M.get_associated_function (|
                                            Ty.apply
                                              (Ty.path "alloc::collections::vec_deque::VecDeque")
                                              [ T; A ],
                                            "ptr",
                                            []
                                          |),
                                          [ other ]
                                        |);
                                        M.read (| amount_in_second |)
                                      ]
                                    |)
                                  |) in
                                M.alloc (| Value.Tuple [] |)))
                          ]
                        |)))
                  ]
                |) in
              let _ :=
                M.write (|
                  M.SubPointer.get_struct_record_field (|
                    M.read (| self |),
                    "alloc::collections::vec_deque::VecDeque",
                    "len"
                  |),
                  M.read (| at_ |)
                |) in
              let _ :=
                M.write (|
                  M.SubPointer.get_struct_record_field (|
                    other,
                    "alloc::collections::vec_deque::VecDeque",
                    "len"
                  |),
                  M.read (| other_len |)
                |) in
              other
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_split_off :
        forall (T A : Ty.t),
        M.IsAssociatedFunction (Self T A) "split_off" (split_off T A).
      
      (*
          pub fn append(&mut self, other: &mut Self) {
              if T::IS_ZST {
                  self.len = self.len.checked_add(other.len).expect("capacity overflow");
                  other.len = 0;
                  other.head = 0;
                  return;
              }
      
              self.reserve(other.len);
              unsafe {
                  let (left, right) = other.as_slices();
                  self.copy_slice(self.to_physical_idx(self.len), left);
                  // no overflow, because self.capacity() >= old_cap + left.len() >= self.len + left.len()
                  self.copy_slice(self.to_physical_idx(self.len + left.len()), right);
              }
              // SAFETY: Update pointers after copying to avoid leaving doppelganger
              // in case of panics.
              self.len += other.len;
              // Now that we own its values, forget everything in `other`.
              other.len = 0;
              other.head = 0;
          }
      *)
      Definition append (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.read (|
                  let _ :=
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.get_constant (| "core::mem::SizedTypeProperties::IS_ZST" |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (|
                              M.never_to_any (|
                                M.read (|
                                  let _ :=
                                    M.write (|
                                      M.SubPointer.get_struct_record_field (|
                                        M.read (| self |),
                                        "alloc::collections::vec_deque::VecDeque",
                                        "len"
                                      |),
                                      M.call_closure (|
                                        M.get_associated_function (|
                                          Ty.apply
                                            (Ty.path "core::option::Option")
                                            [ Ty.path "usize" ],
                                          "expect",
                                          []
                                        |),
                                        [
                                          M.call_closure (|
                                            M.get_associated_function (|
                                              Ty.path "usize",
                                              "checked_add",
                                              []
                                            |),
                                            [
                                              M.read (|
                                                M.SubPointer.get_struct_record_field (|
                                                  M.read (| self |),
                                                  "alloc::collections::vec_deque::VecDeque",
                                                  "len"
                                                |)
                                              |);
                                              M.read (|
                                                M.SubPointer.get_struct_record_field (|
                                                  M.read (| other |),
                                                  "alloc::collections::vec_deque::VecDeque",
                                                  "len"
                                                |)
                                              |)
                                            ]
                                          |);
                                          M.read (| Value.String "capacity overflow" |)
                                        ]
                                      |)
                                    |) in
                                  let _ :=
                                    M.write (|
                                      M.SubPointer.get_struct_record_field (|
                                        M.read (| other |),
                                        "alloc::collections::vec_deque::VecDeque",
                                        "len"
                                      |),
                                      Value.Integer 0
                                    |) in
                                  let _ :=
                                    M.write (|
                                      M.SubPointer.get_struct_record_field (|
                                        M.read (| other |),
                                        "alloc::collections::vec_deque::VecDeque",
                                        "head"
                                      |),
                                      Value.Integer 0
                                    |) in
                                  M.return_ (| Value.Tuple [] |)
                                |)
                              |)
                            |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                      ]
                    |) in
                  let _ :=
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "alloc::collections::vec_deque::VecDeque") [ T; A ],
                          "reserve",
                          []
                        |),
                        [
                          M.read (| self |);
                          M.read (|
                            M.SubPointer.get_struct_record_field (|
                              M.read (| other |),
                              "alloc::collections::vec_deque::VecDeque",
                              "len"
                            |)
                          |)
                        ]
                      |)
                    |) in
                  let _ :=
                    M.match_operator (|
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.apply (Ty.path "alloc::collections::vec_deque::VecDeque") [ T; A ],
                            "as_slices",
                            []
                          |),
                          [ M.read (| other |) ]
                        |)
                      |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                            let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                            let left := M.copy (| γ0_0 |) in
                            let right := M.copy (| γ0_1 |) in
                            let _ :=
                              M.alloc (|
                                M.call_closure (|
                                  M.get_associated_function (|
                                    Ty.apply
                                      (Ty.path "alloc::collections::vec_deque::VecDeque")
                                      [ T; A ],
                                    "copy_slice",
                                    []
                                  |),
                                  [
                                    M.read (| self |);
                                    M.call_closure (|
                                      M.get_associated_function (|
                                        Ty.apply
                                          (Ty.path "alloc::collections::vec_deque::VecDeque")
                                          [ T; A ],
                                        "to_physical_idx",
                                        []
                                      |),
                                      [
                                        M.read (| self |);
                                        M.read (|
                                          M.SubPointer.get_struct_record_field (|
                                            M.read (| self |),
                                            "alloc::collections::vec_deque::VecDeque",
                                            "len"
                                          |)
                                        |)
                                      ]
                                    |);
                                    M.read (| left |)
                                  ]
                                |)
                              |) in
                            let _ :=
                              M.alloc (|
                                M.call_closure (|
                                  M.get_associated_function (|
                                    Ty.apply
                                      (Ty.path "alloc::collections::vec_deque::VecDeque")
                                      [ T; A ],
                                    "copy_slice",
                                    []
                                  |),
                                  [
                                    M.read (| self |);
                                    M.call_closure (|
                                      M.get_associated_function (|
                                        Ty.apply
                                          (Ty.path "alloc::collections::vec_deque::VecDeque")
                                          [ T; A ],
                                        "to_physical_idx",
                                        []
                                      |),
                                      [
                                        M.read (| self |);
                                        BinOp.Panic.add (|
                                          Integer.Usize,
                                          M.read (|
                                            M.SubPointer.get_struct_record_field (|
                                              M.read (| self |),
                                              "alloc::collections::vec_deque::VecDeque",
                                              "len"
                                            |)
                                          |),
                                          M.call_closure (|
                                            M.get_associated_function (|
                                              Ty.apply (Ty.path "slice") [ T ],
                                              "len",
                                              []
                                            |),
                                            [ M.read (| left |) ]
                                          |)
                                        |)
                                      ]
                                    |);
                                    M.read (| right |)
                                  ]
                                |)
                              |) in
                            M.alloc (| Value.Tuple [] |)))
                      ]
                    |) in
                  let _ :=
                    let β :=
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "alloc::collections::vec_deque::VecDeque",
                        "len"
                      |) in
                    M.write (|
                      β,
                      BinOp.Panic.add (|
                        Integer.Usize,
                        M.read (| β |),
                        M.read (|
                          M.SubPointer.get_struct_record_field (|
                            M.read (| other |),
                            "alloc::collections::vec_deque::VecDeque",
                            "len"
                          |)
                        |)
                      |)
                    |) in
                  let _ :=
                    M.write (|
                      M.SubPointer.get_struct_record_field (|
                        M.read (| other |),
                        "alloc::collections::vec_deque::VecDeque",
                        "len"
                      |),
                      Value.Integer 0
                    |) in
                  let _ :=
                    M.write (|
                      M.SubPointer.get_struct_record_field (|
                        M.read (| other |),
                        "alloc::collections::vec_deque::VecDeque",
                        "head"
                      |),
                      Value.Integer 0
                    |) in
                  M.alloc (| Value.Tuple [] |)
                |)))
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_append :
        forall (T A : Ty.t),
        M.IsAssociatedFunction (Self T A) "append" (append T A).
      
      (*
          pub fn retain<F>(&mut self, mut f: F)
          where
              F: FnMut(&T) -> bool,
          {
              self.retain_mut(|elem| f(elem));
          }
      *)
      Definition retain (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match τ, α with
        | [ F ], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.read (|
              let _ :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply (Ty.path "alloc::collections::vec_deque::VecDeque") [ T; A ],
                      "retain_mut",
                      [
                        Ty.function
                          [ Ty.tuple [ Ty.apply (Ty.path "&mut") [ T ] ] ]
                          (Ty.path "bool")
                      ]
                    |),
                    [
                      M.read (| self |);
                      M.closure
                        (fun γ =>
                          ltac:(M.monadic
                            match γ with
                            | [ α0 ] =>
                              M.match_operator (|
                                M.alloc (| α0 |),
                                [
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let elem := M.copy (| γ |) in
                                      M.call_closure (|
                                        M.get_trait_method (|
                                          "core::ops::function::FnMut",
                                          F,
                                          [ Ty.tuple [ Ty.apply (Ty.path "&") [ T ] ] ],
                                          "call_mut",
                                          []
                                        |),
                                        [ f; Value.Tuple [ M.read (| elem |) ] ]
                                      |)))
                                ]
                              |)
                            | _ => M.impossible (||)
                            end))
                    ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_retain :
        forall (T A : Ty.t),
        M.IsAssociatedFunction (Self T A) "retain" (retain T A).
      
      (*
          pub fn retain_mut<F>(&mut self, mut f: F)
          where
              F: FnMut(&mut T) -> bool,
          {
              let len = self.len;
              let mut idx = 0;
              let mut cur = 0;
      
              // Stage 1: All values are retained.
              while cur < len {
                  if !f(&mut self[cur]) {
                      cur += 1;
                      break;
                  }
                  cur += 1;
                  idx += 1;
              }
              // Stage 2: Swap retained value into current idx.
              while cur < len {
                  if !f(&mut self[cur]) {
                      cur += 1;
                      continue;
                  }
      
                  self.swap(idx, cur);
                  cur += 1;
                  idx += 1;
              }
              // Stage 3: Truncate all values after idx.
              if cur != idx {
                  self.truncate(idx);
              }
          }
      *)
      Definition retain_mut (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match τ, α with
        | [ F ], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.read (|
              let len :=
                M.copy (|
                  M.SubPointer.get_struct_record_field (|
                    M.read (| self |),
                    "alloc::collections::vec_deque::VecDeque",
                    "len"
                  |)
                |) in
              let idx := M.alloc (| Value.Integer 0 |) in
              let cur := M.alloc (| Value.Integer 0 |) in
              let _ :=
                M.loop (|
                  ltac:(M.monadic
                    (M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  BinOp.Pure.lt (M.read (| cur |)) (M.read (| len |))
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            let _ :=
                              M.match_operator (|
                                M.alloc (| Value.Tuple [] |),
                                [
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let γ :=
                                        M.use
                                          (M.alloc (|
                                            UnOp.Pure.not
                                              (M.call_closure (|
                                                M.get_trait_method (|
                                                  "core::ops::function::FnMut",
                                                  F,
                                                  [ Ty.tuple [ Ty.apply (Ty.path "&mut") [ T ] ] ],
                                                  "call_mut",
                                                  []
                                                |),
                                                [
                                                  f;
                                                  Value.Tuple
                                                    [
                                                      M.call_closure (|
                                                        M.get_trait_method (|
                                                          "core::ops::index::IndexMut",
                                                          Ty.apply
                                                            (Ty.path
                                                              "alloc::collections::vec_deque::VecDeque")
                                                            [ T; A ],
                                                          [ Ty.path "usize" ],
                                                          "index_mut",
                                                          []
                                                        |),
                                                        [ M.read (| self |); M.read (| cur |) ]
                                                      |)
                                                    ]
                                                ]
                                              |))
                                          |)) in
                                      let _ :=
                                        M.is_constant_or_break_match (|
                                          M.read (| γ |),
                                          Value.Bool true
                                        |) in
                                      M.alloc (|
                                        M.never_to_any (|
                                          M.read (|
                                            let _ :=
                                              let β := cur in
                                              M.write (|
                                                β,
                                                BinOp.Panic.add (|
                                                  Integer.Usize,
                                                  M.read (| β |),
                                                  Value.Integer 1
                                                |)
                                              |) in
                                            M.break (||)
                                          |)
                                        |)
                                      |)));
                                  fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                                ]
                              |) in
                            let _ :=
                              let β := cur in
                              M.write (|
                                β,
                                BinOp.Panic.add (| Integer.Usize, M.read (| β |), Value.Integer 1 |)
                              |) in
                            let _ :=
                              let β := idx in
                              M.write (|
                                β,
                                BinOp.Panic.add (| Integer.Usize, M.read (| β |), Value.Integer 1 |)
                              |) in
                            M.alloc (| Value.Tuple [] |)));
                        fun γ =>
                          ltac:(M.monadic
                            (M.alloc (|
                              M.never_to_any (|
                                M.read (|
                                  let _ :=
                                    M.alloc (| M.never_to_any (| M.read (| M.break (||) |) |) |) in
                                  M.alloc (| Value.Tuple [] |)
                                |)
                              |)
                            |)))
                      ]
                    |)))
                |) in
              let _ :=
                M.loop (|
                  ltac:(M.monadic
                    (M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  BinOp.Pure.lt (M.read (| cur |)) (M.read (| len |))
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            let _ :=
                              M.match_operator (|
                                M.alloc (| Value.Tuple [] |),
                                [
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let γ :=
                                        M.use
                                          (M.alloc (|
                                            UnOp.Pure.not
                                              (M.call_closure (|
                                                M.get_trait_method (|
                                                  "core::ops::function::FnMut",
                                                  F,
                                                  [ Ty.tuple [ Ty.apply (Ty.path "&mut") [ T ] ] ],
                                                  "call_mut",
                                                  []
                                                |),
                                                [
                                                  f;
                                                  Value.Tuple
                                                    [
                                                      M.call_closure (|
                                                        M.get_trait_method (|
                                                          "core::ops::index::IndexMut",
                                                          Ty.apply
                                                            (Ty.path
                                                              "alloc::collections::vec_deque::VecDeque")
                                                            [ T; A ],
                                                          [ Ty.path "usize" ],
                                                          "index_mut",
                                                          []
                                                        |),
                                                        [ M.read (| self |); M.read (| cur |) ]
                                                      |)
                                                    ]
                                                ]
                                              |))
                                          |)) in
                                      let _ :=
                                        M.is_constant_or_break_match (|
                                          M.read (| γ |),
                                          Value.Bool true
                                        |) in
                                      M.alloc (|
                                        M.never_to_any (|
                                          M.read (|
                                            let _ :=
                                              let β := cur in
                                              M.write (|
                                                β,
                                                BinOp.Panic.add (|
                                                  Integer.Usize,
                                                  M.read (| β |),
                                                  Value.Integer 1
                                                |)
                                              |) in
                                            M.continue (||)
                                          |)
                                        |)
                                      |)));
                                  fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                                ]
                              |) in
                            let _ :=
                              M.alloc (|
                                M.call_closure (|
                                  M.get_associated_function (|
                                    Ty.apply
                                      (Ty.path "alloc::collections::vec_deque::VecDeque")
                                      [ T; A ],
                                    "swap",
                                    []
                                  |),
                                  [ M.read (| self |); M.read (| idx |); M.read (| cur |) ]
                                |)
                              |) in
                            let _ :=
                              let β := cur in
                              M.write (|
                                β,
                                BinOp.Panic.add (| Integer.Usize, M.read (| β |), Value.Integer 1 |)
                              |) in
                            let _ :=
                              let β := idx in
                              M.write (|
                                β,
                                BinOp.Panic.add (| Integer.Usize, M.read (| β |), Value.Integer 1 |)
                              |) in
                            M.alloc (| Value.Tuple [] |)));
                        fun γ =>
                          ltac:(M.monadic
                            (M.alloc (|
                              M.never_to_any (|
                                M.read (|
                                  let _ :=
                                    M.alloc (| M.never_to_any (| M.read (| M.break (||) |) |) |) in
                                  M.alloc (| Value.Tuple [] |)
                                |)
                              |)
                            |)))
                      ]
                    |)))
                |) in
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use (M.alloc (| BinOp.Pure.ne (M.read (| cur |)) (M.read (| idx |)) |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      let _ :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply (Ty.path "alloc::collections::vec_deque::VecDeque") [ T; A ],
                              "truncate",
                              []
                            |),
                            [ M.read (| self |); M.read (| idx |) ]
                          |)
                        |) in
                      M.alloc (| Value.Tuple [] |)));
                  fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_retain_mut :
        forall (T A : Ty.t),
        M.IsAssociatedFunction (Self T A) "retain_mut" (retain_mut T A).
      
      (*
          fn grow(&mut self) {
              // Extend or possibly remove this assertion when valid use-cases for growing the
              // buffer without it being full emerge
              debug_assert!(self.is_full());
              let old_cap = self.capacity();
              self.buf.reserve_for_push(old_cap);
              unsafe {
                  self.handle_capacity_increase(old_cap);
              }
              debug_assert!(!self.is_full());
          }
      *)
      Definition grow (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              let _ :=
                M.match_operator (|
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.use (M.alloc (| Value.Bool true |)) in
                        let _ :=
                          M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        let _ :=
                          M.match_operator (|
                            M.alloc (| Value.Tuple [] |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ :=
                                    M.use
                                      (M.alloc (|
                                        UnOp.Pure.not
                                          (M.call_closure (|
                                            M.get_associated_function (|
                                              Ty.apply
                                                (Ty.path "alloc::collections::vec_deque::VecDeque")
                                                [ T; A ],
                                              "is_full",
                                              []
                                            |),
                                            [ M.read (| self |) ]
                                          |))
                                      |)) in
                                  let _ :=
                                    M.is_constant_or_break_match (|
                                      M.read (| γ |),
                                      Value.Bool true
                                    |) in
                                  M.alloc (|
                                    M.never_to_any (|
                                      M.call_closure (|
                                        M.get_function (| "core::panicking::panic", [] |),
                                        [
                                          M.read (|
                                            Value.String "assertion failed: self.is_full()"
                                          |)
                                        ]
                                      |)
                                    |)
                                  |)));
                              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                            ]
                          |) in
                        M.alloc (| Value.Tuple [] |)));
                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                  ]
                |) in
              let old_cap :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply (Ty.path "alloc::collections::vec_deque::VecDeque") [ T; A ],
                      "capacity",
                      []
                    |),
                    [ M.read (| self |) ]
                  |)
                |) in
              let _ :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply (Ty.path "alloc::raw_vec::RawVec") [ T; A ],
                      "reserve_for_push",
                      []
                    |),
                    [
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "alloc::collections::vec_deque::VecDeque",
                        "buf"
                      |);
                      M.read (| old_cap |)
                    ]
                  |)
                |) in
              let _ :=
                let _ :=
                  M.alloc (|
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "alloc::collections::vec_deque::VecDeque") [ T; A ],
                        "handle_capacity_increase",
                        []
                      |),
                      [ M.read (| self |); M.read (| old_cap |) ]
                    |)
                  |) in
                M.alloc (| Value.Tuple [] |) in
              let _ :=
                M.match_operator (|
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.use (M.alloc (| Value.Bool true |)) in
                        let _ :=
                          M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        let _ :=
                          M.match_operator (|
                            M.alloc (| Value.Tuple [] |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ :=
                                    M.use
                                      (M.alloc (|
                                        UnOp.Pure.not
                                          (UnOp.Pure.not
                                            (M.call_closure (|
                                              M.get_associated_function (|
                                                Ty.apply
                                                  (Ty.path
                                                    "alloc::collections::vec_deque::VecDeque")
                                                  [ T; A ],
                                                "is_full",
                                                []
                                              |),
                                              [ M.read (| self |) ]
                                            |)))
                                      |)) in
                                  let _ :=
                                    M.is_constant_or_break_match (|
                                      M.read (| γ |),
                                      Value.Bool true
                                    |) in
                                  M.alloc (|
                                    M.never_to_any (|
                                      M.call_closure (|
                                        M.get_function (| "core::panicking::panic", [] |),
                                        [
                                          M.read (|
                                            Value.String "assertion failed: !self.is_full()"
                                          |)
                                        ]
                                      |)
                                    |)
                                  |)));
                              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                            ]
                          |) in
                        M.alloc (| Value.Tuple [] |)));
                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                  ]
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_grow :
        forall (T A : Ty.t),
        M.IsAssociatedFunction (Self T A) "grow" (grow T A).
      
      (*
          pub fn resize_with(&mut self, new_len: usize, generator: impl FnMut() -> T) {
              let len = self.len;
      
              if new_len > len {
                  self.extend(repeat_with(generator).take(new_len - len))
              } else {
                  self.truncate(new_len);
              }
          }
      *)
      Definition resize_with (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match τ, α with
        | [ impl_FnMut___arrow_T ], [ self; new_len; generator ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let new_len := M.alloc (| new_len |) in
            let generator := M.alloc (| generator |) in
            M.read (|
              let len :=
                M.copy (|
                  M.SubPointer.get_struct_record_field (|
                    M.read (| self |),
                    "alloc::collections::vec_deque::VecDeque",
                    "len"
                  |)
                |) in
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (| BinOp.Pure.gt (M.read (| new_len |)) (M.read (| len |)) |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (|
                        M.call_closure (|
                          M.get_trait_method (|
                            "core::iter::traits::collect::Extend",
                            Ty.apply (Ty.path "alloc::collections::vec_deque::VecDeque") [ T; A ],
                            [ T ],
                            "extend",
                            [
                              Ty.apply
                                (Ty.path "core::iter::adapters::take::Take")
                                [
                                  Ty.apply
                                    (Ty.path "core::iter::sources::repeat_with::RepeatWith")
                                    [ impl_FnMut___arrow_T ]
                                ]
                            ]
                          |),
                          [
                            M.read (| self |);
                            M.call_closure (|
                              M.get_trait_method (|
                                "core::iter::traits::iterator::Iterator",
                                Ty.apply
                                  (Ty.path "core::iter::sources::repeat_with::RepeatWith")
                                  [ impl_FnMut___arrow_T ],
                                [],
                                "take",
                                []
                              |),
                              [
                                M.call_closure (|
                                  M.get_function (|
                                    "core::iter::sources::repeat_with::repeat_with",
                                    [ T; impl_FnMut___arrow_T ]
                                  |),
                                  [ M.read (| generator |) ]
                                |);
                                BinOp.Panic.sub (|
                                  Integer.Usize,
                                  M.read (| new_len |),
                                  M.read (| len |)
                                |)
                              ]
                            |)
                          ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let _ :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply (Ty.path "alloc::collections::vec_deque::VecDeque") [ T; A ],
                              "truncate",
                              []
                            |),
                            [ M.read (| self |); M.read (| new_len |) ]
                          |)
                        |) in
                      M.alloc (| Value.Tuple [] |)))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_resize_with :
        forall (T A : Ty.t),
        M.IsAssociatedFunction (Self T A) "resize_with" (resize_with T A).
      
      (*
          pub fn make_contiguous(&mut self) -> &mut [T] {
              if T::IS_ZST {
                  self.head = 0;
              }
      
              if self.is_contiguous() {
                  unsafe { return slice::from_raw_parts_mut(self.ptr().add(self.head), self.len) }
              }
      
              let &mut Self { head, len, .. } = self;
              let ptr = self.ptr();
              let cap = self.capacity();
      
              let free = cap - len;
              let head_len = cap - head;
              let tail = len - head_len;
              let tail_len = tail;
      
              if free >= head_len {
                  // there is enough free space to copy the head in one go,
                  // this means that we first shift the tail backwards, and then
                  // copy the head to the correct position.
                  //
                  // from: DEFGH....ABC
                  // to:   ABCDEFGH....
                  unsafe {
                      self.copy(0, head_len, tail_len);
                      // ...DEFGH.ABC
                      self.copy_nonoverlapping(head, 0, head_len);
                      // ABCDEFGH....
                  }
      
                  self.head = 0;
              } else if free >= tail_len {
                  // there is enough free space to copy the tail in one go,
                  // this means that we first shift the head forwards, and then
                  // copy the tail to the correct position.
                  //
                  // from: FGH....ABCDE
                  // to:   ...ABCDEFGH.
                  unsafe {
                      self.copy(head, tail, head_len);
                      // FGHABCDE....
                      self.copy_nonoverlapping(0, tail + head_len, tail_len);
                      // ...ABCDEFGH.
                  }
      
                  self.head = tail;
              } else {
                  // `free` is smaller than both `head_len` and `tail_len`.
                  // the general algorithm for this first moves the slices
                  // right next to each other and then uses `slice::rotate`
                  // to rotate them into place:
                  //
                  // initially:   HIJK..ABCDEFG
                  // step 1:      ..HIJKABCDEFG
                  // step 2:      ..ABCDEFGHIJK
                  //
                  // or:
                  //
                  // initially:   FGHIJK..ABCDE
                  // step 1:      FGHIJKABCDE..
                  // step 2:      ABCDEFGHIJK..
      
                  // pick the shorter of the 2 slices to reduce the amount
                  // of memory that needs to be moved around.
                  if head_len > tail_len {
                      // tail is shorter, so:
                      //  1. copy tail forwards
                      //  2. rotate used part of the buffer
                      //  3. update head to point to the new beginning (which is just `free`)
      
                      unsafe {
                          // if there is no free space in the buffer, then the slices are already
                          // right next to each other and we don't need to move any memory.
                          if free != 0 {
                              // because we only move the tail forward as much as there's free space
                              // behind it, we don't overwrite any elements of the head slice, and
                              // the slices end up right next to each other.
                              self.copy(0, free, tail_len);
                          }
      
                          // We just copied the tail right next to the head slice,
                          // so all of the elements in the range are initialized
                          let slice = &mut *self.buffer_range(free..self.capacity());
      
                          // because the deque wasn't contiguous, we know that `tail_len < self.len == slice.len()`,
                          // so this will never panic.
                          slice.rotate_left(tail_len);
      
                          // the used part of the buffer now is `free..self.capacity()`, so set
                          // `head` to the beginning of that range.
                          self.head = free;
                      }
                  } else {
                      // head is shorter so:
                      //  1. copy head backwards
                      //  2. rotate used part of the buffer
                      //  3. update head to point to the new beginning (which is the beginning of the buffer)
      
                      unsafe {
                          // if there is no free space in the buffer, then the slices are already
                          // right next to each other and we don't need to move any memory.
                          if free != 0 {
                              // copy the head slice to lie right behind the tail slice.
                              self.copy(self.head, tail_len, head_len);
                          }
      
                          // because we copied the head slice so that both slices lie right
                          // next to each other, all the elements in the range are initialized.
                          let slice = &mut *self.buffer_range(0..self.len);
      
                          // because the deque wasn't contiguous, we know that `head_len < self.len == slice.len()`
                          // so this will never panic.
                          slice.rotate_right(head_len);
      
                          // the used part of the buffer now is `0..self.len`, so set
                          // `head` to the beginning of that range.
                          self.head = 0;
                      }
                  }
              }
      
              unsafe { slice::from_raw_parts_mut(ptr.add(self.head), self.len) }
          }
      *)
      Definition make_contiguous (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.read (|
                  let _ :=
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.get_constant (| "core::mem::SizedTypeProperties::IS_ZST" |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            let _ :=
                              M.write (|
                                M.SubPointer.get_struct_record_field (|
                                  M.read (| self |),
                                  "alloc::collections::vec_deque::VecDeque",
                                  "head"
                                |),
                                Value.Integer 0
                              |) in
                            M.alloc (| Value.Tuple [] |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                      ]
                    |) in
                  let _ :=
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  M.call_closure (|
                                    M.get_associated_function (|
                                      Ty.apply
                                        (Ty.path "alloc::collections::vec_deque::VecDeque")
                                        [ T; A ],
                                      "is_contiguous",
                                      []
                                    |),
                                    [ M.read (| self |) ]
                                  |)
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (|
                              M.never_to_any (|
                                M.read (|
                                  M.return_ (|
                                    M.call_closure (|
                                      M.get_function (|
                                        "core::slice::raw::from_raw_parts_mut",
                                        [ T ]
                                      |),
                                      [
                                        M.call_closure (|
                                          M.get_associated_function (|
                                            Ty.apply (Ty.path "*mut") [ T ],
                                            "add",
                                            []
                                          |),
                                          [
                                            M.call_closure (|
                                              M.get_associated_function (|
                                                Ty.apply
                                                  (Ty.path
                                                    "alloc::collections::vec_deque::VecDeque")
                                                  [ T; A ],
                                                "ptr",
                                                []
                                              |),
                                              [ M.read (| self |) ]
                                            |);
                                            M.read (|
                                              M.SubPointer.get_struct_record_field (|
                                                M.read (| self |),
                                                "alloc::collections::vec_deque::VecDeque",
                                                "head"
                                              |)
                                            |)
                                          ]
                                        |);
                                        M.read (|
                                          M.SubPointer.get_struct_record_field (|
                                            M.read (| self |),
                                            "alloc::collections::vec_deque::VecDeque",
                                            "len"
                                          |)
                                        |)
                                      ]
                                    |)
                                  |)
                                |)
                              |)
                            |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                      ]
                    |) in
                  M.match_operator (|
                    self,
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ := M.read (| γ |) in
                          let γ1_0 :=
                            M.SubPointer.get_struct_record_field (|
                              γ,
                              "alloc::collections::vec_deque::VecDeque",
                              "head"
                            |) in
                          let γ1_1 :=
                            M.SubPointer.get_struct_record_field (|
                              γ,
                              "alloc::collections::vec_deque::VecDeque",
                              "len"
                            |) in
                          let head := M.copy (| γ1_0 |) in
                          let len := M.copy (| γ1_1 |) in
                          let ptr :=
                            M.alloc (|
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "alloc::collections::vec_deque::VecDeque")
                                    [ T; A ],
                                  "ptr",
                                  []
                                |),
                                [ M.read (| self |) ]
                              |)
                            |) in
                          let cap :=
                            M.alloc (|
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "alloc::collections::vec_deque::VecDeque")
                                    [ T; A ],
                                  "capacity",
                                  []
                                |),
                                [ M.read (| self |) ]
                              |)
                            |) in
                          let free :=
                            M.alloc (|
                              BinOp.Panic.sub (|
                                Integer.Usize,
                                M.read (| cap |),
                                M.read (| len |)
                              |)
                            |) in
                          let head_len :=
                            M.alloc (|
                              BinOp.Panic.sub (|
                                Integer.Usize,
                                M.read (| cap |),
                                M.read (| head |)
                              |)
                            |) in
                          let tail :=
                            M.alloc (|
                              BinOp.Panic.sub (|
                                Integer.Usize,
                                M.read (| len |),
                                M.read (| head_len |)
                              |)
                            |) in
                          let tail_len := M.copy (| tail |) in
                          let _ :=
                            M.match_operator (|
                              M.alloc (| Value.Tuple [] |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let γ :=
                                      M.use
                                        (M.alloc (|
                                          BinOp.Pure.ge (M.read (| free |)) (M.read (| head_len |))
                                        |)) in
                                    let _ :=
                                      M.is_constant_or_break_match (|
                                        M.read (| γ |),
                                        Value.Bool true
                                      |) in
                                    let _ :=
                                      let _ :=
                                        M.alloc (|
                                          M.call_closure (|
                                            M.get_associated_function (|
                                              Ty.apply
                                                (Ty.path "alloc::collections::vec_deque::VecDeque")
                                                [ T; A ],
                                              "copy",
                                              []
                                            |),
                                            [
                                              M.read (| self |);
                                              Value.Integer 0;
                                              M.read (| head_len |);
                                              M.read (| tail_len |)
                                            ]
                                          |)
                                        |) in
                                      let _ :=
                                        M.alloc (|
                                          M.call_closure (|
                                            M.get_associated_function (|
                                              Ty.apply
                                                (Ty.path "alloc::collections::vec_deque::VecDeque")
                                                [ T; A ],
                                              "copy_nonoverlapping",
                                              []
                                            |),
                                            [
                                              M.read (| self |);
                                              M.read (| head |);
                                              Value.Integer 0;
                                              M.read (| head_len |)
                                            ]
                                          |)
                                        |) in
                                      M.alloc (| Value.Tuple [] |) in
                                    let _ :=
                                      M.write (|
                                        M.SubPointer.get_struct_record_field (|
                                          M.read (| self |),
                                          "alloc::collections::vec_deque::VecDeque",
                                          "head"
                                        |),
                                        Value.Integer 0
                                      |) in
                                    M.alloc (| Value.Tuple [] |)));
                                fun γ =>
                                  ltac:(M.monadic
                                    (M.match_operator (|
                                      M.alloc (| Value.Tuple [] |),
                                      [
                                        fun γ =>
                                          ltac:(M.monadic
                                            (let γ :=
                                              M.use
                                                (M.alloc (|
                                                  BinOp.Pure.ge
                                                    (M.read (| free |))
                                                    (M.read (| tail_len |))
                                                |)) in
                                            let _ :=
                                              M.is_constant_or_break_match (|
                                                M.read (| γ |),
                                                Value.Bool true
                                              |) in
                                            let _ :=
                                              let _ :=
                                                M.alloc (|
                                                  M.call_closure (|
                                                    M.get_associated_function (|
                                                      Ty.apply
                                                        (Ty.path
                                                          "alloc::collections::vec_deque::VecDeque")
                                                        [ T; A ],
                                                      "copy",
                                                      []
                                                    |),
                                                    [
                                                      M.read (| self |);
                                                      M.read (| head |);
                                                      M.read (| tail |);
                                                      M.read (| head_len |)
                                                    ]
                                                  |)
                                                |) in
                                              let _ :=
                                                M.alloc (|
                                                  M.call_closure (|
                                                    M.get_associated_function (|
                                                      Ty.apply
                                                        (Ty.path
                                                          "alloc::collections::vec_deque::VecDeque")
                                                        [ T; A ],
                                                      "copy_nonoverlapping",
                                                      []
                                                    |),
                                                    [
                                                      M.read (| self |);
                                                      Value.Integer 0;
                                                      BinOp.Panic.add (|
                                                        Integer.Usize,
                                                        M.read (| tail |),
                                                        M.read (| head_len |)
                                                      |);
                                                      M.read (| tail_len |)
                                                    ]
                                                  |)
                                                |) in
                                              M.alloc (| Value.Tuple [] |) in
                                            let _ :=
                                              M.write (|
                                                M.SubPointer.get_struct_record_field (|
                                                  M.read (| self |),
                                                  "alloc::collections::vec_deque::VecDeque",
                                                  "head"
                                                |),
                                                M.read (| tail |)
                                              |) in
                                            M.alloc (| Value.Tuple [] |)));
                                        fun γ =>
                                          ltac:(M.monadic
                                            (M.match_operator (|
                                              M.alloc (| Value.Tuple [] |),
                                              [
                                                fun γ =>
                                                  ltac:(M.monadic
                                                    (let γ :=
                                                      M.use
                                                        (M.alloc (|
                                                          BinOp.Pure.gt
                                                            (M.read (| head_len |))
                                                            (M.read (| tail_len |))
                                                        |)) in
                                                    let _ :=
                                                      M.is_constant_or_break_match (|
                                                        M.read (| γ |),
                                                        Value.Bool true
                                                      |) in
                                                    let _ :=
                                                      M.match_operator (|
                                                        M.alloc (| Value.Tuple [] |),
                                                        [
                                                          fun γ =>
                                                            ltac:(M.monadic
                                                              (let γ :=
                                                                M.use
                                                                  (M.alloc (|
                                                                    BinOp.Pure.ne
                                                                      (M.read (| free |))
                                                                      (Value.Integer 0)
                                                                  |)) in
                                                              let _ :=
                                                                M.is_constant_or_break_match (|
                                                                  M.read (| γ |),
                                                                  Value.Bool true
                                                                |) in
                                                              let _ :=
                                                                M.alloc (|
                                                                  M.call_closure (|
                                                                    M.get_associated_function (|
                                                                      Ty.apply
                                                                        (Ty.path
                                                                          "alloc::collections::vec_deque::VecDeque")
                                                                        [ T; A ],
                                                                      "copy",
                                                                      []
                                                                    |),
                                                                    [
                                                                      M.read (| self |);
                                                                      Value.Integer 0;
                                                                      M.read (| free |);
                                                                      M.read (| tail_len |)
                                                                    ]
                                                                  |)
                                                                |) in
                                                              M.alloc (| Value.Tuple [] |)));
                                                          fun γ =>
                                                            ltac:(M.monadic
                                                              (M.alloc (| Value.Tuple [] |)))
                                                        ]
                                                      |) in
                                                    let slice :=
                                                      M.alloc (|
                                                        M.call_closure (|
                                                          M.get_associated_function (|
                                                            Ty.apply
                                                              (Ty.path
                                                                "alloc::collections::vec_deque::VecDeque")
                                                              [ T; A ],
                                                            "buffer_range",
                                                            []
                                                          |),
                                                          [
                                                            M.read (| self |);
                                                            Value.StructRecord
                                                              "core::ops::range::Range"
                                                              [
                                                                ("start", M.read (| free |));
                                                                ("end_",
                                                                  M.call_closure (|
                                                                    M.get_associated_function (|
                                                                      Ty.apply
                                                                        (Ty.path
                                                                          "alloc::collections::vec_deque::VecDeque")
                                                                        [ T; A ],
                                                                      "capacity",
                                                                      []
                                                                    |),
                                                                    [ M.read (| self |) ]
                                                                  |))
                                                              ]
                                                          ]
                                                        |)
                                                      |) in
                                                    let _ :=
                                                      M.alloc (|
                                                        M.call_closure (|
                                                          M.get_associated_function (|
                                                            Ty.apply (Ty.path "slice") [ T ],
                                                            "rotate_left",
                                                            []
                                                          |),
                                                          [
                                                            M.read (| slice |);
                                                            M.read (| tail_len |)
                                                          ]
                                                        |)
                                                      |) in
                                                    let _ :=
                                                      M.write (|
                                                        M.SubPointer.get_struct_record_field (|
                                                          M.read (| self |),
                                                          "alloc::collections::vec_deque::VecDeque",
                                                          "head"
                                                        |),
                                                        M.read (| free |)
                                                      |) in
                                                    M.alloc (| Value.Tuple [] |)));
                                                fun γ =>
                                                  ltac:(M.monadic
                                                    (let _ :=
                                                      M.match_operator (|
                                                        M.alloc (| Value.Tuple [] |),
                                                        [
                                                          fun γ =>
                                                            ltac:(M.monadic
                                                              (let γ :=
                                                                M.use
                                                                  (M.alloc (|
                                                                    BinOp.Pure.ne
                                                                      (M.read (| free |))
                                                                      (Value.Integer 0)
                                                                  |)) in
                                                              let _ :=
                                                                M.is_constant_or_break_match (|
                                                                  M.read (| γ |),
                                                                  Value.Bool true
                                                                |) in
                                                              let _ :=
                                                                M.alloc (|
                                                                  M.call_closure (|
                                                                    M.get_associated_function (|
                                                                      Ty.apply
                                                                        (Ty.path
                                                                          "alloc::collections::vec_deque::VecDeque")
                                                                        [ T; A ],
                                                                      "copy",
                                                                      []
                                                                    |),
                                                                    [
                                                                      M.read (| self |);
                                                                      M.read (|
                                                                        M.SubPointer.get_struct_record_field (|
                                                                          M.read (| self |),
                                                                          "alloc::collections::vec_deque::VecDeque",
                                                                          "head"
                                                                        |)
                                                                      |);
                                                                      M.read (| tail_len |);
                                                                      M.read (| head_len |)
                                                                    ]
                                                                  |)
                                                                |) in
                                                              M.alloc (| Value.Tuple [] |)));
                                                          fun γ =>
                                                            ltac:(M.monadic
                                                              (M.alloc (| Value.Tuple [] |)))
                                                        ]
                                                      |) in
                                                    let slice :=
                                                      M.alloc (|
                                                        M.call_closure (|
                                                          M.get_associated_function (|
                                                            Ty.apply
                                                              (Ty.path
                                                                "alloc::collections::vec_deque::VecDeque")
                                                              [ T; A ],
                                                            "buffer_range",
                                                            []
                                                          |),
                                                          [
                                                            M.read (| self |);
                                                            Value.StructRecord
                                                              "core::ops::range::Range"
                                                              [
                                                                ("start", Value.Integer 0);
                                                                ("end_",
                                                                  M.read (|
                                                                    M.SubPointer.get_struct_record_field (|
                                                                      M.read (| self |),
                                                                      "alloc::collections::vec_deque::VecDeque",
                                                                      "len"
                                                                    |)
                                                                  |))
                                                              ]
                                                          ]
                                                        |)
                                                      |) in
                                                    let _ :=
                                                      M.alloc (|
                                                        M.call_closure (|
                                                          M.get_associated_function (|
                                                            Ty.apply (Ty.path "slice") [ T ],
                                                            "rotate_right",
                                                            []
                                                          |),
                                                          [
                                                            M.read (| slice |);
                                                            M.read (| head_len |)
                                                          ]
                                                        |)
                                                      |) in
                                                    let _ :=
                                                      M.write (|
                                                        M.SubPointer.get_struct_record_field (|
                                                          M.read (| self |),
                                                          "alloc::collections::vec_deque::VecDeque",
                                                          "head"
                                                        |),
                                                        Value.Integer 0
                                                      |) in
                                                    M.alloc (| Value.Tuple [] |)))
                                              ]
                                            |)))
                                      ]
                                    |)))
                              ]
                            |) in
                          M.alloc (|
                            M.call_closure (|
                              M.get_function (| "core::slice::raw::from_raw_parts_mut", [ T ] |),
                              [
                                M.call_closure (|
                                  M.get_associated_function (|
                                    Ty.apply (Ty.path "*mut") [ T ],
                                    "add",
                                    []
                                  |),
                                  [
                                    M.read (| ptr |);
                                    M.read (|
                                      M.SubPointer.get_struct_record_field (|
                                        M.read (| self |),
                                        "alloc::collections::vec_deque::VecDeque",
                                        "head"
                                      |)
                                    |)
                                  ]
                                |);
                                M.read (|
                                  M.SubPointer.get_struct_record_field (|
                                    M.read (| self |),
                                    "alloc::collections::vec_deque::VecDeque",
                                    "len"
                                  |)
                                |)
                              ]
                            |)
                          |)))
                    ]
                  |)
                |)))
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_make_contiguous :
        forall (T A : Ty.t),
        M.IsAssociatedFunction (Self T A) "make_contiguous" (make_contiguous T A).
      
      (*
          pub fn rotate_left(&mut self, n: usize) {
              assert!(n <= self.len());
              let k = self.len - n;
              if n <= k {
                  unsafe { self.rotate_left_inner(n) }
              } else {
                  unsafe { self.rotate_right_inner(k) }
              }
          }
      *)
      Definition rotate_left (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match τ, α with
        | [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            M.read (|
              let _ :=
                M.match_operator (|
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ :=
                          M.use
                            (M.alloc (|
                              UnOp.Pure.not
                                (BinOp.Pure.le
                                  (M.read (| n |))
                                  (M.call_closure (|
                                    M.get_associated_function (|
                                      Ty.apply
                                        (Ty.path "alloc::collections::vec_deque::VecDeque")
                                        [ T; A ],
                                      "len",
                                      []
                                    |),
                                    [ M.read (| self |) ]
                                  |)))
                            |)) in
                        let _ :=
                          M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        M.alloc (|
                          M.never_to_any (|
                            M.call_closure (|
                              M.get_function (| "core::panicking::panic", [] |),
                              [ M.read (| Value.String "assertion failed: n <= self.len()" |) ]
                            |)
                          |)
                        |)));
                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                  ]
                |) in
              let k :=
                M.alloc (|
                  BinOp.Panic.sub (|
                    Integer.Usize,
                    M.read (|
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "alloc::collections::vec_deque::VecDeque",
                        "len"
                      |)
                    |),
                    M.read (| n |)
                  |)
                |) in
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use (M.alloc (| BinOp.Pure.le (M.read (| n |)) (M.read (| k |)) |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.apply (Ty.path "alloc::collections::vec_deque::VecDeque") [ T; A ],
                            "rotate_left_inner",
                            []
                          |),
                          [ M.read (| self |); M.read (| n |) ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.apply (Ty.path "alloc::collections::vec_deque::VecDeque") [ T; A ],
                            "rotate_right_inner",
                            []
                          |),
                          [ M.read (| self |); M.read (| k |) ]
                        |)
                      |)))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_rotate_left :
        forall (T A : Ty.t),
        M.IsAssociatedFunction (Self T A) "rotate_left" (rotate_left T A).
      
      (*
          pub fn rotate_right(&mut self, n: usize) {
              assert!(n <= self.len());
              let k = self.len - n;
              if n <= k {
                  unsafe { self.rotate_right_inner(n) }
              } else {
                  unsafe { self.rotate_left_inner(k) }
              }
          }
      *)
      Definition rotate_right (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match τ, α with
        | [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            M.read (|
              let _ :=
                M.match_operator (|
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ :=
                          M.use
                            (M.alloc (|
                              UnOp.Pure.not
                                (BinOp.Pure.le
                                  (M.read (| n |))
                                  (M.call_closure (|
                                    M.get_associated_function (|
                                      Ty.apply
                                        (Ty.path "alloc::collections::vec_deque::VecDeque")
                                        [ T; A ],
                                      "len",
                                      []
                                    |),
                                    [ M.read (| self |) ]
                                  |)))
                            |)) in
                        let _ :=
                          M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        M.alloc (|
                          M.never_to_any (|
                            M.call_closure (|
                              M.get_function (| "core::panicking::panic", [] |),
                              [ M.read (| Value.String "assertion failed: n <= self.len()" |) ]
                            |)
                          |)
                        |)));
                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                  ]
                |) in
              let k :=
                M.alloc (|
                  BinOp.Panic.sub (|
                    Integer.Usize,
                    M.read (|
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "alloc::collections::vec_deque::VecDeque",
                        "len"
                      |)
                    |),
                    M.read (| n |)
                  |)
                |) in
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use (M.alloc (| BinOp.Pure.le (M.read (| n |)) (M.read (| k |)) |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.apply (Ty.path "alloc::collections::vec_deque::VecDeque") [ T; A ],
                            "rotate_right_inner",
                            []
                          |),
                          [ M.read (| self |); M.read (| n |) ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.apply (Ty.path "alloc::collections::vec_deque::VecDeque") [ T; A ],
                            "rotate_left_inner",
                            []
                          |),
                          [ M.read (| self |); M.read (| k |) ]
                        |)
                      |)))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_rotate_right :
        forall (T A : Ty.t),
        M.IsAssociatedFunction (Self T A) "rotate_right" (rotate_right T A).
      
      (*
          unsafe fn rotate_left_inner(&mut self, mid: usize) {
              debug_assert!(mid * 2 <= self.len());
              unsafe {
                  self.wrap_copy(self.head, self.to_physical_idx(self.len), mid);
              }
              self.head = self.to_physical_idx(mid);
          }
      *)
      Definition rotate_left_inner (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match τ, α with
        | [], [ self; mid ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let mid := M.alloc (| mid |) in
            M.read (|
              let _ :=
                M.match_operator (|
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.use (M.alloc (| Value.Bool true |)) in
                        let _ :=
                          M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        let _ :=
                          M.match_operator (|
                            M.alloc (| Value.Tuple [] |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ :=
                                    M.use
                                      (M.alloc (|
                                        UnOp.Pure.not
                                          (BinOp.Pure.le
                                            (BinOp.Panic.mul (|
                                              Integer.Usize,
                                              M.read (| mid |),
                                              Value.Integer 2
                                            |))
                                            (M.call_closure (|
                                              M.get_associated_function (|
                                                Ty.apply
                                                  (Ty.path
                                                    "alloc::collections::vec_deque::VecDeque")
                                                  [ T; A ],
                                                "len",
                                                []
                                              |),
                                              [ M.read (| self |) ]
                                            |)))
                                      |)) in
                                  let _ :=
                                    M.is_constant_or_break_match (|
                                      M.read (| γ |),
                                      Value.Bool true
                                    |) in
                                  M.alloc (|
                                    M.never_to_any (|
                                      M.call_closure (|
                                        M.get_function (| "core::panicking::panic", [] |),
                                        [
                                          M.read (|
                                            Value.String "assertion failed: mid * 2 <= self.len()"
                                          |)
                                        ]
                                      |)
                                    |)
                                  |)));
                              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                            ]
                          |) in
                        M.alloc (| Value.Tuple [] |)));
                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                  ]
                |) in
              let _ :=
                let _ :=
                  M.alloc (|
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "alloc::collections::vec_deque::VecDeque") [ T; A ],
                        "wrap_copy",
                        []
                      |),
                      [
                        M.read (| self |);
                        M.read (|
                          M.SubPointer.get_struct_record_field (|
                            M.read (| self |),
                            "alloc::collections::vec_deque::VecDeque",
                            "head"
                          |)
                        |);
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.apply (Ty.path "alloc::collections::vec_deque::VecDeque") [ T; A ],
                            "to_physical_idx",
                            []
                          |),
                          [
                            M.read (| self |);
                            M.read (|
                              M.SubPointer.get_struct_record_field (|
                                M.read (| self |),
                                "alloc::collections::vec_deque::VecDeque",
                                "len"
                              |)
                            |)
                          ]
                        |);
                        M.read (| mid |)
                      ]
                    |)
                  |) in
                M.alloc (| Value.Tuple [] |) in
              let _ :=
                M.write (|
                  M.SubPointer.get_struct_record_field (|
                    M.read (| self |),
                    "alloc::collections::vec_deque::VecDeque",
                    "head"
                  |),
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply (Ty.path "alloc::collections::vec_deque::VecDeque") [ T; A ],
                      "to_physical_idx",
                      []
                    |),
                    [ M.read (| self |); M.read (| mid |) ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_rotate_left_inner :
        forall (T A : Ty.t),
        M.IsAssociatedFunction (Self T A) "rotate_left_inner" (rotate_left_inner T A).
      
      (*
          unsafe fn rotate_right_inner(&mut self, k: usize) {
              debug_assert!(k * 2 <= self.len());
              self.head = self.wrap_sub(self.head, k);
              unsafe {
                  self.wrap_copy(self.to_physical_idx(self.len), self.head, k);
              }
          }
      *)
      Definition rotate_right_inner (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match τ, α with
        | [], [ self; k ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let k := M.alloc (| k |) in
            M.read (|
              let _ :=
                M.match_operator (|
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.use (M.alloc (| Value.Bool true |)) in
                        let _ :=
                          M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        let _ :=
                          M.match_operator (|
                            M.alloc (| Value.Tuple [] |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ :=
                                    M.use
                                      (M.alloc (|
                                        UnOp.Pure.not
                                          (BinOp.Pure.le
                                            (BinOp.Panic.mul (|
                                              Integer.Usize,
                                              M.read (| k |),
                                              Value.Integer 2
                                            |))
                                            (M.call_closure (|
                                              M.get_associated_function (|
                                                Ty.apply
                                                  (Ty.path
                                                    "alloc::collections::vec_deque::VecDeque")
                                                  [ T; A ],
                                                "len",
                                                []
                                              |),
                                              [ M.read (| self |) ]
                                            |)))
                                      |)) in
                                  let _ :=
                                    M.is_constant_or_break_match (|
                                      M.read (| γ |),
                                      Value.Bool true
                                    |) in
                                  M.alloc (|
                                    M.never_to_any (|
                                      M.call_closure (|
                                        M.get_function (| "core::panicking::panic", [] |),
                                        [
                                          M.read (|
                                            Value.String "assertion failed: k * 2 <= self.len()"
                                          |)
                                        ]
                                      |)
                                    |)
                                  |)));
                              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                            ]
                          |) in
                        M.alloc (| Value.Tuple [] |)));
                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                  ]
                |) in
              let _ :=
                M.write (|
                  M.SubPointer.get_struct_record_field (|
                    M.read (| self |),
                    "alloc::collections::vec_deque::VecDeque",
                    "head"
                  |),
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply (Ty.path "alloc::collections::vec_deque::VecDeque") [ T; A ],
                      "wrap_sub",
                      []
                    |),
                    [
                      M.read (| self |);
                      M.read (|
                        M.SubPointer.get_struct_record_field (|
                          M.read (| self |),
                          "alloc::collections::vec_deque::VecDeque",
                          "head"
                        |)
                      |);
                      M.read (| k |)
                    ]
                  |)
                |) in
              let _ :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply (Ty.path "alloc::collections::vec_deque::VecDeque") [ T; A ],
                      "wrap_copy",
                      []
                    |),
                    [
                      M.read (| self |);
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "alloc::collections::vec_deque::VecDeque") [ T; A ],
                          "to_physical_idx",
                          []
                        |),
                        [
                          M.read (| self |);
                          M.read (|
                            M.SubPointer.get_struct_record_field (|
                              M.read (| self |),
                              "alloc::collections::vec_deque::VecDeque",
                              "len"
                            |)
                          |)
                        ]
                      |);
                      M.read (|
                        M.SubPointer.get_struct_record_field (|
                          M.read (| self |),
                          "alloc::collections::vec_deque::VecDeque",
                          "head"
                        |)
                      |);
                      M.read (| k |)
                    ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_rotate_right_inner :
        forall (T A : Ty.t),
        M.IsAssociatedFunction (Self T A) "rotate_right_inner" (rotate_right_inner T A).
      
      (*
          pub fn binary_search(&self, x: &T) -> Result<usize, usize>
          where
              T: Ord,
          {
              self.binary_search_by(|e| e.cmp(x))
          }
      *)
      Definition binary_search (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match τ, α with
        | [], [ self; x ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let x := M.alloc (| x |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply (Ty.path "alloc::collections::vec_deque::VecDeque") [ T; A ],
                "binary_search_by",
                [
                  Ty.function
                    [ Ty.tuple [ Ty.apply (Ty.path "&") [ T ] ] ]
                    (Ty.path "core::cmp::Ordering")
                ]
              |),
              [
                M.read (| self |);
                M.closure
                  (fun γ =>
                    ltac:(M.monadic
                      match γ with
                      | [ α0 ] =>
                        M.match_operator (|
                          M.alloc (| α0 |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let e := M.copy (| γ |) in
                                M.call_closure (|
                                  M.get_trait_method (| "core::cmp::Ord", T, [], "cmp", [] |),
                                  [ M.read (| e |); M.read (| x |) ]
                                |)))
                          ]
                        |)
                      | _ => M.impossible (||)
                      end))
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_binary_search :
        forall (T A : Ty.t),
        M.IsAssociatedFunction (Self T A) "binary_search" (binary_search T A).
      
      (*
          pub fn binary_search_by<'a, F>(&'a self, mut f: F) -> Result<usize, usize>
          where
              F: FnMut(&'a T) -> Ordering,
          {
              let (front, back) = self.as_slices();
              let cmp_back = back.first().map(|elem| f(elem));
      
              if let Some(Ordering::Equal) = cmp_back {
                  Ok(front.len())
              } else if let Some(Ordering::Less) = cmp_back {
                  back.binary_search_by(f).map(|idx| idx + front.len()).map_err(|idx| idx + front.len())
              } else {
                  front.binary_search_by(f)
              }
          }
      *)
      Definition binary_search_by (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match τ, α with
        | [ F ], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.read (|
              M.match_operator (|
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply (Ty.path "alloc::collections::vec_deque::VecDeque") [ T; A ],
                      "as_slices",
                      []
                    |),
                    [ M.read (| self |) ]
                  |)
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      let front := M.copy (| γ0_0 |) in
                      let back := M.copy (| γ0_1 |) in
                      let cmp_back :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply
                                (Ty.path "core::option::Option")
                                [ Ty.apply (Ty.path "&") [ T ] ],
                              "map",
                              [
                                Ty.path "core::cmp::Ordering";
                                Ty.function
                                  [ Ty.tuple [ Ty.apply (Ty.path "&") [ T ] ] ]
                                  (Ty.path "core::cmp::Ordering")
                              ]
                            |),
                            [
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "slice") [ T ],
                                  "first",
                                  []
                                |),
                                [ M.read (| back |) ]
                              |);
                              M.closure
                                (fun γ =>
                                  ltac:(M.monadic
                                    match γ with
                                    | [ α0 ] =>
                                      M.match_operator (|
                                        M.alloc (| α0 |),
                                        [
                                          fun γ =>
                                            ltac:(M.monadic
                                              (let elem := M.copy (| γ |) in
                                              M.call_closure (|
                                                M.get_trait_method (|
                                                  "core::ops::function::FnMut",
                                                  F,
                                                  [ Ty.tuple [ Ty.apply (Ty.path "&") [ T ] ] ],
                                                  "call_mut",
                                                  []
                                                |),
                                                [ f; Value.Tuple [ M.read (| elem |) ] ]
                                              |)))
                                        ]
                                      |)
                                    | _ => M.impossible (||)
                                    end))
                            ]
                          |)
                        |) in
                      M.match_operator (|
                        M.alloc (| Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ := cmp_back in
                              let γ0_0 :=
                                M.SubPointer.get_struct_tuple_field (|
                                  γ,
                                  "core::option::Option::Some",
                                  0
                                |) in
                              M.alloc (|
                                Value.StructTuple
                                  "core::result::Result::Ok"
                                  [
                                    M.call_closure (|
                                      M.get_associated_function (|
                                        Ty.apply (Ty.path "slice") [ T ],
                                        "len",
                                        []
                                      |),
                                      [ M.read (| front |) ]
                                    |)
                                  ]
                              |)));
                          fun γ =>
                            ltac:(M.monadic
                              (M.match_operator (|
                                M.alloc (| Value.Tuple [] |),
                                [
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let γ := cmp_back in
                                      let γ0_0 :=
                                        M.SubPointer.get_struct_tuple_field (|
                                          γ,
                                          "core::option::Option::Some",
                                          0
                                        |) in
                                      M.alloc (|
                                        M.call_closure (|
                                          M.get_associated_function (|
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              [ Ty.path "usize"; Ty.path "usize" ],
                                            "map_err",
                                            [
                                              Ty.path "usize";
                                              Ty.function
                                                [ Ty.tuple [ Ty.path "usize" ] ]
                                                (Ty.path "usize")
                                            ]
                                          |),
                                          [
                                            M.call_closure (|
                                              M.get_associated_function (|
                                                Ty.apply
                                                  (Ty.path "core::result::Result")
                                                  [ Ty.path "usize"; Ty.path "usize" ],
                                                "map",
                                                [
                                                  Ty.path "usize";
                                                  Ty.function
                                                    [ Ty.tuple [ Ty.path "usize" ] ]
                                                    (Ty.path "usize")
                                                ]
                                              |),
                                              [
                                                M.call_closure (|
                                                  M.get_associated_function (|
                                                    Ty.apply (Ty.path "slice") [ T ],
                                                    "binary_search_by",
                                                    [ F ]
                                                  |),
                                                  [ M.read (| back |); M.read (| f |) ]
                                                |);
                                                M.closure
                                                  (fun γ =>
                                                    ltac:(M.monadic
                                                      match γ with
                                                      | [ α0 ] =>
                                                        M.match_operator (|
                                                          M.alloc (| α0 |),
                                                          [
                                                            fun γ =>
                                                              ltac:(M.monadic
                                                                (let idx := M.copy (| γ |) in
                                                                BinOp.Panic.add (|
                                                                  Integer.Usize,
                                                                  M.read (| idx |),
                                                                  M.call_closure (|
                                                                    M.get_associated_function (|
                                                                      Ty.apply
                                                                        (Ty.path "slice")
                                                                        [ T ],
                                                                      "len",
                                                                      []
                                                                    |),
                                                                    [ M.read (| front |) ]
                                                                  |)
                                                                |)))
                                                          ]
                                                        |)
                                                      | _ => M.impossible (||)
                                                      end))
                                              ]
                                            |);
                                            M.closure
                                              (fun γ =>
                                                ltac:(M.monadic
                                                  match γ with
                                                  | [ α0 ] =>
                                                    M.match_operator (|
                                                      M.alloc (| α0 |),
                                                      [
                                                        fun γ =>
                                                          ltac:(M.monadic
                                                            (let idx := M.copy (| γ |) in
                                                            BinOp.Panic.add (|
                                                              Integer.Usize,
                                                              M.read (| idx |),
                                                              M.call_closure (|
                                                                M.get_associated_function (|
                                                                  Ty.apply (Ty.path "slice") [ T ],
                                                                  "len",
                                                                  []
                                                                |),
                                                                [ M.read (| front |) ]
                                                              |)
                                                            |)))
                                                      ]
                                                    |)
                                                  | _ => M.impossible (||)
                                                  end))
                                          ]
                                        |)
                                      |)));
                                  fun γ =>
                                    ltac:(M.monadic
                                      (M.alloc (|
                                        M.call_closure (|
                                          M.get_associated_function (|
                                            Ty.apply (Ty.path "slice") [ T ],
                                            "binary_search_by",
                                            [ F ]
                                          |),
                                          [ M.read (| front |); M.read (| f |) ]
                                        |)
                                      |)))
                                ]
                              |)))
                        ]
                      |)))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_binary_search_by :
        forall (T A : Ty.t),
        M.IsAssociatedFunction (Self T A) "binary_search_by" (binary_search_by T A).
      
      (*
          pub fn binary_search_by_key<'a, B, F>(&'a self, b: &B, mut f: F) -> Result<usize, usize>
          where
              F: FnMut(&'a T) -> B,
              B: Ord,
          {
              self.binary_search_by(|k| f(k).cmp(b))
          }
      *)
      Definition binary_search_by_key (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match τ, α with
        | [ B; F ], [ self; b; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let b := M.alloc (| b |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply (Ty.path "alloc::collections::vec_deque::VecDeque") [ T; A ],
                "binary_search_by",
                [
                  Ty.function
                    [ Ty.tuple [ Ty.apply (Ty.path "&") [ T ] ] ]
                    (Ty.path "core::cmp::Ordering")
                ]
              |),
              [
                M.read (| self |);
                M.closure
                  (fun γ =>
                    ltac:(M.monadic
                      match γ with
                      | [ α0 ] =>
                        M.match_operator (|
                          M.alloc (| α0 |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let k := M.copy (| γ |) in
                                M.call_closure (|
                                  M.get_trait_method (| "core::cmp::Ord", B, [], "cmp", [] |),
                                  [
                                    M.alloc (|
                                      M.call_closure (|
                                        M.get_trait_method (|
                                          "core::ops::function::FnMut",
                                          F,
                                          [ Ty.tuple [ Ty.apply (Ty.path "&") [ T ] ] ],
                                          "call_mut",
                                          []
                                        |),
                                        [ f; Value.Tuple [ M.read (| k |) ] ]
                                      |)
                                    |);
                                    M.read (| b |)
                                  ]
                                |)))
                          ]
                        |)
                      | _ => M.impossible (||)
                      end))
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_binary_search_by_key :
        forall (T A : Ty.t),
        M.IsAssociatedFunction (Self T A) "binary_search_by_key" (binary_search_by_key T A).
      
      (*
          pub fn partition_point<P>(&self, mut pred: P) -> usize
          where
              P: FnMut(&T) -> bool,
          {
              let (front, back) = self.as_slices();
      
              if let Some(true) = back.first().map(|v| pred(v)) {
                  back.partition_point(pred) + front.len()
              } else {
                  front.partition_point(pred)
              }
          }
      *)
      Definition partition_point (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match τ, α with
        | [ P ], [ self; pred ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let pred := M.alloc (| pred |) in
            M.read (|
              M.match_operator (|
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply (Ty.path "alloc::collections::vec_deque::VecDeque") [ T; A ],
                      "as_slices",
                      []
                    |),
                    [ M.read (| self |) ]
                  |)
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      let front := M.copy (| γ0_0 |) in
                      let back := M.copy (| γ0_1 |) in
                      M.match_operator (|
                        M.alloc (| Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.alloc (|
                                  M.call_closure (|
                                    M.get_associated_function (|
                                      Ty.apply
                                        (Ty.path "core::option::Option")
                                        [ Ty.apply (Ty.path "&") [ T ] ],
                                      "map",
                                      [
                                        Ty.path "bool";
                                        Ty.function
                                          [ Ty.tuple [ Ty.apply (Ty.path "&") [ T ] ] ]
                                          (Ty.path "bool")
                                      ]
                                    |),
                                    [
                                      M.call_closure (|
                                        M.get_associated_function (|
                                          Ty.apply (Ty.path "slice") [ T ],
                                          "first",
                                          []
                                        |),
                                        [ M.read (| back |) ]
                                      |);
                                      M.closure
                                        (fun γ =>
                                          ltac:(M.monadic
                                            match γ with
                                            | [ α0 ] =>
                                              M.match_operator (|
                                                M.alloc (| α0 |),
                                                [
                                                  fun γ =>
                                                    ltac:(M.monadic
                                                      (let v := M.copy (| γ |) in
                                                      M.call_closure (|
                                                        M.get_trait_method (|
                                                          "core::ops::function::FnMut",
                                                          P,
                                                          [
                                                            Ty.tuple
                                                              [ Ty.apply (Ty.path "&") [ T ] ]
                                                          ],
                                                          "call_mut",
                                                          []
                                                        |),
                                                        [ pred; Value.Tuple [ M.read (| v |) ] ]
                                                      |)))
                                                ]
                                              |)
                                            | _ => M.impossible (||)
                                            end))
                                    ]
                                  |)
                                |) in
                              let γ0_0 :=
                                M.SubPointer.get_struct_tuple_field (|
                                  γ,
                                  "core::option::Option::Some",
                                  0
                                |) in
                              let _ :=
                                M.is_constant_or_break_match (|
                                  M.read (| γ0_0 |),
                                  Value.Bool true
                                |) in
                              M.alloc (|
                                BinOp.Panic.add (|
                                  Integer.Usize,
                                  M.call_closure (|
                                    M.get_associated_function (|
                                      Ty.apply (Ty.path "slice") [ T ],
                                      "partition_point",
                                      [ P ]
                                    |),
                                    [ M.read (| back |); M.read (| pred |) ]
                                  |),
                                  M.call_closure (|
                                    M.get_associated_function (|
                                      Ty.apply (Ty.path "slice") [ T ],
                                      "len",
                                      []
                                    |),
                                    [ M.read (| front |) ]
                                  |)
                                |)
                              |)));
                          fun γ =>
                            ltac:(M.monadic
                              (M.alloc (|
                                M.call_closure (|
                                  M.get_associated_function (|
                                    Ty.apply (Ty.path "slice") [ T ],
                                    "partition_point",
                                    [ P ]
                                  |),
                                  [ M.read (| front |); M.read (| pred |) ]
                                |)
                              |)))
                        ]
                      |)))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_partition_point :
        forall (T A : Ty.t),
        M.IsAssociatedFunction (Self T A) "partition_point" (partition_point T A).
      (*
          pub fn resize(&mut self, new_len: usize, value: T) {
              if new_len > self.len() {
                  let extra = new_len - self.len();
                  self.extend(repeat_n(value, extra))
              } else {
                  self.truncate(new_len);
              }
          }
      *)
      Definition resize (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match τ, α with
        | [], [ self; new_len; value ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let new_len := M.alloc (| new_len |) in
            let value := M.alloc (| value |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            BinOp.Pure.gt
                              (M.read (| new_len |))
                              (M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "alloc::collections::vec_deque::VecDeque")
                                    [ T; A ],
                                  "len",
                                  []
                                |),
                                [ M.read (| self |) ]
                              |))
                          |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      let extra :=
                        M.alloc (|
                          BinOp.Panic.sub (|
                            Integer.Usize,
                            M.read (| new_len |),
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "alloc::collections::vec_deque::VecDeque")
                                  [ T; A ],
                                "len",
                                []
                              |),
                              [ M.read (| self |) ]
                            |)
                          |)
                        |) in
                      M.alloc (|
                        M.call_closure (|
                          M.get_trait_method (|
                            "core::iter::traits::collect::Extend",
                            Ty.apply (Ty.path "alloc::collections::vec_deque::VecDeque") [ T; A ],
                            [ T ],
                            "extend",
                            [ Ty.apply (Ty.path "core::iter::sources::repeat_n::RepeatN") [ T ] ]
                          |),
                          [
                            M.read (| self |);
                            M.call_closure (|
                              M.get_function (| "core::iter::sources::repeat_n::repeat_n", [ T ] |),
                              [ M.read (| value |); M.read (| extra |) ]
                            |)
                          ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let _ :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply (Ty.path "alloc::collections::vec_deque::VecDeque") [ T; A ],
                              "truncate",
                              []
                            |),
                            [ M.read (| self |); M.read (| new_len |) ]
                          |)
                        |) in
                      M.alloc (| Value.Tuple [] |)))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_resize :
        forall (T A : Ty.t),
        M.IsAssociatedFunction (Self T A) "resize" (resize T A).
    End Impl_alloc_collections_vec_deque_VecDeque_T_A.
    
    Module Impl_alloc_collections_vec_deque_VecDeque_T_alloc_alloc_Global.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply
          (Ty.path "alloc::collections::vec_deque::VecDeque")
          [ T; Ty.path "alloc::alloc::Global" ].
      
      (*
          pub const fn new() -> VecDeque<T> {
              // FIXME: This should just be `VecDeque::new_in(Global)` once that hits stable.
              VecDeque { head: 0, len: 0, buf: RawVec::NEW }
          }
      *)
      Definition new (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [] =>
          ltac:(M.monadic
            (Value.StructRecord
              "alloc::collections::vec_deque::VecDeque"
              [
                ("head", Value.Integer 0);
                ("len", Value.Integer 0);
                ("buf", M.read (| M.get_constant (| "alloc::raw_vec::NEW" |) |))
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_new :
        forall (T : Ty.t),
        M.IsAssociatedFunction (Self T) "new" (new T).
      
      (*
          pub fn with_capacity(capacity: usize) -> VecDeque<T> {
              Self::with_capacity_in(capacity, Global)
          }
      *)
      Definition with_capacity (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ capacity ] =>
          ltac:(M.monadic
            (let capacity := M.alloc (| capacity |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply
                  (Ty.path "alloc::collections::vec_deque::VecDeque")
                  [ T; Ty.path "alloc::alloc::Global" ],
                "with_capacity_in",
                []
              |),
              [ M.read (| capacity |); Value.StructTuple "alloc::alloc::Global" [] ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_with_capacity :
        forall (T : Ty.t),
        M.IsAssociatedFunction (Self T) "with_capacity" (with_capacity T).
    End Impl_alloc_collections_vec_deque_VecDeque_T_alloc_alloc_Global.
    
    
    
    (*
    fn wrap_index(logical_index: usize, capacity: usize) -> usize {
        debug_assert!(
            (logical_index == 0 && capacity == 0)
                || logical_index < capacity
                || (logical_index - capacity) < capacity
        );
        if logical_index >= capacity { logical_index - capacity } else { logical_index }
    }
    *)
    Definition wrap_index (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ logical_index; capacity ] =>
        ltac:(M.monadic
          (let logical_index := M.alloc (| logical_index |) in
          let capacity := M.alloc (| capacity |) in
          M.read (|
            let _ :=
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.use (M.alloc (| Value.Bool true |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      let _ :=
                        M.match_operator (|
                          M.alloc (| Value.Tuple [] |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ :=
                                  M.use
                                    (M.alloc (|
                                      UnOp.Pure.not
                                        (LogicalOp.or (|
                                          LogicalOp.or (|
                                            LogicalOp.and (|
                                              BinOp.Pure.eq
                                                (M.read (| logical_index |))
                                                (Value.Integer 0),
                                              ltac:(M.monadic
                                                (BinOp.Pure.eq
                                                  (M.read (| capacity |))
                                                  (Value.Integer 0)))
                                            |),
                                            ltac:(M.monadic
                                              (BinOp.Pure.lt
                                                (M.read (| logical_index |))
                                                (M.read (| capacity |))))
                                          |),
                                          ltac:(M.monadic
                                            (BinOp.Pure.lt
                                              (BinOp.Panic.sub (|
                                                Integer.Usize,
                                                M.read (| logical_index |),
                                                M.read (| capacity |)
                                              |))
                                              (M.read (| capacity |))))
                                        |))
                                    |)) in
                                let _ :=
                                  M.is_constant_or_break_match (|
                                    M.read (| γ |),
                                    Value.Bool true
                                  |) in
                                M.alloc (|
                                  M.never_to_any (|
                                    M.call_closure (|
                                      M.get_function (| "core::panicking::panic", [] |),
                                      [
                                        M.read (|
                                          Value.String
                                            "assertion failed: (logical_index == 0 && capacity == 0) || logical_index < capacity ||
    (logical_index - capacity) < capacity"
                                        |)
                                      ]
                                    |)
                                  |)
                                |)));
                            fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                          ]
                        |) in
                      M.alloc (| Value.Tuple [] |)));
                  fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                ]
              |) in
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          BinOp.Pure.ge (M.read (| logical_index |)) (M.read (| capacity |))
                        |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (|
                      BinOp.Panic.sub (|
                        Integer.Usize,
                        M.read (| logical_index |),
                        M.read (| capacity |)
                      |)
                    |)));
                fun γ => ltac:(M.monadic logical_index)
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Function_wrap_index : M.IsFunction "alloc::collections::vec_deque::wrap_index" wrap_index.
    
    Module Impl_core_cmp_PartialEq_where_core_cmp_PartialEq_T_where_core_alloc_Allocator_A_for_alloc_collections_vec_deque_VecDeque_T_A.
      Definition Self (T A : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "alloc::collections::vec_deque::VecDeque") [ T; A ].
      
      (*
          fn eq(&self, other: &Self) -> bool {
              if self.len != other.len() {
                  return false;
              }
              let (sa, sb) = self.as_slices();
              let (oa, ob) = other.as_slices();
              if sa.len() == oa.len() {
                  sa == oa && sb == ob
              } else if sa.len() < oa.len() {
                  // Always divisible in three sections, for example:
                  // self:  [a b c|d e f]
                  // other: [0 1 2 3|4 5]
                  // front = 3, mid = 1,
                  // [a b c] == [0 1 2] && [d] == [3] && [e f] == [4 5]
                  let front = sa.len();
                  let mid = oa.len() - front;
      
                  let (oa_front, oa_mid) = oa.split_at(front);
                  let (sb_mid, sb_back) = sb.split_at(mid);
                  debug_assert_eq!(sa.len(), oa_front.len());
                  debug_assert_eq!(sb_mid.len(), oa_mid.len());
                  debug_assert_eq!(sb_back.len(), ob.len());
                  sa == oa_front && sb_mid == oa_mid && sb_back == ob
              } else {
                  let front = oa.len();
                  let mid = sa.len() - front;
      
                  let (sa_front, sa_mid) = sa.split_at(front);
                  let (ob_mid, ob_back) = ob.split_at(mid);
                  debug_assert_eq!(sa_front.len(), oa.len());
                  debug_assert_eq!(sa_mid.len(), ob_mid.len());
                  debug_assert_eq!(sb.len(), ob_back.len());
                  sa_front == oa && sa_mid == ob_mid && sb == ob_back
              }
          }
      *)
      Definition eq (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.read (|
                  let _ :=
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  BinOp.Pure.ne
                                    (M.read (|
                                      M.SubPointer.get_struct_record_field (|
                                        M.read (| self |),
                                        "alloc::collections::vec_deque::VecDeque",
                                        "len"
                                      |)
                                    |))
                                    (M.call_closure (|
                                      M.get_associated_function (|
                                        Ty.apply
                                          (Ty.path "alloc::collections::vec_deque::VecDeque")
                                          [ T; A ],
                                        "len",
                                        []
                                      |),
                                      [ M.read (| other |) ]
                                    |))
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (|
                              M.never_to_any (| M.read (| M.return_ (| Value.Bool false |) |) |)
                            |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                      ]
                    |) in
                  M.match_operator (|
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "alloc::collections::vec_deque::VecDeque") [ T; A ],
                          "as_slices",
                          []
                        |),
                        [ M.read (| self |) ]
                      |)
                    |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                          let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                          let sa := M.copy (| γ0_0 |) in
                          let sb := M.copy (| γ0_1 |) in
                          M.match_operator (|
                            M.alloc (|
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "alloc::collections::vec_deque::VecDeque")
                                    [ T; A ],
                                  "as_slices",
                                  []
                                |),
                                [ M.read (| other |) ]
                              |)
                            |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                                  let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                  let oa := M.copy (| γ0_0 |) in
                                  let ob := M.copy (| γ0_1 |) in
                                  M.match_operator (|
                                    M.alloc (| Value.Tuple [] |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let γ :=
                                            M.use
                                              (M.alloc (|
                                                BinOp.Pure.eq
                                                  (M.call_closure (|
                                                    M.get_associated_function (|
                                                      Ty.apply (Ty.path "slice") [ T ],
                                                      "len",
                                                      []
                                                    |),
                                                    [ M.read (| sa |) ]
                                                  |))
                                                  (M.call_closure (|
                                                    M.get_associated_function (|
                                                      Ty.apply (Ty.path "slice") [ T ],
                                                      "len",
                                                      []
                                                    |),
                                                    [ M.read (| oa |) ]
                                                  |))
                                              |)) in
                                          let _ :=
                                            M.is_constant_or_break_match (|
                                              M.read (| γ |),
                                              Value.Bool true
                                            |) in
                                          M.alloc (|
                                            LogicalOp.and (|
                                              M.call_closure (|
                                                M.get_trait_method (|
                                                  "core::cmp::PartialEq",
                                                  Ty.apply
                                                    (Ty.path "&")
                                                    [ Ty.apply (Ty.path "slice") [ T ] ],
                                                  [
                                                    Ty.apply
                                                      (Ty.path "&")
                                                      [ Ty.apply (Ty.path "slice") [ T ] ]
                                                  ],
                                                  "eq",
                                                  []
                                                |),
                                                [ sa; oa ]
                                              |),
                                              ltac:(M.monadic
                                                (M.call_closure (|
                                                  M.get_trait_method (|
                                                    "core::cmp::PartialEq",
                                                    Ty.apply
                                                      (Ty.path "&")
                                                      [ Ty.apply (Ty.path "slice") [ T ] ],
                                                    [
                                                      Ty.apply
                                                        (Ty.path "&")
                                                        [ Ty.apply (Ty.path "slice") [ T ] ]
                                                    ],
                                                    "eq",
                                                    []
                                                  |),
                                                  [ sb; ob ]
                                                |)))
                                            |)
                                          |)));
                                      fun γ =>
                                        ltac:(M.monadic
                                          (M.match_operator (|
                                            M.alloc (| Value.Tuple [] |),
                                            [
                                              fun γ =>
                                                ltac:(M.monadic
                                                  (let γ :=
                                                    M.use
                                                      (M.alloc (|
                                                        BinOp.Pure.lt
                                                          (M.call_closure (|
                                                            M.get_associated_function (|
                                                              Ty.apply (Ty.path "slice") [ T ],
                                                              "len",
                                                              []
                                                            |),
                                                            [ M.read (| sa |) ]
                                                          |))
                                                          (M.call_closure (|
                                                            M.get_associated_function (|
                                                              Ty.apply (Ty.path "slice") [ T ],
                                                              "len",
                                                              []
                                                            |),
                                                            [ M.read (| oa |) ]
                                                          |))
                                                      |)) in
                                                  let _ :=
                                                    M.is_constant_or_break_match (|
                                                      M.read (| γ |),
                                                      Value.Bool true
                                                    |) in
                                                  let front :=
                                                    M.alloc (|
                                                      M.call_closure (|
                                                        M.get_associated_function (|
                                                          Ty.apply (Ty.path "slice") [ T ],
                                                          "len",
                                                          []
                                                        |),
                                                        [ M.read (| sa |) ]
                                                      |)
                                                    |) in
                                                  let mid :=
                                                    M.alloc (|
                                                      BinOp.Panic.sub (|
                                                        Integer.Usize,
                                                        M.call_closure (|
                                                          M.get_associated_function (|
                                                            Ty.apply (Ty.path "slice") [ T ],
                                                            "len",
                                                            []
                                                          |),
                                                          [ M.read (| oa |) ]
                                                        |),
                                                        M.read (| front |)
                                                      |)
                                                    |) in
                                                  M.match_operator (|
                                                    M.alloc (|
                                                      M.call_closure (|
                                                        M.get_associated_function (|
                                                          Ty.apply (Ty.path "slice") [ T ],
                                                          "split_at",
                                                          []
                                                        |),
                                                        [ M.read (| oa |); M.read (| front |) ]
                                                      |)
                                                    |),
                                                    [
                                                      fun γ =>
                                                        ltac:(M.monadic
                                                          (let γ0_0 :=
                                                            M.SubPointer.get_tuple_field (|
                                                              γ,
                                                              0
                                                            |) in
                                                          let γ0_1 :=
                                                            M.SubPointer.get_tuple_field (|
                                                              γ,
                                                              1
                                                            |) in
                                                          let oa_front := M.copy (| γ0_0 |) in
                                                          let oa_mid := M.copy (| γ0_1 |) in
                                                          M.match_operator (|
                                                            M.alloc (|
                                                              M.call_closure (|
                                                                M.get_associated_function (|
                                                                  Ty.apply (Ty.path "slice") [ T ],
                                                                  "split_at",
                                                                  []
                                                                |),
                                                                [ M.read (| sb |); M.read (| mid |)
                                                                ]
                                                              |)
                                                            |),
                                                            [
                                                              fun γ =>
                                                                ltac:(M.monadic
                                                                  (let γ0_0 :=
                                                                    M.SubPointer.get_tuple_field (|
                                                                      γ,
                                                                      0
                                                                    |) in
                                                                  let γ0_1 :=
                                                                    M.SubPointer.get_tuple_field (|
                                                                      γ,
                                                                      1
                                                                    |) in
                                                                  let sb_mid := M.copy (| γ0_0 |) in
                                                                  let sb_back :=
                                                                    M.copy (| γ0_1 |) in
                                                                  let _ :=
                                                                    M.match_operator (|
                                                                      M.alloc (| Value.Tuple [] |),
                                                                      [
                                                                        fun γ =>
                                                                          ltac:(M.monadic
                                                                            (let γ :=
                                                                              M.use
                                                                                (M.alloc (|
                                                                                  Value.Bool true
                                                                                |)) in
                                                                            let _ :=
                                                                              M.is_constant_or_break_match (|
                                                                                M.read (| γ |),
                                                                                Value.Bool true
                                                                              |) in
                                                                            let _ :=
                                                                              M.match_operator (|
                                                                                M.alloc (|
                                                                                  Value.Tuple
                                                                                    [
                                                                                      M.alloc (|
                                                                                        M.call_closure (|
                                                                                          M.get_associated_function (|
                                                                                            Ty.apply
                                                                                              (Ty.path
                                                                                                "slice")
                                                                                              [ T ],
                                                                                            "len",
                                                                                            []
                                                                                          |),
                                                                                          [
                                                                                            M.read (|
                                                                                              sa
                                                                                            |)
                                                                                          ]
                                                                                        |)
                                                                                      |);
                                                                                      M.alloc (|
                                                                                        M.call_closure (|
                                                                                          M.get_associated_function (|
                                                                                            Ty.apply
                                                                                              (Ty.path
                                                                                                "slice")
                                                                                              [ T ],
                                                                                            "len",
                                                                                            []
                                                                                          |),
                                                                                          [
                                                                                            M.read (|
                                                                                              oa_front
                                                                                            |)
                                                                                          ]
                                                                                        |)
                                                                                      |)
                                                                                    ]
                                                                                |),
                                                                                [
                                                                                  fun γ =>
                                                                                    ltac:(M.monadic
                                                                                      (let γ0_0 :=
                                                                                        M.SubPointer.get_tuple_field (|
                                                                                          γ,
                                                                                          0
                                                                                        |) in
                                                                                      let γ0_1 :=
                                                                                        M.SubPointer.get_tuple_field (|
                                                                                          γ,
                                                                                          1
                                                                                        |) in
                                                                                      let
                                                                                            left_val :=
                                                                                        M.copy (|
                                                                                          γ0_0
                                                                                        |) in
                                                                                      let
                                                                                            right_val :=
                                                                                        M.copy (|
                                                                                          γ0_1
                                                                                        |) in
                                                                                      M.match_operator (|
                                                                                        M.alloc (|
                                                                                          Value.Tuple
                                                                                            []
                                                                                        |),
                                                                                        [
                                                                                          fun γ =>
                                                                                            ltac:(M.monadic
                                                                                              (let
                                                                                                    γ :=
                                                                                                M.use
                                                                                                  (M.alloc (|
                                                                                                    UnOp.Pure.not
                                                                                                      (BinOp.Pure.eq
                                                                                                        (M.read (|
                                                                                                          M.read (|
                                                                                                            left_val
                                                                                                          |)
                                                                                                        |))
                                                                                                        (M.read (|
                                                                                                          M.read (|
                                                                                                            right_val
                                                                                                          |)
                                                                                                        |)))
                                                                                                  |)) in
                                                                                              let
                                                                                                    _ :=
                                                                                                M.is_constant_or_break_match (|
                                                                                                  M.read (|
                                                                                                    γ
                                                                                                  |),
                                                                                                  Value.Bool
                                                                                                    true
                                                                                                |) in
                                                                                              M.alloc (|
                                                                                                M.never_to_any (|
                                                                                                  M.read (|
                                                                                                    let
                                                                                                          kind :=
                                                                                                      M.alloc (|
                                                                                                        Value.StructTuple
                                                                                                          "core::panicking::AssertKind::Eq"
                                                                                                          []
                                                                                                      |) in
                                                                                                    M.alloc (|
                                                                                                      M.call_closure (|
                                                                                                        M.get_function (|
                                                                                                          "core::panicking::assert_failed",
                                                                                                          [
                                                                                                            Ty.path
                                                                                                              "usize";
                                                                                                            Ty.path
                                                                                                              "usize"
                                                                                                          ]
                                                                                                        |),
                                                                                                        [
                                                                                                          M.read (|
                                                                                                            kind
                                                                                                          |);
                                                                                                          M.read (|
                                                                                                            left_val
                                                                                                          |);
                                                                                                          M.read (|
                                                                                                            right_val
                                                                                                          |);
                                                                                                          Value.StructTuple
                                                                                                            "core::option::Option::None"
                                                                                                            []
                                                                                                        ]
                                                                                                      |)
                                                                                                    |)
                                                                                                  |)
                                                                                                |)
                                                                                              |)));
                                                                                          fun γ =>
                                                                                            ltac:(M.monadic
                                                                                              (M.alloc (|
                                                                                                Value.Tuple
                                                                                                  []
                                                                                              |)))
                                                                                        ]
                                                                                      |)))
                                                                                ]
                                                                              |) in
                                                                            M.alloc (|
                                                                              Value.Tuple []
                                                                            |)));
                                                                        fun γ =>
                                                                          ltac:(M.monadic
                                                                            (M.alloc (|
                                                                              Value.Tuple []
                                                                            |)))
                                                                      ]
                                                                    |) in
                                                                  let _ :=
                                                                    M.match_operator (|
                                                                      M.alloc (| Value.Tuple [] |),
                                                                      [
                                                                        fun γ =>
                                                                          ltac:(M.monadic
                                                                            (let γ :=
                                                                              M.use
                                                                                (M.alloc (|
                                                                                  Value.Bool true
                                                                                |)) in
                                                                            let _ :=
                                                                              M.is_constant_or_break_match (|
                                                                                M.read (| γ |),
                                                                                Value.Bool true
                                                                              |) in
                                                                            let _ :=
                                                                              M.match_operator (|
                                                                                M.alloc (|
                                                                                  Value.Tuple
                                                                                    [
                                                                                      M.alloc (|
                                                                                        M.call_closure (|
                                                                                          M.get_associated_function (|
                                                                                            Ty.apply
                                                                                              (Ty.path
                                                                                                "slice")
                                                                                              [ T ],
                                                                                            "len",
                                                                                            []
                                                                                          |),
                                                                                          [
                                                                                            M.read (|
                                                                                              sb_mid
                                                                                            |)
                                                                                          ]
                                                                                        |)
                                                                                      |);
                                                                                      M.alloc (|
                                                                                        M.call_closure (|
                                                                                          M.get_associated_function (|
                                                                                            Ty.apply
                                                                                              (Ty.path
                                                                                                "slice")
                                                                                              [ T ],
                                                                                            "len",
                                                                                            []
                                                                                          |),
                                                                                          [
                                                                                            M.read (|
                                                                                              oa_mid
                                                                                            |)
                                                                                          ]
                                                                                        |)
                                                                                      |)
                                                                                    ]
                                                                                |),
                                                                                [
                                                                                  fun γ =>
                                                                                    ltac:(M.monadic
                                                                                      (let γ0_0 :=
                                                                                        M.SubPointer.get_tuple_field (|
                                                                                          γ,
                                                                                          0
                                                                                        |) in
                                                                                      let γ0_1 :=
                                                                                        M.SubPointer.get_tuple_field (|
                                                                                          γ,
                                                                                          1
                                                                                        |) in
                                                                                      let
                                                                                            left_val :=
                                                                                        M.copy (|
                                                                                          γ0_0
                                                                                        |) in
                                                                                      let
                                                                                            right_val :=
                                                                                        M.copy (|
                                                                                          γ0_1
                                                                                        |) in
                                                                                      M.match_operator (|
                                                                                        M.alloc (|
                                                                                          Value.Tuple
                                                                                            []
                                                                                        |),
                                                                                        [
                                                                                          fun γ =>
                                                                                            ltac:(M.monadic
                                                                                              (let
                                                                                                    γ :=
                                                                                                M.use
                                                                                                  (M.alloc (|
                                                                                                    UnOp.Pure.not
                                                                                                      (BinOp.Pure.eq
                                                                                                        (M.read (|
                                                                                                          M.read (|
                                                                                                            left_val
                                                                                                          |)
                                                                                                        |))
                                                                                                        (M.read (|
                                                                                                          M.read (|
                                                                                                            right_val
                                                                                                          |)
                                                                                                        |)))
                                                                                                  |)) in
                                                                                              let
                                                                                                    _ :=
                                                                                                M.is_constant_or_break_match (|
                                                                                                  M.read (|
                                                                                                    γ
                                                                                                  |),
                                                                                                  Value.Bool
                                                                                                    true
                                                                                                |) in
                                                                                              M.alloc (|
                                                                                                M.never_to_any (|
                                                                                                  M.read (|
                                                                                                    let
                                                                                                          kind :=
                                                                                                      M.alloc (|
                                                                                                        Value.StructTuple
                                                                                                          "core::panicking::AssertKind::Eq"
                                                                                                          []
                                                                                                      |) in
                                                                                                    M.alloc (|
                                                                                                      M.call_closure (|
                                                                                                        M.get_function (|
                                                                                                          "core::panicking::assert_failed",
                                                                                                          [
                                                                                                            Ty.path
                                                                                                              "usize";
                                                                                                            Ty.path
                                                                                                              "usize"
                                                                                                          ]
                                                                                                        |),
                                                                                                        [
                                                                                                          M.read (|
                                                                                                            kind
                                                                                                          |);
                                                                                                          M.read (|
                                                                                                            left_val
                                                                                                          |);
                                                                                                          M.read (|
                                                                                                            right_val
                                                                                                          |);
                                                                                                          Value.StructTuple
                                                                                                            "core::option::Option::None"
                                                                                                            []
                                                                                                        ]
                                                                                                      |)
                                                                                                    |)
                                                                                                  |)
                                                                                                |)
                                                                                              |)));
                                                                                          fun γ =>
                                                                                            ltac:(M.monadic
                                                                                              (M.alloc (|
                                                                                                Value.Tuple
                                                                                                  []
                                                                                              |)))
                                                                                        ]
                                                                                      |)))
                                                                                ]
                                                                              |) in
                                                                            M.alloc (|
                                                                              Value.Tuple []
                                                                            |)));
                                                                        fun γ =>
                                                                          ltac:(M.monadic
                                                                            (M.alloc (|
                                                                              Value.Tuple []
                                                                            |)))
                                                                      ]
                                                                    |) in
                                                                  let _ :=
                                                                    M.match_operator (|
                                                                      M.alloc (| Value.Tuple [] |),
                                                                      [
                                                                        fun γ =>
                                                                          ltac:(M.monadic
                                                                            (let γ :=
                                                                              M.use
                                                                                (M.alloc (|
                                                                                  Value.Bool true
                                                                                |)) in
                                                                            let _ :=
                                                                              M.is_constant_or_break_match (|
                                                                                M.read (| γ |),
                                                                                Value.Bool true
                                                                              |) in
                                                                            let _ :=
                                                                              M.match_operator (|
                                                                                M.alloc (|
                                                                                  Value.Tuple
                                                                                    [
                                                                                      M.alloc (|
                                                                                        M.call_closure (|
                                                                                          M.get_associated_function (|
                                                                                            Ty.apply
                                                                                              (Ty.path
                                                                                                "slice")
                                                                                              [ T ],
                                                                                            "len",
                                                                                            []
                                                                                          |),
                                                                                          [
                                                                                            M.read (|
                                                                                              sb_back
                                                                                            |)
                                                                                          ]
                                                                                        |)
                                                                                      |);
                                                                                      M.alloc (|
                                                                                        M.call_closure (|
                                                                                          M.get_associated_function (|
                                                                                            Ty.apply
                                                                                              (Ty.path
                                                                                                "slice")
                                                                                              [ T ],
                                                                                            "len",
                                                                                            []
                                                                                          |),
                                                                                          [
                                                                                            M.read (|
                                                                                              ob
                                                                                            |)
                                                                                          ]
                                                                                        |)
                                                                                      |)
                                                                                    ]
                                                                                |),
                                                                                [
                                                                                  fun γ =>
                                                                                    ltac:(M.monadic
                                                                                      (let γ0_0 :=
                                                                                        M.SubPointer.get_tuple_field (|
                                                                                          γ,
                                                                                          0
                                                                                        |) in
                                                                                      let γ0_1 :=
                                                                                        M.SubPointer.get_tuple_field (|
                                                                                          γ,
                                                                                          1
                                                                                        |) in
                                                                                      let
                                                                                            left_val :=
                                                                                        M.copy (|
                                                                                          γ0_0
                                                                                        |) in
                                                                                      let
                                                                                            right_val :=
                                                                                        M.copy (|
                                                                                          γ0_1
                                                                                        |) in
                                                                                      M.match_operator (|
                                                                                        M.alloc (|
                                                                                          Value.Tuple
                                                                                            []
                                                                                        |),
                                                                                        [
                                                                                          fun γ =>
                                                                                            ltac:(M.monadic
                                                                                              (let
                                                                                                    γ :=
                                                                                                M.use
                                                                                                  (M.alloc (|
                                                                                                    UnOp.Pure.not
                                                                                                      (BinOp.Pure.eq
                                                                                                        (M.read (|
                                                                                                          M.read (|
                                                                                                            left_val
                                                                                                          |)
                                                                                                        |))
                                                                                                        (M.read (|
                                                                                                          M.read (|
                                                                                                            right_val
                                                                                                          |)
                                                                                                        |)))
                                                                                                  |)) in
                                                                                              let
                                                                                                    _ :=
                                                                                                M.is_constant_or_break_match (|
                                                                                                  M.read (|
                                                                                                    γ
                                                                                                  |),
                                                                                                  Value.Bool
                                                                                                    true
                                                                                                |) in
                                                                                              M.alloc (|
                                                                                                M.never_to_any (|
                                                                                                  M.read (|
                                                                                                    let
                                                                                                          kind :=
                                                                                                      M.alloc (|
                                                                                                        Value.StructTuple
                                                                                                          "core::panicking::AssertKind::Eq"
                                                                                                          []
                                                                                                      |) in
                                                                                                    M.alloc (|
                                                                                                      M.call_closure (|
                                                                                                        M.get_function (|
                                                                                                          "core::panicking::assert_failed",
                                                                                                          [
                                                                                                            Ty.path
                                                                                                              "usize";
                                                                                                            Ty.path
                                                                                                              "usize"
                                                                                                          ]
                                                                                                        |),
                                                                                                        [
                                                                                                          M.read (|
                                                                                                            kind
                                                                                                          |);
                                                                                                          M.read (|
                                                                                                            left_val
                                                                                                          |);
                                                                                                          M.read (|
                                                                                                            right_val
                                                                                                          |);
                                                                                                          Value.StructTuple
                                                                                                            "core::option::Option::None"
                                                                                                            []
                                                                                                        ]
                                                                                                      |)
                                                                                                    |)
                                                                                                  |)
                                                                                                |)
                                                                                              |)));
                                                                                          fun γ =>
                                                                                            ltac:(M.monadic
                                                                                              (M.alloc (|
                                                                                                Value.Tuple
                                                                                                  []
                                                                                              |)))
                                                                                        ]
                                                                                      |)))
                                                                                ]
                                                                              |) in
                                                                            M.alloc (|
                                                                              Value.Tuple []
                                                                            |)));
                                                                        fun γ =>
                                                                          ltac:(M.monadic
                                                                            (M.alloc (|
                                                                              Value.Tuple []
                                                                            |)))
                                                                      ]
                                                                    |) in
                                                                  M.alloc (|
                                                                    LogicalOp.and (|
                                                                      LogicalOp.and (|
                                                                        M.call_closure (|
                                                                          M.get_trait_method (|
                                                                            "core::cmp::PartialEq",
                                                                            Ty.apply
                                                                              (Ty.path "&")
                                                                              [
                                                                                Ty.apply
                                                                                  (Ty.path "slice")
                                                                                  [ T ]
                                                                              ],
                                                                            [
                                                                              Ty.apply
                                                                                (Ty.path "&")
                                                                                [
                                                                                  Ty.apply
                                                                                    (Ty.path
                                                                                      "slice")
                                                                                    [ T ]
                                                                                ]
                                                                            ],
                                                                            "eq",
                                                                            []
                                                                          |),
                                                                          [ sa; oa_front ]
                                                                        |),
                                                                        ltac:(M.monadic
                                                                          (M.call_closure (|
                                                                            M.get_trait_method (|
                                                                              "core::cmp::PartialEq",
                                                                              Ty.apply
                                                                                (Ty.path "&")
                                                                                [
                                                                                  Ty.apply
                                                                                    (Ty.path
                                                                                      "slice")
                                                                                    [ T ]
                                                                                ],
                                                                              [
                                                                                Ty.apply
                                                                                  (Ty.path "&")
                                                                                  [
                                                                                    Ty.apply
                                                                                      (Ty.path
                                                                                        "slice")
                                                                                      [ T ]
                                                                                  ]
                                                                              ],
                                                                              "eq",
                                                                              []
                                                                            |),
                                                                            [ sb_mid; oa_mid ]
                                                                          |)))
                                                                      |),
                                                                      ltac:(M.monadic
                                                                        (M.call_closure (|
                                                                          M.get_trait_method (|
                                                                            "core::cmp::PartialEq",
                                                                            Ty.apply
                                                                              (Ty.path "&")
                                                                              [
                                                                                Ty.apply
                                                                                  (Ty.path "slice")
                                                                                  [ T ]
                                                                              ],
                                                                            [
                                                                              Ty.apply
                                                                                (Ty.path "&")
                                                                                [
                                                                                  Ty.apply
                                                                                    (Ty.path
                                                                                      "slice")
                                                                                    [ T ]
                                                                                ]
                                                                            ],
                                                                            "eq",
                                                                            []
                                                                          |),
                                                                          [ sb_back; ob ]
                                                                        |)))
                                                                    |)
                                                                  |)))
                                                            ]
                                                          |)))
                                                    ]
                                                  |)));
                                              fun γ =>
                                                ltac:(M.monadic
                                                  (let front :=
                                                    M.alloc (|
                                                      M.call_closure (|
                                                        M.get_associated_function (|
                                                          Ty.apply (Ty.path "slice") [ T ],
                                                          "len",
                                                          []
                                                        |),
                                                        [ M.read (| oa |) ]
                                                      |)
                                                    |) in
                                                  let mid :=
                                                    M.alloc (|
                                                      BinOp.Panic.sub (|
                                                        Integer.Usize,
                                                        M.call_closure (|
                                                          M.get_associated_function (|
                                                            Ty.apply (Ty.path "slice") [ T ],
                                                            "len",
                                                            []
                                                          |),
                                                          [ M.read (| sa |) ]
                                                        |),
                                                        M.read (| front |)
                                                      |)
                                                    |) in
                                                  M.match_operator (|
                                                    M.alloc (|
                                                      M.call_closure (|
                                                        M.get_associated_function (|
                                                          Ty.apply (Ty.path "slice") [ T ],
                                                          "split_at",
                                                          []
                                                        |),
                                                        [ M.read (| sa |); M.read (| front |) ]
                                                      |)
                                                    |),
                                                    [
                                                      fun γ =>
                                                        ltac:(M.monadic
                                                          (let γ0_0 :=
                                                            M.SubPointer.get_tuple_field (|
                                                              γ,
                                                              0
                                                            |) in
                                                          let γ0_1 :=
                                                            M.SubPointer.get_tuple_field (|
                                                              γ,
                                                              1
                                                            |) in
                                                          let sa_front := M.copy (| γ0_0 |) in
                                                          let sa_mid := M.copy (| γ0_1 |) in
                                                          M.match_operator (|
                                                            M.alloc (|
                                                              M.call_closure (|
                                                                M.get_associated_function (|
                                                                  Ty.apply (Ty.path "slice") [ T ],
                                                                  "split_at",
                                                                  []
                                                                |),
                                                                [ M.read (| ob |); M.read (| mid |)
                                                                ]
                                                              |)
                                                            |),
                                                            [
                                                              fun γ =>
                                                                ltac:(M.monadic
                                                                  (let γ0_0 :=
                                                                    M.SubPointer.get_tuple_field (|
                                                                      γ,
                                                                      0
                                                                    |) in
                                                                  let γ0_1 :=
                                                                    M.SubPointer.get_tuple_field (|
                                                                      γ,
                                                                      1
                                                                    |) in
                                                                  let ob_mid := M.copy (| γ0_0 |) in
                                                                  let ob_back :=
                                                                    M.copy (| γ0_1 |) in
                                                                  let _ :=
                                                                    M.match_operator (|
                                                                      M.alloc (| Value.Tuple [] |),
                                                                      [
                                                                        fun γ =>
                                                                          ltac:(M.monadic
                                                                            (let γ :=
                                                                              M.use
                                                                                (M.alloc (|
                                                                                  Value.Bool true
                                                                                |)) in
                                                                            let _ :=
                                                                              M.is_constant_or_break_match (|
                                                                                M.read (| γ |),
                                                                                Value.Bool true
                                                                              |) in
                                                                            let _ :=
                                                                              M.match_operator (|
                                                                                M.alloc (|
                                                                                  Value.Tuple
                                                                                    [
                                                                                      M.alloc (|
                                                                                        M.call_closure (|
                                                                                          M.get_associated_function (|
                                                                                            Ty.apply
                                                                                              (Ty.path
                                                                                                "slice")
                                                                                              [ T ],
                                                                                            "len",
                                                                                            []
                                                                                          |),
                                                                                          [
                                                                                            M.read (|
                                                                                              sa_front
                                                                                            |)
                                                                                          ]
                                                                                        |)
                                                                                      |);
                                                                                      M.alloc (|
                                                                                        M.call_closure (|
                                                                                          M.get_associated_function (|
                                                                                            Ty.apply
                                                                                              (Ty.path
                                                                                                "slice")
                                                                                              [ T ],
                                                                                            "len",
                                                                                            []
                                                                                          |),
                                                                                          [
                                                                                            M.read (|
                                                                                              oa
                                                                                            |)
                                                                                          ]
                                                                                        |)
                                                                                      |)
                                                                                    ]
                                                                                |),
                                                                                [
                                                                                  fun γ =>
                                                                                    ltac:(M.monadic
                                                                                      (let γ0_0 :=
                                                                                        M.SubPointer.get_tuple_field (|
                                                                                          γ,
                                                                                          0
                                                                                        |) in
                                                                                      let γ0_1 :=
                                                                                        M.SubPointer.get_tuple_field (|
                                                                                          γ,
                                                                                          1
                                                                                        |) in
                                                                                      let
                                                                                            left_val :=
                                                                                        M.copy (|
                                                                                          γ0_0
                                                                                        |) in
                                                                                      let
                                                                                            right_val :=
                                                                                        M.copy (|
                                                                                          γ0_1
                                                                                        |) in
                                                                                      M.match_operator (|
                                                                                        M.alloc (|
                                                                                          Value.Tuple
                                                                                            []
                                                                                        |),
                                                                                        [
                                                                                          fun γ =>
                                                                                            ltac:(M.monadic
                                                                                              (let
                                                                                                    γ :=
                                                                                                M.use
                                                                                                  (M.alloc (|
                                                                                                    UnOp.Pure.not
                                                                                                      (BinOp.Pure.eq
                                                                                                        (M.read (|
                                                                                                          M.read (|
                                                                                                            left_val
                                                                                                          |)
                                                                                                        |))
                                                                                                        (M.read (|
                                                                                                          M.read (|
                                                                                                            right_val
                                                                                                          |)
                                                                                                        |)))
                                                                                                  |)) in
                                                                                              let
                                                                                                    _ :=
                                                                                                M.is_constant_or_break_match (|
                                                                                                  M.read (|
                                                                                                    γ
                                                                                                  |),
                                                                                                  Value.Bool
                                                                                                    true
                                                                                                |) in
                                                                                              M.alloc (|
                                                                                                M.never_to_any (|
                                                                                                  M.read (|
                                                                                                    let
                                                                                                          kind :=
                                                                                                      M.alloc (|
                                                                                                        Value.StructTuple
                                                                                                          "core::panicking::AssertKind::Eq"
                                                                                                          []
                                                                                                      |) in
                                                                                                    M.alloc (|
                                                                                                      M.call_closure (|
                                                                                                        M.get_function (|
                                                                                                          "core::panicking::assert_failed",
                                                                                                          [
                                                                                                            Ty.path
                                                                                                              "usize";
                                                                                                            Ty.path
                                                                                                              "usize"
                                                                                                          ]
                                                                                                        |),
                                                                                                        [
                                                                                                          M.read (|
                                                                                                            kind
                                                                                                          |);
                                                                                                          M.read (|
                                                                                                            left_val
                                                                                                          |);
                                                                                                          M.read (|
                                                                                                            right_val
                                                                                                          |);
                                                                                                          Value.StructTuple
                                                                                                            "core::option::Option::None"
                                                                                                            []
                                                                                                        ]
                                                                                                      |)
                                                                                                    |)
                                                                                                  |)
                                                                                                |)
                                                                                              |)));
                                                                                          fun γ =>
                                                                                            ltac:(M.monadic
                                                                                              (M.alloc (|
                                                                                                Value.Tuple
                                                                                                  []
                                                                                              |)))
                                                                                        ]
                                                                                      |)))
                                                                                ]
                                                                              |) in
                                                                            M.alloc (|
                                                                              Value.Tuple []
                                                                            |)));
                                                                        fun γ =>
                                                                          ltac:(M.monadic
                                                                            (M.alloc (|
                                                                              Value.Tuple []
                                                                            |)))
                                                                      ]
                                                                    |) in
                                                                  let _ :=
                                                                    M.match_operator (|
                                                                      M.alloc (| Value.Tuple [] |),
                                                                      [
                                                                        fun γ =>
                                                                          ltac:(M.monadic
                                                                            (let γ :=
                                                                              M.use
                                                                                (M.alloc (|
                                                                                  Value.Bool true
                                                                                |)) in
                                                                            let _ :=
                                                                              M.is_constant_or_break_match (|
                                                                                M.read (| γ |),
                                                                                Value.Bool true
                                                                              |) in
                                                                            let _ :=
                                                                              M.match_operator (|
                                                                                M.alloc (|
                                                                                  Value.Tuple
                                                                                    [
                                                                                      M.alloc (|
                                                                                        M.call_closure (|
                                                                                          M.get_associated_function (|
                                                                                            Ty.apply
                                                                                              (Ty.path
                                                                                                "slice")
                                                                                              [ T ],
                                                                                            "len",
                                                                                            []
                                                                                          |),
                                                                                          [
                                                                                            M.read (|
                                                                                              sa_mid
                                                                                            |)
                                                                                          ]
                                                                                        |)
                                                                                      |);
                                                                                      M.alloc (|
                                                                                        M.call_closure (|
                                                                                          M.get_associated_function (|
                                                                                            Ty.apply
                                                                                              (Ty.path
                                                                                                "slice")
                                                                                              [ T ],
                                                                                            "len",
                                                                                            []
                                                                                          |),
                                                                                          [
                                                                                            M.read (|
                                                                                              ob_mid
                                                                                            |)
                                                                                          ]
                                                                                        |)
                                                                                      |)
                                                                                    ]
                                                                                |),
                                                                                [
                                                                                  fun γ =>
                                                                                    ltac:(M.monadic
                                                                                      (let γ0_0 :=
                                                                                        M.SubPointer.get_tuple_field (|
                                                                                          γ,
                                                                                          0
                                                                                        |) in
                                                                                      let γ0_1 :=
                                                                                        M.SubPointer.get_tuple_field (|
                                                                                          γ,
                                                                                          1
                                                                                        |) in
                                                                                      let
                                                                                            left_val :=
                                                                                        M.copy (|
                                                                                          γ0_0
                                                                                        |) in
                                                                                      let
                                                                                            right_val :=
                                                                                        M.copy (|
                                                                                          γ0_1
                                                                                        |) in
                                                                                      M.match_operator (|
                                                                                        M.alloc (|
                                                                                          Value.Tuple
                                                                                            []
                                                                                        |),
                                                                                        [
                                                                                          fun γ =>
                                                                                            ltac:(M.monadic
                                                                                              (let
                                                                                                    γ :=
                                                                                                M.use
                                                                                                  (M.alloc (|
                                                                                                    UnOp.Pure.not
                                                                                                      (BinOp.Pure.eq
                                                                                                        (M.read (|
                                                                                                          M.read (|
                                                                                                            left_val
                                                                                                          |)
                                                                                                        |))
                                                                                                        (M.read (|
                                                                                                          M.read (|
                                                                                                            right_val
                                                                                                          |)
                                                                                                        |)))
                                                                                                  |)) in
                                                                                              let
                                                                                                    _ :=
                                                                                                M.is_constant_or_break_match (|
                                                                                                  M.read (|
                                                                                                    γ
                                                                                                  |),
                                                                                                  Value.Bool
                                                                                                    true
                                                                                                |) in
                                                                                              M.alloc (|
                                                                                                M.never_to_any (|
                                                                                                  M.read (|
                                                                                                    let
                                                                                                          kind :=
                                                                                                      M.alloc (|
                                                                                                        Value.StructTuple
                                                                                                          "core::panicking::AssertKind::Eq"
                                                                                                          []
                                                                                                      |) in
                                                                                                    M.alloc (|
                                                                                                      M.call_closure (|
                                                                                                        M.get_function (|
                                                                                                          "core::panicking::assert_failed",
                                                                                                          [
                                                                                                            Ty.path
                                                                                                              "usize";
                                                                                                            Ty.path
                                                                                                              "usize"
                                                                                                          ]
                                                                                                        |),
                                                                                                        [
                                                                                                          M.read (|
                                                                                                            kind
                                                                                                          |);
                                                                                                          M.read (|
                                                                                                            left_val
                                                                                                          |);
                                                                                                          M.read (|
                                                                                                            right_val
                                                                                                          |);
                                                                                                          Value.StructTuple
                                                                                                            "core::option::Option::None"
                                                                                                            []
                                                                                                        ]
                                                                                                      |)
                                                                                                    |)
                                                                                                  |)
                                                                                                |)
                                                                                              |)));
                                                                                          fun γ =>
                                                                                            ltac:(M.monadic
                                                                                              (M.alloc (|
                                                                                                Value.Tuple
                                                                                                  []
                                                                                              |)))
                                                                                        ]
                                                                                      |)))
                                                                                ]
                                                                              |) in
                                                                            M.alloc (|
                                                                              Value.Tuple []
                                                                            |)));
                                                                        fun γ =>
                                                                          ltac:(M.monadic
                                                                            (M.alloc (|
                                                                              Value.Tuple []
                                                                            |)))
                                                                      ]
                                                                    |) in
                                                                  let _ :=
                                                                    M.match_operator (|
                                                                      M.alloc (| Value.Tuple [] |),
                                                                      [
                                                                        fun γ =>
                                                                          ltac:(M.monadic
                                                                            (let γ :=
                                                                              M.use
                                                                                (M.alloc (|
                                                                                  Value.Bool true
                                                                                |)) in
                                                                            let _ :=
                                                                              M.is_constant_or_break_match (|
                                                                                M.read (| γ |),
                                                                                Value.Bool true
                                                                              |) in
                                                                            let _ :=
                                                                              M.match_operator (|
                                                                                M.alloc (|
                                                                                  Value.Tuple
                                                                                    [
                                                                                      M.alloc (|
                                                                                        M.call_closure (|
                                                                                          M.get_associated_function (|
                                                                                            Ty.apply
                                                                                              (Ty.path
                                                                                                "slice")
                                                                                              [ T ],
                                                                                            "len",
                                                                                            []
                                                                                          |),
                                                                                          [
                                                                                            M.read (|
                                                                                              sb
                                                                                            |)
                                                                                          ]
                                                                                        |)
                                                                                      |);
                                                                                      M.alloc (|
                                                                                        M.call_closure (|
                                                                                          M.get_associated_function (|
                                                                                            Ty.apply
                                                                                              (Ty.path
                                                                                                "slice")
                                                                                              [ T ],
                                                                                            "len",
                                                                                            []
                                                                                          |),
                                                                                          [
                                                                                            M.read (|
                                                                                              ob_back
                                                                                            |)
                                                                                          ]
                                                                                        |)
                                                                                      |)
                                                                                    ]
                                                                                |),
                                                                                [
                                                                                  fun γ =>
                                                                                    ltac:(M.monadic
                                                                                      (let γ0_0 :=
                                                                                        M.SubPointer.get_tuple_field (|
                                                                                          γ,
                                                                                          0
                                                                                        |) in
                                                                                      let γ0_1 :=
                                                                                        M.SubPointer.get_tuple_field (|
                                                                                          γ,
                                                                                          1
                                                                                        |) in
                                                                                      let
                                                                                            left_val :=
                                                                                        M.copy (|
                                                                                          γ0_0
                                                                                        |) in
                                                                                      let
                                                                                            right_val :=
                                                                                        M.copy (|
                                                                                          γ0_1
                                                                                        |) in
                                                                                      M.match_operator (|
                                                                                        M.alloc (|
                                                                                          Value.Tuple
                                                                                            []
                                                                                        |),
                                                                                        [
                                                                                          fun γ =>
                                                                                            ltac:(M.monadic
                                                                                              (let
                                                                                                    γ :=
                                                                                                M.use
                                                                                                  (M.alloc (|
                                                                                                    UnOp.Pure.not
                                                                                                      (BinOp.Pure.eq
                                                                                                        (M.read (|
                                                                                                          M.read (|
                                                                                                            left_val
                                                                                                          |)
                                                                                                        |))
                                                                                                        (M.read (|
                                                                                                          M.read (|
                                                                                                            right_val
                                                                                                          |)
                                                                                                        |)))
                                                                                                  |)) in
                                                                                              let
                                                                                                    _ :=
                                                                                                M.is_constant_or_break_match (|
                                                                                                  M.read (|
                                                                                                    γ
                                                                                                  |),
                                                                                                  Value.Bool
                                                                                                    true
                                                                                                |) in
                                                                                              M.alloc (|
                                                                                                M.never_to_any (|
                                                                                                  M.read (|
                                                                                                    let
                                                                                                          kind :=
                                                                                                      M.alloc (|
                                                                                                        Value.StructTuple
                                                                                                          "core::panicking::AssertKind::Eq"
                                                                                                          []
                                                                                                      |) in
                                                                                                    M.alloc (|
                                                                                                      M.call_closure (|
                                                                                                        M.get_function (|
                                                                                                          "core::panicking::assert_failed",
                                                                                                          [
                                                                                                            Ty.path
                                                                                                              "usize";
                                                                                                            Ty.path
                                                                                                              "usize"
                                                                                                          ]
                                                                                                        |),
                                                                                                        [
                                                                                                          M.read (|
                                                                                                            kind
                                                                                                          |);
                                                                                                          M.read (|
                                                                                                            left_val
                                                                                                          |);
                                                                                                          M.read (|
                                                                                                            right_val
                                                                                                          |);
                                                                                                          Value.StructTuple
                                                                                                            "core::option::Option::None"
                                                                                                            []
                                                                                                        ]
                                                                                                      |)
                                                                                                    |)
                                                                                                  |)
                                                                                                |)
                                                                                              |)));
                                                                                          fun γ =>
                                                                                            ltac:(M.monadic
                                                                                              (M.alloc (|
                                                                                                Value.Tuple
                                                                                                  []
                                                                                              |)))
                                                                                        ]
                                                                                      |)))
                                                                                ]
                                                                              |) in
                                                                            M.alloc (|
                                                                              Value.Tuple []
                                                                            |)));
                                                                        fun γ =>
                                                                          ltac:(M.monadic
                                                                            (M.alloc (|
                                                                              Value.Tuple []
                                                                            |)))
                                                                      ]
                                                                    |) in
                                                                  M.alloc (|
                                                                    LogicalOp.and (|
                                                                      LogicalOp.and (|
                                                                        M.call_closure (|
                                                                          M.get_trait_method (|
                                                                            "core::cmp::PartialEq",
                                                                            Ty.apply
                                                                              (Ty.path "&")
                                                                              [
                                                                                Ty.apply
                                                                                  (Ty.path "slice")
                                                                                  [ T ]
                                                                              ],
                                                                            [
                                                                              Ty.apply
                                                                                (Ty.path "&")
                                                                                [
                                                                                  Ty.apply
                                                                                    (Ty.path
                                                                                      "slice")
                                                                                    [ T ]
                                                                                ]
                                                                            ],
                                                                            "eq",
                                                                            []
                                                                          |),
                                                                          [ sa_front; oa ]
                                                                        |),
                                                                        ltac:(M.monadic
                                                                          (M.call_closure (|
                                                                            M.get_trait_method (|
                                                                              "core::cmp::PartialEq",
                                                                              Ty.apply
                                                                                (Ty.path "&")
                                                                                [
                                                                                  Ty.apply
                                                                                    (Ty.path
                                                                                      "slice")
                                                                                    [ T ]
                                                                                ],
                                                                              [
                                                                                Ty.apply
                                                                                  (Ty.path "&")
                                                                                  [
                                                                                    Ty.apply
                                                                                      (Ty.path
                                                                                        "slice")
                                                                                      [ T ]
                                                                                  ]
                                                                              ],
                                                                              "eq",
                                                                              []
                                                                            |),
                                                                            [ sa_mid; ob_mid ]
                                                                          |)))
                                                                      |),
                                                                      ltac:(M.monadic
                                                                        (M.call_closure (|
                                                                          M.get_trait_method (|
                                                                            "core::cmp::PartialEq",
                                                                            Ty.apply
                                                                              (Ty.path "&")
                                                                              [
                                                                                Ty.apply
                                                                                  (Ty.path "slice")
                                                                                  [ T ]
                                                                              ],
                                                                            [
                                                                              Ty.apply
                                                                                (Ty.path "&")
                                                                                [
                                                                                  Ty.apply
                                                                                    (Ty.path
                                                                                      "slice")
                                                                                    [ T ]
                                                                                ]
                                                                            ],
                                                                            "eq",
                                                                            []
                                                                          |),
                                                                          [ sb; ob_back ]
                                                                        |)))
                                                                    |)
                                                                  |)))
                                                            ]
                                                          |)))
                                                    ]
                                                  |)))
                                            ]
                                          |)))
                                    ]
                                  |)))
                            ]
                          |)))
                    ]
                  |)
                |)))
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (T A : Ty.t),
        M.IsTraitInstance
          "core::cmp::PartialEq"
          (Self T A)
          (* Trait polymorphic types *) []
          (* Instance *) [ ("eq", InstanceField.Method (eq T A)) ].
    End Impl_core_cmp_PartialEq_where_core_cmp_PartialEq_T_where_core_alloc_Allocator_A_for_alloc_collections_vec_deque_VecDeque_T_A.
    
    Module Impl_core_cmp_Eq_where_core_cmp_Eq_T_where_core_alloc_Allocator_A_for_alloc_collections_vec_deque_VecDeque_T_A.
      Definition Self (T A : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "alloc::collections::vec_deque::VecDeque") [ T; A ].
      
      Axiom Implements :
        forall (T A : Ty.t),
        M.IsTraitInstance
          "core::cmp::Eq"
          (Self T A)
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_cmp_Eq_where_core_cmp_Eq_T_where_core_alloc_Allocator_A_for_alloc_collections_vec_deque_VecDeque_T_A.
    
    Module Impl_core_cmp_PartialOrd_where_core_cmp_PartialOrd_T_where_core_alloc_Allocator_A_for_alloc_collections_vec_deque_VecDeque_T_A.
      Definition Self (T A : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "alloc::collections::vec_deque::VecDeque") [ T; A ].
      
      (*
          fn partial_cmp(&self, other: &Self) -> Option<Ordering> {
              self.iter().partial_cmp(other.iter())
          }
      *)
      Definition partial_cmp (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              M.get_trait_method (|
                "core::iter::traits::iterator::Iterator",
                Ty.apply (Ty.path "alloc::collections::vec_deque::iter::Iter") [ T ],
                [],
                "partial_cmp",
                [ Ty.apply (Ty.path "alloc::collections::vec_deque::iter::Iter") [ T ] ]
              |),
              [
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "alloc::collections::vec_deque::VecDeque") [ T; A ],
                    "iter",
                    []
                  |),
                  [ M.read (| self |) ]
                |);
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "alloc::collections::vec_deque::VecDeque") [ T; A ],
                    "iter",
                    []
                  |),
                  [ M.read (| other |) ]
                |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (T A : Ty.t),
        M.IsTraitInstance
          "core::cmp::PartialOrd"
          (Self T A)
          (* Trait polymorphic types *) []
          (* Instance *) [ ("partial_cmp", InstanceField.Method (partial_cmp T A)) ].
    End Impl_core_cmp_PartialOrd_where_core_cmp_PartialOrd_T_where_core_alloc_Allocator_A_for_alloc_collections_vec_deque_VecDeque_T_A.
    
    Module Impl_core_cmp_Ord_where_core_cmp_Ord_T_where_core_alloc_Allocator_A_for_alloc_collections_vec_deque_VecDeque_T_A.
      Definition Self (T A : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "alloc::collections::vec_deque::VecDeque") [ T; A ].
      
      (*
          fn cmp(&self, other: &Self) -> Ordering {
              self.iter().cmp(other.iter())
          }
      *)
      Definition cmp (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              M.get_trait_method (|
                "core::iter::traits::iterator::Iterator",
                Ty.apply (Ty.path "alloc::collections::vec_deque::iter::Iter") [ T ],
                [],
                "cmp",
                [ Ty.apply (Ty.path "alloc::collections::vec_deque::iter::Iter") [ T ] ]
              |),
              [
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "alloc::collections::vec_deque::VecDeque") [ T; A ],
                    "iter",
                    []
                  |),
                  [ M.read (| self |) ]
                |);
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "alloc::collections::vec_deque::VecDeque") [ T; A ],
                    "iter",
                    []
                  |),
                  [ M.read (| other |) ]
                |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (T A : Ty.t),
        M.IsTraitInstance
          "core::cmp::Ord"
          (Self T A)
          (* Trait polymorphic types *) []
          (* Instance *) [ ("cmp", InstanceField.Method (cmp T A)) ].
    End Impl_core_cmp_Ord_where_core_cmp_Ord_T_where_core_alloc_Allocator_A_for_alloc_collections_vec_deque_VecDeque_T_A.
    
    Module Impl_core_hash_Hash_where_core_hash_Hash_T_where_core_alloc_Allocator_A_for_alloc_collections_vec_deque_VecDeque_T_A.
      Definition Self (T A : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "alloc::collections::vec_deque::VecDeque") [ T; A ].
      
      (*
          fn hash<H: Hasher>(&self, state: &mut H) {
              state.write_length_prefix(self.len);
              // It's not possible to use Hash::hash_slice on slices
              // returned by as_slices method as their length can vary
              // in otherwise identical deques.
              //
              // Hasher only guarantees equivalence for the exact same
              // set of calls to its methods.
              self.iter().for_each(|elem| elem.hash(state));
          }
      *)
      Definition hash (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match τ, α with
        | [ H ], [ self; state ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let state := M.alloc (| state |) in
            M.read (|
              let _ :=
                M.alloc (|
                  M.call_closure (|
                    M.get_trait_method (| "core::hash::Hasher", H, [], "write_length_prefix", [] |),
                    [
                      M.read (| state |);
                      M.read (|
                        M.SubPointer.get_struct_record_field (|
                          M.read (| self |),
                          "alloc::collections::vec_deque::VecDeque",
                          "len"
                        |)
                      |)
                    ]
                  |)
                |) in
              let _ :=
                M.alloc (|
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::iter::traits::iterator::Iterator",
                      Ty.apply (Ty.path "alloc::collections::vec_deque::iter::Iter") [ T ],
                      [],
                      "for_each",
                      [ Ty.function [ Ty.tuple [ Ty.apply (Ty.path "&") [ T ] ] ] (Ty.tuple []) ]
                    |),
                    [
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "alloc::collections::vec_deque::VecDeque") [ T; A ],
                          "iter",
                          []
                        |),
                        [ M.read (| self |) ]
                      |);
                      M.closure
                        (fun γ =>
                          ltac:(M.monadic
                            match γ with
                            | [ α0 ] =>
                              M.match_operator (|
                                M.alloc (| α0 |),
                                [
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let elem := M.copy (| γ |) in
                                      M.call_closure (|
                                        M.get_trait_method (|
                                          "core::hash::Hash",
                                          T,
                                          [],
                                          "hash",
                                          [ H ]
                                        |),
                                        [ M.read (| elem |); M.read (| state |) ]
                                      |)))
                                ]
                              |)
                            | _ => M.impossible (||)
                            end))
                    ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (T A : Ty.t),
        M.IsTraitInstance
          "core::hash::Hash"
          (Self T A)
          (* Trait polymorphic types *) []
          (* Instance *) [ ("hash", InstanceField.Method (hash T A)) ].
    End Impl_core_hash_Hash_where_core_hash_Hash_T_where_core_alloc_Allocator_A_for_alloc_collections_vec_deque_VecDeque_T_A.
    
    Module Impl_core_ops_index_Index_where_core_alloc_Allocator_A_usize_for_alloc_collections_vec_deque_VecDeque_T_A.
      Definition Self (T A : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "alloc::collections::vec_deque::VecDeque") [ T; A ].
      
      (*     type Output = T; *)
      Definition _Output (T A : Ty.t) : Ty.t := T.
      
      (*
          fn index(&self, index: usize) -> &T {
              self.get(index).expect("Out of bounds access")
          }
      *)
      Definition index (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match τ, α with
        | [], [ self; index ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let index := M.alloc (| index |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply (Ty.path "core::option::Option") [ Ty.apply (Ty.path "&") [ T ] ],
                "expect",
                []
              |),
              [
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "alloc::collections::vec_deque::VecDeque") [ T; A ],
                    "get",
                    []
                  |),
                  [ M.read (| self |); M.read (| index |) ]
                |);
                M.read (| Value.String "Out of bounds access" |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (T A : Ty.t),
        M.IsTraitInstance
          "core::ops::index::Index"
          (Self T A)
          (* Trait polymorphic types *) [ (* Idx *) Ty.path "usize" ]
          (* Instance *)
          [ ("Output", InstanceField.Ty (_Output T A)); ("index", InstanceField.Method (index T A))
          ].
    End Impl_core_ops_index_Index_where_core_alloc_Allocator_A_usize_for_alloc_collections_vec_deque_VecDeque_T_A.
    
    Module Impl_core_ops_index_IndexMut_where_core_alloc_Allocator_A_usize_for_alloc_collections_vec_deque_VecDeque_T_A.
      Definition Self (T A : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "alloc::collections::vec_deque::VecDeque") [ T; A ].
      
      (*
          fn index_mut(&mut self, index: usize) -> &mut T {
              self.get_mut(index).expect("Out of bounds access")
          }
      *)
      Definition index_mut (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match τ, α with
        | [], [ self; index ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let index := M.alloc (| index |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply (Ty.path "core::option::Option") [ Ty.apply (Ty.path "&mut") [ T ] ],
                "expect",
                []
              |),
              [
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "alloc::collections::vec_deque::VecDeque") [ T; A ],
                    "get_mut",
                    []
                  |),
                  [ M.read (| self |); M.read (| index |) ]
                |);
                M.read (| Value.String "Out of bounds access" |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (T A : Ty.t),
        M.IsTraitInstance
          "core::ops::index::IndexMut"
          (Self T A)
          (* Trait polymorphic types *) [ (* Idx *) Ty.path "usize" ]
          (* Instance *) [ ("index_mut", InstanceField.Method (index_mut T A)) ].
    End Impl_core_ops_index_IndexMut_where_core_alloc_Allocator_A_usize_for_alloc_collections_vec_deque_VecDeque_T_A.
    
    Module Impl_core_iter_traits_collect_FromIterator_T_for_alloc_collections_vec_deque_VecDeque_T_alloc_alloc_Global.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply
          (Ty.path "alloc::collections::vec_deque::VecDeque")
          [ T; Ty.path "alloc::alloc::Global" ].
      
      (*
          fn from_iter<I: IntoIterator<Item = T>>(iter: I) -> VecDeque<T> {
              SpecFromIter::spec_from_iter(iter.into_iter())
          }
      *)
      Definition from_iter (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [ _ as I ], [ iter ] =>
          ltac:(M.monadic
            (let iter := M.alloc (| iter |) in
            M.call_closure (|
              M.get_trait_method (|
                "alloc::collections::vec_deque::spec_from_iter::SpecFromIter",
                Ty.apply
                  (Ty.path "alloc::collections::vec_deque::VecDeque")
                  [ T; Ty.path "alloc::alloc::Global" ],
                [ T; Ty.associated ],
                "spec_from_iter",
                []
              |),
              [
                M.call_closure (|
                  M.get_trait_method (|
                    "core::iter::traits::collect::IntoIterator",
                    I,
                    [],
                    "into_iter",
                    []
                  |),
                  [ M.read (| iter |) ]
                |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::collect::FromIterator"
          (Self T)
          (* Trait polymorphic types *) [ (* A *) T ]
          (* Instance *) [ ("from_iter", InstanceField.Method (from_iter T)) ].
    End Impl_core_iter_traits_collect_FromIterator_T_for_alloc_collections_vec_deque_VecDeque_T_alloc_alloc_Global.
    
    Module Impl_core_iter_traits_collect_IntoIterator_where_core_alloc_Allocator_A_for_alloc_collections_vec_deque_VecDeque_T_A.
      Definition Self (T A : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "alloc::collections::vec_deque::VecDeque") [ T; A ].
      
      (*     type Item = T; *)
      Definition _Item (T A : Ty.t) : Ty.t := T.
      
      (*     type IntoIter = IntoIter<T, A>; *)
      Definition _IntoIter (T A : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "alloc::collections::vec_deque::into_iter::IntoIter") [ T; A ].
      
      (*
          fn into_iter(self) -> IntoIter<T, A> {
              IntoIter::new(self)
          }
      *)
      Definition into_iter (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply (Ty.path "alloc::collections::vec_deque::into_iter::IntoIter") [ T; A ],
                "new",
                []
              |),
              [ M.read (| self |) ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (T A : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::collect::IntoIterator"
          (Self T A)
          (* Trait polymorphic types *) []
          (* Instance *)
          [
            ("Item", InstanceField.Ty (_Item T A));
            ("IntoIter", InstanceField.Ty (_IntoIter T A));
            ("into_iter", InstanceField.Method (into_iter T A))
          ].
    End Impl_core_iter_traits_collect_IntoIterator_where_core_alloc_Allocator_A_for_alloc_collections_vec_deque_VecDeque_T_A.
    
    Module Impl_core_iter_traits_collect_IntoIterator_where_core_alloc_Allocator_A_for_ref__alloc_collections_vec_deque_VecDeque_T_A.
      Definition Self (T A : Ty.t) : Ty.t :=
        Ty.apply
          (Ty.path "&")
          [ Ty.apply (Ty.path "alloc::collections::vec_deque::VecDeque") [ T; A ] ].
      
      (*     type Item = &'a T; *)
      Definition _Item (T A : Ty.t) : Ty.t := Ty.apply (Ty.path "&") [ T ].
      
      (*     type IntoIter = Iter<'a, T>; *)
      Definition _IntoIter (T A : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "alloc::collections::vec_deque::iter::Iter") [ T ].
      
      (*
          fn into_iter(self) -> Iter<'a, T> {
              self.iter()
          }
      *)
      Definition into_iter (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply (Ty.path "alloc::collections::vec_deque::VecDeque") [ T; A ],
                "iter",
                []
              |),
              [ M.read (| self |) ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (T A : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::collect::IntoIterator"
          (Self T A)
          (* Trait polymorphic types *) []
          (* Instance *)
          [
            ("Item", InstanceField.Ty (_Item T A));
            ("IntoIter", InstanceField.Ty (_IntoIter T A));
            ("into_iter", InstanceField.Method (into_iter T A))
          ].
    End Impl_core_iter_traits_collect_IntoIterator_where_core_alloc_Allocator_A_for_ref__alloc_collections_vec_deque_VecDeque_T_A.
    
    Module Impl_core_iter_traits_collect_IntoIterator_where_core_alloc_Allocator_A_for_ref_mut_alloc_collections_vec_deque_VecDeque_T_A.
      Definition Self (T A : Ty.t) : Ty.t :=
        Ty.apply
          (Ty.path "&mut")
          [ Ty.apply (Ty.path "alloc::collections::vec_deque::VecDeque") [ T; A ] ].
      
      (*     type Item = &'a mut T; *)
      Definition _Item (T A : Ty.t) : Ty.t := Ty.apply (Ty.path "&mut") [ T ].
      
      (*     type IntoIter = IterMut<'a, T>; *)
      Definition _IntoIter (T A : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "alloc::collections::vec_deque::iter_mut::IterMut") [ T ].
      
      (*
          fn into_iter(self) -> IterMut<'a, T> {
              self.iter_mut()
          }
      *)
      Definition into_iter (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply (Ty.path "alloc::collections::vec_deque::VecDeque") [ T; A ],
                "iter_mut",
                []
              |),
              [ M.read (| self |) ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (T A : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::collect::IntoIterator"
          (Self T A)
          (* Trait polymorphic types *) []
          (* Instance *)
          [
            ("Item", InstanceField.Ty (_Item T A));
            ("IntoIter", InstanceField.Ty (_IntoIter T A));
            ("into_iter", InstanceField.Method (into_iter T A))
          ].
    End Impl_core_iter_traits_collect_IntoIterator_where_core_alloc_Allocator_A_for_ref_mut_alloc_collections_vec_deque_VecDeque_T_A.
    
    Module Impl_core_iter_traits_collect_Extend_where_core_alloc_Allocator_A_T_for_alloc_collections_vec_deque_VecDeque_T_A.
      Definition Self (T A : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "alloc::collections::vec_deque::VecDeque") [ T; A ].
      
      (*
          fn extend<I: IntoIterator<Item = T>>(&mut self, iter: I) {
              <Self as SpecExtend<T, I::IntoIter>>::spec_extend(self, iter.into_iter());
          }
      *)
      Definition extend (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match τ, α with
        | [ _ as I ], [ self; iter ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let iter := M.alloc (| iter |) in
            M.read (|
              let _ :=
                M.alloc (|
                  M.call_closure (|
                    M.get_trait_method (|
                      "alloc::collections::vec_deque::spec_extend::SpecExtend",
                      Ty.apply (Ty.path "alloc::collections::vec_deque::VecDeque") [ T; A ],
                      [ T; Ty.associated ],
                      "spec_extend",
                      []
                    |),
                    [
                      M.read (| self |);
                      M.call_closure (|
                        M.get_trait_method (|
                          "core::iter::traits::collect::IntoIterator",
                          I,
                          [],
                          "into_iter",
                          []
                        |),
                        [ M.read (| iter |) ]
                      |)
                    ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      (*
          fn extend_one(&mut self, elem: T) {
              self.push_back(elem);
          }
      *)
      Definition extend_one (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match τ, α with
        | [], [ self; elem ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let elem := M.alloc (| elem |) in
            M.read (|
              let _ :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply (Ty.path "alloc::collections::vec_deque::VecDeque") [ T; A ],
                      "push_back",
                      []
                    |),
                    [ M.read (| self |); M.read (| elem |) ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      (*
          fn extend_reserve(&mut self, additional: usize) {
              self.reserve(additional);
          }
      *)
      Definition extend_reserve (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match τ, α with
        | [], [ self; additional ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let additional := M.alloc (| additional |) in
            M.read (|
              let _ :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply (Ty.path "alloc::collections::vec_deque::VecDeque") [ T; A ],
                      "reserve",
                      []
                    |),
                    [ M.read (| self |); M.read (| additional |) ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (T A : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::collect::Extend"
          (Self T A)
          (* Trait polymorphic types *) [ (* A *) T ]
          (* Instance *)
          [
            ("extend", InstanceField.Method (extend T A));
            ("extend_one", InstanceField.Method (extend_one T A));
            ("extend_reserve", InstanceField.Method (extend_reserve T A))
          ].
    End Impl_core_iter_traits_collect_Extend_where_core_alloc_Allocator_A_T_for_alloc_collections_vec_deque_VecDeque_T_A.
    
    Module Impl_core_iter_traits_collect_Extend_where_core_marker_Copy_T_where_core_alloc_Allocator_A_ref__T_for_alloc_collections_vec_deque_VecDeque_T_A.
      Definition Self (T A : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "alloc::collections::vec_deque::VecDeque") [ T; A ].
      
      (*
          fn extend<I: IntoIterator<Item = &'a T>>(&mut self, iter: I) {
              self.spec_extend(iter.into_iter());
          }
      *)
      Definition extend (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match τ, α with
        | [ _ as I ], [ self; iter ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let iter := M.alloc (| iter |) in
            M.read (|
              let _ :=
                M.alloc (|
                  M.call_closure (|
                    M.get_trait_method (|
                      "alloc::collections::vec_deque::spec_extend::SpecExtend",
                      Ty.apply (Ty.path "alloc::collections::vec_deque::VecDeque") [ T; A ],
                      [ Ty.apply (Ty.path "&") [ T ]; Ty.associated ],
                      "spec_extend",
                      []
                    |),
                    [
                      M.read (| self |);
                      M.call_closure (|
                        M.get_trait_method (|
                          "core::iter::traits::collect::IntoIterator",
                          I,
                          [],
                          "into_iter",
                          []
                        |),
                        [ M.read (| iter |) ]
                      |)
                    ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      (*
          fn extend_one(&mut self, &elem: &'a T) {
              self.push_back(elem);
          }
      *)
      Definition extend_one (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match τ, α with
        | [], [ self; β1 ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let β1 := M.alloc (| β1 |) in
            M.match_operator (|
              β1,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let elem := M.copy (| γ |) in
                    M.read (|
                      let _ :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply (Ty.path "alloc::collections::vec_deque::VecDeque") [ T; A ],
                              "push_back",
                              []
                            |),
                            [ M.read (| self |); M.read (| elem |) ]
                          |)
                        |) in
                      M.alloc (| Value.Tuple [] |)
                    |)))
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      (*
          fn extend_reserve(&mut self, additional: usize) {
              self.reserve(additional);
          }
      *)
      Definition extend_reserve (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match τ, α with
        | [], [ self; additional ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let additional := M.alloc (| additional |) in
            M.read (|
              let _ :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply (Ty.path "alloc::collections::vec_deque::VecDeque") [ T; A ],
                      "reserve",
                      []
                    |),
                    [ M.read (| self |); M.read (| additional |) ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (T A : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::collect::Extend"
          (Self T A)
          (* Trait polymorphic types *) [ (* A *) Ty.apply (Ty.path "&") [ T ] ]
          (* Instance *)
          [
            ("extend", InstanceField.Method (extend T A));
            ("extend_one", InstanceField.Method (extend_one T A));
            ("extend_reserve", InstanceField.Method (extend_reserve T A))
          ].
    End Impl_core_iter_traits_collect_Extend_where_core_marker_Copy_T_where_core_alloc_Allocator_A_ref__T_for_alloc_collections_vec_deque_VecDeque_T_A.
    
    Module Impl_core_fmt_Debug_where_core_fmt_Debug_T_where_core_alloc_Allocator_A_for_alloc_collections_vec_deque_VecDeque_T_A.
      Definition Self (T A : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "alloc::collections::vec_deque::VecDeque") [ T; A ].
      
      (*
          fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
              f.debug_list().entries(self.iter()).finish()
          }
      *)
      Definition fmt (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "core::fmt::builders::DebugList",
                "finish",
                []
              |),
              [
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.path "core::fmt::builders::DebugList",
                    "entries",
                    [
                      Ty.apply (Ty.path "&") [ T ];
                      Ty.apply (Ty.path "alloc::collections::vec_deque::iter::Iter") [ T ]
                    ]
                  |),
                  [
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "debug_list",
                          []
                        |),
                        [ M.read (| f |) ]
                      |)
                    |);
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "alloc::collections::vec_deque::VecDeque") [ T; A ],
                        "iter",
                        []
                      |),
                      [ M.read (| self |) ]
                    |)
                  ]
                |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (T A : Ty.t),
        M.IsTraitInstance
          "core::fmt::Debug"
          (Self T A)
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method (fmt T A)) ].
    End Impl_core_fmt_Debug_where_core_fmt_Debug_T_where_core_alloc_Allocator_A_for_alloc_collections_vec_deque_VecDeque_T_A.
    
    Module Impl_core_convert_From_where_core_alloc_Allocator_A_alloc_vec_Vec_T_A_for_alloc_collections_vec_deque_VecDeque_T_A.
      Definition Self (T A : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "alloc::collections::vec_deque::VecDeque") [ T; A ].
      
      (*
          fn from(other: Vec<T, A>) -> Self {
              let (ptr, len, cap, alloc) = other.into_raw_parts_with_alloc();
              Self { head: 0, len, buf: unsafe { RawVec::from_raw_parts_in(ptr, cap, alloc) } }
          }
      *)
      Definition from (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match τ, α with
        | [], [ other ] =>
          ltac:(M.monadic
            (let other := M.alloc (| other |) in
            M.read (|
              M.match_operator (|
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply (Ty.path "alloc::vec::Vec") [ T; A ],
                      "into_raw_parts_with_alloc",
                      []
                    |),
                    [ M.read (| other |) ]
                  |)
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      let γ0_2 := M.SubPointer.get_tuple_field (| γ, 2 |) in
                      let γ0_3 := M.SubPointer.get_tuple_field (| γ, 3 |) in
                      let ptr := M.copy (| γ0_0 |) in
                      let len := M.copy (| γ0_1 |) in
                      let cap := M.copy (| γ0_2 |) in
                      let alloc := M.copy (| γ0_3 |) in
                      M.alloc (|
                        Value.StructRecord
                          "alloc::collections::vec_deque::VecDeque"
                          [
                            ("head", Value.Integer 0);
                            ("len", M.read (| len |));
                            ("buf",
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "alloc::raw_vec::RawVec") [ T; A ],
                                  "from_raw_parts_in",
                                  []
                                |),
                                [ M.read (| ptr |); M.read (| cap |); M.read (| alloc |) ]
                              |))
                          ]
                      |)))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (T A : Ty.t),
        M.IsTraitInstance
          "core::convert::From"
          (Self T A)
          (* Trait polymorphic types *) [ (* T *) Ty.apply (Ty.path "alloc::vec::Vec") [ T; A ] ]
          (* Instance *) [ ("from", InstanceField.Method (from T A)) ].
    End Impl_core_convert_From_where_core_alloc_Allocator_A_alloc_vec_Vec_T_A_for_alloc_collections_vec_deque_VecDeque_T_A.
    
    Module Impl_core_convert_From_where_core_alloc_Allocator_A_alloc_collections_vec_deque_VecDeque_T_A_for_alloc_vec_Vec_T_A.
      Definition Self (T A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::vec::Vec") [ T; A ].
      
      (*
          fn from(mut other: VecDeque<T, A>) -> Self {
              other.make_contiguous();
      
              unsafe {
                  let other = ManuallyDrop::new(other);
                  let buf = other.buf.ptr();
                  let len = other.len();
                  let cap = other.capacity();
                  let alloc = ptr::read(other.allocator());
      
                  if other.head != 0 {
                      ptr::copy(buf.add(other.head), buf, len);
                  }
                  Vec::from_raw_parts_in(buf, len, cap, alloc)
              }
          }
      *)
      Definition from (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T A in
        match τ, α with
        | [], [ other ] =>
          ltac:(M.monadic
            (let other := M.alloc (| other |) in
            M.read (|
              let _ :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply (Ty.path "alloc::collections::vec_deque::VecDeque") [ T; A ],
                      "make_contiguous",
                      []
                    |),
                    [ other ]
                  |)
                |) in
              let other :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "core::mem::manually_drop::ManuallyDrop")
                        [ Ty.apply (Ty.path "alloc::collections::vec_deque::VecDeque") [ T; A ] ],
                      "new",
                      []
                    |),
                    [ M.read (| other |) ]
                  |)
                |) in
              let buf :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply (Ty.path "alloc::raw_vec::RawVec") [ T; A ],
                      "ptr",
                      []
                    |),
                    [
                      M.SubPointer.get_struct_record_field (|
                        M.call_closure (|
                          M.get_trait_method (|
                            "core::ops::deref::Deref",
                            Ty.apply
                              (Ty.path "core::mem::manually_drop::ManuallyDrop")
                              [
                                Ty.apply
                                  (Ty.path "alloc::collections::vec_deque::VecDeque")
                                  [ T; A ]
                              ],
                            [],
                            "deref",
                            []
                          |),
                          [ other ]
                        |),
                        "alloc::collections::vec_deque::VecDeque",
                        "buf"
                      |)
                    ]
                  |)
                |) in
              let len :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply (Ty.path "alloc::collections::vec_deque::VecDeque") [ T; A ],
                      "len",
                      []
                    |),
                    [
                      M.call_closure (|
                        M.get_trait_method (|
                          "core::ops::deref::Deref",
                          Ty.apply
                            (Ty.path "core::mem::manually_drop::ManuallyDrop")
                            [ Ty.apply (Ty.path "alloc::collections::vec_deque::VecDeque") [ T; A ]
                            ],
                          [],
                          "deref",
                          []
                        |),
                        [ other ]
                      |)
                    ]
                  |)
                |) in
              let cap :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply (Ty.path "alloc::collections::vec_deque::VecDeque") [ T; A ],
                      "capacity",
                      []
                    |),
                    [
                      M.call_closure (|
                        M.get_trait_method (|
                          "core::ops::deref::Deref",
                          Ty.apply
                            (Ty.path "core::mem::manually_drop::ManuallyDrop")
                            [ Ty.apply (Ty.path "alloc::collections::vec_deque::VecDeque") [ T; A ]
                            ],
                          [],
                          "deref",
                          []
                        |),
                        [ other ]
                      |)
                    ]
                  |)
                |) in
              let alloc :=
                M.alloc (|
                  M.call_closure (|
                    M.get_function (| "core::ptr::read", [ A ] |),
                    [
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "alloc::collections::vec_deque::VecDeque") [ T; A ],
                          "allocator",
                          []
                        |),
                        [
                          M.call_closure (|
                            M.get_trait_method (|
                              "core::ops::deref::Deref",
                              Ty.apply
                                (Ty.path "core::mem::manually_drop::ManuallyDrop")
                                [
                                  Ty.apply
                                    (Ty.path "alloc::collections::vec_deque::VecDeque")
                                    [ T; A ]
                                ],
                              [],
                              "deref",
                              []
                            |),
                            [ other ]
                          |)
                        ]
                      |)
                    ]
                  |)
                |) in
              let _ :=
                M.match_operator (|
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ :=
                          M.use
                            (M.alloc (|
                              BinOp.Pure.ne
                                (M.read (|
                                  M.SubPointer.get_struct_record_field (|
                                    M.call_closure (|
                                      M.get_trait_method (|
                                        "core::ops::deref::Deref",
                                        Ty.apply
                                          (Ty.path "core::mem::manually_drop::ManuallyDrop")
                                          [
                                            Ty.apply
                                              (Ty.path "alloc::collections::vec_deque::VecDeque")
                                              [ T; A ]
                                          ],
                                        [],
                                        "deref",
                                        []
                                      |),
                                      [ other ]
                                    |),
                                    "alloc::collections::vec_deque::VecDeque",
                                    "head"
                                  |)
                                |))
                                (Value.Integer 0)
                            |)) in
                        let _ :=
                          M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        let _ :=
                          M.alloc (|
                            M.call_closure (|
                              M.get_function (| "core::intrinsics::copy", [ T ] |),
                              [
                                (* MutToConstPointer *)
                                M.pointer_coercion
                                  (M.call_closure (|
                                    M.get_associated_function (|
                                      Ty.apply (Ty.path "*mut") [ T ],
                                      "add",
                                      []
                                    |),
                                    [
                                      M.read (| buf |);
                                      M.read (|
                                        M.SubPointer.get_struct_record_field (|
                                          M.call_closure (|
                                            M.get_trait_method (|
                                              "core::ops::deref::Deref",
                                              Ty.apply
                                                (Ty.path "core::mem::manually_drop::ManuallyDrop")
                                                [
                                                  Ty.apply
                                                    (Ty.path
                                                      "alloc::collections::vec_deque::VecDeque")
                                                    [ T; A ]
                                                ],
                                              [],
                                              "deref",
                                              []
                                            |),
                                            [ other ]
                                          |),
                                          "alloc::collections::vec_deque::VecDeque",
                                          "head"
                                        |)
                                      |)
                                    ]
                                  |));
                                M.read (| buf |);
                                M.read (| len |)
                              ]
                            |)
                          |) in
                        M.alloc (| Value.Tuple [] |)));
                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                  ]
                |) in
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "alloc::vec::Vec") [ T; A ],
                    "from_raw_parts_in",
                    []
                  |),
                  [ M.read (| buf |); M.read (| len |); M.read (| cap |); M.read (| alloc |) ]
                |)
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (T A : Ty.t),
        M.IsTraitInstance
          "core::convert::From"
          (Self T A)
          (* Trait polymorphic types *)
          [ (* T *) Ty.apply (Ty.path "alloc::collections::vec_deque::VecDeque") [ T; A ] ]
          (* Instance *) [ ("from", InstanceField.Method (from T A)) ].
    End Impl_core_convert_From_where_core_alloc_Allocator_A_alloc_collections_vec_deque_VecDeque_T_A_for_alloc_vec_Vec_T_A.
    
    Module Impl_core_convert_From_array_T_for_alloc_collections_vec_deque_VecDeque_T_alloc_alloc_Global.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply
          (Ty.path "alloc::collections::vec_deque::VecDeque")
          [ T; Ty.path "alloc::alloc::Global" ].
      
      (*
          fn from(arr: [T; N]) -> Self {
              let mut deq = VecDeque::with_capacity(N);
              let arr = ManuallyDrop::new(arr);
              if !<T>::IS_ZST {
                  // SAFETY: VecDeque::with_capacity ensures that there is enough capacity.
                  unsafe {
                      ptr::copy_nonoverlapping(arr.as_ptr(), deq.ptr(), N);
                  }
              }
              deq.head = 0;
              deq.len = N;
              deq
          }
      *)
      Definition from (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ arr ] =>
          ltac:(M.monadic
            (let arr := M.alloc (| arr |) in
            M.read (|
              let deq :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "alloc::collections::vec_deque::VecDeque")
                        [ T; Ty.path "alloc::alloc::Global" ],
                      "with_capacity",
                      []
                    |),
                    [ M.read (| M.get_constant (| "alloc::collections::vec_deque::N" |) |) ]
                  |)
                |) in
              let arr :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "core::mem::manually_drop::ManuallyDrop")
                        [ Ty.apply (Ty.path "array") [ T ] ],
                      "new",
                      []
                    |),
                    [ M.read (| arr |) ]
                  |)
                |) in
              let _ :=
                M.match_operator (|
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ :=
                          M.use
                            (M.alloc (|
                              UnOp.Pure.not
                                (M.read (|
                                  M.get_constant (| "core::mem::SizedTypeProperties::IS_ZST" |)
                                |))
                            |)) in
                        let _ :=
                          M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        let _ :=
                          M.alloc (|
                            M.call_closure (|
                              M.get_function (| "core::intrinsics::copy_nonoverlapping", [ T ] |),
                              [
                                M.call_closure (|
                                  M.get_associated_function (|
                                    Ty.apply (Ty.path "slice") [ T ],
                                    "as_ptr",
                                    []
                                  |),
                                  [
                                    (* Unsize *)
                                    M.pointer_coercion
                                      (M.call_closure (|
                                        M.get_trait_method (|
                                          "core::ops::deref::Deref",
                                          Ty.apply
                                            (Ty.path "core::mem::manually_drop::ManuallyDrop")
                                            [ Ty.apply (Ty.path "array") [ T ] ],
                                          [],
                                          "deref",
                                          []
                                        |),
                                        [ arr ]
                                      |))
                                  ]
                                |);
                                M.call_closure (|
                                  M.get_associated_function (|
                                    Ty.apply
                                      (Ty.path "alloc::collections::vec_deque::VecDeque")
                                      [ T; Ty.path "alloc::alloc::Global" ],
                                    "ptr",
                                    []
                                  |),
                                  [ deq ]
                                |);
                                M.read (| M.get_constant (| "alloc::collections::vec_deque::N" |) |)
                              ]
                            |)
                          |) in
                        M.alloc (| Value.Tuple [] |)));
                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                  ]
                |) in
              let _ :=
                M.write (|
                  M.SubPointer.get_struct_record_field (|
                    deq,
                    "alloc::collections::vec_deque::VecDeque",
                    "head"
                  |),
                  Value.Integer 0
                |) in
              let _ :=
                M.write (|
                  M.SubPointer.get_struct_record_field (|
                    deq,
                    "alloc::collections::vec_deque::VecDeque",
                    "len"
                  |),
                  M.read (| M.get_constant (| "alloc::collections::vec_deque::N" |) |)
                |) in
              deq
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::convert::From"
          (Self T)
          (* Trait polymorphic types *) [ (* T *) Ty.apply (Ty.path "array") [ T ] ]
          (* Instance *) [ ("from", InstanceField.Method (from T)) ].
    End Impl_core_convert_From_array_T_for_alloc_collections_vec_deque_VecDeque_T_alloc_alloc_Global.
  End vec_deque.
End collections.
