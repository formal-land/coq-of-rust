(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module raw_vec.
  (*
  Enum AllocInit
  {
    ty_params := [];
    variants :=
      [
        {
          name := "Uninitialized";
          item := StructTuple [];
          discriminant := None;
        };
        {
          name := "Zeroed";
          item := StructTuple [];
          discriminant := None;
        }
      ];
  }
  *)
  
  (* StructRecord
    {
      name := "RawVec";
      ty_params := [ "T"; "A" ];
      fields :=
        [
          ("ptr", Ty.apply (Ty.path "core::ptr::unique::Unique") [ T ]);
          ("cap", Ty.path "usize");
          ("alloc", A)
        ];
    } *)
  
  Module Impl_alloc_raw_vec_RawVec_T_alloc_alloc_Global.
    Definition Self (T : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "alloc::raw_vec::RawVec") [ T; Ty.path "alloc::alloc::Global" ].
    
    (*     pub const NEW: Self = Self::new(); *)
    (* Ty.apply (Ty.path "alloc::raw_vec::RawVec") [ T; Ty.path "alloc::alloc::Global" ] *)
    Definition value_NEW (T : Ty.t) : Value.t :=
      let Self : Ty.t := Self T in
      M.run
        ltac:(M.monadic
          (M.alloc (|
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply (Ty.path "alloc::raw_vec::RawVec") [ T; Ty.path "alloc::alloc::Global" ],
                "new",
                []
              |),
              []
            |)
          |))).
    
    Axiom AssociatedConstant_value_NEW :
      forall (T : Ty.t),
      M.IsAssociatedConstant (Self T) "value_NEW" (value_NEW T).
    
    (*
        pub const fn new() -> Self {
            Self::new_in(Global)
        }
    *)
    Definition new (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match τ, α with
      | [], [] =>
        ltac:(M.monadic
          (M.call_closure (|
            M.get_associated_function (|
              Ty.apply (Ty.path "alloc::raw_vec::RawVec") [ T; Ty.path "alloc::alloc::Global" ],
              "new_in",
              []
            |),
            [ Value.StructTuple "alloc::alloc::Global" [] ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_new : forall (T : Ty.t), M.IsAssociatedFunction (Self T) "new" (new T).
    
    (*
        pub fn with_capacity(capacity: usize) -> Self {
            Self::with_capacity_in(capacity, Global)
        }
    *)
    Definition with_capacity (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match τ, α with
      | [], [ capacity ] =>
        ltac:(M.monadic
          (let capacity := M.alloc (| capacity |) in
          M.call_closure (|
            M.get_associated_function (|
              Ty.apply (Ty.path "alloc::raw_vec::RawVec") [ T; Ty.path "alloc::alloc::Global" ],
              "with_capacity_in",
              []
            |),
            [ M.read (| capacity |); Value.StructTuple "alloc::alloc::Global" [] ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_with_capacity :
      forall (T : Ty.t),
      M.IsAssociatedFunction (Self T) "with_capacity" (with_capacity T).
    
    (*
        pub fn with_capacity_zeroed(capacity: usize) -> Self {
            Self::with_capacity_zeroed_in(capacity, Global)
        }
    *)
    Definition with_capacity_zeroed (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match τ, α with
      | [], [ capacity ] =>
        ltac:(M.monadic
          (let capacity := M.alloc (| capacity |) in
          M.call_closure (|
            M.get_associated_function (|
              Ty.apply (Ty.path "alloc::raw_vec::RawVec") [ T; Ty.path "alloc::alloc::Global" ],
              "with_capacity_zeroed_in",
              []
            |),
            [ M.read (| capacity |); Value.StructTuple "alloc::alloc::Global" [] ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_with_capacity_zeroed :
      forall (T : Ty.t),
      M.IsAssociatedFunction (Self T) "with_capacity_zeroed" (with_capacity_zeroed T).
  End Impl_alloc_raw_vec_RawVec_T_alloc_alloc_Global.
  
  Module Impl_alloc_raw_vec_RawVec_T_A.
    Definition Self (T A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::raw_vec::RawVec") [ T; A ].
    
    (*
        pub(crate) const MIN_NON_ZERO_CAP: usize = if mem::size_of::<T>() == 1 {
            8
        } else if mem::size_of::<T>() <= 1024 {
            4
        } else {
            1
        };
    *)
    (* Ty.path "usize" *)
    Definition value_MIN_NON_ZERO_CAP (T A : Ty.t) : Value.t :=
      let Self : Ty.t := Self T A in
      M.run
        ltac:(M.monadic
          (M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        BinOp.Pure.eq
                          (M.call_closure (|
                            M.get_function (| "core::mem::size_of", [ T ] |),
                            []
                          |))
                          (Value.Integer 1)
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (| Value.Integer 8 |)));
              fun γ =>
                ltac:(M.monadic
                  (M.match_operator (|
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                BinOp.Pure.le
                                  (M.call_closure (|
                                    M.get_function (| "core::mem::size_of", [ T ] |),
                                    []
                                  |))
                                  (Value.Integer 1024)
                              |)) in
                          let _ :=
                            M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (| Value.Integer 4 |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Integer 1 |)))
                    ]
                  |)))
            ]
          |))).
    
    Axiom AssociatedConstant_value_MIN_NON_ZERO_CAP :
      forall (T A : Ty.t),
      M.IsAssociatedConstant (Self T A) "value_MIN_NON_ZERO_CAP" (value_MIN_NON_ZERO_CAP T A).
    
    (*
        pub const fn new_in(alloc: A) -> Self {
            // `cap: 0` means "unallocated". zero-sized types are ignored.
            Self { ptr: Unique::dangling(), cap: 0, alloc }
        }
    *)
    Definition new_in (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match τ, α with
      | [], [ alloc ] =>
        ltac:(M.monadic
          (let alloc := M.alloc (| alloc |) in
          Value.StructRecord
            "alloc::raw_vec::RawVec"
            [
              ("ptr",
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::ptr::unique::Unique") [ T ],
                    "dangling",
                    []
                  |),
                  []
                |));
              ("cap", Value.Integer 0);
              ("alloc", M.read (| alloc |))
            ]))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_new_in :
      forall (T A : Ty.t),
      M.IsAssociatedFunction (Self T A) "new_in" (new_in T A).
    
    (*
        pub fn with_capacity_in(capacity: usize, alloc: A) -> Self {
            Self::allocate_in(capacity, AllocInit::Uninitialized, alloc)
        }
    *)
    Definition with_capacity_in (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match τ, α with
      | [], [ capacity; alloc ] =>
        ltac:(M.monadic
          (let capacity := M.alloc (| capacity |) in
          let alloc := M.alloc (| alloc |) in
          M.call_closure (|
            M.get_associated_function (|
              Ty.apply (Ty.path "alloc::raw_vec::RawVec") [ T; A ],
              "allocate_in",
              []
            |),
            [
              M.read (| capacity |);
              Value.StructTuple "alloc::raw_vec::AllocInit::Uninitialized" [];
              M.read (| alloc |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_with_capacity_in :
      forall (T A : Ty.t),
      M.IsAssociatedFunction (Self T A) "with_capacity_in" (with_capacity_in T A).
    
    (*
        pub fn with_capacity_zeroed_in(capacity: usize, alloc: A) -> Self {
            Self::allocate_in(capacity, AllocInit::Zeroed, alloc)
        }
    *)
    Definition with_capacity_zeroed_in (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match τ, α with
      | [], [ capacity; alloc ] =>
        ltac:(M.monadic
          (let capacity := M.alloc (| capacity |) in
          let alloc := M.alloc (| alloc |) in
          M.call_closure (|
            M.get_associated_function (|
              Ty.apply (Ty.path "alloc::raw_vec::RawVec") [ T; A ],
              "allocate_in",
              []
            |),
            [
              M.read (| capacity |);
              Value.StructTuple "alloc::raw_vec::AllocInit::Zeroed" [];
              M.read (| alloc |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_with_capacity_zeroed_in :
      forall (T A : Ty.t),
      M.IsAssociatedFunction (Self T A) "with_capacity_zeroed_in" (with_capacity_zeroed_in T A).
    
    (*
        pub unsafe fn into_box(self, len: usize) -> Box<[MaybeUninit<T>], A> {
            // Sanity-check one half of the safety requirement (we cannot check the other half).
            debug_assert!(
                len <= self.capacity(),
                "`len` must be smaller than or equal to `self.capacity()`"
            );
    
            let me = ManuallyDrop::new(self);
            unsafe {
                let slice = slice::from_raw_parts_mut(me.ptr() as *mut MaybeUninit<T>, len);
                Box::from_raw_in(slice, ptr::read(&me.alloc))
            }
        }
    *)
    Definition into_box (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match τ, α with
      | [], [ self; len ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let len := M.alloc (| len |) in
          M.read (|
            let _ :=
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.use (M.alloc (| Value.Bool true |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      let _ :=
                        M.match_operator (|
                          M.alloc (| Value.Tuple [] |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ :=
                                  M.use
                                    (M.alloc (|
                                      UnOp.Pure.not
                                        (BinOp.Pure.le
                                          (M.read (| len |))
                                          (M.call_closure (|
                                            M.get_associated_function (|
                                              Ty.apply (Ty.path "alloc::raw_vec::RawVec") [ T; A ],
                                              "capacity",
                                              []
                                            |),
                                            [ self ]
                                          |)))
                                    |)) in
                                let _ :=
                                  M.is_constant_or_break_match (|
                                    M.read (| γ |),
                                    Value.Bool true
                                  |) in
                                M.alloc (|
                                  M.never_to_any (|
                                    M.call_closure (|
                                      M.get_function (| "core::panicking::panic_fmt", [] |),
                                      [
                                        M.call_closure (|
                                          M.get_associated_function (|
                                            Ty.path "core::fmt::Arguments",
                                            "new_const",
                                            []
                                          |),
                                          [
                                            (* Unsize *)
                                            M.pointer_coercion
                                              (M.alloc (|
                                                Value.Array
                                                  [
                                                    M.read (|
                                                      Value.String
                                                        "`len` must be smaller than or equal to `self.capacity()`"
                                                    |)
                                                  ]
                                              |))
                                          ]
                                        |)
                                      ]
                                    |)
                                  |)
                                |)));
                            fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                          ]
                        |) in
                      M.alloc (| Value.Tuple [] |)));
                  fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                ]
              |) in
            let me :=
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "core::mem::manually_drop::ManuallyDrop")
                      [ Ty.apply (Ty.path "alloc::raw_vec::RawVec") [ T; A ] ],
                    "new",
                    []
                  |),
                  [ M.read (| self |) ]
                |)
              |) in
            let slice :=
              M.alloc (|
                M.call_closure (|
                  M.get_function (|
                    "core::slice::raw::from_raw_parts_mut",
                    [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ T ] ]
                  |),
                  [
                    M.rust_cast
                      (M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "alloc::raw_vec::RawVec") [ T; A ],
                          "ptr",
                          []
                        |),
                        [
                          M.call_closure (|
                            M.get_trait_method (|
                              "core::ops::deref::Deref",
                              Ty.apply
                                (Ty.path "core::mem::manually_drop::ManuallyDrop")
                                [ Ty.apply (Ty.path "alloc::raw_vec::RawVec") [ T; A ] ],
                              [],
                              "deref",
                              []
                            |),
                            [ me ]
                          |)
                        ]
                      |));
                    M.read (| len |)
                  ]
                |)
              |) in
            M.alloc (|
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "alloc::boxed::Box")
                    [
                      Ty.apply
                        (Ty.path "slice")
                        [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ T ] ];
                      A
                    ],
                  "from_raw_in",
                  []
                |),
                [
                  M.read (| slice |);
                  M.call_closure (|
                    M.get_function (| "core::ptr::read", [ A ] |),
                    [
                      M.SubPointer.get_struct_record_field (|
                        M.call_closure (|
                          M.get_trait_method (|
                            "core::ops::deref::Deref",
                            Ty.apply
                              (Ty.path "core::mem::manually_drop::ManuallyDrop")
                              [ Ty.apply (Ty.path "alloc::raw_vec::RawVec") [ T; A ] ],
                            [],
                            "deref",
                            []
                          |),
                          [ me ]
                        |),
                        "alloc::raw_vec::RawVec",
                        "alloc"
                      |)
                    ]
                  |)
                ]
              |)
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_into_box :
      forall (T A : Ty.t),
      M.IsAssociatedFunction (Self T A) "into_box" (into_box T A).
    
    (*
        fn allocate_in(capacity: usize, init: AllocInit, alloc: A) -> Self {
            // Don't allocate here because `Drop` will not deallocate when `capacity` is 0.
            if T::IS_ZST || capacity == 0 {
                Self::new_in(alloc)
            } else {
                // We avoid `unwrap_or_else` here because it bloats the amount of
                // LLVM IR generated.
                let layout = match Layout::array::<T>(capacity) {
                    Ok(layout) => layout,
                    Err(_) => capacity_overflow(),
                };
                match alloc_guard(layout.size()) {
                    Ok(_) => {}
                    Err(_) => capacity_overflow(),
                }
                let result = match init {
                    AllocInit::Uninitialized => alloc.allocate(layout),
                    AllocInit::Zeroed => alloc.allocate_zeroed(layout),
                };
                let ptr = match result {
                    Ok(ptr) => ptr,
                    Err(_) => handle_alloc_error(layout),
                };
    
                // Allocators currently return a `NonNull<[u8]>` whose length
                // matches the size requested. If that ever changes, the capacity
                // here should change to `ptr.len() / mem::size_of::<T>()`.
                Self {
                    ptr: unsafe { Unique::new_unchecked(ptr.cast().as_ptr()) },
                    cap: capacity,
                    alloc,
                }
            }
        }
    *)
    Definition allocate_in (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match τ, α with
      | [], [ capacity; init; alloc ] =>
        ltac:(M.monadic
          (let capacity := M.alloc (| capacity |) in
          let init := M.alloc (| init |) in
          let alloc := M.alloc (| alloc |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          LogicalOp.or (|
                            M.read (|
                              M.get_constant (| "core::mem::SizedTypeProperties::IS_ZST" |)
                            |),
                            ltac:(M.monadic
                              (BinOp.Pure.eq (M.read (| capacity |)) (Value.Integer 0)))
                          |)
                        |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "alloc::raw_vec::RawVec") [ T; A ],
                          "new_in",
                          []
                        |),
                        [ M.read (| alloc |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let layout :=
                      M.copy (|
                        M.match_operator (|
                          M.alloc (|
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.path "core::alloc::layout::Layout",
                                "array",
                                [ T ]
                              |),
                              [ M.read (| capacity |) ]
                            |)
                          |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ0_0 :=
                                  M.SubPointer.get_struct_tuple_field (|
                                    γ,
                                    "core::result::Result::Ok",
                                    0
                                  |) in
                                let layout := M.copy (| γ0_0 |) in
                                layout));
                            fun γ =>
                              ltac:(M.monadic
                                (let γ0_0 :=
                                  M.SubPointer.get_struct_tuple_field (|
                                    γ,
                                    "core::result::Result::Err",
                                    0
                                  |) in
                                M.alloc (|
                                  M.never_to_any (|
                                    M.call_closure (|
                                      M.get_function (| "alloc::raw_vec::capacity_overflow", [] |),
                                      []
                                    |)
                                  |)
                                |)))
                          ]
                        |)
                      |) in
                    let _ :=
                      M.match_operator (|
                        M.alloc (|
                          M.call_closure (|
                            M.get_function (| "alloc::raw_vec::alloc_guard", [] |),
                            [
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.path "core::alloc::layout::Layout",
                                  "size",
                                  []
                                |),
                                [ layout ]
                              |)
                            ]
                          |)
                        |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 :=
                                M.SubPointer.get_struct_tuple_field (|
                                  γ,
                                  "core::result::Result::Ok",
                                  0
                                |) in
                              M.alloc (| Value.Tuple [] |)));
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 :=
                                M.SubPointer.get_struct_tuple_field (|
                                  γ,
                                  "core::result::Result::Err",
                                  0
                                |) in
                              M.alloc (|
                                M.never_to_any (|
                                  M.call_closure (|
                                    M.get_function (| "alloc::raw_vec::capacity_overflow", [] |),
                                    []
                                  |)
                                |)
                              |)))
                        ]
                      |) in
                    let result :=
                      M.copy (|
                        M.match_operator (|
                          init,
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (M.alloc (|
                                  M.call_closure (|
                                    M.get_trait_method (|
                                      "core::alloc::Allocator",
                                      A,
                                      [],
                                      "allocate",
                                      []
                                    |),
                                    [ alloc; M.read (| layout |) ]
                                  |)
                                |)));
                            fun γ =>
                              ltac:(M.monadic
                                (M.alloc (|
                                  M.call_closure (|
                                    M.get_trait_method (|
                                      "core::alloc::Allocator",
                                      A,
                                      [],
                                      "allocate_zeroed",
                                      []
                                    |),
                                    [ alloc; M.read (| layout |) ]
                                  |)
                                |)))
                          ]
                        |)
                      |) in
                    let ptr :=
                      M.copy (|
                        M.match_operator (|
                          result,
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ0_0 :=
                                  M.SubPointer.get_struct_tuple_field (|
                                    γ,
                                    "core::result::Result::Ok",
                                    0
                                  |) in
                                let ptr := M.copy (| γ0_0 |) in
                                ptr));
                            fun γ =>
                              ltac:(M.monadic
                                (let γ0_0 :=
                                  M.SubPointer.get_struct_tuple_field (|
                                    γ,
                                    "core::result::Result::Err",
                                    0
                                  |) in
                                M.alloc (|
                                  M.never_to_any (|
                                    M.call_closure (|
                                      M.get_function (| "alloc::alloc::handle_alloc_error", [] |),
                                      [ M.read (| layout |) ]
                                    |)
                                  |)
                                |)))
                          ]
                        |)
                      |) in
                    M.alloc (|
                      Value.StructRecord
                        "alloc::raw_vec::RawVec"
                        [
                          ("ptr",
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply (Ty.path "core::ptr::unique::Unique") [ T ],
                                "new_unchecked",
                                []
                              |),
                              [
                                M.call_closure (|
                                  M.get_associated_function (|
                                    Ty.apply (Ty.path "core::ptr::non_null::NonNull") [ T ],
                                    "as_ptr",
                                    []
                                  |),
                                  [
                                    M.call_closure (|
                                      M.get_associated_function (|
                                        Ty.apply
                                          (Ty.path "core::ptr::non_null::NonNull")
                                          [ Ty.apply (Ty.path "slice") [ Ty.path "u8" ] ],
                                        "cast",
                                        [ T ]
                                      |),
                                      [ M.read (| ptr |) ]
                                    |)
                                  ]
                                |)
                              ]
                            |));
                          ("cap", M.read (| capacity |));
                          ("alloc", M.read (| alloc |))
                        ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_allocate_in :
      forall (T A : Ty.t),
      M.IsAssociatedFunction (Self T A) "allocate_in" (allocate_in T A).
    
    (*
        pub unsafe fn from_raw_parts_in(ptr: *mut T, capacity: usize, alloc: A) -> Self {
            Self { ptr: unsafe { Unique::new_unchecked(ptr) }, cap: capacity, alloc }
        }
    *)
    Definition from_raw_parts_in (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match τ, α with
      | [], [ ptr; capacity; alloc ] =>
        ltac:(M.monadic
          (let ptr := M.alloc (| ptr |) in
          let capacity := M.alloc (| capacity |) in
          let alloc := M.alloc (| alloc |) in
          Value.StructRecord
            "alloc::raw_vec::RawVec"
            [
              ("ptr",
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::ptr::unique::Unique") [ T ],
                    "new_unchecked",
                    []
                  |),
                  [ M.read (| ptr |) ]
                |));
              ("cap", M.read (| capacity |));
              ("alloc", M.read (| alloc |))
            ]))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_from_raw_parts_in :
      forall (T A : Ty.t),
      M.IsAssociatedFunction (Self T A) "from_raw_parts_in" (from_raw_parts_in T A).
    
    (*
        pub fn ptr(&self) -> *mut T {
            self.ptr.as_ptr()
        }
    *)
    Definition ptr (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_associated_function (|
              Ty.apply (Ty.path "core::ptr::unique::Unique") [ T ],
              "as_ptr",
              []
            |),
            [
              M.read (|
                M.SubPointer.get_struct_record_field (|
                  M.read (| self |),
                  "alloc::raw_vec::RawVec",
                  "ptr"
                |)
              |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_ptr :
      forall (T A : Ty.t),
      M.IsAssociatedFunction (Self T A) "ptr" (ptr T A).
    
    (*
        pub fn capacity(&self) -> usize {
            if T::IS_ZST { usize::MAX } else { self.cap }
        }
    *)
    Definition capacity (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use (M.get_constant (| "core::mem::SizedTypeProperties::IS_ZST" |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.get_constant (| "core::num::MAX" |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "alloc::raw_vec::RawVec",
                      "cap"
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_capacity :
      forall (T A : Ty.t),
      M.IsAssociatedFunction (Self T A) "capacity" (capacity T A).
    
    (*
        pub fn allocator(&self) -> &A {
            &self.alloc
        }
    *)
    Definition allocator (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.SubPointer.get_struct_record_field (|
            M.read (| self |),
            "alloc::raw_vec::RawVec",
            "alloc"
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_allocator :
      forall (T A : Ty.t),
      M.IsAssociatedFunction (Self T A) "allocator" (allocator T A).
    
    (*
        fn current_memory(&self) -> Option<(NonNull<u8>, Layout)> {
            if T::IS_ZST || self.cap == 0 {
                None
            } else {
                // We could use Layout::array here which ensures the absence of isize and usize overflows
                // and could hypothetically handle differences between stride and size, but this memory
                // has already been allocated so we know it can't overflow and currently rust does not
                // support such types. So we can do better by skipping some checks and avoid an unwrap.
                let _: () = const { assert!(mem::size_of::<T>() % mem::align_of::<T>() == 0) };
                unsafe {
                    let align = mem::align_of::<T>();
                    let size = mem::size_of::<T>().unchecked_mul(self.cap);
                    let layout = Layout::from_size_align_unchecked(size, align);
                    Some((self.ptr.cast().into(), layout))
                }
            }
        }
    *)
    Definition current_memory (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          LogicalOp.or (|
                            M.read (|
                              M.get_constant (| "core::mem::SizedTypeProperties::IS_ZST" |)
                            |),
                            ltac:(M.monadic
                              (BinOp.Pure.eq
                                (M.read (|
                                  M.SubPointer.get_struct_record_field (|
                                    M.read (| self |),
                                    "alloc::raw_vec::RawVec",
                                    "cap"
                                  |)
                                |))
                                (Value.Integer 0)))
                          |)
                        |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.match_operator (|
                      M.get_constant (| "alloc::raw_vec::current_memory_discriminant" |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let align :=
                              M.alloc (|
                                M.call_closure (|
                                  M.get_function (| "core::mem::align_of", [ T ] |),
                                  []
                                |)
                              |) in
                            let size :=
                              M.alloc (|
                                M.call_closure (|
                                  M.get_associated_function (|
                                    Ty.path "usize",
                                    "unchecked_mul",
                                    []
                                  |),
                                  [
                                    M.call_closure (|
                                      M.get_function (| "core::mem::size_of", [ T ] |),
                                      []
                                    |);
                                    M.read (|
                                      M.SubPointer.get_struct_record_field (|
                                        M.read (| self |),
                                        "alloc::raw_vec::RawVec",
                                        "cap"
                                      |)
                                    |)
                                  ]
                                |)
                              |) in
                            let layout :=
                              M.alloc (|
                                M.call_closure (|
                                  M.get_associated_function (|
                                    Ty.path "core::alloc::layout::Layout",
                                    "from_size_align_unchecked",
                                    []
                                  |),
                                  [ M.read (| size |); M.read (| align |) ]
                                |)
                              |) in
                            M.alloc (|
                              Value.StructTuple
                                "core::option::Option::Some"
                                [
                                  Value.Tuple
                                    [
                                      M.call_closure (|
                                        M.get_trait_method (|
                                          "core::convert::Into",
                                          Ty.apply
                                            (Ty.path "core::ptr::unique::Unique")
                                            [ Ty.path "u8" ],
                                          [
                                            Ty.apply
                                              (Ty.path "core::ptr::non_null::NonNull")
                                              [ Ty.path "u8" ]
                                          ],
                                          "into",
                                          []
                                        |),
                                        [
                                          M.call_closure (|
                                            M.get_associated_function (|
                                              Ty.apply (Ty.path "core::ptr::unique::Unique") [ T ],
                                              "cast",
                                              [ Ty.path "u8" ]
                                            |),
                                            [
                                              M.read (|
                                                M.SubPointer.get_struct_record_field (|
                                                  M.read (| self |),
                                                  "alloc::raw_vec::RawVec",
                                                  "ptr"
                                                |)
                                              |)
                                            ]
                                          |)
                                        ]
                                      |);
                                      M.read (| layout |)
                                    ]
                                ]
                            |)))
                      ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_current_memory :
      forall (T A : Ty.t),
      M.IsAssociatedFunction (Self T A) "current_memory" (current_memory T A).
    
    (*
        pub fn reserve(&mut self, len: usize, additional: usize) {
            // Callers expect this function to be very cheap when there is already sufficient capacity.
            // Therefore, we move all the resizing and error-handling logic from grow_amortized and
            // handle_reserve behind a call, while making sure that this function is likely to be
            // inlined as just a comparison and a call if the comparison fails.
            #[cold]
            fn do_reserve_and_handle<T, A: Allocator>(
                slf: &mut RawVec<T, A>,
                len: usize,
                additional: usize,
            ) {
                handle_reserve(slf.grow_amortized(len, additional));
            }
    
            if self.needs_to_grow(len, additional) {
                do_reserve_and_handle(self, len, additional);
            }
        }
    *)
    Definition reserve (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match τ, α with
      | [], [ self; len; additional ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let len := M.alloc (| len |) in
          let additional := M.alloc (| additional |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply (Ty.path "alloc::raw_vec::RawVec") [ T; A ],
                              "needs_to_grow",
                              []
                            |),
                            [ M.read (| self |); M.read (| len |); M.read (| additional |) ]
                          |)
                        |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    let _ :=
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (| Self, "do_reserve_and_handle.reserve", [] |),
                          [ M.read (| self |); M.read (| len |); M.read (| additional |) ]
                        |)
                      |) in
                    M.alloc (| Value.Tuple [] |)));
                fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_reserve :
      forall (T A : Ty.t),
      M.IsAssociatedFunction (Self T A) "reserve" (reserve T A).
    
    (*
        pub fn reserve_for_push(&mut self, len: usize) {
            handle_reserve(self.grow_amortized(len, 1));
        }
    *)
    Definition reserve_for_push (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match τ, α with
      | [], [ self; len ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let len := M.alloc (| len |) in
          M.read (|
            let _ :=
              M.alloc (|
                M.call_closure (|
                  M.get_function (| "alloc::raw_vec::handle_reserve", [] |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "alloc::raw_vec::RawVec") [ T; A ],
                        "grow_amortized",
                        []
                      |),
                      [ M.read (| self |); M.read (| len |); Value.Integer 1 ]
                    |)
                  ]
                |)
              |) in
            M.alloc (| Value.Tuple [] |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_reserve_for_push :
      forall (T A : Ty.t),
      M.IsAssociatedFunction (Self T A) "reserve_for_push" (reserve_for_push T A).
    
    (*
        pub fn try_reserve(&mut self, len: usize, additional: usize) -> Result<(), TryReserveError> {
            if self.needs_to_grow(len, additional) {
                self.grow_amortized(len, additional)?;
            }
            unsafe {
                // Inform the optimizer that the reservation has succeeded or wasn't needed
                core::intrinsics::assume(!self.needs_to_grow(len, additional));
            }
            Ok(())
        }
    *)
    Definition try_reserve (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match τ, α with
      | [], [ self; len; additional ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let len := M.alloc (| len |) in
          let additional := M.alloc (| additional |) in
          M.catch_return (|
            ltac:(M.monadic
              (M.read (|
                let _ :=
                  M.match_operator (|
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                M.call_closure (|
                                  M.get_associated_function (|
                                    Ty.apply (Ty.path "alloc::raw_vec::RawVec") [ T; A ],
                                    "needs_to_grow",
                                    []
                                  |),
                                  [ M.read (| self |); M.read (| len |); M.read (| additional |) ]
                                |)
                              |)) in
                          let _ :=
                            M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          let _ :=
                            M.match_operator (|
                              M.alloc (|
                                M.call_closure (|
                                  M.get_trait_method (|
                                    "core::ops::try_trait::Try",
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      [ Ty.tuple []; Ty.path "alloc::collections::TryReserveError"
                                      ],
                                    [],
                                    "branch",
                                    []
                                  |),
                                  [
                                    M.call_closure (|
                                      M.get_associated_function (|
                                        Ty.apply (Ty.path "alloc::raw_vec::RawVec") [ T; A ],
                                        "grow_amortized",
                                        []
                                      |),
                                      [ M.read (| self |); M.read (| len |); M.read (| additional |)
                                      ]
                                    |)
                                  ]
                                |)
                              |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let γ0_0 :=
                                      M.SubPointer.get_struct_tuple_field (|
                                        γ,
                                        "core::ops::control_flow::ControlFlow::Break",
                                        0
                                      |) in
                                    let residual := M.copy (| γ0_0 |) in
                                    M.alloc (|
                                      M.never_to_any (|
                                        M.read (|
                                          M.return_ (|
                                            M.call_closure (|
                                              M.get_trait_method (|
                                                "core::ops::try_trait::FromResidual",
                                                Ty.apply
                                                  (Ty.path "core::result::Result")
                                                  [
                                                    Ty.tuple [];
                                                    Ty.path "alloc::collections::TryReserveError"
                                                  ],
                                                [
                                                  Ty.apply
                                                    (Ty.path "core::result::Result")
                                                    [
                                                      Ty.path "core::convert::Infallible";
                                                      Ty.path "alloc::collections::TryReserveError"
                                                    ]
                                                ],
                                                "from_residual",
                                                []
                                              |),
                                              [ M.read (| residual |) ]
                                            |)
                                          |)
                                        |)
                                      |)
                                    |)));
                                fun γ =>
                                  ltac:(M.monadic
                                    (let γ0_0 :=
                                      M.SubPointer.get_struct_tuple_field (|
                                        γ,
                                        "core::ops::control_flow::ControlFlow::Continue",
                                        0
                                      |) in
                                    let val := M.copy (| γ0_0 |) in
                                    val))
                              ]
                            |) in
                          M.alloc (| Value.Tuple [] |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                let _ :=
                  let _ :=
                    M.alloc (|
                      M.call_closure (|
                        M.get_function (| "core::intrinsics::assume", [] |),
                        [
                          UnOp.Pure.not
                            (M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply (Ty.path "alloc::raw_vec::RawVec") [ T; A ],
                                "needs_to_grow",
                                []
                              |),
                              [ M.read (| self |); M.read (| len |); M.read (| additional |) ]
                            |))
                        ]
                      |)
                    |) in
                  M.alloc (| Value.Tuple [] |) in
                M.alloc (| Value.StructTuple "core::result::Result::Ok" [ Value.Tuple [] ] |)
              |)))
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_try_reserve :
      forall (T A : Ty.t),
      M.IsAssociatedFunction (Self T A) "try_reserve" (try_reserve T A).
    
    (*
        pub fn reserve_exact(&mut self, len: usize, additional: usize) {
            handle_reserve(self.try_reserve_exact(len, additional));
        }
    *)
    Definition reserve_exact (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match τ, α with
      | [], [ self; len; additional ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let len := M.alloc (| len |) in
          let additional := M.alloc (| additional |) in
          M.read (|
            let _ :=
              M.alloc (|
                M.call_closure (|
                  M.get_function (| "alloc::raw_vec::handle_reserve", [] |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "alloc::raw_vec::RawVec") [ T; A ],
                        "try_reserve_exact",
                        []
                      |),
                      [ M.read (| self |); M.read (| len |); M.read (| additional |) ]
                    |)
                  ]
                |)
              |) in
            M.alloc (| Value.Tuple [] |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_reserve_exact :
      forall (T A : Ty.t),
      M.IsAssociatedFunction (Self T A) "reserve_exact" (reserve_exact T A).
    
    (*
        pub fn try_reserve_exact(
            &mut self,
            len: usize,
            additional: usize,
        ) -> Result<(), TryReserveError> {
            if self.needs_to_grow(len, additional) {
                self.grow_exact(len, additional)?;
            }
            unsafe {
                // Inform the optimizer that the reservation has succeeded or wasn't needed
                core::intrinsics::assume(!self.needs_to_grow(len, additional));
            }
            Ok(())
        }
    *)
    Definition try_reserve_exact (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match τ, α with
      | [], [ self; len; additional ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let len := M.alloc (| len |) in
          let additional := M.alloc (| additional |) in
          M.catch_return (|
            ltac:(M.monadic
              (M.read (|
                let _ :=
                  M.match_operator (|
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                M.call_closure (|
                                  M.get_associated_function (|
                                    Ty.apply (Ty.path "alloc::raw_vec::RawVec") [ T; A ],
                                    "needs_to_grow",
                                    []
                                  |),
                                  [ M.read (| self |); M.read (| len |); M.read (| additional |) ]
                                |)
                              |)) in
                          let _ :=
                            M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          let _ :=
                            M.match_operator (|
                              M.alloc (|
                                M.call_closure (|
                                  M.get_trait_method (|
                                    "core::ops::try_trait::Try",
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      [ Ty.tuple []; Ty.path "alloc::collections::TryReserveError"
                                      ],
                                    [],
                                    "branch",
                                    []
                                  |),
                                  [
                                    M.call_closure (|
                                      M.get_associated_function (|
                                        Ty.apply (Ty.path "alloc::raw_vec::RawVec") [ T; A ],
                                        "grow_exact",
                                        []
                                      |),
                                      [ M.read (| self |); M.read (| len |); M.read (| additional |)
                                      ]
                                    |)
                                  ]
                                |)
                              |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let γ0_0 :=
                                      M.SubPointer.get_struct_tuple_field (|
                                        γ,
                                        "core::ops::control_flow::ControlFlow::Break",
                                        0
                                      |) in
                                    let residual := M.copy (| γ0_0 |) in
                                    M.alloc (|
                                      M.never_to_any (|
                                        M.read (|
                                          M.return_ (|
                                            M.call_closure (|
                                              M.get_trait_method (|
                                                "core::ops::try_trait::FromResidual",
                                                Ty.apply
                                                  (Ty.path "core::result::Result")
                                                  [
                                                    Ty.tuple [];
                                                    Ty.path "alloc::collections::TryReserveError"
                                                  ],
                                                [
                                                  Ty.apply
                                                    (Ty.path "core::result::Result")
                                                    [
                                                      Ty.path "core::convert::Infallible";
                                                      Ty.path "alloc::collections::TryReserveError"
                                                    ]
                                                ],
                                                "from_residual",
                                                []
                                              |),
                                              [ M.read (| residual |) ]
                                            |)
                                          |)
                                        |)
                                      |)
                                    |)));
                                fun γ =>
                                  ltac:(M.monadic
                                    (let γ0_0 :=
                                      M.SubPointer.get_struct_tuple_field (|
                                        γ,
                                        "core::ops::control_flow::ControlFlow::Continue",
                                        0
                                      |) in
                                    let val := M.copy (| γ0_0 |) in
                                    val))
                              ]
                            |) in
                          M.alloc (| Value.Tuple [] |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                let _ :=
                  let _ :=
                    M.alloc (|
                      M.call_closure (|
                        M.get_function (| "core::intrinsics::assume", [] |),
                        [
                          UnOp.Pure.not
                            (M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply (Ty.path "alloc::raw_vec::RawVec") [ T; A ],
                                "needs_to_grow",
                                []
                              |),
                              [ M.read (| self |); M.read (| len |); M.read (| additional |) ]
                            |))
                        ]
                      |)
                    |) in
                  M.alloc (| Value.Tuple [] |) in
                M.alloc (| Value.StructTuple "core::result::Result::Ok" [ Value.Tuple [] ] |)
              |)))
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_try_reserve_exact :
      forall (T A : Ty.t),
      M.IsAssociatedFunction (Self T A) "try_reserve_exact" (try_reserve_exact T A).
    
    (*
        pub fn shrink_to_fit(&mut self, cap: usize) {
            handle_reserve(self.shrink(cap));
        }
    *)
    Definition shrink_to_fit (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match τ, α with
      | [], [ self; cap ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let cap := M.alloc (| cap |) in
          M.read (|
            let _ :=
              M.alloc (|
                M.call_closure (|
                  M.get_function (| "alloc::raw_vec::handle_reserve", [] |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "alloc::raw_vec::RawVec") [ T; A ],
                        "shrink",
                        []
                      |),
                      [ M.read (| self |); M.read (| cap |) ]
                    |)
                  ]
                |)
              |) in
            M.alloc (| Value.Tuple [] |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_shrink_to_fit :
      forall (T A : Ty.t),
      M.IsAssociatedFunction (Self T A) "shrink_to_fit" (shrink_to_fit T A).
    (*
        fn needs_to_grow(&self, len: usize, additional: usize) -> bool {
            additional > self.capacity().wrapping_sub(len)
        }
    *)
    Definition needs_to_grow (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match τ, α with
      | [], [ self; len; additional ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let len := M.alloc (| len |) in
          let additional := M.alloc (| additional |) in
          BinOp.Pure.gt
            (M.read (| additional |))
            (M.call_closure (|
              M.get_associated_function (| Ty.path "usize", "wrapping_sub", [] |),
              [
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "alloc::raw_vec::RawVec") [ T; A ],
                    "capacity",
                    []
                  |),
                  [ M.read (| self |) ]
                |);
                M.read (| len |)
              ]
            |))))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_needs_to_grow :
      forall (T A : Ty.t),
      M.IsAssociatedFunction (Self T A) "needs_to_grow" (needs_to_grow T A).
    
    (*
        fn set_ptr_and_cap(&mut self, ptr: NonNull<[u8]>, cap: usize) {
            // Allocators currently return a `NonNull<[u8]>` whose length matches
            // the size requested. If that ever changes, the capacity here should
            // change to `ptr.len() / mem::size_of::<T>()`.
            self.ptr = unsafe { Unique::new_unchecked(ptr.cast().as_ptr()) };
            self.cap = cap;
        }
    *)
    Definition set_ptr_and_cap (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match τ, α with
      | [], [ self; ptr; cap ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let ptr := M.alloc (| ptr |) in
          let cap := M.alloc (| cap |) in
          M.read (|
            let _ :=
              M.write (|
                M.SubPointer.get_struct_record_field (|
                  M.read (| self |),
                  "alloc::raw_vec::RawVec",
                  "ptr"
                |),
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::ptr::unique::Unique") [ T ],
                    "new_unchecked",
                    []
                  |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::ptr::non_null::NonNull") [ T ],
                        "as_ptr",
                        []
                      |),
                      [
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.apply
                              (Ty.path "core::ptr::non_null::NonNull")
                              [ Ty.apply (Ty.path "slice") [ Ty.path "u8" ] ],
                            "cast",
                            [ T ]
                          |),
                          [ M.read (| ptr |) ]
                        |)
                      ]
                    |)
                  ]
                |)
              |) in
            let _ :=
              M.write (|
                M.SubPointer.get_struct_record_field (|
                  M.read (| self |),
                  "alloc::raw_vec::RawVec",
                  "cap"
                |),
                M.read (| cap |)
              |) in
            M.alloc (| Value.Tuple [] |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_set_ptr_and_cap :
      forall (T A : Ty.t),
      M.IsAssociatedFunction (Self T A) "set_ptr_and_cap" (set_ptr_and_cap T A).
    
    (*
        fn grow_amortized(&mut self, len: usize, additional: usize) -> Result<(), TryReserveError> {
            // This is ensured by the calling contexts.
            debug_assert!(additional > 0);
    
            if T::IS_ZST {
                // Since we return a capacity of `usize::MAX` when `elem_size` is
                // 0, getting to here necessarily means the `RawVec` is overfull.
                return Err(CapacityOverflow.into());
            }
    
            // Nothing we can really do about these checks, sadly.
            let required_cap = len.checked_add(additional).ok_or(CapacityOverflow)?;
    
            // This guarantees exponential growth. The doubling cannot overflow
            // because `cap <= isize::MAX` and the type of `cap` is `usize`.
            let cap = cmp::max(self.cap * 2, required_cap);
            let cap = cmp::max(Self::MIN_NON_ZERO_CAP, cap);
    
            let new_layout = Layout::array::<T>(cap);
    
            // `finish_grow` is non-generic over `T`.
            let ptr = finish_grow(new_layout, self.current_memory(), &mut self.alloc)?;
            self.set_ptr_and_cap(ptr, cap);
            Ok(())
        }
    *)
    Definition grow_amortized (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match τ, α with
      | [], [ self; len; additional ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let len := M.alloc (| len |) in
          let additional := M.alloc (| additional |) in
          M.catch_return (|
            ltac:(M.monadic
              (M.read (|
                let _ :=
                  M.match_operator (|
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ := M.use (M.alloc (| Value.Bool true |)) in
                          let _ :=
                            M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          let _ :=
                            M.match_operator (|
                              M.alloc (| Value.Tuple [] |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let γ :=
                                      M.use
                                        (M.alloc (|
                                          UnOp.Pure.not
                                            (BinOp.Pure.gt
                                              (M.read (| additional |))
                                              (Value.Integer 0))
                                        |)) in
                                    let _ :=
                                      M.is_constant_or_break_match (|
                                        M.read (| γ |),
                                        Value.Bool true
                                      |) in
                                    M.alloc (|
                                      M.never_to_any (|
                                        M.call_closure (|
                                          M.get_function (| "core::panicking::panic", [] |),
                                          [
                                            M.read (|
                                              Value.String "assertion failed: additional > 0"
                                            |)
                                          ]
                                        |)
                                      |)
                                    |)));
                                fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                              ]
                            |) in
                          M.alloc (| Value.Tuple [] |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                let _ :=
                  M.match_operator (|
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use (M.get_constant (| "core::mem::SizedTypeProperties::IS_ZST" |)) in
                          let _ :=
                            M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (|
                            M.never_to_any (|
                              M.read (|
                                M.return_ (|
                                  Value.StructTuple
                                    "core::result::Result::Err"
                                    [
                                      M.call_closure (|
                                        M.get_trait_method (|
                                          "core::convert::Into",
                                          Ty.path "alloc::collections::TryReserveErrorKind",
                                          [ Ty.path "alloc::collections::TryReserveError" ],
                                          "into",
                                          []
                                        |),
                                        [
                                          Value.StructTuple
                                            "alloc::collections::TryReserveErrorKind::CapacityOverflow"
                                            []
                                        ]
                                      |)
                                    ]
                                |)
                              |)
                            |)
                          |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                let required_cap :=
                  M.copy (|
                    M.match_operator (|
                      M.alloc (|
                        M.call_closure (|
                          M.get_trait_method (|
                            "core::ops::try_trait::Try",
                            Ty.apply
                              (Ty.path "core::result::Result")
                              [ Ty.path "usize"; Ty.path "alloc::collections::TryReserveErrorKind"
                              ],
                            [],
                            "branch",
                            []
                          |),
                          [
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply (Ty.path "core::option::Option") [ Ty.path "usize" ],
                                "ok_or",
                                [ Ty.path "alloc::collections::TryReserveErrorKind" ]
                              |),
                              [
                                M.call_closure (|
                                  M.get_associated_function (|
                                    Ty.path "usize",
                                    "checked_add",
                                    []
                                  |),
                                  [ M.read (| len |); M.read (| additional |) ]
                                |);
                                Value.StructTuple
                                  "alloc::collections::TryReserveErrorKind::CapacityOverflow"
                                  []
                              ]
                            |)
                          ]
                        |)
                      |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "core::ops::control_flow::ControlFlow::Break",
                                0
                              |) in
                            let residual := M.copy (| γ0_0 |) in
                            M.alloc (|
                              M.never_to_any (|
                                M.read (|
                                  M.return_ (|
                                    M.call_closure (|
                                      M.get_trait_method (|
                                        "core::ops::try_trait::FromResidual",
                                        Ty.apply
                                          (Ty.path "core::result::Result")
                                          [
                                            Ty.tuple [];
                                            Ty.path "alloc::collections::TryReserveError"
                                          ],
                                        [
                                          Ty.apply
                                            (Ty.path "core::result::Result")
                                            [
                                              Ty.path "core::convert::Infallible";
                                              Ty.path "alloc::collections::TryReserveErrorKind"
                                            ]
                                        ],
                                        "from_residual",
                                        []
                                      |),
                                      [ M.read (| residual |) ]
                                    |)
                                  |)
                                |)
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "core::ops::control_flow::ControlFlow::Continue",
                                0
                              |) in
                            let val := M.copy (| γ0_0 |) in
                            val))
                      ]
                    |)
                  |) in
                let cap :=
                  M.alloc (|
                    M.call_closure (|
                      M.get_function (| "core::cmp::max", [ Ty.path "usize" ] |),
                      [
                        BinOp.Wrap.mul
                          Integer.Usize
                          (M.read (|
                            M.SubPointer.get_struct_record_field (|
                              M.read (| self |),
                              "alloc::raw_vec::RawVec",
                              "cap"
                            |)
                          |))
                          (Value.Integer 2);
                        M.read (| required_cap |)
                      ]
                    |)
                  |) in
                let cap :=
                  M.alloc (|
                    M.call_closure (|
                      M.get_function (| "core::cmp::max", [ Ty.path "usize" ] |),
                      [
                        M.read (| M.get_constant (| "alloc::raw_vec::MIN_NON_ZERO_CAP" |) |);
                        M.read (| cap |)
                      ]
                    |)
                  |) in
                let new_layout :=
                  M.alloc (|
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.path "core::alloc::layout::Layout",
                        "array",
                        [ T ]
                      |),
                      [ M.read (| cap |) ]
                    |)
                  |) in
                let ptr :=
                  M.copy (|
                    M.match_operator (|
                      M.alloc (|
                        M.call_closure (|
                          M.get_trait_method (|
                            "core::ops::try_trait::Try",
                            Ty.apply
                              (Ty.path "core::result::Result")
                              [
                                Ty.apply
                                  (Ty.path "core::ptr::non_null::NonNull")
                                  [ Ty.apply (Ty.path "slice") [ Ty.path "u8" ] ];
                                Ty.path "alloc::collections::TryReserveError"
                              ],
                            [],
                            "branch",
                            []
                          |),
                          [
                            M.call_closure (|
                              M.get_function (| "alloc::raw_vec::finish_grow", [ A ] |),
                              [
                                M.read (| new_layout |);
                                M.call_closure (|
                                  M.get_associated_function (|
                                    Ty.apply (Ty.path "alloc::raw_vec::RawVec") [ T; A ],
                                    "current_memory",
                                    []
                                  |),
                                  [ M.read (| self |) ]
                                |);
                                M.SubPointer.get_struct_record_field (|
                                  M.read (| self |),
                                  "alloc::raw_vec::RawVec",
                                  "alloc"
                                |)
                              ]
                            |)
                          ]
                        |)
                      |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "core::ops::control_flow::ControlFlow::Break",
                                0
                              |) in
                            let residual := M.copy (| γ0_0 |) in
                            M.alloc (|
                              M.never_to_any (|
                                M.read (|
                                  M.return_ (|
                                    M.call_closure (|
                                      M.get_trait_method (|
                                        "core::ops::try_trait::FromResidual",
                                        Ty.apply
                                          (Ty.path "core::result::Result")
                                          [
                                            Ty.tuple [];
                                            Ty.path "alloc::collections::TryReserveError"
                                          ],
                                        [
                                          Ty.apply
                                            (Ty.path "core::result::Result")
                                            [
                                              Ty.path "core::convert::Infallible";
                                              Ty.path "alloc::collections::TryReserveError"
                                            ]
                                        ],
                                        "from_residual",
                                        []
                                      |),
                                      [ M.read (| residual |) ]
                                    |)
                                  |)
                                |)
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "core::ops::control_flow::ControlFlow::Continue",
                                0
                              |) in
                            let val := M.copy (| γ0_0 |) in
                            val))
                      ]
                    |)
                  |) in
                let _ :=
                  M.alloc (|
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "alloc::raw_vec::RawVec") [ T; A ],
                        "set_ptr_and_cap",
                        []
                      |),
                      [ M.read (| self |); M.read (| ptr |); M.read (| cap |) ]
                    |)
                  |) in
                M.alloc (| Value.StructTuple "core::result::Result::Ok" [ Value.Tuple [] ] |)
              |)))
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_grow_amortized :
      forall (T A : Ty.t),
      M.IsAssociatedFunction (Self T A) "grow_amortized" (grow_amortized T A).
    
    (*
        fn grow_exact(&mut self, len: usize, additional: usize) -> Result<(), TryReserveError> {
            if T::IS_ZST {
                // Since we return a capacity of `usize::MAX` when the type size is
                // 0, getting to here necessarily means the `RawVec` is overfull.
                return Err(CapacityOverflow.into());
            }
    
            let cap = len.checked_add(additional).ok_or(CapacityOverflow)?;
            let new_layout = Layout::array::<T>(cap);
    
            // `finish_grow` is non-generic over `T`.
            let ptr = finish_grow(new_layout, self.current_memory(), &mut self.alloc)?;
            self.set_ptr_and_cap(ptr, cap);
            Ok(())
        }
    *)
    Definition grow_exact (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match τ, α with
      | [], [ self; len; additional ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let len := M.alloc (| len |) in
          let additional := M.alloc (| additional |) in
          M.catch_return (|
            ltac:(M.monadic
              (M.read (|
                let _ :=
                  M.match_operator (|
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use (M.get_constant (| "core::mem::SizedTypeProperties::IS_ZST" |)) in
                          let _ :=
                            M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (|
                            M.never_to_any (|
                              M.read (|
                                M.return_ (|
                                  Value.StructTuple
                                    "core::result::Result::Err"
                                    [
                                      M.call_closure (|
                                        M.get_trait_method (|
                                          "core::convert::Into",
                                          Ty.path "alloc::collections::TryReserveErrorKind",
                                          [ Ty.path "alloc::collections::TryReserveError" ],
                                          "into",
                                          []
                                        |),
                                        [
                                          Value.StructTuple
                                            "alloc::collections::TryReserveErrorKind::CapacityOverflow"
                                            []
                                        ]
                                      |)
                                    ]
                                |)
                              |)
                            |)
                          |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                let cap :=
                  M.copy (|
                    M.match_operator (|
                      M.alloc (|
                        M.call_closure (|
                          M.get_trait_method (|
                            "core::ops::try_trait::Try",
                            Ty.apply
                              (Ty.path "core::result::Result")
                              [ Ty.path "usize"; Ty.path "alloc::collections::TryReserveErrorKind"
                              ],
                            [],
                            "branch",
                            []
                          |),
                          [
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply (Ty.path "core::option::Option") [ Ty.path "usize" ],
                                "ok_or",
                                [ Ty.path "alloc::collections::TryReserveErrorKind" ]
                              |),
                              [
                                M.call_closure (|
                                  M.get_associated_function (|
                                    Ty.path "usize",
                                    "checked_add",
                                    []
                                  |),
                                  [ M.read (| len |); M.read (| additional |) ]
                                |);
                                Value.StructTuple
                                  "alloc::collections::TryReserveErrorKind::CapacityOverflow"
                                  []
                              ]
                            |)
                          ]
                        |)
                      |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "core::ops::control_flow::ControlFlow::Break",
                                0
                              |) in
                            let residual := M.copy (| γ0_0 |) in
                            M.alloc (|
                              M.never_to_any (|
                                M.read (|
                                  M.return_ (|
                                    M.call_closure (|
                                      M.get_trait_method (|
                                        "core::ops::try_trait::FromResidual",
                                        Ty.apply
                                          (Ty.path "core::result::Result")
                                          [
                                            Ty.tuple [];
                                            Ty.path "alloc::collections::TryReserveError"
                                          ],
                                        [
                                          Ty.apply
                                            (Ty.path "core::result::Result")
                                            [
                                              Ty.path "core::convert::Infallible";
                                              Ty.path "alloc::collections::TryReserveErrorKind"
                                            ]
                                        ],
                                        "from_residual",
                                        []
                                      |),
                                      [ M.read (| residual |) ]
                                    |)
                                  |)
                                |)
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "core::ops::control_flow::ControlFlow::Continue",
                                0
                              |) in
                            let val := M.copy (| γ0_0 |) in
                            val))
                      ]
                    |)
                  |) in
                let new_layout :=
                  M.alloc (|
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.path "core::alloc::layout::Layout",
                        "array",
                        [ T ]
                      |),
                      [ M.read (| cap |) ]
                    |)
                  |) in
                let ptr :=
                  M.copy (|
                    M.match_operator (|
                      M.alloc (|
                        M.call_closure (|
                          M.get_trait_method (|
                            "core::ops::try_trait::Try",
                            Ty.apply
                              (Ty.path "core::result::Result")
                              [
                                Ty.apply
                                  (Ty.path "core::ptr::non_null::NonNull")
                                  [ Ty.apply (Ty.path "slice") [ Ty.path "u8" ] ];
                                Ty.path "alloc::collections::TryReserveError"
                              ],
                            [],
                            "branch",
                            []
                          |),
                          [
                            M.call_closure (|
                              M.get_function (| "alloc::raw_vec::finish_grow", [ A ] |),
                              [
                                M.read (| new_layout |);
                                M.call_closure (|
                                  M.get_associated_function (|
                                    Ty.apply (Ty.path "alloc::raw_vec::RawVec") [ T; A ],
                                    "current_memory",
                                    []
                                  |),
                                  [ M.read (| self |) ]
                                |);
                                M.SubPointer.get_struct_record_field (|
                                  M.read (| self |),
                                  "alloc::raw_vec::RawVec",
                                  "alloc"
                                |)
                              ]
                            |)
                          ]
                        |)
                      |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "core::ops::control_flow::ControlFlow::Break",
                                0
                              |) in
                            let residual := M.copy (| γ0_0 |) in
                            M.alloc (|
                              M.never_to_any (|
                                M.read (|
                                  M.return_ (|
                                    M.call_closure (|
                                      M.get_trait_method (|
                                        "core::ops::try_trait::FromResidual",
                                        Ty.apply
                                          (Ty.path "core::result::Result")
                                          [
                                            Ty.tuple [];
                                            Ty.path "alloc::collections::TryReserveError"
                                          ],
                                        [
                                          Ty.apply
                                            (Ty.path "core::result::Result")
                                            [
                                              Ty.path "core::convert::Infallible";
                                              Ty.path "alloc::collections::TryReserveError"
                                            ]
                                        ],
                                        "from_residual",
                                        []
                                      |),
                                      [ M.read (| residual |) ]
                                    |)
                                  |)
                                |)
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "core::ops::control_flow::ControlFlow::Continue",
                                0
                              |) in
                            let val := M.copy (| γ0_0 |) in
                            val))
                      ]
                    |)
                  |) in
                let _ :=
                  M.alloc (|
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "alloc::raw_vec::RawVec") [ T; A ],
                        "set_ptr_and_cap",
                        []
                      |),
                      [ M.read (| self |); M.read (| ptr |); M.read (| cap |) ]
                    |)
                  |) in
                M.alloc (| Value.StructTuple "core::result::Result::Ok" [ Value.Tuple [] ] |)
              |)))
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_grow_exact :
      forall (T A : Ty.t),
      M.IsAssociatedFunction (Self T A) "grow_exact" (grow_exact T A).
    
    (*
        fn shrink(&mut self, cap: usize) -> Result<(), TryReserveError> {
            assert!(cap <= self.capacity(), "Tried to shrink to a larger capacity");
    
            let (ptr, layout) = if let Some(mem) = self.current_memory() { mem } else { return Ok(()) };
            // See current_memory() why this assert is here
            let _: () = const { assert!(mem::size_of::<T>() % mem::align_of::<T>() == 0) };
    
            // If shrinking to 0, deallocate the buffer. We don't reach this point
            // for the T::IS_ZST case since current_memory() will have returned
            // None.
            if cap == 0 {
                unsafe { self.alloc.deallocate(ptr, layout) };
                self.ptr = Unique::dangling();
                self.cap = 0;
            } else {
                let ptr = unsafe {
                    // `Layout::array` cannot overflow here because it would have
                    // overflowed earlier when capacity was larger.
                    let new_size = mem::size_of::<T>().unchecked_mul(cap);
                    let new_layout = Layout::from_size_align_unchecked(new_size, layout.align());
                    self.alloc
                        .shrink(ptr, layout, new_layout)
                        .map_err(|_| AllocError { layout: new_layout, non_exhaustive: () })?
                };
                self.set_ptr_and_cap(ptr, cap);
            }
            Ok(())
        }
    *)
    Definition shrink (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match τ, α with
      | [], [ self; cap ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let cap := M.alloc (| cap |) in
          M.catch_return (|
            ltac:(M.monadic
              (M.read (|
                let _ :=
                  M.match_operator (|
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                UnOp.Pure.not
                                  (BinOp.Pure.le
                                    (M.read (| cap |))
                                    (M.call_closure (|
                                      M.get_associated_function (|
                                        Ty.apply (Ty.path "alloc::raw_vec::RawVec") [ T; A ],
                                        "capacity",
                                        []
                                      |),
                                      [ M.read (| self |) ]
                                    |)))
                              |)) in
                          let _ :=
                            M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (|
                            M.never_to_any (|
                              M.call_closure (|
                                M.get_function (| "core::panicking::panic_fmt", [] |),
                                [
                                  M.call_closure (|
                                    M.get_associated_function (|
                                      Ty.path "core::fmt::Arguments",
                                      "new_const",
                                      []
                                    |),
                                    [
                                      (* Unsize *)
                                      M.pointer_coercion
                                        (M.alloc (|
                                          Value.Array
                                            [
                                              M.read (|
                                                Value.String "Tried to shrink to a larger capacity"
                                              |)
                                            ]
                                        |))
                                    ]
                                  |)
                                ]
                              |)
                            |)
                          |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                M.match_operator (|
                  M.match_operator (|
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.alloc (|
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "alloc::raw_vec::RawVec") [ T; A ],
                                  "current_memory",
                                  []
                                |),
                                [ M.read (| self |) ]
                              |)
                            |) in
                          let γ0_0 :=
                            M.SubPointer.get_struct_tuple_field (|
                              γ,
                              "core::option::Option::Some",
                              0
                            |) in
                          let mem := M.copy (| γ0_0 |) in
                          mem));
                      fun γ =>
                        ltac:(M.monadic
                          (M.alloc (|
                            M.never_to_any (|
                              M.read (|
                                M.return_ (|
                                  Value.StructTuple "core::result::Result::Ok" [ Value.Tuple [] ]
                                |)
                              |)
                            |)
                          |)))
                    ]
                  |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                        let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                        let ptr := M.copy (| γ0_0 |) in
                        let layout := M.copy (| γ0_1 |) in
                        M.match_operator (|
                          M.get_constant (| "alloc::raw_vec::shrink_discriminant" |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let _ :=
                                  M.match_operator (|
                                    M.alloc (| Value.Tuple [] |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let γ :=
                                            M.use
                                              (M.alloc (|
                                                BinOp.Pure.eq (M.read (| cap |)) (Value.Integer 0)
                                              |)) in
                                          let _ :=
                                            M.is_constant_or_break_match (|
                                              M.read (| γ |),
                                              Value.Bool true
                                            |) in
                                          let _ :=
                                            M.alloc (|
                                              M.call_closure (|
                                                M.get_trait_method (|
                                                  "core::alloc::Allocator",
                                                  A,
                                                  [],
                                                  "deallocate",
                                                  []
                                                |),
                                                [
                                                  M.SubPointer.get_struct_record_field (|
                                                    M.read (| self |),
                                                    "alloc::raw_vec::RawVec",
                                                    "alloc"
                                                  |);
                                                  M.read (| ptr |);
                                                  M.read (| layout |)
                                                ]
                                              |)
                                            |) in
                                          let _ :=
                                            M.write (|
                                              M.SubPointer.get_struct_record_field (|
                                                M.read (| self |),
                                                "alloc::raw_vec::RawVec",
                                                "ptr"
                                              |),
                                              M.call_closure (|
                                                M.get_associated_function (|
                                                  Ty.apply
                                                    (Ty.path "core::ptr::unique::Unique")
                                                    [ T ],
                                                  "dangling",
                                                  []
                                                |),
                                                []
                                              |)
                                            |) in
                                          let _ :=
                                            M.write (|
                                              M.SubPointer.get_struct_record_field (|
                                                M.read (| self |),
                                                "alloc::raw_vec::RawVec",
                                                "cap"
                                              |),
                                              Value.Integer 0
                                            |) in
                                          M.alloc (| Value.Tuple [] |)));
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let ptr :=
                                            M.copy (|
                                              let new_size :=
                                                M.alloc (|
                                                  M.call_closure (|
                                                    M.get_associated_function (|
                                                      Ty.path "usize",
                                                      "unchecked_mul",
                                                      []
                                                    |),
                                                    [
                                                      M.call_closure (|
                                                        M.get_function (|
                                                          "core::mem::size_of",
                                                          [ T ]
                                                        |),
                                                        []
                                                      |);
                                                      M.read (| cap |)
                                                    ]
                                                  |)
                                                |) in
                                              let new_layout :=
                                                M.alloc (|
                                                  M.call_closure (|
                                                    M.get_associated_function (|
                                                      Ty.path "core::alloc::layout::Layout",
                                                      "from_size_align_unchecked",
                                                      []
                                                    |),
                                                    [
                                                      M.read (| new_size |);
                                                      M.call_closure (|
                                                        M.get_associated_function (|
                                                          Ty.path "core::alloc::layout::Layout",
                                                          "align",
                                                          []
                                                        |),
                                                        [ layout ]
                                                      |)
                                                    ]
                                                  |)
                                                |) in
                                              M.match_operator (|
                                                M.alloc (|
                                                  M.call_closure (|
                                                    M.get_trait_method (|
                                                      "core::ops::try_trait::Try",
                                                      Ty.apply
                                                        (Ty.path "core::result::Result")
                                                        [
                                                          Ty.apply
                                                            (Ty.path "core::ptr::non_null::NonNull")
                                                            [
                                                              Ty.apply
                                                                (Ty.path "slice")
                                                                [ Ty.path "u8" ]
                                                            ];
                                                          Ty.path
                                                            "alloc::collections::TryReserveErrorKind"
                                                        ],
                                                      [],
                                                      "branch",
                                                      []
                                                    |),
                                                    [
                                                      M.call_closure (|
                                                        M.get_associated_function (|
                                                          Ty.apply
                                                            (Ty.path "core::result::Result")
                                                            [
                                                              Ty.apply
                                                                (Ty.path
                                                                  "core::ptr::non_null::NonNull")
                                                                [
                                                                  Ty.apply
                                                                    (Ty.path "slice")
                                                                    [ Ty.path "u8" ]
                                                                ];
                                                              Ty.path "core::alloc::AllocError"
                                                            ],
                                                          "map_err",
                                                          [
                                                            Ty.path
                                                              "alloc::collections::TryReserveErrorKind";
                                                            Ty.function
                                                              [
                                                                Ty.tuple
                                                                  [
                                                                    Ty.path
                                                                      "core::alloc::AllocError"
                                                                  ]
                                                              ]
                                                              (Ty.path
                                                                "alloc::collections::TryReserveErrorKind")
                                                          ]
                                                        |),
                                                        [
                                                          M.call_closure (|
                                                            M.get_trait_method (|
                                                              "core::alloc::Allocator",
                                                              A,
                                                              [],
                                                              "shrink",
                                                              []
                                                            |),
                                                            [
                                                              M.SubPointer.get_struct_record_field (|
                                                                M.read (| self |),
                                                                "alloc::raw_vec::RawVec",
                                                                "alloc"
                                                              |);
                                                              M.read (| ptr |);
                                                              M.read (| layout |);
                                                              M.read (| new_layout |)
                                                            ]
                                                          |);
                                                          M.closure
                                                            (fun γ =>
                                                              ltac:(M.monadic
                                                                match γ with
                                                                | [ α0 ] =>
                                                                  M.match_operator (|
                                                                    M.alloc (| α0 |),
                                                                    [
                                                                      fun γ =>
                                                                        ltac:(M.monadic
                                                                          (Value.StructRecord
                                                                            "alloc::collections::TryReserveErrorKind::AllocError"
                                                                            [
                                                                              ("layout",
                                                                                M.read (|
                                                                                  new_layout
                                                                                |));
                                                                              ("non_exhaustive",
                                                                                Value.Tuple [])
                                                                            ]))
                                                                    ]
                                                                  |)
                                                                | _ => M.impossible (||)
                                                                end))
                                                        ]
                                                      |)
                                                    ]
                                                  |)
                                                |),
                                                [
                                                  fun γ =>
                                                    ltac:(M.monadic
                                                      (let γ0_0 :=
                                                        M.SubPointer.get_struct_tuple_field (|
                                                          γ,
                                                          "core::ops::control_flow::ControlFlow::Break",
                                                          0
                                                        |) in
                                                      let residual := M.copy (| γ0_0 |) in
                                                      M.alloc (|
                                                        M.never_to_any (|
                                                          M.read (|
                                                            M.return_ (|
                                                              M.call_closure (|
                                                                M.get_trait_method (|
                                                                  "core::ops::try_trait::FromResidual",
                                                                  Ty.apply
                                                                    (Ty.path "core::result::Result")
                                                                    [
                                                                      Ty.tuple [];
                                                                      Ty.path
                                                                        "alloc::collections::TryReserveError"
                                                                    ],
                                                                  [
                                                                    Ty.apply
                                                                      (Ty.path
                                                                        "core::result::Result")
                                                                      [
                                                                        Ty.path
                                                                          "core::convert::Infallible";
                                                                        Ty.path
                                                                          "alloc::collections::TryReserveErrorKind"
                                                                      ]
                                                                  ],
                                                                  "from_residual",
                                                                  []
                                                                |),
                                                                [ M.read (| residual |) ]
                                                              |)
                                                            |)
                                                          |)
                                                        |)
                                                      |)));
                                                  fun γ =>
                                                    ltac:(M.monadic
                                                      (let γ0_0 :=
                                                        M.SubPointer.get_struct_tuple_field (|
                                                          γ,
                                                          "core::ops::control_flow::ControlFlow::Continue",
                                                          0
                                                        |) in
                                                      let val := M.copy (| γ0_0 |) in
                                                      val))
                                                ]
                                              |)
                                            |) in
                                          let _ :=
                                            M.alloc (|
                                              M.call_closure (|
                                                M.get_associated_function (|
                                                  Ty.apply
                                                    (Ty.path "alloc::raw_vec::RawVec")
                                                    [ T; A ],
                                                  "set_ptr_and_cap",
                                                  []
                                                |),
                                                [
                                                  M.read (| self |);
                                                  M.read (| ptr |);
                                                  M.read (| cap |)
                                                ]
                                              |)
                                            |) in
                                          M.alloc (| Value.Tuple [] |)))
                                    ]
                                  |) in
                                M.alloc (|
                                  Value.StructTuple "core::result::Result::Ok" [ Value.Tuple [] ]
                                |)))
                          ]
                        |)))
                  ]
                |)
              |)))
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_shrink :
      forall (T A : Ty.t),
      M.IsAssociatedFunction (Self T A) "shrink" (shrink T A).
  End Impl_alloc_raw_vec_RawVec_T_A.
  
  
  (*
  fn finish_grow<A>(
      new_layout: Result<Layout, LayoutError>,
      current_memory: Option<(NonNull<u8>, Layout)>,
      alloc: &mut A,
  ) -> Result<NonNull<[u8]>, TryReserveError>
  where
      A: Allocator,
  {
      // Check for the error here to minimize the size of `RawVec::grow_*`.
      let new_layout = new_layout.map_err(|_| CapacityOverflow)?;
  
      alloc_guard(new_layout.size())?;
  
      let memory = if let Some((ptr, old_layout)) = current_memory {
          debug_assert_eq!(old_layout.align(), new_layout.align());
          unsafe {
              // The allocator checks for alignment equality
              intrinsics::assume(old_layout.align() == new_layout.align());
              alloc.grow(ptr, old_layout, new_layout)
          }
      } else {
          alloc.allocate(new_layout)
      };
  
      memory.map_err(|_| AllocError { layout: new_layout, non_exhaustive: () }.into())
  }
  *)
  Definition finish_grow (τ : list Ty.t) (α : list Value.t) : M :=
    match τ, α with
    | [ A ], [ new_layout; current_memory; alloc ] =>
      ltac:(M.monadic
        (let new_layout := M.alloc (| new_layout |) in
        let current_memory := M.alloc (| current_memory |) in
        let alloc := M.alloc (| alloc |) in
        M.catch_return (|
          ltac:(M.monadic
            (M.read (|
              let new_layout :=
                M.copy (|
                  M.match_operator (|
                    M.alloc (|
                      M.call_closure (|
                        M.get_trait_method (|
                          "core::ops::try_trait::Try",
                          Ty.apply
                            (Ty.path "core::result::Result")
                            [
                              Ty.path "core::alloc::layout::Layout";
                              Ty.path "alloc::collections::TryReserveErrorKind"
                            ],
                          [],
                          "branch",
                          []
                        |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply
                                (Ty.path "core::result::Result")
                                [
                                  Ty.path "core::alloc::layout::Layout";
                                  Ty.path "core::alloc::layout::LayoutError"
                                ],
                              "map_err",
                              [
                                Ty.path "alloc::collections::TryReserveErrorKind";
                                Ty.function
                                  [ Ty.tuple [ Ty.path "core::alloc::layout::LayoutError" ] ]
                                  (Ty.path "alloc::collections::TryReserveErrorKind")
                              ]
                            |),
                            [
                              M.read (| new_layout |);
                              M.closure
                                (fun γ =>
                                  ltac:(M.monadic
                                    match γ with
                                    | [ α0 ] =>
                                      M.match_operator (|
                                        M.alloc (| α0 |),
                                        [
                                          fun γ =>
                                            ltac:(M.monadic
                                              (Value.StructTuple
                                                "alloc::collections::TryReserveErrorKind::CapacityOverflow"
                                                []))
                                        ]
                                      |)
                                    | _ => M.impossible (||)
                                    end))
                            ]
                          |)
                        ]
                      |)
                    |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ0_0 :=
                            M.SubPointer.get_struct_tuple_field (|
                              γ,
                              "core::ops::control_flow::ControlFlow::Break",
                              0
                            |) in
                          let residual := M.copy (| γ0_0 |) in
                          M.alloc (|
                            M.never_to_any (|
                              M.read (|
                                M.return_ (|
                                  M.call_closure (|
                                    M.get_trait_method (|
                                      "core::ops::try_trait::FromResidual",
                                      Ty.apply
                                        (Ty.path "core::result::Result")
                                        [
                                          Ty.apply
                                            (Ty.path "core::ptr::non_null::NonNull")
                                            [ Ty.apply (Ty.path "slice") [ Ty.path "u8" ] ];
                                          Ty.path "alloc::collections::TryReserveError"
                                        ],
                                      [
                                        Ty.apply
                                          (Ty.path "core::result::Result")
                                          [
                                            Ty.path "core::convert::Infallible";
                                            Ty.path "alloc::collections::TryReserveErrorKind"
                                          ]
                                      ],
                                      "from_residual",
                                      []
                                    |),
                                    [ M.read (| residual |) ]
                                  |)
                                |)
                              |)
                            |)
                          |)));
                      fun γ =>
                        ltac:(M.monadic
                          (let γ0_0 :=
                            M.SubPointer.get_struct_tuple_field (|
                              γ,
                              "core::ops::control_flow::ControlFlow::Continue",
                              0
                            |) in
                          let val := M.copy (| γ0_0 |) in
                          val))
                    ]
                  |)
                |) in
              let _ :=
                M.match_operator (|
                  M.alloc (|
                    M.call_closure (|
                      M.get_trait_method (|
                        "core::ops::try_trait::Try",
                        Ty.apply
                          (Ty.path "core::result::Result")
                          [ Ty.tuple []; Ty.path "alloc::collections::TryReserveError" ],
                        [],
                        "branch",
                        []
                      |),
                      [
                        M.call_closure (|
                          M.get_function (| "alloc::raw_vec::alloc_guard", [] |),
                          [
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.path "core::alloc::layout::Layout",
                                "size",
                                []
                              |),
                              [ new_layout ]
                            |)
                          ]
                        |)
                      ]
                    |)
                  |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ0_0 :=
                          M.SubPointer.get_struct_tuple_field (|
                            γ,
                            "core::ops::control_flow::ControlFlow::Break",
                            0
                          |) in
                        let residual := M.copy (| γ0_0 |) in
                        M.alloc (|
                          M.never_to_any (|
                            M.read (|
                              M.return_ (|
                                M.call_closure (|
                                  M.get_trait_method (|
                                    "core::ops::try_trait::FromResidual",
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      [
                                        Ty.apply
                                          (Ty.path "core::ptr::non_null::NonNull")
                                          [ Ty.apply (Ty.path "slice") [ Ty.path "u8" ] ];
                                        Ty.path "alloc::collections::TryReserveError"
                                      ],
                                    [
                                      Ty.apply
                                        (Ty.path "core::result::Result")
                                        [
                                          Ty.path "core::convert::Infallible";
                                          Ty.path "alloc::collections::TryReserveError"
                                        ]
                                    ],
                                    "from_residual",
                                    []
                                  |),
                                  [ M.read (| residual |) ]
                                |)
                              |)
                            |)
                          |)
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ0_0 :=
                          M.SubPointer.get_struct_tuple_field (|
                            γ,
                            "core::ops::control_flow::ControlFlow::Continue",
                            0
                          |) in
                        let val := M.copy (| γ0_0 |) in
                        val))
                  ]
                |) in
              let memory :=
                M.copy (|
                  M.match_operator (|
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ := current_memory in
                          let γ0_0 :=
                            M.SubPointer.get_struct_tuple_field (|
                              γ,
                              "core::option::Option::Some",
                              0
                            |) in
                          let γ1_0 := M.SubPointer.get_tuple_field (| γ0_0, 0 |) in
                          let γ1_1 := M.SubPointer.get_tuple_field (| γ0_0, 1 |) in
                          let ptr := M.copy (| γ1_0 |) in
                          let old_layout := M.copy (| γ1_1 |) in
                          let _ :=
                            M.match_operator (|
                              M.alloc (| Value.Tuple [] |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let γ := M.use (M.alloc (| Value.Bool true |)) in
                                    let _ :=
                                      M.is_constant_or_break_match (|
                                        M.read (| γ |),
                                        Value.Bool true
                                      |) in
                                    let _ :=
                                      M.match_operator (|
                                        M.alloc (|
                                          Value.Tuple
                                            [
                                              M.alloc (|
                                                M.call_closure (|
                                                  M.get_associated_function (|
                                                    Ty.path "core::alloc::layout::Layout",
                                                    "align",
                                                    []
                                                  |),
                                                  [ old_layout ]
                                                |)
                                              |);
                                              M.alloc (|
                                                M.call_closure (|
                                                  M.get_associated_function (|
                                                    Ty.path "core::alloc::layout::Layout",
                                                    "align",
                                                    []
                                                  |),
                                                  [ new_layout ]
                                                |)
                                              |)
                                            ]
                                        |),
                                        [
                                          fun γ =>
                                            ltac:(M.monadic
                                              (let γ0_0 :=
                                                M.SubPointer.get_tuple_field (| γ, 0 |) in
                                              let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                              let left_val := M.copy (| γ0_0 |) in
                                              let right_val := M.copy (| γ0_1 |) in
                                              M.match_operator (|
                                                M.alloc (| Value.Tuple [] |),
                                                [
                                                  fun γ =>
                                                    ltac:(M.monadic
                                                      (let γ :=
                                                        M.use
                                                          (M.alloc (|
                                                            UnOp.Pure.not
                                                              (BinOp.Pure.eq
                                                                (M.read (| M.read (| left_val |) |))
                                                                (M.read (|
                                                                  M.read (| right_val |)
                                                                |)))
                                                          |)) in
                                                      let _ :=
                                                        M.is_constant_or_break_match (|
                                                          M.read (| γ |),
                                                          Value.Bool true
                                                        |) in
                                                      M.alloc (|
                                                        M.never_to_any (|
                                                          M.read (|
                                                            let kind :=
                                                              M.alloc (|
                                                                Value.StructTuple
                                                                  "core::panicking::AssertKind::Eq"
                                                                  []
                                                              |) in
                                                            M.alloc (|
                                                              M.call_closure (|
                                                                M.get_function (|
                                                                  "core::panicking::assert_failed",
                                                                  [ Ty.path "usize"; Ty.path "usize"
                                                                  ]
                                                                |),
                                                                [
                                                                  M.read (| kind |);
                                                                  M.read (| left_val |);
                                                                  M.read (| right_val |);
                                                                  Value.StructTuple
                                                                    "core::option::Option::None"
                                                                    []
                                                                ]
                                                              |)
                                                            |)
                                                          |)
                                                        |)
                                                      |)));
                                                  fun γ =>
                                                    ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                                                ]
                                              |)))
                                        ]
                                      |) in
                                    M.alloc (| Value.Tuple [] |)));
                                fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                              ]
                            |) in
                          let _ :=
                            M.alloc (|
                              M.call_closure (|
                                M.get_function (| "core::intrinsics::assume", [] |),
                                [
                                  BinOp.Pure.eq
                                    (M.call_closure (|
                                      M.get_associated_function (|
                                        Ty.path "core::alloc::layout::Layout",
                                        "align",
                                        []
                                      |),
                                      [ old_layout ]
                                    |))
                                    (M.call_closure (|
                                      M.get_associated_function (|
                                        Ty.path "core::alloc::layout::Layout",
                                        "align",
                                        []
                                      |),
                                      [ new_layout ]
                                    |))
                                ]
                              |)
                            |) in
                          M.alloc (|
                            M.call_closure (|
                              M.get_trait_method (| "core::alloc::Allocator", A, [], "grow", [] |),
                              [
                                M.read (| alloc |);
                                M.read (| ptr |);
                                M.read (| old_layout |);
                                M.read (| new_layout |)
                              ]
                            |)
                          |)));
                      fun γ =>
                        ltac:(M.monadic
                          (M.alloc (|
                            M.call_closure (|
                              M.get_trait_method (|
                                "core::alloc::Allocator",
                                A,
                                [],
                                "allocate",
                                []
                              |),
                              [ M.read (| alloc |); M.read (| new_layout |) ]
                            |)
                          |)))
                    ]
                  |)
                |) in
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "core::result::Result")
                      [
                        Ty.apply
                          (Ty.path "core::ptr::non_null::NonNull")
                          [ Ty.apply (Ty.path "slice") [ Ty.path "u8" ] ];
                        Ty.path "core::alloc::AllocError"
                      ],
                    "map_err",
                    [
                      Ty.path "alloc::collections::TryReserveError";
                      Ty.function
                        [ Ty.tuple [ Ty.path "core::alloc::AllocError" ] ]
                        (Ty.path "alloc::collections::TryReserveError")
                    ]
                  |),
                  [
                    M.read (| memory |);
                    M.closure
                      (fun γ =>
                        ltac:(M.monadic
                          match γ with
                          | [ α0 ] =>
                            M.match_operator (|
                              M.alloc (| α0 |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (M.call_closure (|
                                      M.get_trait_method (|
                                        "core::convert::Into",
                                        Ty.path "alloc::collections::TryReserveErrorKind",
                                        [ Ty.path "alloc::collections::TryReserveError" ],
                                        "into",
                                        []
                                      |),
                                      [
                                        Value.StructRecord
                                          "alloc::collections::TryReserveErrorKind::AllocError"
                                          [
                                            ("layout", M.read (| new_layout |));
                                            ("non_exhaustive", Value.Tuple [])
                                          ]
                                      ]
                                    |)))
                              ]
                            |)
                          | _ => M.impossible (||)
                          end))
                  ]
                |)
              |)
            |)))
        |)))
    | _, _ => M.impossible
    end.
  
  Axiom Function_finish_grow : M.IsFunction "alloc::raw_vec::finish_grow" finish_grow.
  
  Module Impl_core_ops_drop_Drop_where_core_alloc_Allocator_A_for_alloc_raw_vec_RawVec_T_A.
    Definition Self (T A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::raw_vec::RawVec") [ T; A ].
    
    (*
        fn drop(&mut self) {
            if let Some((ptr, layout)) = self.current_memory() {
                unsafe { self.alloc.deallocate(ptr, layout) }
            }
        }
    *)
    Definition drop (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.apply (Ty.path "alloc::raw_vec::RawVec") [ T; A ],
                            "current_memory",
                            []
                          |),
                          [ M.read (| self |) ]
                        |)
                      |) in
                    let γ0_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "core::option::Option::Some",
                        0
                      |) in
                    let γ1_0 := M.SubPointer.get_tuple_field (| γ0_0, 0 |) in
                    let γ1_1 := M.SubPointer.get_tuple_field (| γ0_0, 1 |) in
                    let ptr := M.copy (| γ1_0 |) in
                    let layout := M.copy (| γ1_1 |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_trait_method (| "core::alloc::Allocator", A, [], "deallocate", [] |),
                        [
                          M.SubPointer.get_struct_record_field (|
                            M.read (| self |),
                            "alloc::raw_vec::RawVec",
                            "alloc"
                          |);
                          M.read (| ptr |);
                          M.read (| layout |)
                        ]
                      |)
                    |)));
                fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (T A : Ty.t),
      M.IsTraitInstance
        "core::ops::drop::Drop"
        (Self T A)
        (* Trait polymorphic types *) []
        (* Instance *) [ ("drop", InstanceField.Method (drop T A)) ].
  End Impl_core_ops_drop_Drop_where_core_alloc_Allocator_A_for_alloc_raw_vec_RawVec_T_A.
  
  (*
  fn handle_reserve(result: Result<(), TryReserveError>) {
      match result.map_err(|e| e.kind()) {
          Err(CapacityOverflow) => capacity_overflow(),
          Err(AllocError { layout, .. }) => handle_alloc_error(layout),
          Ok(()) => { /* yay */ }
      }
  }
  *)
  Definition handle_reserve (τ : list Ty.t) (α : list Value.t) : M :=
    match τ, α with
    | [], [ result ] =>
      ltac:(M.monadic
        (let result := M.alloc (| result |) in
        M.read (|
          M.match_operator (|
            M.alloc (|
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "core::result::Result")
                    [ Ty.tuple []; Ty.path "alloc::collections::TryReserveError" ],
                  "map_err",
                  [
                    Ty.path "alloc::collections::TryReserveErrorKind";
                    Ty.function
                      [ Ty.tuple [ Ty.path "alloc::collections::TryReserveError" ] ]
                      (Ty.path "alloc::collections::TryReserveErrorKind")
                  ]
                |),
                [
                  M.read (| result |);
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0 ] =>
                          M.match_operator (|
                            M.alloc (| α0 |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let e := M.copy (| γ |) in
                                  M.call_closure (|
                                    M.get_associated_function (|
                                      Ty.path "alloc::collections::TryReserveError",
                                      "kind",
                                      []
                                    |),
                                    [ e ]
                                  |)))
                            ]
                          |)
                        | _ => M.impossible (||)
                        end))
                ]
              |)
            |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ0_0 :=
                    M.SubPointer.get_struct_tuple_field (| γ, "core::result::Result::Err", 0 |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        M.get_function (| "alloc::raw_vec::capacity_overflow", [] |),
                        []
                      |)
                    |)
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (let γ0_0 :=
                    M.SubPointer.get_struct_tuple_field (| γ, "core::result::Result::Err", 0 |) in
                  let γ1_0 :=
                    M.SubPointer.get_struct_record_field (|
                      γ0_0,
                      "alloc::collections::TryReserveErrorKind::AllocError",
                      "layout"
                    |) in
                  let layout := M.copy (| γ1_0 |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        M.get_function (| "alloc::alloc::handle_alloc_error", [] |),
                        [ M.read (| layout |) ]
                      |)
                    |)
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (let γ0_0 :=
                    M.SubPointer.get_struct_tuple_field (| γ, "core::result::Result::Ok", 0 |) in
                  M.alloc (| Value.Tuple [] |)))
            ]
          |)
        |)))
    | _, _ => M.impossible
    end.
  
  Axiom Function_handle_reserve : M.IsFunction "alloc::raw_vec::handle_reserve" handle_reserve.
  
  (*
  fn alloc_guard(alloc_size: usize) -> Result<(), TryReserveError> {
      if usize::BITS < 64 && alloc_size > isize::MAX as usize {
          Err(CapacityOverflow.into())
      } else {
          Ok(())
      }
  }
  *)
  Definition alloc_guard (τ : list Ty.t) (α : list Value.t) : M :=
    match τ, α with
    | [], [ alloc_size ] =>
      ltac:(M.monadic
        (let alloc_size := M.alloc (| alloc_size |) in
        M.read (|
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        LogicalOp.and (|
                          BinOp.Pure.lt
                            (M.read (| M.get_constant (| "core::num::BITS" |) |))
                            (Value.Integer 64),
                          ltac:(M.monadic
                            (BinOp.Pure.gt
                              (M.read (| alloc_size |))
                              (M.rust_cast (M.read (| M.get_constant (| "core::num::MAX" |) |)))))
                        |)
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    Value.StructTuple
                      "core::result::Result::Err"
                      [
                        M.call_closure (|
                          M.get_trait_method (|
                            "core::convert::Into",
                            Ty.path "alloc::collections::TryReserveErrorKind",
                            [ Ty.path "alloc::collections::TryReserveError" ],
                            "into",
                            []
                          |),
                          [
                            Value.StructTuple
                              "alloc::collections::TryReserveErrorKind::CapacityOverflow"
                              []
                          ]
                        |)
                      ]
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (M.alloc (| Value.StructTuple "core::result::Result::Ok" [ Value.Tuple [] ] |)))
            ]
          |)
        |)))
    | _, _ => M.impossible
    end.
  
  Axiom Function_alloc_guard : M.IsFunction "alloc::raw_vec::alloc_guard" alloc_guard.
  
  (*
  fn capacity_overflow() -> ! {
      panic!("capacity overflow");
  }
  *)
  Definition capacity_overflow (τ : list Ty.t) (α : list Value.t) : M :=
    match τ, α with
    | [], [] =>
      ltac:(M.monadic
        (M.call_closure (|
          M.get_function (| "core::panicking::panic_fmt", [] |),
          [
            M.call_closure (|
              M.get_associated_function (| Ty.path "core::fmt::Arguments", "new_const", [] |),
              [
                (* Unsize *)
                M.pointer_coercion
                  (M.alloc (| Value.Array [ M.read (| Value.String "capacity overflow" |) ] |))
              ]
            |)
          ]
        |)))
    | _, _ => M.impossible
    end.
  
  Axiom Function_capacity_overflow :
    M.IsFunction "alloc::raw_vec::capacity_overflow" capacity_overflow.
End raw_vec.
