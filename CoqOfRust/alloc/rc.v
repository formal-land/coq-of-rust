(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module rc.
  (* StructRecord
    {
      name := "RcInner";
      const_params := [];
      ty_params := [ "T" ];
      fields :=
        [
          ("strong", Ty.apply (Ty.path "core::cell::Cell") [] [ Ty.path "usize" ]);
          ("weak", Ty.apply (Ty.path "core::cell::Cell") [] [ Ty.path "usize" ]);
          ("value", T)
        ];
    } *)
  
  (*
  fn rc_inner_layout_for_value_layout(layout: Layout) -> Layout {
      // Calculate layout using the given value layout.
      // Previously, layout was calculated on the expression
      // `&*(ptr as *const RcInner<T>)`, but this created a misaligned
      // reference (see #54908).
      Layout::new::<RcInner<()>>().extend(layout).unwrap().0.pad_to_align()
  }
  *)
  Definition rc_inner_layout_for_value_layout
      (ε : list Value.t)
      (τ : list Ty.t)
      (α : list Value.t)
      : M :=
    match ε, τ, α with
    | [], [], [ layout ] =>
      ltac:(M.monadic
        (let layout := M.alloc (| layout |) in
        M.call_closure (|
          Ty.path "core::alloc::layout::Layout",
          M.get_associated_function (|
            Ty.path "core::alloc::layout::Layout",
            "pad_to_align",
            [],
            []
          |),
          [
            M.borrow (|
              Pointer.Kind.Ref,
              M.SubPointer.get_tuple_field (|
                M.alloc (|
                  M.call_closure (|
                    Ty.tuple [ Ty.path "core::alloc::layout::Layout"; Ty.path "usize" ],
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "core::result::Result")
                        []
                        [
                          Ty.tuple [ Ty.path "core::alloc::layout::Layout"; Ty.path "usize" ];
                          Ty.path "core::alloc::layout::LayoutError"
                        ],
                      "unwrap",
                      [],
                      []
                    |),
                    [
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [
                            Ty.tuple [ Ty.path "core::alloc::layout::Layout"; Ty.path "usize" ];
                            Ty.path "core::alloc::layout::LayoutError"
                          ],
                        M.get_associated_function (|
                          Ty.path "core::alloc::layout::Layout",
                          "extend",
                          [],
                          []
                        |),
                        [
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.alloc (|
                              M.call_closure (|
                                Ty.path "core::alloc::layout::Layout",
                                M.get_associated_function (|
                                  Ty.path "core::alloc::layout::Layout",
                                  "new",
                                  [],
                                  [ Ty.apply (Ty.path "alloc::rc::RcInner") [] [ Ty.tuple [] ] ]
                                |),
                                []
                              |)
                            |)
                          |);
                          M.read (| layout |)
                        ]
                      |)
                    ]
                  |)
                |),
                0
              |)
            |)
          ]
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_rc_inner_layout_for_value_layout :
    M.IsFunction.C "alloc::rc::rc_inner_layout_for_value_layout" rc_inner_layout_for_value_layout.
  Admitted.
  Global Typeclasses Opaque rc_inner_layout_for_value_layout.
  
  (* StructRecord
    {
      name := "Rc";
      const_params := [];
      ty_params := [ "T"; "A" ];
      fields :=
        [
          ("ptr",
            Ty.apply
              (Ty.path "core::ptr::non_null::NonNull")
              []
              [ Ty.apply (Ty.path "alloc::rc::RcInner") [] [ T ] ]);
          ("phantom",
            Ty.apply
              (Ty.path "core::marker::PhantomData")
              []
              [ Ty.apply (Ty.path "alloc::rc::RcInner") [] [ T ] ]);
          ("alloc", A)
        ];
    } *)
  
  Module Impl_core_marker_Send_where_core_marker_Sized_T_where_core_alloc_Allocator_A_for_alloc_rc_Rc_T_A.
    Definition Self (T A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::rc::Rc") [] [ T; A ].
    
    Axiom Implements :
      forall (T A : Ty.t),
      M.IsTraitInstance
        "core::marker::Send"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self T A)
        (* Instance *) [].
  End Impl_core_marker_Send_where_core_marker_Sized_T_where_core_alloc_Allocator_A_for_alloc_rc_Rc_T_A.
  
  Module Impl_core_marker_Sync_where_core_marker_Sized_T_where_core_alloc_Allocator_A_for_alloc_rc_Rc_T_A.
    Definition Self (T A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::rc::Rc") [] [ T; A ].
    
    Axiom Implements :
      forall (T A : Ty.t),
      M.IsTraitInstance
        "core::marker::Sync"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self T A)
        (* Instance *) [].
  End Impl_core_marker_Sync_where_core_marker_Sized_T_where_core_alloc_Allocator_A_for_alloc_rc_Rc_T_A.
  
  Module Impl_core_panic_unwind_safe_UnwindSafe_where_core_panic_unwind_safe_RefUnwindSafe_T_where_core_marker_Sized_T_where_core_alloc_Allocator_A_where_core_panic_unwind_safe_UnwindSafe_A_for_alloc_rc_Rc_T_A.
    Definition Self (T A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::rc::Rc") [] [ T; A ].
    
    Axiom Implements :
      forall (T A : Ty.t),
      M.IsTraitInstance
        "core::panic::unwind_safe::UnwindSafe"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self T A)
        (* Instance *) [].
  End Impl_core_panic_unwind_safe_UnwindSafe_where_core_panic_unwind_safe_RefUnwindSafe_T_where_core_marker_Sized_T_where_core_alloc_Allocator_A_where_core_panic_unwind_safe_UnwindSafe_A_for_alloc_rc_Rc_T_A.
  
  Module Impl_core_panic_unwind_safe_RefUnwindSafe_where_core_panic_unwind_safe_RefUnwindSafe_T_where_core_marker_Sized_T_where_core_alloc_Allocator_A_where_core_panic_unwind_safe_UnwindSafe_A_for_alloc_rc_Rc_T_A.
    Definition Self (T A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::rc::Rc") [] [ T; A ].
    
    Axiom Implements :
      forall (T A : Ty.t),
      M.IsTraitInstance
        "core::panic::unwind_safe::RefUnwindSafe"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self T A)
        (* Instance *) [].
  End Impl_core_panic_unwind_safe_RefUnwindSafe_where_core_panic_unwind_safe_RefUnwindSafe_T_where_core_marker_Sized_T_where_core_alloc_Allocator_A_where_core_panic_unwind_safe_UnwindSafe_A_for_alloc_rc_Rc_T_A.
  
  Module Impl_core_ops_unsize_CoerceUnsized_where_core_marker_Sized_T_where_core_marker_Unsize_T_U_where_core_marker_Sized_U_where_core_alloc_Allocator_A_alloc_rc_Rc_U_A_for_alloc_rc_Rc_T_A.
    Definition Self (T U A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::rc::Rc") [] [ T; A ].
    
    Axiom Implements :
      forall (T U A : Ty.t),
      M.IsTraitInstance
        "core::ops::unsize::CoerceUnsized"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.apply (Ty.path "alloc::rc::Rc") [] [ U; A ] ]
        (Self T U A)
        (* Instance *) [].
  End Impl_core_ops_unsize_CoerceUnsized_where_core_marker_Sized_T_where_core_marker_Unsize_T_U_where_core_marker_Sized_U_where_core_alloc_Allocator_A_alloc_rc_Rc_U_A_for_alloc_rc_Rc_T_A.
  
  Module Impl_core_ops_unsize_DispatchFromDyn_where_core_marker_Sized_T_where_core_marker_Unsize_T_U_where_core_marker_Sized_U_alloc_rc_Rc_U_alloc_alloc_Global_for_alloc_rc_Rc_T_alloc_alloc_Global.
    Definition Self (T U : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "alloc::rc::Rc") [] [ T; Ty.path "alloc::alloc::Global" ].
    
    Axiom Implements :
      forall (T U : Ty.t),
      M.IsTraitInstance
        "core::ops::unsize::DispatchFromDyn"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *)
        [ Ty.apply (Ty.path "alloc::rc::Rc") [] [ U; Ty.path "alloc::alloc::Global" ] ]
        (Self T U)
        (* Instance *) [].
  End Impl_core_ops_unsize_DispatchFromDyn_where_core_marker_Sized_T_where_core_marker_Unsize_T_U_where_core_marker_Sized_U_alloc_rc_Rc_U_alloc_alloc_Global_for_alloc_rc_Rc_T_alloc_alloc_Global.
  
  Module Impl_alloc_rc_Rc_T_alloc_alloc_Global.
    Definition Self (T : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "alloc::rc::Rc") [] [ T; Ty.path "alloc::alloc::Global" ].
    
    (*
        unsafe fn from_inner(ptr: NonNull<RcInner<T>>) -> Self {
            unsafe { Self::from_inner_in(ptr, Global) }
        }
    *)
    Definition from_inner (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [], [ ptr ] =>
        ltac:(M.monadic
          (let ptr := M.alloc (| ptr |) in
          M.call_closure (|
            Ty.apply (Ty.path "alloc::rc::Rc") [] [ T; Ty.path "alloc::alloc::Global" ],
            M.get_associated_function (|
              Ty.apply (Ty.path "alloc::rc::Rc") [] [ T; Ty.path "alloc::alloc::Global" ],
              "from_inner_in",
              [],
              []
            |),
            [ M.read (| ptr |); Value.StructTuple "alloc::alloc::Global" [] ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_from_inner :
      forall (T : Ty.t),
      M.IsAssociatedFunction.C (Self T) "from_inner" (from_inner T).
    Admitted.
    Global Typeclasses Opaque from_inner.
    
    (*
        unsafe fn from_ptr(ptr: *mut RcInner<T>) -> Self {
            unsafe { Self::from_inner(NonNull::new_unchecked(ptr)) }
        }
    *)
    Definition from_ptr (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [], [ ptr ] =>
        ltac:(M.monadic
          (let ptr := M.alloc (| ptr |) in
          M.call_closure (|
            Ty.apply (Ty.path "alloc::rc::Rc") [] [ T; Ty.path "alloc::alloc::Global" ],
            M.get_associated_function (|
              Ty.apply (Ty.path "alloc::rc::Rc") [] [ T; Ty.path "alloc::alloc::Global" ],
              "from_inner",
              [],
              []
            |),
            [
              M.call_closure (|
                Ty.apply
                  (Ty.path "core::ptr::non_null::NonNull")
                  []
                  [ Ty.apply (Ty.path "alloc::rc::RcInner") [] [ T ] ],
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "core::ptr::non_null::NonNull")
                    []
                    [ Ty.apply (Ty.path "alloc::rc::RcInner") [] [ T ] ],
                  "new_unchecked",
                  [],
                  []
                |),
                [ M.read (| ptr |) ]
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_from_ptr :
      forall (T : Ty.t),
      M.IsAssociatedFunction.C (Self T) "from_ptr" (from_ptr T).
    Admitted.
    Global Typeclasses Opaque from_ptr.
    (*
        pub fn new(value: T) -> Rc<T> {
            // There is an implicit weak pointer owned by all the strong
            // pointers, which ensures that the weak destructor never frees
            // the allocation while the strong destructor is running, even
            // if the weak pointer is stored inside the strong one.
            unsafe {
                Self::from_inner(
                    Box::leak(Box::new(RcInner { strong: Cell::new(1), weak: Cell::new(1), value }))
                        .into(),
                )
            }
        }
    *)
    Definition new (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [], [ value ] =>
        ltac:(M.monadic
          (let value := M.alloc (| value |) in
          M.call_closure (|
            Ty.apply (Ty.path "alloc::rc::Rc") [] [ T; Ty.path "alloc::alloc::Global" ],
            M.get_associated_function (|
              Ty.apply (Ty.path "alloc::rc::Rc") [] [ T; Ty.path "alloc::alloc::Global" ],
              "from_inner",
              [],
              []
            |),
            [
              M.call_closure (|
                Ty.apply
                  (Ty.path "core::ptr::non_null::NonNull")
                  []
                  [ Ty.apply (Ty.path "alloc::rc::RcInner") [] [ T ] ],
                M.get_trait_method (|
                  "core::convert::Into",
                  Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "alloc::rc::RcInner") [] [ T ] ],
                  [],
                  [
                    Ty.apply
                      (Ty.path "core::ptr::non_null::NonNull")
                      []
                      [ Ty.apply (Ty.path "alloc::rc::RcInner") [] [ T ] ]
                  ],
                  "into",
                  [],
                  []
                |),
                [
                  M.borrow (|
                    Pointer.Kind.MutRef,
                    M.deref (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "&mut")
                          []
                          [ Ty.apply (Ty.path "alloc::rc::RcInner") [] [ T ] ],
                        M.get_associated_function (|
                          Ty.apply
                            (Ty.path "alloc::boxed::Box")
                            []
                            [
                              Ty.apply (Ty.path "alloc::rc::RcInner") [] [ T ];
                              Ty.path "alloc::alloc::Global"
                            ],
                          "leak",
                          [],
                          []
                        |),
                        [
                          M.call_closure (|
                            Ty.apply
                              (Ty.path "alloc::boxed::Box")
                              []
                              [
                                Ty.apply (Ty.path "alloc::rc::RcInner") [] [ T ];
                                Ty.path "alloc::alloc::Global"
                              ],
                            M.get_associated_function (|
                              Ty.apply
                                (Ty.path "alloc::boxed::Box")
                                []
                                [
                                  Ty.apply (Ty.path "alloc::rc::RcInner") [] [ T ];
                                  Ty.path "alloc::alloc::Global"
                                ],
                              "new",
                              [],
                              []
                            |),
                            [
                              Value.StructRecord
                                "alloc::rc::RcInner"
                                [
                                  ("strong",
                                    M.call_closure (|
                                      Ty.apply (Ty.path "core::cell::Cell") [] [ Ty.path "usize" ],
                                      M.get_associated_function (|
                                        Ty.apply
                                          (Ty.path "core::cell::Cell")
                                          []
                                          [ Ty.path "usize" ],
                                        "new",
                                        [],
                                        []
                                      |),
                                      [ Value.Integer IntegerKind.Usize 1 ]
                                    |));
                                  ("weak",
                                    M.call_closure (|
                                      Ty.apply (Ty.path "core::cell::Cell") [] [ Ty.path "usize" ],
                                      M.get_associated_function (|
                                        Ty.apply
                                          (Ty.path "core::cell::Cell")
                                          []
                                          [ Ty.path "usize" ],
                                        "new",
                                        [],
                                        []
                                      |),
                                      [ Value.Integer IntegerKind.Usize 1 ]
                                    |));
                                  ("value", M.read (| value |))
                                ]
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)
                ]
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_new :
      forall (T : Ty.t),
      M.IsAssociatedFunction.C (Self T) "new" (new T).
    Admitted.
    Global Typeclasses Opaque new.
    
    (*
        pub fn new_cyclic<F>(data_fn: F) -> Rc<T>
        where
            F: FnOnce(&Weak<T>) -> T,
        {
            Self::new_cyclic_in(data_fn, Global)
        }
    *)
    Definition new_cyclic (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [ F ], [ data_fn ] =>
        ltac:(M.monadic
          (let data_fn := M.alloc (| data_fn |) in
          M.call_closure (|
            Ty.apply (Ty.path "alloc::rc::Rc") [] [ T; Ty.path "alloc::alloc::Global" ],
            M.get_associated_function (|
              Ty.apply (Ty.path "alloc::rc::Rc") [] [ T; Ty.path "alloc::alloc::Global" ],
              "new_cyclic_in",
              [],
              [ F ]
            |),
            [ M.read (| data_fn |); Value.StructTuple "alloc::alloc::Global" [] ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_new_cyclic :
      forall (T : Ty.t),
      M.IsAssociatedFunction.C (Self T) "new_cyclic" (new_cyclic T).
    Admitted.
    Global Typeclasses Opaque new_cyclic.
    
    (*
        pub fn new_uninit() -> Rc<mem::MaybeUninit<T>> {
            unsafe {
                Rc::from_ptr(Rc::allocate_for_layout(
                    Layout::new::<T>(),
                    |layout| Global.allocate(layout),
                    <*mut u8>::cast,
                ))
            }
        }
    *)
    Definition new_uninit (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [], [] =>
        ltac:(M.monadic
          (M.call_closure (|
            Ty.apply
              (Ty.path "alloc::rc::Rc")
              []
              [
                Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ];
                Ty.path "alloc::alloc::Global"
              ],
            M.get_associated_function (|
              Ty.apply
                (Ty.path "alloc::rc::Rc")
                []
                [
                  Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ];
                  Ty.path "alloc::alloc::Global"
                ],
              "from_ptr",
              [],
              []
            |),
            [
              M.call_closure (|
                Ty.apply
                  (Ty.path "*mut")
                  []
                  [
                    Ty.apply
                      (Ty.path "alloc::rc::RcInner")
                      []
                      [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ] ]
                  ],
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "alloc::rc::Rc")
                    []
                    [
                      Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ];
                      Ty.path "alloc::alloc::Global"
                    ],
                  "allocate_for_layout",
                  [],
                  [
                    Ty.function
                      [ Ty.tuple [ Ty.path "core::alloc::layout::Layout" ] ]
                      (Ty.apply
                        (Ty.path "core::result::Result")
                        []
                        [
                          Ty.apply
                            (Ty.path "core::ptr::non_null::NonNull")
                            []
                            [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ];
                          Ty.path "core::alloc::AllocError"
                        ]);
                    Ty.function
                      [ Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ] ]
                      (Ty.apply
                        (Ty.path "*mut")
                        []
                        [
                          Ty.apply
                            (Ty.path "alloc::rc::RcInner")
                            []
                            [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ] ]
                        ])
                  ]
                |),
                [
                  M.call_closure (|
                    Ty.path "core::alloc::layout::Layout",
                    M.get_associated_function (|
                      Ty.path "core::alloc::layout::Layout",
                      "new",
                      [],
                      [ T ]
                    |),
                    []
                  |);
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0 ] =>
                          ltac:(M.monadic
                            (M.match_operator (|
                              Some
                                (Ty.function
                                  [ Ty.tuple [ Ty.path "core::alloc::layout::Layout" ] ]
                                  (Ty.apply
                                    (Ty.path "core::result::Result")
                                    []
                                    [
                                      Ty.apply
                                        (Ty.path "core::ptr::non_null::NonNull")
                                        []
                                        [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ];
                                      Ty.path "core::alloc::AllocError"
                                    ])),
                              M.alloc (| α0 |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let layout := M.copy (| γ |) in
                                    M.call_closure (|
                                      Ty.apply
                                        (Ty.path "core::result::Result")
                                        []
                                        [
                                          Ty.apply
                                            (Ty.path "core::ptr::non_null::NonNull")
                                            []
                                            [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ];
                                          Ty.path "core::alloc::AllocError"
                                        ],
                                      M.get_trait_method (|
                                        "core::alloc::Allocator",
                                        Ty.path "alloc::alloc::Global",
                                        [],
                                        [],
                                        "allocate",
                                        [],
                                        []
                                      |),
                                      [
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.alloc (| Value.StructTuple "alloc::alloc::Global" [] |)
                                        |);
                                        M.read (| layout |)
                                      ]
                                    |)))
                              ]
                            |)))
                        | _ => M.impossible "wrong number of arguments"
                        end));
                  M.get_associated_function (|
                    Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ],
                    "cast",
                    [],
                    [
                      Ty.apply
                        (Ty.path "alloc::rc::RcInner")
                        []
                        [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ] ]
                    ]
                  |)
                ]
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_new_uninit :
      forall (T : Ty.t),
      M.IsAssociatedFunction.C (Self T) "new_uninit" (new_uninit T).
    Admitted.
    Global Typeclasses Opaque new_uninit.
    
    (*
        pub fn new_zeroed() -> Rc<mem::MaybeUninit<T>> {
            unsafe {
                Rc::from_ptr(Rc::allocate_for_layout(
                    Layout::new::<T>(),
                    |layout| Global.allocate_zeroed(layout),
                    <*mut u8>::cast,
                ))
            }
        }
    *)
    Definition new_zeroed (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [], [] =>
        ltac:(M.monadic
          (M.call_closure (|
            Ty.apply
              (Ty.path "alloc::rc::Rc")
              []
              [
                Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ];
                Ty.path "alloc::alloc::Global"
              ],
            M.get_associated_function (|
              Ty.apply
                (Ty.path "alloc::rc::Rc")
                []
                [
                  Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ];
                  Ty.path "alloc::alloc::Global"
                ],
              "from_ptr",
              [],
              []
            |),
            [
              M.call_closure (|
                Ty.apply
                  (Ty.path "*mut")
                  []
                  [
                    Ty.apply
                      (Ty.path "alloc::rc::RcInner")
                      []
                      [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ] ]
                  ],
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "alloc::rc::Rc")
                    []
                    [
                      Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ];
                      Ty.path "alloc::alloc::Global"
                    ],
                  "allocate_for_layout",
                  [],
                  [
                    Ty.function
                      [ Ty.tuple [ Ty.path "core::alloc::layout::Layout" ] ]
                      (Ty.apply
                        (Ty.path "core::result::Result")
                        []
                        [
                          Ty.apply
                            (Ty.path "core::ptr::non_null::NonNull")
                            []
                            [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ];
                          Ty.path "core::alloc::AllocError"
                        ]);
                    Ty.function
                      [ Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ] ]
                      (Ty.apply
                        (Ty.path "*mut")
                        []
                        [
                          Ty.apply
                            (Ty.path "alloc::rc::RcInner")
                            []
                            [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ] ]
                        ])
                  ]
                |),
                [
                  M.call_closure (|
                    Ty.path "core::alloc::layout::Layout",
                    M.get_associated_function (|
                      Ty.path "core::alloc::layout::Layout",
                      "new",
                      [],
                      [ T ]
                    |),
                    []
                  |);
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0 ] =>
                          ltac:(M.monadic
                            (M.match_operator (|
                              Some
                                (Ty.function
                                  [ Ty.tuple [ Ty.path "core::alloc::layout::Layout" ] ]
                                  (Ty.apply
                                    (Ty.path "core::result::Result")
                                    []
                                    [
                                      Ty.apply
                                        (Ty.path "core::ptr::non_null::NonNull")
                                        []
                                        [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ];
                                      Ty.path "core::alloc::AllocError"
                                    ])),
                              M.alloc (| α0 |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let layout := M.copy (| γ |) in
                                    M.call_closure (|
                                      Ty.apply
                                        (Ty.path "core::result::Result")
                                        []
                                        [
                                          Ty.apply
                                            (Ty.path "core::ptr::non_null::NonNull")
                                            []
                                            [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ];
                                          Ty.path "core::alloc::AllocError"
                                        ],
                                      M.get_trait_method (|
                                        "core::alloc::Allocator",
                                        Ty.path "alloc::alloc::Global",
                                        [],
                                        [],
                                        "allocate_zeroed",
                                        [],
                                        []
                                      |),
                                      [
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.alloc (| Value.StructTuple "alloc::alloc::Global" [] |)
                                        |);
                                        M.read (| layout |)
                                      ]
                                    |)))
                              ]
                            |)))
                        | _ => M.impossible "wrong number of arguments"
                        end));
                  M.get_associated_function (|
                    Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ],
                    "cast",
                    [],
                    [
                      Ty.apply
                        (Ty.path "alloc::rc::RcInner")
                        []
                        [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ] ]
                    ]
                  |)
                ]
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_new_zeroed :
      forall (T : Ty.t),
      M.IsAssociatedFunction.C (Self T) "new_zeroed" (new_zeroed T).
    Admitted.
    Global Typeclasses Opaque new_zeroed.
    
    (*
        pub fn try_new(value: T) -> Result<Rc<T>, AllocError> {
            // There is an implicit weak pointer owned by all the strong
            // pointers, which ensures that the weak destructor never frees
            // the allocation while the strong destructor is running, even
            // if the weak pointer is stored inside the strong one.
            unsafe {
                Ok(Self::from_inner(
                    Box::leak(Box::try_new(RcInner {
                        strong: Cell::new(1),
                        weak: Cell::new(1),
                        value,
                    })?)
                    .into(),
                ))
            }
        }
    *)
    Definition try_new (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [], [ value ] =>
        ltac:(M.monadic
          (let value := M.alloc (| value |) in
          M.catch_return (|
            ltac:(M.monadic
              (Value.StructTuple
                "core::result::Result::Ok"
                [
                  M.call_closure (|
                    Ty.apply (Ty.path "alloc::rc::Rc") [] [ T; Ty.path "alloc::alloc::Global" ],
                    M.get_associated_function (|
                      Ty.apply (Ty.path "alloc::rc::Rc") [] [ T; Ty.path "alloc::alloc::Global" ],
                      "from_inner",
                      [],
                      []
                    |),
                    [
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::ptr::non_null::NonNull")
                          []
                          [ Ty.apply (Ty.path "alloc::rc::RcInner") [] [ T ] ],
                        M.get_trait_method (|
                          "core::convert::Into",
                          Ty.apply
                            (Ty.path "&mut")
                            []
                            [ Ty.apply (Ty.path "alloc::rc::RcInner") [] [ T ] ],
                          [],
                          [
                            Ty.apply
                              (Ty.path "core::ptr::non_null::NonNull")
                              []
                              [ Ty.apply (Ty.path "alloc::rc::RcInner") [] [ T ] ]
                          ],
                          "into",
                          [],
                          []
                        |),
                        [
                          M.borrow (|
                            Pointer.Kind.MutRef,
                            M.deref (|
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "&mut")
                                  []
                                  [ Ty.apply (Ty.path "alloc::rc::RcInner") [] [ T ] ],
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "alloc::boxed::Box")
                                    []
                                    [
                                      Ty.apply (Ty.path "alloc::rc::RcInner") [] [ T ];
                                      Ty.path "alloc::alloc::Global"
                                    ],
                                  "leak",
                                  [],
                                  []
                                |),
                                [
                                  M.read (|
                                    M.match_operator (|
                                      Some
                                        (Ty.apply
                                          (Ty.path "alloc::boxed::Box")
                                          []
                                          [
                                            Ty.apply (Ty.path "alloc::rc::RcInner") [] [ T ];
                                            Ty.path "alloc::alloc::Global"
                                          ]),
                                      M.alloc (|
                                        M.call_closure (|
                                          Ty.apply
                                            (Ty.path "core::ops::control_flow::ControlFlow")
                                            []
                                            [
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                []
                                                [
                                                  Ty.path "core::convert::Infallible";
                                                  Ty.path "core::alloc::AllocError"
                                                ];
                                              Ty.apply
                                                (Ty.path "alloc::boxed::Box")
                                                []
                                                [
                                                  Ty.apply (Ty.path "alloc::rc::RcInner") [] [ T ];
                                                  Ty.path "alloc::alloc::Global"
                                                ]
                                            ],
                                          M.get_trait_method (|
                                            "core::ops::try_trait::Try",
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "alloc::boxed::Box")
                                                  []
                                                  [
                                                    Ty.apply
                                                      (Ty.path "alloc::rc::RcInner")
                                                      []
                                                      [ T ];
                                                    Ty.path "alloc::alloc::Global"
                                                  ];
                                                Ty.path "core::alloc::AllocError"
                                              ],
                                            [],
                                            [],
                                            "branch",
                                            [],
                                            []
                                          |),
                                          [
                                            M.call_closure (|
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path "alloc::boxed::Box")
                                                    []
                                                    [
                                                      Ty.apply
                                                        (Ty.path "alloc::rc::RcInner")
                                                        []
                                                        [ T ];
                                                      Ty.path "alloc::alloc::Global"
                                                    ];
                                                  Ty.path "core::alloc::AllocError"
                                                ],
                                              M.get_associated_function (|
                                                Ty.apply
                                                  (Ty.path "alloc::boxed::Box")
                                                  []
                                                  [
                                                    Ty.apply
                                                      (Ty.path "alloc::rc::RcInner")
                                                      []
                                                      [ T ];
                                                    Ty.path "alloc::alloc::Global"
                                                  ],
                                                "try_new",
                                                [],
                                                []
                                              |),
                                              [
                                                Value.StructRecord
                                                  "alloc::rc::RcInner"
                                                  [
                                                    ("strong",
                                                      M.call_closure (|
                                                        Ty.apply
                                                          (Ty.path "core::cell::Cell")
                                                          []
                                                          [ Ty.path "usize" ],
                                                        M.get_associated_function (|
                                                          Ty.apply
                                                            (Ty.path "core::cell::Cell")
                                                            []
                                                            [ Ty.path "usize" ],
                                                          "new",
                                                          [],
                                                          []
                                                        |),
                                                        [ Value.Integer IntegerKind.Usize 1 ]
                                                      |));
                                                    ("weak",
                                                      M.call_closure (|
                                                        Ty.apply
                                                          (Ty.path "core::cell::Cell")
                                                          []
                                                          [ Ty.path "usize" ],
                                                        M.get_associated_function (|
                                                          Ty.apply
                                                            (Ty.path "core::cell::Cell")
                                                            []
                                                            [ Ty.path "usize" ],
                                                          "new",
                                                          [],
                                                          []
                                                        |),
                                                        [ Value.Integer IntegerKind.Usize 1 ]
                                                      |));
                                                    ("value", M.read (| value |))
                                                  ]
                                              ]
                                            |)
                                          ]
                                        |)
                                      |),
                                      [
                                        fun γ =>
                                          ltac:(M.monadic
                                            (let γ0_0 :=
                                              M.SubPointer.get_struct_tuple_field (|
                                                γ,
                                                "core::ops::control_flow::ControlFlow::Break",
                                                0
                                              |) in
                                            let residual := M.copy (| γ0_0 |) in
                                            M.alloc (|
                                              M.never_to_any (|
                                                M.read (|
                                                  M.return_ (|
                                                    M.call_closure (|
                                                      Ty.apply
                                                        (Ty.path "core::result::Result")
                                                        []
                                                        [
                                                          Ty.apply
                                                            (Ty.path "alloc::rc::Rc")
                                                            []
                                                            [ T; Ty.path "alloc::alloc::Global" ];
                                                          Ty.path "core::alloc::AllocError"
                                                        ],
                                                      M.get_trait_method (|
                                                        "core::ops::try_trait::FromResidual",
                                                        Ty.apply
                                                          (Ty.path "core::result::Result")
                                                          []
                                                          [
                                                            Ty.apply
                                                              (Ty.path "alloc::rc::Rc")
                                                              []
                                                              [ T; Ty.path "alloc::alloc::Global" ];
                                                            Ty.path "core::alloc::AllocError"
                                                          ],
                                                        [],
                                                        [
                                                          Ty.apply
                                                            (Ty.path "core::result::Result")
                                                            []
                                                            [
                                                              Ty.path "core::convert::Infallible";
                                                              Ty.path "core::alloc::AllocError"
                                                            ]
                                                        ],
                                                        "from_residual",
                                                        [],
                                                        []
                                                      |),
                                                      [ M.read (| residual |) ]
                                                    |)
                                                  |)
                                                |)
                                              |)
                                            |)));
                                        fun γ =>
                                          ltac:(M.monadic
                                            (let γ0_0 :=
                                              M.SubPointer.get_struct_tuple_field (|
                                                γ,
                                                "core::ops::control_flow::ControlFlow::Continue",
                                                0
                                              |) in
                                            let val := M.copy (| γ0_0 |) in
                                            val))
                                      ]
                                    |)
                                  |)
                                ]
                              |)
                            |)
                          |)
                        ]
                      |)
                    ]
                  |)
                ]))
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_try_new :
      forall (T : Ty.t),
      M.IsAssociatedFunction.C (Self T) "try_new" (try_new T).
    Admitted.
    Global Typeclasses Opaque try_new.
    
    (*
        pub fn try_new_uninit() -> Result<Rc<mem::MaybeUninit<T>>, AllocError> {
            unsafe {
                Ok(Rc::from_ptr(Rc::try_allocate_for_layout(
                    Layout::new::<T>(),
                    |layout| Global.allocate(layout),
                    <*mut u8>::cast,
                )?))
            }
        }
    *)
    Definition try_new_uninit
        (T : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [], [] =>
        ltac:(M.monadic
          (M.catch_return (|
            ltac:(M.monadic
              (Value.StructTuple
                "core::result::Result::Ok"
                [
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "alloc::rc::Rc")
                      []
                      [
                        Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ];
                        Ty.path "alloc::alloc::Global"
                      ],
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "alloc::rc::Rc")
                        []
                        [
                          Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ];
                          Ty.path "alloc::alloc::Global"
                        ],
                      "from_ptr",
                      [],
                      []
                    |),
                    [
                      M.read (|
                        M.match_operator (|
                          Some
                            (Ty.apply
                              (Ty.path "*mut")
                              []
                              [
                                Ty.apply
                                  (Ty.path "alloc::rc::RcInner")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                      []
                                      [ T ]
                                  ]
                              ]),
                          M.alloc (|
                            M.call_closure (|
                              Ty.apply
                                (Ty.path "core::ops::control_flow::ControlFlow")
                                []
                                [
                                  Ty.apply
                                    (Ty.path "core::result::Result")
                                    []
                                    [
                                      Ty.path "core::convert::Infallible";
                                      Ty.path "core::alloc::AllocError"
                                    ];
                                  Ty.apply
                                    (Ty.path "*mut")
                                    []
                                    [
                                      Ty.apply
                                        (Ty.path "alloc::rc::RcInner")
                                        []
                                        [
                                          Ty.apply
                                            (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                            []
                                            [ T ]
                                        ]
                                    ]
                                ],
                              M.get_trait_method (|
                                "core::ops::try_trait::Try",
                                Ty.apply
                                  (Ty.path "core::result::Result")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "*mut")
                                      []
                                      [
                                        Ty.apply
                                          (Ty.path "alloc::rc::RcInner")
                                          []
                                          [
                                            Ty.apply
                                              (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                              []
                                              [ T ]
                                          ]
                                      ];
                                    Ty.path "core::alloc::AllocError"
                                  ],
                                [],
                                [],
                                "branch",
                                [],
                                []
                              |),
                              [
                                M.call_closure (|
                                  Ty.apply
                                    (Ty.path "core::result::Result")
                                    []
                                    [
                                      Ty.apply
                                        (Ty.path "*mut")
                                        []
                                        [
                                          Ty.apply
                                            (Ty.path "alloc::rc::RcInner")
                                            []
                                            [
                                              Ty.apply
                                                (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                                []
                                                [ T ]
                                            ]
                                        ];
                                      Ty.path "core::alloc::AllocError"
                                    ],
                                  M.get_associated_function (|
                                    Ty.apply
                                      (Ty.path "alloc::rc::Rc")
                                      []
                                      [
                                        Ty.apply
                                          (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                          []
                                          [ T ];
                                        Ty.path "alloc::alloc::Global"
                                      ],
                                    "try_allocate_for_layout",
                                    [],
                                    [
                                      Ty.function
                                        [ Ty.tuple [ Ty.path "core::alloc::layout::Layout" ] ]
                                        (Ty.apply
                                          (Ty.path "core::result::Result")
                                          []
                                          [
                                            Ty.apply
                                              (Ty.path "core::ptr::non_null::NonNull")
                                              []
                                              [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ];
                                            Ty.path "core::alloc::AllocError"
                                          ]);
                                      Ty.function
                                        [ Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ] ]
                                        (Ty.apply
                                          (Ty.path "*mut")
                                          []
                                          [
                                            Ty.apply
                                              (Ty.path "alloc::rc::RcInner")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                                  []
                                                  [ T ]
                                              ]
                                          ])
                                    ]
                                  |),
                                  [
                                    M.call_closure (|
                                      Ty.path "core::alloc::layout::Layout",
                                      M.get_associated_function (|
                                        Ty.path "core::alloc::layout::Layout",
                                        "new",
                                        [],
                                        [ T ]
                                      |),
                                      []
                                    |);
                                    M.closure
                                      (fun γ =>
                                        ltac:(M.monadic
                                          match γ with
                                          | [ α0 ] =>
                                            ltac:(M.monadic
                                              (M.match_operator (|
                                                Some
                                                  (Ty.function
                                                    [
                                                      Ty.tuple
                                                        [ Ty.path "core::alloc::layout::Layout" ]
                                                    ]
                                                    (Ty.apply
                                                      (Ty.path "core::result::Result")
                                                      []
                                                      [
                                                        Ty.apply
                                                          (Ty.path "core::ptr::non_null::NonNull")
                                                          []
                                                          [
                                                            Ty.apply
                                                              (Ty.path "slice")
                                                              []
                                                              [ Ty.path "u8" ]
                                                          ];
                                                        Ty.path "core::alloc::AllocError"
                                                      ])),
                                                M.alloc (| α0 |),
                                                [
                                                  fun γ =>
                                                    ltac:(M.monadic
                                                      (let layout := M.copy (| γ |) in
                                                      M.call_closure (|
                                                        Ty.apply
                                                          (Ty.path "core::result::Result")
                                                          []
                                                          [
                                                            Ty.apply
                                                              (Ty.path
                                                                "core::ptr::non_null::NonNull")
                                                              []
                                                              [
                                                                Ty.apply
                                                                  (Ty.path "slice")
                                                                  []
                                                                  [ Ty.path "u8" ]
                                                              ];
                                                            Ty.path "core::alloc::AllocError"
                                                          ],
                                                        M.get_trait_method (|
                                                          "core::alloc::Allocator",
                                                          Ty.path "alloc::alloc::Global",
                                                          [],
                                                          [],
                                                          "allocate",
                                                          [],
                                                          []
                                                        |),
                                                        [
                                                          M.borrow (|
                                                            Pointer.Kind.Ref,
                                                            M.alloc (|
                                                              Value.StructTuple
                                                                "alloc::alloc::Global"
                                                                []
                                                            |)
                                                          |);
                                                          M.read (| layout |)
                                                        ]
                                                      |)))
                                                ]
                                              |)))
                                          | _ => M.impossible "wrong number of arguments"
                                          end));
                                    M.get_associated_function (|
                                      Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ],
                                      "cast",
                                      [],
                                      [
                                        Ty.apply
                                          (Ty.path "alloc::rc::RcInner")
                                          []
                                          [
                                            Ty.apply
                                              (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                              []
                                              [ T ]
                                          ]
                                      ]
                                    |)
                                  ]
                                |)
                              ]
                            |)
                          |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ0_0 :=
                                  M.SubPointer.get_struct_tuple_field (|
                                    γ,
                                    "core::ops::control_flow::ControlFlow::Break",
                                    0
                                  |) in
                                let residual := M.copy (| γ0_0 |) in
                                M.alloc (|
                                  M.never_to_any (|
                                    M.read (|
                                      M.return_ (|
                                        M.call_closure (|
                                          Ty.apply
                                            (Ty.path "core::result::Result")
                                            []
                                            [
                                              Ty.apply
                                                (Ty.path "alloc::rc::Rc")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                                    []
                                                    [ T ];
                                                  Ty.path "alloc::alloc::Global"
                                                ];
                                              Ty.path "core::alloc::AllocError"
                                            ],
                                          M.get_trait_method (|
                                            "core::ops::try_trait::FromResidual",
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "alloc::rc::Rc")
                                                  []
                                                  [
                                                    Ty.apply
                                                      (Ty.path
                                                        "core::mem::maybe_uninit::MaybeUninit")
                                                      []
                                                      [ T ];
                                                    Ty.path "alloc::alloc::Global"
                                                  ];
                                                Ty.path "core::alloc::AllocError"
                                              ],
                                            [],
                                            [
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                []
                                                [
                                                  Ty.path "core::convert::Infallible";
                                                  Ty.path "core::alloc::AllocError"
                                                ]
                                            ],
                                            "from_residual",
                                            [],
                                            []
                                          |),
                                          [ M.read (| residual |) ]
                                        |)
                                      |)
                                    |)
                                  |)
                                |)));
                            fun γ =>
                              ltac:(M.monadic
                                (let γ0_0 :=
                                  M.SubPointer.get_struct_tuple_field (|
                                    γ,
                                    "core::ops::control_flow::ControlFlow::Continue",
                                    0
                                  |) in
                                let val := M.copy (| γ0_0 |) in
                                val))
                          ]
                        |)
                      |)
                    ]
                  |)
                ]))
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_try_new_uninit :
      forall (T : Ty.t),
      M.IsAssociatedFunction.C (Self T) "try_new_uninit" (try_new_uninit T).
    Admitted.
    Global Typeclasses Opaque try_new_uninit.
    
    (*
        pub fn try_new_zeroed() -> Result<Rc<mem::MaybeUninit<T>>, AllocError> {
            unsafe {
                Ok(Rc::from_ptr(Rc::try_allocate_for_layout(
                    Layout::new::<T>(),
                    |layout| Global.allocate_zeroed(layout),
                    <*mut u8>::cast,
                )?))
            }
        }
    *)
    Definition try_new_zeroed
        (T : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [], [] =>
        ltac:(M.monadic
          (M.catch_return (|
            ltac:(M.monadic
              (Value.StructTuple
                "core::result::Result::Ok"
                [
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "alloc::rc::Rc")
                      []
                      [
                        Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ];
                        Ty.path "alloc::alloc::Global"
                      ],
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "alloc::rc::Rc")
                        []
                        [
                          Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ];
                          Ty.path "alloc::alloc::Global"
                        ],
                      "from_ptr",
                      [],
                      []
                    |),
                    [
                      M.read (|
                        M.match_operator (|
                          Some
                            (Ty.apply
                              (Ty.path "*mut")
                              []
                              [
                                Ty.apply
                                  (Ty.path "alloc::rc::RcInner")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                      []
                                      [ T ]
                                  ]
                              ]),
                          M.alloc (|
                            M.call_closure (|
                              Ty.apply
                                (Ty.path "core::ops::control_flow::ControlFlow")
                                []
                                [
                                  Ty.apply
                                    (Ty.path "core::result::Result")
                                    []
                                    [
                                      Ty.path "core::convert::Infallible";
                                      Ty.path "core::alloc::AllocError"
                                    ];
                                  Ty.apply
                                    (Ty.path "*mut")
                                    []
                                    [
                                      Ty.apply
                                        (Ty.path "alloc::rc::RcInner")
                                        []
                                        [
                                          Ty.apply
                                            (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                            []
                                            [ T ]
                                        ]
                                    ]
                                ],
                              M.get_trait_method (|
                                "core::ops::try_trait::Try",
                                Ty.apply
                                  (Ty.path "core::result::Result")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "*mut")
                                      []
                                      [
                                        Ty.apply
                                          (Ty.path "alloc::rc::RcInner")
                                          []
                                          [
                                            Ty.apply
                                              (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                              []
                                              [ T ]
                                          ]
                                      ];
                                    Ty.path "core::alloc::AllocError"
                                  ],
                                [],
                                [],
                                "branch",
                                [],
                                []
                              |),
                              [
                                M.call_closure (|
                                  Ty.apply
                                    (Ty.path "core::result::Result")
                                    []
                                    [
                                      Ty.apply
                                        (Ty.path "*mut")
                                        []
                                        [
                                          Ty.apply
                                            (Ty.path "alloc::rc::RcInner")
                                            []
                                            [
                                              Ty.apply
                                                (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                                []
                                                [ T ]
                                            ]
                                        ];
                                      Ty.path "core::alloc::AllocError"
                                    ],
                                  M.get_associated_function (|
                                    Ty.apply
                                      (Ty.path "alloc::rc::Rc")
                                      []
                                      [
                                        Ty.apply
                                          (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                          []
                                          [ T ];
                                        Ty.path "alloc::alloc::Global"
                                      ],
                                    "try_allocate_for_layout",
                                    [],
                                    [
                                      Ty.function
                                        [ Ty.tuple [ Ty.path "core::alloc::layout::Layout" ] ]
                                        (Ty.apply
                                          (Ty.path "core::result::Result")
                                          []
                                          [
                                            Ty.apply
                                              (Ty.path "core::ptr::non_null::NonNull")
                                              []
                                              [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ];
                                            Ty.path "core::alloc::AllocError"
                                          ]);
                                      Ty.function
                                        [ Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ] ]
                                        (Ty.apply
                                          (Ty.path "*mut")
                                          []
                                          [
                                            Ty.apply
                                              (Ty.path "alloc::rc::RcInner")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                                  []
                                                  [ T ]
                                              ]
                                          ])
                                    ]
                                  |),
                                  [
                                    M.call_closure (|
                                      Ty.path "core::alloc::layout::Layout",
                                      M.get_associated_function (|
                                        Ty.path "core::alloc::layout::Layout",
                                        "new",
                                        [],
                                        [ T ]
                                      |),
                                      []
                                    |);
                                    M.closure
                                      (fun γ =>
                                        ltac:(M.monadic
                                          match γ with
                                          | [ α0 ] =>
                                            ltac:(M.monadic
                                              (M.match_operator (|
                                                Some
                                                  (Ty.function
                                                    [
                                                      Ty.tuple
                                                        [ Ty.path "core::alloc::layout::Layout" ]
                                                    ]
                                                    (Ty.apply
                                                      (Ty.path "core::result::Result")
                                                      []
                                                      [
                                                        Ty.apply
                                                          (Ty.path "core::ptr::non_null::NonNull")
                                                          []
                                                          [
                                                            Ty.apply
                                                              (Ty.path "slice")
                                                              []
                                                              [ Ty.path "u8" ]
                                                          ];
                                                        Ty.path "core::alloc::AllocError"
                                                      ])),
                                                M.alloc (| α0 |),
                                                [
                                                  fun γ =>
                                                    ltac:(M.monadic
                                                      (let layout := M.copy (| γ |) in
                                                      M.call_closure (|
                                                        Ty.apply
                                                          (Ty.path "core::result::Result")
                                                          []
                                                          [
                                                            Ty.apply
                                                              (Ty.path
                                                                "core::ptr::non_null::NonNull")
                                                              []
                                                              [
                                                                Ty.apply
                                                                  (Ty.path "slice")
                                                                  []
                                                                  [ Ty.path "u8" ]
                                                              ];
                                                            Ty.path "core::alloc::AllocError"
                                                          ],
                                                        M.get_trait_method (|
                                                          "core::alloc::Allocator",
                                                          Ty.path "alloc::alloc::Global",
                                                          [],
                                                          [],
                                                          "allocate_zeroed",
                                                          [],
                                                          []
                                                        |),
                                                        [
                                                          M.borrow (|
                                                            Pointer.Kind.Ref,
                                                            M.alloc (|
                                                              Value.StructTuple
                                                                "alloc::alloc::Global"
                                                                []
                                                            |)
                                                          |);
                                                          M.read (| layout |)
                                                        ]
                                                      |)))
                                                ]
                                              |)))
                                          | _ => M.impossible "wrong number of arguments"
                                          end));
                                    M.get_associated_function (|
                                      Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ],
                                      "cast",
                                      [],
                                      [
                                        Ty.apply
                                          (Ty.path "alloc::rc::RcInner")
                                          []
                                          [
                                            Ty.apply
                                              (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                              []
                                              [ T ]
                                          ]
                                      ]
                                    |)
                                  ]
                                |)
                              ]
                            |)
                          |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ0_0 :=
                                  M.SubPointer.get_struct_tuple_field (|
                                    γ,
                                    "core::ops::control_flow::ControlFlow::Break",
                                    0
                                  |) in
                                let residual := M.copy (| γ0_0 |) in
                                M.alloc (|
                                  M.never_to_any (|
                                    M.read (|
                                      M.return_ (|
                                        M.call_closure (|
                                          Ty.apply
                                            (Ty.path "core::result::Result")
                                            []
                                            [
                                              Ty.apply
                                                (Ty.path "alloc::rc::Rc")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                                    []
                                                    [ T ];
                                                  Ty.path "alloc::alloc::Global"
                                                ];
                                              Ty.path "core::alloc::AllocError"
                                            ],
                                          M.get_trait_method (|
                                            "core::ops::try_trait::FromResidual",
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "alloc::rc::Rc")
                                                  []
                                                  [
                                                    Ty.apply
                                                      (Ty.path
                                                        "core::mem::maybe_uninit::MaybeUninit")
                                                      []
                                                      [ T ];
                                                    Ty.path "alloc::alloc::Global"
                                                  ];
                                                Ty.path "core::alloc::AllocError"
                                              ],
                                            [],
                                            [
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                []
                                                [
                                                  Ty.path "core::convert::Infallible";
                                                  Ty.path "core::alloc::AllocError"
                                                ]
                                            ],
                                            "from_residual",
                                            [],
                                            []
                                          |),
                                          [ M.read (| residual |) ]
                                        |)
                                      |)
                                    |)
                                  |)
                                |)));
                            fun γ =>
                              ltac:(M.monadic
                                (let γ0_0 :=
                                  M.SubPointer.get_struct_tuple_field (|
                                    γ,
                                    "core::ops::control_flow::ControlFlow::Continue",
                                    0
                                  |) in
                                let val := M.copy (| γ0_0 |) in
                                val))
                          ]
                        |)
                      |)
                    ]
                  |)
                ]))
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_try_new_zeroed :
      forall (T : Ty.t),
      M.IsAssociatedFunction.C (Self T) "try_new_zeroed" (try_new_zeroed T).
    Admitted.
    Global Typeclasses Opaque try_new_zeroed.
    
    (*
        pub fn pin(value: T) -> Pin<Rc<T>> {
            unsafe { Pin::new_unchecked(Rc::new(value)) }
        }
    *)
    Definition pin (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [], [ value ] =>
        ltac:(M.monadic
          (let value := M.alloc (| value |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "core::pin::Pin")
              []
              [ Ty.apply (Ty.path "alloc::rc::Rc") [] [ T; Ty.path "alloc::alloc::Global" ] ],
            M.get_associated_function (|
              Ty.apply
                (Ty.path "core::pin::Pin")
                []
                [ Ty.apply (Ty.path "alloc::rc::Rc") [] [ T; Ty.path "alloc::alloc::Global" ] ],
              "new_unchecked",
              [],
              []
            |),
            [
              M.call_closure (|
                Ty.apply (Ty.path "alloc::rc::Rc") [] [ T; Ty.path "alloc::alloc::Global" ],
                M.get_associated_function (|
                  Ty.apply (Ty.path "alloc::rc::Rc") [] [ T; Ty.path "alloc::alloc::Global" ],
                  "new",
                  [],
                  []
                |),
                [ M.read (| value |) ]
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_pin :
      forall (T : Ty.t),
      M.IsAssociatedFunction.C (Self T) "pin" (pin T).
    Admitted.
    Global Typeclasses Opaque pin.
    (*
        pub unsafe fn from_raw(ptr: *const T) -> Self {
            unsafe { Self::from_raw_in(ptr, Global) }
        }
    *)
    Definition from_raw (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [], [ ptr ] =>
        ltac:(M.monadic
          (let ptr := M.alloc (| ptr |) in
          M.call_closure (|
            Ty.apply (Ty.path "alloc::rc::Rc") [] [ T; Ty.path "alloc::alloc::Global" ],
            M.get_associated_function (|
              Ty.apply (Ty.path "alloc::rc::Rc") [] [ T; Ty.path "alloc::alloc::Global" ],
              "from_raw_in",
              [],
              []
            |),
            [ M.read (| ptr |); Value.StructTuple "alloc::alloc::Global" [] ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_from_raw :
      forall (T : Ty.t),
      M.IsAssociatedFunction.C (Self T) "from_raw" (from_raw T).
    Admitted.
    Global Typeclasses Opaque from_raw.
    
    (*
        pub unsafe fn increment_strong_count(ptr: *const T) {
            unsafe { Self::increment_strong_count_in(ptr, Global) }
        }
    *)
    Definition increment_strong_count
        (T : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [], [ ptr ] =>
        ltac:(M.monadic
          (let ptr := M.alloc (| ptr |) in
          M.call_closure (|
            Ty.tuple [],
            M.get_associated_function (|
              Ty.apply (Ty.path "alloc::rc::Rc") [] [ T; Ty.path "alloc::alloc::Global" ],
              "increment_strong_count_in",
              [],
              []
            |),
            [ M.read (| ptr |); Value.StructTuple "alloc::alloc::Global" [] ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_increment_strong_count :
      forall (T : Ty.t),
      M.IsAssociatedFunction.C (Self T) "increment_strong_count" (increment_strong_count T).
    Admitted.
    Global Typeclasses Opaque increment_strong_count.
    
    (*
        pub unsafe fn decrement_strong_count(ptr: *const T) {
            unsafe { Self::decrement_strong_count_in(ptr, Global) }
        }
    *)
    Definition decrement_strong_count
        (T : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [], [ ptr ] =>
        ltac:(M.monadic
          (let ptr := M.alloc (| ptr |) in
          M.call_closure (|
            Ty.tuple [],
            M.get_associated_function (|
              Ty.apply (Ty.path "alloc::rc::Rc") [] [ T; Ty.path "alloc::alloc::Global" ],
              "decrement_strong_count_in",
              [],
              []
            |),
            [ M.read (| ptr |); Value.StructTuple "alloc::alloc::Global" [] ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_decrement_strong_count :
      forall (T : Ty.t),
      M.IsAssociatedFunction.C (Self T) "decrement_strong_count" (decrement_strong_count T).
    Admitted.
    Global Typeclasses Opaque decrement_strong_count.
    (*
        unsafe fn allocate_for_layout(
            value_layout: Layout,
            allocate: impl FnOnce(Layout) -> Result<NonNull<[u8]>, AllocError>,
            mem_to_rc_inner: impl FnOnce( *mut u8) -> *mut RcInner<T>,
        ) -> *mut RcInner<T> {
            let layout = rc_inner_layout_for_value_layout(value_layout);
            unsafe {
                Rc::try_allocate_for_layout(value_layout, allocate, mem_to_rc_inner)
                    .unwrap_or_else(|_| handle_alloc_error(layout))
            }
        }
    *)
    Definition allocate_for_layout
        (T : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [],
          [
            impl_FnOnce_Layout__arrow_Result_NonNull__u8____AllocError_;
            impl_FnOnce__mut_u8__arrow__mut_RcInner_T_
          ],
          [ value_layout; allocate; mem_to_rc_inner ] =>
        ltac:(M.monadic
          (let value_layout := M.alloc (| value_layout |) in
          let allocate := M.alloc (| allocate |) in
          let mem_to_rc_inner := M.alloc (| mem_to_rc_inner |) in
          M.read (|
            let~ layout : Ty.path "core::alloc::layout::Layout" :=
              M.alloc (|
                M.call_closure (|
                  Ty.path "core::alloc::layout::Layout",
                  M.get_function (| "alloc::rc::rc_inner_layout_for_value_layout", [], [] |),
                  [ M.read (| value_layout |) ]
                |)
              |) in
            M.alloc (|
              M.call_closure (|
                Ty.apply (Ty.path "*mut") [] [ Ty.apply (Ty.path "alloc::rc::RcInner") [] [ T ] ],
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "core::result::Result")
                    []
                    [
                      Ty.apply
                        (Ty.path "*mut")
                        []
                        [ Ty.apply (Ty.path "alloc::rc::RcInner") [] [ T ] ];
                      Ty.path "core::alloc::AllocError"
                    ],
                  "unwrap_or_else",
                  [],
                  [
                    Ty.function
                      [ Ty.tuple [ Ty.path "core::alloc::AllocError" ] ]
                      (Ty.apply
                        (Ty.path "*mut")
                        []
                        [ Ty.apply (Ty.path "alloc::rc::RcInner") [] [ T ] ])
                  ]
                |),
                [
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "core::result::Result")
                      []
                      [
                        Ty.apply
                          (Ty.path "*mut")
                          []
                          [ Ty.apply (Ty.path "alloc::rc::RcInner") [] [ T ] ];
                        Ty.path "core::alloc::AllocError"
                      ],
                    M.get_associated_function (|
                      Ty.apply (Ty.path "alloc::rc::Rc") [] [ T; Ty.path "alloc::alloc::Global" ],
                      "try_allocate_for_layout",
                      [],
                      [
                        impl_FnOnce_Layout__arrow_Result_NonNull__u8____AllocError_;
                        impl_FnOnce__mut_u8__arrow__mut_RcInner_T_
                      ]
                    |),
                    [ M.read (| value_layout |); M.read (| allocate |); M.read (| mem_to_rc_inner |)
                    ]
                  |);
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0 ] =>
                          ltac:(M.monadic
                            (M.match_operator (|
                              Some
                                (Ty.function
                                  [ Ty.tuple [ Ty.path "core::alloc::AllocError" ] ]
                                  (Ty.apply
                                    (Ty.path "*mut")
                                    []
                                    [ Ty.apply (Ty.path "alloc::rc::RcInner") [] [ T ] ])),
                              M.alloc (| α0 |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (M.never_to_any (|
                                      M.call_closure (|
                                        Ty.path "never",
                                        M.get_function (|
                                          "alloc::alloc::handle_alloc_error",
                                          [],
                                          []
                                        |),
                                        [ M.read (| layout |) ]
                                      |)
                                    |)))
                              ]
                            |)))
                        | _ => M.impossible "wrong number of arguments"
                        end))
                ]
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_allocate_for_layout :
      forall (T : Ty.t),
      M.IsAssociatedFunction.C (Self T) "allocate_for_layout" (allocate_for_layout T).
    Admitted.
    Global Typeclasses Opaque allocate_for_layout.
    
    (*
        unsafe fn try_allocate_for_layout(
            value_layout: Layout,
            allocate: impl FnOnce(Layout) -> Result<NonNull<[u8]>, AllocError>,
            mem_to_rc_inner: impl FnOnce( *mut u8) -> *mut RcInner<T>,
        ) -> Result<*mut RcInner<T>, AllocError> {
            let layout = rc_inner_layout_for_value_layout(value_layout);
    
            // Allocate for the layout.
            let ptr = allocate(layout)?;
    
            // Initialize the RcInner
            let inner = mem_to_rc_inner(ptr.as_non_null_ptr().as_ptr());
            unsafe {
                debug_assert_eq!(Layout::for_value_raw(inner), layout);
    
                (&raw mut ( *inner).strong).write(Cell::new(1));
                (&raw mut ( *inner).weak).write(Cell::new(1));
            }
    
            Ok(inner)
        }
    *)
    Definition try_allocate_for_layout
        (T : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [],
          [
            impl_FnOnce_Layout__arrow_Result_NonNull__u8____AllocError_;
            impl_FnOnce__mut_u8__arrow__mut_RcInner_T_
          ],
          [ value_layout; allocate; mem_to_rc_inner ] =>
        ltac:(M.monadic
          (let value_layout := M.alloc (| value_layout |) in
          let allocate := M.alloc (| allocate |) in
          let mem_to_rc_inner := M.alloc (| mem_to_rc_inner |) in
          M.catch_return (|
            ltac:(M.monadic
              (M.read (|
                let~ layout : Ty.path "core::alloc::layout::Layout" :=
                  M.alloc (|
                    M.call_closure (|
                      Ty.path "core::alloc::layout::Layout",
                      M.get_function (| "alloc::rc::rc_inner_layout_for_value_layout", [], [] |),
                      [ M.read (| value_layout |) ]
                    |)
                  |) in
                let~ ptr :
                    Ty.apply
                      (Ty.path "core::ptr::non_null::NonNull")
                      []
                      [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ] :=
                  M.copy (|
                    M.match_operator (|
                      Some
                        (Ty.apply
                          (Ty.path "core::ptr::non_null::NonNull")
                          []
                          [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]),
                      M.alloc (|
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "core::ops::control_flow::ControlFlow")
                            []
                            [
                              Ty.apply
                                (Ty.path "core::result::Result")
                                []
                                [
                                  Ty.path "core::convert::Infallible";
                                  Ty.path "core::alloc::AllocError"
                                ];
                              Ty.apply
                                (Ty.path "core::ptr::non_null::NonNull")
                                []
                                [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
                            ],
                          M.get_trait_method (|
                            "core::ops::try_trait::Try",
                            Ty.apply
                              (Ty.path "core::result::Result")
                              []
                              [
                                Ty.apply
                                  (Ty.path "core::ptr::non_null::NonNull")
                                  []
                                  [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ];
                                Ty.path "core::alloc::AllocError"
                              ],
                            [],
                            [],
                            "branch",
                            [],
                            []
                          |),
                          [
                            M.call_closure (|
                              Ty.apply
                                (Ty.path "core::result::Result")
                                []
                                [
                                  Ty.apply
                                    (Ty.path "core::ptr::non_null::NonNull")
                                    []
                                    [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ];
                                  Ty.path "core::alloc::AllocError"
                                ],
                              M.get_trait_method (|
                                "core::ops::function::FnOnce",
                                impl_FnOnce_Layout__arrow_Result_NonNull__u8____AllocError_,
                                [],
                                [ Ty.tuple [ Ty.path "core::alloc::layout::Layout" ] ],
                                "call_once",
                                [],
                                []
                              |),
                              [ M.read (| allocate |); Value.Tuple [ M.read (| layout |) ] ]
                            |)
                          ]
                        |)
                      |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "core::ops::control_flow::ControlFlow::Break",
                                0
                              |) in
                            let residual := M.copy (| γ0_0 |) in
                            M.alloc (|
                              M.never_to_any (|
                                M.read (|
                                  M.return_ (|
                                    M.call_closure (|
                                      Ty.apply
                                        (Ty.path "core::result::Result")
                                        []
                                        [
                                          Ty.apply
                                            (Ty.path "*mut")
                                            []
                                            [ Ty.apply (Ty.path "alloc::rc::RcInner") [] [ T ] ];
                                          Ty.path "core::alloc::AllocError"
                                        ],
                                      M.get_trait_method (|
                                        "core::ops::try_trait::FromResidual",
                                        Ty.apply
                                          (Ty.path "core::result::Result")
                                          []
                                          [
                                            Ty.apply
                                              (Ty.path "*mut")
                                              []
                                              [ Ty.apply (Ty.path "alloc::rc::RcInner") [] [ T ] ];
                                            Ty.path "core::alloc::AllocError"
                                          ],
                                        [],
                                        [
                                          Ty.apply
                                            (Ty.path "core::result::Result")
                                            []
                                            [
                                              Ty.path "core::convert::Infallible";
                                              Ty.path "core::alloc::AllocError"
                                            ]
                                        ],
                                        "from_residual",
                                        [],
                                        []
                                      |),
                                      [ M.read (| residual |) ]
                                    |)
                                  |)
                                |)
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "core::ops::control_flow::ControlFlow::Continue",
                                0
                              |) in
                            let val := M.copy (| γ0_0 |) in
                            val))
                      ]
                    |)
                  |) in
                let~ inner :
                    Ty.apply
                      (Ty.path "*mut")
                      []
                      [ Ty.apply (Ty.path "alloc::rc::RcInner") [] [ T ] ] :=
                  M.alloc (|
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "*mut")
                        []
                        [ Ty.apply (Ty.path "alloc::rc::RcInner") [] [ T ] ],
                      M.get_trait_method (|
                        "core::ops::function::FnOnce",
                        impl_FnOnce__mut_u8__arrow__mut_RcInner_T_,
                        [],
                        [ Ty.tuple [ Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ] ] ],
                        "call_once",
                        [],
                        []
                      |),
                      [
                        M.read (| mem_to_rc_inner |);
                        Value.Tuple
                          [
                            M.call_closure (|
                              Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ],
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "core::ptr::non_null::NonNull")
                                  []
                                  [ Ty.path "u8" ],
                                "as_ptr",
                                [],
                                []
                              |),
                              [
                                M.call_closure (|
                                  Ty.apply
                                    (Ty.path "core::ptr::non_null::NonNull")
                                    []
                                    [ Ty.path "u8" ],
                                  M.get_associated_function (|
                                    Ty.apply
                                      (Ty.path "core::ptr::non_null::NonNull")
                                      []
                                      [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                                    "as_non_null_ptr",
                                    [],
                                    []
                                  |),
                                  [ M.read (| ptr |) ]
                                |)
                              ]
                            |)
                          ]
                      ]
                    |)
                  |) in
                let~ _ : Ty.tuple [] :=
                  let~ _ : Ty.tuple [] :=
                    M.match_operator (|
                      Some (Ty.tuple []),
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ := M.use (M.alloc (| Value.Bool true |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            let~ _ : Ty.tuple [] :=
                              M.match_operator (|
                                Some (Ty.tuple []),
                                M.alloc (|
                                  Value.Tuple
                                    [
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.alloc (|
                                          M.call_closure (|
                                            Ty.path "core::alloc::layout::Layout",
                                            M.get_associated_function (|
                                              Ty.path "core::alloc::layout::Layout",
                                              "for_value_raw",
                                              [],
                                              [ Ty.apply (Ty.path "alloc::rc::RcInner") [] [ T ] ]
                                            |),
                                            [
                                              (* MutToConstPointer *)
                                              M.pointer_coercion (M.read (| inner |))
                                            ]
                                          |)
                                        |)
                                      |);
                                      M.borrow (| Pointer.Kind.Ref, layout |)
                                    ]
                                |),
                                [
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                      let left_val := M.copy (| γ0_0 |) in
                                      let right_val := M.copy (| γ0_1 |) in
                                      M.match_operator (|
                                        Some (Ty.tuple []),
                                        M.alloc (| Value.Tuple [] |),
                                        [
                                          fun γ =>
                                            ltac:(M.monadic
                                              (let γ :=
                                                M.use
                                                  (M.alloc (|
                                                    UnOp.not (|
                                                      M.call_closure (|
                                                        Ty.path "bool",
                                                        M.get_trait_method (|
                                                          "core::cmp::PartialEq",
                                                          Ty.path "core::alloc::layout::Layout",
                                                          [],
                                                          [ Ty.path "core::alloc::layout::Layout" ],
                                                          "eq",
                                                          [],
                                                          []
                                                        |),
                                                        [
                                                          M.borrow (|
                                                            Pointer.Kind.Ref,
                                                            M.deref (| M.read (| left_val |) |)
                                                          |);
                                                          M.borrow (|
                                                            Pointer.Kind.Ref,
                                                            M.deref (| M.read (| right_val |) |)
                                                          |)
                                                        ]
                                                      |)
                                                    |)
                                                  |)) in
                                              let _ :=
                                                M.is_constant_or_break_match (|
                                                  M.read (| γ |),
                                                  Value.Bool true
                                                |) in
                                              M.alloc (|
                                                M.never_to_any (|
                                                  M.read (|
                                                    let~ kind :
                                                        Ty.path "core::panicking::AssertKind" :=
                                                      M.alloc (|
                                                        Value.StructTuple
                                                          "core::panicking::AssertKind::Eq"
                                                          []
                                                      |) in
                                                    M.alloc (|
                                                      M.call_closure (|
                                                        Ty.path "never",
                                                        M.get_function (|
                                                          "core::panicking::assert_failed",
                                                          [],
                                                          [
                                                            Ty.path "core::alloc::layout::Layout";
                                                            Ty.path "core::alloc::layout::Layout"
                                                          ]
                                                        |),
                                                        [
                                                          M.read (| kind |);
                                                          M.borrow (|
                                                            Pointer.Kind.Ref,
                                                            M.deref (|
                                                              M.borrow (|
                                                                Pointer.Kind.Ref,
                                                                M.deref (| M.read (| left_val |) |)
                                                              |)
                                                            |)
                                                          |);
                                                          M.borrow (|
                                                            Pointer.Kind.Ref,
                                                            M.deref (|
                                                              M.borrow (|
                                                                Pointer.Kind.Ref,
                                                                M.deref (| M.read (| right_val |) |)
                                                              |)
                                                            |)
                                                          |);
                                                          Value.StructTuple
                                                            "core::option::Option::None"
                                                            []
                                                        ]
                                                      |)
                                                    |)
                                                  |)
                                                |)
                                              |)));
                                          fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                                        ]
                                      |)))
                                ]
                              |) in
                            M.alloc (| Value.Tuple [] |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                      ]
                    |) in
                  let~ _ : Ty.tuple [] :=
                    M.alloc (|
                      M.call_closure (|
                        Ty.tuple [],
                        M.get_associated_function (|
                          Ty.apply
                            (Ty.path "*mut")
                            []
                            [ Ty.apply (Ty.path "core::cell::Cell") [] [ Ty.path "usize" ] ],
                          "write",
                          [],
                          []
                        |),
                        [
                          M.borrow (|
                            Pointer.Kind.MutPointer,
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| inner |) |),
                              "alloc::rc::RcInner",
                              "strong"
                            |)
                          |);
                          M.call_closure (|
                            Ty.apply (Ty.path "core::cell::Cell") [] [ Ty.path "usize" ],
                            M.get_associated_function (|
                              Ty.apply (Ty.path "core::cell::Cell") [] [ Ty.path "usize" ],
                              "new",
                              [],
                              []
                            |),
                            [ Value.Integer IntegerKind.Usize 1 ]
                          |)
                        ]
                      |)
                    |) in
                  let~ _ : Ty.tuple [] :=
                    M.alloc (|
                      M.call_closure (|
                        Ty.tuple [],
                        M.get_associated_function (|
                          Ty.apply
                            (Ty.path "*mut")
                            []
                            [ Ty.apply (Ty.path "core::cell::Cell") [] [ Ty.path "usize" ] ],
                          "write",
                          [],
                          []
                        |),
                        [
                          M.borrow (|
                            Pointer.Kind.MutPointer,
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| inner |) |),
                              "alloc::rc::RcInner",
                              "weak"
                            |)
                          |);
                          M.call_closure (|
                            Ty.apply (Ty.path "core::cell::Cell") [] [ Ty.path "usize" ],
                            M.get_associated_function (|
                              Ty.apply (Ty.path "core::cell::Cell") [] [ Ty.path "usize" ],
                              "new",
                              [],
                              []
                            |),
                            [ Value.Integer IntegerKind.Usize 1 ]
                          |)
                        ]
                      |)
                    |) in
                  M.alloc (| Value.Tuple [] |) in
                M.alloc (| Value.StructTuple "core::result::Result::Ok" [ M.read (| inner |) ] |)
              |)))
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_try_allocate_for_layout :
      forall (T : Ty.t),
      M.IsAssociatedFunction.C (Self T) "try_allocate_for_layout" (try_allocate_for_layout T).
    Admitted.
    Global Typeclasses Opaque try_allocate_for_layout.
  End Impl_alloc_rc_Rc_T_alloc_alloc_Global.
  
  Module Impl_alloc_rc_Rc_T_A.
    Definition Self (T A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::rc::Rc") [] [ T; A ].
    
    (*
        fn inner(&self) -> &RcInner<T> {
            // This unsafety is ok because while this Rc is alive we're guaranteed
            // that the inner pointer is valid.
            unsafe { self.ptr.as_ref() }
        }
    *)
    Definition inner (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.borrow (|
            Pointer.Kind.Ref,
            M.deref (|
              M.call_closure (|
                Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "alloc::rc::RcInner") [] [ T ] ],
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "core::ptr::non_null::NonNull")
                    []
                    [ Ty.apply (Ty.path "alloc::rc::RcInner") [] [ T ] ],
                  "as_ref",
                  [],
                  []
                |),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| self |) |),
                      "alloc::rc::Rc",
                      "ptr"
                    |)
                  |)
                ]
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_inner :
      forall (T A : Ty.t),
      M.IsAssociatedFunction.C (Self T A) "inner" (inner T A).
    Admitted.
    Global Typeclasses Opaque inner.
    
    (*
        fn into_inner_with_allocator(this: Self) -> (NonNull<RcInner<T>>, A) {
            let this = mem::ManuallyDrop::new(this);
            (this.ptr, unsafe { ptr::read(&this.alloc) })
        }
    *)
    Definition into_inner_with_allocator
        (T A : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ this ] =>
        ltac:(M.monadic
          (let this := M.alloc (| this |) in
          M.read (|
            let~ this :
                Ty.apply
                  (Ty.path "core::mem::manually_drop::ManuallyDrop")
                  []
                  [ Ty.apply (Ty.path "alloc::rc::Rc") [] [ T; A ] ] :=
              M.alloc (|
                M.call_closure (|
                  Ty.apply
                    (Ty.path "core::mem::manually_drop::ManuallyDrop")
                    []
                    [ Ty.apply (Ty.path "alloc::rc::Rc") [] [ T; A ] ],
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "core::mem::manually_drop::ManuallyDrop")
                      []
                      [ Ty.apply (Ty.path "alloc::rc::Rc") [] [ T; A ] ],
                    "new",
                    [],
                    []
                  |),
                  [ M.read (| this |) ]
                |)
              |) in
            M.alloc (|
              Value.Tuple
                [
                  M.read (|
                    M.SubPointer.get_struct_record_field (|
                      M.deref (|
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "&")
                            []
                            [ Ty.apply (Ty.path "alloc::rc::Rc") [] [ T; A ] ],
                          M.get_trait_method (|
                            "core::ops::deref::Deref",
                            Ty.apply
                              (Ty.path "core::mem::manually_drop::ManuallyDrop")
                              []
                              [ Ty.apply (Ty.path "alloc::rc::Rc") [] [ T; A ] ],
                            [],
                            [],
                            "deref",
                            [],
                            []
                          |),
                          [ M.borrow (| Pointer.Kind.Ref, this |) ]
                        |)
                      |),
                      "alloc::rc::Rc",
                      "ptr"
                    |)
                  |);
                  M.call_closure (|
                    A,
                    M.get_function (| "core::ptr::read", [], [ A ] |),
                    [
                      M.borrow (|
                        Pointer.Kind.ConstPointer,
                        M.deref (|
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.SubPointer.get_struct_record_field (|
                              M.deref (|
                                M.call_closure (|
                                  Ty.apply
                                    (Ty.path "&")
                                    []
                                    [ Ty.apply (Ty.path "alloc::rc::Rc") [] [ T; A ] ],
                                  M.get_trait_method (|
                                    "core::ops::deref::Deref",
                                    Ty.apply
                                      (Ty.path "core::mem::manually_drop::ManuallyDrop")
                                      []
                                      [ Ty.apply (Ty.path "alloc::rc::Rc") [] [ T; A ] ],
                                    [],
                                    [],
                                    "deref",
                                    [],
                                    []
                                  |),
                                  [ M.borrow (| Pointer.Kind.Ref, this |) ]
                                |)
                              |),
                              "alloc::rc::Rc",
                              "alloc"
                            |)
                          |)
                        |)
                      |)
                    ]
                  |)
                ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_into_inner_with_allocator :
      forall (T A : Ty.t),
      M.IsAssociatedFunction.C
        (Self T A)
        "into_inner_with_allocator"
        (into_inner_with_allocator T A).
    Admitted.
    Global Typeclasses Opaque into_inner_with_allocator.
    
    (*
        unsafe fn from_inner_in(ptr: NonNull<RcInner<T>>, alloc: A) -> Self {
            Self { ptr, phantom: PhantomData, alloc }
        }
    *)
    Definition from_inner_in
        (T A : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ ptr; alloc ] =>
        ltac:(M.monadic
          (let ptr := M.alloc (| ptr |) in
          let alloc := M.alloc (| alloc |) in
          Value.StructRecord
            "alloc::rc::Rc"
            [
              ("ptr", M.read (| ptr |));
              ("phantom", Value.StructTuple "core::marker::PhantomData" []);
              ("alloc", M.read (| alloc |))
            ]))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_from_inner_in :
      forall (T A : Ty.t),
      M.IsAssociatedFunction.C (Self T A) "from_inner_in" (from_inner_in T A).
    Admitted.
    Global Typeclasses Opaque from_inner_in.
    
    (*
        unsafe fn from_ptr_in(ptr: *mut RcInner<T>, alloc: A) -> Self {
            unsafe { Self::from_inner_in(NonNull::new_unchecked(ptr), alloc) }
        }
    *)
    Definition from_ptr_in (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ ptr; alloc ] =>
        ltac:(M.monadic
          (let ptr := M.alloc (| ptr |) in
          let alloc := M.alloc (| alloc |) in
          M.call_closure (|
            Ty.apply (Ty.path "alloc::rc::Rc") [] [ T; A ],
            M.get_associated_function (|
              Ty.apply (Ty.path "alloc::rc::Rc") [] [ T; A ],
              "from_inner_in",
              [],
              []
            |),
            [
              M.call_closure (|
                Ty.apply
                  (Ty.path "core::ptr::non_null::NonNull")
                  []
                  [ Ty.apply (Ty.path "alloc::rc::RcInner") [] [ T ] ],
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "core::ptr::non_null::NonNull")
                    []
                    [ Ty.apply (Ty.path "alloc::rc::RcInner") [] [ T ] ],
                  "new_unchecked",
                  [],
                  []
                |),
                [ M.read (| ptr |) ]
              |);
              M.read (| alloc |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_from_ptr_in :
      forall (T A : Ty.t),
      M.IsAssociatedFunction.C (Self T A) "from_ptr_in" (from_ptr_in T A).
    Admitted.
    Global Typeclasses Opaque from_ptr_in.
    
    (*
        unsafe fn drop_slow(&mut self) {
            // Reconstruct the "strong weak" pointer and drop it when this
            // variable goes out of scope. This ensures that the memory is
            // deallocated even if the destructor of `T` panics.
            let _weak = Weak { ptr: self.ptr, alloc: &self.alloc };
    
            // Destroy the contained object.
            // We cannot use `get_mut_unchecked` here, because `self.alloc` is borrowed.
            unsafe {
                ptr::drop_in_place(&mut ( *self.ptr.as_ptr()).value);
            }
        }
    *)
    Definition drop_slow (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            let~ _weak :
                Ty.apply (Ty.path "alloc::rc::Weak") [] [ T; Ty.apply (Ty.path "&") [] [ A ] ] :=
              M.alloc (|
                Value.StructRecord
                  "alloc::rc::Weak"
                  [
                    ("ptr",
                      M.read (|
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "alloc::rc::Rc",
                          "ptr"
                        |)
                      |));
                    ("alloc",
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "alloc::rc::Rc",
                          "alloc"
                        |)
                      |))
                  ]
              |) in
            let~ _ : Ty.tuple [] :=
              M.alloc (|
                M.call_closure (|
                  Ty.tuple [],
                  M.get_function (| "core::ptr::drop_in_place", [], [ T ] |),
                  [
                    M.borrow (|
                      Pointer.Kind.MutPointer,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.MutRef,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (|
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "*mut")
                                  []
                                  [ Ty.apply (Ty.path "alloc::rc::RcInner") [] [ T ] ],
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "core::ptr::non_null::NonNull")
                                    []
                                    [ Ty.apply (Ty.path "alloc::rc::RcInner") [] [ T ] ],
                                  "as_ptr",
                                  [],
                                  []
                                |),
                                [
                                  M.read (|
                                    M.SubPointer.get_struct_record_field (|
                                      M.deref (| M.read (| self |) |),
                                      "alloc::rc::Rc",
                                      "ptr"
                                    |)
                                  |)
                                ]
                              |)
                            |),
                            "alloc::rc::RcInner",
                            "value"
                          |)
                        |)
                      |)
                    |)
                  ]
                |)
              |) in
            M.alloc (| Value.Tuple [] |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_drop_slow :
      forall (T A : Ty.t),
      M.IsAssociatedFunction.C (Self T A) "drop_slow" (drop_slow T A).
    Admitted.
    Global Typeclasses Opaque drop_slow.
    (*
        pub fn new_in(value: T, alloc: A) -> Rc<T, A> {
            // NOTE: Prefer match over unwrap_or_else since closure sometimes not inlineable.
            // That would make code size bigger.
            match Self::try_new_in(value, alloc) {
                Ok(m) => m,
                Err(_) => handle_alloc_error(Layout::new::<RcInner<T>>()),
            }
        }
    *)
    Definition new_in (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ value; alloc ] =>
        ltac:(M.monadic
          (let value := M.alloc (| value |) in
          let alloc := M.alloc (| alloc |) in
          M.read (|
            M.match_operator (|
              Some (Ty.apply (Ty.path "alloc::rc::Rc") [] [ T; A ]),
              M.alloc (|
                M.call_closure (|
                  Ty.apply
                    (Ty.path "core::result::Result")
                    []
                    [
                      Ty.apply (Ty.path "alloc::rc::Rc") [] [ T; A ];
                      Ty.path "core::alloc::AllocError"
                    ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "alloc::rc::Rc") [] [ T; A ],
                    "try_new_in",
                    [],
                    []
                  |),
                  [ M.read (| value |); M.read (| alloc |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 :=
                      M.SubPointer.get_struct_tuple_field (| γ, "core::result::Result::Ok", 0 |) in
                    let m := M.copy (| γ0_0 |) in
                    m));
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 :=
                      M.SubPointer.get_struct_tuple_field (| γ, "core::result::Result::Err", 0 |) in
                    M.alloc (|
                      M.never_to_any (|
                        M.call_closure (|
                          Ty.path "never",
                          M.get_function (| "alloc::alloc::handle_alloc_error", [], [] |),
                          [
                            M.call_closure (|
                              Ty.path "core::alloc::layout::Layout",
                              M.get_associated_function (|
                                Ty.path "core::alloc::layout::Layout",
                                "new",
                                [],
                                [ Ty.apply (Ty.path "alloc::rc::RcInner") [] [ T ] ]
                              |),
                              []
                            |)
                          ]
                        |)
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_new_in :
      forall (T A : Ty.t),
      M.IsAssociatedFunction.C (Self T A) "new_in" (new_in T A).
    Admitted.
    Global Typeclasses Opaque new_in.
    
    (*
        pub fn new_uninit_in(alloc: A) -> Rc<mem::MaybeUninit<T>, A> {
            unsafe {
                Rc::from_ptr_in(
                    Rc::allocate_for_layout(
                        Layout::new::<T>(),
                        |layout| alloc.allocate(layout),
                        <*mut u8>::cast,
                    ),
                    alloc,
                )
            }
        }
    *)
    Definition new_uninit_in
        (T A : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ alloc ] =>
        ltac:(M.monadic
          (let alloc := M.alloc (| alloc |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "alloc::rc::Rc")
              []
              [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ]; A ],
            M.get_associated_function (|
              Ty.apply
                (Ty.path "alloc::rc::Rc")
                []
                [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ]; A ],
              "from_ptr_in",
              [],
              []
            |),
            [
              M.call_closure (|
                Ty.apply
                  (Ty.path "*mut")
                  []
                  [
                    Ty.apply
                      (Ty.path "alloc::rc::RcInner")
                      []
                      [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ] ]
                  ],
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "alloc::rc::Rc")
                    []
                    [
                      Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ];
                      Ty.path "alloc::alloc::Global"
                    ],
                  "allocate_for_layout",
                  [],
                  [
                    Ty.function
                      [ Ty.tuple [ Ty.path "core::alloc::layout::Layout" ] ]
                      (Ty.apply
                        (Ty.path "core::result::Result")
                        []
                        [
                          Ty.apply
                            (Ty.path "core::ptr::non_null::NonNull")
                            []
                            [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ];
                          Ty.path "core::alloc::AllocError"
                        ]);
                    Ty.function
                      [ Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ] ]
                      (Ty.apply
                        (Ty.path "*mut")
                        []
                        [
                          Ty.apply
                            (Ty.path "alloc::rc::RcInner")
                            []
                            [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ] ]
                        ])
                  ]
                |),
                [
                  M.call_closure (|
                    Ty.path "core::alloc::layout::Layout",
                    M.get_associated_function (|
                      Ty.path "core::alloc::layout::Layout",
                      "new",
                      [],
                      [ T ]
                    |),
                    []
                  |);
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0 ] =>
                          ltac:(M.monadic
                            (M.match_operator (|
                              Some
                                (Ty.function
                                  [ Ty.tuple [ Ty.path "core::alloc::layout::Layout" ] ]
                                  (Ty.apply
                                    (Ty.path "core::result::Result")
                                    []
                                    [
                                      Ty.apply
                                        (Ty.path "core::ptr::non_null::NonNull")
                                        []
                                        [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ];
                                      Ty.path "core::alloc::AllocError"
                                    ])),
                              M.alloc (| α0 |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let layout := M.copy (| γ |) in
                                    M.call_closure (|
                                      Ty.apply
                                        (Ty.path "core::result::Result")
                                        []
                                        [
                                          Ty.apply
                                            (Ty.path "core::ptr::non_null::NonNull")
                                            []
                                            [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ];
                                          Ty.path "core::alloc::AllocError"
                                        ],
                                      M.get_trait_method (|
                                        "core::alloc::Allocator",
                                        A,
                                        [],
                                        [],
                                        "allocate",
                                        [],
                                        []
                                      |),
                                      [ M.borrow (| Pointer.Kind.Ref, alloc |); M.read (| layout |)
                                      ]
                                    |)))
                              ]
                            |)))
                        | _ => M.impossible "wrong number of arguments"
                        end));
                  M.get_associated_function (|
                    Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ],
                    "cast",
                    [],
                    [
                      Ty.apply
                        (Ty.path "alloc::rc::RcInner")
                        []
                        [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ] ]
                    ]
                  |)
                ]
              |);
              M.read (| alloc |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_new_uninit_in :
      forall (T A : Ty.t),
      M.IsAssociatedFunction.C (Self T A) "new_uninit_in" (new_uninit_in T A).
    Admitted.
    Global Typeclasses Opaque new_uninit_in.
    
    (*
        pub fn new_zeroed_in(alloc: A) -> Rc<mem::MaybeUninit<T>, A> {
            unsafe {
                Rc::from_ptr_in(
                    Rc::allocate_for_layout(
                        Layout::new::<T>(),
                        |layout| alloc.allocate_zeroed(layout),
                        <*mut u8>::cast,
                    ),
                    alloc,
                )
            }
        }
    *)
    Definition new_zeroed_in
        (T A : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ alloc ] =>
        ltac:(M.monadic
          (let alloc := M.alloc (| alloc |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "alloc::rc::Rc")
              []
              [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ]; A ],
            M.get_associated_function (|
              Ty.apply
                (Ty.path "alloc::rc::Rc")
                []
                [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ]; A ],
              "from_ptr_in",
              [],
              []
            |),
            [
              M.call_closure (|
                Ty.apply
                  (Ty.path "*mut")
                  []
                  [
                    Ty.apply
                      (Ty.path "alloc::rc::RcInner")
                      []
                      [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ] ]
                  ],
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "alloc::rc::Rc")
                    []
                    [
                      Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ];
                      Ty.path "alloc::alloc::Global"
                    ],
                  "allocate_for_layout",
                  [],
                  [
                    Ty.function
                      [ Ty.tuple [ Ty.path "core::alloc::layout::Layout" ] ]
                      (Ty.apply
                        (Ty.path "core::result::Result")
                        []
                        [
                          Ty.apply
                            (Ty.path "core::ptr::non_null::NonNull")
                            []
                            [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ];
                          Ty.path "core::alloc::AllocError"
                        ]);
                    Ty.function
                      [ Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ] ]
                      (Ty.apply
                        (Ty.path "*mut")
                        []
                        [
                          Ty.apply
                            (Ty.path "alloc::rc::RcInner")
                            []
                            [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ] ]
                        ])
                  ]
                |),
                [
                  M.call_closure (|
                    Ty.path "core::alloc::layout::Layout",
                    M.get_associated_function (|
                      Ty.path "core::alloc::layout::Layout",
                      "new",
                      [],
                      [ T ]
                    |),
                    []
                  |);
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0 ] =>
                          ltac:(M.monadic
                            (M.match_operator (|
                              Some
                                (Ty.function
                                  [ Ty.tuple [ Ty.path "core::alloc::layout::Layout" ] ]
                                  (Ty.apply
                                    (Ty.path "core::result::Result")
                                    []
                                    [
                                      Ty.apply
                                        (Ty.path "core::ptr::non_null::NonNull")
                                        []
                                        [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ];
                                      Ty.path "core::alloc::AllocError"
                                    ])),
                              M.alloc (| α0 |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let layout := M.copy (| γ |) in
                                    M.call_closure (|
                                      Ty.apply
                                        (Ty.path "core::result::Result")
                                        []
                                        [
                                          Ty.apply
                                            (Ty.path "core::ptr::non_null::NonNull")
                                            []
                                            [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ];
                                          Ty.path "core::alloc::AllocError"
                                        ],
                                      M.get_trait_method (|
                                        "core::alloc::Allocator",
                                        A,
                                        [],
                                        [],
                                        "allocate_zeroed",
                                        [],
                                        []
                                      |),
                                      [ M.borrow (| Pointer.Kind.Ref, alloc |); M.read (| layout |)
                                      ]
                                    |)))
                              ]
                            |)))
                        | _ => M.impossible "wrong number of arguments"
                        end));
                  M.get_associated_function (|
                    Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ],
                    "cast",
                    [],
                    [
                      Ty.apply
                        (Ty.path "alloc::rc::RcInner")
                        []
                        [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ] ]
                    ]
                  |)
                ]
              |);
              M.read (| alloc |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_new_zeroed_in :
      forall (T A : Ty.t),
      M.IsAssociatedFunction.C (Self T A) "new_zeroed_in" (new_zeroed_in T A).
    Admitted.
    Global Typeclasses Opaque new_zeroed_in.
    
    (*
        pub fn new_cyclic_in<F>(data_fn: F, alloc: A) -> Rc<T, A>
        where
            F: FnOnce(&Weak<T, A>) -> T,
        {
            // Construct the inner in the "uninitialized" state with a single
            // weak reference.
            let (uninit_raw_ptr, alloc) = Box::into_raw_with_allocator(Box::new_in(
                RcInner {
                    strong: Cell::new(0),
                    weak: Cell::new(1),
                    value: mem::MaybeUninit::<T>::uninit(),
                },
                alloc,
            ));
            let uninit_ptr: NonNull<_> = (unsafe { &mut *uninit_raw_ptr }).into();
            let init_ptr: NonNull<RcInner<T>> = uninit_ptr.cast();
    
            let weak = Weak { ptr: init_ptr, alloc: alloc };
    
            // It's important we don't give up ownership of the weak pointer, or
            // else the memory might be freed by the time `data_fn` returns. If
            // we really wanted to pass ownership, we could create an additional
            // weak pointer for ourselves, but this would result in additional
            // updates to the weak reference count which might not be necessary
            // otherwise.
            let data = data_fn(&weak);
    
            let strong = unsafe {
                let inner = init_ptr.as_ptr();
                ptr::write(&raw mut ( *inner).value, data);
    
                let prev_value = ( *inner).strong.get();
                debug_assert_eq!(prev_value, 0, "No prior strong references should exist");
                ( *inner).strong.set(1);
    
                // Strong references should collectively own a shared weak reference,
                // so don't run the destructor for our old weak reference.
                // Calling into_raw_with_allocator has the double effect of giving us back the allocator,
                // and forgetting the weak reference.
                let alloc = weak.into_raw_with_allocator().1;
    
                Rc::from_inner_in(init_ptr, alloc)
            };
    
            strong
        }
    *)
    Definition new_cyclic_in
        (T A : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [ F ], [ data_fn; alloc ] =>
        ltac:(M.monadic
          (let data_fn := M.alloc (| data_fn |) in
          let alloc := M.alloc (| alloc |) in
          M.read (|
            M.match_operator (|
              None,
              M.alloc (|
                M.call_closure (|
                  Ty.tuple
                    [
                      Ty.apply
                        (Ty.path "*mut")
                        []
                        [
                          Ty.apply
                            (Ty.path "alloc::rc::RcInner")
                            []
                            [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ] ]
                        ];
                      A
                    ],
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "alloc::boxed::Box")
                      []
                      [
                        Ty.apply
                          (Ty.path "alloc::rc::RcInner")
                          []
                          [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ] ];
                        A
                      ],
                    "into_raw_with_allocator",
                    [],
                    []
                  |),
                  [
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "alloc::boxed::Box")
                        []
                        [
                          Ty.apply
                            (Ty.path "alloc::rc::RcInner")
                            []
                            [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ] ];
                          A
                        ],
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "alloc::boxed::Box")
                          []
                          [
                            Ty.apply
                              (Ty.path "alloc::rc::RcInner")
                              []
                              [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ]
                              ];
                            A
                          ],
                        "new_in",
                        [],
                        []
                      |),
                      [
                        Value.StructRecord
                          "alloc::rc::RcInner"
                          [
                            ("strong",
                              M.call_closure (|
                                Ty.apply (Ty.path "core::cell::Cell") [] [ Ty.path "usize" ],
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "core::cell::Cell") [] [ Ty.path "usize" ],
                                  "new",
                                  [],
                                  []
                                |),
                                [ Value.Integer IntegerKind.Usize 0 ]
                              |));
                            ("weak",
                              M.call_closure (|
                                Ty.apply (Ty.path "core::cell::Cell") [] [ Ty.path "usize" ],
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "core::cell::Cell") [] [ Ty.path "usize" ],
                                  "new",
                                  [],
                                  []
                                |),
                                [ Value.Integer IntegerKind.Usize 1 ]
                              |));
                            ("value",
                              M.call_closure (|
                                Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ],
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                    []
                                    [ T ],
                                  "uninit",
                                  [],
                                  []
                                |),
                                []
                              |))
                          ];
                        M.read (| alloc |)
                      ]
                    |)
                  ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let uninit_raw_ptr := M.copy (| γ0_0 |) in
                    let alloc := M.copy (| γ0_1 |) in
                    let~ uninit_ptr :
                        Ty.apply
                          (Ty.path "core::ptr::non_null::NonNull")
                          []
                          [
                            Ty.apply
                              (Ty.path "alloc::rc::RcInner")
                              []
                              [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ] ]
                          ] :=
                      M.alloc (|
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "core::ptr::non_null::NonNull")
                            []
                            [
                              Ty.apply
                                (Ty.path "alloc::rc::RcInner")
                                []
                                [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ]
                                ]
                            ],
                          M.get_trait_method (|
                            "core::convert::Into",
                            Ty.apply
                              (Ty.path "&mut")
                              []
                              [
                                Ty.apply
                                  (Ty.path "alloc::rc::RcInner")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                      []
                                      [ T ]
                                  ]
                              ],
                            [],
                            [
                              Ty.apply
                                (Ty.path "core::ptr::non_null::NonNull")
                                []
                                [
                                  Ty.apply
                                    (Ty.path "alloc::rc::RcInner")
                                    []
                                    [
                                      Ty.apply
                                        (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                        []
                                        [ T ]
                                    ]
                                ]
                            ],
                            "into",
                            [],
                            []
                          |),
                          [
                            M.borrow (|
                              Pointer.Kind.MutRef,
                              M.deref (|
                                M.borrow (|
                                  Pointer.Kind.MutRef,
                                  M.deref (| M.read (| uninit_raw_ptr |) |)
                                |)
                              |)
                            |)
                          ]
                        |)
                      |) in
                    let~ init_ptr :
                        Ty.apply
                          (Ty.path "core::ptr::non_null::NonNull")
                          []
                          [ Ty.apply (Ty.path "alloc::rc::RcInner") [] [ T ] ] :=
                      M.alloc (|
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "core::ptr::non_null::NonNull")
                            []
                            [ Ty.apply (Ty.path "alloc::rc::RcInner") [] [ T ] ],
                          M.get_associated_function (|
                            Ty.apply
                              (Ty.path "core::ptr::non_null::NonNull")
                              []
                              [
                                Ty.apply
                                  (Ty.path "alloc::rc::RcInner")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                      []
                                      [ T ]
                                  ]
                              ],
                            "cast",
                            [],
                            [ Ty.apply (Ty.path "alloc::rc::RcInner") [] [ T ] ]
                          |),
                          [ M.read (| uninit_ptr |) ]
                        |)
                      |) in
                    let~ weak : Ty.apply (Ty.path "alloc::rc::Weak") [] [ T; A ] :=
                      M.alloc (|
                        Value.StructRecord
                          "alloc::rc::Weak"
                          [ ("ptr", M.read (| init_ptr |)); ("alloc", M.read (| alloc |)) ]
                      |) in
                    let~ data : T :=
                      M.alloc (|
                        M.call_closure (|
                          T,
                          M.get_trait_method (|
                            "core::ops::function::FnOnce",
                            F,
                            [],
                            [
                              Ty.tuple
                                [
                                  Ty.apply
                                    (Ty.path "&")
                                    []
                                    [ Ty.apply (Ty.path "alloc::rc::Weak") [] [ T; A ] ]
                                ]
                            ],
                            "call_once",
                            [],
                            []
                          |),
                          [
                            M.read (| data_fn |);
                            Value.Tuple
                              [
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.deref (| M.borrow (| Pointer.Kind.Ref, weak |) |)
                                |)
                              ]
                          ]
                        |)
                      |) in
                    let~ strong : Ty.apply (Ty.path "alloc::rc::Rc") [] [ T; A ] :=
                      M.copy (|
                        let~ inner :
                            Ty.apply
                              (Ty.path "*mut")
                              []
                              [ Ty.apply (Ty.path "alloc::rc::RcInner") [] [ T ] ] :=
                          M.alloc (|
                            M.call_closure (|
                              Ty.apply
                                (Ty.path "*mut")
                                []
                                [ Ty.apply (Ty.path "alloc::rc::RcInner") [] [ T ] ],
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "core::ptr::non_null::NonNull")
                                  []
                                  [ Ty.apply (Ty.path "alloc::rc::RcInner") [] [ T ] ],
                                "as_ptr",
                                [],
                                []
                              |),
                              [ M.read (| init_ptr |) ]
                            |)
                          |) in
                        let~ _ : Ty.tuple [] :=
                          M.alloc (|
                            M.call_closure (|
                              Ty.tuple [],
                              M.get_function (| "core::ptr::write", [], [ T ] |),
                              [
                                M.borrow (|
                                  Pointer.Kind.MutPointer,
                                  M.SubPointer.get_struct_record_field (|
                                    M.deref (| M.read (| inner |) |),
                                    "alloc::rc::RcInner",
                                    "value"
                                  |)
                                |);
                                M.read (| data |)
                              ]
                            |)
                          |) in
                        let~ prev_value : Ty.path "usize" :=
                          M.alloc (|
                            M.call_closure (|
                              Ty.path "usize",
                              M.get_associated_function (|
                                Ty.apply (Ty.path "core::cell::Cell") [] [ Ty.path "usize" ],
                                "get",
                                [],
                                []
                              |),
                              [
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.SubPointer.get_struct_record_field (|
                                    M.deref (| M.read (| inner |) |),
                                    "alloc::rc::RcInner",
                                    "strong"
                                  |)
                                |)
                              ]
                            |)
                          |) in
                        let~ _ : Ty.tuple [] :=
                          M.match_operator (|
                            Some (Ty.tuple []),
                            M.alloc (| Value.Tuple [] |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ := M.use (M.alloc (| Value.Bool true |)) in
                                  let _ :=
                                    M.is_constant_or_break_match (|
                                      M.read (| γ |),
                                      Value.Bool true
                                    |) in
                                  let~ _ : Ty.tuple [] :=
                                    M.match_operator (|
                                      Some (Ty.tuple []),
                                      M.alloc (|
                                        Value.Tuple
                                          [
                                            M.borrow (| Pointer.Kind.Ref, prev_value |);
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.alloc (| Value.Integer IntegerKind.Usize 0 |)
                                            |)
                                          ]
                                      |),
                                      [
                                        fun γ =>
                                          ltac:(M.monadic
                                            (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                                            let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                            let left_val := M.copy (| γ0_0 |) in
                                            let right_val := M.copy (| γ0_1 |) in
                                            M.match_operator (|
                                              Some (Ty.tuple []),
                                              M.alloc (| Value.Tuple [] |),
                                              [
                                                fun γ =>
                                                  ltac:(M.monadic
                                                    (let γ :=
                                                      M.use
                                                        (M.alloc (|
                                                          UnOp.not (|
                                                            BinOp.eq (|
                                                              M.read (|
                                                                M.deref (| M.read (| left_val |) |)
                                                              |),
                                                              M.read (|
                                                                M.deref (| M.read (| right_val |) |)
                                                              |)
                                                            |)
                                                          |)
                                                        |)) in
                                                    let _ :=
                                                      M.is_constant_or_break_match (|
                                                        M.read (| γ |),
                                                        Value.Bool true
                                                      |) in
                                                    M.alloc (|
                                                      M.never_to_any (|
                                                        M.read (|
                                                          let~ kind :
                                                              Ty.path
                                                                "core::panicking::AssertKind" :=
                                                            M.alloc (|
                                                              Value.StructTuple
                                                                "core::panicking::AssertKind::Eq"
                                                                []
                                                            |) in
                                                          M.alloc (|
                                                            M.call_closure (|
                                                              Ty.path "never",
                                                              M.get_function (|
                                                                "core::panicking::assert_failed",
                                                                [],
                                                                [ Ty.path "usize"; Ty.path "usize" ]
                                                              |),
                                                              [
                                                                M.read (| kind |);
                                                                M.borrow (|
                                                                  Pointer.Kind.Ref,
                                                                  M.deref (|
                                                                    M.borrow (|
                                                                      Pointer.Kind.Ref,
                                                                      M.deref (|
                                                                        M.read (| left_val |)
                                                                      |)
                                                                    |)
                                                                  |)
                                                                |);
                                                                M.borrow (|
                                                                  Pointer.Kind.Ref,
                                                                  M.deref (|
                                                                    M.borrow (|
                                                                      Pointer.Kind.Ref,
                                                                      M.deref (|
                                                                        M.read (| right_val |)
                                                                      |)
                                                                    |)
                                                                  |)
                                                                |);
                                                                Value.StructTuple
                                                                  "core::option::Option::Some"
                                                                  [
                                                                    M.call_closure (|
                                                                      Ty.path
                                                                        "core::fmt::Arguments",
                                                                      M.get_associated_function (|
                                                                        Ty.path
                                                                          "core::fmt::Arguments",
                                                                        "new_const",
                                                                        [
                                                                          Value.Integer
                                                                            IntegerKind.Usize
                                                                            1
                                                                        ],
                                                                        []
                                                                      |),
                                                                      [
                                                                        M.borrow (|
                                                                          Pointer.Kind.Ref,
                                                                          M.deref (|
                                                                            M.borrow (|
                                                                              Pointer.Kind.Ref,
                                                                              M.alloc (|
                                                                                Value.Array
                                                                                  [
                                                                                    mk_str (|
                                                                                      "No prior strong references should exist"
                                                                                    |)
                                                                                  ]
                                                                              |)
                                                                            |)
                                                                          |)
                                                                        |)
                                                                      ]
                                                                    |)
                                                                  ]
                                                              ]
                                                            |)
                                                          |)
                                                        |)
                                                      |)
                                                    |)));
                                                fun γ =>
                                                  ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                                              ]
                                            |)))
                                      ]
                                    |) in
                                  M.alloc (| Value.Tuple [] |)));
                              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                            ]
                          |) in
                        let~ _ : Ty.tuple [] :=
                          M.alloc (|
                            M.call_closure (|
                              Ty.tuple [],
                              M.get_associated_function (|
                                Ty.apply (Ty.path "core::cell::Cell") [] [ Ty.path "usize" ],
                                "set",
                                [],
                                []
                              |),
                              [
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.SubPointer.get_struct_record_field (|
                                    M.deref (| M.read (| inner |) |),
                                    "alloc::rc::RcInner",
                                    "strong"
                                  |)
                                |);
                                Value.Integer IntegerKind.Usize 1
                              ]
                            |)
                          |) in
                        let~ alloc : A :=
                          M.copy (|
                            M.SubPointer.get_tuple_field (|
                              M.alloc (|
                                M.call_closure (|
                                  Ty.tuple [ Ty.apply (Ty.path "*const") [] [ T ]; A ],
                                  M.get_associated_function (|
                                    Ty.apply (Ty.path "alloc::rc::Weak") [] [ T; A ],
                                    "into_raw_with_allocator",
                                    [],
                                    []
                                  |),
                                  [ M.read (| weak |) ]
                                |)
                              |),
                              1
                            |)
                          |) in
                        M.alloc (|
                          M.call_closure (|
                            Ty.apply (Ty.path "alloc::rc::Rc") [] [ T; A ],
                            M.get_associated_function (|
                              Ty.apply (Ty.path "alloc::rc::Rc") [] [ T; A ],
                              "from_inner_in",
                              [],
                              []
                            |),
                            [ M.read (| init_ptr |); M.read (| alloc |) ]
                          |)
                        |)
                      |) in
                    strong))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_new_cyclic_in :
      forall (T A : Ty.t),
      M.IsAssociatedFunction.C (Self T A) "new_cyclic_in" (new_cyclic_in T A).
    Admitted.
    Global Typeclasses Opaque new_cyclic_in.
    
    (*
        pub fn try_new_in(value: T, alloc: A) -> Result<Self, AllocError> {
            // There is an implicit weak pointer owned by all the strong
            // pointers, which ensures that the weak destructor never frees
            // the allocation while the strong destructor is running, even
            // if the weak pointer is stored inside the strong one.
            let (ptr, alloc) = Box::into_unique(Box::try_new_in(
                RcInner { strong: Cell::new(1), weak: Cell::new(1), value },
                alloc,
            )?);
            Ok(unsafe { Self::from_inner_in(ptr.into(), alloc) })
        }
    *)
    Definition try_new_in (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ value; alloc ] =>
        ltac:(M.monadic
          (let value := M.alloc (| value |) in
          let alloc := M.alloc (| alloc |) in
          M.catch_return (|
            ltac:(M.monadic
              (M.read (|
                M.match_operator (|
                  None,
                  M.alloc (|
                    M.call_closure (|
                      Ty.tuple
                        [
                          Ty.apply
                            (Ty.path "core::ptr::unique::Unique")
                            []
                            [ Ty.apply (Ty.path "alloc::rc::RcInner") [] [ T ] ];
                          A
                        ],
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "alloc::boxed::Box")
                          []
                          [ Ty.apply (Ty.path "alloc::rc::RcInner") [] [ T ]; A ],
                        "into_unique",
                        [],
                        []
                      |),
                      [
                        M.read (|
                          M.match_operator (|
                            Some
                              (Ty.apply
                                (Ty.path "alloc::boxed::Box")
                                []
                                [ Ty.apply (Ty.path "alloc::rc::RcInner") [] [ T ]; A ]),
                            M.alloc (|
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "core::ops::control_flow::ControlFlow")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [
                                        Ty.path "core::convert::Infallible";
                                        Ty.path "core::alloc::AllocError"
                                      ];
                                    Ty.apply
                                      (Ty.path "alloc::boxed::Box")
                                      []
                                      [ Ty.apply (Ty.path "alloc::rc::RcInner") [] [ T ]; A ]
                                  ],
                                M.get_trait_method (|
                                  "core::ops::try_trait::Try",
                                  Ty.apply
                                    (Ty.path "core::result::Result")
                                    []
                                    [
                                      Ty.apply
                                        (Ty.path "alloc::boxed::Box")
                                        []
                                        [ Ty.apply (Ty.path "alloc::rc::RcInner") [] [ T ]; A ];
                                      Ty.path "core::alloc::AllocError"
                                    ],
                                  [],
                                  [],
                                  "branch",
                                  [],
                                  []
                                |),
                                [
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [
                                        Ty.apply
                                          (Ty.path "alloc::boxed::Box")
                                          []
                                          [ Ty.apply (Ty.path "alloc::rc::RcInner") [] [ T ]; A ];
                                        Ty.path "core::alloc::AllocError"
                                      ],
                                    M.get_associated_function (|
                                      Ty.apply
                                        (Ty.path "alloc::boxed::Box")
                                        []
                                        [ Ty.apply (Ty.path "alloc::rc::RcInner") [] [ T ]; A ],
                                      "try_new_in",
                                      [],
                                      []
                                    |),
                                    [
                                      Value.StructRecord
                                        "alloc::rc::RcInner"
                                        [
                                          ("strong",
                                            M.call_closure (|
                                              Ty.apply
                                                (Ty.path "core::cell::Cell")
                                                []
                                                [ Ty.path "usize" ],
                                              M.get_associated_function (|
                                                Ty.apply
                                                  (Ty.path "core::cell::Cell")
                                                  []
                                                  [ Ty.path "usize" ],
                                                "new",
                                                [],
                                                []
                                              |),
                                              [ Value.Integer IntegerKind.Usize 1 ]
                                            |));
                                          ("weak",
                                            M.call_closure (|
                                              Ty.apply
                                                (Ty.path "core::cell::Cell")
                                                []
                                                [ Ty.path "usize" ],
                                              M.get_associated_function (|
                                                Ty.apply
                                                  (Ty.path "core::cell::Cell")
                                                  []
                                                  [ Ty.path "usize" ],
                                                "new",
                                                [],
                                                []
                                              |),
                                              [ Value.Integer IntegerKind.Usize 1 ]
                                            |));
                                          ("value", M.read (| value |))
                                        ];
                                      M.read (| alloc |)
                                    ]
                                  |)
                                ]
                              |)
                            |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Break",
                                      0
                                    |) in
                                  let residual := M.copy (| γ0_0 |) in
                                  M.alloc (|
                                    M.never_to_any (|
                                      M.read (|
                                        M.return_ (|
                                          M.call_closure (|
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              []
                                              [
                                                Ty.apply (Ty.path "alloc::rc::Rc") [] [ T; A ];
                                                Ty.path "core::alloc::AllocError"
                                              ],
                                            M.get_trait_method (|
                                              "core::ops::try_trait::FromResidual",
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                []
                                                [
                                                  Ty.apply (Ty.path "alloc::rc::Rc") [] [ T; A ];
                                                  Ty.path "core::alloc::AllocError"
                                                ],
                                              [],
                                              [
                                                Ty.apply
                                                  (Ty.path "core::result::Result")
                                                  []
                                                  [
                                                    Ty.path "core::convert::Infallible";
                                                    Ty.path "core::alloc::AllocError"
                                                  ]
                                              ],
                                              "from_residual",
                                              [],
                                              []
                                            |),
                                            [ M.read (| residual |) ]
                                          |)
                                        |)
                                      |)
                                    |)
                                  |)));
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Continue",
                                      0
                                    |) in
                                  let val := M.copy (| γ0_0 |) in
                                  val))
                            ]
                          |)
                        |)
                      ]
                    |)
                  |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                        let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                        let ptr := M.copy (| γ0_0 |) in
                        let alloc := M.copy (| γ0_1 |) in
                        M.alloc (|
                          Value.StructTuple
                            "core::result::Result::Ok"
                            [
                              M.call_closure (|
                                Ty.apply (Ty.path "alloc::rc::Rc") [] [ T; A ],
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "alloc::rc::Rc") [] [ T; A ],
                                  "from_inner_in",
                                  [],
                                  []
                                |),
                                [
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "core::ptr::non_null::NonNull")
                                      []
                                      [ Ty.apply (Ty.path "alloc::rc::RcInner") [] [ T ] ],
                                    M.get_trait_method (|
                                      "core::convert::Into",
                                      Ty.apply
                                        (Ty.path "core::ptr::unique::Unique")
                                        []
                                        [ Ty.apply (Ty.path "alloc::rc::RcInner") [] [ T ] ],
                                      [],
                                      [
                                        Ty.apply
                                          (Ty.path "core::ptr::non_null::NonNull")
                                          []
                                          [ Ty.apply (Ty.path "alloc::rc::RcInner") [] [ T ] ]
                                      ],
                                      "into",
                                      [],
                                      []
                                    |),
                                    [ M.read (| ptr |) ]
                                  |);
                                  M.read (| alloc |)
                                ]
                              |)
                            ]
                        |)))
                  ]
                |)
              |)))
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_try_new_in :
      forall (T A : Ty.t),
      M.IsAssociatedFunction.C (Self T A) "try_new_in" (try_new_in T A).
    Admitted.
    Global Typeclasses Opaque try_new_in.
    
    (*
        pub fn try_new_uninit_in(alloc: A) -> Result<Rc<mem::MaybeUninit<T>, A>, AllocError> {
            unsafe {
                Ok(Rc::from_ptr_in(
                    Rc::try_allocate_for_layout(
                        Layout::new::<T>(),
                        |layout| alloc.allocate(layout),
                        <*mut u8>::cast,
                    )?,
                    alloc,
                ))
            }
        }
    *)
    Definition try_new_uninit_in
        (T A : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ alloc ] =>
        ltac:(M.monadic
          (let alloc := M.alloc (| alloc |) in
          M.catch_return (|
            ltac:(M.monadic
              (Value.StructTuple
                "core::result::Result::Ok"
                [
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "alloc::rc::Rc")
                      []
                      [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ]; A ],
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "alloc::rc::Rc")
                        []
                        [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ]; A ],
                      "from_ptr_in",
                      [],
                      []
                    |),
                    [
                      M.read (|
                        M.match_operator (|
                          Some
                            (Ty.apply
                              (Ty.path "*mut")
                              []
                              [
                                Ty.apply
                                  (Ty.path "alloc::rc::RcInner")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                      []
                                      [ T ]
                                  ]
                              ]),
                          M.alloc (|
                            M.call_closure (|
                              Ty.apply
                                (Ty.path "core::ops::control_flow::ControlFlow")
                                []
                                [
                                  Ty.apply
                                    (Ty.path "core::result::Result")
                                    []
                                    [
                                      Ty.path "core::convert::Infallible";
                                      Ty.path "core::alloc::AllocError"
                                    ];
                                  Ty.apply
                                    (Ty.path "*mut")
                                    []
                                    [
                                      Ty.apply
                                        (Ty.path "alloc::rc::RcInner")
                                        []
                                        [
                                          Ty.apply
                                            (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                            []
                                            [ T ]
                                        ]
                                    ]
                                ],
                              M.get_trait_method (|
                                "core::ops::try_trait::Try",
                                Ty.apply
                                  (Ty.path "core::result::Result")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "*mut")
                                      []
                                      [
                                        Ty.apply
                                          (Ty.path "alloc::rc::RcInner")
                                          []
                                          [
                                            Ty.apply
                                              (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                              []
                                              [ T ]
                                          ]
                                      ];
                                    Ty.path "core::alloc::AllocError"
                                  ],
                                [],
                                [],
                                "branch",
                                [],
                                []
                              |),
                              [
                                M.call_closure (|
                                  Ty.apply
                                    (Ty.path "core::result::Result")
                                    []
                                    [
                                      Ty.apply
                                        (Ty.path "*mut")
                                        []
                                        [
                                          Ty.apply
                                            (Ty.path "alloc::rc::RcInner")
                                            []
                                            [
                                              Ty.apply
                                                (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                                []
                                                [ T ]
                                            ]
                                        ];
                                      Ty.path "core::alloc::AllocError"
                                    ],
                                  M.get_associated_function (|
                                    Ty.apply
                                      (Ty.path "alloc::rc::Rc")
                                      []
                                      [
                                        Ty.apply
                                          (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                          []
                                          [ T ];
                                        Ty.path "alloc::alloc::Global"
                                      ],
                                    "try_allocate_for_layout",
                                    [],
                                    [
                                      Ty.function
                                        [ Ty.tuple [ Ty.path "core::alloc::layout::Layout" ] ]
                                        (Ty.apply
                                          (Ty.path "core::result::Result")
                                          []
                                          [
                                            Ty.apply
                                              (Ty.path "core::ptr::non_null::NonNull")
                                              []
                                              [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ];
                                            Ty.path "core::alloc::AllocError"
                                          ]);
                                      Ty.function
                                        [ Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ] ]
                                        (Ty.apply
                                          (Ty.path "*mut")
                                          []
                                          [
                                            Ty.apply
                                              (Ty.path "alloc::rc::RcInner")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                                  []
                                                  [ T ]
                                              ]
                                          ])
                                    ]
                                  |),
                                  [
                                    M.call_closure (|
                                      Ty.path "core::alloc::layout::Layout",
                                      M.get_associated_function (|
                                        Ty.path "core::alloc::layout::Layout",
                                        "new",
                                        [],
                                        [ T ]
                                      |),
                                      []
                                    |);
                                    M.closure
                                      (fun γ =>
                                        ltac:(M.monadic
                                          match γ with
                                          | [ α0 ] =>
                                            ltac:(M.monadic
                                              (M.match_operator (|
                                                Some
                                                  (Ty.function
                                                    [
                                                      Ty.tuple
                                                        [ Ty.path "core::alloc::layout::Layout" ]
                                                    ]
                                                    (Ty.apply
                                                      (Ty.path "core::result::Result")
                                                      []
                                                      [
                                                        Ty.apply
                                                          (Ty.path "core::ptr::non_null::NonNull")
                                                          []
                                                          [
                                                            Ty.apply
                                                              (Ty.path "slice")
                                                              []
                                                              [ Ty.path "u8" ]
                                                          ];
                                                        Ty.path "core::alloc::AllocError"
                                                      ])),
                                                M.alloc (| α0 |),
                                                [
                                                  fun γ =>
                                                    ltac:(M.monadic
                                                      (let layout := M.copy (| γ |) in
                                                      M.call_closure (|
                                                        Ty.apply
                                                          (Ty.path "core::result::Result")
                                                          []
                                                          [
                                                            Ty.apply
                                                              (Ty.path
                                                                "core::ptr::non_null::NonNull")
                                                              []
                                                              [
                                                                Ty.apply
                                                                  (Ty.path "slice")
                                                                  []
                                                                  [ Ty.path "u8" ]
                                                              ];
                                                            Ty.path "core::alloc::AllocError"
                                                          ],
                                                        M.get_trait_method (|
                                                          "core::alloc::Allocator",
                                                          A,
                                                          [],
                                                          [],
                                                          "allocate",
                                                          [],
                                                          []
                                                        |),
                                                        [
                                                          M.borrow (| Pointer.Kind.Ref, alloc |);
                                                          M.read (| layout |)
                                                        ]
                                                      |)))
                                                ]
                                              |)))
                                          | _ => M.impossible "wrong number of arguments"
                                          end));
                                    M.get_associated_function (|
                                      Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ],
                                      "cast",
                                      [],
                                      [
                                        Ty.apply
                                          (Ty.path "alloc::rc::RcInner")
                                          []
                                          [
                                            Ty.apply
                                              (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                              []
                                              [ T ]
                                          ]
                                      ]
                                    |)
                                  ]
                                |)
                              ]
                            |)
                          |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ0_0 :=
                                  M.SubPointer.get_struct_tuple_field (|
                                    γ,
                                    "core::ops::control_flow::ControlFlow::Break",
                                    0
                                  |) in
                                let residual := M.copy (| γ0_0 |) in
                                M.alloc (|
                                  M.never_to_any (|
                                    M.read (|
                                      M.return_ (|
                                        M.call_closure (|
                                          Ty.apply
                                            (Ty.path "core::result::Result")
                                            []
                                            [
                                              Ty.apply
                                                (Ty.path "alloc::rc::Rc")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                                    []
                                                    [ T ];
                                                  A
                                                ];
                                              Ty.path "core::alloc::AllocError"
                                            ],
                                          M.get_trait_method (|
                                            "core::ops::try_trait::FromResidual",
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "alloc::rc::Rc")
                                                  []
                                                  [
                                                    Ty.apply
                                                      (Ty.path
                                                        "core::mem::maybe_uninit::MaybeUninit")
                                                      []
                                                      [ T ];
                                                    A
                                                  ];
                                                Ty.path "core::alloc::AllocError"
                                              ],
                                            [],
                                            [
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                []
                                                [
                                                  Ty.path "core::convert::Infallible";
                                                  Ty.path "core::alloc::AllocError"
                                                ]
                                            ],
                                            "from_residual",
                                            [],
                                            []
                                          |),
                                          [ M.read (| residual |) ]
                                        |)
                                      |)
                                    |)
                                  |)
                                |)));
                            fun γ =>
                              ltac:(M.monadic
                                (let γ0_0 :=
                                  M.SubPointer.get_struct_tuple_field (|
                                    γ,
                                    "core::ops::control_flow::ControlFlow::Continue",
                                    0
                                  |) in
                                let val := M.copy (| γ0_0 |) in
                                val))
                          ]
                        |)
                      |);
                      M.read (| alloc |)
                    ]
                  |)
                ]))
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_try_new_uninit_in :
      forall (T A : Ty.t),
      M.IsAssociatedFunction.C (Self T A) "try_new_uninit_in" (try_new_uninit_in T A).
    Admitted.
    Global Typeclasses Opaque try_new_uninit_in.
    
    (*
        pub fn try_new_zeroed_in(alloc: A) -> Result<Rc<mem::MaybeUninit<T>, A>, AllocError> {
            unsafe {
                Ok(Rc::from_ptr_in(
                    Rc::try_allocate_for_layout(
                        Layout::new::<T>(),
                        |layout| alloc.allocate_zeroed(layout),
                        <*mut u8>::cast,
                    )?,
                    alloc,
                ))
            }
        }
    *)
    Definition try_new_zeroed_in
        (T A : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ alloc ] =>
        ltac:(M.monadic
          (let alloc := M.alloc (| alloc |) in
          M.catch_return (|
            ltac:(M.monadic
              (Value.StructTuple
                "core::result::Result::Ok"
                [
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "alloc::rc::Rc")
                      []
                      [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ]; A ],
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "alloc::rc::Rc")
                        []
                        [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ]; A ],
                      "from_ptr_in",
                      [],
                      []
                    |),
                    [
                      M.read (|
                        M.match_operator (|
                          Some
                            (Ty.apply
                              (Ty.path "*mut")
                              []
                              [
                                Ty.apply
                                  (Ty.path "alloc::rc::RcInner")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                      []
                                      [ T ]
                                  ]
                              ]),
                          M.alloc (|
                            M.call_closure (|
                              Ty.apply
                                (Ty.path "core::ops::control_flow::ControlFlow")
                                []
                                [
                                  Ty.apply
                                    (Ty.path "core::result::Result")
                                    []
                                    [
                                      Ty.path "core::convert::Infallible";
                                      Ty.path "core::alloc::AllocError"
                                    ];
                                  Ty.apply
                                    (Ty.path "*mut")
                                    []
                                    [
                                      Ty.apply
                                        (Ty.path "alloc::rc::RcInner")
                                        []
                                        [
                                          Ty.apply
                                            (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                            []
                                            [ T ]
                                        ]
                                    ]
                                ],
                              M.get_trait_method (|
                                "core::ops::try_trait::Try",
                                Ty.apply
                                  (Ty.path "core::result::Result")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "*mut")
                                      []
                                      [
                                        Ty.apply
                                          (Ty.path "alloc::rc::RcInner")
                                          []
                                          [
                                            Ty.apply
                                              (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                              []
                                              [ T ]
                                          ]
                                      ];
                                    Ty.path "core::alloc::AllocError"
                                  ],
                                [],
                                [],
                                "branch",
                                [],
                                []
                              |),
                              [
                                M.call_closure (|
                                  Ty.apply
                                    (Ty.path "core::result::Result")
                                    []
                                    [
                                      Ty.apply
                                        (Ty.path "*mut")
                                        []
                                        [
                                          Ty.apply
                                            (Ty.path "alloc::rc::RcInner")
                                            []
                                            [
                                              Ty.apply
                                                (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                                []
                                                [ T ]
                                            ]
                                        ];
                                      Ty.path "core::alloc::AllocError"
                                    ],
                                  M.get_associated_function (|
                                    Ty.apply
                                      (Ty.path "alloc::rc::Rc")
                                      []
                                      [
                                        Ty.apply
                                          (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                          []
                                          [ T ];
                                        Ty.path "alloc::alloc::Global"
                                      ],
                                    "try_allocate_for_layout",
                                    [],
                                    [
                                      Ty.function
                                        [ Ty.tuple [ Ty.path "core::alloc::layout::Layout" ] ]
                                        (Ty.apply
                                          (Ty.path "core::result::Result")
                                          []
                                          [
                                            Ty.apply
                                              (Ty.path "core::ptr::non_null::NonNull")
                                              []
                                              [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ];
                                            Ty.path "core::alloc::AllocError"
                                          ]);
                                      Ty.function
                                        [ Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ] ]
                                        (Ty.apply
                                          (Ty.path "*mut")
                                          []
                                          [
                                            Ty.apply
                                              (Ty.path "alloc::rc::RcInner")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                                  []
                                                  [ T ]
                                              ]
                                          ])
                                    ]
                                  |),
                                  [
                                    M.call_closure (|
                                      Ty.path "core::alloc::layout::Layout",
                                      M.get_associated_function (|
                                        Ty.path "core::alloc::layout::Layout",
                                        "new",
                                        [],
                                        [ T ]
                                      |),
                                      []
                                    |);
                                    M.closure
                                      (fun γ =>
                                        ltac:(M.monadic
                                          match γ with
                                          | [ α0 ] =>
                                            ltac:(M.monadic
                                              (M.match_operator (|
                                                Some
                                                  (Ty.function
                                                    [
                                                      Ty.tuple
                                                        [ Ty.path "core::alloc::layout::Layout" ]
                                                    ]
                                                    (Ty.apply
                                                      (Ty.path "core::result::Result")
                                                      []
                                                      [
                                                        Ty.apply
                                                          (Ty.path "core::ptr::non_null::NonNull")
                                                          []
                                                          [
                                                            Ty.apply
                                                              (Ty.path "slice")
                                                              []
                                                              [ Ty.path "u8" ]
                                                          ];
                                                        Ty.path "core::alloc::AllocError"
                                                      ])),
                                                M.alloc (| α0 |),
                                                [
                                                  fun γ =>
                                                    ltac:(M.monadic
                                                      (let layout := M.copy (| γ |) in
                                                      M.call_closure (|
                                                        Ty.apply
                                                          (Ty.path "core::result::Result")
                                                          []
                                                          [
                                                            Ty.apply
                                                              (Ty.path
                                                                "core::ptr::non_null::NonNull")
                                                              []
                                                              [
                                                                Ty.apply
                                                                  (Ty.path "slice")
                                                                  []
                                                                  [ Ty.path "u8" ]
                                                              ];
                                                            Ty.path "core::alloc::AllocError"
                                                          ],
                                                        M.get_trait_method (|
                                                          "core::alloc::Allocator",
                                                          A,
                                                          [],
                                                          [],
                                                          "allocate_zeroed",
                                                          [],
                                                          []
                                                        |),
                                                        [
                                                          M.borrow (| Pointer.Kind.Ref, alloc |);
                                                          M.read (| layout |)
                                                        ]
                                                      |)))
                                                ]
                                              |)))
                                          | _ => M.impossible "wrong number of arguments"
                                          end));
                                    M.get_associated_function (|
                                      Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ],
                                      "cast",
                                      [],
                                      [
                                        Ty.apply
                                          (Ty.path "alloc::rc::RcInner")
                                          []
                                          [
                                            Ty.apply
                                              (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                              []
                                              [ T ]
                                          ]
                                      ]
                                    |)
                                  ]
                                |)
                              ]
                            |)
                          |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ0_0 :=
                                  M.SubPointer.get_struct_tuple_field (|
                                    γ,
                                    "core::ops::control_flow::ControlFlow::Break",
                                    0
                                  |) in
                                let residual := M.copy (| γ0_0 |) in
                                M.alloc (|
                                  M.never_to_any (|
                                    M.read (|
                                      M.return_ (|
                                        M.call_closure (|
                                          Ty.apply
                                            (Ty.path "core::result::Result")
                                            []
                                            [
                                              Ty.apply
                                                (Ty.path "alloc::rc::Rc")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                                    []
                                                    [ T ];
                                                  A
                                                ];
                                              Ty.path "core::alloc::AllocError"
                                            ],
                                          M.get_trait_method (|
                                            "core::ops::try_trait::FromResidual",
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "alloc::rc::Rc")
                                                  []
                                                  [
                                                    Ty.apply
                                                      (Ty.path
                                                        "core::mem::maybe_uninit::MaybeUninit")
                                                      []
                                                      [ T ];
                                                    A
                                                  ];
                                                Ty.path "core::alloc::AllocError"
                                              ],
                                            [],
                                            [
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                []
                                                [
                                                  Ty.path "core::convert::Infallible";
                                                  Ty.path "core::alloc::AllocError"
                                                ]
                                            ],
                                            "from_residual",
                                            [],
                                            []
                                          |),
                                          [ M.read (| residual |) ]
                                        |)
                                      |)
                                    |)
                                  |)
                                |)));
                            fun γ =>
                              ltac:(M.monadic
                                (let γ0_0 :=
                                  M.SubPointer.get_struct_tuple_field (|
                                    γ,
                                    "core::ops::control_flow::ControlFlow::Continue",
                                    0
                                  |) in
                                let val := M.copy (| γ0_0 |) in
                                val))
                          ]
                        |)
                      |);
                      M.read (| alloc |)
                    ]
                  |)
                ]))
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_try_new_zeroed_in :
      forall (T A : Ty.t),
      M.IsAssociatedFunction.C (Self T A) "try_new_zeroed_in" (try_new_zeroed_in T A).
    Admitted.
    Global Typeclasses Opaque try_new_zeroed_in.
    
    (*
        pub fn pin_in(value: T, alloc: A) -> Pin<Self>
        where
            A: 'static,
        {
            unsafe { Pin::new_unchecked(Rc::new_in(value, alloc)) }
        }
    *)
    Definition pin_in (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ value; alloc ] =>
        ltac:(M.monadic
          (let value := M.alloc (| value |) in
          let alloc := M.alloc (| alloc |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "core::pin::Pin")
              []
              [ Ty.apply (Ty.path "alloc::rc::Rc") [] [ T; A ] ],
            M.get_associated_function (|
              Ty.apply
                (Ty.path "core::pin::Pin")
                []
                [ Ty.apply (Ty.path "alloc::rc::Rc") [] [ T; A ] ],
              "new_unchecked",
              [],
              []
            |),
            [
              M.call_closure (|
                Ty.apply (Ty.path "alloc::rc::Rc") [] [ T; A ],
                M.get_associated_function (|
                  Ty.apply (Ty.path "alloc::rc::Rc") [] [ T; A ],
                  "new_in",
                  [],
                  []
                |),
                [ M.read (| value |); M.read (| alloc |) ]
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_pin_in :
      forall (T A : Ty.t),
      M.IsAssociatedFunction.C (Self T A) "pin_in" (pin_in T A).
    Admitted.
    Global Typeclasses Opaque pin_in.
    
    (*
        pub fn try_unwrap(this: Self) -> Result<T, Self> {
            if Rc::strong_count(&this) == 1 {
                let this = ManuallyDrop::new(this);
    
                let val: T = unsafe { ptr::read(&**this) }; // copy the contained object
                let alloc: A = unsafe { ptr::read(&this.alloc) }; // copy the allocator
    
                // Indicate to Weaks that they can't be promoted by decrementing
                // the strong count, and then remove the implicit "strong weak"
                // pointer while also handling drop logic by just crafting a
                // fake Weak.
                this.inner().dec_strong();
                let _weak = Weak { ptr: this.ptr, alloc };
                Ok(val)
            } else {
                Err(this)
            }
        }
    *)
    Definition try_unwrap (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ this ] =>
        ltac:(M.monadic
          (let this := M.alloc (| this |) in
          M.read (|
            M.match_operator (|
              Some
                (Ty.apply
                  (Ty.path "core::result::Result")
                  []
                  [ T; Ty.apply (Ty.path "alloc::rc::Rc") [] [ T; A ] ]),
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          BinOp.eq (|
                            M.call_closure (|
                              Ty.path "usize",
                              M.get_associated_function (|
                                Ty.apply (Ty.path "alloc::rc::Rc") [] [ T; A ],
                                "strong_count",
                                [],
                                []
                              |),
                              [
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.deref (| M.borrow (| Pointer.Kind.Ref, this |) |)
                                |)
                              ]
                            |),
                            Value.Integer IntegerKind.Usize 1
                          |)
                        |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    let~ this :
                        Ty.apply
                          (Ty.path "core::mem::manually_drop::ManuallyDrop")
                          []
                          [ Ty.apply (Ty.path "alloc::rc::Rc") [] [ T; A ] ] :=
                      M.alloc (|
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "core::mem::manually_drop::ManuallyDrop")
                            []
                            [ Ty.apply (Ty.path "alloc::rc::Rc") [] [ T; A ] ],
                          M.get_associated_function (|
                            Ty.apply
                              (Ty.path "core::mem::manually_drop::ManuallyDrop")
                              []
                              [ Ty.apply (Ty.path "alloc::rc::Rc") [] [ T; A ] ],
                            "new",
                            [],
                            []
                          |),
                          [ M.read (| this |) ]
                        |)
                      |) in
                    let~ val : T :=
                      M.alloc (|
                        M.call_closure (|
                          T,
                          M.get_function (| "core::ptr::read", [], [ T ] |),
                          [
                            M.borrow (|
                              Pointer.Kind.ConstPointer,
                              M.deref (|
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.deref (|
                                    M.call_closure (|
                                      Ty.apply (Ty.path "&") [] [ T ],
                                      M.get_trait_method (|
                                        "core::ops::deref::Deref",
                                        Ty.apply (Ty.path "alloc::rc::Rc") [] [ T; A ],
                                        [],
                                        [],
                                        "deref",
                                        [],
                                        []
                                      |),
                                      [
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.deref (|
                                            M.call_closure (|
                                              Ty.apply
                                                (Ty.path "&")
                                                []
                                                [ Ty.apply (Ty.path "alloc::rc::Rc") [] [ T; A ] ],
                                              M.get_trait_method (|
                                                "core::ops::deref::Deref",
                                                Ty.apply
                                                  (Ty.path "core::mem::manually_drop::ManuallyDrop")
                                                  []
                                                  [ Ty.apply (Ty.path "alloc::rc::Rc") [] [ T; A ]
                                                  ],
                                                [],
                                                [],
                                                "deref",
                                                [],
                                                []
                                              |),
                                              [ M.borrow (| Pointer.Kind.Ref, this |) ]
                                            |)
                                          |)
                                        |)
                                      ]
                                    |)
                                  |)
                                |)
                              |)
                            |)
                          ]
                        |)
                      |) in
                    let~ alloc : A :=
                      M.alloc (|
                        M.call_closure (|
                          A,
                          M.get_function (| "core::ptr::read", [], [ A ] |),
                          [
                            M.borrow (|
                              Pointer.Kind.ConstPointer,
                              M.deref (|
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.SubPointer.get_struct_record_field (|
                                    M.deref (|
                                      M.call_closure (|
                                        Ty.apply
                                          (Ty.path "&")
                                          []
                                          [ Ty.apply (Ty.path "alloc::rc::Rc") [] [ T; A ] ],
                                        M.get_trait_method (|
                                          "core::ops::deref::Deref",
                                          Ty.apply
                                            (Ty.path "core::mem::manually_drop::ManuallyDrop")
                                            []
                                            [ Ty.apply (Ty.path "alloc::rc::Rc") [] [ T; A ] ],
                                          [],
                                          [],
                                          "deref",
                                          [],
                                          []
                                        |),
                                        [ M.borrow (| Pointer.Kind.Ref, this |) ]
                                      |)
                                    |),
                                    "alloc::rc::Rc",
                                    "alloc"
                                  |)
                                |)
                              |)
                            |)
                          ]
                        |)
                      |) in
                    let~ _ : Ty.tuple [] :=
                      M.alloc (|
                        M.call_closure (|
                          Ty.tuple [],
                          M.get_trait_method (|
                            "alloc::rc::RcInnerPtr",
                            Ty.apply (Ty.path "alloc::rc::RcInner") [] [ T ],
                            [],
                            [],
                            "dec_strong",
                            [],
                            []
                          |),
                          [
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.deref (|
                                M.call_closure (|
                                  Ty.apply
                                    (Ty.path "&")
                                    []
                                    [ Ty.apply (Ty.path "alloc::rc::RcInner") [] [ T ] ],
                                  M.get_associated_function (|
                                    Ty.apply (Ty.path "alloc::rc::Rc") [] [ T; A ],
                                    "inner",
                                    [],
                                    []
                                  |),
                                  [
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.deref (|
                                        M.call_closure (|
                                          Ty.apply
                                            (Ty.path "&")
                                            []
                                            [ Ty.apply (Ty.path "alloc::rc::Rc") [] [ T; A ] ],
                                          M.get_trait_method (|
                                            "core::ops::deref::Deref",
                                            Ty.apply
                                              (Ty.path "core::mem::manually_drop::ManuallyDrop")
                                              []
                                              [ Ty.apply (Ty.path "alloc::rc::Rc") [] [ T; A ] ],
                                            [],
                                            [],
                                            "deref",
                                            [],
                                            []
                                          |),
                                          [ M.borrow (| Pointer.Kind.Ref, this |) ]
                                        |)
                                      |)
                                    |)
                                  ]
                                |)
                              |)
                            |)
                          ]
                        |)
                      |) in
                    let~ _weak : Ty.apply (Ty.path "alloc::rc::Weak") [] [ T; A ] :=
                      M.alloc (|
                        Value.StructRecord
                          "alloc::rc::Weak"
                          [
                            ("ptr",
                              M.read (|
                                M.SubPointer.get_struct_record_field (|
                                  M.deref (|
                                    M.call_closure (|
                                      Ty.apply
                                        (Ty.path "&")
                                        []
                                        [ Ty.apply (Ty.path "alloc::rc::Rc") [] [ T; A ] ],
                                      M.get_trait_method (|
                                        "core::ops::deref::Deref",
                                        Ty.apply
                                          (Ty.path "core::mem::manually_drop::ManuallyDrop")
                                          []
                                          [ Ty.apply (Ty.path "alloc::rc::Rc") [] [ T; A ] ],
                                        [],
                                        [],
                                        "deref",
                                        [],
                                        []
                                      |),
                                      [ M.borrow (| Pointer.Kind.Ref, this |) ]
                                    |)
                                  |),
                                  "alloc::rc::Rc",
                                  "ptr"
                                |)
                              |));
                            ("alloc", M.read (| alloc |))
                          ]
                      |) in
                    M.alloc (|
                      Value.StructTuple "core::result::Result::Ok" [ M.read (| val |) ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      Value.StructTuple "core::result::Result::Err" [ M.read (| this |) ]
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_try_unwrap :
      forall (T A : Ty.t),
      M.IsAssociatedFunction.C (Self T A) "try_unwrap" (try_unwrap T A).
    Admitted.
    Global Typeclasses Opaque try_unwrap.
    
    (*
        pub fn into_inner(this: Self) -> Option<T> {
            Rc::try_unwrap(this).ok()
        }
    *)
    Definition into_inner (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ this ] =>
        ltac:(M.monadic
          (let this := M.alloc (| this |) in
          M.call_closure (|
            Ty.apply (Ty.path "core::option::Option") [] [ T ],
            M.get_associated_function (|
              Ty.apply
                (Ty.path "core::result::Result")
                []
                [ T; Ty.apply (Ty.path "alloc::rc::Rc") [] [ T; A ] ],
              "ok",
              [],
              []
            |),
            [
              M.call_closure (|
                Ty.apply
                  (Ty.path "core::result::Result")
                  []
                  [ T; Ty.apply (Ty.path "alloc::rc::Rc") [] [ T; A ] ],
                M.get_associated_function (|
                  Ty.apply (Ty.path "alloc::rc::Rc") [] [ T; A ],
                  "try_unwrap",
                  [],
                  []
                |),
                [ M.read (| this |) ]
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_into_inner :
      forall (T A : Ty.t),
      M.IsAssociatedFunction.C (Self T A) "into_inner" (into_inner T A).
    Admitted.
    Global Typeclasses Opaque into_inner.
    (*
        pub fn allocator(this: &Self) -> &A {
            &this.alloc
        }
    *)
    Definition allocator (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ this ] =>
        ltac:(M.monadic
          (let this := M.alloc (| this |) in
          M.borrow (|
            Pointer.Kind.Ref,
            M.deref (|
              M.borrow (|
                Pointer.Kind.Ref,
                M.SubPointer.get_struct_record_field (|
                  M.deref (| M.read (| this |) |),
                  "alloc::rc::Rc",
                  "alloc"
                |)
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_allocator :
      forall (T A : Ty.t),
      M.IsAssociatedFunction.C (Self T A) "allocator" (allocator T A).
    Admitted.
    Global Typeclasses Opaque allocator.
    
    (*
        pub fn into_raw(this: Self) -> *const T {
            let this = ManuallyDrop::new(this);
            Self::as_ptr(&*this)
        }
    *)
    Definition into_raw (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ this ] =>
        ltac:(M.monadic
          (let this := M.alloc (| this |) in
          M.read (|
            let~ this :
                Ty.apply
                  (Ty.path "core::mem::manually_drop::ManuallyDrop")
                  []
                  [ Ty.apply (Ty.path "alloc::rc::Rc") [] [ T; A ] ] :=
              M.alloc (|
                M.call_closure (|
                  Ty.apply
                    (Ty.path "core::mem::manually_drop::ManuallyDrop")
                    []
                    [ Ty.apply (Ty.path "alloc::rc::Rc") [] [ T; A ] ],
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "core::mem::manually_drop::ManuallyDrop")
                      []
                      [ Ty.apply (Ty.path "alloc::rc::Rc") [] [ T; A ] ],
                    "new",
                    [],
                    []
                  |),
                  [ M.read (| this |) ]
                |)
              |) in
            M.alloc (|
              M.call_closure (|
                Ty.apply (Ty.path "*const") [] [ T ],
                M.get_associated_function (|
                  Ty.apply (Ty.path "alloc::rc::Rc") [] [ T; A ],
                  "as_ptr",
                  [],
                  []
                |),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.deref (|
                          M.call_closure (|
                            Ty.apply
                              (Ty.path "&")
                              []
                              [ Ty.apply (Ty.path "alloc::rc::Rc") [] [ T; A ] ],
                            M.get_trait_method (|
                              "core::ops::deref::Deref",
                              Ty.apply
                                (Ty.path "core::mem::manually_drop::ManuallyDrop")
                                []
                                [ Ty.apply (Ty.path "alloc::rc::Rc") [] [ T; A ] ],
                              [],
                              [],
                              "deref",
                              [],
                              []
                            |),
                            [ M.borrow (| Pointer.Kind.Ref, this |) ]
                          |)
                        |)
                      |)
                    |)
                  |)
                ]
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_into_raw :
      forall (T A : Ty.t),
      M.IsAssociatedFunction.C (Self T A) "into_raw" (into_raw T A).
    Admitted.
    Global Typeclasses Opaque into_raw.
    
    (*
        pub fn into_raw_with_allocator(this: Self) -> ( *const T, A) {
            let this = mem::ManuallyDrop::new(this);
            let ptr = Self::as_ptr(&this);
            // Safety: `this` is ManuallyDrop so the allocator will not be double-dropped
            let alloc = unsafe { ptr::read(&this.alloc) };
            (ptr, alloc)
        }
    *)
    Definition into_raw_with_allocator
        (T A : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ this ] =>
        ltac:(M.monadic
          (let this := M.alloc (| this |) in
          M.read (|
            let~ this :
                Ty.apply
                  (Ty.path "core::mem::manually_drop::ManuallyDrop")
                  []
                  [ Ty.apply (Ty.path "alloc::rc::Rc") [] [ T; A ] ] :=
              M.alloc (|
                M.call_closure (|
                  Ty.apply
                    (Ty.path "core::mem::manually_drop::ManuallyDrop")
                    []
                    [ Ty.apply (Ty.path "alloc::rc::Rc") [] [ T; A ] ],
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "core::mem::manually_drop::ManuallyDrop")
                      []
                      [ Ty.apply (Ty.path "alloc::rc::Rc") [] [ T; A ] ],
                    "new",
                    [],
                    []
                  |),
                  [ M.read (| this |) ]
                |)
              |) in
            let~ ptr : Ty.apply (Ty.path "*const") [] [ T ] :=
              M.alloc (|
                M.call_closure (|
                  Ty.apply (Ty.path "*const") [] [ T ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "alloc::rc::Rc") [] [ T; A ],
                    "as_ptr",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "&")
                            []
                            [ Ty.apply (Ty.path "alloc::rc::Rc") [] [ T; A ] ],
                          M.get_trait_method (|
                            "core::ops::deref::Deref",
                            Ty.apply
                              (Ty.path "core::mem::manually_drop::ManuallyDrop")
                              []
                              [ Ty.apply (Ty.path "alloc::rc::Rc") [] [ T; A ] ],
                            [],
                            [],
                            "deref",
                            [],
                            []
                          |),
                          [
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.deref (| M.borrow (| Pointer.Kind.Ref, this |) |)
                            |)
                          ]
                        |)
                      |)
                    |)
                  ]
                |)
              |) in
            let~ alloc : A :=
              M.alloc (|
                M.call_closure (|
                  A,
                  M.get_function (| "core::ptr::read", [], [ A ] |),
                  [
                    M.borrow (|
                      Pointer.Kind.ConstPointer,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (|
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "&")
                                  []
                                  [ Ty.apply (Ty.path "alloc::rc::Rc") [] [ T; A ] ],
                                M.get_trait_method (|
                                  "core::ops::deref::Deref",
                                  Ty.apply
                                    (Ty.path "core::mem::manually_drop::ManuallyDrop")
                                    []
                                    [ Ty.apply (Ty.path "alloc::rc::Rc") [] [ T; A ] ],
                                  [],
                                  [],
                                  "deref",
                                  [],
                                  []
                                |),
                                [ M.borrow (| Pointer.Kind.Ref, this |) ]
                              |)
                            |),
                            "alloc::rc::Rc",
                            "alloc"
                          |)
                        |)
                      |)
                    |)
                  ]
                |)
              |) in
            M.alloc (| Value.Tuple [ M.read (| ptr |); M.read (| alloc |) ] |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_into_raw_with_allocator :
      forall (T A : Ty.t),
      M.IsAssociatedFunction.C (Self T A) "into_raw_with_allocator" (into_raw_with_allocator T A).
    Admitted.
    Global Typeclasses Opaque into_raw_with_allocator.
    
    (*
        pub fn as_ptr(this: &Self) -> *const T {
            let ptr: *mut RcInner<T> = NonNull::as_ptr(this.ptr);
    
            // SAFETY: This cannot go through Deref::deref or Rc::inner because
            // this is required to retain raw/mut provenance such that e.g. `get_mut` can
            // write through the pointer after the Rc is recovered through `from_raw`.
            unsafe { &raw mut ( *ptr).value }
        }
    *)
    Definition as_ptr (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ this ] =>
        ltac:(M.monadic
          (let this := M.alloc (| this |) in
          M.read (|
            let~ ptr :
                Ty.apply (Ty.path "*mut") [] [ Ty.apply (Ty.path "alloc::rc::RcInner") [] [ T ] ] :=
              M.alloc (|
                M.call_closure (|
                  Ty.apply (Ty.path "*mut") [] [ Ty.apply (Ty.path "alloc::rc::RcInner") [] [ T ] ],
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "core::ptr::non_null::NonNull")
                      []
                      [ Ty.apply (Ty.path "alloc::rc::RcInner") [] [ T ] ],
                    "as_ptr",
                    [],
                    []
                  |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| this |) |),
                        "alloc::rc::Rc",
                        "ptr"
                      |)
                    |)
                  ]
                |)
              |) in
            M.alloc (|
              (* MutToConstPointer *)
              M.pointer_coercion
                (M.borrow (|
                  Pointer.Kind.MutPointer,
                  M.SubPointer.get_struct_record_field (|
                    M.deref (| M.read (| ptr |) |),
                    "alloc::rc::RcInner",
                    "value"
                  |)
                |))
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_as_ptr :
      forall (T A : Ty.t),
      M.IsAssociatedFunction.C (Self T A) "as_ptr" (as_ptr T A).
    Admitted.
    Global Typeclasses Opaque as_ptr.
    
    (*
        pub unsafe fn from_raw_in(ptr: *const T, alloc: A) -> Self {
            let offset = unsafe { data_offset(ptr) };
    
            // Reverse the offset to find the original RcInner.
            let rc_ptr = unsafe { ptr.byte_sub(offset) as *mut RcInner<T> };
    
            unsafe { Self::from_ptr_in(rc_ptr, alloc) }
        }
    *)
    Definition from_raw_in (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ ptr; alloc ] =>
        ltac:(M.monadic
          (let ptr := M.alloc (| ptr |) in
          let alloc := M.alloc (| alloc |) in
          M.read (|
            let~ offset : Ty.path "usize" :=
              M.alloc (|
                M.call_closure (|
                  Ty.path "usize",
                  M.get_function (| "alloc::rc::data_offset", [], [ T ] |),
                  [ M.read (| ptr |) ]
                |)
              |) in
            let~ rc_ptr :
                Ty.apply (Ty.path "*mut") [] [ Ty.apply (Ty.path "alloc::rc::RcInner") [] [ T ] ] :=
              M.alloc (|
                M.cast
                  (Ty.apply
                    (Ty.path "*mut")
                    []
                    [ Ty.apply (Ty.path "alloc::rc::RcInner") [] [ T ] ])
                  (M.call_closure (|
                    Ty.apply (Ty.path "*const") [] [ T ],
                    M.get_associated_function (|
                      Ty.apply (Ty.path "*const") [] [ T ],
                      "byte_sub",
                      [],
                      []
                    |),
                    [ M.read (| ptr |); M.read (| offset |) ]
                  |))
              |) in
            M.alloc (|
              M.call_closure (|
                Ty.apply (Ty.path "alloc::rc::Rc") [] [ T; A ],
                M.get_associated_function (|
                  Ty.apply (Ty.path "alloc::rc::Rc") [] [ T; A ],
                  "from_ptr_in",
                  [],
                  []
                |),
                [ M.read (| rc_ptr |); M.read (| alloc |) ]
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_from_raw_in :
      forall (T A : Ty.t),
      M.IsAssociatedFunction.C (Self T A) "from_raw_in" (from_raw_in T A).
    Admitted.
    Global Typeclasses Opaque from_raw_in.
    
    (*
        pub fn downgrade(this: &Self) -> Weak<T, A>
        where
            A: Clone,
        {
            this.inner().inc_weak();
            // Make sure we do not create a dangling Weak
            debug_assert!(!is_dangling(this.ptr.as_ptr()));
            Weak { ptr: this.ptr, alloc: this.alloc.clone() }
        }
    *)
    Definition downgrade (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ this ] =>
        ltac:(M.monadic
          (let this := M.alloc (| this |) in
          M.read (|
            let~ _ : Ty.tuple [] :=
              M.alloc (|
                M.call_closure (|
                  Ty.tuple [],
                  M.get_trait_method (|
                    "alloc::rc::RcInnerPtr",
                    Ty.apply (Ty.path "alloc::rc::RcInner") [] [ T ],
                    [],
                    [],
                    "inc_weak",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "&")
                            []
                            [ Ty.apply (Ty.path "alloc::rc::RcInner") [] [ T ] ],
                          M.get_associated_function (|
                            Ty.apply (Ty.path "alloc::rc::Rc") [] [ T; A ],
                            "inner",
                            [],
                            []
                          |),
                          [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| this |) |) |) ]
                        |)
                      |)
                    |)
                  ]
                |)
              |) in
            let~ _ : Ty.tuple [] :=
              M.match_operator (|
                Some (Ty.tuple []),
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.use (M.alloc (| Value.Bool true |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      let~ _ : Ty.tuple [] :=
                        M.match_operator (|
                          Some (Ty.tuple []),
                          M.alloc (| Value.Tuple [] |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ :=
                                  M.use
                                    (M.alloc (|
                                      UnOp.not (|
                                        UnOp.not (|
                                          M.call_closure (|
                                            Ty.path "bool",
                                            M.get_function (|
                                              "alloc::rc::is_dangling",
                                              [],
                                              [ Ty.apply (Ty.path "alloc::rc::RcInner") [] [ T ] ]
                                            |),
                                            [
                                              (* MutToConstPointer *)
                                              M.pointer_coercion
                                                (M.call_closure (|
                                                  Ty.apply
                                                    (Ty.path "*mut")
                                                    []
                                                    [
                                                      Ty.apply
                                                        (Ty.path "alloc::rc::RcInner")
                                                        []
                                                        [ T ]
                                                    ],
                                                  M.get_associated_function (|
                                                    Ty.apply
                                                      (Ty.path "core::ptr::non_null::NonNull")
                                                      []
                                                      [
                                                        Ty.apply
                                                          (Ty.path "alloc::rc::RcInner")
                                                          []
                                                          [ T ]
                                                      ],
                                                    "as_ptr",
                                                    [],
                                                    []
                                                  |),
                                                  [
                                                    M.read (|
                                                      M.SubPointer.get_struct_record_field (|
                                                        M.deref (| M.read (| this |) |),
                                                        "alloc::rc::Rc",
                                                        "ptr"
                                                      |)
                                                    |)
                                                  ]
                                                |))
                                            ]
                                          |)
                                        |)
                                      |)
                                    |)) in
                                let _ :=
                                  M.is_constant_or_break_match (|
                                    M.read (| γ |),
                                    Value.Bool true
                                  |) in
                                M.alloc (|
                                  M.never_to_any (|
                                    M.call_closure (|
                                      Ty.path "never",
                                      M.get_function (| "core::panicking::panic", [], [] |),
                                      [
                                        mk_str (|
                                          "assertion failed: !is_dangling(this.ptr.as_ptr())"
                                        |)
                                      ]
                                    |)
                                  |)
                                |)));
                            fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                          ]
                        |) in
                      M.alloc (| Value.Tuple [] |)));
                  fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                ]
              |) in
            M.alloc (|
              Value.StructRecord
                "alloc::rc::Weak"
                [
                  ("ptr",
                    M.read (|
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| this |) |),
                        "alloc::rc::Rc",
                        "ptr"
                      |)
                    |));
                  ("alloc",
                    M.call_closure (|
                      A,
                      M.get_trait_method (| "core::clone::Clone", A, [], [], "clone", [], [] |),
                      [
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| this |) |),
                            "alloc::rc::Rc",
                            "alloc"
                          |)
                        |)
                      ]
                    |))
                ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_downgrade :
      forall (T A : Ty.t),
      M.IsAssociatedFunction.C (Self T A) "downgrade" (downgrade T A).
    Admitted.
    Global Typeclasses Opaque downgrade.
    
    (*
        pub fn weak_count(this: &Self) -> usize {
            this.inner().weak() - 1
        }
    *)
    Definition weak_count (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ this ] =>
        ltac:(M.monadic
          (let this := M.alloc (| this |) in
          BinOp.Wrap.sub (|
            M.call_closure (|
              Ty.path "usize",
              M.get_trait_method (|
                "alloc::rc::RcInnerPtr",
                Ty.apply (Ty.path "alloc::rc::RcInner") [] [ T ],
                [],
                [],
                "weak",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "&")
                        []
                        [ Ty.apply (Ty.path "alloc::rc::RcInner") [] [ T ] ],
                      M.get_associated_function (|
                        Ty.apply (Ty.path "alloc::rc::Rc") [] [ T; A ],
                        "inner",
                        [],
                        []
                      |),
                      [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| this |) |) |) ]
                    |)
                  |)
                |)
              ]
            |),
            Value.Integer IntegerKind.Usize 1
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_weak_count :
      forall (T A : Ty.t),
      M.IsAssociatedFunction.C (Self T A) "weak_count" (weak_count T A).
    Admitted.
    Global Typeclasses Opaque weak_count.
    
    (*
        pub fn strong_count(this: &Self) -> usize {
            this.inner().strong()
        }
    *)
    Definition strong_count
        (T A : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ this ] =>
        ltac:(M.monadic
          (let this := M.alloc (| this |) in
          M.call_closure (|
            Ty.path "usize",
            M.get_trait_method (|
              "alloc::rc::RcInnerPtr",
              Ty.apply (Ty.path "alloc::rc::RcInner") [] [ T ],
              [],
              [],
              "strong",
              [],
              []
            |),
            [
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.call_closure (|
                    Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "alloc::rc::RcInner") [] [ T ] ],
                    M.get_associated_function (|
                      Ty.apply (Ty.path "alloc::rc::Rc") [] [ T; A ],
                      "inner",
                      [],
                      []
                    |),
                    [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| this |) |) |) ]
                  |)
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_strong_count :
      forall (T A : Ty.t),
      M.IsAssociatedFunction.C (Self T A) "strong_count" (strong_count T A).
    Admitted.
    Global Typeclasses Opaque strong_count.
    
    (*
        pub unsafe fn increment_strong_count_in(ptr: *const T, alloc: A)
        where
            A: Clone,
        {
            // Retain Rc, but don't touch refcount by wrapping in ManuallyDrop
            let rc = unsafe { mem::ManuallyDrop::new(Rc::<T, A>::from_raw_in(ptr, alloc)) };
            // Now increase refcount, but don't drop new refcount either
            let _rc_clone: mem::ManuallyDrop<_> = rc.clone();
        }
    *)
    Definition increment_strong_count_in
        (T A : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ ptr; alloc ] =>
        ltac:(M.monadic
          (let ptr := M.alloc (| ptr |) in
          let alloc := M.alloc (| alloc |) in
          M.read (|
            let~ rc :
                Ty.apply
                  (Ty.path "core::mem::manually_drop::ManuallyDrop")
                  []
                  [ Ty.apply (Ty.path "alloc::rc::Rc") [] [ T; A ] ] :=
              M.alloc (|
                M.call_closure (|
                  Ty.apply
                    (Ty.path "core::mem::manually_drop::ManuallyDrop")
                    []
                    [ Ty.apply (Ty.path "alloc::rc::Rc") [] [ T; A ] ],
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "core::mem::manually_drop::ManuallyDrop")
                      []
                      [ Ty.apply (Ty.path "alloc::rc::Rc") [] [ T; A ] ],
                    "new",
                    [],
                    []
                  |),
                  [
                    M.call_closure (|
                      Ty.apply (Ty.path "alloc::rc::Rc") [] [ T; A ],
                      M.get_associated_function (|
                        Ty.apply (Ty.path "alloc::rc::Rc") [] [ T; A ],
                        "from_raw_in",
                        [],
                        []
                      |),
                      [ M.read (| ptr |); M.read (| alloc |) ]
                    |)
                  ]
                |)
              |) in
            let~ _rc_clone :
                Ty.apply
                  (Ty.path "core::mem::manually_drop::ManuallyDrop")
                  []
                  [ Ty.apply (Ty.path "alloc::rc::Rc") [] [ T; A ] ] :=
              M.alloc (|
                M.call_closure (|
                  Ty.apply
                    (Ty.path "core::mem::manually_drop::ManuallyDrop")
                    []
                    [ Ty.apply (Ty.path "alloc::rc::Rc") [] [ T; A ] ],
                  M.get_trait_method (|
                    "core::clone::Clone",
                    Ty.apply
                      (Ty.path "core::mem::manually_drop::ManuallyDrop")
                      []
                      [ Ty.apply (Ty.path "alloc::rc::Rc") [] [ T; A ] ],
                    [],
                    [],
                    "clone",
                    [],
                    []
                  |),
                  [ M.borrow (| Pointer.Kind.Ref, rc |) ]
                |)
              |) in
            M.alloc (| Value.Tuple [] |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_increment_strong_count_in :
      forall (T A : Ty.t),
      M.IsAssociatedFunction.C
        (Self T A)
        "increment_strong_count_in"
        (increment_strong_count_in T A).
    Admitted.
    Global Typeclasses Opaque increment_strong_count_in.
    
    (*
        pub unsafe fn decrement_strong_count_in(ptr: *const T, alloc: A) {
            unsafe { drop(Rc::from_raw_in(ptr, alloc)) };
        }
    *)
    Definition decrement_strong_count_in
        (T A : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ ptr; alloc ] =>
        ltac:(M.monadic
          (let ptr := M.alloc (| ptr |) in
          let alloc := M.alloc (| alloc |) in
          M.read (|
            let~ _ : Ty.tuple [] :=
              M.alloc (|
                M.call_closure (|
                  Ty.tuple [],
                  M.get_function (|
                    "core::mem::drop",
                    [],
                    [ Ty.apply (Ty.path "alloc::rc::Rc") [] [ T; A ] ]
                  |),
                  [
                    M.call_closure (|
                      Ty.apply (Ty.path "alloc::rc::Rc") [] [ T; A ],
                      M.get_associated_function (|
                        Ty.apply (Ty.path "alloc::rc::Rc") [] [ T; A ],
                        "from_raw_in",
                        [],
                        []
                      |),
                      [ M.read (| ptr |); M.read (| alloc |) ]
                    |)
                  ]
                |)
              |) in
            M.alloc (| Value.Tuple [] |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_decrement_strong_count_in :
      forall (T A : Ty.t),
      M.IsAssociatedFunction.C
        (Self T A)
        "decrement_strong_count_in"
        (decrement_strong_count_in T A).
    Admitted.
    Global Typeclasses Opaque decrement_strong_count_in.
    
    (*
        fn is_unique(this: &Self) -> bool {
            Rc::weak_count(this) == 0 && Rc::strong_count(this) == 1
        }
    *)
    Definition is_unique (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ this ] =>
        ltac:(M.monadic
          (let this := M.alloc (| this |) in
          LogicalOp.and (|
            BinOp.eq (|
              M.call_closure (|
                Ty.path "usize",
                M.get_associated_function (|
                  Ty.apply (Ty.path "alloc::rc::Rc") [] [ T; A ],
                  "weak_count",
                  [],
                  []
                |),
                [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| this |) |) |) ]
              |),
              Value.Integer IntegerKind.Usize 0
            |),
            ltac:(M.monadic
              (BinOp.eq (|
                M.call_closure (|
                  Ty.path "usize",
                  M.get_associated_function (|
                    Ty.apply (Ty.path "alloc::rc::Rc") [] [ T; A ],
                    "strong_count",
                    [],
                    []
                  |),
                  [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| this |) |) |) ]
                |),
                Value.Integer IntegerKind.Usize 1
              |)))
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_is_unique :
      forall (T A : Ty.t),
      M.IsAssociatedFunction.C (Self T A) "is_unique" (is_unique T A).
    Admitted.
    Global Typeclasses Opaque is_unique.
    
    (*
        pub fn get_mut(this: &mut Self) -> Option<&mut T> {
            if Rc::is_unique(this) { unsafe { Some(Rc::get_mut_unchecked(this)) } } else { None }
        }
    *)
    Definition get_mut (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ this ] =>
        ltac:(M.monadic
          (let this := M.alloc (| this |) in
          M.read (|
            M.match_operator (|
              Some
                (Ty.apply
                  (Ty.path "core::option::Option")
                  []
                  [ Ty.apply (Ty.path "&mut") [] [ T ] ]),
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          M.call_closure (|
                            Ty.path "bool",
                            M.get_associated_function (|
                              Ty.apply (Ty.path "alloc::rc::Rc") [] [ T; A ],
                              "is_unique",
                              [],
                              []
                            |),
                            [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| this |) |) |) ]
                          |)
                        |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::option::Option::Some"
                        [
                          M.borrow (|
                            Pointer.Kind.MutRef,
                            M.deref (|
                              M.call_closure (|
                                Ty.apply (Ty.path "&mut") [] [ T ],
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "alloc::rc::Rc") [] [ T; A ],
                                  "get_mut_unchecked",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (|
                                    Pointer.Kind.MutRef,
                                    M.deref (| M.read (| this |) |)
                                  |)
                                ]
                              |)
                            |)
                          |)
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic (M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_get_mut :
      forall (T A : Ty.t),
      M.IsAssociatedFunction.C (Self T A) "get_mut" (get_mut T A).
    Admitted.
    Global Typeclasses Opaque get_mut.
    
    (*
        pub unsafe fn get_mut_unchecked(this: &mut Self) -> &mut T {
            // We are careful to *not* create a reference covering the "count" fields, as
            // this would conflict with accesses to the reference counts (e.g. by `Weak`).
            unsafe { &mut ( *this.ptr.as_ptr()).value }
        }
    *)
    Definition get_mut_unchecked
        (T A : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ this ] =>
        ltac:(M.monadic
          (let this := M.alloc (| this |) in
          M.borrow (|
            Pointer.Kind.MutRef,
            M.deref (|
              M.borrow (|
                Pointer.Kind.MutRef,
                M.deref (|
                  M.borrow (|
                    Pointer.Kind.MutRef,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.MutRef,
                        M.SubPointer.get_struct_record_field (|
                          M.deref (|
                            M.call_closure (|
                              Ty.apply
                                (Ty.path "*mut")
                                []
                                [ Ty.apply (Ty.path "alloc::rc::RcInner") [] [ T ] ],
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "core::ptr::non_null::NonNull")
                                  []
                                  [ Ty.apply (Ty.path "alloc::rc::RcInner") [] [ T ] ],
                                "as_ptr",
                                [],
                                []
                              |),
                              [
                                M.read (|
                                  M.SubPointer.get_struct_record_field (|
                                    M.deref (| M.read (| this |) |),
                                    "alloc::rc::Rc",
                                    "ptr"
                                  |)
                                |)
                              ]
                            |)
                          |),
                          "alloc::rc::RcInner",
                          "value"
                        |)
                      |)
                    |)
                  |)
                |)
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_get_mut_unchecked :
      forall (T A : Ty.t),
      M.IsAssociatedFunction.C (Self T A) "get_mut_unchecked" (get_mut_unchecked T A).
    Admitted.
    Global Typeclasses Opaque get_mut_unchecked.
    
    (*
        pub fn ptr_eq(this: &Self, other: &Self) -> bool {
            ptr::addr_eq(this.ptr.as_ptr(), other.ptr.as_ptr())
        }
    *)
    Definition ptr_eq (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ this; other ] =>
        ltac:(M.monadic
          (let this := M.alloc (| this |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            Ty.path "bool",
            M.get_function (|
              "core::ptr::addr_eq",
              [],
              [
                Ty.apply (Ty.path "alloc::rc::RcInner") [] [ T ];
                Ty.apply (Ty.path "alloc::rc::RcInner") [] [ T ]
              ]
            |),
            [
              (* MutToConstPointer *)
              M.pointer_coercion
                (M.call_closure (|
                  Ty.apply (Ty.path "*mut") [] [ Ty.apply (Ty.path "alloc::rc::RcInner") [] [ T ] ],
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "core::ptr::non_null::NonNull")
                      []
                      [ Ty.apply (Ty.path "alloc::rc::RcInner") [] [ T ] ],
                    "as_ptr",
                    [],
                    []
                  |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| this |) |),
                        "alloc::rc::Rc",
                        "ptr"
                      |)
                    |)
                  ]
                |));
              (* MutToConstPointer *)
              M.pointer_coercion
                (M.call_closure (|
                  Ty.apply (Ty.path "*mut") [] [ Ty.apply (Ty.path "alloc::rc::RcInner") [] [ T ] ],
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "core::ptr::non_null::NonNull")
                      []
                      [ Ty.apply (Ty.path "alloc::rc::RcInner") [] [ T ] ],
                    "as_ptr",
                    [],
                    []
                  |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| other |) |),
                        "alloc::rc::Rc",
                        "ptr"
                      |)
                    |)
                  ]
                |))
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_ptr_eq :
      forall (T A : Ty.t),
      M.IsAssociatedFunction.C (Self T A) "ptr_eq" (ptr_eq T A).
    Admitted.
    Global Typeclasses Opaque ptr_eq.
    (*
        pub fn make_mut(this: &mut Self) -> &mut T {
            let size_of_val = size_of_val::<T>(&**this);
    
            if Rc::strong_count(this) != 1 {
                // Gotta clone the data, there are other Rcs.
    
                let this_data_ref: &T = &**this;
                // `in_progress` drops the allocation if we panic before finishing initializing it.
                let mut in_progress: UniqueRcUninit<T, A> =
                    UniqueRcUninit::new(this_data_ref, this.alloc.clone());
    
                // Initialize with clone of this.
                let initialized_clone = unsafe {
                    // Clone. If the clone panics, `in_progress` will be dropped and clean up.
                    this_data_ref.clone_to_uninit(in_progress.data_ptr().cast());
                    // Cast type of pointer, now that it is initialized.
                    in_progress.into_rc()
                };
    
                // Replace `this` with newly constructed Rc.
                *this = initialized_clone;
            } else if Rc::weak_count(this) != 0 {
                // Can just steal the data, all that's left is Weaks
    
                // We don't need panic-protection like the above branch does, but we might as well
                // use the same mechanism.
                let mut in_progress: UniqueRcUninit<T, A> =
                    UniqueRcUninit::new(&**this, this.alloc.clone());
                unsafe {
                    // Initialize `in_progress` with move of **this.
                    // We have to express this in terms of bytes because `T: ?Sized`; there is no
                    // operation that just copies a value based on its `size_of_val()`.
                    ptr::copy_nonoverlapping(
                        ptr::from_ref(&**this).cast::<u8>(),
                        in_progress.data_ptr().cast::<u8>(),
                        size_of_val,
                    );
    
                    this.inner().dec_strong();
                    // Remove implicit strong-weak ref (no need to craft a fake
                    // Weak here -- we know other Weaks can clean up for us)
                    this.inner().dec_weak();
                    // Replace `this` with newly constructed Rc that has the moved data.
                    ptr::write(this, in_progress.into_rc());
                }
            }
            // This unsafety is ok because we're guaranteed that the pointer
            // returned is the *only* pointer that will ever be returned to T. Our
            // reference count is guaranteed to be 1 at this point, and we required
            // the `Rc<T>` itself to be `mut`, so we're returning the only possible
            // reference to the allocation.
            unsafe { &mut this.ptr.as_mut().value }
        }
    *)
    Definition make_mut (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ this ] =>
        ltac:(M.monadic
          (let this := M.alloc (| this |) in
          M.borrow (|
            Pointer.Kind.MutRef,
            M.deref (|
              M.read (|
                let~ size_of_val : Ty.path "usize" :=
                  M.alloc (|
                    M.call_closure (|
                      Ty.path "usize",
                      M.get_function (| "core::mem::size_of_val", [], [ T ] |),
                      [
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.deref (|
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.deref (|
                                M.call_closure (|
                                  Ty.apply (Ty.path "&") [] [ T ],
                                  M.get_trait_method (|
                                    "core::ops::deref::Deref",
                                    Ty.apply (Ty.path "alloc::rc::Rc") [] [ T; A ],
                                    [],
                                    [],
                                    "deref",
                                    [],
                                    []
                                  |),
                                  [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| this |) |) |)
                                  ]
                                |)
                              |)
                            |)
                          |)
                        |)
                      ]
                    |)
                  |) in
                let~ _ : Ty.tuple [] :=
                  M.match_operator (|
                    Some (Ty.tuple []),
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                BinOp.ne (|
                                  M.call_closure (|
                                    Ty.path "usize",
                                    M.get_associated_function (|
                                      Ty.apply (Ty.path "alloc::rc::Rc") [] [ T; A ],
                                      "strong_count",
                                      [],
                                      []
                                    |),
                                    [
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.deref (| M.read (| this |) |)
                                      |)
                                    ]
                                  |),
                                  Value.Integer IntegerKind.Usize 1
                                |)
                              |)) in
                          let _ :=
                            M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          let~ this_data_ref : Ty.apply (Ty.path "&") [] [ T ] :=
                            M.alloc (|
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (|
                                      M.call_closure (|
                                        Ty.apply (Ty.path "&") [] [ T ],
                                        M.get_trait_method (|
                                          "core::ops::deref::Deref",
                                          Ty.apply (Ty.path "alloc::rc::Rc") [] [ T; A ],
                                          [],
                                          [],
                                          "deref",
                                          [],
                                          []
                                        |),
                                        [
                                          M.borrow (|
                                            Pointer.Kind.Ref,
                                            M.deref (| M.read (| this |) |)
                                          |)
                                        ]
                                      |)
                                    |)
                                  |)
                                |)
                              |)
                            |) in
                          let~ in_progress :
                              Ty.apply (Ty.path "alloc::rc::UniqueRcUninit") [] [ T; A ] :=
                            M.alloc (|
                              M.call_closure (|
                                Ty.apply (Ty.path "alloc::rc::UniqueRcUninit") [] [ T; A ],
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "alloc::rc::UniqueRcUninit") [] [ T; A ],
                                  "new",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (| M.read (| this_data_ref |) |)
                                  |);
                                  M.call_closure (|
                                    A,
                                    M.get_trait_method (|
                                      "core::clone::Clone",
                                      A,
                                      [],
                                      [],
                                      "clone",
                                      [],
                                      []
                                    |),
                                    [
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.SubPointer.get_struct_record_field (|
                                          M.deref (| M.read (| this |) |),
                                          "alloc::rc::Rc",
                                          "alloc"
                                        |)
                                      |)
                                    ]
                                  |)
                                ]
                              |)
                            |) in
                          let~ initialized_clone : Ty.apply (Ty.path "alloc::rc::Rc") [] [ T; A ] :=
                            M.copy (|
                              let~ _ : Ty.tuple [] :=
                                M.alloc (|
                                  M.call_closure (|
                                    Ty.tuple [],
                                    M.get_trait_method (|
                                      "core::clone::CloneToUninit",
                                      T,
                                      [],
                                      [],
                                      "clone_to_uninit",
                                      [],
                                      []
                                    |),
                                    [
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.deref (| M.read (| this_data_ref |) |)
                                      |);
                                      M.call_closure (|
                                        Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ],
                                        M.get_associated_function (|
                                          Ty.apply (Ty.path "*mut") [] [ T ],
                                          "cast",
                                          [],
                                          [ Ty.path "u8" ]
                                        |),
                                        [
                                          M.call_closure (|
                                            Ty.apply (Ty.path "*mut") [] [ T ],
                                            M.get_associated_function (|
                                              Ty.apply
                                                (Ty.path "alloc::rc::UniqueRcUninit")
                                                []
                                                [ T; A ],
                                              "data_ptr",
                                              [],
                                              []
                                            |),
                                            [ M.borrow (| Pointer.Kind.MutRef, in_progress |) ]
                                          |)
                                        ]
                                      |)
                                    ]
                                  |)
                                |) in
                              M.alloc (|
                                M.call_closure (|
                                  Ty.apply (Ty.path "alloc::rc::Rc") [] [ T; A ],
                                  M.get_associated_function (|
                                    Ty.apply (Ty.path "alloc::rc::UniqueRcUninit") [] [ T; A ],
                                    "into_rc",
                                    [],
                                    []
                                  |),
                                  [ M.read (| in_progress |) ]
                                |)
                              |)
                            |) in
                          let~ _ : Ty.tuple [] :=
                            M.alloc (|
                              M.write (|
                                M.deref (| M.read (| this |) |),
                                M.read (| initialized_clone |)
                              |)
                            |) in
                          M.alloc (| Value.Tuple [] |)));
                      fun γ =>
                        ltac:(M.monadic
                          (M.match_operator (|
                            Some (Ty.tuple []),
                            M.alloc (| Value.Tuple [] |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ :=
                                    M.use
                                      (M.alloc (|
                                        BinOp.ne (|
                                          M.call_closure (|
                                            Ty.path "usize",
                                            M.get_associated_function (|
                                              Ty.apply (Ty.path "alloc::rc::Rc") [] [ T; A ],
                                              "weak_count",
                                              [],
                                              []
                                            |),
                                            [
                                              M.borrow (|
                                                Pointer.Kind.Ref,
                                                M.deref (| M.read (| this |) |)
                                              |)
                                            ]
                                          |),
                                          Value.Integer IntegerKind.Usize 0
                                        |)
                                      |)) in
                                  let _ :=
                                    M.is_constant_or_break_match (|
                                      M.read (| γ |),
                                      Value.Bool true
                                    |) in
                                  let~ in_progress :
                                      Ty.apply (Ty.path "alloc::rc::UniqueRcUninit") [] [ T; A ] :=
                                    M.alloc (|
                                      M.call_closure (|
                                        Ty.apply (Ty.path "alloc::rc::UniqueRcUninit") [] [ T; A ],
                                        M.get_associated_function (|
                                          Ty.apply
                                            (Ty.path "alloc::rc::UniqueRcUninit")
                                            []
                                            [ T; A ],
                                          "new",
                                          [],
                                          []
                                        |),
                                        [
                                          M.borrow (|
                                            Pointer.Kind.Ref,
                                            M.deref (|
                                              M.borrow (|
                                                Pointer.Kind.Ref,
                                                M.deref (|
                                                  M.call_closure (|
                                                    Ty.apply (Ty.path "&") [] [ T ],
                                                    M.get_trait_method (|
                                                      "core::ops::deref::Deref",
                                                      Ty.apply
                                                        (Ty.path "alloc::rc::Rc")
                                                        []
                                                        [ T; A ],
                                                      [],
                                                      [],
                                                      "deref",
                                                      [],
                                                      []
                                                    |),
                                                    [
                                                      M.borrow (|
                                                        Pointer.Kind.Ref,
                                                        M.deref (| M.read (| this |) |)
                                                      |)
                                                    ]
                                                  |)
                                                |)
                                              |)
                                            |)
                                          |);
                                          M.call_closure (|
                                            A,
                                            M.get_trait_method (|
                                              "core::clone::Clone",
                                              A,
                                              [],
                                              [],
                                              "clone",
                                              [],
                                              []
                                            |),
                                            [
                                              M.borrow (|
                                                Pointer.Kind.Ref,
                                                M.SubPointer.get_struct_record_field (|
                                                  M.deref (| M.read (| this |) |),
                                                  "alloc::rc::Rc",
                                                  "alloc"
                                                |)
                                              |)
                                            ]
                                          |)
                                        ]
                                      |)
                                    |) in
                                  let~ _ : Ty.tuple [] :=
                                    M.alloc (|
                                      M.call_closure (|
                                        Ty.tuple [],
                                        M.get_function (|
                                          "core::intrinsics::copy_nonoverlapping",
                                          [],
                                          [ Ty.path "u8" ]
                                        |),
                                        [
                                          M.call_closure (|
                                            Ty.apply (Ty.path "*const") [] [ Ty.path "u8" ],
                                            M.get_associated_function (|
                                              Ty.apply (Ty.path "*const") [] [ T ],
                                              "cast",
                                              [],
                                              [ Ty.path "u8" ]
                                            |),
                                            [
                                              M.call_closure (|
                                                Ty.apply (Ty.path "*const") [] [ T ],
                                                M.get_function (|
                                                  "core::ptr::from_ref",
                                                  [],
                                                  [ T ]
                                                |),
                                                [
                                                  M.borrow (|
                                                    Pointer.Kind.Ref,
                                                    M.deref (|
                                                      M.borrow (|
                                                        Pointer.Kind.Ref,
                                                        M.deref (|
                                                          M.call_closure (|
                                                            Ty.apply (Ty.path "&") [] [ T ],
                                                            M.get_trait_method (|
                                                              "core::ops::deref::Deref",
                                                              Ty.apply
                                                                (Ty.path "alloc::rc::Rc")
                                                                []
                                                                [ T; A ],
                                                              [],
                                                              [],
                                                              "deref",
                                                              [],
                                                              []
                                                            |),
                                                            [
                                                              M.borrow (|
                                                                Pointer.Kind.Ref,
                                                                M.deref (| M.read (| this |) |)
                                                              |)
                                                            ]
                                                          |)
                                                        |)
                                                      |)
                                                    |)
                                                  |)
                                                ]
                                              |)
                                            ]
                                          |);
                                          M.call_closure (|
                                            Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ],
                                            M.get_associated_function (|
                                              Ty.apply (Ty.path "*mut") [] [ T ],
                                              "cast",
                                              [],
                                              [ Ty.path "u8" ]
                                            |),
                                            [
                                              M.call_closure (|
                                                Ty.apply (Ty.path "*mut") [] [ T ],
                                                M.get_associated_function (|
                                                  Ty.apply
                                                    (Ty.path "alloc::rc::UniqueRcUninit")
                                                    []
                                                    [ T; A ],
                                                  "data_ptr",
                                                  [],
                                                  []
                                                |),
                                                [ M.borrow (| Pointer.Kind.MutRef, in_progress |) ]
                                              |)
                                            ]
                                          |);
                                          M.read (| size_of_val |)
                                        ]
                                      |)
                                    |) in
                                  let~ _ : Ty.tuple [] :=
                                    M.alloc (|
                                      M.call_closure (|
                                        Ty.tuple [],
                                        M.get_trait_method (|
                                          "alloc::rc::RcInnerPtr",
                                          Ty.apply (Ty.path "alloc::rc::RcInner") [] [ T ],
                                          [],
                                          [],
                                          "dec_strong",
                                          [],
                                          []
                                        |),
                                        [
                                          M.borrow (|
                                            Pointer.Kind.Ref,
                                            M.deref (|
                                              M.call_closure (|
                                                Ty.apply
                                                  (Ty.path "&")
                                                  []
                                                  [ Ty.apply (Ty.path "alloc::rc::RcInner") [] [ T ]
                                                  ],
                                                M.get_associated_function (|
                                                  Ty.apply (Ty.path "alloc::rc::Rc") [] [ T; A ],
                                                  "inner",
                                                  [],
                                                  []
                                                |),
                                                [
                                                  M.borrow (|
                                                    Pointer.Kind.Ref,
                                                    M.deref (| M.read (| this |) |)
                                                  |)
                                                ]
                                              |)
                                            |)
                                          |)
                                        ]
                                      |)
                                    |) in
                                  let~ _ : Ty.tuple [] :=
                                    M.alloc (|
                                      M.call_closure (|
                                        Ty.tuple [],
                                        M.get_trait_method (|
                                          "alloc::rc::RcInnerPtr",
                                          Ty.apply (Ty.path "alloc::rc::RcInner") [] [ T ],
                                          [],
                                          [],
                                          "dec_weak",
                                          [],
                                          []
                                        |),
                                        [
                                          M.borrow (|
                                            Pointer.Kind.Ref,
                                            M.deref (|
                                              M.call_closure (|
                                                Ty.apply
                                                  (Ty.path "&")
                                                  []
                                                  [ Ty.apply (Ty.path "alloc::rc::RcInner") [] [ T ]
                                                  ],
                                                M.get_associated_function (|
                                                  Ty.apply (Ty.path "alloc::rc::Rc") [] [ T; A ],
                                                  "inner",
                                                  [],
                                                  []
                                                |),
                                                [
                                                  M.borrow (|
                                                    Pointer.Kind.Ref,
                                                    M.deref (| M.read (| this |) |)
                                                  |)
                                                ]
                                              |)
                                            |)
                                          |)
                                        ]
                                      |)
                                    |) in
                                  let~ _ : Ty.tuple [] :=
                                    M.alloc (|
                                      M.call_closure (|
                                        Ty.tuple [],
                                        M.get_function (|
                                          "core::ptr::write",
                                          [],
                                          [ Ty.apply (Ty.path "alloc::rc::Rc") [] [ T; A ] ]
                                        |),
                                        [
                                          M.borrow (|
                                            Pointer.Kind.MutPointer,
                                            M.deref (| M.read (| this |) |)
                                          |);
                                          M.call_closure (|
                                            Ty.apply (Ty.path "alloc::rc::Rc") [] [ T; A ],
                                            M.get_associated_function (|
                                              Ty.apply
                                                (Ty.path "alloc::rc::UniqueRcUninit")
                                                []
                                                [ T; A ],
                                              "into_rc",
                                              [],
                                              []
                                            |),
                                            [ M.read (| in_progress |) ]
                                          |)
                                        ]
                                      |)
                                    |) in
                                  M.alloc (| Value.Tuple [] |)));
                              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                            ]
                          |)))
                    ]
                  |) in
                M.alloc (|
                  M.borrow (|
                    Pointer.Kind.MutRef,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.MutRef,
                        M.deref (|
                          M.borrow (|
                            Pointer.Kind.MutRef,
                            M.SubPointer.get_struct_record_field (|
                              M.deref (|
                                M.call_closure (|
                                  Ty.apply
                                    (Ty.path "&mut")
                                    []
                                    [ Ty.apply (Ty.path "alloc::rc::RcInner") [] [ T ] ],
                                  M.get_associated_function (|
                                    Ty.apply
                                      (Ty.path "core::ptr::non_null::NonNull")
                                      []
                                      [ Ty.apply (Ty.path "alloc::rc::RcInner") [] [ T ] ],
                                    "as_mut",
                                    [],
                                    []
                                  |),
                                  [
                                    M.borrow (|
                                      Pointer.Kind.MutRef,
                                      M.SubPointer.get_struct_record_field (|
                                        M.deref (| M.read (| this |) |),
                                        "alloc::rc::Rc",
                                        "ptr"
                                      |)
                                    |)
                                  ]
                                |)
                              |),
                              "alloc::rc::RcInner",
                              "value"
                            |)
                          |)
                        |)
                      |)
                    |)
                  |)
                |)
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_make_mut :
      forall (T A : Ty.t),
      M.IsAssociatedFunction.C (Self T A) "make_mut" (make_mut T A).
    Admitted.
    Global Typeclasses Opaque make_mut.
    (*
        pub fn unwrap_or_clone(this: Self) -> T {
            Rc::try_unwrap(this).unwrap_or_else(|rc| ( *rc).clone())
        }
    *)
    Definition unwrap_or_clone
        (T A : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ this ] =>
        ltac:(M.monadic
          (let this := M.alloc (| this |) in
          M.call_closure (|
            T,
            M.get_associated_function (|
              Ty.apply
                (Ty.path "core::result::Result")
                []
                [ T; Ty.apply (Ty.path "alloc::rc::Rc") [] [ T; A ] ],
              "unwrap_or_else",
              [],
              [ Ty.function [ Ty.tuple [ Ty.apply (Ty.path "alloc::rc::Rc") [] [ T; A ] ] ] T ]
            |),
            [
              M.call_closure (|
                Ty.apply
                  (Ty.path "core::result::Result")
                  []
                  [ T; Ty.apply (Ty.path "alloc::rc::Rc") [] [ T; A ] ],
                M.get_associated_function (|
                  Ty.apply (Ty.path "alloc::rc::Rc") [] [ T; A ],
                  "try_unwrap",
                  [],
                  []
                |),
                [ M.read (| this |) ]
              |);
              M.closure
                (fun γ =>
                  ltac:(M.monadic
                    match γ with
                    | [ α0 ] =>
                      ltac:(M.monadic
                        (M.match_operator (|
                          Some
                            (Ty.function
                              [ Ty.tuple [ Ty.apply (Ty.path "alloc::rc::Rc") [] [ T; A ] ] ]
                              T),
                          M.alloc (| α0 |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let rc := M.copy (| γ |) in
                                M.call_closure (|
                                  T,
                                  M.get_trait_method (|
                                    "core::clone::Clone",
                                    T,
                                    [],
                                    [],
                                    "clone",
                                    [],
                                    []
                                  |),
                                  [
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.deref (|
                                        M.call_closure (|
                                          Ty.apply (Ty.path "&") [] [ T ],
                                          M.get_trait_method (|
                                            "core::ops::deref::Deref",
                                            Ty.apply (Ty.path "alloc::rc::Rc") [] [ T; A ],
                                            [],
                                            [],
                                            "deref",
                                            [],
                                            []
                                          |),
                                          [ M.borrow (| Pointer.Kind.Ref, rc |) ]
                                        |)
                                      |)
                                    |)
                                  ]
                                |)))
                          ]
                        |)))
                    | _ => M.impossible "wrong number of arguments"
                    end))
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_unwrap_or_clone :
      forall (T A : Ty.t),
      M.IsAssociatedFunction.C (Self T A) "unwrap_or_clone" (unwrap_or_clone T A).
    Admitted.
    Global Typeclasses Opaque unwrap_or_clone.
    (*
        unsafe fn allocate_for_ptr_in(ptr: *const T, alloc: &A) -> *mut RcInner<T> {
            // Allocate for the `RcInner<T>` using the given value.
            unsafe {
                Rc::<T>::allocate_for_layout(
                    Layout::for_value_raw(ptr),
                    |layout| alloc.allocate(layout),
                    |mem| mem.with_metadata_of(ptr as *const RcInner<T>),
                )
            }
        }
    *)
    Definition allocate_for_ptr_in
        (T A : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ ptr; alloc ] =>
        ltac:(M.monadic
          (let ptr := M.alloc (| ptr |) in
          let alloc := M.alloc (| alloc |) in
          M.call_closure (|
            Ty.apply (Ty.path "*mut") [] [ Ty.apply (Ty.path "alloc::rc::RcInner") [] [ T ] ],
            M.get_associated_function (|
              Ty.apply (Ty.path "alloc::rc::Rc") [] [ T; Ty.path "alloc::alloc::Global" ],
              "allocate_for_layout",
              [],
              [
                Ty.function
                  [ Ty.tuple [ Ty.path "core::alloc::layout::Layout" ] ]
                  (Ty.apply
                    (Ty.path "core::result::Result")
                    []
                    [
                      Ty.apply
                        (Ty.path "core::ptr::non_null::NonNull")
                        []
                        [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ];
                      Ty.path "core::alloc::AllocError"
                    ]);
                Ty.function
                  [ Ty.tuple [ Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ] ] ]
                  (Ty.apply
                    (Ty.path "*mut")
                    []
                    [ Ty.apply (Ty.path "alloc::rc::RcInner") [] [ T ] ])
              ]
            |),
            [
              M.call_closure (|
                Ty.path "core::alloc::layout::Layout",
                M.get_associated_function (|
                  Ty.path "core::alloc::layout::Layout",
                  "for_value_raw",
                  [],
                  [ T ]
                |),
                [ M.read (| ptr |) ]
              |);
              M.closure
                (fun γ =>
                  ltac:(M.monadic
                    match γ with
                    | [ α0 ] =>
                      ltac:(M.monadic
                        (M.match_operator (|
                          Some
                            (Ty.function
                              [ Ty.tuple [ Ty.path "core::alloc::layout::Layout" ] ]
                              (Ty.apply
                                (Ty.path "core::result::Result")
                                []
                                [
                                  Ty.apply
                                    (Ty.path "core::ptr::non_null::NonNull")
                                    []
                                    [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ];
                                  Ty.path "core::alloc::AllocError"
                                ])),
                          M.alloc (| α0 |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let layout := M.copy (| γ |) in
                                M.call_closure (|
                                  Ty.apply
                                    (Ty.path "core::result::Result")
                                    []
                                    [
                                      Ty.apply
                                        (Ty.path "core::ptr::non_null::NonNull")
                                        []
                                        [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ];
                                      Ty.path "core::alloc::AllocError"
                                    ],
                                  M.get_trait_method (|
                                    "core::alloc::Allocator",
                                    A,
                                    [],
                                    [],
                                    "allocate",
                                    [],
                                    []
                                  |),
                                  [
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.deref (| M.read (| alloc |) |)
                                    |);
                                    M.read (| layout |)
                                  ]
                                |)))
                          ]
                        |)))
                    | _ => M.impossible "wrong number of arguments"
                    end));
              M.closure
                (fun γ =>
                  ltac:(M.monadic
                    match γ with
                    | [ α0 ] =>
                      ltac:(M.monadic
                        (M.match_operator (|
                          Some
                            (Ty.function
                              [ Ty.tuple [ Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ] ] ]
                              (Ty.apply
                                (Ty.path "*mut")
                                []
                                [ Ty.apply (Ty.path "alloc::rc::RcInner") [] [ T ] ])),
                          M.alloc (| α0 |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let mem := M.copy (| γ |) in
                                M.call_closure (|
                                  Ty.apply
                                    (Ty.path "*mut")
                                    []
                                    [ Ty.apply (Ty.path "alloc::rc::RcInner") [] [ T ] ],
                                  M.get_associated_function (|
                                    Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ],
                                    "with_metadata_of",
                                    [],
                                    [ Ty.apply (Ty.path "alloc::rc::RcInner") [] [ T ] ]
                                  |),
                                  [
                                    M.read (| mem |);
                                    M.cast
                                      (Ty.apply
                                        (Ty.path "*const")
                                        []
                                        [ Ty.apply (Ty.path "alloc::rc::RcInner") [] [ T ] ])
                                      (M.read (| ptr |))
                                  ]
                                |)))
                          ]
                        |)))
                    | _ => M.impossible "wrong number of arguments"
                    end))
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_allocate_for_ptr_in :
      forall (T A : Ty.t),
      M.IsAssociatedFunction.C (Self T A) "allocate_for_ptr_in" (allocate_for_ptr_in T A).
    Admitted.
    Global Typeclasses Opaque allocate_for_ptr_in.
    
    (*
        fn from_box_in(src: Box<T, A>) -> Rc<T, A> {
            unsafe {
                let value_size = size_of_val(&*src);
                let ptr = Self::allocate_for_ptr_in(&*src, Box::allocator(&src));
    
                // Copy value as bytes
                ptr::copy_nonoverlapping(
                    (&raw const *src) as *const u8,
                    (&raw mut ( *ptr).value) as *mut u8,
                    value_size,
                );
    
                // Free the allocation without dropping its contents
                let (bptr, alloc) = Box::into_raw_with_allocator(src);
                let src = Box::from_raw_in(bptr as *mut mem::ManuallyDrop<T>, alloc.by_ref());
                drop(src);
    
                Self::from_ptr_in(ptr, alloc)
            }
        }
    *)
    Definition from_box_in (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ src ] =>
        ltac:(M.monadic
          (let src := M.alloc (| src |) in
          M.read (|
            let~ value_size : Ty.path "usize" :=
              M.alloc (|
                M.call_closure (|
                  Ty.path "usize",
                  M.get_function (| "core::mem::size_of_val", [], [ T ] |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (| M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| src |) |) |) |)
                    |)
                  ]
                |)
              |) in
            let~ ptr :
                Ty.apply (Ty.path "*mut") [] [ Ty.apply (Ty.path "alloc::rc::RcInner") [] [ T ] ] :=
              M.alloc (|
                M.call_closure (|
                  Ty.apply (Ty.path "*mut") [] [ Ty.apply (Ty.path "alloc::rc::RcInner") [] [ T ] ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "alloc::rc::Rc") [] [ T; A ],
                    "allocate_for_ptr_in",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.ConstPointer,
                      M.deref (| M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| src |) |) |) |)
                    |);
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.call_closure (|
                          Ty.apply (Ty.path "&") [] [ A ],
                          M.get_associated_function (|
                            Ty.apply (Ty.path "alloc::boxed::Box") [] [ T; A ],
                            "allocator",
                            [],
                            []
                          |),
                          [
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.deref (| M.borrow (| Pointer.Kind.Ref, src |) |)
                            |)
                          ]
                        |)
                      |)
                    |)
                  ]
                |)
              |) in
            let~ _ : Ty.tuple [] :=
              M.alloc (|
                M.call_closure (|
                  Ty.tuple [],
                  M.get_function (|
                    "core::intrinsics::copy_nonoverlapping",
                    [],
                    [ Ty.path "u8" ]
                  |),
                  [
                    M.cast
                      (Ty.apply (Ty.path "*const") [] [ Ty.path "u8" ])
                      (M.borrow (| Pointer.Kind.ConstPointer, M.deref (| M.read (| src |) |) |));
                    M.cast
                      (Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ])
                      (M.borrow (|
                        Pointer.Kind.MutPointer,
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| ptr |) |),
                          "alloc::rc::RcInner",
                          "value"
                        |)
                      |));
                    M.read (| value_size |)
                  ]
                |)
              |) in
            M.match_operator (|
              None,
              M.alloc (|
                M.call_closure (|
                  Ty.tuple [ Ty.apply (Ty.path "*mut") [] [ T ]; A ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "alloc::boxed::Box") [] [ T; A ],
                    "into_raw_with_allocator",
                    [],
                    []
                  |),
                  [ M.read (| src |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let bptr := M.copy (| γ0_0 |) in
                    let alloc := M.copy (| γ0_1 |) in
                    let~ src :
                        Ty.apply
                          (Ty.path "alloc::boxed::Box")
                          []
                          [
                            Ty.apply (Ty.path "core::mem::manually_drop::ManuallyDrop") [] [ T ];
                            Ty.apply (Ty.path "&") [] [ A ]
                          ] :=
                      M.alloc (|
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "alloc::boxed::Box")
                            []
                            [
                              Ty.apply (Ty.path "core::mem::manually_drop::ManuallyDrop") [] [ T ];
                              Ty.apply (Ty.path "&") [] [ A ]
                            ],
                          M.get_associated_function (|
                            Ty.apply
                              (Ty.path "alloc::boxed::Box")
                              []
                              [
                                Ty.apply
                                  (Ty.path "core::mem::manually_drop::ManuallyDrop")
                                  []
                                  [ T ];
                                Ty.apply (Ty.path "&") [] [ A ]
                              ],
                            "from_raw_in",
                            [],
                            []
                          |),
                          [
                            M.cast
                              (Ty.apply
                                (Ty.path "*mut")
                                []
                                [
                                  Ty.apply
                                    (Ty.path "core::mem::manually_drop::ManuallyDrop")
                                    []
                                    [ T ]
                                ])
                              (M.read (| bptr |));
                            M.call_closure (|
                              Ty.apply (Ty.path "&") [] [ A ],
                              M.get_trait_method (|
                                "core::alloc::Allocator",
                                A,
                                [],
                                [],
                                "by_ref",
                                [],
                                []
                              |),
                              [ M.borrow (| Pointer.Kind.Ref, alloc |) ]
                            |)
                          ]
                        |)
                      |) in
                    let~ _ : Ty.tuple [] :=
                      M.alloc (|
                        M.call_closure (|
                          Ty.tuple [],
                          M.get_function (|
                            "core::mem::drop",
                            [],
                            [
                              Ty.apply
                                (Ty.path "alloc::boxed::Box")
                                []
                                [
                                  Ty.apply
                                    (Ty.path "core::mem::manually_drop::ManuallyDrop")
                                    []
                                    [ T ];
                                  Ty.apply (Ty.path "&") [] [ A ]
                                ]
                            ]
                          |),
                          [ M.read (| src |) ]
                        |)
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply (Ty.path "alloc::rc::Rc") [] [ T; A ],
                        M.get_associated_function (|
                          Ty.apply (Ty.path "alloc::rc::Rc") [] [ T; A ],
                          "from_ptr_in",
                          [],
                          []
                        |),
                        [ M.read (| ptr |); M.read (| alloc |) ]
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_from_box_in :
      forall (T A : Ty.t),
      M.IsAssociatedFunction.C (Self T A) "from_box_in" (from_box_in T A).
    Admitted.
    Global Typeclasses Opaque from_box_in.
  End Impl_alloc_rc_Rc_T_A.
  
  
  
  Module Impl_alloc_rc_Rc_slice_T_alloc_alloc_Global.
    Definition Self (T : Ty.t) : Ty.t :=
      Ty.apply
        (Ty.path "alloc::rc::Rc")
        []
        [ Ty.apply (Ty.path "slice") [] [ T ]; Ty.path "alloc::alloc::Global" ].
    
    (*
        pub fn new_uninit_slice(len: usize) -> Rc<[mem::MaybeUninit<T>]> {
            unsafe { Rc::from_ptr(Rc::allocate_for_slice(len)) }
        }
    *)
    Definition new_uninit_slice
        (T : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [], [ len ] =>
        ltac:(M.monadic
          (let len := M.alloc (| len |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "alloc::rc::Rc")
              []
              [
                Ty.apply
                  (Ty.path "slice")
                  []
                  [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ] ];
                Ty.path "alloc::alloc::Global"
              ],
            M.get_associated_function (|
              Ty.apply
                (Ty.path "alloc::rc::Rc")
                []
                [
                  Ty.apply
                    (Ty.path "slice")
                    []
                    [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ] ];
                  Ty.path "alloc::alloc::Global"
                ],
              "from_ptr",
              [],
              []
            |),
            [
              M.call_closure (|
                Ty.apply
                  (Ty.path "*mut")
                  []
                  [
                    Ty.apply
                      (Ty.path "alloc::rc::RcInner")
                      []
                      [
                        Ty.apply
                          (Ty.path "slice")
                          []
                          [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ] ]
                      ]
                  ],
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "alloc::rc::Rc")
                    []
                    [
                      Ty.apply
                        (Ty.path "slice")
                        []
                        [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ] ];
                      Ty.path "alloc::alloc::Global"
                    ],
                  "allocate_for_slice",
                  [],
                  []
                |),
                [ M.read (| len |) ]
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_new_uninit_slice :
      forall (T : Ty.t),
      M.IsAssociatedFunction.C (Self T) "new_uninit_slice" (new_uninit_slice T).
    Admitted.
    Global Typeclasses Opaque new_uninit_slice.
    
    (*
        pub fn new_zeroed_slice(len: usize) -> Rc<[mem::MaybeUninit<T>]> {
            unsafe {
                Rc::from_ptr(Rc::allocate_for_layout(
                    Layout::array::<T>(len).unwrap(),
                    |layout| Global.allocate_zeroed(layout),
                    |mem| {
                        ptr::slice_from_raw_parts_mut(mem.cast::<T>(), len)
                            as *mut RcInner<[mem::MaybeUninit<T>]>
                    },
                ))
            }
        }
    *)
    Definition new_zeroed_slice
        (T : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [], [ len ] =>
        ltac:(M.monadic
          (let len := M.alloc (| len |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "alloc::rc::Rc")
              []
              [
                Ty.apply
                  (Ty.path "slice")
                  []
                  [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ] ];
                Ty.path "alloc::alloc::Global"
              ],
            M.get_associated_function (|
              Ty.apply
                (Ty.path "alloc::rc::Rc")
                []
                [
                  Ty.apply
                    (Ty.path "slice")
                    []
                    [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ] ];
                  Ty.path "alloc::alloc::Global"
                ],
              "from_ptr",
              [],
              []
            |),
            [
              M.call_closure (|
                Ty.apply
                  (Ty.path "*mut")
                  []
                  [
                    Ty.apply
                      (Ty.path "alloc::rc::RcInner")
                      []
                      [
                        Ty.apply
                          (Ty.path "slice")
                          []
                          [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ] ]
                      ]
                  ],
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "alloc::rc::Rc")
                    []
                    [
                      Ty.apply
                        (Ty.path "slice")
                        []
                        [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ] ];
                      Ty.path "alloc::alloc::Global"
                    ],
                  "allocate_for_layout",
                  [],
                  [
                    Ty.function
                      [ Ty.tuple [ Ty.path "core::alloc::layout::Layout" ] ]
                      (Ty.apply
                        (Ty.path "core::result::Result")
                        []
                        [
                          Ty.apply
                            (Ty.path "core::ptr::non_null::NonNull")
                            []
                            [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ];
                          Ty.path "core::alloc::AllocError"
                        ]);
                    Ty.function
                      [ Ty.tuple [ Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ] ] ]
                      (Ty.apply
                        (Ty.path "*mut")
                        []
                        [
                          Ty.apply
                            (Ty.path "alloc::rc::RcInner")
                            []
                            [
                              Ty.apply
                                (Ty.path "slice")
                                []
                                [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ]
                                ]
                            ]
                        ])
                  ]
                |),
                [
                  M.call_closure (|
                    Ty.path "core::alloc::layout::Layout",
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "core::result::Result")
                        []
                        [
                          Ty.path "core::alloc::layout::Layout";
                          Ty.path "core::alloc::layout::LayoutError"
                        ],
                      "unwrap",
                      [],
                      []
                    |),
                    [
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [
                            Ty.path "core::alloc::layout::Layout";
                            Ty.path "core::alloc::layout::LayoutError"
                          ],
                        M.get_associated_function (|
                          Ty.path "core::alloc::layout::Layout",
                          "array",
                          [],
                          [ T ]
                        |),
                        [ M.read (| len |) ]
                      |)
                    ]
                  |);
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0 ] =>
                          ltac:(M.monadic
                            (M.match_operator (|
                              Some
                                (Ty.function
                                  [ Ty.tuple [ Ty.path "core::alloc::layout::Layout" ] ]
                                  (Ty.apply
                                    (Ty.path "core::result::Result")
                                    []
                                    [
                                      Ty.apply
                                        (Ty.path "core::ptr::non_null::NonNull")
                                        []
                                        [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ];
                                      Ty.path "core::alloc::AllocError"
                                    ])),
                              M.alloc (| α0 |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let layout := M.copy (| γ |) in
                                    M.call_closure (|
                                      Ty.apply
                                        (Ty.path "core::result::Result")
                                        []
                                        [
                                          Ty.apply
                                            (Ty.path "core::ptr::non_null::NonNull")
                                            []
                                            [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ];
                                          Ty.path "core::alloc::AllocError"
                                        ],
                                      M.get_trait_method (|
                                        "core::alloc::Allocator",
                                        Ty.path "alloc::alloc::Global",
                                        [],
                                        [],
                                        "allocate_zeroed",
                                        [],
                                        []
                                      |),
                                      [
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.alloc (| Value.StructTuple "alloc::alloc::Global" [] |)
                                        |);
                                        M.read (| layout |)
                                      ]
                                    |)))
                              ]
                            |)))
                        | _ => M.impossible "wrong number of arguments"
                        end));
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0 ] =>
                          ltac:(M.monadic
                            (M.match_operator (|
                              Some
                                (Ty.function
                                  [ Ty.tuple [ Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ] ] ]
                                  (Ty.apply
                                    (Ty.path "*mut")
                                    []
                                    [
                                      Ty.apply
                                        (Ty.path "alloc::rc::RcInner")
                                        []
                                        [
                                          Ty.apply
                                            (Ty.path "slice")
                                            []
                                            [
                                              Ty.apply
                                                (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                                []
                                                [ T ]
                                            ]
                                        ]
                                    ])),
                              M.alloc (| α0 |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let mem := M.copy (| γ |) in
                                    M.cast
                                      (Ty.apply
                                        (Ty.path "*mut")
                                        []
                                        [
                                          Ty.apply
                                            (Ty.path "alloc::rc::RcInner")
                                            []
                                            [
                                              Ty.apply
                                                (Ty.path "slice")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                                    []
                                                    [ T ]
                                                ]
                                            ]
                                        ])
                                      (M.call_closure (|
                                        Ty.apply
                                          (Ty.path "*mut")
                                          []
                                          [ Ty.apply (Ty.path "slice") [] [ T ] ],
                                        M.get_function (|
                                          "core::ptr::slice_from_raw_parts_mut",
                                          [],
                                          [ T ]
                                        |),
                                        [
                                          M.call_closure (|
                                            Ty.apply (Ty.path "*mut") [] [ T ],
                                            M.get_associated_function (|
                                              Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ],
                                              "cast",
                                              [],
                                              [ T ]
                                            |),
                                            [ M.read (| mem |) ]
                                          |);
                                          M.read (| len |)
                                        ]
                                      |))))
                              ]
                            |)))
                        | _ => M.impossible "wrong number of arguments"
                        end))
                ]
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_new_zeroed_slice :
      forall (T : Ty.t),
      M.IsAssociatedFunction.C (Self T) "new_zeroed_slice" (new_zeroed_slice T).
    Admitted.
    Global Typeclasses Opaque new_zeroed_slice.
    (*
        unsafe fn allocate_for_slice(len: usize) -> *mut RcInner<[T]> {
            unsafe {
                Self::allocate_for_layout(
                    Layout::array::<T>(len).unwrap(),
                    |layout| Global.allocate(layout),
                    |mem| ptr::slice_from_raw_parts_mut(mem.cast::<T>(), len) as *mut RcInner<[T]>,
                )
            }
        }
    *)
    Definition allocate_for_slice
        (T : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [], [ len ] =>
        ltac:(M.monadic
          (let len := M.alloc (| len |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "*mut")
              []
              [ Ty.apply (Ty.path "alloc::rc::RcInner") [] [ Ty.apply (Ty.path "slice") [] [ T ] ]
              ],
            M.get_associated_function (|
              Ty.apply
                (Ty.path "alloc::rc::Rc")
                []
                [ Ty.apply (Ty.path "slice") [] [ T ]; Ty.path "alloc::alloc::Global" ],
              "allocate_for_layout",
              [],
              [
                Ty.function
                  [ Ty.tuple [ Ty.path "core::alloc::layout::Layout" ] ]
                  (Ty.apply
                    (Ty.path "core::result::Result")
                    []
                    [
                      Ty.apply
                        (Ty.path "core::ptr::non_null::NonNull")
                        []
                        [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ];
                      Ty.path "core::alloc::AllocError"
                    ]);
                Ty.function
                  [ Ty.tuple [ Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ] ] ]
                  (Ty.apply
                    (Ty.path "*mut")
                    []
                    [
                      Ty.apply
                        (Ty.path "alloc::rc::RcInner")
                        []
                        [ Ty.apply (Ty.path "slice") [] [ T ] ]
                    ])
              ]
            |),
            [
              M.call_closure (|
                Ty.path "core::alloc::layout::Layout",
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "core::result::Result")
                    []
                    [
                      Ty.path "core::alloc::layout::Layout";
                      Ty.path "core::alloc::layout::LayoutError"
                    ],
                  "unwrap",
                  [],
                  []
                |),
                [
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "core::result::Result")
                      []
                      [
                        Ty.path "core::alloc::layout::Layout";
                        Ty.path "core::alloc::layout::LayoutError"
                      ],
                    M.get_associated_function (|
                      Ty.path "core::alloc::layout::Layout",
                      "array",
                      [],
                      [ T ]
                    |),
                    [ M.read (| len |) ]
                  |)
                ]
              |);
              M.closure
                (fun γ =>
                  ltac:(M.monadic
                    match γ with
                    | [ α0 ] =>
                      ltac:(M.monadic
                        (M.match_operator (|
                          Some
                            (Ty.function
                              [ Ty.tuple [ Ty.path "core::alloc::layout::Layout" ] ]
                              (Ty.apply
                                (Ty.path "core::result::Result")
                                []
                                [
                                  Ty.apply
                                    (Ty.path "core::ptr::non_null::NonNull")
                                    []
                                    [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ];
                                  Ty.path "core::alloc::AllocError"
                                ])),
                          M.alloc (| α0 |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let layout := M.copy (| γ |) in
                                M.call_closure (|
                                  Ty.apply
                                    (Ty.path "core::result::Result")
                                    []
                                    [
                                      Ty.apply
                                        (Ty.path "core::ptr::non_null::NonNull")
                                        []
                                        [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ];
                                      Ty.path "core::alloc::AllocError"
                                    ],
                                  M.get_trait_method (|
                                    "core::alloc::Allocator",
                                    Ty.path "alloc::alloc::Global",
                                    [],
                                    [],
                                    "allocate",
                                    [],
                                    []
                                  |),
                                  [
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.alloc (| Value.StructTuple "alloc::alloc::Global" [] |)
                                    |);
                                    M.read (| layout |)
                                  ]
                                |)))
                          ]
                        |)))
                    | _ => M.impossible "wrong number of arguments"
                    end));
              M.closure
                (fun γ =>
                  ltac:(M.monadic
                    match γ with
                    | [ α0 ] =>
                      ltac:(M.monadic
                        (M.match_operator (|
                          Some
                            (Ty.function
                              [ Ty.tuple [ Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ] ] ]
                              (Ty.apply
                                (Ty.path "*mut")
                                []
                                [
                                  Ty.apply
                                    (Ty.path "alloc::rc::RcInner")
                                    []
                                    [ Ty.apply (Ty.path "slice") [] [ T ] ]
                                ])),
                          M.alloc (| α0 |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let mem := M.copy (| γ |) in
                                M.cast
                                  (Ty.apply
                                    (Ty.path "*mut")
                                    []
                                    [
                                      Ty.apply
                                        (Ty.path "alloc::rc::RcInner")
                                        []
                                        [ Ty.apply (Ty.path "slice") [] [ T ] ]
                                    ])
                                  (M.call_closure (|
                                    Ty.apply
                                      (Ty.path "*mut")
                                      []
                                      [ Ty.apply (Ty.path "slice") [] [ T ] ],
                                    M.get_function (|
                                      "core::ptr::slice_from_raw_parts_mut",
                                      [],
                                      [ T ]
                                    |),
                                    [
                                      M.call_closure (|
                                        Ty.apply (Ty.path "*mut") [] [ T ],
                                        M.get_associated_function (|
                                          Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ],
                                          "cast",
                                          [],
                                          [ T ]
                                        |),
                                        [ M.read (| mem |) ]
                                      |);
                                      M.read (| len |)
                                    ]
                                  |))))
                          ]
                        |)))
                    | _ => M.impossible "wrong number of arguments"
                    end))
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_allocate_for_slice :
      forall (T : Ty.t),
      M.IsAssociatedFunction.C (Self T) "allocate_for_slice" (allocate_for_slice T).
    Admitted.
    Global Typeclasses Opaque allocate_for_slice.
    
    (*
        unsafe fn copy_from_slice(v: &[T]) -> Rc<[T]> {
            unsafe {
                let ptr = Self::allocate_for_slice(v.len());
                ptr::copy_nonoverlapping(v.as_ptr(), (&raw mut ( *ptr).value) as *mut T, v.len());
                Self::from_ptr(ptr)
            }
        }
    *)
    Definition copy_from_slice
        (T : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [], [ v ] =>
        ltac:(M.monadic
          (let v := M.alloc (| v |) in
          M.read (|
            let~ ptr :
                Ty.apply
                  (Ty.path "*mut")
                  []
                  [
                    Ty.apply
                      (Ty.path "alloc::rc::RcInner")
                      []
                      [ Ty.apply (Ty.path "slice") [] [ T ] ]
                  ] :=
              M.alloc (|
                M.call_closure (|
                  Ty.apply
                    (Ty.path "*mut")
                    []
                    [
                      Ty.apply
                        (Ty.path "alloc::rc::RcInner")
                        []
                        [ Ty.apply (Ty.path "slice") [] [ T ] ]
                    ],
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "alloc::rc::Rc")
                      []
                      [ Ty.apply (Ty.path "slice") [] [ T ]; Ty.path "alloc::alloc::Global" ],
                    "allocate_for_slice",
                    [],
                    []
                  |),
                  [
                    M.call_closure (|
                      Ty.path "usize",
                      M.get_associated_function (|
                        Ty.apply (Ty.path "slice") [] [ T ],
                        "len",
                        [],
                        []
                      |),
                      [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| v |) |) |) ]
                    |)
                  ]
                |)
              |) in
            let~ _ : Ty.tuple [] :=
              M.alloc (|
                M.call_closure (|
                  Ty.tuple [],
                  M.get_function (| "core::intrinsics::copy_nonoverlapping", [], [ T ] |),
                  [
                    M.call_closure (|
                      Ty.apply (Ty.path "*const") [] [ T ],
                      M.get_associated_function (|
                        Ty.apply (Ty.path "slice") [] [ T ],
                        "as_ptr",
                        [],
                        []
                      |),
                      [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| v |) |) |) ]
                    |);
                    M.cast
                      (Ty.apply (Ty.path "*mut") [] [ T ])
                      (M.borrow (|
                        Pointer.Kind.MutPointer,
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| ptr |) |),
                          "alloc::rc::RcInner",
                          "value"
                        |)
                      |));
                    M.call_closure (|
                      Ty.path "usize",
                      M.get_associated_function (|
                        Ty.apply (Ty.path "slice") [] [ T ],
                        "len",
                        [],
                        []
                      |),
                      [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| v |) |) |) ]
                    |)
                  ]
                |)
              |) in
            M.alloc (|
              M.call_closure (|
                Ty.apply
                  (Ty.path "alloc::rc::Rc")
                  []
                  [ Ty.apply (Ty.path "slice") [] [ T ]; Ty.path "alloc::alloc::Global" ],
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "alloc::rc::Rc")
                    []
                    [ Ty.apply (Ty.path "slice") [] [ T ]; Ty.path "alloc::alloc::Global" ],
                  "from_ptr",
                  [],
                  []
                |),
                [ M.read (| ptr |) ]
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_copy_from_slice :
      forall (T : Ty.t),
      M.IsAssociatedFunction.C (Self T) "copy_from_slice" (copy_from_slice T).
    Admitted.
    Global Typeclasses Opaque copy_from_slice.
    
    (*
        unsafe fn from_iter_exact(iter: impl Iterator<Item = T>, len: usize) -> Rc<[T]> {
            // Panic guard while cloning T elements.
            // In the event of a panic, elements that have been written
            // into the new RcInner will be dropped, then the memory freed.
            struct Guard<T> {
                mem: NonNull<u8>,
                elems: *mut T,
                layout: Layout,
                n_elems: usize,
            }
    
            impl<T> Drop for Guard<T> {
                fn drop(&mut self) {
                    unsafe {
                        let slice = from_raw_parts_mut(self.elems, self.n_elems);
                        ptr::drop_in_place(slice);
    
                        Global.deallocate(self.mem, self.layout);
                    }
                }
            }
    
            unsafe {
                let ptr = Self::allocate_for_slice(len);
    
                let mem = ptr as *mut _ as *mut u8;
                let layout = Layout::for_value_raw(ptr);
    
                // Pointer to first element
                let elems = (&raw mut ( *ptr).value) as *mut T;
    
                let mut guard = Guard { mem: NonNull::new_unchecked(mem), elems, layout, n_elems: 0 };
    
                for (i, item) in iter.enumerate() {
                    ptr::write(elems.add(i), item);
                    guard.n_elems += 1;
                }
    
                // All clear. Forget the guard so it doesn't free the new RcInner.
                mem::forget(guard);
    
                Self::from_ptr(ptr)
            }
        }
    *)
    Definition from_iter_exact
        (T : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [ impl_Iterator_Item___T_ ], [ iter; len ] =>
        ltac:(M.monadic
          (let iter := M.alloc (| iter |) in
          let len := M.alloc (| len |) in
          M.read (|
            let~ ptr :
                Ty.apply
                  (Ty.path "*mut")
                  []
                  [
                    Ty.apply
                      (Ty.path "alloc::rc::RcInner")
                      []
                      [ Ty.apply (Ty.path "slice") [] [ T ] ]
                  ] :=
              M.alloc (|
                M.call_closure (|
                  Ty.apply
                    (Ty.path "*mut")
                    []
                    [
                      Ty.apply
                        (Ty.path "alloc::rc::RcInner")
                        []
                        [ Ty.apply (Ty.path "slice") [] [ T ] ]
                    ],
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "alloc::rc::Rc")
                      []
                      [ Ty.apply (Ty.path "slice") [] [ T ]; Ty.path "alloc::alloc::Global" ],
                    "allocate_for_slice",
                    [],
                    []
                  |),
                  [ M.read (| len |) ]
                |)
              |) in
            let~ mem : Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ] :=
              M.alloc (|
                M.cast
                  (Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ])
                  (M.cast
                    (Ty.apply
                      (Ty.path "*mut")
                      []
                      [
                        Ty.apply
                          (Ty.path "alloc::rc::RcInner")
                          []
                          [ Ty.apply (Ty.path "slice") [] [ T ] ]
                      ])
                    (M.read (| ptr |)))
              |) in
            let~ layout : Ty.path "core::alloc::layout::Layout" :=
              M.alloc (|
                M.call_closure (|
                  Ty.path "core::alloc::layout::Layout",
                  M.get_associated_function (|
                    Ty.path "core::alloc::layout::Layout",
                    "for_value_raw",
                    [],
                    [
                      Ty.apply
                        (Ty.path "alloc::rc::RcInner")
                        []
                        [ Ty.apply (Ty.path "slice") [] [ T ] ]
                    ]
                  |),
                  [ (* MutToConstPointer *) M.pointer_coercion (M.read (| ptr |)) ]
                |)
              |) in
            let~ elems : Ty.apply (Ty.path "*mut") [] [ T ] :=
              M.alloc (|
                M.cast
                  (Ty.apply (Ty.path "*mut") [] [ T ])
                  (M.borrow (|
                    Pointer.Kind.MutPointer,
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| ptr |) |),
                      "alloc::rc::RcInner",
                      "value"
                    |)
                  |))
              |) in
            let~ guard : Ty.apply (Ty.path "alloc::rc::from_iter_exact::Guard") [] [ T ] :=
              M.alloc (|
                Value.StructRecord
                  "alloc::rc::from_iter_exact::Guard"
                  [
                    ("mem",
                      M.call_closure (|
                        Ty.apply (Ty.path "core::ptr::non_null::NonNull") [] [ Ty.path "u8" ],
                        M.get_associated_function (|
                          Ty.apply (Ty.path "core::ptr::non_null::NonNull") [] [ Ty.path "u8" ],
                          "new_unchecked",
                          [],
                          []
                        |),
                        [ M.read (| mem |) ]
                      |));
                    ("elems", M.read (| elems |));
                    ("layout", M.read (| layout |));
                    ("n_elems", Value.Integer IntegerKind.Usize 0)
                  ]
              |) in
            let~ _ : Ty.tuple [] :=
              M.use
                (M.match_operator (|
                  Some (Ty.tuple []),
                  M.alloc (|
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "core::iter::adapters::enumerate::Enumerate")
                        []
                        [ impl_Iterator_Item___T_ ],
                      M.get_trait_method (|
                        "core::iter::traits::collect::IntoIterator",
                        Ty.apply
                          (Ty.path "core::iter::adapters::enumerate::Enumerate")
                          []
                          [ impl_Iterator_Item___T_ ],
                        [],
                        [],
                        "into_iter",
                        [],
                        []
                      |),
                      [
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "core::iter::adapters::enumerate::Enumerate")
                            []
                            [ impl_Iterator_Item___T_ ],
                          M.get_trait_method (|
                            "core::iter::traits::iterator::Iterator",
                            impl_Iterator_Item___T_,
                            [],
                            [],
                            "enumerate",
                            [],
                            []
                          |),
                          [ M.read (| iter |) ]
                        |)
                      ]
                    |)
                  |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let iter := M.copy (| γ |) in
                        M.loop (|
                          Ty.tuple [],
                          ltac:(M.monadic
                            (let~ _ : Ty.tuple [] :=
                              M.match_operator (|
                                Some (Ty.tuple []),
                                M.alloc (|
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "core::option::Option")
                                      []
                                      [ Ty.tuple [ Ty.path "usize"; T ] ],
                                    M.get_trait_method (|
                                      "core::iter::traits::iterator::Iterator",
                                      Ty.apply
                                        (Ty.path "core::iter::adapters::enumerate::Enumerate")
                                        []
                                        [ impl_Iterator_Item___T_ ],
                                      [],
                                      [],
                                      "next",
                                      [],
                                      []
                                    |),
                                    [
                                      M.borrow (|
                                        Pointer.Kind.MutRef,
                                        M.deref (| M.borrow (| Pointer.Kind.MutRef, iter |) |)
                                      |)
                                    ]
                                  |)
                                |),
                                [
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let _ :=
                                        M.is_struct_tuple (| γ, "core::option::Option::None" |) in
                                      M.alloc (|
                                        M.never_to_any (| M.read (| M.break (||) |) |)
                                      |)));
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let γ0_0 :=
                                        M.SubPointer.get_struct_tuple_field (|
                                          γ,
                                          "core::option::Option::Some",
                                          0
                                        |) in
                                      let γ1_0 := M.SubPointer.get_tuple_field (| γ0_0, 0 |) in
                                      let γ1_1 := M.SubPointer.get_tuple_field (| γ0_0, 1 |) in
                                      let i := M.copy (| γ1_0 |) in
                                      let item := M.copy (| γ1_1 |) in
                                      let~ _ : Ty.tuple [] :=
                                        M.alloc (|
                                          M.call_closure (|
                                            Ty.tuple [],
                                            M.get_function (| "core::ptr::write", [], [ T ] |),
                                            [
                                              M.call_closure (|
                                                Ty.apply (Ty.path "*mut") [] [ T ],
                                                M.get_associated_function (|
                                                  Ty.apply (Ty.path "*mut") [] [ T ],
                                                  "add",
                                                  [],
                                                  []
                                                |),
                                                [ M.read (| elems |); M.read (| i |) ]
                                              |);
                                              M.read (| item |)
                                            ]
                                          |)
                                        |) in
                                      let~ _ : Ty.tuple [] :=
                                        M.alloc (|
                                          let β :=
                                            M.SubPointer.get_struct_record_field (|
                                              guard,
                                              "alloc::rc::from_iter_exact::Guard",
                                              "n_elems"
                                            |) in
                                          M.write (|
                                            β,
                                            BinOp.Wrap.add (|
                                              M.read (| β |),
                                              Value.Integer IntegerKind.Usize 1
                                            |)
                                          |)
                                        |) in
                                      M.alloc (| Value.Tuple [] |)))
                                ]
                              |) in
                            M.alloc (| Value.Tuple [] |)))
                        |)))
                  ]
                |)) in
            let~ _ : Ty.tuple [] :=
              M.alloc (|
                M.call_closure (|
                  Ty.tuple [],
                  M.get_function (|
                    "core::mem::forget",
                    [],
                    [ Ty.apply (Ty.path "alloc::rc::from_iter_exact::Guard") [] [ T ] ]
                  |),
                  [ M.read (| guard |) ]
                |)
              |) in
            M.alloc (|
              M.call_closure (|
                Ty.apply
                  (Ty.path "alloc::rc::Rc")
                  []
                  [ Ty.apply (Ty.path "slice") [] [ T ]; Ty.path "alloc::alloc::Global" ],
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "alloc::rc::Rc")
                    []
                    [ Ty.apply (Ty.path "slice") [] [ T ]; Ty.path "alloc::alloc::Global" ],
                  "from_ptr",
                  [],
                  []
                |),
                [ M.read (| ptr |) ]
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_from_iter_exact :
      forall (T : Ty.t),
      M.IsAssociatedFunction.C (Self T) "from_iter_exact" (from_iter_exact T).
    Admitted.
    Global Typeclasses Opaque from_iter_exact.
  End Impl_alloc_rc_Rc_slice_T_alloc_alloc_Global.
  
  Module Impl_alloc_rc_Rc_slice_T_A.
    Definition Self (T A : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "alloc::rc::Rc") [] [ Ty.apply (Ty.path "slice") [] [ T ]; A ].
    
    (*
        pub fn new_uninit_slice_in(len: usize, alloc: A) -> Rc<[mem::MaybeUninit<T>], A> {
            unsafe { Rc::from_ptr_in(Rc::allocate_for_slice_in(len, &alloc), alloc) }
        }
    *)
    Definition new_uninit_slice_in
        (T A : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ len; alloc ] =>
        ltac:(M.monadic
          (let len := M.alloc (| len |) in
          let alloc := M.alloc (| alloc |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "alloc::rc::Rc")
              []
              [
                Ty.apply
                  (Ty.path "slice")
                  []
                  [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ] ];
                A
              ],
            M.get_associated_function (|
              Ty.apply
                (Ty.path "alloc::rc::Rc")
                []
                [
                  Ty.apply
                    (Ty.path "slice")
                    []
                    [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ] ];
                  A
                ],
              "from_ptr_in",
              [],
              []
            |),
            [
              M.call_closure (|
                Ty.apply
                  (Ty.path "*mut")
                  []
                  [
                    Ty.apply
                      (Ty.path "alloc::rc::RcInner")
                      []
                      [
                        Ty.apply
                          (Ty.path "slice")
                          []
                          [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ] ]
                      ]
                  ],
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "alloc::rc::Rc")
                    []
                    [
                      Ty.apply
                        (Ty.path "slice")
                        []
                        [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ] ];
                      A
                    ],
                  "allocate_for_slice_in",
                  [],
                  []
                |),
                [
                  M.read (| len |);
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (| M.borrow (| Pointer.Kind.Ref, alloc |) |)
                  |)
                ]
              |);
              M.read (| alloc |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_new_uninit_slice_in :
      forall (T A : Ty.t),
      M.IsAssociatedFunction.C (Self T A) "new_uninit_slice_in" (new_uninit_slice_in T A).
    Admitted.
    Global Typeclasses Opaque new_uninit_slice_in.
    
    (*
        pub fn new_zeroed_slice_in(len: usize, alloc: A) -> Rc<[mem::MaybeUninit<T>], A> {
            unsafe {
                Rc::from_ptr_in(
                    Rc::allocate_for_layout(
                        Layout::array::<T>(len).unwrap(),
                        |layout| alloc.allocate_zeroed(layout),
                        |mem| {
                            ptr::slice_from_raw_parts_mut(mem.cast::<T>(), len)
                                as *mut RcInner<[mem::MaybeUninit<T>]>
                        },
                    ),
                    alloc,
                )
            }
        }
    *)
    Definition new_zeroed_slice_in
        (T A : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ len; alloc ] =>
        ltac:(M.monadic
          (let len := M.alloc (| len |) in
          let alloc := M.alloc (| alloc |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "alloc::rc::Rc")
              []
              [
                Ty.apply
                  (Ty.path "slice")
                  []
                  [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ] ];
                A
              ],
            M.get_associated_function (|
              Ty.apply
                (Ty.path "alloc::rc::Rc")
                []
                [
                  Ty.apply
                    (Ty.path "slice")
                    []
                    [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ] ];
                  A
                ],
              "from_ptr_in",
              [],
              []
            |),
            [
              M.call_closure (|
                Ty.apply
                  (Ty.path "*mut")
                  []
                  [
                    Ty.apply
                      (Ty.path "alloc::rc::RcInner")
                      []
                      [
                        Ty.apply
                          (Ty.path "slice")
                          []
                          [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ] ]
                      ]
                  ],
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "alloc::rc::Rc")
                    []
                    [
                      Ty.apply
                        (Ty.path "slice")
                        []
                        [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ] ];
                      Ty.path "alloc::alloc::Global"
                    ],
                  "allocate_for_layout",
                  [],
                  [
                    Ty.function
                      [ Ty.tuple [ Ty.path "core::alloc::layout::Layout" ] ]
                      (Ty.apply
                        (Ty.path "core::result::Result")
                        []
                        [
                          Ty.apply
                            (Ty.path "core::ptr::non_null::NonNull")
                            []
                            [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ];
                          Ty.path "core::alloc::AllocError"
                        ]);
                    Ty.function
                      [ Ty.tuple [ Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ] ] ]
                      (Ty.apply
                        (Ty.path "*mut")
                        []
                        [
                          Ty.apply
                            (Ty.path "alloc::rc::RcInner")
                            []
                            [
                              Ty.apply
                                (Ty.path "slice")
                                []
                                [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ]
                                ]
                            ]
                        ])
                  ]
                |),
                [
                  M.call_closure (|
                    Ty.path "core::alloc::layout::Layout",
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "core::result::Result")
                        []
                        [
                          Ty.path "core::alloc::layout::Layout";
                          Ty.path "core::alloc::layout::LayoutError"
                        ],
                      "unwrap",
                      [],
                      []
                    |),
                    [
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [
                            Ty.path "core::alloc::layout::Layout";
                            Ty.path "core::alloc::layout::LayoutError"
                          ],
                        M.get_associated_function (|
                          Ty.path "core::alloc::layout::Layout",
                          "array",
                          [],
                          [ T ]
                        |),
                        [ M.read (| len |) ]
                      |)
                    ]
                  |);
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0 ] =>
                          ltac:(M.monadic
                            (M.match_operator (|
                              Some
                                (Ty.function
                                  [ Ty.tuple [ Ty.path "core::alloc::layout::Layout" ] ]
                                  (Ty.apply
                                    (Ty.path "core::result::Result")
                                    []
                                    [
                                      Ty.apply
                                        (Ty.path "core::ptr::non_null::NonNull")
                                        []
                                        [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ];
                                      Ty.path "core::alloc::AllocError"
                                    ])),
                              M.alloc (| α0 |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let layout := M.copy (| γ |) in
                                    M.call_closure (|
                                      Ty.apply
                                        (Ty.path "core::result::Result")
                                        []
                                        [
                                          Ty.apply
                                            (Ty.path "core::ptr::non_null::NonNull")
                                            []
                                            [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ];
                                          Ty.path "core::alloc::AllocError"
                                        ],
                                      M.get_trait_method (|
                                        "core::alloc::Allocator",
                                        A,
                                        [],
                                        [],
                                        "allocate_zeroed",
                                        [],
                                        []
                                      |),
                                      [ M.borrow (| Pointer.Kind.Ref, alloc |); M.read (| layout |)
                                      ]
                                    |)))
                              ]
                            |)))
                        | _ => M.impossible "wrong number of arguments"
                        end));
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0 ] =>
                          ltac:(M.monadic
                            (M.match_operator (|
                              Some
                                (Ty.function
                                  [ Ty.tuple [ Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ] ] ]
                                  (Ty.apply
                                    (Ty.path "*mut")
                                    []
                                    [
                                      Ty.apply
                                        (Ty.path "alloc::rc::RcInner")
                                        []
                                        [
                                          Ty.apply
                                            (Ty.path "slice")
                                            []
                                            [
                                              Ty.apply
                                                (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                                []
                                                [ T ]
                                            ]
                                        ]
                                    ])),
                              M.alloc (| α0 |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let mem := M.copy (| γ |) in
                                    M.cast
                                      (Ty.apply
                                        (Ty.path "*mut")
                                        []
                                        [
                                          Ty.apply
                                            (Ty.path "alloc::rc::RcInner")
                                            []
                                            [
                                              Ty.apply
                                                (Ty.path "slice")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                                    []
                                                    [ T ]
                                                ]
                                            ]
                                        ])
                                      (M.call_closure (|
                                        Ty.apply
                                          (Ty.path "*mut")
                                          []
                                          [ Ty.apply (Ty.path "slice") [] [ T ] ],
                                        M.get_function (|
                                          "core::ptr::slice_from_raw_parts_mut",
                                          [],
                                          [ T ]
                                        |),
                                        [
                                          M.call_closure (|
                                            Ty.apply (Ty.path "*mut") [] [ T ],
                                            M.get_associated_function (|
                                              Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ],
                                              "cast",
                                              [],
                                              [ T ]
                                            |),
                                            [ M.read (| mem |) ]
                                          |);
                                          M.read (| len |)
                                        ]
                                      |))))
                              ]
                            |)))
                        | _ => M.impossible "wrong number of arguments"
                        end))
                ]
              |);
              M.read (| alloc |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_new_zeroed_slice_in :
      forall (T A : Ty.t),
      M.IsAssociatedFunction.C (Self T A) "new_zeroed_slice_in" (new_zeroed_slice_in T A).
    Admitted.
    Global Typeclasses Opaque new_zeroed_slice_in.
    (*
        unsafe fn allocate_for_slice_in(len: usize, alloc: &A) -> *mut RcInner<[T]> {
            unsafe {
                Rc::<[T]>::allocate_for_layout(
                    Layout::array::<T>(len).unwrap(),
                    |layout| alloc.allocate(layout),
                    |mem| ptr::slice_from_raw_parts_mut(mem.cast::<T>(), len) as *mut RcInner<[T]>,
                )
            }
        }
    *)
    Definition allocate_for_slice_in
        (T A : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ len; alloc ] =>
        ltac:(M.monadic
          (let len := M.alloc (| len |) in
          let alloc := M.alloc (| alloc |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "*mut")
              []
              [ Ty.apply (Ty.path "alloc::rc::RcInner") [] [ Ty.apply (Ty.path "slice") [] [ T ] ]
              ],
            M.get_associated_function (|
              Ty.apply
                (Ty.path "alloc::rc::Rc")
                []
                [ Ty.apply (Ty.path "slice") [] [ T ]; Ty.path "alloc::alloc::Global" ],
              "allocate_for_layout",
              [],
              [
                Ty.function
                  [ Ty.tuple [ Ty.path "core::alloc::layout::Layout" ] ]
                  (Ty.apply
                    (Ty.path "core::result::Result")
                    []
                    [
                      Ty.apply
                        (Ty.path "core::ptr::non_null::NonNull")
                        []
                        [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ];
                      Ty.path "core::alloc::AllocError"
                    ]);
                Ty.function
                  [ Ty.tuple [ Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ] ] ]
                  (Ty.apply
                    (Ty.path "*mut")
                    []
                    [
                      Ty.apply
                        (Ty.path "alloc::rc::RcInner")
                        []
                        [ Ty.apply (Ty.path "slice") [] [ T ] ]
                    ])
              ]
            |),
            [
              M.call_closure (|
                Ty.path "core::alloc::layout::Layout",
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "core::result::Result")
                    []
                    [
                      Ty.path "core::alloc::layout::Layout";
                      Ty.path "core::alloc::layout::LayoutError"
                    ],
                  "unwrap",
                  [],
                  []
                |),
                [
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "core::result::Result")
                      []
                      [
                        Ty.path "core::alloc::layout::Layout";
                        Ty.path "core::alloc::layout::LayoutError"
                      ],
                    M.get_associated_function (|
                      Ty.path "core::alloc::layout::Layout",
                      "array",
                      [],
                      [ T ]
                    |),
                    [ M.read (| len |) ]
                  |)
                ]
              |);
              M.closure
                (fun γ =>
                  ltac:(M.monadic
                    match γ with
                    | [ α0 ] =>
                      ltac:(M.monadic
                        (M.match_operator (|
                          Some
                            (Ty.function
                              [ Ty.tuple [ Ty.path "core::alloc::layout::Layout" ] ]
                              (Ty.apply
                                (Ty.path "core::result::Result")
                                []
                                [
                                  Ty.apply
                                    (Ty.path "core::ptr::non_null::NonNull")
                                    []
                                    [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ];
                                  Ty.path "core::alloc::AllocError"
                                ])),
                          M.alloc (| α0 |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let layout := M.copy (| γ |) in
                                M.call_closure (|
                                  Ty.apply
                                    (Ty.path "core::result::Result")
                                    []
                                    [
                                      Ty.apply
                                        (Ty.path "core::ptr::non_null::NonNull")
                                        []
                                        [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ];
                                      Ty.path "core::alloc::AllocError"
                                    ],
                                  M.get_trait_method (|
                                    "core::alloc::Allocator",
                                    A,
                                    [],
                                    [],
                                    "allocate",
                                    [],
                                    []
                                  |),
                                  [
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.deref (| M.read (| alloc |) |)
                                    |);
                                    M.read (| layout |)
                                  ]
                                |)))
                          ]
                        |)))
                    | _ => M.impossible "wrong number of arguments"
                    end));
              M.closure
                (fun γ =>
                  ltac:(M.monadic
                    match γ with
                    | [ α0 ] =>
                      ltac:(M.monadic
                        (M.match_operator (|
                          Some
                            (Ty.function
                              [ Ty.tuple [ Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ] ] ]
                              (Ty.apply
                                (Ty.path "*mut")
                                []
                                [
                                  Ty.apply
                                    (Ty.path "alloc::rc::RcInner")
                                    []
                                    [ Ty.apply (Ty.path "slice") [] [ T ] ]
                                ])),
                          M.alloc (| α0 |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let mem := M.copy (| γ |) in
                                M.cast
                                  (Ty.apply
                                    (Ty.path "*mut")
                                    []
                                    [
                                      Ty.apply
                                        (Ty.path "alloc::rc::RcInner")
                                        []
                                        [ Ty.apply (Ty.path "slice") [] [ T ] ]
                                    ])
                                  (M.call_closure (|
                                    Ty.apply
                                      (Ty.path "*mut")
                                      []
                                      [ Ty.apply (Ty.path "slice") [] [ T ] ],
                                    M.get_function (|
                                      "core::ptr::slice_from_raw_parts_mut",
                                      [],
                                      [ T ]
                                    |),
                                    [
                                      M.call_closure (|
                                        Ty.apply (Ty.path "*mut") [] [ T ],
                                        M.get_associated_function (|
                                          Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ],
                                          "cast",
                                          [],
                                          [ T ]
                                        |),
                                        [ M.read (| mem |) ]
                                      |);
                                      M.read (| len |)
                                    ]
                                  |))))
                          ]
                        |)))
                    | _ => M.impossible "wrong number of arguments"
                    end))
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_allocate_for_slice_in :
      forall (T A : Ty.t),
      M.IsAssociatedFunction.C (Self T A) "allocate_for_slice_in" (allocate_for_slice_in T A).
    Admitted.
    Global Typeclasses Opaque allocate_for_slice_in.
  End Impl_alloc_rc_Rc_slice_T_A.
  
  Module Impl_alloc_rc_Rc_core_mem_maybe_uninit_MaybeUninit_T_A.
    Definition Self (T A : Ty.t) : Ty.t :=
      Ty.apply
        (Ty.path "alloc::rc::Rc")
        []
        [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ]; A ].
    
    (*
        pub unsafe fn assume_init(self) -> Rc<T, A> {
            let (ptr, alloc) = Rc::into_inner_with_allocator(self);
            unsafe { Rc::from_inner_in(ptr.cast(), alloc) }
        }
    *)
    Definition assume_init (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              None,
              M.alloc (|
                M.call_closure (|
                  Ty.tuple
                    [
                      Ty.apply
                        (Ty.path "core::ptr::non_null::NonNull")
                        []
                        [
                          Ty.apply
                            (Ty.path "alloc::rc::RcInner")
                            []
                            [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ] ]
                        ];
                      A
                    ],
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "alloc::rc::Rc")
                      []
                      [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ]; A ],
                    "into_inner_with_allocator",
                    [],
                    []
                  |),
                  [ M.read (| self |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let ptr := M.copy (| γ0_0 |) in
                    let alloc := M.copy (| γ0_1 |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply (Ty.path "alloc::rc::Rc") [] [ T; A ],
                        M.get_associated_function (|
                          Ty.apply (Ty.path "alloc::rc::Rc") [] [ T; A ],
                          "from_inner_in",
                          [],
                          []
                        |),
                        [
                          M.call_closure (|
                            Ty.apply
                              (Ty.path "core::ptr::non_null::NonNull")
                              []
                              [ Ty.apply (Ty.path "alloc::rc::RcInner") [] [ T ] ],
                            M.get_associated_function (|
                              Ty.apply
                                (Ty.path "core::ptr::non_null::NonNull")
                                []
                                [
                                  Ty.apply
                                    (Ty.path "alloc::rc::RcInner")
                                    []
                                    [
                                      Ty.apply
                                        (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                        []
                                        [ T ]
                                    ]
                                ],
                              "cast",
                              [],
                              [ Ty.apply (Ty.path "alloc::rc::RcInner") [] [ T ] ]
                            |),
                            [ M.read (| ptr |) ]
                          |);
                          M.read (| alloc |)
                        ]
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_assume_init :
      forall (T A : Ty.t),
      M.IsAssociatedFunction.C (Self T A) "assume_init" (assume_init T A).
    Admitted.
    Global Typeclasses Opaque assume_init.
  End Impl_alloc_rc_Rc_core_mem_maybe_uninit_MaybeUninit_T_A.
  
  Module Impl_alloc_rc_Rc_slice_core_mem_maybe_uninit_MaybeUninit_T_A.
    Definition Self (T A : Ty.t) : Ty.t :=
      Ty.apply
        (Ty.path "alloc::rc::Rc")
        []
        [
          Ty.apply
            (Ty.path "slice")
            []
            [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ] ];
          A
        ].
    
    (*
        pub unsafe fn assume_init(self) -> Rc<[T], A> {
            let (ptr, alloc) = Rc::into_inner_with_allocator(self);
            unsafe { Rc::from_ptr_in(ptr.as_ptr() as _, alloc) }
        }
    *)
    Definition assume_init (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              None,
              M.alloc (|
                M.call_closure (|
                  Ty.tuple
                    [
                      Ty.apply
                        (Ty.path "core::ptr::non_null::NonNull")
                        []
                        [
                          Ty.apply
                            (Ty.path "alloc::rc::RcInner")
                            []
                            [
                              Ty.apply
                                (Ty.path "slice")
                                []
                                [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ]
                                ]
                            ]
                        ];
                      A
                    ],
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "alloc::rc::Rc")
                      []
                      [
                        Ty.apply
                          (Ty.path "slice")
                          []
                          [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ] ];
                        A
                      ],
                    "into_inner_with_allocator",
                    [],
                    []
                  |),
                  [ M.read (| self |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let ptr := M.copy (| γ0_0 |) in
                    let alloc := M.copy (| γ0_1 |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "alloc::rc::Rc")
                          []
                          [ Ty.apply (Ty.path "slice") [] [ T ]; A ],
                        M.get_associated_function (|
                          Ty.apply
                            (Ty.path "alloc::rc::Rc")
                            []
                            [ Ty.apply (Ty.path "slice") [] [ T ]; A ],
                          "from_ptr_in",
                          [],
                          []
                        |),
                        [
                          M.cast
                            (Ty.apply
                              (Ty.path "*mut")
                              []
                              [
                                Ty.apply
                                  (Ty.path "alloc::rc::RcInner")
                                  []
                                  [ Ty.apply (Ty.path "slice") [] [ T ] ]
                              ])
                            (M.call_closure (|
                              Ty.apply
                                (Ty.path "*mut")
                                []
                                [
                                  Ty.apply
                                    (Ty.path "alloc::rc::RcInner")
                                    []
                                    [
                                      Ty.apply
                                        (Ty.path "slice")
                                        []
                                        [
                                          Ty.apply
                                            (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                            []
                                            [ T ]
                                        ]
                                    ]
                                ],
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "core::ptr::non_null::NonNull")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "alloc::rc::RcInner")
                                      []
                                      [
                                        Ty.apply
                                          (Ty.path "slice")
                                          []
                                          [
                                            Ty.apply
                                              (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                              []
                                              [ T ]
                                          ]
                                      ]
                                  ],
                                "as_ptr",
                                [],
                                []
                              |),
                              [ M.read (| ptr |) ]
                            |));
                          M.read (| alloc |)
                        ]
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_assume_init :
      forall (T A : Ty.t),
      M.IsAssociatedFunction.C (Self T A) "assume_init" (assume_init T A).
    Admitted.
    Global Typeclasses Opaque assume_init.
  End Impl_alloc_rc_Rc_slice_core_mem_maybe_uninit_MaybeUninit_T_A.
  
  
  
  
  
  Module Impl_alloc_rc_Rc_Dyn_core_any_Any_Trait_A.
    Definition Self (A : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "alloc::rc::Rc") [] [ Ty.dyn [ ("core::any::Any::Trait", []) ]; A ].
    
    (*
        pub fn downcast<T: Any>(self) -> Result<Rc<T, A>, Self> {
            if ( *self).is::<T>() {
                unsafe {
                    let (ptr, alloc) = Rc::into_inner_with_allocator(self);
                    Ok(Rc::from_inner_in(ptr.cast(), alloc))
                }
            } else {
                Err(self)
            }
        }
    *)
    Definition downcast (A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self A in
      match ε, τ, α with
      | [], [ T ], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              Some
                (Ty.apply
                  (Ty.path "core::result::Result")
                  []
                  [
                    Ty.apply (Ty.path "alloc::rc::Rc") [] [ T; A ];
                    Ty.apply
                      (Ty.path "alloc::rc::Rc")
                      []
                      [ Ty.dyn [ ("core::any::Any::Trait", []) ]; A ]
                  ]),
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          M.call_closure (|
                            Ty.path "bool",
                            M.get_associated_function (|
                              Ty.dyn [ ("core::any::Any::Trait", []) ],
                              "is",
                              [],
                              [ T ]
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "&")
                                      []
                                      [ Ty.dyn [ ("core::any::Any::Trait", []) ] ],
                                    M.get_trait_method (|
                                      "core::ops::deref::Deref",
                                      Ty.apply
                                        (Ty.path "alloc::rc::Rc")
                                        []
                                        [ Ty.dyn [ ("core::any::Any::Trait", []) ]; A ],
                                      [],
                                      [],
                                      "deref",
                                      [],
                                      []
                                    |),
                                    [ M.borrow (| Pointer.Kind.Ref, self |) ]
                                  |)
                                |)
                              |)
                            ]
                          |)
                        |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.match_operator (|
                      None,
                      M.alloc (|
                        M.call_closure (|
                          Ty.tuple
                            [
                              Ty.apply
                                (Ty.path "core::ptr::non_null::NonNull")
                                []
                                [
                                  Ty.apply
                                    (Ty.path "alloc::rc::RcInner")
                                    []
                                    [ Ty.dyn [ ("core::any::Any::Trait", []) ] ]
                                ];
                              A
                            ],
                          M.get_associated_function (|
                            Ty.apply
                              (Ty.path "alloc::rc::Rc")
                              []
                              [ Ty.dyn [ ("core::any::Any::Trait", []) ]; A ],
                            "into_inner_with_allocator",
                            [],
                            []
                          |),
                          [ M.read (| self |) ]
                        |)
                      |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                            let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                            let ptr := M.copy (| γ0_0 |) in
                            let alloc := M.copy (| γ0_1 |) in
                            M.alloc (|
                              Value.StructTuple
                                "core::result::Result::Ok"
                                [
                                  M.call_closure (|
                                    Ty.apply (Ty.path "alloc::rc::Rc") [] [ T; A ],
                                    M.get_associated_function (|
                                      Ty.apply (Ty.path "alloc::rc::Rc") [] [ T; A ],
                                      "from_inner_in",
                                      [],
                                      []
                                    |),
                                    [
                                      M.call_closure (|
                                        Ty.apply
                                          (Ty.path "core::ptr::non_null::NonNull")
                                          []
                                          [ Ty.apply (Ty.path "alloc::rc::RcInner") [] [ T ] ],
                                        M.get_associated_function (|
                                          Ty.apply
                                            (Ty.path "core::ptr::non_null::NonNull")
                                            []
                                            [
                                              Ty.apply
                                                (Ty.path "alloc::rc::RcInner")
                                                []
                                                [ Ty.dyn [ ("core::any::Any::Trait", []) ] ]
                                            ],
                                          "cast",
                                          [],
                                          [ Ty.apply (Ty.path "alloc::rc::RcInner") [] [ T ] ]
                                        |),
                                        [ M.read (| ptr |) ]
                                      |);
                                      M.read (| alloc |)
                                    ]
                                  |)
                                ]
                            |)))
                      ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      Value.StructTuple "core::result::Result::Err" [ M.read (| self |) ]
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_downcast :
      forall (A : Ty.t),
      M.IsAssociatedFunction.C (Self A) "downcast" (downcast A).
    Admitted.
    Global Typeclasses Opaque downcast.
    
    (*
        pub unsafe fn downcast_unchecked<T: Any>(self) -> Rc<T, A> {
            unsafe {
                let (ptr, alloc) = Rc::into_inner_with_allocator(self);
                Rc::from_inner_in(ptr.cast(), alloc)
            }
        }
    *)
    Definition downcast_unchecked
        (A : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self A in
      match ε, τ, α with
      | [], [ T ], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              None,
              M.alloc (|
                M.call_closure (|
                  Ty.tuple
                    [
                      Ty.apply
                        (Ty.path "core::ptr::non_null::NonNull")
                        []
                        [
                          Ty.apply
                            (Ty.path "alloc::rc::RcInner")
                            []
                            [ Ty.dyn [ ("core::any::Any::Trait", []) ] ]
                        ];
                      A
                    ],
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "alloc::rc::Rc")
                      []
                      [ Ty.dyn [ ("core::any::Any::Trait", []) ]; A ],
                    "into_inner_with_allocator",
                    [],
                    []
                  |),
                  [ M.read (| self |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let ptr := M.copy (| γ0_0 |) in
                    let alloc := M.copy (| γ0_1 |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply (Ty.path "alloc::rc::Rc") [] [ T; A ],
                        M.get_associated_function (|
                          Ty.apply (Ty.path "alloc::rc::Rc") [] [ T; A ],
                          "from_inner_in",
                          [],
                          []
                        |),
                        [
                          M.call_closure (|
                            Ty.apply
                              (Ty.path "core::ptr::non_null::NonNull")
                              []
                              [ Ty.apply (Ty.path "alloc::rc::RcInner") [] [ T ] ],
                            M.get_associated_function (|
                              Ty.apply
                                (Ty.path "core::ptr::non_null::NonNull")
                                []
                                [
                                  Ty.apply
                                    (Ty.path "alloc::rc::RcInner")
                                    []
                                    [ Ty.dyn [ ("core::any::Any::Trait", []) ] ]
                                ],
                              "cast",
                              [],
                              [ Ty.apply (Ty.path "alloc::rc::RcInner") [] [ T ] ]
                            |),
                            [ M.read (| ptr |) ]
                          |);
                          M.read (| alloc |)
                        ]
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_downcast_unchecked :
      forall (A : Ty.t),
      M.IsAssociatedFunction.C (Self A) "downcast_unchecked" (downcast_unchecked A).
    Admitted.
    Global Typeclasses Opaque downcast_unchecked.
  End Impl_alloc_rc_Rc_Dyn_core_any_Any_Trait_A.
  
  
  
  
  
  (* Trait *)
  (* Empty module 'RcFromSlice' *)
  
  Module Impl_alloc_rc_RcFromSlice_where_core_clone_Clone_T_T_for_alloc_rc_Rc_slice_T_alloc_alloc_Global.
    Definition Self (T : Ty.t) : Ty.t :=
      Ty.apply
        (Ty.path "alloc::rc::Rc")
        []
        [ Ty.apply (Ty.path "slice") [] [ T ]; Ty.path "alloc::alloc::Global" ].
    
    (*
        default fn from_slice(v: &[T]) -> Self {
            unsafe { Self::from_iter_exact(v.iter().cloned(), v.len()) }
        }
    *)
    Definition from_slice (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [], [ v ] =>
        ltac:(M.monadic
          (let v := M.alloc (| v |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "alloc::rc::Rc")
              []
              [ Ty.apply (Ty.path "slice") [] [ T ]; Ty.path "alloc::alloc::Global" ],
            M.get_associated_function (|
              Ty.apply
                (Ty.path "alloc::rc::Rc")
                []
                [ Ty.apply (Ty.path "slice") [] [ T ]; Ty.path "alloc::alloc::Global" ],
              "from_iter_exact",
              [],
              [
                Ty.apply
                  (Ty.path "core::iter::adapters::cloned::Cloned")
                  []
                  [ Ty.apply (Ty.path "core::slice::iter::Iter") [] [ T ] ]
              ]
            |),
            [
              M.call_closure (|
                Ty.apply
                  (Ty.path "core::iter::adapters::cloned::Cloned")
                  []
                  [ Ty.apply (Ty.path "core::slice::iter::Iter") [] [ T ] ],
                M.get_trait_method (|
                  "core::iter::traits::iterator::Iterator",
                  Ty.apply (Ty.path "core::slice::iter::Iter") [] [ T ],
                  [],
                  [],
                  "cloned",
                  [],
                  [ T ]
                |),
                [
                  M.call_closure (|
                    Ty.apply (Ty.path "core::slice::iter::Iter") [] [ T ],
                    M.get_associated_function (|
                      Ty.apply (Ty.path "slice") [] [ T ],
                      "iter",
                      [],
                      []
                    |),
                    [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| v |) |) |) ]
                  |)
                ]
              |);
              M.call_closure (|
                Ty.path "usize",
                M.get_associated_function (| Ty.apply (Ty.path "slice") [] [ T ], "len", [], [] |),
                [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| v |) |) |) ]
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "alloc::rc::RcFromSlice"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ T ]
        (Self T)
        (* Instance *) [ ("from_slice", InstanceField.Method (from_slice T)) ].
  End Impl_alloc_rc_RcFromSlice_where_core_clone_Clone_T_T_for_alloc_rc_Rc_slice_T_alloc_alloc_Global.
  
  Module Impl_alloc_rc_RcFromSlice_where_core_marker_Copy_T_T_for_alloc_rc_Rc_slice_T_alloc_alloc_Global.
    Definition Self (T : Ty.t) : Ty.t :=
      Ty.apply
        (Ty.path "alloc::rc::Rc")
        []
        [ Ty.apply (Ty.path "slice") [] [ T ]; Ty.path "alloc::alloc::Global" ].
    
    (*
        fn from_slice(v: &[T]) -> Self {
            unsafe { Rc::copy_from_slice(v) }
        }
    *)
    Definition from_slice (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [], [ v ] =>
        ltac:(M.monadic
          (let v := M.alloc (| v |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "alloc::rc::Rc")
              []
              [ Ty.apply (Ty.path "slice") [] [ T ]; Ty.path "alloc::alloc::Global" ],
            M.get_associated_function (|
              Ty.apply
                (Ty.path "alloc::rc::Rc")
                []
                [ Ty.apply (Ty.path "slice") [] [ T ]; Ty.path "alloc::alloc::Global" ],
              "copy_from_slice",
              [],
              []
            |),
            [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| v |) |) |) ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "alloc::rc::RcFromSlice"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ T ]
        (Self T)
        (* Instance *) [ ("from_slice", InstanceField.Method (from_slice T)) ].
  End Impl_alloc_rc_RcFromSlice_where_core_marker_Copy_T_T_for_alloc_rc_Rc_slice_T_alloc_alloc_Global.
  
  Module Impl_core_ops_deref_Deref_where_core_marker_Sized_T_where_core_alloc_Allocator_A_for_alloc_rc_Rc_T_A.
    Definition Self (T A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::rc::Rc") [] [ T; A ].
    
    (*     type Target = T; *)
    Definition _Target (T A : Ty.t) : Ty.t := T.
    
    (*
        fn deref(&self) -> &T {
            &self.inner().value
        }
    *)
    Definition deref (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.borrow (|
            Pointer.Kind.Ref,
            M.deref (|
              M.borrow (|
                Pointer.Kind.Ref,
                M.SubPointer.get_struct_record_field (|
                  M.deref (|
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "&")
                        []
                        [ Ty.apply (Ty.path "alloc::rc::RcInner") [] [ T ] ],
                      M.get_associated_function (|
                        Ty.apply (Ty.path "alloc::rc::Rc") [] [ T; A ],
                        "inner",
                        [],
                        []
                      |),
                      [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                    |)
                  |),
                  "alloc::rc::RcInner",
                  "value"
                |)
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (T A : Ty.t),
      M.IsTraitInstance
        "core::ops::deref::Deref"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self T A)
        (* Instance *)
        [ ("Target", InstanceField.Ty (_Target T A)); ("deref", InstanceField.Method (deref T A)) ].
  End Impl_core_ops_deref_Deref_where_core_marker_Sized_T_where_core_alloc_Allocator_A_for_alloc_rc_Rc_T_A.
  
  Module Impl_core_pin_PinCoerceUnsized_where_core_marker_Sized_T_where_core_alloc_Allocator_A_for_alloc_rc_Rc_T_A.
    Definition Self (T A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::rc::Rc") [] [ T; A ].
    
    Axiom Implements :
      forall (T A : Ty.t),
      M.IsTraitInstance
        "core::pin::PinCoerceUnsized"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self T A)
        (* Instance *) [].
  End Impl_core_pin_PinCoerceUnsized_where_core_marker_Sized_T_where_core_alloc_Allocator_A_for_alloc_rc_Rc_T_A.
  
  Module Impl_core_pin_PinCoerceUnsized_where_core_marker_Sized_T_where_core_alloc_Allocator_A_for_alloc_rc_Weak_T_A.
    Definition Self (T A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::rc::Weak") [] [ T; A ].
    
    Axiom Implements :
      forall (T A : Ty.t),
      M.IsTraitInstance
        "core::pin::PinCoerceUnsized"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self T A)
        (* Instance *) [].
  End Impl_core_pin_PinCoerceUnsized_where_core_marker_Sized_T_where_core_alloc_Allocator_A_for_alloc_rc_Weak_T_A.
  
  Module Impl_core_ops_deref_DerefPure_where_core_marker_Sized_T_where_core_alloc_Allocator_A_for_alloc_rc_Rc_T_A.
    Definition Self (T A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::rc::Rc") [] [ T; A ].
    
    Axiom Implements :
      forall (T A : Ty.t),
      M.IsTraitInstance
        "core::ops::deref::DerefPure"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self T A)
        (* Instance *) [].
  End Impl_core_ops_deref_DerefPure_where_core_marker_Sized_T_where_core_alloc_Allocator_A_for_alloc_rc_Rc_T_A.
  
  Module Impl_core_ops_deref_LegacyReceiver_where_core_marker_Sized_T_for_alloc_rc_Rc_T_alloc_alloc_Global.
    Definition Self (T : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "alloc::rc::Rc") [] [ T; Ty.path "alloc::alloc::Global" ].
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "core::ops::deref::LegacyReceiver"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self T)
        (* Instance *) [].
  End Impl_core_ops_deref_LegacyReceiver_where_core_marker_Sized_T_for_alloc_rc_Rc_T_alloc_alloc_Global.
  
  Module Impl_core_ops_drop_Drop_where_core_marker_Sized_T_where_core_alloc_Allocator_A_for_alloc_rc_Rc_T_A.
    Definition Self (T A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::rc::Rc") [] [ T; A ].
    
    (*
        fn drop(&mut self) {
            unsafe {
                self.inner().dec_strong();
                if self.inner().strong() == 0 {
                    self.drop_slow();
                }
            }
        }
    *)
    Definition drop (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            let~ _ : Ty.tuple [] :=
              M.alloc (|
                M.call_closure (|
                  Ty.tuple [],
                  M.get_trait_method (|
                    "alloc::rc::RcInnerPtr",
                    Ty.apply (Ty.path "alloc::rc::RcInner") [] [ T ],
                    [],
                    [],
                    "dec_strong",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "&")
                            []
                            [ Ty.apply (Ty.path "alloc::rc::RcInner") [] [ T ] ],
                          M.get_associated_function (|
                            Ty.apply (Ty.path "alloc::rc::Rc") [] [ T; A ],
                            "inner",
                            [],
                            []
                          |),
                          [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                        |)
                      |)
                    |)
                  ]
                |)
              |) in
            M.match_operator (|
              Some (Ty.tuple []),
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          BinOp.eq (|
                            M.call_closure (|
                              Ty.path "usize",
                              M.get_trait_method (|
                                "alloc::rc::RcInnerPtr",
                                Ty.apply (Ty.path "alloc::rc::RcInner") [] [ T ],
                                [],
                                [],
                                "strong",
                                [],
                                []
                              |),
                              [
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.deref (|
                                    M.call_closure (|
                                      Ty.apply
                                        (Ty.path "&")
                                        []
                                        [ Ty.apply (Ty.path "alloc::rc::RcInner") [] [ T ] ],
                                      M.get_associated_function (|
                                        Ty.apply (Ty.path "alloc::rc::Rc") [] [ T; A ],
                                        "inner",
                                        [],
                                        []
                                      |),
                                      [
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.deref (| M.read (| self |) |)
                                        |)
                                      ]
                                    |)
                                  |)
                                |)
                              ]
                            |),
                            Value.Integer IntegerKind.Usize 0
                          |)
                        |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    let~ _ : Ty.tuple [] :=
                      M.alloc (|
                        M.call_closure (|
                          Ty.tuple [],
                          M.get_associated_function (|
                            Ty.apply (Ty.path "alloc::rc::Rc") [] [ T; A ],
                            "drop_slow",
                            [],
                            []
                          |),
                          [ M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |) ]
                        |)
                      |) in
                    M.alloc (| Value.Tuple [] |)));
                fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (T A : Ty.t),
      M.IsTraitInstance
        "core::ops::drop::Drop"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self T A)
        (* Instance *) [ ("drop", InstanceField.Method (drop T A)) ].
  End Impl_core_ops_drop_Drop_where_core_marker_Sized_T_where_core_alloc_Allocator_A_for_alloc_rc_Rc_T_A.
  
  Module Impl_core_clone_Clone_where_core_marker_Sized_T_where_core_alloc_Allocator_A_where_core_clone_Clone_A_for_alloc_rc_Rc_T_A.
    Definition Self (T A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::rc::Rc") [] [ T; A ].
    
    (*
        fn clone(&self) -> Self {
            unsafe {
                self.inner().inc_strong();
                Self::from_inner_in(self.ptr, self.alloc.clone())
            }
        }
    *)
    Definition clone (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            let~ _ : Ty.tuple [] :=
              M.alloc (|
                M.call_closure (|
                  Ty.tuple [],
                  M.get_trait_method (|
                    "alloc::rc::RcInnerPtr",
                    Ty.apply (Ty.path "alloc::rc::RcInner") [] [ T ],
                    [],
                    [],
                    "inc_strong",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "&")
                            []
                            [ Ty.apply (Ty.path "alloc::rc::RcInner") [] [ T ] ],
                          M.get_associated_function (|
                            Ty.apply (Ty.path "alloc::rc::Rc") [] [ T; A ],
                            "inner",
                            [],
                            []
                          |),
                          [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                        |)
                      |)
                    |)
                  ]
                |)
              |) in
            M.alloc (|
              M.call_closure (|
                Ty.apply (Ty.path "alloc::rc::Rc") [] [ T; A ],
                M.get_associated_function (|
                  Ty.apply (Ty.path "alloc::rc::Rc") [] [ T; A ],
                  "from_inner_in",
                  [],
                  []
                |),
                [
                  M.read (|
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| self |) |),
                      "alloc::rc::Rc",
                      "ptr"
                    |)
                  |);
                  M.call_closure (|
                    A,
                    M.get_trait_method (| "core::clone::Clone", A, [], [], "clone", [], [] |),
                    [
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "alloc::rc::Rc",
                          "alloc"
                        |)
                      |)
                    ]
                  |)
                ]
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (T A : Ty.t),
      M.IsTraitInstance
        "core::clone::Clone"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self T A)
        (* Instance *) [ ("clone", InstanceField.Method (clone T A)) ].
  End Impl_core_clone_Clone_where_core_marker_Sized_T_where_core_alloc_Allocator_A_where_core_clone_Clone_A_for_alloc_rc_Rc_T_A.
  
  Module Impl_core_default_Default_where_core_default_Default_T_for_alloc_rc_Rc_T_alloc_alloc_Global.
    Definition Self (T : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "alloc::rc::Rc") [] [ T; Ty.path "alloc::alloc::Global" ].
    
    (*
        fn default() -> Rc<T> {
            unsafe {
                Self::from_inner(
                    Box::leak(Box::write(Box::new_uninit(), RcInner {
                        strong: Cell::new(1),
                        weak: Cell::new(1),
                        value: T::default(),
                    }))
                    .into(),
                )
            }
        }
    *)
    Definition default (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [], [] =>
        ltac:(M.monadic
          (M.call_closure (|
            Ty.apply (Ty.path "alloc::rc::Rc") [] [ T; Ty.path "alloc::alloc::Global" ],
            M.get_associated_function (|
              Ty.apply (Ty.path "alloc::rc::Rc") [] [ T; Ty.path "alloc::alloc::Global" ],
              "from_inner",
              [],
              []
            |),
            [
              M.call_closure (|
                Ty.apply
                  (Ty.path "core::ptr::non_null::NonNull")
                  []
                  [ Ty.apply (Ty.path "alloc::rc::RcInner") [] [ T ] ],
                M.get_trait_method (|
                  "core::convert::Into",
                  Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "alloc::rc::RcInner") [] [ T ] ],
                  [],
                  [
                    Ty.apply
                      (Ty.path "core::ptr::non_null::NonNull")
                      []
                      [ Ty.apply (Ty.path "alloc::rc::RcInner") [] [ T ] ]
                  ],
                  "into",
                  [],
                  []
                |),
                [
                  M.borrow (|
                    Pointer.Kind.MutRef,
                    M.deref (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "&mut")
                          []
                          [ Ty.apply (Ty.path "alloc::rc::RcInner") [] [ T ] ],
                        M.get_associated_function (|
                          Ty.apply
                            (Ty.path "alloc::boxed::Box")
                            []
                            [
                              Ty.apply (Ty.path "alloc::rc::RcInner") [] [ T ];
                              Ty.path "alloc::alloc::Global"
                            ],
                          "leak",
                          [],
                          []
                        |),
                        [
                          M.call_closure (|
                            Ty.apply
                              (Ty.path "alloc::boxed::Box")
                              []
                              [
                                Ty.apply (Ty.path "alloc::rc::RcInner") [] [ T ];
                                Ty.path "alloc::alloc::Global"
                              ],
                            M.get_associated_function (|
                              Ty.apply
                                (Ty.path "alloc::boxed::Box")
                                []
                                [
                                  Ty.apply
                                    (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                    []
                                    [ Ty.apply (Ty.path "alloc::rc::RcInner") [] [ T ] ];
                                  Ty.path "alloc::alloc::Global"
                                ],
                              "write",
                              [],
                              []
                            |),
                            [
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "alloc::boxed::Box")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                      []
                                      [ Ty.apply (Ty.path "alloc::rc::RcInner") [] [ T ] ];
                                    Ty.path "alloc::alloc::Global"
                                  ],
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "alloc::boxed::Box")
                                    []
                                    [
                                      Ty.apply (Ty.path "alloc::rc::RcInner") [] [ T ];
                                      Ty.path "alloc::alloc::Global"
                                    ],
                                  "new_uninit",
                                  [],
                                  []
                                |),
                                []
                              |);
                              Value.StructRecord
                                "alloc::rc::RcInner"
                                [
                                  ("strong",
                                    M.call_closure (|
                                      Ty.apply (Ty.path "core::cell::Cell") [] [ Ty.path "usize" ],
                                      M.get_associated_function (|
                                        Ty.apply
                                          (Ty.path "core::cell::Cell")
                                          []
                                          [ Ty.path "usize" ],
                                        "new",
                                        [],
                                        []
                                      |),
                                      [ Value.Integer IntegerKind.Usize 1 ]
                                    |));
                                  ("weak",
                                    M.call_closure (|
                                      Ty.apply (Ty.path "core::cell::Cell") [] [ Ty.path "usize" ],
                                      M.get_associated_function (|
                                        Ty.apply
                                          (Ty.path "core::cell::Cell")
                                          []
                                          [ Ty.path "usize" ],
                                        "new",
                                        [],
                                        []
                                      |),
                                      [ Value.Integer IntegerKind.Usize 1 ]
                                    |));
                                  ("value",
                                    M.call_closure (|
                                      T,
                                      M.get_trait_method (|
                                        "core::default::Default",
                                        T,
                                        [],
                                        [],
                                        "default",
                                        [],
                                        []
                                      |),
                                      []
                                    |))
                                ]
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)
                ]
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "core::default::Default"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self T)
        (* Instance *) [ ("default", InstanceField.Method (default T)) ].
  End Impl_core_default_Default_where_core_default_Default_T_for_alloc_rc_Rc_T_alloc_alloc_Global.
  
  Module Impl_core_default_Default_for_alloc_rc_Rc_str_alloc_alloc_Global.
    Definition Self : Ty.t :=
      Ty.apply (Ty.path "alloc::rc::Rc") [] [ Ty.path "str"; Ty.path "alloc::alloc::Global" ].
    
    (*
        fn default() -> Self {
            Rc::from("")
        }
    *)
    Definition default (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [] =>
        ltac:(M.monadic
          (M.call_closure (|
            Ty.apply (Ty.path "alloc::rc::Rc") [] [ Ty.path "str"; Ty.path "alloc::alloc::Global" ],
            M.get_trait_method (|
              "core::convert::From",
              Ty.apply
                (Ty.path "alloc::rc::Rc")
                []
                [ Ty.path "str"; Ty.path "alloc::alloc::Global" ],
              [],
              [ Ty.apply (Ty.path "&") [] [ Ty.path "str" ] ],
              "from",
              [],
              []
            |),
            [ mk_str (| "" |) ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::default::Default"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("default", InstanceField.Method default) ].
  End Impl_core_default_Default_for_alloc_rc_Rc_str_alloc_alloc_Global.
  
  Module Impl_core_default_Default_for_alloc_rc_Rc_slice_T_alloc_alloc_Global.
    Definition Self (T : Ty.t) : Ty.t :=
      Ty.apply
        (Ty.path "alloc::rc::Rc")
        []
        [ Ty.apply (Ty.path "slice") [] [ T ]; Ty.path "alloc::alloc::Global" ].
    
    (*
        fn default() -> Self {
            let arr: [T; 0] = [];
            Rc::from(arr)
        }
    *)
    Definition default (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [], [] =>
        ltac:(M.monadic
          (M.read (|
            let~ arr : Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 0 ] [ T ] :=
              M.alloc (| Value.Array [] |) in
            M.alloc (|
              M.call_closure (|
                Ty.apply
                  (Ty.path "alloc::rc::Rc")
                  []
                  [ Ty.apply (Ty.path "slice") [] [ T ]; Ty.path "alloc::alloc::Global" ],
                M.get_trait_method (|
                  "core::convert::From",
                  Ty.apply
                    (Ty.path "alloc::rc::Rc")
                    []
                    [ Ty.apply (Ty.path "slice") [] [ T ]; Ty.path "alloc::alloc::Global" ],
                  [],
                  [ Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 0 ] [ T ] ],
                  "from",
                  [],
                  []
                |),
                [ M.read (| arr |) ]
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "core::default::Default"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self T)
        (* Instance *) [ ("default", InstanceField.Method (default T)) ].
  End Impl_core_default_Default_for_alloc_rc_Rc_slice_T_alloc_alloc_Global.
  
  (* Trait *)
  (* Empty module 'RcEqIdent' *)
  
  Module Impl_alloc_rc_RcEqIdent_where_core_marker_Sized_T_where_core_cmp_PartialEq_T_where_core_alloc_Allocator_A_T_A_for_alloc_rc_Rc_T_A.
    Definition Self (T A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::rc::Rc") [] [ T; A ].
    
    (*
        default fn eq(&self, other: &Rc<T, A>) -> bool {
            **self == **other
        }
    *)
    Definition eq (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            Ty.path "bool",
            M.get_trait_method (| "core::cmp::PartialEq", T, [], [ T ], "eq", [], [] |),
            [
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.call_closure (|
                    Ty.apply (Ty.path "&") [] [ T ],
                    M.get_trait_method (|
                      "core::ops::deref::Deref",
                      Ty.apply (Ty.path "alloc::rc::Rc") [] [ T; A ],
                      [],
                      [],
                      "deref",
                      [],
                      []
                    |),
                    [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                  |)
                |)
              |);
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.call_closure (|
                    Ty.apply (Ty.path "&") [] [ T ],
                    M.get_trait_method (|
                      "core::ops::deref::Deref",
                      Ty.apply (Ty.path "alloc::rc::Rc") [] [ T; A ],
                      [],
                      [],
                      "deref",
                      [],
                      []
                    |),
                    [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| other |) |) |) ]
                  |)
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    (*
        default fn ne(&self, other: &Rc<T, A>) -> bool {
            **self != **other
        }
    *)
    Definition ne (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            Ty.path "bool",
            M.get_trait_method (| "core::cmp::PartialEq", T, [], [ T ], "ne", [], [] |),
            [
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.call_closure (|
                    Ty.apply (Ty.path "&") [] [ T ],
                    M.get_trait_method (|
                      "core::ops::deref::Deref",
                      Ty.apply (Ty.path "alloc::rc::Rc") [] [ T; A ],
                      [],
                      [],
                      "deref",
                      [],
                      []
                    |),
                    [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                  |)
                |)
              |);
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.call_closure (|
                    Ty.apply (Ty.path "&") [] [ T ],
                    M.get_trait_method (|
                      "core::ops::deref::Deref",
                      Ty.apply (Ty.path "alloc::rc::Rc") [] [ T; A ],
                      [],
                      [],
                      "deref",
                      [],
                      []
                    |),
                    [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| other |) |) |) ]
                  |)
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (T A : Ty.t),
      M.IsTraitInstance
        "alloc::rc::RcEqIdent"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ T; A ]
        (Self T A)
        (* Instance *)
        [ ("eq", InstanceField.Method (eq T A)); ("ne", InstanceField.Method (ne T A)) ].
  End Impl_alloc_rc_RcEqIdent_where_core_marker_Sized_T_where_core_cmp_PartialEq_T_where_core_alloc_Allocator_A_T_A_for_alloc_rc_Rc_T_A.
  
  (* Trait *)
  (* Empty module 'MarkerEq' *)
  
  Module Impl_alloc_rc_MarkerEq_where_core_cmp_Eq_T_for_T.
    Definition Self (T : Ty.t) : Ty.t := T.
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "alloc::rc::MarkerEq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self T)
        (* Instance *) [].
  End Impl_alloc_rc_MarkerEq_where_core_cmp_Eq_T_for_T.
  
  Module Impl_alloc_rc_RcEqIdent_where_core_marker_Sized_T_where_alloc_rc_MarkerEq_T_where_core_alloc_Allocator_A_T_A_for_alloc_rc_Rc_T_A.
    Definition Self (T A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::rc::Rc") [] [ T; A ].
    
    (*
        fn eq(&self, other: &Rc<T, A>) -> bool {
            Rc::ptr_eq(self, other) || **self == **other
        }
    *)
    Definition eq (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          LogicalOp.or (|
            M.call_closure (|
              Ty.path "bool",
              M.get_associated_function (|
                Ty.apply (Ty.path "alloc::rc::Rc") [] [ T; A ],
                "ptr_eq",
                [],
                []
              |),
              [
                M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |);
                M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| other |) |) |)
              ]
            |),
            ltac:(M.monadic
              (M.call_closure (|
                Ty.path "bool",
                M.get_trait_method (| "core::cmp::PartialEq", T, [], [ T ], "eq", [], [] |),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.call_closure (|
                        Ty.apply (Ty.path "&") [] [ T ],
                        M.get_trait_method (|
                          "core::ops::deref::Deref",
                          Ty.apply (Ty.path "alloc::rc::Rc") [] [ T; A ],
                          [],
                          [],
                          "deref",
                          [],
                          []
                        |),
                        [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                      |)
                    |)
                  |);
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.call_closure (|
                        Ty.apply (Ty.path "&") [] [ T ],
                        M.get_trait_method (|
                          "core::ops::deref::Deref",
                          Ty.apply (Ty.path "alloc::rc::Rc") [] [ T; A ],
                          [],
                          [],
                          "deref",
                          [],
                          []
                        |),
                        [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| other |) |) |) ]
                      |)
                    |)
                  |)
                ]
              |)))
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    (*
        fn ne(&self, other: &Rc<T, A>) -> bool {
            !Rc::ptr_eq(self, other) && **self != **other
        }
    *)
    Definition ne (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          LogicalOp.and (|
            UnOp.not (|
              M.call_closure (|
                Ty.path "bool",
                M.get_associated_function (|
                  Ty.apply (Ty.path "alloc::rc::Rc") [] [ T; A ],
                  "ptr_eq",
                  [],
                  []
                |),
                [
                  M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |);
                  M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| other |) |) |)
                ]
              |)
            |),
            ltac:(M.monadic
              (M.call_closure (|
                Ty.path "bool",
                M.get_trait_method (| "core::cmp::PartialEq", T, [], [ T ], "ne", [], [] |),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.call_closure (|
                        Ty.apply (Ty.path "&") [] [ T ],
                        M.get_trait_method (|
                          "core::ops::deref::Deref",
                          Ty.apply (Ty.path "alloc::rc::Rc") [] [ T; A ],
                          [],
                          [],
                          "deref",
                          [],
                          []
                        |),
                        [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                      |)
                    |)
                  |);
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.call_closure (|
                        Ty.apply (Ty.path "&") [] [ T ],
                        M.get_trait_method (|
                          "core::ops::deref::Deref",
                          Ty.apply (Ty.path "alloc::rc::Rc") [] [ T; A ],
                          [],
                          [],
                          "deref",
                          [],
                          []
                        |),
                        [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| other |) |) |) ]
                      |)
                    |)
                  |)
                ]
              |)))
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (T A : Ty.t),
      M.IsTraitInstance
        "alloc::rc::RcEqIdent"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ T; A ]
        (Self T A)
        (* Instance *)
        [ ("eq", InstanceField.Method (eq T A)); ("ne", InstanceField.Method (ne T A)) ].
  End Impl_alloc_rc_RcEqIdent_where_core_marker_Sized_T_where_alloc_rc_MarkerEq_T_where_core_alloc_Allocator_A_T_A_for_alloc_rc_Rc_T_A.
  
  Module Impl_core_cmp_PartialEq_where_core_marker_Sized_T_where_core_cmp_PartialEq_T_where_core_alloc_Allocator_A_alloc_rc_Rc_T_A_for_alloc_rc_Rc_T_A.
    Definition Self (T A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::rc::Rc") [] [ T; A ].
    
    (*
        fn eq(&self, other: &Rc<T, A>) -> bool {
            RcEqIdent::eq(self, other)
        }
    *)
    Definition eq (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            Ty.path "bool",
            M.get_trait_method (|
              "alloc::rc::RcEqIdent",
              Ty.apply (Ty.path "alloc::rc::Rc") [] [ T; A ],
              [],
              [ T; A ],
              "eq",
              [],
              []
            |),
            [
              M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |);
              M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| other |) |) |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    (*
        fn ne(&self, other: &Rc<T, A>) -> bool {
            RcEqIdent::ne(self, other)
        }
    *)
    Definition ne (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            Ty.path "bool",
            M.get_trait_method (|
              "alloc::rc::RcEqIdent",
              Ty.apply (Ty.path "alloc::rc::Rc") [] [ T; A ],
              [],
              [ T; A ],
              "ne",
              [],
              []
            |),
            [
              M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |);
              M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| other |) |) |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (T A : Ty.t),
      M.IsTraitInstance
        "core::cmp::PartialEq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.apply (Ty.path "alloc::rc::Rc") [] [ T; A ] ]
        (Self T A)
        (* Instance *)
        [ ("eq", InstanceField.Method (eq T A)); ("ne", InstanceField.Method (ne T A)) ].
  End Impl_core_cmp_PartialEq_where_core_marker_Sized_T_where_core_cmp_PartialEq_T_where_core_alloc_Allocator_A_alloc_rc_Rc_T_A_for_alloc_rc_Rc_T_A.
  
  Module Impl_core_cmp_Eq_where_core_marker_Sized_T_where_core_cmp_Eq_T_where_core_alloc_Allocator_A_for_alloc_rc_Rc_T_A.
    Definition Self (T A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::rc::Rc") [] [ T; A ].
    
    Axiom Implements :
      forall (T A : Ty.t),
      M.IsTraitInstance
        "core::cmp::Eq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self T A)
        (* Instance *) [].
  End Impl_core_cmp_Eq_where_core_marker_Sized_T_where_core_cmp_Eq_T_where_core_alloc_Allocator_A_for_alloc_rc_Rc_T_A.
  
  Module Impl_core_cmp_PartialOrd_where_core_marker_Sized_T_where_core_cmp_PartialOrd_T_where_core_alloc_Allocator_A_alloc_rc_Rc_T_A_for_alloc_rc_Rc_T_A.
    Definition Self (T A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::rc::Rc") [] [ T; A ].
    
    (*
        fn partial_cmp(&self, other: &Rc<T, A>) -> Option<Ordering> {
            ( **self).partial_cmp(&**other)
        }
    *)
    Definition partial_cmp (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "core::cmp::Ordering" ],
            M.get_trait_method (| "core::cmp::PartialOrd", T, [], [ T ], "partial_cmp", [], [] |),
            [
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.call_closure (|
                    Ty.apply (Ty.path "&") [] [ T ],
                    M.get_trait_method (|
                      "core::ops::deref::Deref",
                      Ty.apply (Ty.path "alloc::rc::Rc") [] [ T; A ],
                      [],
                      [],
                      "deref",
                      [],
                      []
                    |),
                    [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                  |)
                |)
              |);
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.call_closure (|
                        Ty.apply (Ty.path "&") [] [ T ],
                        M.get_trait_method (|
                          "core::ops::deref::Deref",
                          Ty.apply (Ty.path "alloc::rc::Rc") [] [ T; A ],
                          [],
                          [],
                          "deref",
                          [],
                          []
                        |),
                        [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| other |) |) |) ]
                      |)
                    |)
                  |)
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    (*
        fn lt(&self, other: &Rc<T, A>) -> bool {
            **self < **other
        }
    *)
    Definition lt (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            Ty.path "bool",
            M.get_trait_method (| "core::cmp::PartialOrd", T, [], [ T ], "lt", [], [] |),
            [
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.call_closure (|
                    Ty.apply (Ty.path "&") [] [ T ],
                    M.get_trait_method (|
                      "core::ops::deref::Deref",
                      Ty.apply (Ty.path "alloc::rc::Rc") [] [ T; A ],
                      [],
                      [],
                      "deref",
                      [],
                      []
                    |),
                    [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                  |)
                |)
              |);
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.call_closure (|
                    Ty.apply (Ty.path "&") [] [ T ],
                    M.get_trait_method (|
                      "core::ops::deref::Deref",
                      Ty.apply (Ty.path "alloc::rc::Rc") [] [ T; A ],
                      [],
                      [],
                      "deref",
                      [],
                      []
                    |),
                    [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| other |) |) |) ]
                  |)
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    (*
        fn le(&self, other: &Rc<T, A>) -> bool {
            **self <= **other
        }
    *)
    Definition le (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            Ty.path "bool",
            M.get_trait_method (| "core::cmp::PartialOrd", T, [], [ T ], "le", [], [] |),
            [
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.call_closure (|
                    Ty.apply (Ty.path "&") [] [ T ],
                    M.get_trait_method (|
                      "core::ops::deref::Deref",
                      Ty.apply (Ty.path "alloc::rc::Rc") [] [ T; A ],
                      [],
                      [],
                      "deref",
                      [],
                      []
                    |),
                    [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                  |)
                |)
              |);
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.call_closure (|
                    Ty.apply (Ty.path "&") [] [ T ],
                    M.get_trait_method (|
                      "core::ops::deref::Deref",
                      Ty.apply (Ty.path "alloc::rc::Rc") [] [ T; A ],
                      [],
                      [],
                      "deref",
                      [],
                      []
                    |),
                    [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| other |) |) |) ]
                  |)
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    (*
        fn gt(&self, other: &Rc<T, A>) -> bool {
            **self > **other
        }
    *)
    Definition gt (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            Ty.path "bool",
            M.get_trait_method (| "core::cmp::PartialOrd", T, [], [ T ], "gt", [], [] |),
            [
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.call_closure (|
                    Ty.apply (Ty.path "&") [] [ T ],
                    M.get_trait_method (|
                      "core::ops::deref::Deref",
                      Ty.apply (Ty.path "alloc::rc::Rc") [] [ T; A ],
                      [],
                      [],
                      "deref",
                      [],
                      []
                    |),
                    [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                  |)
                |)
              |);
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.call_closure (|
                    Ty.apply (Ty.path "&") [] [ T ],
                    M.get_trait_method (|
                      "core::ops::deref::Deref",
                      Ty.apply (Ty.path "alloc::rc::Rc") [] [ T; A ],
                      [],
                      [],
                      "deref",
                      [],
                      []
                    |),
                    [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| other |) |) |) ]
                  |)
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    (*
        fn ge(&self, other: &Rc<T, A>) -> bool {
            **self >= **other
        }
    *)
    Definition ge (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            Ty.path "bool",
            M.get_trait_method (| "core::cmp::PartialOrd", T, [], [ T ], "ge", [], [] |),
            [
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.call_closure (|
                    Ty.apply (Ty.path "&") [] [ T ],
                    M.get_trait_method (|
                      "core::ops::deref::Deref",
                      Ty.apply (Ty.path "alloc::rc::Rc") [] [ T; A ],
                      [],
                      [],
                      "deref",
                      [],
                      []
                    |),
                    [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                  |)
                |)
              |);
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.call_closure (|
                    Ty.apply (Ty.path "&") [] [ T ],
                    M.get_trait_method (|
                      "core::ops::deref::Deref",
                      Ty.apply (Ty.path "alloc::rc::Rc") [] [ T; A ],
                      [],
                      [],
                      "deref",
                      [],
                      []
                    |),
                    [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| other |) |) |) ]
                  |)
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (T A : Ty.t),
      M.IsTraitInstance
        "core::cmp::PartialOrd"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.apply (Ty.path "alloc::rc::Rc") [] [ T; A ] ]
        (Self T A)
        (* Instance *)
        [
          ("partial_cmp", InstanceField.Method (partial_cmp T A));
          ("lt", InstanceField.Method (lt T A));
          ("le", InstanceField.Method (le T A));
          ("gt", InstanceField.Method (gt T A));
          ("ge", InstanceField.Method (ge T A))
        ].
  End Impl_core_cmp_PartialOrd_where_core_marker_Sized_T_where_core_cmp_PartialOrd_T_where_core_alloc_Allocator_A_alloc_rc_Rc_T_A_for_alloc_rc_Rc_T_A.
  
  Module Impl_core_cmp_Ord_where_core_marker_Sized_T_where_core_cmp_Ord_T_where_core_alloc_Allocator_A_for_alloc_rc_Rc_T_A.
    Definition Self (T A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::rc::Rc") [] [ T; A ].
    
    (*
        fn cmp(&self, other: &Rc<T, A>) -> Ordering {
            ( **self).cmp(&**other)
        }
    *)
    Definition cmp (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            Ty.path "core::cmp::Ordering",
            M.get_trait_method (| "core::cmp::Ord", T, [], [], "cmp", [], [] |),
            [
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.call_closure (|
                    Ty.apply (Ty.path "&") [] [ T ],
                    M.get_trait_method (|
                      "core::ops::deref::Deref",
                      Ty.apply (Ty.path "alloc::rc::Rc") [] [ T; A ],
                      [],
                      [],
                      "deref",
                      [],
                      []
                    |),
                    [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                  |)
                |)
              |);
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.call_closure (|
                        Ty.apply (Ty.path "&") [] [ T ],
                        M.get_trait_method (|
                          "core::ops::deref::Deref",
                          Ty.apply (Ty.path "alloc::rc::Rc") [] [ T; A ],
                          [],
                          [],
                          "deref",
                          [],
                          []
                        |),
                        [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| other |) |) |) ]
                      |)
                    |)
                  |)
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (T A : Ty.t),
      M.IsTraitInstance
        "core::cmp::Ord"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self T A)
        (* Instance *) [ ("cmp", InstanceField.Method (cmp T A)) ].
  End Impl_core_cmp_Ord_where_core_marker_Sized_T_where_core_cmp_Ord_T_where_core_alloc_Allocator_A_for_alloc_rc_Rc_T_A.
  
  Module Impl_core_hash_Hash_where_core_marker_Sized_T_where_core_hash_Hash_T_where_core_alloc_Allocator_A_for_alloc_rc_Rc_T_A.
    Definition Self (T A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::rc::Rc") [] [ T; A ].
    
    (*
        fn hash<H: Hasher>(&self, state: &mut H) {
            ( **self).hash(state);
        }
    *)
    Definition hash (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [ H ], [ self; state ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let state := M.alloc (| state |) in
          M.read (|
            let~ _ : Ty.tuple [] :=
              M.alloc (|
                M.call_closure (|
                  Ty.tuple [],
                  M.get_trait_method (| "core::hash::Hash", T, [], [], "hash", [], [ H ] |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.call_closure (|
                          Ty.apply (Ty.path "&") [] [ T ],
                          M.get_trait_method (|
                            "core::ops::deref::Deref",
                            Ty.apply (Ty.path "alloc::rc::Rc") [] [ T; A ],
                            [],
                            [],
                            "deref",
                            [],
                            []
                          |),
                          [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                        |)
                      |)
                    |);
                    M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                  ]
                |)
              |) in
            M.alloc (| Value.Tuple [] |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (T A : Ty.t),
      M.IsTraitInstance
        "core::hash::Hash"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self T A)
        (* Instance *) [ ("hash", InstanceField.Method (hash T A)) ].
  End Impl_core_hash_Hash_where_core_marker_Sized_T_where_core_hash_Hash_T_where_core_alloc_Allocator_A_for_alloc_rc_Rc_T_A.
  
  Module Impl_core_fmt_Display_where_core_marker_Sized_T_where_core_fmt_Display_T_where_core_alloc_Allocator_A_for_alloc_rc_Rc_T_A.
    Definition Self (T A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::rc::Rc") [] [ T; A ].
    
    (*
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            fmt::Display::fmt(&**self, f)
        }
    *)
    Definition fmt (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "core::result::Result")
              []
              [ Ty.tuple []; Ty.path "core::fmt::Error" ],
            M.get_trait_method (| "core::fmt::Display", T, [], [], "fmt", [], [] |),
            [
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.call_closure (|
                        Ty.apply (Ty.path "&") [] [ T ],
                        M.get_trait_method (|
                          "core::ops::deref::Deref",
                          Ty.apply (Ty.path "alloc::rc::Rc") [] [ T; A ],
                          [],
                          [],
                          "deref",
                          [],
                          []
                        |),
                        [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                      |)
                    |)
                  |)
                |)
              |);
              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (T A : Ty.t),
      M.IsTraitInstance
        "core::fmt::Display"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self T A)
        (* Instance *) [ ("fmt", InstanceField.Method (fmt T A)) ].
  End Impl_core_fmt_Display_where_core_marker_Sized_T_where_core_fmt_Display_T_where_core_alloc_Allocator_A_for_alloc_rc_Rc_T_A.
  
  Module Impl_core_fmt_Debug_where_core_marker_Sized_T_where_core_fmt_Debug_T_where_core_alloc_Allocator_A_for_alloc_rc_Rc_T_A.
    Definition Self (T A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::rc::Rc") [] [ T; A ].
    
    (*
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            fmt::Debug::fmt(&**self, f)
        }
    *)
    Definition fmt (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "core::result::Result")
              []
              [ Ty.tuple []; Ty.path "core::fmt::Error" ],
            M.get_trait_method (| "core::fmt::Debug", T, [], [], "fmt", [], [] |),
            [
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.call_closure (|
                        Ty.apply (Ty.path "&") [] [ T ],
                        M.get_trait_method (|
                          "core::ops::deref::Deref",
                          Ty.apply (Ty.path "alloc::rc::Rc") [] [ T; A ],
                          [],
                          [],
                          "deref",
                          [],
                          []
                        |),
                        [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                      |)
                    |)
                  |)
                |)
              |);
              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (T A : Ty.t),
      M.IsTraitInstance
        "core::fmt::Debug"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self T A)
        (* Instance *) [ ("fmt", InstanceField.Method (fmt T A)) ].
  End Impl_core_fmt_Debug_where_core_marker_Sized_T_where_core_fmt_Debug_T_where_core_alloc_Allocator_A_for_alloc_rc_Rc_T_A.
  
  Module Impl_core_fmt_Pointer_where_core_marker_Sized_T_where_core_alloc_Allocator_A_for_alloc_rc_Rc_T_A.
    Definition Self (T A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::rc::Rc") [] [ T; A ].
    
    (*
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            fmt::Pointer::fmt(&(&raw const **self), f)
        }
    *)
    Definition fmt (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "core::result::Result")
              []
              [ Ty.tuple []; Ty.path "core::fmt::Error" ],
            M.get_trait_method (|
              "core::fmt::Pointer",
              Ty.apply (Ty.path "*const") [] [ T ],
              [],
              [],
              "fmt",
              [],
              []
            |),
            [
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.alloc (|
                      M.borrow (|
                        Pointer.Kind.ConstPointer,
                        M.deref (|
                          M.call_closure (|
                            Ty.apply (Ty.path "&") [] [ T ],
                            M.get_trait_method (|
                              "core::ops::deref::Deref",
                              Ty.apply (Ty.path "alloc::rc::Rc") [] [ T; A ],
                              [],
                              [],
                              "deref",
                              [],
                              []
                            |),
                            [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                          |)
                        |)
                      |)
                    |)
                  |)
                |)
              |);
              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (T A : Ty.t),
      M.IsTraitInstance
        "core::fmt::Pointer"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self T A)
        (* Instance *) [ ("fmt", InstanceField.Method (fmt T A)) ].
  End Impl_core_fmt_Pointer_where_core_marker_Sized_T_where_core_alloc_Allocator_A_for_alloc_rc_Rc_T_A.
  
  Module Impl_core_convert_From_T_for_alloc_rc_Rc_T_alloc_alloc_Global.
    Definition Self (T : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "alloc::rc::Rc") [] [ T; Ty.path "alloc::alloc::Global" ].
    
    (*
        fn from(t: T) -> Self {
            Rc::new(t)
        }
    *)
    Definition from (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [], [ t ] =>
        ltac:(M.monadic
          (let t := M.alloc (| t |) in
          M.call_closure (|
            Ty.apply (Ty.path "alloc::rc::Rc") [] [ T; Ty.path "alloc::alloc::Global" ],
            M.get_associated_function (|
              Ty.apply (Ty.path "alloc::rc::Rc") [] [ T; Ty.path "alloc::alloc::Global" ],
              "new",
              [],
              []
            |),
            [ M.read (| t |) ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "core::convert::From"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ T ]
        (Self T)
        (* Instance *) [ ("from", InstanceField.Method (from T)) ].
  End Impl_core_convert_From_T_for_alloc_rc_Rc_T_alloc_alloc_Global.
  
  Module Impl_core_convert_From_array_N_T_for_alloc_rc_Rc_slice_T_alloc_alloc_Global.
    Definition Self (N : Value.t) (T : Ty.t) : Ty.t :=
      Ty.apply
        (Ty.path "alloc::rc::Rc")
        []
        [ Ty.apply (Ty.path "slice") [] [ T ]; Ty.path "alloc::alloc::Global" ].
    
    (*
        fn from(v: [T; N]) -> Rc<[T]> {
            Rc::<[T; N]>::from(v)
        }
    *)
    Definition from
        (N : Value.t)
        (T : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self N T in
      match ε, τ, α with
      | [], [], [ v ] =>
        ltac:(M.monadic
          (let v := M.alloc (| v |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "alloc::rc::Rc")
              []
              [ Ty.apply (Ty.path "array") [ N ] [ T ]; Ty.path "alloc::alloc::Global" ],
            M.get_trait_method (|
              "core::convert::From",
              Ty.apply
                (Ty.path "alloc::rc::Rc")
                []
                [ Ty.apply (Ty.path "array") [ N ] [ T ]; Ty.path "alloc::alloc::Global" ],
              [],
              [ Ty.apply (Ty.path "array") [ N ] [ T ] ],
              "from",
              [],
              []
            |),
            [ M.read (| v |) ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (N : Value.t) (T : Ty.t),
      M.IsTraitInstance
        "core::convert::From"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.apply (Ty.path "array") [ N ] [ T ] ]
        (Self N T)
        (* Instance *) [ ("from", InstanceField.Method (from N T)) ].
  End Impl_core_convert_From_array_N_T_for_alloc_rc_Rc_slice_T_alloc_alloc_Global.
  
  Module Impl_core_convert_From_where_core_clone_Clone_T_ref__slice_T_for_alloc_rc_Rc_slice_T_alloc_alloc_Global.
    Definition Self (T : Ty.t) : Ty.t :=
      Ty.apply
        (Ty.path "alloc::rc::Rc")
        []
        [ Ty.apply (Ty.path "slice") [] [ T ]; Ty.path "alloc::alloc::Global" ].
    
    (*
        fn from(v: &[T]) -> Rc<[T]> {
            <Self as RcFromSlice<T>>::from_slice(v)
        }
    *)
    Definition from (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [], [ v ] =>
        ltac:(M.monadic
          (let v := M.alloc (| v |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "alloc::rc::Rc")
              []
              [ Ty.apply (Ty.path "slice") [] [ T ]; Ty.path "alloc::alloc::Global" ],
            M.get_trait_method (|
              "alloc::rc::RcFromSlice",
              Ty.apply
                (Ty.path "alloc::rc::Rc")
                []
                [ Ty.apply (Ty.path "slice") [] [ T ]; Ty.path "alloc::alloc::Global" ],
              [],
              [ T ],
              "from_slice",
              [],
              []
            |),
            [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| v |) |) |) ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "core::convert::From"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *)
        [ Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ T ] ] ]
        (Self T)
        (* Instance *) [ ("from", InstanceField.Method (from T)) ].
  End Impl_core_convert_From_where_core_clone_Clone_T_ref__slice_T_for_alloc_rc_Rc_slice_T_alloc_alloc_Global.
  
  Module Impl_core_convert_From_where_core_clone_Clone_T_ref_mut_slice_T_for_alloc_rc_Rc_slice_T_alloc_alloc_Global.
    Definition Self (T : Ty.t) : Ty.t :=
      Ty.apply
        (Ty.path "alloc::rc::Rc")
        []
        [ Ty.apply (Ty.path "slice") [] [ T ]; Ty.path "alloc::alloc::Global" ].
    
    (*
        fn from(v: &mut [T]) -> Rc<[T]> {
            Rc::from(&*v)
        }
    *)
    Definition from (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [], [ v ] =>
        ltac:(M.monadic
          (let v := M.alloc (| v |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "alloc::rc::Rc")
              []
              [ Ty.apply (Ty.path "slice") [] [ T ]; Ty.path "alloc::alloc::Global" ],
            M.get_trait_method (|
              "core::convert::From",
              Ty.apply
                (Ty.path "alloc::rc::Rc")
                []
                [ Ty.apply (Ty.path "slice") [] [ T ]; Ty.path "alloc::alloc::Global" ],
              [],
              [ Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ T ] ] ],
              "from",
              [],
              []
            |),
            [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| v |) |) |) ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "core::convert::From"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *)
        [ Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "slice") [] [ T ] ] ]
        (Self T)
        (* Instance *) [ ("from", InstanceField.Method (from T)) ].
  End Impl_core_convert_From_where_core_clone_Clone_T_ref_mut_slice_T_for_alloc_rc_Rc_slice_T_alloc_alloc_Global.
  
  Module Impl_core_convert_From_ref__str_for_alloc_rc_Rc_str_alloc_alloc_Global.
    Definition Self : Ty.t :=
      Ty.apply (Ty.path "alloc::rc::Rc") [] [ Ty.path "str"; Ty.path "alloc::alloc::Global" ].
    
    (*
        fn from(v: &str) -> Rc<str> {
            let rc = Rc::<[u8]>::from(v.as_bytes());
            unsafe { Rc::from_raw(Rc::into_raw(rc) as *const str) }
        }
    *)
    Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ v ] =>
        ltac:(M.monadic
          (let v := M.alloc (| v |) in
          M.read (|
            let~ rc :
                Ty.apply
                  (Ty.path "alloc::rc::Rc")
                  []
                  [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ]; Ty.path "alloc::alloc::Global"
                  ] :=
              M.alloc (|
                M.call_closure (|
                  Ty.apply
                    (Ty.path "alloc::rc::Rc")
                    []
                    [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ]; Ty.path "alloc::alloc::Global"
                    ],
                  M.get_trait_method (|
                    "core::convert::From",
                    Ty.apply
                      (Ty.path "alloc::rc::Rc")
                      []
                      [
                        Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ];
                        Ty.path "alloc::alloc::Global"
                      ],
                    [],
                    [ Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
                    ],
                    "from",
                    [],
                    []
                  |),
                  [
                    M.call_closure (|
                      Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                      M.get_associated_function (| Ty.path "str", "as_bytes", [], [] |),
                      [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| v |) |) |) ]
                    |)
                  ]
                |)
              |) in
            M.alloc (|
              M.call_closure (|
                Ty.apply
                  (Ty.path "alloc::rc::Rc")
                  []
                  [ Ty.path "str"; Ty.path "alloc::alloc::Global" ],
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "alloc::rc::Rc")
                    []
                    [ Ty.path "str"; Ty.path "alloc::alloc::Global" ],
                  "from_raw",
                  [],
                  []
                |),
                [
                  M.cast
                    (Ty.apply (Ty.path "*const") [] [ Ty.path "str" ])
                    (M.call_closure (|
                      Ty.apply
                        (Ty.path "*const")
                        []
                        [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "alloc::rc::Rc")
                          []
                          [
                            Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ];
                            Ty.path "alloc::alloc::Global"
                          ],
                        "into_raw",
                        [],
                        []
                      |),
                      [ M.read (| rc |) ]
                    |))
                ]
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::convert::From"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.apply (Ty.path "&") [] [ Ty.path "str" ] ]
        Self
        (* Instance *) [ ("from", InstanceField.Method from) ].
  End Impl_core_convert_From_ref__str_for_alloc_rc_Rc_str_alloc_alloc_Global.
  
  Module Impl_core_convert_From_ref_mut_str_for_alloc_rc_Rc_str_alloc_alloc_Global.
    Definition Self : Ty.t :=
      Ty.apply (Ty.path "alloc::rc::Rc") [] [ Ty.path "str"; Ty.path "alloc::alloc::Global" ].
    
    (*
        fn from(v: &mut str) -> Rc<str> {
            Rc::from(&*v)
        }
    *)
    Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ v ] =>
        ltac:(M.monadic
          (let v := M.alloc (| v |) in
          M.call_closure (|
            Ty.apply (Ty.path "alloc::rc::Rc") [] [ Ty.path "str"; Ty.path "alloc::alloc::Global" ],
            M.get_trait_method (|
              "core::convert::From",
              Ty.apply
                (Ty.path "alloc::rc::Rc")
                []
                [ Ty.path "str"; Ty.path "alloc::alloc::Global" ],
              [],
              [ Ty.apply (Ty.path "&") [] [ Ty.path "str" ] ],
              "from",
              [],
              []
            |),
            [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| v |) |) |) ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::convert::From"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.apply (Ty.path "&mut") [] [ Ty.path "str" ] ]
        Self
        (* Instance *) [ ("from", InstanceField.Method from) ].
  End Impl_core_convert_From_ref_mut_str_for_alloc_rc_Rc_str_alloc_alloc_Global.
  
  Module Impl_core_convert_From_alloc_string_String_for_alloc_rc_Rc_str_alloc_alloc_Global.
    Definition Self : Ty.t :=
      Ty.apply (Ty.path "alloc::rc::Rc") [] [ Ty.path "str"; Ty.path "alloc::alloc::Global" ].
    
    (*
        fn from(v: String) -> Rc<str> {
            Rc::from(&v[..])
        }
    *)
    Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ v ] =>
        ltac:(M.monadic
          (let v := M.alloc (| v |) in
          M.call_closure (|
            Ty.apply (Ty.path "alloc::rc::Rc") [] [ Ty.path "str"; Ty.path "alloc::alloc::Global" ],
            M.get_trait_method (|
              "core::convert::From",
              Ty.apply
                (Ty.path "alloc::rc::Rc")
                []
                [ Ty.path "str"; Ty.path "alloc::alloc::Global" ],
              [],
              [ Ty.apply (Ty.path "&") [] [ Ty.path "str" ] ],
              "from",
              [],
              []
            |),
            [
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.call_closure (|
                    Ty.apply (Ty.path "&") [] [ Ty.path "str" ],
                    M.get_trait_method (|
                      "core::ops::index::Index",
                      Ty.path "alloc::string::String",
                      [],
                      [ Ty.path "core::ops::range::RangeFull" ],
                      "index",
                      [],
                      []
                    |),
                    [
                      M.borrow (| Pointer.Kind.Ref, v |);
                      Value.StructTuple "core::ops::range::RangeFull" []
                    ]
                  |)
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::convert::From"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.path "alloc::string::String" ]
        Self
        (* Instance *) [ ("from", InstanceField.Method from) ].
  End Impl_core_convert_From_alloc_string_String_for_alloc_rc_Rc_str_alloc_alloc_Global.
  
  Module Impl_core_convert_From_where_core_marker_Sized_T_where_core_alloc_Allocator_A_alloc_boxed_Box_T_A_for_alloc_rc_Rc_T_A.
    Definition Self (T A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::rc::Rc") [] [ T; A ].
    
    (*
        fn from(v: Box<T, A>) -> Rc<T, A> {
            Rc::from_box_in(v)
        }
    *)
    Definition from (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ v ] =>
        ltac:(M.monadic
          (let v := M.alloc (| v |) in
          M.call_closure (|
            Ty.apply (Ty.path "alloc::rc::Rc") [] [ T; A ],
            M.get_associated_function (|
              Ty.apply (Ty.path "alloc::rc::Rc") [] [ T; A ],
              "from_box_in",
              [],
              []
            |),
            [ M.read (| v |) ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (T A : Ty.t),
      M.IsTraitInstance
        "core::convert::From"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.apply (Ty.path "alloc::boxed::Box") [] [ T; A ] ]
        (Self T A)
        (* Instance *) [ ("from", InstanceField.Method (from T A)) ].
  End Impl_core_convert_From_where_core_marker_Sized_T_where_core_alloc_Allocator_A_alloc_boxed_Box_T_A_for_alloc_rc_Rc_T_A.
  
  Module Impl_core_convert_From_where_core_alloc_Allocator_A_alloc_vec_Vec_T_A_for_alloc_rc_Rc_slice_T_A.
    Definition Self (T A : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "alloc::rc::Rc") [] [ Ty.apply (Ty.path "slice") [] [ T ]; A ].
    
    (*
        fn from(v: Vec<T, A>) -> Rc<[T], A> {
            unsafe {
                let (vec_ptr, len, cap, alloc) = v.into_raw_parts_with_alloc();
    
                let rc_ptr = Self::allocate_for_slice_in(len, &alloc);
                ptr::copy_nonoverlapping(vec_ptr, (&raw mut ( *rc_ptr).value) as *mut T, len);
    
                // Create a `Vec<T, &A>` with length 0, to deallocate the buffer
                // without dropping its contents or the allocator
                let _ = Vec::from_raw_parts_in(vec_ptr, 0, cap, &alloc);
    
                Self::from_ptr_in(rc_ptr, alloc)
            }
        }
    *)
    Definition from (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ v ] =>
        ltac:(M.monadic
          (let v := M.alloc (| v |) in
          M.read (|
            M.match_operator (|
              None,
              M.alloc (|
                M.call_closure (|
                  Ty.tuple
                    [ Ty.apply (Ty.path "*mut") [] [ T ]; Ty.path "usize"; Ty.path "usize"; A ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "alloc::vec::Vec") [] [ T; A ],
                    "into_raw_parts_with_alloc",
                    [],
                    []
                  |),
                  [ M.read (| v |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let γ0_2 := M.SubPointer.get_tuple_field (| γ, 2 |) in
                    let γ0_3 := M.SubPointer.get_tuple_field (| γ, 3 |) in
                    let vec_ptr := M.copy (| γ0_0 |) in
                    let len := M.copy (| γ0_1 |) in
                    let cap := M.copy (| γ0_2 |) in
                    let alloc := M.copy (| γ0_3 |) in
                    let~ rc_ptr :
                        Ty.apply
                          (Ty.path "*mut")
                          []
                          [
                            Ty.apply
                              (Ty.path "alloc::rc::RcInner")
                              []
                              [ Ty.apply (Ty.path "slice") [] [ T ] ]
                          ] :=
                      M.alloc (|
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "*mut")
                            []
                            [
                              Ty.apply
                                (Ty.path "alloc::rc::RcInner")
                                []
                                [ Ty.apply (Ty.path "slice") [] [ T ] ]
                            ],
                          M.get_associated_function (|
                            Ty.apply
                              (Ty.path "alloc::rc::Rc")
                              []
                              [ Ty.apply (Ty.path "slice") [] [ T ]; A ],
                            "allocate_for_slice_in",
                            [],
                            []
                          |),
                          [
                            M.read (| len |);
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.deref (| M.borrow (| Pointer.Kind.Ref, alloc |) |)
                            |)
                          ]
                        |)
                      |) in
                    let~ _ : Ty.tuple [] :=
                      M.alloc (|
                        M.call_closure (|
                          Ty.tuple [],
                          M.get_function (| "core::intrinsics::copy_nonoverlapping", [], [ T ] |),
                          [
                            (* MutToConstPointer *) M.pointer_coercion (M.read (| vec_ptr |));
                            M.cast
                              (Ty.apply (Ty.path "*mut") [] [ T ])
                              (M.borrow (|
                                Pointer.Kind.MutPointer,
                                M.SubPointer.get_struct_record_field (|
                                  M.deref (| M.read (| rc_ptr |) |),
                                  "alloc::rc::RcInner",
                                  "value"
                                |)
                              |));
                            M.read (| len |)
                          ]
                        |)
                      |) in
                    M.match_operator (|
                      None,
                      M.alloc (|
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "alloc::vec::Vec")
                            []
                            [ T; Ty.apply (Ty.path "&") [] [ A ] ],
                          M.get_associated_function (|
                            Ty.apply
                              (Ty.path "alloc::vec::Vec")
                              []
                              [ T; Ty.apply (Ty.path "&") [] [ A ] ],
                            "from_raw_parts_in",
                            [],
                            []
                          |),
                          [
                            M.read (| vec_ptr |);
                            Value.Integer IntegerKind.Usize 0;
                            M.read (| cap |);
                            M.borrow (| Pointer.Kind.Ref, alloc |)
                          ]
                        |)
                      |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (M.alloc (|
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "alloc::rc::Rc")
                                  []
                                  [ Ty.apply (Ty.path "slice") [] [ T ]; A ],
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "alloc::rc::Rc")
                                    []
                                    [ Ty.apply (Ty.path "slice") [] [ T ]; A ],
                                  "from_ptr_in",
                                  [],
                                  []
                                |),
                                [ M.read (| rc_ptr |); M.read (| alloc |) ]
                              |)
                            |)))
                      ]
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (T A : Ty.t),
      M.IsTraitInstance
        "core::convert::From"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.apply (Ty.path "alloc::vec::Vec") [] [ T; A ] ]
        (Self T A)
        (* Instance *) [ ("from", InstanceField.Method (from T A)) ].
  End Impl_core_convert_From_where_core_alloc_Allocator_A_alloc_vec_Vec_T_A_for_alloc_rc_Rc_slice_T_A.
  
  Module Impl_core_convert_From_where_alloc_borrow_ToOwned_B_where_core_marker_Sized_B_where_core_convert_From_alloc_rc_Rc_B_alloc_alloc_Global_ref__B_where_core_convert_From_alloc_rc_Rc_B_alloc_alloc_Global_associated_in_trait_alloc_borrow_ToOwned___B_Owned_alloc_borrow_Cow_B_for_alloc_rc_Rc_B_alloc_alloc_Global.
    Definition Self (B : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "alloc::rc::Rc") [] [ B; Ty.path "alloc::alloc::Global" ].
    
    (*
        fn from(cow: Cow<'a, B>) -> Rc<B> {
            match cow {
                Cow::Borrowed(s) => Rc::from(s),
                Cow::Owned(s) => Rc::from(s),
            }
        }
    *)
    Definition from (B : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self B in
      match ε, τ, α with
      | [], [], [ cow ] =>
        ltac:(M.monadic
          (let cow := M.alloc (| cow |) in
          M.read (|
            M.match_operator (|
              Some (Ty.apply (Ty.path "alloc::rc::Rc") [] [ B; Ty.path "alloc::alloc::Global" ]),
              cow,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "alloc::borrow::Cow::Borrowed",
                        0
                      |) in
                    let s := M.copy (| γ0_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply (Ty.path "alloc::rc::Rc") [] [ B; Ty.path "alloc::alloc::Global" ],
                        M.get_trait_method (|
                          "core::convert::From",
                          Ty.apply
                            (Ty.path "alloc::rc::Rc")
                            []
                            [ B; Ty.path "alloc::alloc::Global" ],
                          [],
                          [ Ty.apply (Ty.path "&") [] [ B ] ],
                          "from",
                          [],
                          []
                        |),
                        [ M.read (| s |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 :=
                      M.SubPointer.get_struct_tuple_field (| γ, "alloc::borrow::Cow::Owned", 0 |) in
                    let s := M.copy (| γ0_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply (Ty.path "alloc::rc::Rc") [] [ B; Ty.path "alloc::alloc::Global" ],
                        M.get_trait_method (|
                          "core::convert::From",
                          Ty.apply
                            (Ty.path "alloc::rc::Rc")
                            []
                            [ B; Ty.path "alloc::alloc::Global" ],
                          [],
                          [ Ty.associated_in_trait "alloc::borrow::ToOwned" [] [] B "Owned" ],
                          "from",
                          [],
                          []
                        |),
                        [ M.read (| s |) ]
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (B : Ty.t),
      M.IsTraitInstance
        "core::convert::From"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.apply (Ty.path "alloc::borrow::Cow") [] [ B ] ]
        (Self B)
        (* Instance *) [ ("from", InstanceField.Method (from B)) ].
  End Impl_core_convert_From_where_alloc_borrow_ToOwned_B_where_core_marker_Sized_B_where_core_convert_From_alloc_rc_Rc_B_alloc_alloc_Global_ref__B_where_core_convert_From_alloc_rc_Rc_B_alloc_alloc_Global_associated_in_trait_alloc_borrow_ToOwned___B_Owned_alloc_borrow_Cow_B_for_alloc_rc_Rc_B_alloc_alloc_Global.
  
  Module Impl_core_convert_From_alloc_rc_Rc_str_alloc_alloc_Global_for_alloc_rc_Rc_slice_u8_alloc_alloc_Global.
    Definition Self : Ty.t :=
      Ty.apply
        (Ty.path "alloc::rc::Rc")
        []
        [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ]; Ty.path "alloc::alloc::Global" ].
    
    (*
        fn from(rc: Rc<str>) -> Self {
            // SAFETY: `str` has the same layout as `[u8]`.
            unsafe { Rc::from_raw(Rc::into_raw(rc) as *const [u8]) }
        }
    *)
    Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ rc ] =>
        ltac:(M.monadic
          (let rc := M.alloc (| rc |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "alloc::rc::Rc")
              []
              [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ]; Ty.path "alloc::alloc::Global" ],
            M.get_associated_function (|
              Ty.apply
                (Ty.path "alloc::rc::Rc")
                []
                [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ]; Ty.path "alloc::alloc::Global" ],
              "from_raw",
              [],
              []
            |),
            [
              M.cast
                (Ty.apply (Ty.path "*const") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ])
                (M.call_closure (|
                  Ty.apply (Ty.path "*const") [] [ Ty.path "str" ],
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "alloc::rc::Rc")
                      []
                      [ Ty.path "str"; Ty.path "alloc::alloc::Global" ],
                    "into_raw",
                    [],
                    []
                  |),
                  [ M.read (| rc |) ]
                |))
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::convert::From"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *)
        [ Ty.apply (Ty.path "alloc::rc::Rc") [] [ Ty.path "str"; Ty.path "alloc::alloc::Global" ] ]
        Self
        (* Instance *) [ ("from", InstanceField.Method from) ].
  End Impl_core_convert_From_alloc_rc_Rc_str_alloc_alloc_Global_for_alloc_rc_Rc_slice_u8_alloc_alloc_Global.
  
  Module Impl_core_convert_TryFrom_where_core_alloc_Allocator_A_alloc_rc_Rc_slice_T_A_for_alloc_rc_Rc_array_N_T_A.
    Definition Self (N : Value.t) (T A : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "alloc::rc::Rc") [] [ Ty.apply (Ty.path "array") [ N ] [ T ]; A ].
    
    (*     type Error = Rc<[T], A>; *)
    Definition _Error (N : Value.t) (T A : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "alloc::rc::Rc") [] [ Ty.apply (Ty.path "slice") [] [ T ]; A ].
    
    (*
        fn try_from(boxed_slice: Rc<[T], A>) -> Result<Self, Self::Error> {
            if boxed_slice.len() == N {
                let (ptr, alloc) = Rc::into_inner_with_allocator(boxed_slice);
                Ok(unsafe { Rc::from_inner_in(ptr.cast(), alloc) })
            } else {
                Err(boxed_slice)
            }
        }
    *)
    Definition try_from
        (N : Value.t)
        (T A : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self N T A in
      match ε, τ, α with
      | [], [], [ boxed_slice ] =>
        ltac:(M.monadic
          (let boxed_slice := M.alloc (| boxed_slice |) in
          M.read (|
            M.match_operator (|
              Some
                (Ty.apply
                  (Ty.path "core::result::Result")
                  []
                  [
                    Ty.apply
                      (Ty.path "alloc::rc::Rc")
                      []
                      [ Ty.apply (Ty.path "array") [ N ] [ T ]; A ];
                    Ty.apply (Ty.path "alloc::rc::Rc") [] [ Ty.apply (Ty.path "slice") [] [ T ]; A ]
                  ]),
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          BinOp.eq (|
                            M.call_closure (|
                              Ty.path "usize",
                              M.get_associated_function (|
                                Ty.apply (Ty.path "slice") [] [ T ],
                                "len",
                                [],
                                []
                              |),
                              [
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.deref (|
                                    M.call_closure (|
                                      Ty.apply
                                        (Ty.path "&")
                                        []
                                        [ Ty.apply (Ty.path "slice") [] [ T ] ],
                                      M.get_trait_method (|
                                        "core::ops::deref::Deref",
                                        Ty.apply
                                          (Ty.path "alloc::rc::Rc")
                                          []
                                          [ Ty.apply (Ty.path "slice") [] [ T ]; A ],
                                        [],
                                        [],
                                        "deref",
                                        [],
                                        []
                                      |),
                                      [ M.borrow (| Pointer.Kind.Ref, boxed_slice |) ]
                                    |)
                                  |)
                                |)
                              ]
                            |),
                            M.read (| get_constant (| "alloc::rc::N", Ty.path "usize" |) |)
                          |)
                        |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.match_operator (|
                      None,
                      M.alloc (|
                        M.call_closure (|
                          Ty.tuple
                            [
                              Ty.apply
                                (Ty.path "core::ptr::non_null::NonNull")
                                []
                                [
                                  Ty.apply
                                    (Ty.path "alloc::rc::RcInner")
                                    []
                                    [ Ty.apply (Ty.path "slice") [] [ T ] ]
                                ];
                              A
                            ],
                          M.get_associated_function (|
                            Ty.apply
                              (Ty.path "alloc::rc::Rc")
                              []
                              [ Ty.apply (Ty.path "slice") [] [ T ]; A ],
                            "into_inner_with_allocator",
                            [],
                            []
                          |),
                          [ M.read (| boxed_slice |) ]
                        |)
                      |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                            let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                            let ptr := M.copy (| γ0_0 |) in
                            let alloc := M.copy (| γ0_1 |) in
                            M.alloc (|
                              Value.StructTuple
                                "core::result::Result::Ok"
                                [
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "alloc::rc::Rc")
                                      []
                                      [ Ty.apply (Ty.path "array") [ N ] [ T ]; A ],
                                    M.get_associated_function (|
                                      Ty.apply
                                        (Ty.path "alloc::rc::Rc")
                                        []
                                        [ Ty.apply (Ty.path "array") [ N ] [ T ]; A ],
                                      "from_inner_in",
                                      [],
                                      []
                                    |),
                                    [
                                      M.call_closure (|
                                        Ty.apply
                                          (Ty.path "core::ptr::non_null::NonNull")
                                          []
                                          [
                                            Ty.apply
                                              (Ty.path "alloc::rc::RcInner")
                                              []
                                              [ Ty.apply (Ty.path "array") [ N ] [ T ] ]
                                          ],
                                        M.get_associated_function (|
                                          Ty.apply
                                            (Ty.path "core::ptr::non_null::NonNull")
                                            []
                                            [
                                              Ty.apply
                                                (Ty.path "alloc::rc::RcInner")
                                                []
                                                [ Ty.apply (Ty.path "slice") [] [ T ] ]
                                            ],
                                          "cast",
                                          [],
                                          [
                                            Ty.apply
                                              (Ty.path "alloc::rc::RcInner")
                                              []
                                              [ Ty.apply (Ty.path "array") [ N ] [ T ] ]
                                          ]
                                        |),
                                        [ M.read (| ptr |) ]
                                      |);
                                      M.read (| alloc |)
                                    ]
                                  |)
                                ]
                            |)))
                      ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      Value.StructTuple "core::result::Result::Err" [ M.read (| boxed_slice |) ]
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (N : Value.t) (T A : Ty.t),
      M.IsTraitInstance
        "core::convert::TryFrom"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *)
        [ Ty.apply (Ty.path "alloc::rc::Rc") [] [ Ty.apply (Ty.path "slice") [] [ T ]; A ] ]
        (Self N T A)
        (* Instance *)
        [
          ("Error", InstanceField.Ty (_Error N T A));
          ("try_from", InstanceField.Method (try_from N T A))
        ].
  End Impl_core_convert_TryFrom_where_core_alloc_Allocator_A_alloc_rc_Rc_slice_T_A_for_alloc_rc_Rc_array_N_T_A.
  
  Module Impl_core_iter_traits_collect_FromIterator_T_for_alloc_rc_Rc_slice_T_alloc_alloc_Global.
    Definition Self (T : Ty.t) : Ty.t :=
      Ty.apply
        (Ty.path "alloc::rc::Rc")
        []
        [ Ty.apply (Ty.path "slice") [] [ T ]; Ty.path "alloc::alloc::Global" ].
    
    (*
        fn from_iter<I: IntoIterator<Item = T>>(iter: I) -> Self {
            ToRcSlice::to_rc_slice(iter.into_iter())
        }
    *)
    Definition from_iter (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [ _ as I ], [ iter ] =>
        ltac:(M.monadic
          (let iter := M.alloc (| iter |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "alloc::rc::Rc")
              []
              [ Ty.apply (Ty.path "slice") [] [ T ]; Ty.path "alloc::alloc::Global" ],
            M.get_trait_method (|
              "alloc::rc::ToRcSlice",
              Ty.associated_in_trait "core::iter::traits::collect::IntoIterator" [] [] I "IntoIter",
              [],
              [ T ],
              "to_rc_slice",
              [],
              []
            |),
            [
              M.call_closure (|
                Ty.associated_in_trait
                  "core::iter::traits::collect::IntoIterator"
                  []
                  []
                  I
                  "IntoIter",
                M.get_trait_method (|
                  "core::iter::traits::collect::IntoIterator",
                  I,
                  [],
                  [],
                  "into_iter",
                  [],
                  []
                |),
                [ M.read (| iter |) ]
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "core::iter::traits::collect::FromIterator"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ T ]
        (Self T)
        (* Instance *) [ ("from_iter", InstanceField.Method (from_iter T)) ].
  End Impl_core_iter_traits_collect_FromIterator_T_for_alloc_rc_Rc_slice_T_alloc_alloc_Global.
  
  (* Trait *)
  (* Empty module 'ToRcSlice' *)
  
  Module Impl_alloc_rc_ToRcSlice_where_core_iter_traits_iterator_Iterator_I_T_for_I.
    Definition Self (T I : Ty.t) : Ty.t := I.
    
    (*
        default fn to_rc_slice(self) -> Rc<[T]> {
            self.collect::<Vec<T>>().into()
        }
    *)
    Definition to_rc_slice (T I : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T I in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "alloc::rc::Rc")
              []
              [ Ty.apply (Ty.path "slice") [] [ T ]; Ty.path "alloc::alloc::Global" ],
            M.get_trait_method (|
              "core::convert::Into",
              Ty.apply (Ty.path "alloc::vec::Vec") [] [ T; Ty.path "alloc::alloc::Global" ],
              [],
              [
                Ty.apply
                  (Ty.path "alloc::rc::Rc")
                  []
                  [ Ty.apply (Ty.path "slice") [] [ T ]; Ty.path "alloc::alloc::Global" ]
              ],
              "into",
              [],
              []
            |),
            [
              M.call_closure (|
                Ty.apply (Ty.path "alloc::vec::Vec") [] [ T; Ty.path "alloc::alloc::Global" ],
                M.get_trait_method (|
                  "core::iter::traits::iterator::Iterator",
                  I,
                  [],
                  [],
                  "collect",
                  [],
                  [ Ty.apply (Ty.path "alloc::vec::Vec") [] [ T; Ty.path "alloc::alloc::Global" ] ]
                |),
                [ M.read (| self |) ]
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (T I : Ty.t),
      M.IsTraitInstance
        "alloc::rc::ToRcSlice"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ T ]
        (Self T I)
        (* Instance *) [ ("to_rc_slice", InstanceField.Method (to_rc_slice T I)) ].
  End Impl_alloc_rc_ToRcSlice_where_core_iter_traits_iterator_Iterator_I_T_for_I.
  
  Module Impl_alloc_rc_ToRcSlice_where_core_iter_traits_marker_TrustedLen_I_T_for_I.
    Definition Self (T I : Ty.t) : Ty.t := I.
    
    (*
        fn to_rc_slice(self) -> Rc<[T]> {
            // This is the case for a `TrustedLen` iterator.
            let (low, high) = self.size_hint();
            if let Some(high) = high {
                debug_assert_eq!(
                    low,
                    high,
                    "TrustedLen iterator's size hint is not exact: {:?}",
                    (low, high)
                );
    
                unsafe {
                    // SAFETY: We need to ensure that the iterator has an exact length and we have.
                    Rc::from_iter_exact(self, low)
                }
            } else {
                // TrustedLen contract guarantees that `upper_bound == None` implies an iterator
                // length exceeding `usize::MAX`.
                // The default implementation would collect into a vec which would panic.
                // Thus we panic here immediately without invoking `Vec` code.
                panic!("capacity overflow");
            }
        }
    *)
    Definition to_rc_slice (T I : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T I in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              None,
              M.alloc (|
                M.call_closure (|
                  Ty.tuple
                    [
                      Ty.path "usize";
                      Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "usize" ]
                    ],
                  M.get_trait_method (|
                    "core::iter::traits::iterator::Iterator",
                    I,
                    [],
                    [],
                    "size_hint",
                    [],
                    []
                  |),
                  [ M.borrow (| Pointer.Kind.Ref, self |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let low := M.copy (| γ0_0 |) in
                    let high := M.copy (| γ0_1 |) in
                    M.match_operator (|
                      Some
                        (Ty.apply
                          (Ty.path "alloc::rc::Rc")
                          []
                          [ Ty.apply (Ty.path "slice") [] [ T ]; Ty.path "alloc::alloc::Global" ]),
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ := high in
                            let γ0_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "core::option::Option::Some",
                                0
                              |) in
                            let high := M.copy (| γ0_0 |) in
                            let~ _ : Ty.tuple [] :=
                              M.match_operator (|
                                Some (Ty.tuple []),
                                M.alloc (| Value.Tuple [] |),
                                [
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let γ := M.use (M.alloc (| Value.Bool true |)) in
                                      let _ :=
                                        M.is_constant_or_break_match (|
                                          M.read (| γ |),
                                          Value.Bool true
                                        |) in
                                      let~ _ : Ty.tuple [] :=
                                        M.match_operator (|
                                          Some (Ty.tuple []),
                                          M.alloc (|
                                            Value.Tuple
                                              [
                                                M.borrow (| Pointer.Kind.Ref, low |);
                                                M.borrow (| Pointer.Kind.Ref, high |)
                                              ]
                                          |),
                                          [
                                            fun γ =>
                                              ltac:(M.monadic
                                                (let γ0_0 :=
                                                  M.SubPointer.get_tuple_field (| γ, 0 |) in
                                                let γ0_1 :=
                                                  M.SubPointer.get_tuple_field (| γ, 1 |) in
                                                let left_val := M.copy (| γ0_0 |) in
                                                let right_val := M.copy (| γ0_1 |) in
                                                M.match_operator (|
                                                  Some (Ty.tuple []),
                                                  M.alloc (| Value.Tuple [] |),
                                                  [
                                                    fun γ =>
                                                      ltac:(M.monadic
                                                        (let γ :=
                                                          M.use
                                                            (M.alloc (|
                                                              UnOp.not (|
                                                                BinOp.eq (|
                                                                  M.read (|
                                                                    M.deref (|
                                                                      M.read (| left_val |)
                                                                    |)
                                                                  |),
                                                                  M.read (|
                                                                    M.deref (|
                                                                      M.read (| right_val |)
                                                                    |)
                                                                  |)
                                                                |)
                                                              |)
                                                            |)) in
                                                        let _ :=
                                                          M.is_constant_or_break_match (|
                                                            M.read (| γ |),
                                                            Value.Bool true
                                                          |) in
                                                        M.alloc (|
                                                          M.never_to_any (|
                                                            M.read (|
                                                              let~ kind :
                                                                  Ty.path
                                                                    "core::panicking::AssertKind" :=
                                                                M.alloc (|
                                                                  Value.StructTuple
                                                                    "core::panicking::AssertKind::Eq"
                                                                    []
                                                                |) in
                                                              M.alloc (|
                                                                M.call_closure (|
                                                                  Ty.path "never",
                                                                  M.get_function (|
                                                                    "core::panicking::assert_failed",
                                                                    [],
                                                                    [
                                                                      Ty.path "usize";
                                                                      Ty.path "usize"
                                                                    ]
                                                                  |),
                                                                  [
                                                                    M.read (| kind |);
                                                                    M.borrow (|
                                                                      Pointer.Kind.Ref,
                                                                      M.deref (|
                                                                        M.borrow (|
                                                                          Pointer.Kind.Ref,
                                                                          M.deref (|
                                                                            M.read (| left_val |)
                                                                          |)
                                                                        |)
                                                                      |)
                                                                    |);
                                                                    M.borrow (|
                                                                      Pointer.Kind.Ref,
                                                                      M.deref (|
                                                                        M.borrow (|
                                                                          Pointer.Kind.Ref,
                                                                          M.deref (|
                                                                            M.read (| right_val |)
                                                                          |)
                                                                        |)
                                                                      |)
                                                                    |);
                                                                    Value.StructTuple
                                                                      "core::option::Option::Some"
                                                                      [
                                                                        M.call_closure (|
                                                                          Ty.path
                                                                            "core::fmt::Arguments",
                                                                          M.get_associated_function (|
                                                                            Ty.path
                                                                              "core::fmt::Arguments",
                                                                            "new_v1",
                                                                            [
                                                                              Value.Integer
                                                                                IntegerKind.Usize
                                                                                1;
                                                                              Value.Integer
                                                                                IntegerKind.Usize
                                                                                1
                                                                            ],
                                                                            []
                                                                          |),
                                                                          [
                                                                            M.borrow (|
                                                                              Pointer.Kind.Ref,
                                                                              M.deref (|
                                                                                M.borrow (|
                                                                                  Pointer.Kind.Ref,
                                                                                  M.alloc (|
                                                                                    Value.Array
                                                                                      [
                                                                                        mk_str (|
                                                                                          "TrustedLen iterator's size hint is not exact: "
                                                                                        |)
                                                                                      ]
                                                                                  |)
                                                                                |)
                                                                              |)
                                                                            |);
                                                                            M.borrow (|
                                                                              Pointer.Kind.Ref,
                                                                              M.deref (|
                                                                                M.borrow (|
                                                                                  Pointer.Kind.Ref,
                                                                                  M.alloc (|
                                                                                    Value.Array
                                                                                      [
                                                                                        M.call_closure (|
                                                                                          Ty.path
                                                                                            "core::fmt::rt::Argument",
                                                                                          M.get_associated_function (|
                                                                                            Ty.path
                                                                                              "core::fmt::rt::Argument",
                                                                                            "new_debug",
                                                                                            [],
                                                                                            [
                                                                                              Ty.tuple
                                                                                                [
                                                                                                  Ty.path
                                                                                                    "usize";
                                                                                                  Ty.path
                                                                                                    "usize"
                                                                                                ]
                                                                                            ]
                                                                                          |),
                                                                                          [
                                                                                            M.borrow (|
                                                                                              Pointer.Kind.Ref,
                                                                                              M.deref (|
                                                                                                M.borrow (|
                                                                                                  Pointer.Kind.Ref,
                                                                                                  M.alloc (|
                                                                                                    Value.Tuple
                                                                                                      [
                                                                                                        M.read (|
                                                                                                          low
                                                                                                        |);
                                                                                                        M.read (|
                                                                                                          high
                                                                                                        |)
                                                                                                      ]
                                                                                                  |)
                                                                                                |)
                                                                                              |)
                                                                                            |)
                                                                                          ]
                                                                                        |)
                                                                                      ]
                                                                                  |)
                                                                                |)
                                                                              |)
                                                                            |)
                                                                          ]
                                                                        |)
                                                                      ]
                                                                  ]
                                                                |)
                                                              |)
                                                            |)
                                                          |)
                                                        |)));
                                                    fun γ =>
                                                      ltac:(M.monadic
                                                        (M.alloc (| Value.Tuple [] |)))
                                                  ]
                                                |)))
                                          ]
                                        |) in
                                      M.alloc (| Value.Tuple [] |)));
                                  fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                                ]
                              |) in
                            M.alloc (|
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "alloc::rc::Rc")
                                  []
                                  [
                                    Ty.apply (Ty.path "slice") [] [ T ];
                                    Ty.path "alloc::alloc::Global"
                                  ],
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "alloc::rc::Rc")
                                    []
                                    [
                                      Ty.apply (Ty.path "slice") [] [ T ];
                                      Ty.path "alloc::alloc::Global"
                                    ],
                                  "from_iter_exact",
                                  [],
                                  [ I ]
                                |),
                                [ M.read (| self |); M.read (| low |) ]
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (M.alloc (|
                              M.never_to_any (|
                                M.call_closure (|
                                  Ty.path "never",
                                  M.get_function (| "core::panicking::panic_fmt", [], [] |),
                                  [
                                    M.call_closure (|
                                      Ty.path "core::fmt::Arguments",
                                      M.get_associated_function (|
                                        Ty.path "core::fmt::Arguments",
                                        "new_const",
                                        [ Value.Integer IntegerKind.Usize 1 ],
                                        []
                                      |),
                                      [
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.deref (|
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.alloc (|
                                                Value.Array [ mk_str (| "capacity overflow" |) ]
                                              |)
                                            |)
                                          |)
                                        |)
                                      ]
                                    |)
                                  ]
                                |)
                              |)
                            |)))
                      ]
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (T I : Ty.t),
      M.IsTraitInstance
        "alloc::rc::ToRcSlice"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ T ]
        (Self T I)
        (* Instance *) [ ("to_rc_slice", InstanceField.Method (to_rc_slice T I)) ].
  End Impl_alloc_rc_ToRcSlice_where_core_iter_traits_marker_TrustedLen_I_T_for_I.
  
  (* StructRecord
    {
      name := "Weak";
      const_params := [];
      ty_params := [ "T"; "A" ];
      fields :=
        [
          ("ptr",
            Ty.apply
              (Ty.path "core::ptr::non_null::NonNull")
              []
              [ Ty.apply (Ty.path "alloc::rc::RcInner") [] [ T ] ]);
          ("alloc", A)
        ];
    } *)
  
  Module Impl_core_marker_Send_where_core_marker_Sized_T_where_core_alloc_Allocator_A_for_alloc_rc_Weak_T_A.
    Definition Self (T A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::rc::Weak") [] [ T; A ].
    
    Axiom Implements :
      forall (T A : Ty.t),
      M.IsTraitInstance
        "core::marker::Send"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self T A)
        (* Instance *) [].
  End Impl_core_marker_Send_where_core_marker_Sized_T_where_core_alloc_Allocator_A_for_alloc_rc_Weak_T_A.
  
  Module Impl_core_marker_Sync_where_core_marker_Sized_T_where_core_alloc_Allocator_A_for_alloc_rc_Weak_T_A.
    Definition Self (T A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::rc::Weak") [] [ T; A ].
    
    Axiom Implements :
      forall (T A : Ty.t),
      M.IsTraitInstance
        "core::marker::Sync"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self T A)
        (* Instance *) [].
  End Impl_core_marker_Sync_where_core_marker_Sized_T_where_core_alloc_Allocator_A_for_alloc_rc_Weak_T_A.
  
  Module Impl_core_ops_unsize_CoerceUnsized_where_core_marker_Sized_T_where_core_marker_Unsize_T_U_where_core_marker_Sized_U_where_core_alloc_Allocator_A_alloc_rc_Weak_U_A_for_alloc_rc_Weak_T_A.
    Definition Self (T U A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::rc::Weak") [] [ T; A ].
    
    Axiom Implements :
      forall (T U A : Ty.t),
      M.IsTraitInstance
        "core::ops::unsize::CoerceUnsized"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.apply (Ty.path "alloc::rc::Weak") [] [ U; A ] ]
        (Self T U A)
        (* Instance *) [].
  End Impl_core_ops_unsize_CoerceUnsized_where_core_marker_Sized_T_where_core_marker_Unsize_T_U_where_core_marker_Sized_U_where_core_alloc_Allocator_A_alloc_rc_Weak_U_A_for_alloc_rc_Weak_T_A.
  
  Module Impl_core_ops_unsize_DispatchFromDyn_where_core_marker_Sized_T_where_core_marker_Unsize_T_U_where_core_marker_Sized_U_alloc_rc_Weak_U_alloc_alloc_Global_for_alloc_rc_Weak_T_alloc_alloc_Global.
    Definition Self (T U : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "alloc::rc::Weak") [] [ T; Ty.path "alloc::alloc::Global" ].
    
    Axiom Implements :
      forall (T U : Ty.t),
      M.IsTraitInstance
        "core::ops::unsize::DispatchFromDyn"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *)
        [ Ty.apply (Ty.path "alloc::rc::Weak") [] [ U; Ty.path "alloc::alloc::Global" ] ]
        (Self T U)
        (* Instance *) [].
  End Impl_core_ops_unsize_DispatchFromDyn_where_core_marker_Sized_T_where_core_marker_Unsize_T_U_where_core_marker_Sized_U_alloc_rc_Weak_U_alloc_alloc_Global_for_alloc_rc_Weak_T_alloc_alloc_Global.
  
  Module Impl_alloc_rc_Weak_T_alloc_alloc_Global.
    Definition Self (T : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "alloc::rc::Weak") [] [ T; Ty.path "alloc::alloc::Global" ].
    
    (*
        pub const fn new() -> Weak<T> {
            Weak {
                ptr: unsafe {
                    NonNull::new_unchecked(ptr::without_provenance_mut::<RcInner<T>>(usize::MAX))
                },
                alloc: Global,
            }
        }
    *)
    Definition new (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [], [] =>
        ltac:(M.monadic
          (Value.StructRecord
            "alloc::rc::Weak"
            [
              ("ptr",
                M.call_closure (|
                  Ty.apply
                    (Ty.path "core::ptr::non_null::NonNull")
                    []
                    [ Ty.apply (Ty.path "alloc::rc::RcInner") [] [ T ] ],
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "core::ptr::non_null::NonNull")
                      []
                      [ Ty.apply (Ty.path "alloc::rc::RcInner") [] [ T ] ],
                    "new_unchecked",
                    [],
                    []
                  |),
                  [
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "*mut")
                        []
                        [ Ty.apply (Ty.path "alloc::rc::RcInner") [] [ T ] ],
                      M.get_function (|
                        "core::ptr::without_provenance_mut",
                        [],
                        [ Ty.apply (Ty.path "alloc::rc::RcInner") [] [ T ] ]
                      |),
                      [
                        M.read (|
                          get_associated_constant (| Ty.path "usize", "MAX", Ty.path "usize" |)
                        |)
                      ]
                    |)
                  ]
                |));
              ("alloc", Value.StructTuple "alloc::alloc::Global" [])
            ]))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_new :
      forall (T : Ty.t),
      M.IsAssociatedFunction.C (Self T) "new" (new T).
    Admitted.
    Global Typeclasses Opaque new.
    (*
        pub unsafe fn from_raw(ptr: *const T) -> Self {
            unsafe { Self::from_raw_in(ptr, Global) }
        }
    *)
    Definition from_raw (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [], [ ptr ] =>
        ltac:(M.monadic
          (let ptr := M.alloc (| ptr |) in
          M.call_closure (|
            Ty.apply (Ty.path "alloc::rc::Weak") [] [ T; Ty.path "alloc::alloc::Global" ],
            M.get_associated_function (|
              Ty.apply (Ty.path "alloc::rc::Weak") [] [ T; Ty.path "alloc::alloc::Global" ],
              "from_raw_in",
              [],
              []
            |),
            [ M.read (| ptr |); Value.StructTuple "alloc::alloc::Global" [] ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_from_raw :
      forall (T : Ty.t),
      M.IsAssociatedFunction.C (Self T) "from_raw" (from_raw T).
    Admitted.
    Global Typeclasses Opaque from_raw.
  End Impl_alloc_rc_Weak_T_alloc_alloc_Global.
  
  Module Impl_alloc_rc_Weak_T_A.
    Definition Self (T A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::rc::Weak") [] [ T; A ].
    
    (*
        pub fn new_in(alloc: A) -> Weak<T, A> {
            Weak {
                ptr: unsafe {
                    NonNull::new_unchecked(ptr::without_provenance_mut::<RcInner<T>>(usize::MAX))
                },
                alloc,
            }
        }
    *)
    Definition new_in (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ alloc ] =>
        ltac:(M.monadic
          (let alloc := M.alloc (| alloc |) in
          Value.StructRecord
            "alloc::rc::Weak"
            [
              ("ptr",
                M.call_closure (|
                  Ty.apply
                    (Ty.path "core::ptr::non_null::NonNull")
                    []
                    [ Ty.apply (Ty.path "alloc::rc::RcInner") [] [ T ] ],
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "core::ptr::non_null::NonNull")
                      []
                      [ Ty.apply (Ty.path "alloc::rc::RcInner") [] [ T ] ],
                    "new_unchecked",
                    [],
                    []
                  |),
                  [
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "*mut")
                        []
                        [ Ty.apply (Ty.path "alloc::rc::RcInner") [] [ T ] ],
                      M.get_function (|
                        "core::ptr::without_provenance_mut",
                        [],
                        [ Ty.apply (Ty.path "alloc::rc::RcInner") [] [ T ] ]
                      |),
                      [
                        M.read (|
                          get_associated_constant (| Ty.path "usize", "MAX", Ty.path "usize" |)
                        |)
                      ]
                    |)
                  ]
                |));
              ("alloc", M.read (| alloc |))
            ]))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_new_in :
      forall (T A : Ty.t),
      M.IsAssociatedFunction.C (Self T A) "new_in" (new_in T A).
    Admitted.
    Global Typeclasses Opaque new_in.
    (*
        pub fn allocator(&self) -> &A {
            &self.alloc
        }
    *)
    Definition allocator (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.borrow (|
            Pointer.Kind.Ref,
            M.deref (|
              M.borrow (|
                Pointer.Kind.Ref,
                M.SubPointer.get_struct_record_field (|
                  M.deref (| M.read (| self |) |),
                  "alloc::rc::Weak",
                  "alloc"
                |)
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_allocator :
      forall (T A : Ty.t),
      M.IsAssociatedFunction.C (Self T A) "allocator" (allocator T A).
    Admitted.
    Global Typeclasses Opaque allocator.
    
    (*
        pub fn as_ptr(&self) -> *const T {
            let ptr: *mut RcInner<T> = NonNull::as_ptr(self.ptr);
    
            if is_dangling(ptr) {
                // If the pointer is dangling, we return the sentinel directly. This cannot be
                // a valid payload address, as the payload is at least as aligned as RcInner (usize).
                ptr as *const T
            } else {
                // SAFETY: if is_dangling returns false, then the pointer is dereferenceable.
                // The payload may be dropped at this point, and we have to maintain provenance,
                // so use raw pointer manipulation.
                unsafe { &raw mut ( *ptr).value }
            }
        }
    *)
    Definition as_ptr (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            let~ ptr :
                Ty.apply (Ty.path "*mut") [] [ Ty.apply (Ty.path "alloc::rc::RcInner") [] [ T ] ] :=
              M.alloc (|
                M.call_closure (|
                  Ty.apply (Ty.path "*mut") [] [ Ty.apply (Ty.path "alloc::rc::RcInner") [] [ T ] ],
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "core::ptr::non_null::NonNull")
                      []
                      [ Ty.apply (Ty.path "alloc::rc::RcInner") [] [ T ] ],
                    "as_ptr",
                    [],
                    []
                  |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "alloc::rc::Weak",
                        "ptr"
                      |)
                    |)
                  ]
                |)
              |) in
            M.match_operator (|
              Some (Ty.apply (Ty.path "*const") [] [ T ]),
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          M.call_closure (|
                            Ty.path "bool",
                            M.get_function (|
                              "alloc::rc::is_dangling",
                              [],
                              [ Ty.apply (Ty.path "alloc::rc::RcInner") [] [ T ] ]
                            |),
                            [ (* MutToConstPointer *) M.pointer_coercion (M.read (| ptr |)) ]
                          |)
                        |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (|
                      M.cast (Ty.apply (Ty.path "*const") [] [ T ]) (M.read (| ptr |))
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      (* MutToConstPointer *)
                      M.pointer_coercion
                        (M.borrow (|
                          Pointer.Kind.MutPointer,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| ptr |) |),
                            "alloc::rc::RcInner",
                            "value"
                          |)
                        |))
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_as_ptr :
      forall (T A : Ty.t),
      M.IsAssociatedFunction.C (Self T A) "as_ptr" (as_ptr T A).
    Admitted.
    Global Typeclasses Opaque as_ptr.
    
    (*
        pub fn into_raw(self) -> *const T {
            mem::ManuallyDrop::new(self).as_ptr()
        }
    *)
    Definition into_raw (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            Ty.apply (Ty.path "*const") [] [ T ],
            M.get_associated_function (|
              Ty.apply (Ty.path "alloc::rc::Weak") [] [ T; A ],
              "as_ptr",
              [],
              []
            |),
            [
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.call_closure (|
                    Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "alloc::rc::Weak") [] [ T; A ] ],
                    M.get_trait_method (|
                      "core::ops::deref::Deref",
                      Ty.apply
                        (Ty.path "core::mem::manually_drop::ManuallyDrop")
                        []
                        [ Ty.apply (Ty.path "alloc::rc::Weak") [] [ T; A ] ],
                      [],
                      [],
                      "deref",
                      [],
                      []
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.alloc (|
                          M.call_closure (|
                            Ty.apply
                              (Ty.path "core::mem::manually_drop::ManuallyDrop")
                              []
                              [ Ty.apply (Ty.path "alloc::rc::Weak") [] [ T; A ] ],
                            M.get_associated_function (|
                              Ty.apply
                                (Ty.path "core::mem::manually_drop::ManuallyDrop")
                                []
                                [ Ty.apply (Ty.path "alloc::rc::Weak") [] [ T; A ] ],
                              "new",
                              [],
                              []
                            |),
                            [ M.read (| self |) ]
                          |)
                        |)
                      |)
                    ]
                  |)
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_into_raw :
      forall (T A : Ty.t),
      M.IsAssociatedFunction.C (Self T A) "into_raw" (into_raw T A).
    Admitted.
    Global Typeclasses Opaque into_raw.
    
    (*
        pub fn into_raw_with_allocator(self) -> ( *const T, A) {
            let this = mem::ManuallyDrop::new(self);
            let result = this.as_ptr();
            // Safety: `this` is ManuallyDrop so the allocator will not be double-dropped
            let alloc = unsafe { ptr::read(&this.alloc) };
            (result, alloc)
        }
    *)
    Definition into_raw_with_allocator
        (T A : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            let~ this :
                Ty.apply
                  (Ty.path "core::mem::manually_drop::ManuallyDrop")
                  []
                  [ Ty.apply (Ty.path "alloc::rc::Weak") [] [ T; A ] ] :=
              M.alloc (|
                M.call_closure (|
                  Ty.apply
                    (Ty.path "core::mem::manually_drop::ManuallyDrop")
                    []
                    [ Ty.apply (Ty.path "alloc::rc::Weak") [] [ T; A ] ],
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "core::mem::manually_drop::ManuallyDrop")
                      []
                      [ Ty.apply (Ty.path "alloc::rc::Weak") [] [ T; A ] ],
                    "new",
                    [],
                    []
                  |),
                  [ M.read (| self |) ]
                |)
              |) in
            let~ result : Ty.apply (Ty.path "*const") [] [ T ] :=
              M.alloc (|
                M.call_closure (|
                  Ty.apply (Ty.path "*const") [] [ T ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "alloc::rc::Weak") [] [ T; A ],
                    "as_ptr",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "&")
                            []
                            [ Ty.apply (Ty.path "alloc::rc::Weak") [] [ T; A ] ],
                          M.get_trait_method (|
                            "core::ops::deref::Deref",
                            Ty.apply
                              (Ty.path "core::mem::manually_drop::ManuallyDrop")
                              []
                              [ Ty.apply (Ty.path "alloc::rc::Weak") [] [ T; A ] ],
                            [],
                            [],
                            "deref",
                            [],
                            []
                          |),
                          [ M.borrow (| Pointer.Kind.Ref, this |) ]
                        |)
                      |)
                    |)
                  ]
                |)
              |) in
            let~ alloc : A :=
              M.alloc (|
                M.call_closure (|
                  A,
                  M.get_function (| "core::ptr::read", [], [ A ] |),
                  [
                    M.borrow (|
                      Pointer.Kind.ConstPointer,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (|
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "&")
                                  []
                                  [ Ty.apply (Ty.path "alloc::rc::Weak") [] [ T; A ] ],
                                M.get_trait_method (|
                                  "core::ops::deref::Deref",
                                  Ty.apply
                                    (Ty.path "core::mem::manually_drop::ManuallyDrop")
                                    []
                                    [ Ty.apply (Ty.path "alloc::rc::Weak") [] [ T; A ] ],
                                  [],
                                  [],
                                  "deref",
                                  [],
                                  []
                                |),
                                [ M.borrow (| Pointer.Kind.Ref, this |) ]
                              |)
                            |),
                            "alloc::rc::Weak",
                            "alloc"
                          |)
                        |)
                      |)
                    |)
                  ]
                |)
              |) in
            M.alloc (| Value.Tuple [ M.read (| result |); M.read (| alloc |) ] |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_into_raw_with_allocator :
      forall (T A : Ty.t),
      M.IsAssociatedFunction.C (Self T A) "into_raw_with_allocator" (into_raw_with_allocator T A).
    Admitted.
    Global Typeclasses Opaque into_raw_with_allocator.
    
    (*
        pub unsafe fn from_raw_in(ptr: *const T, alloc: A) -> Self {
            // See Weak::as_ptr for context on how the input pointer is derived.
    
            let ptr = if is_dangling(ptr) {
                // This is a dangling Weak.
                ptr as *mut RcInner<T>
            } else {
                // Otherwise, we're guaranteed the pointer came from a nondangling Weak.
                // SAFETY: data_offset is safe to call, as ptr references a real (potentially dropped) T.
                let offset = unsafe { data_offset(ptr) };
                // Thus, we reverse the offset to get the whole RcInner.
                // SAFETY: the pointer originated from a Weak, so this offset is safe.
                unsafe { ptr.byte_sub(offset) as *mut RcInner<T> }
            };
    
            // SAFETY: we now have recovered the original Weak pointer, so can create the Weak.
            Weak { ptr: unsafe { NonNull::new_unchecked(ptr) }, alloc }
        }
    *)
    Definition from_raw_in (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ ptr; alloc ] =>
        ltac:(M.monadic
          (let ptr := M.alloc (| ptr |) in
          let alloc := M.alloc (| alloc |) in
          M.read (|
            let~ ptr :
                Ty.apply (Ty.path "*mut") [] [ Ty.apply (Ty.path "alloc::rc::RcInner") [] [ T ] ] :=
              M.copy (|
                M.match_operator (|
                  Some
                    (Ty.apply
                      (Ty.path "*mut")
                      []
                      [ Ty.apply (Ty.path "alloc::rc::RcInner") [] [ T ] ]),
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ :=
                          M.use
                            (M.alloc (|
                              M.call_closure (|
                                Ty.path "bool",
                                M.get_function (| "alloc::rc::is_dangling", [], [ T ] |),
                                [ M.read (| ptr |) ]
                              |)
                            |)) in
                        let _ :=
                          M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        M.alloc (|
                          M.cast
                            (Ty.apply
                              (Ty.path "*mut")
                              []
                              [ Ty.apply (Ty.path "alloc::rc::RcInner") [] [ T ] ])
                            (M.read (| ptr |))
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let~ offset : Ty.path "usize" :=
                          M.alloc (|
                            M.call_closure (|
                              Ty.path "usize",
                              M.get_function (| "alloc::rc::data_offset", [], [ T ] |),
                              [ M.read (| ptr |) ]
                            |)
                          |) in
                        M.alloc (|
                          M.cast
                            (Ty.apply
                              (Ty.path "*mut")
                              []
                              [ Ty.apply (Ty.path "alloc::rc::RcInner") [] [ T ] ])
                            (M.call_closure (|
                              Ty.apply (Ty.path "*const") [] [ T ],
                              M.get_associated_function (|
                                Ty.apply (Ty.path "*const") [] [ T ],
                                "byte_sub",
                                [],
                                []
                              |),
                              [ M.read (| ptr |); M.read (| offset |) ]
                            |))
                        |)))
                  ]
                |)
              |) in
            M.alloc (|
              Value.StructRecord
                "alloc::rc::Weak"
                [
                  ("ptr",
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "core::ptr::non_null::NonNull")
                        []
                        [ Ty.apply (Ty.path "alloc::rc::RcInner") [] [ T ] ],
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "core::ptr::non_null::NonNull")
                          []
                          [ Ty.apply (Ty.path "alloc::rc::RcInner") [] [ T ] ],
                        "new_unchecked",
                        [],
                        []
                      |),
                      [ M.read (| ptr |) ]
                    |));
                  ("alloc", M.read (| alloc |))
                ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_from_raw_in :
      forall (T A : Ty.t),
      M.IsAssociatedFunction.C (Self T A) "from_raw_in" (from_raw_in T A).
    Admitted.
    Global Typeclasses Opaque from_raw_in.
    
    (*
        pub fn upgrade(&self) -> Option<Rc<T, A>>
        where
            A: Clone,
        {
            let inner = self.inner()?;
    
            if inner.strong() == 0 {
                None
            } else {
                unsafe {
                    inner.inc_strong();
                    Some(Rc::from_inner_in(self.ptr, self.alloc.clone()))
                }
            }
        }
    *)
    Definition upgrade (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.catch_return (|
            ltac:(M.monadic
              (M.read (|
                let~ inner : Ty.path "alloc::rc::WeakInner" :=
                  M.copy (|
                    M.match_operator (|
                      Some (Ty.path "alloc::rc::WeakInner"),
                      M.alloc (|
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "core::ops::control_flow::ControlFlow")
                            []
                            [
                              Ty.apply
                                (Ty.path "core::option::Option")
                                []
                                [ Ty.path "core::convert::Infallible" ];
                              Ty.path "alloc::rc::WeakInner"
                            ],
                          M.get_trait_method (|
                            "core::ops::try_trait::Try",
                            Ty.apply
                              (Ty.path "core::option::Option")
                              []
                              [ Ty.path "alloc::rc::WeakInner" ],
                            [],
                            [],
                            "branch",
                            [],
                            []
                          |),
                          [
                            M.call_closure (|
                              Ty.apply
                                (Ty.path "core::option::Option")
                                []
                                [ Ty.path "alloc::rc::WeakInner" ],
                              M.get_associated_function (|
                                Ty.apply (Ty.path "alloc::rc::Weak") [] [ T; A ],
                                "inner",
                                [],
                                []
                              |),
                              [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                            |)
                          ]
                        |)
                      |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "core::ops::control_flow::ControlFlow::Break",
                                0
                              |) in
                            let residual := M.copy (| γ0_0 |) in
                            M.alloc (|
                              M.never_to_any (|
                                M.read (|
                                  M.return_ (|
                                    M.call_closure (|
                                      Ty.apply
                                        (Ty.path "core::option::Option")
                                        []
                                        [ Ty.apply (Ty.path "alloc::rc::Rc") [] [ T; A ] ],
                                      M.get_trait_method (|
                                        "core::ops::try_trait::FromResidual",
                                        Ty.apply
                                          (Ty.path "core::option::Option")
                                          []
                                          [ Ty.apply (Ty.path "alloc::rc::Rc") [] [ T; A ] ],
                                        [],
                                        [
                                          Ty.apply
                                            (Ty.path "core::option::Option")
                                            []
                                            [ Ty.path "core::convert::Infallible" ]
                                        ],
                                        "from_residual",
                                        [],
                                        []
                                      |),
                                      [ M.read (| residual |) ]
                                    |)
                                  |)
                                |)
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "core::ops::control_flow::ControlFlow::Continue",
                                0
                              |) in
                            let val := M.copy (| γ0_0 |) in
                            val))
                      ]
                    |)
                  |) in
                M.match_operator (|
                  Some
                    (Ty.apply
                      (Ty.path "core::option::Option")
                      []
                      [ Ty.apply (Ty.path "alloc::rc::Rc") [] [ T; A ] ]),
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ :=
                          M.use
                            (M.alloc (|
                              BinOp.eq (|
                                M.call_closure (|
                                  Ty.path "usize",
                                  M.get_trait_method (|
                                    "alloc::rc::RcInnerPtr",
                                    Ty.path "alloc::rc::WeakInner",
                                    [],
                                    [],
                                    "strong",
                                    [],
                                    []
                                  |),
                                  [ M.borrow (| Pointer.Kind.Ref, inner |) ]
                                |),
                                Value.Integer IntegerKind.Usize 0
                              |)
                            |)) in
                        let _ :=
                          M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let~ _ : Ty.tuple [] :=
                          M.alloc (|
                            M.call_closure (|
                              Ty.tuple [],
                              M.get_trait_method (|
                                "alloc::rc::RcInnerPtr",
                                Ty.path "alloc::rc::WeakInner",
                                [],
                                [],
                                "inc_strong",
                                [],
                                []
                              |),
                              [ M.borrow (| Pointer.Kind.Ref, inner |) ]
                            |)
                          |) in
                        M.alloc (|
                          Value.StructTuple
                            "core::option::Option::Some"
                            [
                              M.call_closure (|
                                Ty.apply (Ty.path "alloc::rc::Rc") [] [ T; A ],
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "alloc::rc::Rc") [] [ T; A ],
                                  "from_inner_in",
                                  [],
                                  []
                                |),
                                [
                                  M.read (|
                                    M.SubPointer.get_struct_record_field (|
                                      M.deref (| M.read (| self |) |),
                                      "alloc::rc::Weak",
                                      "ptr"
                                    |)
                                  |);
                                  M.call_closure (|
                                    A,
                                    M.get_trait_method (|
                                      "core::clone::Clone",
                                      A,
                                      [],
                                      [],
                                      "clone",
                                      [],
                                      []
                                    |),
                                    [
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.SubPointer.get_struct_record_field (|
                                          M.deref (| M.read (| self |) |),
                                          "alloc::rc::Weak",
                                          "alloc"
                                        |)
                                      |)
                                    ]
                                  |)
                                ]
                              |)
                            ]
                        |)))
                  ]
                |)
              |)))
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_upgrade :
      forall (T A : Ty.t),
      M.IsAssociatedFunction.C (Self T A) "upgrade" (upgrade T A).
    Admitted.
    Global Typeclasses Opaque upgrade.
    
    (*
        pub fn strong_count(&self) -> usize {
            if let Some(inner) = self.inner() { inner.strong() } else { 0 }
        }
    *)
    Definition strong_count
        (T A : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              Some (Ty.path "usize"),
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.alloc (|
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "core::option::Option")
                            []
                            [ Ty.path "alloc::rc::WeakInner" ],
                          M.get_associated_function (|
                            Ty.apply (Ty.path "alloc::rc::Weak") [] [ T; A ],
                            "inner",
                            [],
                            []
                          |),
                          [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                        |)
                      |) in
                    let γ0_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "core::option::Option::Some",
                        0
                      |) in
                    let inner := M.copy (| γ0_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.path "usize",
                        M.get_trait_method (|
                          "alloc::rc::RcInnerPtr",
                          Ty.path "alloc::rc::WeakInner",
                          [],
                          [],
                          "strong",
                          [],
                          []
                        |),
                        [ M.borrow (| Pointer.Kind.Ref, inner |) ]
                      |)
                    |)));
                fun γ => ltac:(M.monadic (M.alloc (| Value.Integer IntegerKind.Usize 0 |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_strong_count :
      forall (T A : Ty.t),
      M.IsAssociatedFunction.C (Self T A) "strong_count" (strong_count T A).
    Admitted.
    Global Typeclasses Opaque strong_count.
    
    (*
        pub fn weak_count(&self) -> usize {
            if let Some(inner) = self.inner() {
                if inner.strong() > 0 {
                    inner.weak() - 1 // subtract the implicit weak ptr
                } else {
                    0
                }
            } else {
                0
            }
        }
    *)
    Definition weak_count (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              Some (Ty.path "usize"),
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.alloc (|
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "core::option::Option")
                            []
                            [ Ty.path "alloc::rc::WeakInner" ],
                          M.get_associated_function (|
                            Ty.apply (Ty.path "alloc::rc::Weak") [] [ T; A ],
                            "inner",
                            [],
                            []
                          |),
                          [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                        |)
                      |) in
                    let γ0_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "core::option::Option::Some",
                        0
                      |) in
                    let inner := M.copy (| γ0_0 |) in
                    M.match_operator (|
                      Some (Ty.path "usize"),
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  BinOp.gt (|
                                    M.call_closure (|
                                      Ty.path "usize",
                                      M.get_trait_method (|
                                        "alloc::rc::RcInnerPtr",
                                        Ty.path "alloc::rc::WeakInner",
                                        [],
                                        [],
                                        "strong",
                                        [],
                                        []
                                      |),
                                      [ M.borrow (| Pointer.Kind.Ref, inner |) ]
                                    |),
                                    Value.Integer IntegerKind.Usize 0
                                  |)
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (|
                              BinOp.Wrap.sub (|
                                M.call_closure (|
                                  Ty.path "usize",
                                  M.get_trait_method (|
                                    "alloc::rc::RcInnerPtr",
                                    Ty.path "alloc::rc::WeakInner",
                                    [],
                                    [],
                                    "weak",
                                    [],
                                    []
                                  |),
                                  [ M.borrow (| Pointer.Kind.Ref, inner |) ]
                                |),
                                Value.Integer IntegerKind.Usize 1
                              |)
                            |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Integer IntegerKind.Usize 0 |)))
                      ]
                    |)));
                fun γ => ltac:(M.monadic (M.alloc (| Value.Integer IntegerKind.Usize 0 |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_weak_count :
      forall (T A : Ty.t),
      M.IsAssociatedFunction.C (Self T A) "weak_count" (weak_count T A).
    Admitted.
    Global Typeclasses Opaque weak_count.
    
    (*
        fn inner(&self) -> Option<WeakInner<'_>> {
            if is_dangling(self.ptr.as_ptr()) {
                None
            } else {
                // We are careful to *not* create a reference covering the "data" field, as
                // the field may be mutated concurrently (for example, if the last `Rc`
                // is dropped, the data field will be dropped in-place).
                Some(unsafe {
                    let ptr = self.ptr.as_ptr();
                    WeakInner { strong: &( *ptr).strong, weak: &( *ptr).weak }
                })
            }
        }
    *)
    Definition inner (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              Some
                (Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "alloc::rc::WeakInner" ]),
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          M.call_closure (|
                            Ty.path "bool",
                            M.get_function (|
                              "alloc::rc::is_dangling",
                              [],
                              [ Ty.apply (Ty.path "alloc::rc::RcInner") [] [ T ] ]
                            |),
                            [
                              (* MutToConstPointer *)
                              M.pointer_coercion
                                (M.call_closure (|
                                  Ty.apply
                                    (Ty.path "*mut")
                                    []
                                    [ Ty.apply (Ty.path "alloc::rc::RcInner") [] [ T ] ],
                                  M.get_associated_function (|
                                    Ty.apply
                                      (Ty.path "core::ptr::non_null::NonNull")
                                      []
                                      [ Ty.apply (Ty.path "alloc::rc::RcInner") [] [ T ] ],
                                    "as_ptr",
                                    [],
                                    []
                                  |),
                                  [
                                    M.read (|
                                      M.SubPointer.get_struct_record_field (|
                                        M.deref (| M.read (| self |) |),
                                        "alloc::rc::Weak",
                                        "ptr"
                                      |)
                                    |)
                                  ]
                                |))
                            ]
                          |)
                        |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      Value.StructTuple
                        "core::option::Option::Some"
                        [
                          M.read (|
                            let~ ptr :
                                Ty.apply
                                  (Ty.path "*mut")
                                  []
                                  [ Ty.apply (Ty.path "alloc::rc::RcInner") [] [ T ] ] :=
                              M.alloc (|
                                M.call_closure (|
                                  Ty.apply
                                    (Ty.path "*mut")
                                    []
                                    [ Ty.apply (Ty.path "alloc::rc::RcInner") [] [ T ] ],
                                  M.get_associated_function (|
                                    Ty.apply
                                      (Ty.path "core::ptr::non_null::NonNull")
                                      []
                                      [ Ty.apply (Ty.path "alloc::rc::RcInner") [] [ T ] ],
                                    "as_ptr",
                                    [],
                                    []
                                  |),
                                  [
                                    M.read (|
                                      M.SubPointer.get_struct_record_field (|
                                        M.deref (| M.read (| self |) |),
                                        "alloc::rc::Weak",
                                        "ptr"
                                      |)
                                    |)
                                  ]
                                |)
                              |) in
                            M.alloc (|
                              Value.StructRecord
                                "alloc::rc::WeakInner"
                                [
                                  ("strong",
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.deref (|
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.SubPointer.get_struct_record_field (|
                                            M.deref (| M.read (| ptr |) |),
                                            "alloc::rc::RcInner",
                                            "strong"
                                          |)
                                        |)
                                      |)
                                    |));
                                  ("weak",
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.deref (|
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.SubPointer.get_struct_record_field (|
                                            M.deref (| M.read (| ptr |) |),
                                            "alloc::rc::RcInner",
                                            "weak"
                                          |)
                                        |)
                                      |)
                                    |))
                                ]
                            |)
                          |)
                        ]
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_inner :
      forall (T A : Ty.t),
      M.IsAssociatedFunction.C (Self T A) "inner" (inner T A).
    Admitted.
    Global Typeclasses Opaque inner.
    
    (*
        pub fn ptr_eq(&self, other: &Self) -> bool {
            ptr::addr_eq(self.ptr.as_ptr(), other.ptr.as_ptr())
        }
    *)
    Definition ptr_eq (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            Ty.path "bool",
            M.get_function (|
              "core::ptr::addr_eq",
              [],
              [
                Ty.apply (Ty.path "alloc::rc::RcInner") [] [ T ];
                Ty.apply (Ty.path "alloc::rc::RcInner") [] [ T ]
              ]
            |),
            [
              (* MutToConstPointer *)
              M.pointer_coercion
                (M.call_closure (|
                  Ty.apply (Ty.path "*mut") [] [ Ty.apply (Ty.path "alloc::rc::RcInner") [] [ T ] ],
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "core::ptr::non_null::NonNull")
                      []
                      [ Ty.apply (Ty.path "alloc::rc::RcInner") [] [ T ] ],
                    "as_ptr",
                    [],
                    []
                  |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "alloc::rc::Weak",
                        "ptr"
                      |)
                    |)
                  ]
                |));
              (* MutToConstPointer *)
              M.pointer_coercion
                (M.call_closure (|
                  Ty.apply (Ty.path "*mut") [] [ Ty.apply (Ty.path "alloc::rc::RcInner") [] [ T ] ],
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "core::ptr::non_null::NonNull")
                      []
                      [ Ty.apply (Ty.path "alloc::rc::RcInner") [] [ T ] ],
                    "as_ptr",
                    [],
                    []
                  |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| other |) |),
                        "alloc::rc::Weak",
                        "ptr"
                      |)
                    |)
                  ]
                |))
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_ptr_eq :
      forall (T A : Ty.t),
      M.IsAssociatedFunction.C (Self T A) "ptr_eq" (ptr_eq T A).
    Admitted.
    Global Typeclasses Opaque ptr_eq.
  End Impl_alloc_rc_Weak_T_A.
  
  (*
  pub(crate) fn is_dangling<T: ?Sized>(ptr: *const T) -> bool {
      (ptr.cast::<()>()).addr() == usize::MAX
  }
  *)
  Definition is_dangling (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [ T ], [ ptr ] =>
      ltac:(M.monadic
        (let ptr := M.alloc (| ptr |) in
        BinOp.eq (|
          M.call_closure (|
            Ty.path "usize",
            M.get_associated_function (|
              Ty.apply (Ty.path "*const") [] [ Ty.tuple [] ],
              "addr",
              [],
              []
            |),
            [
              M.call_closure (|
                Ty.apply (Ty.path "*const") [] [ Ty.tuple [] ],
                M.get_associated_function (|
                  Ty.apply (Ty.path "*const") [] [ T ],
                  "cast",
                  [],
                  [ Ty.tuple [] ]
                |),
                [ M.read (| ptr |) ]
              |)
            ]
          |),
          M.read (| get_associated_constant (| Ty.path "usize", "MAX", Ty.path "usize" |) |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_is_dangling :
    M.IsFunction.C "alloc::rc::is_dangling" is_dangling.
  Admitted.
  Global Typeclasses Opaque is_dangling.
  
  (* StructRecord
    {
      name := "WeakInner";
      const_params := [];
      ty_params := [];
      fields :=
        [
          ("weak",
            Ty.apply
              (Ty.path "&")
              []
              [ Ty.apply (Ty.path "core::cell::Cell") [] [ Ty.path "usize" ] ]);
          ("strong",
            Ty.apply
              (Ty.path "&")
              []
              [ Ty.apply (Ty.path "core::cell::Cell") [] [ Ty.path "usize" ] ])
        ];
    } *)
  
  
  
  Module Impl_core_ops_drop_Drop_where_core_marker_Sized_T_where_core_alloc_Allocator_A_for_alloc_rc_Weak_T_A.
    Definition Self (T A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::rc::Weak") [] [ T; A ].
    
    (*
        fn drop(&mut self) {
            let inner = if let Some(inner) = self.inner() { inner } else { return };
    
            inner.dec_weak();
            // the weak count starts at 1, and will only go to zero if all
            // the strong pointers have disappeared.
            if inner.weak() == 0 {
                unsafe {
                    self.alloc.deallocate(self.ptr.cast(), Layout::for_value_raw(self.ptr.as_ptr()));
                }
            }
        }
    *)
    Definition drop (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.catch_return (|
            ltac:(M.monadic
              (M.read (|
                let~ inner : Ty.path "alloc::rc::WeakInner" :=
                  M.copy (|
                    M.match_operator (|
                      Some (Ty.path "alloc::rc::WeakInner"),
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.alloc (|
                                M.call_closure (|
                                  Ty.apply
                                    (Ty.path "core::option::Option")
                                    []
                                    [ Ty.path "alloc::rc::WeakInner" ],
                                  M.get_associated_function (|
                                    Ty.apply (Ty.path "alloc::rc::Weak") [] [ T; A ],
                                    "inner",
                                    [],
                                    []
                                  |),
                                  [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |)
                                  ]
                                |)
                              |) in
                            let γ0_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "core::option::Option::Some",
                                0
                              |) in
                            let inner := M.copy (| γ0_0 |) in
                            inner));
                        fun γ =>
                          ltac:(M.monadic
                            (M.alloc (|
                              M.never_to_any (| M.read (| M.return_ (| Value.Tuple [] |) |) |)
                            |)))
                      ]
                    |)
                  |) in
                let~ _ : Ty.tuple [] :=
                  M.alloc (|
                    M.call_closure (|
                      Ty.tuple [],
                      M.get_trait_method (|
                        "alloc::rc::RcInnerPtr",
                        Ty.path "alloc::rc::WeakInner",
                        [],
                        [],
                        "dec_weak",
                        [],
                        []
                      |),
                      [ M.borrow (| Pointer.Kind.Ref, inner |) ]
                    |)
                  |) in
                M.match_operator (|
                  Some (Ty.tuple []),
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ :=
                          M.use
                            (M.alloc (|
                              BinOp.eq (|
                                M.call_closure (|
                                  Ty.path "usize",
                                  M.get_trait_method (|
                                    "alloc::rc::RcInnerPtr",
                                    Ty.path "alloc::rc::WeakInner",
                                    [],
                                    [],
                                    "weak",
                                    [],
                                    []
                                  |),
                                  [ M.borrow (| Pointer.Kind.Ref, inner |) ]
                                |),
                                Value.Integer IntegerKind.Usize 0
                              |)
                            |)) in
                        let _ :=
                          M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        let~ _ : Ty.tuple [] :=
                          M.alloc (|
                            M.call_closure (|
                              Ty.tuple [],
                              M.get_trait_method (|
                                "core::alloc::Allocator",
                                A,
                                [],
                                [],
                                "deallocate",
                                [],
                                []
                              |),
                              [
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.SubPointer.get_struct_record_field (|
                                    M.deref (| M.read (| self |) |),
                                    "alloc::rc::Weak",
                                    "alloc"
                                  |)
                                |);
                                M.call_closure (|
                                  Ty.apply
                                    (Ty.path "core::ptr::non_null::NonNull")
                                    []
                                    [ Ty.path "u8" ],
                                  M.get_associated_function (|
                                    Ty.apply
                                      (Ty.path "core::ptr::non_null::NonNull")
                                      []
                                      [ Ty.apply (Ty.path "alloc::rc::RcInner") [] [ T ] ],
                                    "cast",
                                    [],
                                    [ Ty.path "u8" ]
                                  |),
                                  [
                                    M.read (|
                                      M.SubPointer.get_struct_record_field (|
                                        M.deref (| M.read (| self |) |),
                                        "alloc::rc::Weak",
                                        "ptr"
                                      |)
                                    |)
                                  ]
                                |);
                                M.call_closure (|
                                  Ty.path "core::alloc::layout::Layout",
                                  M.get_associated_function (|
                                    Ty.path "core::alloc::layout::Layout",
                                    "for_value_raw",
                                    [],
                                    [ Ty.apply (Ty.path "alloc::rc::RcInner") [] [ T ] ]
                                  |),
                                  [
                                    (* MutToConstPointer *)
                                    M.pointer_coercion
                                      (M.call_closure (|
                                        Ty.apply
                                          (Ty.path "*mut")
                                          []
                                          [ Ty.apply (Ty.path "alloc::rc::RcInner") [] [ T ] ],
                                        M.get_associated_function (|
                                          Ty.apply
                                            (Ty.path "core::ptr::non_null::NonNull")
                                            []
                                            [ Ty.apply (Ty.path "alloc::rc::RcInner") [] [ T ] ],
                                          "as_ptr",
                                          [],
                                          []
                                        |),
                                        [
                                          M.read (|
                                            M.SubPointer.get_struct_record_field (|
                                              M.deref (| M.read (| self |) |),
                                              "alloc::rc::Weak",
                                              "ptr"
                                            |)
                                          |)
                                        ]
                                      |))
                                  ]
                                |)
                              ]
                            |)
                          |) in
                        M.alloc (| Value.Tuple [] |)));
                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                  ]
                |)
              |)))
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (T A : Ty.t),
      M.IsTraitInstance
        "core::ops::drop::Drop"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self T A)
        (* Instance *) [ ("drop", InstanceField.Method (drop T A)) ].
  End Impl_core_ops_drop_Drop_where_core_marker_Sized_T_where_core_alloc_Allocator_A_for_alloc_rc_Weak_T_A.
  
  Module Impl_core_clone_Clone_where_core_marker_Sized_T_where_core_alloc_Allocator_A_where_core_clone_Clone_A_for_alloc_rc_Weak_T_A.
    Definition Self (T A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::rc::Weak") [] [ T; A ].
    
    (*
        fn clone(&self) -> Weak<T, A> {
            if let Some(inner) = self.inner() {
                inner.inc_weak()
            }
            Weak { ptr: self.ptr, alloc: self.alloc.clone() }
        }
    *)
    Definition clone (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            let~ _ : Ty.tuple [] :=
              M.match_operator (|
                Some (Ty.tuple []),
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.alloc (|
                          M.call_closure (|
                            Ty.apply
                              (Ty.path "core::option::Option")
                              []
                              [ Ty.path "alloc::rc::WeakInner" ],
                            M.get_associated_function (|
                              Ty.apply (Ty.path "alloc::rc::Weak") [] [ T; A ],
                              "inner",
                              [],
                              []
                            |),
                            [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                          |)
                        |) in
                      let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::option::Option::Some",
                          0
                        |) in
                      let inner := M.copy (| γ0_0 |) in
                      M.alloc (|
                        M.call_closure (|
                          Ty.tuple [],
                          M.get_trait_method (|
                            "alloc::rc::RcInnerPtr",
                            Ty.path "alloc::rc::WeakInner",
                            [],
                            [],
                            "inc_weak",
                            [],
                            []
                          |),
                          [ M.borrow (| Pointer.Kind.Ref, inner |) ]
                        |)
                      |)));
                  fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                ]
              |) in
            M.alloc (|
              Value.StructRecord
                "alloc::rc::Weak"
                [
                  ("ptr",
                    M.read (|
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "alloc::rc::Weak",
                        "ptr"
                      |)
                    |));
                  ("alloc",
                    M.call_closure (|
                      A,
                      M.get_trait_method (| "core::clone::Clone", A, [], [], "clone", [], [] |),
                      [
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "alloc::rc::Weak",
                            "alloc"
                          |)
                        |)
                      ]
                    |))
                ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (T A : Ty.t),
      M.IsTraitInstance
        "core::clone::Clone"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self T A)
        (* Instance *) [ ("clone", InstanceField.Method (clone T A)) ].
  End Impl_core_clone_Clone_where_core_marker_Sized_T_where_core_alloc_Allocator_A_where_core_clone_Clone_A_for_alloc_rc_Weak_T_A.
  
  Module Impl_core_fmt_Debug_where_core_marker_Sized_T_where_core_alloc_Allocator_A_for_alloc_rc_Weak_T_A.
    Definition Self (T A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::rc::Weak") [] [ T; A ].
    
    (*
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            write!(f, "(Weak)")
        }
    *)
    Definition fmt (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "core::result::Result")
              []
              [ Ty.tuple []; Ty.path "core::fmt::Error" ],
            M.get_associated_function (| Ty.path "core::fmt::Formatter", "write_fmt", [], [] |),
            [
              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
              M.call_closure (|
                Ty.path "core::fmt::Arguments",
                M.get_associated_function (|
                  Ty.path "core::fmt::Arguments",
                  "new_const",
                  [ Value.Integer IntegerKind.Usize 1 ],
                  []
                |),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.alloc (| Value.Array [ mk_str (| "(Weak)" |) ] |)
                      |)
                    |)
                  |)
                ]
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (T A : Ty.t),
      M.IsTraitInstance
        "core::fmt::Debug"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self T A)
        (* Instance *) [ ("fmt", InstanceField.Method (fmt T A)) ].
  End Impl_core_fmt_Debug_where_core_marker_Sized_T_where_core_alloc_Allocator_A_for_alloc_rc_Weak_T_A.
  
  Module Impl_core_default_Default_for_alloc_rc_Weak_T_alloc_alloc_Global.
    Definition Self (T : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "alloc::rc::Weak") [] [ T; Ty.path "alloc::alloc::Global" ].
    
    (*
        fn default() -> Weak<T> {
            Weak::new()
        }
    *)
    Definition default (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [], [] =>
        ltac:(M.monadic
          (M.call_closure (|
            Ty.apply (Ty.path "alloc::rc::Weak") [] [ T; Ty.path "alloc::alloc::Global" ],
            M.get_associated_function (|
              Ty.apply (Ty.path "alloc::rc::Weak") [] [ T; Ty.path "alloc::alloc::Global" ],
              "new",
              [],
              []
            |),
            []
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "core::default::Default"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self T)
        (* Instance *) [ ("default", InstanceField.Method (default T)) ].
  End Impl_core_default_Default_for_alloc_rc_Weak_T_alloc_alloc_Global.
  
  (* Trait *)
  Module RcInnerPtr.
    Definition strong (Self : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            Ty.path "usize",
            M.get_associated_function (|
              Ty.apply (Ty.path "core::cell::Cell") [] [ Ty.path "usize" ],
              "get",
              [],
              []
            |),
            [
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "&")
                      []
                      [ Ty.apply (Ty.path "core::cell::Cell") [] [ Ty.path "usize" ] ],
                    M.get_trait_method (|
                      "alloc::rc::RcInnerPtr",
                      Self,
                      [],
                      [],
                      "strong_ref",
                      [],
                      []
                    |),
                    [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                  |)
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom ProvidedMethod_strong : M.IsProvidedMethod "alloc::rc::RcInnerPtr" "strong" strong.
    Definition inc_strong (Self : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            let~ strong : Ty.path "usize" :=
              M.alloc (|
                M.call_closure (|
                  Ty.path "usize",
                  M.get_trait_method (| "alloc::rc::RcInnerPtr", Self, [], [], "strong", [], [] |),
                  [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                |)
              |) in
            let~ _ : Ty.tuple [] :=
              let~ _ : Ty.tuple [] :=
                M.alloc (|
                  M.call_closure (|
                    Ty.tuple [],
                    M.get_function (| "core::hint::assert_unchecked", [], [] |),
                    [ BinOp.ne (| M.read (| strong |), Value.Integer IntegerKind.Usize 0 |) ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |) in
            let~ strong : Ty.path "usize" :=
              M.alloc (|
                M.call_closure (|
                  Ty.path "usize",
                  M.get_associated_function (| Ty.path "usize", "wrapping_add", [], [] |),
                  [ M.read (| strong |); Value.Integer IntegerKind.Usize 1 ]
                |)
              |) in
            let~ _ : Ty.tuple [] :=
              M.alloc (|
                M.call_closure (|
                  Ty.tuple [],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::Cell") [] [ Ty.path "usize" ],
                    "set",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "&")
                            []
                            [ Ty.apply (Ty.path "core::cell::Cell") [] [ Ty.path "usize" ] ],
                          M.get_trait_method (|
                            "alloc::rc::RcInnerPtr",
                            Self,
                            [],
                            [],
                            "strong_ref",
                            [],
                            []
                          |),
                          [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                        |)
                      |)
                    |);
                    M.read (| strong |)
                  ]
                |)
              |) in
            M.match_operator (|
              Some (Ty.tuple []),
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          M.call_closure (|
                            Ty.path "bool",
                            M.get_function (| "core::intrinsics::unlikely", [], [] |),
                            [ BinOp.eq (| M.read (| strong |), Value.Integer IntegerKind.Usize 0 |)
                            ]
                          |)
                        |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (|
                      M.never_to_any (|
                        M.call_closure (|
                          Ty.path "never",
                          M.get_function (| "core::intrinsics::abort", [], [] |),
                          []
                        |)
                      |)
                    |)));
                fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom ProvidedMethod_inc_strong :
      M.IsProvidedMethod "alloc::rc::RcInnerPtr" "inc_strong" inc_strong.
    Definition dec_strong (Self : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            let~ _ : Ty.tuple [] :=
              M.alloc (|
                M.call_closure (|
                  Ty.tuple [],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::Cell") [] [ Ty.path "usize" ],
                    "set",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "&")
                            []
                            [ Ty.apply (Ty.path "core::cell::Cell") [] [ Ty.path "usize" ] ],
                          M.get_trait_method (|
                            "alloc::rc::RcInnerPtr",
                            Self,
                            [],
                            [],
                            "strong_ref",
                            [],
                            []
                          |),
                          [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                        |)
                      |)
                    |);
                    BinOp.Wrap.sub (|
                      M.call_closure (|
                        Ty.path "usize",
                        M.get_trait_method (|
                          "alloc::rc::RcInnerPtr",
                          Self,
                          [],
                          [],
                          "strong",
                          [],
                          []
                        |),
                        [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                      |),
                      Value.Integer IntegerKind.Usize 1
                    |)
                  ]
                |)
              |) in
            M.alloc (| Value.Tuple [] |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom ProvidedMethod_dec_strong :
      M.IsProvidedMethod "alloc::rc::RcInnerPtr" "dec_strong" dec_strong.
    Definition weak (Self : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            Ty.path "usize",
            M.get_associated_function (|
              Ty.apply (Ty.path "core::cell::Cell") [] [ Ty.path "usize" ],
              "get",
              [],
              []
            |),
            [
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "&")
                      []
                      [ Ty.apply (Ty.path "core::cell::Cell") [] [ Ty.path "usize" ] ],
                    M.get_trait_method (|
                      "alloc::rc::RcInnerPtr",
                      Self,
                      [],
                      [],
                      "weak_ref",
                      [],
                      []
                    |),
                    [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                  |)
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom ProvidedMethod_weak : M.IsProvidedMethod "alloc::rc::RcInnerPtr" "weak" weak.
    Definition inc_weak (Self : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            let~ weak : Ty.path "usize" :=
              M.alloc (|
                M.call_closure (|
                  Ty.path "usize",
                  M.get_trait_method (| "alloc::rc::RcInnerPtr", Self, [], [], "weak", [], [] |),
                  [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                |)
              |) in
            let~ _ : Ty.tuple [] :=
              let~ _ : Ty.tuple [] :=
                M.alloc (|
                  M.call_closure (|
                    Ty.tuple [],
                    M.get_function (| "core::hint::assert_unchecked", [], [] |),
                    [ BinOp.ne (| M.read (| weak |), Value.Integer IntegerKind.Usize 0 |) ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |) in
            let~ weak : Ty.path "usize" :=
              M.alloc (|
                M.call_closure (|
                  Ty.path "usize",
                  M.get_associated_function (| Ty.path "usize", "wrapping_add", [], [] |),
                  [ M.read (| weak |); Value.Integer IntegerKind.Usize 1 ]
                |)
              |) in
            let~ _ : Ty.tuple [] :=
              M.alloc (|
                M.call_closure (|
                  Ty.tuple [],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::Cell") [] [ Ty.path "usize" ],
                    "set",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "&")
                            []
                            [ Ty.apply (Ty.path "core::cell::Cell") [] [ Ty.path "usize" ] ],
                          M.get_trait_method (|
                            "alloc::rc::RcInnerPtr",
                            Self,
                            [],
                            [],
                            "weak_ref",
                            [],
                            []
                          |),
                          [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                        |)
                      |)
                    |);
                    M.read (| weak |)
                  ]
                |)
              |) in
            M.match_operator (|
              Some (Ty.tuple []),
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          M.call_closure (|
                            Ty.path "bool",
                            M.get_function (| "core::intrinsics::unlikely", [], [] |),
                            [ BinOp.eq (| M.read (| weak |), Value.Integer IntegerKind.Usize 0 |) ]
                          |)
                        |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (|
                      M.never_to_any (|
                        M.call_closure (|
                          Ty.path "never",
                          M.get_function (| "core::intrinsics::abort", [], [] |),
                          []
                        |)
                      |)
                    |)));
                fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom ProvidedMethod_inc_weak : M.IsProvidedMethod "alloc::rc::RcInnerPtr" "inc_weak" inc_weak.
    Definition dec_weak (Self : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            let~ _ : Ty.tuple [] :=
              M.alloc (|
                M.call_closure (|
                  Ty.tuple [],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::Cell") [] [ Ty.path "usize" ],
                    "set",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "&")
                            []
                            [ Ty.apply (Ty.path "core::cell::Cell") [] [ Ty.path "usize" ] ],
                          M.get_trait_method (|
                            "alloc::rc::RcInnerPtr",
                            Self,
                            [],
                            [],
                            "weak_ref",
                            [],
                            []
                          |),
                          [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                        |)
                      |)
                    |);
                    BinOp.Wrap.sub (|
                      M.call_closure (|
                        Ty.path "usize",
                        M.get_trait_method (|
                          "alloc::rc::RcInnerPtr",
                          Self,
                          [],
                          [],
                          "weak",
                          [],
                          []
                        |),
                        [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                      |),
                      Value.Integer IntegerKind.Usize 1
                    |)
                  ]
                |)
              |) in
            M.alloc (| Value.Tuple [] |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom ProvidedMethod_dec_weak : M.IsProvidedMethod "alloc::rc::RcInnerPtr" "dec_weak" dec_weak.
  End RcInnerPtr.
  
  Module Impl_alloc_rc_RcInnerPtr_where_core_marker_Sized_T_for_alloc_rc_RcInner_T.
    Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::rc::RcInner") [] [ T ].
    
    (*
        fn weak_ref(&self) -> &Cell<usize> {
            &self.weak
        }
    *)
    Definition weak_ref (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.borrow (|
            Pointer.Kind.Ref,
            M.deref (|
              M.borrow (|
                Pointer.Kind.Ref,
                M.SubPointer.get_struct_record_field (|
                  M.deref (| M.read (| self |) |),
                  "alloc::rc::RcInner",
                  "weak"
                |)
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    (*
        fn strong_ref(&self) -> &Cell<usize> {
            &self.strong
        }
    *)
    Definition strong_ref (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.borrow (|
            Pointer.Kind.Ref,
            M.deref (|
              M.borrow (|
                Pointer.Kind.Ref,
                M.SubPointer.get_struct_record_field (|
                  M.deref (| M.read (| self |) |),
                  "alloc::rc::RcInner",
                  "strong"
                |)
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "alloc::rc::RcInnerPtr"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self T)
        (* Instance *)
        [
          ("weak_ref", InstanceField.Method (weak_ref T));
          ("strong_ref", InstanceField.Method (strong_ref T))
        ].
  End Impl_alloc_rc_RcInnerPtr_where_core_marker_Sized_T_for_alloc_rc_RcInner_T.
  
  Module Impl_alloc_rc_RcInnerPtr_for_alloc_rc_WeakInner.
    Definition Self : Ty.t := Ty.path "alloc::rc::WeakInner".
    
    (*
        fn weak_ref(&self) -> &Cell<usize> {
            self.weak
        }
    *)
    Definition weak_ref (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.borrow (|
            Pointer.Kind.Ref,
            M.deref (|
              M.read (|
                M.SubPointer.get_struct_record_field (|
                  M.deref (| M.read (| self |) |),
                  "alloc::rc::WeakInner",
                  "weak"
                |)
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    (*
        fn strong_ref(&self) -> &Cell<usize> {
            self.strong
        }
    *)
    Definition strong_ref (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.borrow (|
            Pointer.Kind.Ref,
            M.deref (|
              M.read (|
                M.SubPointer.get_struct_record_field (|
                  M.deref (| M.read (| self |) |),
                  "alloc::rc::WeakInner",
                  "strong"
                |)
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "alloc::rc::RcInnerPtr"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *)
        [
          ("weak_ref", InstanceField.Method weak_ref);
          ("strong_ref", InstanceField.Method strong_ref)
        ].
  End Impl_alloc_rc_RcInnerPtr_for_alloc_rc_WeakInner.
  
  Module Impl_core_borrow_Borrow_where_core_marker_Sized_T_where_core_alloc_Allocator_A_T_for_alloc_rc_Rc_T_A.
    Definition Self (T A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::rc::Rc") [] [ T; A ].
    
    (*
        fn borrow(&self) -> &T {
            &**self
        }
    *)
    Definition borrow (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.borrow (|
            Pointer.Kind.Ref,
            M.deref (|
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.call_closure (|
                    Ty.apply (Ty.path "&") [] [ T ],
                    M.get_trait_method (|
                      "core::ops::deref::Deref",
                      Ty.apply (Ty.path "alloc::rc::Rc") [] [ T; A ],
                      [],
                      [],
                      "deref",
                      [],
                      []
                    |),
                    [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                  |)
                |)
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (T A : Ty.t),
      M.IsTraitInstance
        "core::borrow::Borrow"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ T ]
        (Self T A)
        (* Instance *) [ ("borrow", InstanceField.Method (borrow T A)) ].
  End Impl_core_borrow_Borrow_where_core_marker_Sized_T_where_core_alloc_Allocator_A_T_for_alloc_rc_Rc_T_A.
  
  Module Impl_core_convert_AsRef_where_core_marker_Sized_T_where_core_alloc_Allocator_A_T_for_alloc_rc_Rc_T_A.
    Definition Self (T A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::rc::Rc") [] [ T; A ].
    
    (*
        fn as_ref(&self) -> &T {
            &**self
        }
    *)
    Definition as_ref (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.borrow (|
            Pointer.Kind.Ref,
            M.deref (|
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.call_closure (|
                    Ty.apply (Ty.path "&") [] [ T ],
                    M.get_trait_method (|
                      "core::ops::deref::Deref",
                      Ty.apply (Ty.path "alloc::rc::Rc") [] [ T; A ],
                      [],
                      [],
                      "deref",
                      [],
                      []
                    |),
                    [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                  |)
                |)
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (T A : Ty.t),
      M.IsTraitInstance
        "core::convert::AsRef"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ T ]
        (Self T A)
        (* Instance *) [ ("as_ref", InstanceField.Method (as_ref T A)) ].
  End Impl_core_convert_AsRef_where_core_marker_Sized_T_where_core_alloc_Allocator_A_T_for_alloc_rc_Rc_T_A.
  
  Module Impl_core_marker_Unpin_where_core_marker_Sized_T_where_core_alloc_Allocator_A_for_alloc_rc_Rc_T_A.
    Definition Self (T A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::rc::Rc") [] [ T; A ].
    
    Axiom Implements :
      forall (T A : Ty.t),
      M.IsTraitInstance
        "core::marker::Unpin"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self T A)
        (* Instance *) [].
  End Impl_core_marker_Unpin_where_core_marker_Sized_T_where_core_alloc_Allocator_A_for_alloc_rc_Rc_T_A.
  
  (*
  unsafe fn data_offset<T: ?Sized>(ptr: *const T) -> usize {
      // Align the unsized value to the end of the RcInner.
      // Because RcInner is repr(C), it will always be the last field in memory.
      // SAFETY: since the only unsized types possible are slices, trait objects,
      // and extern types, the input safety requirement is currently enough to
      // satisfy the requirements of align_of_val_raw; this is an implementation
      // detail of the language that must not be relied upon outside of std.
      unsafe { data_offset_align(align_of_val_raw(ptr)) }
  }
  *)
  Definition data_offset (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [ T ], [ ptr ] =>
      ltac:(M.monadic
        (let ptr := M.alloc (| ptr |) in
        M.call_closure (|
          Ty.path "usize",
          M.get_function (| "alloc::rc::data_offset_align", [], [] |),
          [
            M.call_closure (|
              Ty.path "usize",
              M.get_function (| "core::mem::align_of_val_raw", [], [ T ] |),
              [ M.read (| ptr |) ]
            |)
          ]
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_data_offset :
    M.IsFunction.C "alloc::rc::data_offset" data_offset.
  Admitted.
  Global Typeclasses Opaque data_offset.
  
  (*
  fn data_offset_align(align: usize) -> usize {
      let layout = Layout::new::<RcInner<()>>();
      layout.size() + layout.padding_needed_for(align)
  }
  *)
  Definition data_offset_align (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ align ] =>
      ltac:(M.monadic
        (let align := M.alloc (| align |) in
        M.read (|
          let~ layout : Ty.path "core::alloc::layout::Layout" :=
            M.alloc (|
              M.call_closure (|
                Ty.path "core::alloc::layout::Layout",
                M.get_associated_function (|
                  Ty.path "core::alloc::layout::Layout",
                  "new",
                  [],
                  [ Ty.apply (Ty.path "alloc::rc::RcInner") [] [ Ty.tuple [] ] ]
                |),
                []
              |)
            |) in
          M.alloc (|
            BinOp.Wrap.add (|
              M.call_closure (|
                Ty.path "usize",
                M.get_associated_function (|
                  Ty.path "core::alloc::layout::Layout",
                  "size",
                  [],
                  []
                |),
                [ M.borrow (| Pointer.Kind.Ref, layout |) ]
              |),
              M.call_closure (|
                Ty.path "usize",
                M.get_associated_function (|
                  Ty.path "core::alloc::layout::Layout",
                  "padding_needed_for",
                  [],
                  []
                |),
                [ M.borrow (| Pointer.Kind.Ref, layout |); M.read (| align |) ]
              |)
            |)
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_data_offset_align :
    M.IsFunction.C "alloc::rc::data_offset_align" data_offset_align.
  Admitted.
  Global Typeclasses Opaque data_offset_align.
  
  (* StructRecord
    {
      name := "UniqueRc";
      const_params := [];
      ty_params := [ "T"; "A" ];
      fields :=
        [
          ("ptr",
            Ty.apply
              (Ty.path "core::ptr::non_null::NonNull")
              []
              [ Ty.apply (Ty.path "alloc::rc::RcInner") [] [ T ] ]);
          ("phantom",
            Ty.apply
              (Ty.path "core::marker::PhantomData")
              []
              [ Ty.apply (Ty.path "alloc::rc::RcInner") [] [ T ] ]);
          ("alloc", A)
        ];
    } *)
  
  Module Impl_core_fmt_Debug_where_core_fmt_Debug_T_where_core_marker_Sized_T_where_core_fmt_Debug_A_where_core_alloc_Allocator_A_for_alloc_rc_UniqueRc_T_A.
    Definition Self (T A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::rc::UniqueRc") [] [ T; A ].
    
    (* Debug *)
    Definition fmt (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "core::result::Result")
              []
              [ Ty.tuple []; Ty.path "core::fmt::Error" ],
            M.get_associated_function (|
              Ty.path "core::fmt::Formatter",
              "debug_struct_field3_finish",
              [],
              []
            |),
            [
              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
              M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "UniqueRc" |) |) |);
              M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "ptr" |) |) |);
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| self |) |),
                      "alloc::rc::UniqueRc",
                      "ptr"
                    |)
                  |)
                |)
              |);
              M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "phantom" |) |) |);
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| self |) |),
                      "alloc::rc::UniqueRc",
                      "phantom"
                    |)
                  |)
                |)
              |);
              M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "alloc" |) |) |);
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.alloc (|
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "alloc::rc::UniqueRc",
                          "alloc"
                        |)
                      |)
                    |)
                  |)
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (T A : Ty.t),
      M.IsTraitInstance
        "core::fmt::Debug"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self T A)
        (* Instance *) [ ("fmt", InstanceField.Method (fmt T A)) ].
  End Impl_core_fmt_Debug_where_core_fmt_Debug_T_where_core_marker_Sized_T_where_core_fmt_Debug_A_where_core_alloc_Allocator_A_for_alloc_rc_UniqueRc_T_A.
  
  Module Impl_core_ops_unsize_CoerceUnsized_where_core_marker_Sized_T_where_core_marker_Unsize_T_U_where_core_marker_Sized_U_where_core_alloc_Allocator_A_alloc_rc_UniqueRc_U_A_for_alloc_rc_UniqueRc_T_A.
    Definition Self (T U A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::rc::UniqueRc") [] [ T; A ].
    
    Axiom Implements :
      forall (T U A : Ty.t),
      M.IsTraitInstance
        "core::ops::unsize::CoerceUnsized"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.apply (Ty.path "alloc::rc::UniqueRc") [] [ U; A ] ]
        (Self T U A)
        (* Instance *) [].
  End Impl_core_ops_unsize_CoerceUnsized_where_core_marker_Sized_T_where_core_marker_Unsize_T_U_where_core_marker_Sized_U_where_core_alloc_Allocator_A_alloc_rc_UniqueRc_U_A_for_alloc_rc_UniqueRc_T_A.
  
  Module Impl_alloc_rc_UniqueRc_T_alloc_alloc_Global.
    Definition Self (T : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "alloc::rc::UniqueRc") [] [ T; Ty.path "alloc::alloc::Global" ].
    
    (*
        pub fn new(value: T) -> Self {
            Self::new_in(value, Global)
        }
    *)
    Definition new (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [], [ value ] =>
        ltac:(M.monadic
          (let value := M.alloc (| value |) in
          M.call_closure (|
            Ty.apply (Ty.path "alloc::rc::UniqueRc") [] [ T; Ty.path "alloc::alloc::Global" ],
            M.get_associated_function (|
              Ty.apply (Ty.path "alloc::rc::UniqueRc") [] [ T; Ty.path "alloc::alloc::Global" ],
              "new_in",
              [],
              []
            |),
            [ M.read (| value |); Value.StructTuple "alloc::alloc::Global" [] ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_new :
      forall (T : Ty.t),
      M.IsAssociatedFunction.C (Self T) "new" (new T).
    Admitted.
    Global Typeclasses Opaque new.
  End Impl_alloc_rc_UniqueRc_T_alloc_alloc_Global.
  
  Module Impl_alloc_rc_UniqueRc_T_A.
    Definition Self (T A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::rc::UniqueRc") [] [ T; A ].
    
    (*
        pub fn new_in(value: T, alloc: A) -> Self {
            let (ptr, alloc) = Box::into_unique(Box::new_in(
                RcInner {
                    strong: Cell::new(0),
                    // keep one weak reference so if all the weak pointers that are created are dropped
                    // the UniqueRc still stays valid.
                    weak: Cell::new(1),
                    value,
                },
                alloc,
            ));
            Self { ptr: ptr.into(), phantom: PhantomData, alloc }
        }
    *)
    Definition new_in (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ value; alloc ] =>
        ltac:(M.monadic
          (let value := M.alloc (| value |) in
          let alloc := M.alloc (| alloc |) in
          M.read (|
            M.match_operator (|
              None,
              M.alloc (|
                M.call_closure (|
                  Ty.tuple
                    [
                      Ty.apply
                        (Ty.path "core::ptr::unique::Unique")
                        []
                        [ Ty.apply (Ty.path "alloc::rc::RcInner") [] [ T ] ];
                      A
                    ],
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "alloc::boxed::Box")
                      []
                      [ Ty.apply (Ty.path "alloc::rc::RcInner") [] [ T ]; A ],
                    "into_unique",
                    [],
                    []
                  |),
                  [
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "alloc::boxed::Box")
                        []
                        [ Ty.apply (Ty.path "alloc::rc::RcInner") [] [ T ]; A ],
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "alloc::boxed::Box")
                          []
                          [ Ty.apply (Ty.path "alloc::rc::RcInner") [] [ T ]; A ],
                        "new_in",
                        [],
                        []
                      |),
                      [
                        Value.StructRecord
                          "alloc::rc::RcInner"
                          [
                            ("strong",
                              M.call_closure (|
                                Ty.apply (Ty.path "core::cell::Cell") [] [ Ty.path "usize" ],
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "core::cell::Cell") [] [ Ty.path "usize" ],
                                  "new",
                                  [],
                                  []
                                |),
                                [ Value.Integer IntegerKind.Usize 0 ]
                              |));
                            ("weak",
                              M.call_closure (|
                                Ty.apply (Ty.path "core::cell::Cell") [] [ Ty.path "usize" ],
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "core::cell::Cell") [] [ Ty.path "usize" ],
                                  "new",
                                  [],
                                  []
                                |),
                                [ Value.Integer IntegerKind.Usize 1 ]
                              |));
                            ("value", M.read (| value |))
                          ];
                        M.read (| alloc |)
                      ]
                    |)
                  ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let ptr := M.copy (| γ0_0 |) in
                    let alloc := M.copy (| γ0_1 |) in
                    M.alloc (|
                      Value.StructRecord
                        "alloc::rc::UniqueRc"
                        [
                          ("ptr",
                            M.call_closure (|
                              Ty.apply
                                (Ty.path "core::ptr::non_null::NonNull")
                                []
                                [ Ty.apply (Ty.path "alloc::rc::RcInner") [] [ T ] ],
                              M.get_trait_method (|
                                "core::convert::Into",
                                Ty.apply
                                  (Ty.path "core::ptr::unique::Unique")
                                  []
                                  [ Ty.apply (Ty.path "alloc::rc::RcInner") [] [ T ] ],
                                [],
                                [
                                  Ty.apply
                                    (Ty.path "core::ptr::non_null::NonNull")
                                    []
                                    [ Ty.apply (Ty.path "alloc::rc::RcInner") [] [ T ] ]
                                ],
                                "into",
                                [],
                                []
                              |),
                              [ M.read (| ptr |) ]
                            |));
                          ("phantom", Value.StructTuple "core::marker::PhantomData" []);
                          ("alloc", M.read (| alloc |))
                        ]
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_new_in :
      forall (T A : Ty.t),
      M.IsAssociatedFunction.C (Self T A) "new_in" (new_in T A).
    Admitted.
    Global Typeclasses Opaque new_in.
    (*
        pub fn into_rc(this: Self) -> Rc<T, A> {
            let mut this = ManuallyDrop::new(this);
    
            // Move the allocator out.
            // SAFETY: `this.alloc` will not be accessed again, nor dropped because it is in
            // a `ManuallyDrop`.
            let alloc: A = unsafe { ptr::read(&this.alloc) };
    
            // SAFETY: This pointer was allocated at creation time so we know it is valid.
            unsafe {
                // Convert our weak reference into a strong reference
                this.ptr.as_mut().strong.set(1);
                Rc::from_inner_in(this.ptr, alloc)
            }
        }
    *)
    Definition into_rc (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ this ] =>
        ltac:(M.monadic
          (let this := M.alloc (| this |) in
          M.read (|
            let~ this :
                Ty.apply
                  (Ty.path "core::mem::manually_drop::ManuallyDrop")
                  []
                  [ Ty.apply (Ty.path "alloc::rc::UniqueRc") [] [ T; A ] ] :=
              M.alloc (|
                M.call_closure (|
                  Ty.apply
                    (Ty.path "core::mem::manually_drop::ManuallyDrop")
                    []
                    [ Ty.apply (Ty.path "alloc::rc::UniqueRc") [] [ T; A ] ],
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "core::mem::manually_drop::ManuallyDrop")
                      []
                      [ Ty.apply (Ty.path "alloc::rc::UniqueRc") [] [ T; A ] ],
                    "new",
                    [],
                    []
                  |),
                  [ M.read (| this |) ]
                |)
              |) in
            let~ alloc : A :=
              M.alloc (|
                M.call_closure (|
                  A,
                  M.get_function (| "core::ptr::read", [], [ A ] |),
                  [
                    M.borrow (|
                      Pointer.Kind.ConstPointer,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (|
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "&")
                                  []
                                  [ Ty.apply (Ty.path "alloc::rc::UniqueRc") [] [ T; A ] ],
                                M.get_trait_method (|
                                  "core::ops::deref::Deref",
                                  Ty.apply
                                    (Ty.path "core::mem::manually_drop::ManuallyDrop")
                                    []
                                    [ Ty.apply (Ty.path "alloc::rc::UniqueRc") [] [ T; A ] ],
                                  [],
                                  [],
                                  "deref",
                                  [],
                                  []
                                |),
                                [ M.borrow (| Pointer.Kind.Ref, this |) ]
                              |)
                            |),
                            "alloc::rc::UniqueRc",
                            "alloc"
                          |)
                        |)
                      |)
                    |)
                  ]
                |)
              |) in
            let~ _ : Ty.tuple [] :=
              M.alloc (|
                M.call_closure (|
                  Ty.tuple [],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::Cell") [] [ Ty.path "usize" ],
                    "set",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (|
                          M.call_closure (|
                            Ty.apply
                              (Ty.path "&mut")
                              []
                              [ Ty.apply (Ty.path "alloc::rc::RcInner") [] [ T ] ],
                            M.get_associated_function (|
                              Ty.apply
                                (Ty.path "core::ptr::non_null::NonNull")
                                []
                                [ Ty.apply (Ty.path "alloc::rc::RcInner") [] [ T ] ],
                              "as_mut",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.MutRef,
                                M.SubPointer.get_struct_record_field (|
                                  M.deref (|
                                    M.call_closure (|
                                      Ty.apply
                                        (Ty.path "&mut")
                                        []
                                        [ Ty.apply (Ty.path "alloc::rc::UniqueRc") [] [ T; A ] ],
                                      M.get_trait_method (|
                                        "core::ops::deref::DerefMut",
                                        Ty.apply
                                          (Ty.path "core::mem::manually_drop::ManuallyDrop")
                                          []
                                          [ Ty.apply (Ty.path "alloc::rc::UniqueRc") [] [ T; A ] ],
                                        [],
                                        [],
                                        "deref_mut",
                                        [],
                                        []
                                      |),
                                      [ M.borrow (| Pointer.Kind.MutRef, this |) ]
                                    |)
                                  |),
                                  "alloc::rc::UniqueRc",
                                  "ptr"
                                |)
                              |)
                            ]
                          |)
                        |),
                        "alloc::rc::RcInner",
                        "strong"
                      |)
                    |);
                    Value.Integer IntegerKind.Usize 1
                  ]
                |)
              |) in
            M.alloc (|
              M.call_closure (|
                Ty.apply (Ty.path "alloc::rc::Rc") [] [ T; A ],
                M.get_associated_function (|
                  Ty.apply (Ty.path "alloc::rc::Rc") [] [ T; A ],
                  "from_inner_in",
                  [],
                  []
                |),
                [
                  M.read (|
                    M.SubPointer.get_struct_record_field (|
                      M.deref (|
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "&")
                            []
                            [ Ty.apply (Ty.path "alloc::rc::UniqueRc") [] [ T; A ] ],
                          M.get_trait_method (|
                            "core::ops::deref::Deref",
                            Ty.apply
                              (Ty.path "core::mem::manually_drop::ManuallyDrop")
                              []
                              [ Ty.apply (Ty.path "alloc::rc::UniqueRc") [] [ T; A ] ],
                            [],
                            [],
                            "deref",
                            [],
                            []
                          |),
                          [ M.borrow (| Pointer.Kind.Ref, this |) ]
                        |)
                      |),
                      "alloc::rc::UniqueRc",
                      "ptr"
                    |)
                  |);
                  M.read (| alloc |)
                ]
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_into_rc :
      forall (T A : Ty.t),
      M.IsAssociatedFunction.C (Self T A) "into_rc" (into_rc T A).
    Admitted.
    Global Typeclasses Opaque into_rc.
    (*
        pub fn downgrade(this: &Self) -> Weak<T, A> {
            // SAFETY: This pointer was allocated at creation time and we guarantee that we only have
            // one strong reference before converting to a regular Rc.
            unsafe {
                this.ptr.as_ref().inc_weak();
            }
            Weak { ptr: this.ptr, alloc: this.alloc.clone() }
        }
    *)
    Definition downgrade (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ this ] =>
        ltac:(M.monadic
          (let this := M.alloc (| this |) in
          M.read (|
            let~ _ : Ty.tuple [] :=
              let~ _ : Ty.tuple [] :=
                M.alloc (|
                  M.call_closure (|
                    Ty.tuple [],
                    M.get_trait_method (|
                      "alloc::rc::RcInnerPtr",
                      Ty.apply (Ty.path "alloc::rc::RcInner") [] [ T ],
                      [],
                      [],
                      "inc_weak",
                      [],
                      []
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.deref (|
                          M.call_closure (|
                            Ty.apply
                              (Ty.path "&")
                              []
                              [ Ty.apply (Ty.path "alloc::rc::RcInner") [] [ T ] ],
                            M.get_associated_function (|
                              Ty.apply
                                (Ty.path "core::ptr::non_null::NonNull")
                                []
                                [ Ty.apply (Ty.path "alloc::rc::RcInner") [] [ T ] ],
                              "as_ref",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.SubPointer.get_struct_record_field (|
                                  M.deref (| M.read (| this |) |),
                                  "alloc::rc::UniqueRc",
                                  "ptr"
                                |)
                              |)
                            ]
                          |)
                        |)
                      |)
                    ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |) in
            M.alloc (|
              Value.StructRecord
                "alloc::rc::Weak"
                [
                  ("ptr",
                    M.read (|
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| this |) |),
                        "alloc::rc::UniqueRc",
                        "ptr"
                      |)
                    |));
                  ("alloc",
                    M.call_closure (|
                      A,
                      M.get_trait_method (| "core::clone::Clone", A, [], [], "clone", [], [] |),
                      [
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| this |) |),
                            "alloc::rc::UniqueRc",
                            "alloc"
                          |)
                        |)
                      ]
                    |))
                ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_downgrade :
      forall (T A : Ty.t),
      M.IsAssociatedFunction.C (Self T A) "downgrade" (downgrade T A).
    Admitted.
    Global Typeclasses Opaque downgrade.
  End Impl_alloc_rc_UniqueRc_T_A.
  
  
  
  Module Impl_core_ops_deref_Deref_where_core_marker_Sized_T_where_core_alloc_Allocator_A_for_alloc_rc_UniqueRc_T_A.
    Definition Self (T A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::rc::UniqueRc") [] [ T; A ].
    
    (*     type Target = T; *)
    Definition _Target (T A : Ty.t) : Ty.t := T.
    
    (*
        fn deref(&self) -> &T {
            // SAFETY: This pointer was allocated at creation time so we know it is valid.
            unsafe { &self.ptr.as_ref().value }
        }
    *)
    Definition deref (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.borrow (|
            Pointer.Kind.Ref,
            M.deref (|
              M.borrow (|
                Pointer.Kind.Ref,
                M.SubPointer.get_struct_record_field (|
                  M.deref (|
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "&")
                        []
                        [ Ty.apply (Ty.path "alloc::rc::RcInner") [] [ T ] ],
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "core::ptr::non_null::NonNull")
                          []
                          [ Ty.apply (Ty.path "alloc::rc::RcInner") [] [ T ] ],
                        "as_ref",
                        [],
                        []
                      |),
                      [
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "alloc::rc::UniqueRc",
                            "ptr"
                          |)
                        |)
                      ]
                    |)
                  |),
                  "alloc::rc::RcInner",
                  "value"
                |)
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (T A : Ty.t),
      M.IsTraitInstance
        "core::ops::deref::Deref"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self T A)
        (* Instance *)
        [ ("Target", InstanceField.Ty (_Target T A)); ("deref", InstanceField.Method (deref T A)) ].
  End Impl_core_ops_deref_Deref_where_core_marker_Sized_T_where_core_alloc_Allocator_A_for_alloc_rc_UniqueRc_T_A.
  
  Module Impl_core_pin_PinCoerceUnsized_where_core_marker_Sized_T_for_alloc_rc_UniqueRc_T_alloc_alloc_Global.
    Definition Self (T : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "alloc::rc::UniqueRc") [] [ T; Ty.path "alloc::alloc::Global" ].
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "core::pin::PinCoerceUnsized"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self T)
        (* Instance *) [].
  End Impl_core_pin_PinCoerceUnsized_where_core_marker_Sized_T_for_alloc_rc_UniqueRc_T_alloc_alloc_Global.
  
  Module Impl_core_ops_deref_DerefMut_where_core_marker_Sized_T_where_core_alloc_Allocator_A_for_alloc_rc_UniqueRc_T_A.
    Definition Self (T A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::rc::UniqueRc") [] [ T; A ].
    
    (*
        fn deref_mut(&mut self) -> &mut T {
            // SAFETY: This pointer was allocated at creation time so we know it is valid. We know we
            // have unique ownership and therefore it's safe to make a mutable reference because
            // `UniqueRc` owns the only strong reference to itself.
            unsafe { &mut ( *self.ptr.as_ptr()).value }
        }
    *)
    Definition deref_mut (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.borrow (|
            Pointer.Kind.MutRef,
            M.deref (|
              M.borrow (|
                Pointer.Kind.MutRef,
                M.deref (|
                  M.borrow (|
                    Pointer.Kind.MutRef,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.MutRef,
                        M.SubPointer.get_struct_record_field (|
                          M.deref (|
                            M.call_closure (|
                              Ty.apply
                                (Ty.path "*mut")
                                []
                                [ Ty.apply (Ty.path "alloc::rc::RcInner") [] [ T ] ],
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "core::ptr::non_null::NonNull")
                                  []
                                  [ Ty.apply (Ty.path "alloc::rc::RcInner") [] [ T ] ],
                                "as_ptr",
                                [],
                                []
                              |),
                              [
                                M.read (|
                                  M.SubPointer.get_struct_record_field (|
                                    M.deref (| M.read (| self |) |),
                                    "alloc::rc::UniqueRc",
                                    "ptr"
                                  |)
                                |)
                              ]
                            |)
                          |),
                          "alloc::rc::RcInner",
                          "value"
                        |)
                      |)
                    |)
                  |)
                |)
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (T A : Ty.t),
      M.IsTraitInstance
        "core::ops::deref::DerefMut"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self T A)
        (* Instance *) [ ("deref_mut", InstanceField.Method (deref_mut T A)) ].
  End Impl_core_ops_deref_DerefMut_where_core_marker_Sized_T_where_core_alloc_Allocator_A_for_alloc_rc_UniqueRc_T_A.
  
  Module Impl_core_ops_drop_Drop_where_core_marker_Sized_T_where_core_alloc_Allocator_A_for_alloc_rc_UniqueRc_T_A.
    Definition Self (T A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::rc::UniqueRc") [] [ T; A ].
    
    (*
        fn drop(&mut self) {
            unsafe {
                // destroy the contained object
                drop_in_place(DerefMut::deref_mut(self));
    
                // remove the implicit "strong weak" pointer now that we've destroyed the contents.
                self.ptr.as_ref().dec_weak();
    
                if self.ptr.as_ref().weak() == 0 {
                    self.alloc.deallocate(self.ptr.cast(), Layout::for_value_raw(self.ptr.as_ptr()));
                }
            }
        }
    *)
    Definition drop (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            let~ _ : Ty.tuple [] :=
              M.alloc (|
                M.call_closure (|
                  Ty.tuple [],
                  M.get_function (| "core::ptr::drop_in_place", [], [ T ] |),
                  [
                    M.borrow (|
                      Pointer.Kind.MutPointer,
                      M.deref (|
                        M.call_closure (|
                          Ty.apply (Ty.path "&mut") [] [ T ],
                          M.get_trait_method (|
                            "core::ops::deref::DerefMut",
                            Ty.apply (Ty.path "alloc::rc::UniqueRc") [] [ T; A ],
                            [],
                            [],
                            "deref_mut",
                            [],
                            []
                          |),
                          [ M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |) ]
                        |)
                      |)
                    |)
                  ]
                |)
              |) in
            let~ _ : Ty.tuple [] :=
              M.alloc (|
                M.call_closure (|
                  Ty.tuple [],
                  M.get_trait_method (|
                    "alloc::rc::RcInnerPtr",
                    Ty.apply (Ty.path "alloc::rc::RcInner") [] [ T ],
                    [],
                    [],
                    "dec_weak",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "&")
                            []
                            [ Ty.apply (Ty.path "alloc::rc::RcInner") [] [ T ] ],
                          M.get_associated_function (|
                            Ty.apply
                              (Ty.path "core::ptr::non_null::NonNull")
                              []
                              [ Ty.apply (Ty.path "alloc::rc::RcInner") [] [ T ] ],
                            "as_ref",
                            [],
                            []
                          |),
                          [
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.SubPointer.get_struct_record_field (|
                                M.deref (| M.read (| self |) |),
                                "alloc::rc::UniqueRc",
                                "ptr"
                              |)
                            |)
                          ]
                        |)
                      |)
                    |)
                  ]
                |)
              |) in
            M.match_operator (|
              Some (Ty.tuple []),
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          BinOp.eq (|
                            M.call_closure (|
                              Ty.path "usize",
                              M.get_trait_method (|
                                "alloc::rc::RcInnerPtr",
                                Ty.apply (Ty.path "alloc::rc::RcInner") [] [ T ],
                                [],
                                [],
                                "weak",
                                [],
                                []
                              |),
                              [
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.deref (|
                                    M.call_closure (|
                                      Ty.apply
                                        (Ty.path "&")
                                        []
                                        [ Ty.apply (Ty.path "alloc::rc::RcInner") [] [ T ] ],
                                      M.get_associated_function (|
                                        Ty.apply
                                          (Ty.path "core::ptr::non_null::NonNull")
                                          []
                                          [ Ty.apply (Ty.path "alloc::rc::RcInner") [] [ T ] ],
                                        "as_ref",
                                        [],
                                        []
                                      |),
                                      [
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.SubPointer.get_struct_record_field (|
                                            M.deref (| M.read (| self |) |),
                                            "alloc::rc::UniqueRc",
                                            "ptr"
                                          |)
                                        |)
                                      ]
                                    |)
                                  |)
                                |)
                              ]
                            |),
                            Value.Integer IntegerKind.Usize 0
                          |)
                        |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    let~ _ : Ty.tuple [] :=
                      M.alloc (|
                        M.call_closure (|
                          Ty.tuple [],
                          M.get_trait_method (|
                            "core::alloc::Allocator",
                            A,
                            [],
                            [],
                            "deallocate",
                            [],
                            []
                          |),
                          [
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.SubPointer.get_struct_record_field (|
                                M.deref (| M.read (| self |) |),
                                "alloc::rc::UniqueRc",
                                "alloc"
                              |)
                            |);
                            M.call_closure (|
                              Ty.apply (Ty.path "core::ptr::non_null::NonNull") [] [ Ty.path "u8" ],
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "core::ptr::non_null::NonNull")
                                  []
                                  [ Ty.apply (Ty.path "alloc::rc::RcInner") [] [ T ] ],
                                "cast",
                                [],
                                [ Ty.path "u8" ]
                              |),
                              [
                                M.read (|
                                  M.SubPointer.get_struct_record_field (|
                                    M.deref (| M.read (| self |) |),
                                    "alloc::rc::UniqueRc",
                                    "ptr"
                                  |)
                                |)
                              ]
                            |);
                            M.call_closure (|
                              Ty.path "core::alloc::layout::Layout",
                              M.get_associated_function (|
                                Ty.path "core::alloc::layout::Layout",
                                "for_value_raw",
                                [],
                                [ Ty.apply (Ty.path "alloc::rc::RcInner") [] [ T ] ]
                              |),
                              [
                                (* MutToConstPointer *)
                                M.pointer_coercion
                                  (M.call_closure (|
                                    Ty.apply
                                      (Ty.path "*mut")
                                      []
                                      [ Ty.apply (Ty.path "alloc::rc::RcInner") [] [ T ] ],
                                    M.get_associated_function (|
                                      Ty.apply
                                        (Ty.path "core::ptr::non_null::NonNull")
                                        []
                                        [ Ty.apply (Ty.path "alloc::rc::RcInner") [] [ T ] ],
                                      "as_ptr",
                                      [],
                                      []
                                    |),
                                    [
                                      M.read (|
                                        M.SubPointer.get_struct_record_field (|
                                          M.deref (| M.read (| self |) |),
                                          "alloc::rc::UniqueRc",
                                          "ptr"
                                        |)
                                      |)
                                    ]
                                  |))
                              ]
                            |)
                          ]
                        |)
                      |) in
                    M.alloc (| Value.Tuple [] |)));
                fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (T A : Ty.t),
      M.IsTraitInstance
        "core::ops::drop::Drop"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self T A)
        (* Instance *) [ ("drop", InstanceField.Method (drop T A)) ].
  End Impl_core_ops_drop_Drop_where_core_marker_Sized_T_where_core_alloc_Allocator_A_for_alloc_rc_UniqueRc_T_A.
  
  (* StructRecord
    {
      name := "UniqueRcUninit";
      const_params := [];
      ty_params := [ "T"; "A" ];
      fields :=
        [
          ("ptr",
            Ty.apply
              (Ty.path "core::ptr::non_null::NonNull")
              []
              [ Ty.apply (Ty.path "alloc::rc::RcInner") [] [ T ] ]);
          ("layout_for_value", Ty.path "core::alloc::layout::Layout");
          ("alloc", Ty.apply (Ty.path "core::option::Option") [] [ A ])
        ];
    } *)
  
  Module Impl_alloc_rc_UniqueRcUninit_T_A.
    Definition Self (T A : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "alloc::rc::UniqueRcUninit") [] [ T; A ].
    
    (*
        fn new(for_value: &T, alloc: A) -> UniqueRcUninit<T, A> {
            let layout = Layout::for_value(for_value);
            let ptr = unsafe {
                Rc::allocate_for_layout(
                    layout,
                    |layout_for_rc_inner| alloc.allocate(layout_for_rc_inner),
                    |mem| mem.with_metadata_of(ptr::from_ref(for_value) as *const RcInner<T>),
                )
            };
            Self { ptr: NonNull::new(ptr).unwrap(), layout_for_value: layout, alloc: Some(alloc) }
        }
    *)
    Definition new (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ for_value; alloc ] =>
        ltac:(M.monadic
          (let for_value := M.alloc (| for_value |) in
          let alloc := M.alloc (| alloc |) in
          M.read (|
            let~ layout : Ty.path "core::alloc::layout::Layout" :=
              M.alloc (|
                M.call_closure (|
                  Ty.path "core::alloc::layout::Layout",
                  M.get_associated_function (|
                    Ty.path "core::alloc::layout::Layout",
                    "for_value",
                    [],
                    [ T ]
                  |),
                  [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| for_value |) |) |) ]
                |)
              |) in
            let~ ptr :
                Ty.apply (Ty.path "*mut") [] [ Ty.apply (Ty.path "alloc::rc::RcInner") [] [ T ] ] :=
              M.alloc (|
                M.call_closure (|
                  Ty.apply (Ty.path "*mut") [] [ Ty.apply (Ty.path "alloc::rc::RcInner") [] [ T ] ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "alloc::rc::Rc") [] [ T; Ty.path "alloc::alloc::Global" ],
                    "allocate_for_layout",
                    [],
                    [
                      Ty.function
                        [ Ty.tuple [ Ty.path "core::alloc::layout::Layout" ] ]
                        (Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [
                            Ty.apply
                              (Ty.path "core::ptr::non_null::NonNull")
                              []
                              [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ];
                            Ty.path "core::alloc::AllocError"
                          ]);
                      Ty.function
                        [ Ty.tuple [ Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ] ] ]
                        (Ty.apply
                          (Ty.path "*mut")
                          []
                          [ Ty.apply (Ty.path "alloc::rc::RcInner") [] [ T ] ])
                    ]
                  |),
                  [
                    M.read (| layout |);
                    M.closure
                      (fun γ =>
                        ltac:(M.monadic
                          match γ with
                          | [ α0 ] =>
                            ltac:(M.monadic
                              (M.match_operator (|
                                Some
                                  (Ty.function
                                    [ Ty.tuple [ Ty.path "core::alloc::layout::Layout" ] ]
                                    (Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [
                                        Ty.apply
                                          (Ty.path "core::ptr::non_null::NonNull")
                                          []
                                          [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ];
                                        Ty.path "core::alloc::AllocError"
                                      ])),
                                M.alloc (| α0 |),
                                [
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let layout_for_rc_inner := M.copy (| γ |) in
                                      M.call_closure (|
                                        Ty.apply
                                          (Ty.path "core::result::Result")
                                          []
                                          [
                                            Ty.apply
                                              (Ty.path "core::ptr::non_null::NonNull")
                                              []
                                              [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ];
                                            Ty.path "core::alloc::AllocError"
                                          ],
                                        M.get_trait_method (|
                                          "core::alloc::Allocator",
                                          A,
                                          [],
                                          [],
                                          "allocate",
                                          [],
                                          []
                                        |),
                                        [
                                          M.borrow (| Pointer.Kind.Ref, alloc |);
                                          M.read (| layout_for_rc_inner |)
                                        ]
                                      |)))
                                ]
                              |)))
                          | _ => M.impossible "wrong number of arguments"
                          end));
                    M.closure
                      (fun γ =>
                        ltac:(M.monadic
                          match γ with
                          | [ α0 ] =>
                            ltac:(M.monadic
                              (M.match_operator (|
                                Some
                                  (Ty.function
                                    [ Ty.tuple [ Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ] ] ]
                                    (Ty.apply
                                      (Ty.path "*mut")
                                      []
                                      [ Ty.apply (Ty.path "alloc::rc::RcInner") [] [ T ] ])),
                                M.alloc (| α0 |),
                                [
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let mem := M.copy (| γ |) in
                                      M.call_closure (|
                                        Ty.apply
                                          (Ty.path "*mut")
                                          []
                                          [ Ty.apply (Ty.path "alloc::rc::RcInner") [] [ T ] ],
                                        M.get_associated_function (|
                                          Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ],
                                          "with_metadata_of",
                                          [],
                                          [ Ty.apply (Ty.path "alloc::rc::RcInner") [] [ T ] ]
                                        |),
                                        [
                                          M.read (| mem |);
                                          M.cast
                                            (Ty.apply
                                              (Ty.path "*const")
                                              []
                                              [ Ty.apply (Ty.path "alloc::rc::RcInner") [] [ T ] ])
                                            (M.call_closure (|
                                              Ty.apply (Ty.path "*const") [] [ T ],
                                              M.get_function (| "core::ptr::from_ref", [], [ T ] |),
                                              [
                                                M.borrow (|
                                                  Pointer.Kind.Ref,
                                                  M.deref (| M.read (| for_value |) |)
                                                |)
                                              ]
                                            |))
                                        ]
                                      |)))
                                ]
                              |)))
                          | _ => M.impossible "wrong number of arguments"
                          end))
                  ]
                |)
              |) in
            M.alloc (|
              Value.StructRecord
                "alloc::rc::UniqueRcUninit"
                [
                  ("ptr",
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "core::ptr::non_null::NonNull")
                        []
                        [ Ty.apply (Ty.path "alloc::rc::RcInner") [] [ T ] ],
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "core::option::Option")
                          []
                          [
                            Ty.apply
                              (Ty.path "core::ptr::non_null::NonNull")
                              []
                              [ Ty.apply (Ty.path "alloc::rc::RcInner") [] [ T ] ]
                          ],
                        "unwrap",
                        [],
                        []
                      |),
                      [
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "core::option::Option")
                            []
                            [
                              Ty.apply
                                (Ty.path "core::ptr::non_null::NonNull")
                                []
                                [ Ty.apply (Ty.path "alloc::rc::RcInner") [] [ T ] ]
                            ],
                          M.get_associated_function (|
                            Ty.apply
                              (Ty.path "core::ptr::non_null::NonNull")
                              []
                              [ Ty.apply (Ty.path "alloc::rc::RcInner") [] [ T ] ],
                            "new",
                            [],
                            []
                          |),
                          [ M.read (| ptr |) ]
                        |)
                      ]
                    |));
                  ("layout_for_value", M.read (| layout |));
                  ("alloc", Value.StructTuple "core::option::Option::Some" [ M.read (| alloc |) ])
                ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_new :
      forall (T A : Ty.t),
      M.IsAssociatedFunction.C (Self T A) "new" (new T A).
    Admitted.
    Global Typeclasses Opaque new.
    
    (*
        fn data_ptr(&mut self) -> *mut T {
            let offset = data_offset_align(self.layout_for_value.align());
            unsafe { self.ptr.as_ptr().byte_add(offset) as *mut T }
        }
    *)
    Definition data_ptr (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            let~ offset : Ty.path "usize" :=
              M.alloc (|
                M.call_closure (|
                  Ty.path "usize",
                  M.get_function (| "alloc::rc::data_offset_align", [], [] |),
                  [
                    M.call_closure (|
                      Ty.path "usize",
                      M.get_associated_function (|
                        Ty.path "core::alloc::layout::Layout",
                        "align",
                        [],
                        []
                      |),
                      [
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "alloc::rc::UniqueRcUninit",
                            "layout_for_value"
                          |)
                        |)
                      ]
                    |)
                  ]
                |)
              |) in
            M.alloc (|
              M.cast
                (Ty.apply (Ty.path "*mut") [] [ T ])
                (M.call_closure (|
                  Ty.apply (Ty.path "*mut") [] [ Ty.apply (Ty.path "alloc::rc::RcInner") [] [ T ] ],
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "*mut")
                      []
                      [ Ty.apply (Ty.path "alloc::rc::RcInner") [] [ T ] ],
                    "byte_add",
                    [],
                    []
                  |),
                  [
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "*mut")
                        []
                        [ Ty.apply (Ty.path "alloc::rc::RcInner") [] [ T ] ],
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "core::ptr::non_null::NonNull")
                          []
                          [ Ty.apply (Ty.path "alloc::rc::RcInner") [] [ T ] ],
                        "as_ptr",
                        [],
                        []
                      |),
                      [
                        M.read (|
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "alloc::rc::UniqueRcUninit",
                            "ptr"
                          |)
                        |)
                      ]
                    |);
                    M.read (| offset |)
                  ]
                |))
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_data_ptr :
      forall (T A : Ty.t),
      M.IsAssociatedFunction.C (Self T A) "data_ptr" (data_ptr T A).
    Admitted.
    Global Typeclasses Opaque data_ptr.
    
    (*
        unsafe fn into_rc(self) -> Rc<T, A> {
            let mut this = ManuallyDrop::new(self);
            let ptr = this.ptr;
            let alloc = this.alloc.take().unwrap();
    
            // SAFETY: The pointer is valid as per `UniqueRcUninit::new`, and the caller is responsible
            // for having initialized the data.
            unsafe { Rc::from_ptr_in(ptr.as_ptr(), alloc) }
        }
    *)
    Definition into_rc (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            let~ this :
                Ty.apply
                  (Ty.path "core::mem::manually_drop::ManuallyDrop")
                  []
                  [ Ty.apply (Ty.path "alloc::rc::UniqueRcUninit") [] [ T; A ] ] :=
              M.alloc (|
                M.call_closure (|
                  Ty.apply
                    (Ty.path "core::mem::manually_drop::ManuallyDrop")
                    []
                    [ Ty.apply (Ty.path "alloc::rc::UniqueRcUninit") [] [ T; A ] ],
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "core::mem::manually_drop::ManuallyDrop")
                      []
                      [ Ty.apply (Ty.path "alloc::rc::UniqueRcUninit") [] [ T; A ] ],
                    "new",
                    [],
                    []
                  |),
                  [ M.read (| self |) ]
                |)
              |) in
            let~ ptr :
                Ty.apply
                  (Ty.path "core::ptr::non_null::NonNull")
                  []
                  [ Ty.apply (Ty.path "alloc::rc::RcInner") [] [ T ] ] :=
              M.copy (|
                M.SubPointer.get_struct_record_field (|
                  M.deref (|
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "&")
                        []
                        [ Ty.apply (Ty.path "alloc::rc::UniqueRcUninit") [] [ T; A ] ],
                      M.get_trait_method (|
                        "core::ops::deref::Deref",
                        Ty.apply
                          (Ty.path "core::mem::manually_drop::ManuallyDrop")
                          []
                          [ Ty.apply (Ty.path "alloc::rc::UniqueRcUninit") [] [ T; A ] ],
                        [],
                        [],
                        "deref",
                        [],
                        []
                      |),
                      [ M.borrow (| Pointer.Kind.Ref, this |) ]
                    |)
                  |),
                  "alloc::rc::UniqueRcUninit",
                  "ptr"
                |)
              |) in
            let~ alloc : A :=
              M.alloc (|
                M.call_closure (|
                  A,
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::option::Option") [] [ A ],
                    "unwrap",
                    [],
                    []
                  |),
                  [
                    M.call_closure (|
                      Ty.apply (Ty.path "core::option::Option") [] [ A ],
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::option::Option") [] [ A ],
                        "take",
                        [],
                        []
                      |),
                      [
                        M.borrow (|
                          Pointer.Kind.MutRef,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (|
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "&mut")
                                  []
                                  [ Ty.apply (Ty.path "alloc::rc::UniqueRcUninit") [] [ T; A ] ],
                                M.get_trait_method (|
                                  "core::ops::deref::DerefMut",
                                  Ty.apply
                                    (Ty.path "core::mem::manually_drop::ManuallyDrop")
                                    []
                                    [ Ty.apply (Ty.path "alloc::rc::UniqueRcUninit") [] [ T; A ] ],
                                  [],
                                  [],
                                  "deref_mut",
                                  [],
                                  []
                                |),
                                [ M.borrow (| Pointer.Kind.MutRef, this |) ]
                              |)
                            |),
                            "alloc::rc::UniqueRcUninit",
                            "alloc"
                          |)
                        |)
                      ]
                    |)
                  ]
                |)
              |) in
            M.alloc (|
              M.call_closure (|
                Ty.apply (Ty.path "alloc::rc::Rc") [] [ T; A ],
                M.get_associated_function (|
                  Ty.apply (Ty.path "alloc::rc::Rc") [] [ T; A ],
                  "from_ptr_in",
                  [],
                  []
                |),
                [
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "*mut")
                      []
                      [ Ty.apply (Ty.path "alloc::rc::RcInner") [] [ T ] ],
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "core::ptr::non_null::NonNull")
                        []
                        [ Ty.apply (Ty.path "alloc::rc::RcInner") [] [ T ] ],
                      "as_ptr",
                      [],
                      []
                    |),
                    [ M.read (| ptr |) ]
                  |);
                  M.read (| alloc |)
                ]
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_into_rc :
      forall (T A : Ty.t),
      M.IsAssociatedFunction.C (Self T A) "into_rc" (into_rc T A).
    Admitted.
    Global Typeclasses Opaque into_rc.
  End Impl_alloc_rc_UniqueRcUninit_T_A.
  
  Module Impl_core_ops_drop_Drop_where_core_marker_Sized_T_where_core_alloc_Allocator_A_for_alloc_rc_UniqueRcUninit_T_A.
    Definition Self (T A : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "alloc::rc::UniqueRcUninit") [] [ T; A ].
    
    (*
        fn drop(&mut self) {
            // SAFETY:
            // * new() produced a pointer safe to deallocate.
            // * We own the pointer unless into_rc() was called, which forgets us.
            unsafe {
                self.alloc.take().unwrap().deallocate(
                    self.ptr.cast(),
                    rc_inner_layout_for_value_layout(self.layout_for_value),
                );
            }
        }
    *)
    Definition drop (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            let~ _ : Ty.tuple [] :=
              M.alloc (|
                M.call_closure (|
                  Ty.tuple [],
                  M.get_trait_method (|
                    "core::alloc::Allocator",
                    A,
                    [],
                    [],
                    "deallocate",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.alloc (|
                        M.call_closure (|
                          A,
                          M.get_associated_function (|
                            Ty.apply (Ty.path "core::option::Option") [] [ A ],
                            "unwrap",
                            [],
                            []
                          |),
                          [
                            M.call_closure (|
                              Ty.apply (Ty.path "core::option::Option") [] [ A ],
                              M.get_associated_function (|
                                Ty.apply (Ty.path "core::option::Option") [] [ A ],
                                "take",
                                [],
                                []
                              |),
                              [
                                M.borrow (|
                                  Pointer.Kind.MutRef,
                                  M.SubPointer.get_struct_record_field (|
                                    M.deref (| M.read (| self |) |),
                                    "alloc::rc::UniqueRcUninit",
                                    "alloc"
                                  |)
                                |)
                              ]
                            |)
                          ]
                        |)
                      |)
                    |);
                    M.call_closure (|
                      Ty.apply (Ty.path "core::ptr::non_null::NonNull") [] [ Ty.path "u8" ],
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "core::ptr::non_null::NonNull")
                          []
                          [ Ty.apply (Ty.path "alloc::rc::RcInner") [] [ T ] ],
                        "cast",
                        [],
                        [ Ty.path "u8" ]
                      |),
                      [
                        M.read (|
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "alloc::rc::UniqueRcUninit",
                            "ptr"
                          |)
                        |)
                      ]
                    |);
                    M.call_closure (|
                      Ty.path "core::alloc::layout::Layout",
                      M.get_function (| "alloc::rc::rc_inner_layout_for_value_layout", [], [] |),
                      [
                        M.read (|
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "alloc::rc::UniqueRcUninit",
                            "layout_for_value"
                          |)
                        |)
                      ]
                    |)
                  ]
                |)
              |) in
            M.alloc (| Value.Tuple [] |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (T A : Ty.t),
      M.IsTraitInstance
        "core::ops::drop::Drop"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self T A)
        (* Instance *) [ ("drop", InstanceField.Method (drop T A)) ].
  End Impl_core_ops_drop_Drop_where_core_marker_Sized_T_where_core_alloc_Allocator_A_for_alloc_rc_UniqueRcUninit_T_A.
End rc.
