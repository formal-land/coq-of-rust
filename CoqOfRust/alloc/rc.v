(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module rc.
  (* StructRecord
    {
      name := "RcBox";
      ty_params := [ "T" ];
      fields :=
        [
          ("strong", Ty.apply (Ty.path "core::cell::Cell") [ Ty.path "usize" ]);
          ("weak", Ty.apply (Ty.path "core::cell::Cell") [ Ty.path "usize" ]);
          ("value", T)
        ];
    } *)
  
  (*
  fn rcbox_layout_for_value_layout(layout: Layout) -> Layout {
      // Calculate layout using the given value layout.
      // Previously, layout was calculated on the expression
      // `&*(ptr as *const RcBox<T>)`, but this created a misaligned
      // reference (see #54908).
      Layout::new::<RcBox<()>>().extend(layout).unwrap().0.pad_to_align()
  }
  *)
  Definition rcbox_layout_for_value_layout (τ : list Ty.t) (α : list Value.t) : M :=
    match τ, α with
    | [], [ layout ] =>
      ltac:(M.monadic
        (let layout := M.alloc (| layout |) in
        M.call_closure (|
          M.get_associated_function (| Ty.path "core::alloc::layout::Layout", "pad_to_align", [] |),
          [
            M.SubPointer.get_tuple_field (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "core::result::Result")
                      [
                        Ty.tuple [ Ty.path "core::alloc::layout::Layout"; Ty.path "usize" ];
                        Ty.path "core::alloc::layout::LayoutError"
                      ],
                    "unwrap",
                    []
                  |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.path "core::alloc::layout::Layout",
                        "extend",
                        []
                      |),
                      [
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::alloc::layout::Layout",
                              "new",
                              [ Ty.apply (Ty.path "alloc::rc::RcBox") [ Ty.tuple [] ] ]
                            |),
                            []
                          |)
                        |);
                        M.read (| layout |)
                      ]
                    |)
                  ]
                |)
              |),
              0
            |)
          ]
        |)))
    | _, _ => M.impossible
    end.
  
  (* StructRecord
    {
      name := "Rc";
      ty_params := [ "T"; "A" ];
      fields :=
        [
          ("ptr",
            Ty.apply
              (Ty.path "core::ptr::non_null::NonNull")
              [ Ty.apply (Ty.path "alloc::rc::RcBox") [ T ] ]);
          ("phantom",
            Ty.apply
              (Ty.path "core::marker::PhantomData")
              [ Ty.apply (Ty.path "alloc::rc::RcBox") [ T ] ]);
          ("alloc", A)
        ];
    } *)
  
  Module Impl_core_marker_Send_where_core_marker_Sized_T_where_core_alloc_Allocator_A_for_alloc_rc_Rc_T_A.
    Definition Self (T A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::rc::Rc") [ T; A ].
    
    Axiom Implements :
      forall (T A : Ty.t),
      M.IsTraitInstance
        "core::marker::Send"
        (Self T A)
        (* Trait polymorphic types *) []
        (* Instance *) [].
  End Impl_core_marker_Send_where_core_marker_Sized_T_where_core_alloc_Allocator_A_for_alloc_rc_Rc_T_A.
  
  Module Impl_core_marker_Sync_where_core_marker_Sized_T_where_core_alloc_Allocator_A_for_alloc_rc_Rc_T_A.
    Definition Self (T A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::rc::Rc") [ T; A ].
    
    Axiom Implements :
      forall (T A : Ty.t),
      M.IsTraitInstance
        "core::marker::Sync"
        (Self T A)
        (* Trait polymorphic types *) []
        (* Instance *) [].
  End Impl_core_marker_Sync_where_core_marker_Sized_T_where_core_alloc_Allocator_A_for_alloc_rc_Rc_T_A.
  
  Module Impl_core_panic_unwind_safe_UnwindSafe_where_core_panic_unwind_safe_RefUnwindSafe_T_where_core_marker_Sized_T_where_core_alloc_Allocator_A_where_core_panic_unwind_safe_UnwindSafe_A_for_alloc_rc_Rc_T_A.
    Definition Self (T A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::rc::Rc") [ T; A ].
    
    Axiom Implements :
      forall (T A : Ty.t),
      M.IsTraitInstance
        "core::panic::unwind_safe::UnwindSafe"
        (Self T A)
        (* Trait polymorphic types *) []
        (* Instance *) [].
  End Impl_core_panic_unwind_safe_UnwindSafe_where_core_panic_unwind_safe_RefUnwindSafe_T_where_core_marker_Sized_T_where_core_alloc_Allocator_A_where_core_panic_unwind_safe_UnwindSafe_A_for_alloc_rc_Rc_T_A.
  
  Module Impl_core_panic_unwind_safe_RefUnwindSafe_where_core_panic_unwind_safe_RefUnwindSafe_T_where_core_marker_Sized_T_where_core_alloc_Allocator_A_where_core_panic_unwind_safe_UnwindSafe_A_for_alloc_rc_Rc_T_A.
    Definition Self (T A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::rc::Rc") [ T; A ].
    
    Axiom Implements :
      forall (T A : Ty.t),
      M.IsTraitInstance
        "core::panic::unwind_safe::RefUnwindSafe"
        (Self T A)
        (* Trait polymorphic types *) []
        (* Instance *) [].
  End Impl_core_panic_unwind_safe_RefUnwindSafe_where_core_panic_unwind_safe_RefUnwindSafe_T_where_core_marker_Sized_T_where_core_alloc_Allocator_A_where_core_panic_unwind_safe_UnwindSafe_A_for_alloc_rc_Rc_T_A.
  
  Module Impl_core_ops_unsize_CoerceUnsized_where_core_marker_Sized_T_where_core_marker_Unsize_T_U_where_core_marker_Sized_U_where_core_alloc_Allocator_A_alloc_rc_Rc_U_A_for_alloc_rc_Rc_T_A.
    Definition Self (T U A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::rc::Rc") [ T; A ].
    
    Axiom Implements :
      forall (T U A : Ty.t),
      M.IsTraitInstance
        "core::ops::unsize::CoerceUnsized"
        (Self T U A)
        (* Trait polymorphic types *) [ (* T *) Ty.apply (Ty.path "alloc::rc::Rc") [ U; A ] ]
        (* Instance *) [].
  End Impl_core_ops_unsize_CoerceUnsized_where_core_marker_Sized_T_where_core_marker_Unsize_T_U_where_core_marker_Sized_U_where_core_alloc_Allocator_A_alloc_rc_Rc_U_A_for_alloc_rc_Rc_T_A.
  
  Module Impl_core_ops_unsize_DispatchFromDyn_where_core_marker_Sized_T_where_core_marker_Unsize_T_U_where_core_marker_Sized_U_alloc_rc_Rc_U_alloc_alloc_Global_for_alloc_rc_Rc_T_alloc_alloc_Global.
    Definition Self (T U : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "alloc::rc::Rc") [ T; Ty.path "alloc::alloc::Global" ].
    
    Axiom Implements :
      forall (T U : Ty.t),
      M.IsTraitInstance
        "core::ops::unsize::DispatchFromDyn"
        (Self T U)
        (* Trait polymorphic types *)
        [ (* T *) Ty.apply (Ty.path "alloc::rc::Rc") [ U; Ty.path "alloc::alloc::Global" ] ]
        (* Instance *) [].
  End Impl_core_ops_unsize_DispatchFromDyn_where_core_marker_Sized_T_where_core_marker_Unsize_T_U_where_core_marker_Sized_U_alloc_rc_Rc_U_alloc_alloc_Global_for_alloc_rc_Rc_T_alloc_alloc_Global.
  
  Module Impl_alloc_rc_Rc_T_alloc_alloc_Global.
    Definition Self (T : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "alloc::rc::Rc") [ T; Ty.path "alloc::alloc::Global" ].
    
    (*
        unsafe fn from_inner(ptr: NonNull<RcBox<T>>) -> Self {
            unsafe { Self::from_inner_in(ptr, Global) }
        }
    *)
    Definition from_inner (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match τ, α with
      | [], [ ptr ] =>
        ltac:(M.monadic
          (let ptr := M.alloc (| ptr |) in
          M.call_closure (|
            M.get_associated_function (|
              Ty.apply (Ty.path "alloc::rc::Rc") [ T; Ty.path "alloc::alloc::Global" ],
              "from_inner_in",
              []
            |),
            [ M.read (| ptr |); Value.StructTuple "alloc::alloc::Global" [] ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_from_inner :
      forall (T : Ty.t),
      M.IsAssociatedFunction (Self T) "from_inner" (from_inner T).
    
    (*
        unsafe fn from_ptr(ptr: *mut RcBox<T>) -> Self {
            unsafe { Self::from_inner(NonNull::new_unchecked(ptr)) }
        }
    *)
    Definition from_ptr (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match τ, α with
      | [], [ ptr ] =>
        ltac:(M.monadic
          (let ptr := M.alloc (| ptr |) in
          M.call_closure (|
            M.get_associated_function (|
              Ty.apply (Ty.path "alloc::rc::Rc") [ T; Ty.path "alloc::alloc::Global" ],
              "from_inner",
              []
            |),
            [
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "core::ptr::non_null::NonNull")
                    [ Ty.apply (Ty.path "alloc::rc::RcBox") [ T ] ],
                  "new_unchecked",
                  []
                |),
                [ M.read (| ptr |) ]
              |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_from_ptr :
      forall (T : Ty.t),
      M.IsAssociatedFunction (Self T) "from_ptr" (from_ptr T).
    (*
        pub fn new(value: T) -> Rc<T> {
            // There is an implicit weak pointer owned by all the strong
            // pointers, which ensures that the weak destructor never frees
            // the allocation while the strong destructor is running, even
            // if the weak pointer is stored inside the strong one.
            unsafe {
                Self::from_inner(
                    Box::leak(Box::new(RcBox { strong: Cell::new(1), weak: Cell::new(1), value }))
                        .into(),
                )
            }
        }
    *)
    Definition new (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match τ, α with
      | [], [ value ] =>
        ltac:(M.monadic
          (let value := M.alloc (| value |) in
          M.call_closure (|
            M.get_associated_function (|
              Ty.apply (Ty.path "alloc::rc::Rc") [ T; Ty.path "alloc::alloc::Global" ],
              "from_inner",
              []
            |),
            [
              M.call_closure (|
                M.get_trait_method (|
                  "core::convert::Into",
                  Ty.apply (Ty.path "&mut") [ Ty.apply (Ty.path "alloc::rc::RcBox") [ T ] ],
                  [
                    Ty.apply
                      (Ty.path "core::ptr::non_null::NonNull")
                      [ Ty.apply (Ty.path "alloc::rc::RcBox") [ T ] ]
                  ],
                  "into",
                  []
                |),
                [
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "alloc::boxed::Box")
                        [
                          Ty.apply (Ty.path "alloc::rc::RcBox") [ T ];
                          Ty.path "alloc::alloc::Global"
                        ],
                      "leak",
                      []
                    |),
                    [
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply
                            (Ty.path "alloc::boxed::Box")
                            [
                              Ty.apply (Ty.path "alloc::rc::RcBox") [ T ];
                              Ty.path "alloc::alloc::Global"
                            ],
                          "new",
                          []
                        |),
                        [
                          Value.StructRecord
                            "alloc::rc::RcBox"
                            [
                              ("strong",
                                M.call_closure (|
                                  M.get_associated_function (|
                                    Ty.apply (Ty.path "core::cell::Cell") [ Ty.path "usize" ],
                                    "new",
                                    []
                                  |),
                                  [ Value.Integer 1 ]
                                |));
                              ("weak",
                                M.call_closure (|
                                  M.get_associated_function (|
                                    Ty.apply (Ty.path "core::cell::Cell") [ Ty.path "usize" ],
                                    "new",
                                    []
                                  |),
                                  [ Value.Integer 1 ]
                                |));
                              ("value", M.read (| value |))
                            ]
                        ]
                      |)
                    ]
                  |)
                ]
              |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_new : forall (T : Ty.t), M.IsAssociatedFunction (Self T) "new" (new T).
    
    (*
        pub fn new_cyclic<F>(data_fn: F) -> Rc<T>
        where
            F: FnOnce(&Weak<T>) -> T,
        {
            // Construct the inner in the "uninitialized" state with a single
            // weak reference.
            let uninit_ptr: NonNull<_> = Box::leak(Box::new(RcBox {
                strong: Cell::new(0),
                weak: Cell::new(1),
                value: mem::MaybeUninit::<T>::uninit(),
            }))
            .into();
    
            let init_ptr: NonNull<RcBox<T>> = uninit_ptr.cast();
    
            let weak = Weak { ptr: init_ptr, alloc: Global };
    
            // It's important we don't give up ownership of the weak pointer, or
            // else the memory might be freed by the time `data_fn` returns. If
            // we really wanted to pass ownership, we could create an additional
            // weak pointer for ourselves, but this would result in additional
            // updates to the weak reference count which might not be necessary
            // otherwise.
            let data = data_fn(&weak);
    
            let strong = unsafe {
                let inner = init_ptr.as_ptr();
                ptr::write(ptr::addr_of_mut!(( *inner).value), data);
    
                let prev_value = ( *inner).strong.get();
                debug_assert_eq!(prev_value, 0, "No prior strong references should exist");
                ( *inner).strong.set(1);
    
                Rc::from_inner(init_ptr)
            };
    
            // Strong references should collectively own a shared weak reference,
            // so don't run the destructor for our old weak reference.
            mem::forget(weak);
            strong
        }
    *)
    Definition new_cyclic (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match τ, α with
      | [ F ], [ data_fn ] =>
        ltac:(M.monadic
          (let data_fn := M.alloc (| data_fn |) in
          M.read (|
            let uninit_ptr :=
              M.alloc (|
                M.call_closure (|
                  M.get_trait_method (|
                    "core::convert::Into",
                    Ty.apply
                      (Ty.path "&mut")
                      [
                        Ty.apply
                          (Ty.path "alloc::rc::RcBox")
                          [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ T ] ]
                      ],
                    [
                      Ty.apply
                        (Ty.path "core::ptr::non_null::NonNull")
                        [
                          Ty.apply
                            (Ty.path "alloc::rc::RcBox")
                            [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ T ] ]
                        ]
                    ],
                    "into",
                    []
                  |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "alloc::boxed::Box")
                          [
                            Ty.apply
                              (Ty.path "alloc::rc::RcBox")
                              [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ T ] ];
                            Ty.path "alloc::alloc::Global"
                          ],
                        "leak",
                        []
                      |),
                      [
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.apply
                              (Ty.path "alloc::boxed::Box")
                              [
                                Ty.apply
                                  (Ty.path "alloc::rc::RcBox")
                                  [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ T ]
                                  ];
                                Ty.path "alloc::alloc::Global"
                              ],
                            "new",
                            []
                          |),
                          [
                            Value.StructRecord
                              "alloc::rc::RcBox"
                              [
                                ("strong",
                                  M.call_closure (|
                                    M.get_associated_function (|
                                      Ty.apply (Ty.path "core::cell::Cell") [ Ty.path "usize" ],
                                      "new",
                                      []
                                    |),
                                    [ Value.Integer 0 ]
                                  |));
                                ("weak",
                                  M.call_closure (|
                                    M.get_associated_function (|
                                      Ty.apply (Ty.path "core::cell::Cell") [ Ty.path "usize" ],
                                      "new",
                                      []
                                    |),
                                    [ Value.Integer 1 ]
                                  |));
                                ("value",
                                  M.call_closure (|
                                    M.get_associated_function (|
                                      Ty.apply
                                        (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                        [ T ],
                                      "uninit",
                                      []
                                    |),
                                    []
                                  |))
                              ]
                          ]
                        |)
                      ]
                    |)
                  ]
                |)
              |) in
            let init_ptr :=
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "core::ptr::non_null::NonNull")
                      [
                        Ty.apply
                          (Ty.path "alloc::rc::RcBox")
                          [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ T ] ]
                      ],
                    "cast",
                    [ Ty.apply (Ty.path "alloc::rc::RcBox") [ T ] ]
                  |),
                  [ M.read (| uninit_ptr |) ]
                |)
              |) in
            let weak :=
              M.alloc (|
                Value.StructRecord
                  "alloc::rc::Weak"
                  [
                    ("ptr", M.read (| init_ptr |));
                    ("alloc", Value.StructTuple "alloc::alloc::Global" [])
                  ]
              |) in
            let data :=
              M.alloc (|
                M.call_closure (|
                  M.get_trait_method (|
                    "core::ops::function::FnOnce",
                    F,
                    [
                      Ty.tuple
                        [
                          Ty.apply
                            (Ty.path "&")
                            [
                              Ty.apply
                                (Ty.path "alloc::rc::Weak")
                                [ T; Ty.path "alloc::alloc::Global" ]
                            ]
                        ]
                    ],
                    "call_once",
                    []
                  |),
                  [ M.read (| data_fn |); Value.Tuple [ weak ] ]
                |)
              |) in
            let strong :=
              M.copy (|
                let inner :=
                  M.alloc (|
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "core::ptr::non_null::NonNull")
                          [ Ty.apply (Ty.path "alloc::rc::RcBox") [ T ] ],
                        "as_ptr",
                        []
                      |),
                      [ M.read (| init_ptr |) ]
                    |)
                  |) in
                let _ :=
                  M.alloc (|
                    M.call_closure (|
                      M.get_function (| "core::ptr::write", [ T ] |),
                      [
                        M.SubPointer.get_struct_record_field (|
                          M.read (| inner |),
                          "alloc::rc::RcBox",
                          "value"
                        |);
                        M.read (| data |)
                      ]
                    |)
                  |) in
                let prev_value :=
                  M.alloc (|
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::cell::Cell") [ Ty.path "usize" ],
                        "get",
                        []
                      |),
                      [
                        M.SubPointer.get_struct_record_field (|
                          M.read (| inner |),
                          "alloc::rc::RcBox",
                          "strong"
                        |)
                      ]
                    |)
                  |) in
                let _ :=
                  M.match_operator (|
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ := M.use (M.alloc (| Value.Bool true |)) in
                          let _ :=
                            M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          let _ :=
                            M.match_operator (|
                              M.alloc (|
                                Value.Tuple [ prev_value; M.alloc (| Value.Integer 0 |) ]
                              |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                    let left_val := M.copy (| γ0_0 |) in
                                    let right_val := M.copy (| γ0_1 |) in
                                    M.match_operator (|
                                      M.alloc (| Value.Tuple [] |),
                                      [
                                        fun γ =>
                                          ltac:(M.monadic
                                            (let γ :=
                                              M.use
                                                (M.alloc (|
                                                  UnOp.Pure.not
                                                    (BinOp.Pure.eq
                                                      (M.read (| M.read (| left_val |) |))
                                                      (M.read (| M.read (| right_val |) |)))
                                                |)) in
                                            let _ :=
                                              M.is_constant_or_break_match (|
                                                M.read (| γ |),
                                                Value.Bool true
                                              |) in
                                            M.alloc (|
                                              M.never_to_any (|
                                                M.read (|
                                                  let kind :=
                                                    M.alloc (|
                                                      Value.StructTuple
                                                        "core::panicking::AssertKind::Eq"
                                                        []
                                                    |) in
                                                  M.alloc (|
                                                    M.call_closure (|
                                                      M.get_function (|
                                                        "core::panicking::assert_failed",
                                                        [ Ty.path "usize"; Ty.path "usize" ]
                                                      |),
                                                      [
                                                        M.read (| kind |);
                                                        M.read (| left_val |);
                                                        M.read (| right_val |);
                                                        Value.StructTuple
                                                          "core::option::Option::Some"
                                                          [
                                                            M.call_closure (|
                                                              M.get_associated_function (|
                                                                Ty.path "core::fmt::Arguments",
                                                                "new_const",
                                                                []
                                                              |),
                                                              [
                                                                (* Unsize *)
                                                                M.pointer_coercion
                                                                  (M.alloc (|
                                                                    Value.Array
                                                                      [
                                                                        M.read (|
                                                                          Value.String
                                                                            "No prior strong references should exist"
                                                                        |)
                                                                      ]
                                                                  |))
                                                              ]
                                                            |)
                                                          ]
                                                      ]
                                                    |)
                                                  |)
                                                |)
                                              |)
                                            |)));
                                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                                      ]
                                    |)))
                              ]
                            |) in
                          M.alloc (| Value.Tuple [] |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                let _ :=
                  M.alloc (|
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::cell::Cell") [ Ty.path "usize" ],
                        "set",
                        []
                      |),
                      [
                        M.SubPointer.get_struct_record_field (|
                          M.read (| inner |),
                          "alloc::rc::RcBox",
                          "strong"
                        |);
                        Value.Integer 1
                      ]
                    |)
                  |) in
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply (Ty.path "alloc::rc::Rc") [ T; Ty.path "alloc::alloc::Global" ],
                      "from_inner",
                      []
                    |),
                    [ M.read (| init_ptr |) ]
                  |)
                |)
              |) in
            let _ :=
              M.alloc (|
                M.call_closure (|
                  M.get_function (|
                    "core::mem::forget",
                    [ Ty.apply (Ty.path "alloc::rc::Weak") [ T; Ty.path "alloc::alloc::Global" ] ]
                  |),
                  [ M.read (| weak |) ]
                |)
              |) in
            strong
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_new_cyclic :
      forall (T : Ty.t),
      M.IsAssociatedFunction (Self T) "new_cyclic" (new_cyclic T).
    
    (*
        pub fn new_uninit() -> Rc<mem::MaybeUninit<T>> {
            unsafe {
                Rc::from_ptr(Rc::allocate_for_layout(
                    Layout::new::<T>(),
                    |layout| Global.allocate(layout),
                    <*mut u8>::cast,
                ))
            }
        }
    *)
    Definition new_uninit (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match τ, α with
      | [], [] =>
        ltac:(M.monadic
          (M.call_closure (|
            M.get_associated_function (|
              Ty.apply
                (Ty.path "alloc::rc::Rc")
                [
                  Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ T ];
                  Ty.path "alloc::alloc::Global"
                ],
              "from_ptr",
              []
            |),
            [
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "alloc::rc::Rc")
                    [
                      Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ T ];
                      Ty.path "alloc::alloc::Global"
                    ],
                  "allocate_for_layout",
                  [
                    Ty.function
                      [ Ty.tuple [ Ty.path "core::alloc::layout::Layout" ] ]
                      (Ty.apply
                        (Ty.path "core::result::Result")
                        [
                          Ty.apply
                            (Ty.path "core::ptr::non_null::NonNull")
                            [ Ty.apply (Ty.path "slice") [ Ty.path "u8" ] ];
                          Ty.path "core::alloc::AllocError"
                        ]);
                    Ty.function
                      [ Ty.apply (Ty.path "*mut") [ Ty.path "u8" ] ]
                      (Ty.apply
                        (Ty.path "*mut")
                        [
                          Ty.apply
                            (Ty.path "alloc::rc::RcBox")
                            [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ T ] ]
                        ])
                  ]
                |),
                [
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.path "core::alloc::layout::Layout",
                      "new",
                      [ T ]
                    |),
                    []
                  |);
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0 ] =>
                          M.match_operator (|
                            M.alloc (| α0 |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let layout := M.copy (| γ |) in
                                  M.call_closure (|
                                    M.get_trait_method (|
                                      "core::alloc::Allocator",
                                      Ty.path "alloc::alloc::Global",
                                      [],
                                      "allocate",
                                      []
                                    |),
                                    [
                                      M.alloc (| Value.StructTuple "alloc::alloc::Global" [] |);
                                      M.read (| layout |)
                                    ]
                                  |)))
                            ]
                          |)
                        | _ => M.impossible (||)
                        end));
                  M.get_associated_function (|
                    Ty.apply (Ty.path "*mut") [ Ty.path "u8" ],
                    "cast",
                    [
                      Ty.apply
                        (Ty.path "alloc::rc::RcBox")
                        [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ T ] ]
                    ]
                  |)
                ]
              |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_new_uninit :
      forall (T : Ty.t),
      M.IsAssociatedFunction (Self T) "new_uninit" (new_uninit T).
    
    (*
        pub fn new_zeroed() -> Rc<mem::MaybeUninit<T>> {
            unsafe {
                Rc::from_ptr(Rc::allocate_for_layout(
                    Layout::new::<T>(),
                    |layout| Global.allocate_zeroed(layout),
                    <*mut u8>::cast,
                ))
            }
        }
    *)
    Definition new_zeroed (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match τ, α with
      | [], [] =>
        ltac:(M.monadic
          (M.call_closure (|
            M.get_associated_function (|
              Ty.apply
                (Ty.path "alloc::rc::Rc")
                [
                  Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ T ];
                  Ty.path "alloc::alloc::Global"
                ],
              "from_ptr",
              []
            |),
            [
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "alloc::rc::Rc")
                    [
                      Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ T ];
                      Ty.path "alloc::alloc::Global"
                    ],
                  "allocate_for_layout",
                  [
                    Ty.function
                      [ Ty.tuple [ Ty.path "core::alloc::layout::Layout" ] ]
                      (Ty.apply
                        (Ty.path "core::result::Result")
                        [
                          Ty.apply
                            (Ty.path "core::ptr::non_null::NonNull")
                            [ Ty.apply (Ty.path "slice") [ Ty.path "u8" ] ];
                          Ty.path "core::alloc::AllocError"
                        ]);
                    Ty.function
                      [ Ty.apply (Ty.path "*mut") [ Ty.path "u8" ] ]
                      (Ty.apply
                        (Ty.path "*mut")
                        [
                          Ty.apply
                            (Ty.path "alloc::rc::RcBox")
                            [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ T ] ]
                        ])
                  ]
                |),
                [
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.path "core::alloc::layout::Layout",
                      "new",
                      [ T ]
                    |),
                    []
                  |);
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0 ] =>
                          M.match_operator (|
                            M.alloc (| α0 |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let layout := M.copy (| γ |) in
                                  M.call_closure (|
                                    M.get_trait_method (|
                                      "core::alloc::Allocator",
                                      Ty.path "alloc::alloc::Global",
                                      [],
                                      "allocate_zeroed",
                                      []
                                    |),
                                    [
                                      M.alloc (| Value.StructTuple "alloc::alloc::Global" [] |);
                                      M.read (| layout |)
                                    ]
                                  |)))
                            ]
                          |)
                        | _ => M.impossible (||)
                        end));
                  M.get_associated_function (|
                    Ty.apply (Ty.path "*mut") [ Ty.path "u8" ],
                    "cast",
                    [
                      Ty.apply
                        (Ty.path "alloc::rc::RcBox")
                        [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ T ] ]
                    ]
                  |)
                ]
              |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_new_zeroed :
      forall (T : Ty.t),
      M.IsAssociatedFunction (Self T) "new_zeroed" (new_zeroed T).
    
    (*
        pub fn try_new(value: T) -> Result<Rc<T>, AllocError> {
            // There is an implicit weak pointer owned by all the strong
            // pointers, which ensures that the weak destructor never frees
            // the allocation while the strong destructor is running, even
            // if the weak pointer is stored inside the strong one.
            unsafe {
                Ok(Self::from_inner(
                    Box::leak(Box::try_new(RcBox { strong: Cell::new(1), weak: Cell::new(1), value })?)
                        .into(),
                ))
            }
        }
    *)
    Definition try_new (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match τ, α with
      | [], [ value ] =>
        ltac:(M.monadic
          (let value := M.alloc (| value |) in
          M.catch_return (|
            ltac:(M.monadic
              (Value.StructTuple
                "core::result::Result::Ok"
                [
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply (Ty.path "alloc::rc::Rc") [ T; Ty.path "alloc::alloc::Global" ],
                      "from_inner",
                      []
                    |),
                    [
                      M.call_closure (|
                        M.get_trait_method (|
                          "core::convert::Into",
                          Ty.apply (Ty.path "&mut") [ Ty.apply (Ty.path "alloc::rc::RcBox") [ T ] ],
                          [
                            Ty.apply
                              (Ty.path "core::ptr::non_null::NonNull")
                              [ Ty.apply (Ty.path "alloc::rc::RcBox") [ T ] ]
                          ],
                          "into",
                          []
                        |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply
                                (Ty.path "alloc::boxed::Box")
                                [
                                  Ty.apply (Ty.path "alloc::rc::RcBox") [ T ];
                                  Ty.path "alloc::alloc::Global"
                                ],
                              "leak",
                              []
                            |),
                            [
                              M.read (|
                                M.match_operator (|
                                  M.alloc (|
                                    M.call_closure (|
                                      M.get_trait_method (|
                                        "core::ops::try_trait::Try",
                                        Ty.apply
                                          (Ty.path "core::result::Result")
                                          [
                                            Ty.apply
                                              (Ty.path "alloc::boxed::Box")
                                              [
                                                Ty.apply (Ty.path "alloc::rc::RcBox") [ T ];
                                                Ty.path "alloc::alloc::Global"
                                              ];
                                            Ty.path "core::alloc::AllocError"
                                          ],
                                        [],
                                        "branch",
                                        []
                                      |),
                                      [
                                        M.call_closure (|
                                          M.get_associated_function (|
                                            Ty.apply
                                              (Ty.path "alloc::boxed::Box")
                                              [
                                                Ty.apply (Ty.path "alloc::rc::RcBox") [ T ];
                                                Ty.path "alloc::alloc::Global"
                                              ],
                                            "try_new",
                                            []
                                          |),
                                          [
                                            Value.StructRecord
                                              "alloc::rc::RcBox"
                                              [
                                                ("strong",
                                                  M.call_closure (|
                                                    M.get_associated_function (|
                                                      Ty.apply
                                                        (Ty.path "core::cell::Cell")
                                                        [ Ty.path "usize" ],
                                                      "new",
                                                      []
                                                    |),
                                                    [ Value.Integer 1 ]
                                                  |));
                                                ("weak",
                                                  M.call_closure (|
                                                    M.get_associated_function (|
                                                      Ty.apply
                                                        (Ty.path "core::cell::Cell")
                                                        [ Ty.path "usize" ],
                                                      "new",
                                                      []
                                                    |),
                                                    [ Value.Integer 1 ]
                                                  |));
                                                ("value", M.read (| value |))
                                              ]
                                          ]
                                        |)
                                      ]
                                    |)
                                  |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ0_0 :=
                                          M.SubPointer.get_struct_tuple_field (|
                                            γ,
                                            "core::ops::control_flow::ControlFlow::Break",
                                            0
                                          |) in
                                        let residual := M.copy (| γ0_0 |) in
                                        M.alloc (|
                                          M.never_to_any (|
                                            M.read (|
                                              M.return_ (|
                                                M.call_closure (|
                                                  M.get_trait_method (|
                                                    "core::ops::try_trait::FromResidual",
                                                    Ty.apply
                                                      (Ty.path "core::result::Result")
                                                      [
                                                        Ty.apply
                                                          (Ty.path "alloc::rc::Rc")
                                                          [ T; Ty.path "alloc::alloc::Global" ];
                                                        Ty.path "core::alloc::AllocError"
                                                      ],
                                                    [
                                                      Ty.apply
                                                        (Ty.path "core::result::Result")
                                                        [
                                                          Ty.path "core::convert::Infallible";
                                                          Ty.path "core::alloc::AllocError"
                                                        ]
                                                    ],
                                                    "from_residual",
                                                    []
                                                  |),
                                                  [ M.read (| residual |) ]
                                                |)
                                              |)
                                            |)
                                          |)
                                        |)));
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ0_0 :=
                                          M.SubPointer.get_struct_tuple_field (|
                                            γ,
                                            "core::ops::control_flow::ControlFlow::Continue",
                                            0
                                          |) in
                                        let val := M.copy (| γ0_0 |) in
                                        val))
                                  ]
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    ]
                  |)
                ]))
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_try_new :
      forall (T : Ty.t),
      M.IsAssociatedFunction (Self T) "try_new" (try_new T).
    
    (*
        pub fn try_new_uninit() -> Result<Rc<mem::MaybeUninit<T>>, AllocError> {
            unsafe {
                Ok(Rc::from_ptr(Rc::try_allocate_for_layout(
                    Layout::new::<T>(),
                    |layout| Global.allocate(layout),
                    <*mut u8>::cast,
                )?))
            }
        }
    *)
    Definition try_new_uninit (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match τ, α with
      | [], [] =>
        ltac:(M.monadic
          (M.catch_return (|
            ltac:(M.monadic
              (Value.StructTuple
                "core::result::Result::Ok"
                [
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "alloc::rc::Rc")
                        [
                          Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ T ];
                          Ty.path "alloc::alloc::Global"
                        ],
                      "from_ptr",
                      []
                    |),
                    [
                      M.read (|
                        M.match_operator (|
                          M.alloc (|
                            M.call_closure (|
                              M.get_trait_method (|
                                "core::ops::try_trait::Try",
                                Ty.apply
                                  (Ty.path "core::result::Result")
                                  [
                                    Ty.apply
                                      (Ty.path "*mut")
                                      [
                                        Ty.apply
                                          (Ty.path "alloc::rc::RcBox")
                                          [
                                            Ty.apply
                                              (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                              [ T ]
                                          ]
                                      ];
                                    Ty.path "core::alloc::AllocError"
                                  ],
                                [],
                                "branch",
                                []
                              |),
                              [
                                M.call_closure (|
                                  M.get_associated_function (|
                                    Ty.apply
                                      (Ty.path "alloc::rc::Rc")
                                      [
                                        Ty.apply
                                          (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                          [ T ];
                                        Ty.path "alloc::alloc::Global"
                                      ],
                                    "try_allocate_for_layout",
                                    [
                                      Ty.function
                                        [ Ty.tuple [ Ty.path "core::alloc::layout::Layout" ] ]
                                        (Ty.apply
                                          (Ty.path "core::result::Result")
                                          [
                                            Ty.apply
                                              (Ty.path "core::ptr::non_null::NonNull")
                                              [ Ty.apply (Ty.path "slice") [ Ty.path "u8" ] ];
                                            Ty.path "core::alloc::AllocError"
                                          ]);
                                      Ty.function
                                        [ Ty.apply (Ty.path "*mut") [ Ty.path "u8" ] ]
                                        (Ty.apply
                                          (Ty.path "*mut")
                                          [
                                            Ty.apply
                                              (Ty.path "alloc::rc::RcBox")
                                              [
                                                Ty.apply
                                                  (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                                  [ T ]
                                              ]
                                          ])
                                    ]
                                  |),
                                  [
                                    M.call_closure (|
                                      M.get_associated_function (|
                                        Ty.path "core::alloc::layout::Layout",
                                        "new",
                                        [ T ]
                                      |),
                                      []
                                    |);
                                    M.closure
                                      (fun γ =>
                                        ltac:(M.monadic
                                          match γ with
                                          | [ α0 ] =>
                                            M.match_operator (|
                                              M.alloc (| α0 |),
                                              [
                                                fun γ =>
                                                  ltac:(M.monadic
                                                    (let layout := M.copy (| γ |) in
                                                    M.call_closure (|
                                                      M.get_trait_method (|
                                                        "core::alloc::Allocator",
                                                        Ty.path "alloc::alloc::Global",
                                                        [],
                                                        "allocate",
                                                        []
                                                      |),
                                                      [
                                                        M.alloc (|
                                                          Value.StructTuple
                                                            "alloc::alloc::Global"
                                                            []
                                                        |);
                                                        M.read (| layout |)
                                                      ]
                                                    |)))
                                              ]
                                            |)
                                          | _ => M.impossible (||)
                                          end));
                                    M.get_associated_function (|
                                      Ty.apply (Ty.path "*mut") [ Ty.path "u8" ],
                                      "cast",
                                      [
                                        Ty.apply
                                          (Ty.path "alloc::rc::RcBox")
                                          [
                                            Ty.apply
                                              (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                              [ T ]
                                          ]
                                      ]
                                    |)
                                  ]
                                |)
                              ]
                            |)
                          |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ0_0 :=
                                  M.SubPointer.get_struct_tuple_field (|
                                    γ,
                                    "core::ops::control_flow::ControlFlow::Break",
                                    0
                                  |) in
                                let residual := M.copy (| γ0_0 |) in
                                M.alloc (|
                                  M.never_to_any (|
                                    M.read (|
                                      M.return_ (|
                                        M.call_closure (|
                                          M.get_trait_method (|
                                            "core::ops::try_trait::FromResidual",
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              [
                                                Ty.apply
                                                  (Ty.path "alloc::rc::Rc")
                                                  [
                                                    Ty.apply
                                                      (Ty.path
                                                        "core::mem::maybe_uninit::MaybeUninit")
                                                      [ T ];
                                                    Ty.path "alloc::alloc::Global"
                                                  ];
                                                Ty.path "core::alloc::AllocError"
                                              ],
                                            [
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                [
                                                  Ty.path "core::convert::Infallible";
                                                  Ty.path "core::alloc::AllocError"
                                                ]
                                            ],
                                            "from_residual",
                                            []
                                          |),
                                          [ M.read (| residual |) ]
                                        |)
                                      |)
                                    |)
                                  |)
                                |)));
                            fun γ =>
                              ltac:(M.monadic
                                (let γ0_0 :=
                                  M.SubPointer.get_struct_tuple_field (|
                                    γ,
                                    "core::ops::control_flow::ControlFlow::Continue",
                                    0
                                  |) in
                                let val := M.copy (| γ0_0 |) in
                                val))
                          ]
                        |)
                      |)
                    ]
                  |)
                ]))
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_try_new_uninit :
      forall (T : Ty.t),
      M.IsAssociatedFunction (Self T) "try_new_uninit" (try_new_uninit T).
    
    (*
        pub fn try_new_zeroed() -> Result<Rc<mem::MaybeUninit<T>>, AllocError> {
            unsafe {
                Ok(Rc::from_ptr(Rc::try_allocate_for_layout(
                    Layout::new::<T>(),
                    |layout| Global.allocate_zeroed(layout),
                    <*mut u8>::cast,
                )?))
            }
        }
    *)
    Definition try_new_zeroed (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match τ, α with
      | [], [] =>
        ltac:(M.monadic
          (M.catch_return (|
            ltac:(M.monadic
              (Value.StructTuple
                "core::result::Result::Ok"
                [
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "alloc::rc::Rc")
                        [
                          Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ T ];
                          Ty.path "alloc::alloc::Global"
                        ],
                      "from_ptr",
                      []
                    |),
                    [
                      M.read (|
                        M.match_operator (|
                          M.alloc (|
                            M.call_closure (|
                              M.get_trait_method (|
                                "core::ops::try_trait::Try",
                                Ty.apply
                                  (Ty.path "core::result::Result")
                                  [
                                    Ty.apply
                                      (Ty.path "*mut")
                                      [
                                        Ty.apply
                                          (Ty.path "alloc::rc::RcBox")
                                          [
                                            Ty.apply
                                              (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                              [ T ]
                                          ]
                                      ];
                                    Ty.path "core::alloc::AllocError"
                                  ],
                                [],
                                "branch",
                                []
                              |),
                              [
                                M.call_closure (|
                                  M.get_associated_function (|
                                    Ty.apply
                                      (Ty.path "alloc::rc::Rc")
                                      [
                                        Ty.apply
                                          (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                          [ T ];
                                        Ty.path "alloc::alloc::Global"
                                      ],
                                    "try_allocate_for_layout",
                                    [
                                      Ty.function
                                        [ Ty.tuple [ Ty.path "core::alloc::layout::Layout" ] ]
                                        (Ty.apply
                                          (Ty.path "core::result::Result")
                                          [
                                            Ty.apply
                                              (Ty.path "core::ptr::non_null::NonNull")
                                              [ Ty.apply (Ty.path "slice") [ Ty.path "u8" ] ];
                                            Ty.path "core::alloc::AllocError"
                                          ]);
                                      Ty.function
                                        [ Ty.apply (Ty.path "*mut") [ Ty.path "u8" ] ]
                                        (Ty.apply
                                          (Ty.path "*mut")
                                          [
                                            Ty.apply
                                              (Ty.path "alloc::rc::RcBox")
                                              [
                                                Ty.apply
                                                  (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                                  [ T ]
                                              ]
                                          ])
                                    ]
                                  |),
                                  [
                                    M.call_closure (|
                                      M.get_associated_function (|
                                        Ty.path "core::alloc::layout::Layout",
                                        "new",
                                        [ T ]
                                      |),
                                      []
                                    |);
                                    M.closure
                                      (fun γ =>
                                        ltac:(M.monadic
                                          match γ with
                                          | [ α0 ] =>
                                            M.match_operator (|
                                              M.alloc (| α0 |),
                                              [
                                                fun γ =>
                                                  ltac:(M.monadic
                                                    (let layout := M.copy (| γ |) in
                                                    M.call_closure (|
                                                      M.get_trait_method (|
                                                        "core::alloc::Allocator",
                                                        Ty.path "alloc::alloc::Global",
                                                        [],
                                                        "allocate_zeroed",
                                                        []
                                                      |),
                                                      [
                                                        M.alloc (|
                                                          Value.StructTuple
                                                            "alloc::alloc::Global"
                                                            []
                                                        |);
                                                        M.read (| layout |)
                                                      ]
                                                    |)))
                                              ]
                                            |)
                                          | _ => M.impossible (||)
                                          end));
                                    M.get_associated_function (|
                                      Ty.apply (Ty.path "*mut") [ Ty.path "u8" ],
                                      "cast",
                                      [
                                        Ty.apply
                                          (Ty.path "alloc::rc::RcBox")
                                          [
                                            Ty.apply
                                              (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                              [ T ]
                                          ]
                                      ]
                                    |)
                                  ]
                                |)
                              ]
                            |)
                          |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ0_0 :=
                                  M.SubPointer.get_struct_tuple_field (|
                                    γ,
                                    "core::ops::control_flow::ControlFlow::Break",
                                    0
                                  |) in
                                let residual := M.copy (| γ0_0 |) in
                                M.alloc (|
                                  M.never_to_any (|
                                    M.read (|
                                      M.return_ (|
                                        M.call_closure (|
                                          M.get_trait_method (|
                                            "core::ops::try_trait::FromResidual",
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              [
                                                Ty.apply
                                                  (Ty.path "alloc::rc::Rc")
                                                  [
                                                    Ty.apply
                                                      (Ty.path
                                                        "core::mem::maybe_uninit::MaybeUninit")
                                                      [ T ];
                                                    Ty.path "alloc::alloc::Global"
                                                  ];
                                                Ty.path "core::alloc::AllocError"
                                              ],
                                            [
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                [
                                                  Ty.path "core::convert::Infallible";
                                                  Ty.path "core::alloc::AllocError"
                                                ]
                                            ],
                                            "from_residual",
                                            []
                                          |),
                                          [ M.read (| residual |) ]
                                        |)
                                      |)
                                    |)
                                  |)
                                |)));
                            fun γ =>
                              ltac:(M.monadic
                                (let γ0_0 :=
                                  M.SubPointer.get_struct_tuple_field (|
                                    γ,
                                    "core::ops::control_flow::ControlFlow::Continue",
                                    0
                                  |) in
                                let val := M.copy (| γ0_0 |) in
                                val))
                          ]
                        |)
                      |)
                    ]
                  |)
                ]))
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_try_new_zeroed :
      forall (T : Ty.t),
      M.IsAssociatedFunction (Self T) "try_new_zeroed" (try_new_zeroed T).
    
    (*
        pub fn pin(value: T) -> Pin<Rc<T>> {
            unsafe { Pin::new_unchecked(Rc::new(value)) }
        }
    *)
    Definition pin (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match τ, α with
      | [], [ value ] =>
        ltac:(M.monadic
          (let value := M.alloc (| value |) in
          M.call_closure (|
            M.get_associated_function (|
              Ty.apply
                (Ty.path "core::pin::Pin")
                [ Ty.apply (Ty.path "alloc::rc::Rc") [ T; Ty.path "alloc::alloc::Global" ] ],
              "new_unchecked",
              []
            |),
            [
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply (Ty.path "alloc::rc::Rc") [ T; Ty.path "alloc::alloc::Global" ],
                  "new",
                  []
                |),
                [ M.read (| value |) ]
              |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_pin : forall (T : Ty.t), M.IsAssociatedFunction (Self T) "pin" (pin T).
    (*
        pub unsafe fn from_raw(ptr: *const T) -> Self {
            unsafe { Self::from_raw_in(ptr, Global) }
        }
    *)
    Definition from_raw (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match τ, α with
      | [], [ ptr ] =>
        ltac:(M.monadic
          (let ptr := M.alloc (| ptr |) in
          M.call_closure (|
            M.get_associated_function (|
              Ty.apply (Ty.path "alloc::rc::Rc") [ T; Ty.path "alloc::alloc::Global" ],
              "from_raw_in",
              []
            |),
            [ M.read (| ptr |); Value.StructTuple "alloc::alloc::Global" [] ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_from_raw :
      forall (T : Ty.t),
      M.IsAssociatedFunction (Self T) "from_raw" (from_raw T).
    
    (*
        pub unsafe fn increment_strong_count(ptr: *const T) {
            unsafe { Self::increment_strong_count_in(ptr, Global) }
        }
    *)
    Definition increment_strong_count (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match τ, α with
      | [], [ ptr ] =>
        ltac:(M.monadic
          (let ptr := M.alloc (| ptr |) in
          M.call_closure (|
            M.get_associated_function (|
              Ty.apply (Ty.path "alloc::rc::Rc") [ T; Ty.path "alloc::alloc::Global" ],
              "increment_strong_count_in",
              []
            |),
            [ M.read (| ptr |); Value.StructTuple "alloc::alloc::Global" [] ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_increment_strong_count :
      forall (T : Ty.t),
      M.IsAssociatedFunction (Self T) "increment_strong_count" (increment_strong_count T).
    
    (*
        pub unsafe fn decrement_strong_count(ptr: *const T) {
            unsafe { Self::decrement_strong_count_in(ptr, Global) }
        }
    *)
    Definition decrement_strong_count (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match τ, α with
      | [], [ ptr ] =>
        ltac:(M.monadic
          (let ptr := M.alloc (| ptr |) in
          M.call_closure (|
            M.get_associated_function (|
              Ty.apply (Ty.path "alloc::rc::Rc") [ T; Ty.path "alloc::alloc::Global" ],
              "decrement_strong_count_in",
              []
            |),
            [ M.read (| ptr |); Value.StructTuple "alloc::alloc::Global" [] ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_decrement_strong_count :
      forall (T : Ty.t),
      M.IsAssociatedFunction (Self T) "decrement_strong_count" (decrement_strong_count T).
    (*
        unsafe fn allocate_for_layout(
            value_layout: Layout,
            allocate: impl FnOnce(Layout) -> Result<NonNull<[u8]>, AllocError>,
            mem_to_rcbox: impl FnOnce( *mut u8) -> *mut RcBox<T>,
        ) -> *mut RcBox<T> {
            let layout = rcbox_layout_for_value_layout(value_layout);
            unsafe {
                Rc::try_allocate_for_layout(value_layout, allocate, mem_to_rcbox)
                    .unwrap_or_else(|_| handle_alloc_error(layout))
            }
        }
    *)
    Definition allocate_for_layout (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match τ, α with
      | [
            impl_FnOnce_Layout__arrow_Result_NonNull__u8____AllocError_;
            impl_FnOnce__mut_u8__arrow__mut_RcBox_T_
          ],
          [ value_layout; allocate; mem_to_rcbox ] =>
        ltac:(M.monadic
          (let value_layout := M.alloc (| value_layout |) in
          let allocate := M.alloc (| allocate |) in
          let mem_to_rcbox := M.alloc (| mem_to_rcbox |) in
          M.read (|
            let layout :=
              M.alloc (|
                M.call_closure (|
                  M.get_function (| "alloc::rc::rcbox_layout_for_value_layout", [] |),
                  [ M.read (| value_layout |) ]
                |)
              |) in
            M.alloc (|
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "core::result::Result")
                    [
                      Ty.apply (Ty.path "*mut") [ Ty.apply (Ty.path "alloc::rc::RcBox") [ T ] ];
                      Ty.path "core::alloc::AllocError"
                    ],
                  "unwrap_or_else",
                  [
                    Ty.function
                      [ Ty.tuple [ Ty.path "core::alloc::AllocError" ] ]
                      (Ty.apply (Ty.path "*mut") [ Ty.apply (Ty.path "alloc::rc::RcBox") [ T ] ])
                  ]
                |),
                [
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply (Ty.path "alloc::rc::Rc") [ T; Ty.path "alloc::alloc::Global" ],
                      "try_allocate_for_layout",
                      [
                        impl_FnOnce_Layout__arrow_Result_NonNull__u8____AllocError_;
                        impl_FnOnce__mut_u8__arrow__mut_RcBox_T_
                      ]
                    |),
                    [ M.read (| value_layout |); M.read (| allocate |); M.read (| mem_to_rcbox |) ]
                  |);
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0 ] =>
                          M.match_operator (|
                            M.alloc (| α0 |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (M.never_to_any (|
                                    M.call_closure (|
                                      M.get_function (| "alloc::alloc::handle_alloc_error", [] |),
                                      [ M.read (| layout |) ]
                                    |)
                                  |)))
                            ]
                          |)
                        | _ => M.impossible (||)
                        end))
                ]
              |)
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_allocate_for_layout :
      forall (T : Ty.t),
      M.IsAssociatedFunction (Self T) "allocate_for_layout" (allocate_for_layout T).
    
    (*
        unsafe fn try_allocate_for_layout(
            value_layout: Layout,
            allocate: impl FnOnce(Layout) -> Result<NonNull<[u8]>, AllocError>,
            mem_to_rcbox: impl FnOnce( *mut u8) -> *mut RcBox<T>,
        ) -> Result<*mut RcBox<T>, AllocError> {
            let layout = rcbox_layout_for_value_layout(value_layout);
    
            // Allocate for the layout.
            let ptr = allocate(layout)?;
    
            // Initialize the RcBox
            let inner = mem_to_rcbox(ptr.as_non_null_ptr().as_ptr());
            unsafe {
                debug_assert_eq!(Layout::for_value(&*inner), layout);
    
                ptr::write(&mut ( *inner).strong, Cell::new(1));
                ptr::write(&mut ( *inner).weak, Cell::new(1));
            }
    
            Ok(inner)
        }
    *)
    Definition try_allocate_for_layout (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match τ, α with
      | [
            impl_FnOnce_Layout__arrow_Result_NonNull__u8____AllocError_;
            impl_FnOnce__mut_u8__arrow__mut_RcBox_T_
          ],
          [ value_layout; allocate; mem_to_rcbox ] =>
        ltac:(M.monadic
          (let value_layout := M.alloc (| value_layout |) in
          let allocate := M.alloc (| allocate |) in
          let mem_to_rcbox := M.alloc (| mem_to_rcbox |) in
          M.catch_return (|
            ltac:(M.monadic
              (M.read (|
                let layout :=
                  M.alloc (|
                    M.call_closure (|
                      M.get_function (| "alloc::rc::rcbox_layout_for_value_layout", [] |),
                      [ M.read (| value_layout |) ]
                    |)
                  |) in
                let ptr :=
                  M.copy (|
                    M.match_operator (|
                      M.alloc (|
                        M.call_closure (|
                          M.get_trait_method (|
                            "core::ops::try_trait::Try",
                            Ty.apply
                              (Ty.path "core::result::Result")
                              [
                                Ty.apply
                                  (Ty.path "core::ptr::non_null::NonNull")
                                  [ Ty.apply (Ty.path "slice") [ Ty.path "u8" ] ];
                                Ty.path "core::alloc::AllocError"
                              ],
                            [],
                            "branch",
                            []
                          |),
                          [
                            M.call_closure (|
                              M.get_trait_method (|
                                "core::ops::function::FnOnce",
                                impl_FnOnce_Layout__arrow_Result_NonNull__u8____AllocError_,
                                [ Ty.tuple [ Ty.path "core::alloc::layout::Layout" ] ],
                                "call_once",
                                []
                              |),
                              [ M.read (| allocate |); Value.Tuple [ M.read (| layout |) ] ]
                            |)
                          ]
                        |)
                      |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "core::ops::control_flow::ControlFlow::Break",
                                0
                              |) in
                            let residual := M.copy (| γ0_0 |) in
                            M.alloc (|
                              M.never_to_any (|
                                M.read (|
                                  M.return_ (|
                                    M.call_closure (|
                                      M.get_trait_method (|
                                        "core::ops::try_trait::FromResidual",
                                        Ty.apply
                                          (Ty.path "core::result::Result")
                                          [
                                            Ty.apply
                                              (Ty.path "*mut")
                                              [ Ty.apply (Ty.path "alloc::rc::RcBox") [ T ] ];
                                            Ty.path "core::alloc::AllocError"
                                          ],
                                        [
                                          Ty.apply
                                            (Ty.path "core::result::Result")
                                            [
                                              Ty.path "core::convert::Infallible";
                                              Ty.path "core::alloc::AllocError"
                                            ]
                                        ],
                                        "from_residual",
                                        []
                                      |),
                                      [ M.read (| residual |) ]
                                    |)
                                  |)
                                |)
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "core::ops::control_flow::ControlFlow::Continue",
                                0
                              |) in
                            let val := M.copy (| γ0_0 |) in
                            val))
                      ]
                    |)
                  |) in
                let inner :=
                  M.alloc (|
                    M.call_closure (|
                      M.get_trait_method (|
                        "core::ops::function::FnOnce",
                        impl_FnOnce__mut_u8__arrow__mut_RcBox_T_,
                        [ Ty.tuple [ Ty.apply (Ty.path "*mut") [ Ty.path "u8" ] ] ],
                        "call_once",
                        []
                      |),
                      [
                        M.read (| mem_to_rcbox |);
                        Value.Tuple
                          [
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply (Ty.path "core::ptr::non_null::NonNull") [ Ty.path "u8" ],
                                "as_ptr",
                                []
                              |),
                              [
                                M.call_closure (|
                                  M.get_associated_function (|
                                    Ty.apply
                                      (Ty.path "core::ptr::non_null::NonNull")
                                      [ Ty.apply (Ty.path "slice") [ Ty.path "u8" ] ],
                                    "as_non_null_ptr",
                                    []
                                  |),
                                  [ M.read (| ptr |) ]
                                |)
                              ]
                            |)
                          ]
                      ]
                    |)
                  |) in
                let _ :=
                  let _ :=
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ := M.use (M.alloc (| Value.Bool true |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            let _ :=
                              M.match_operator (|
                                M.alloc (|
                                  Value.Tuple
                                    [
                                      M.alloc (|
                                        M.call_closure (|
                                          M.get_associated_function (|
                                            Ty.path "core::alloc::layout::Layout",
                                            "for_value",
                                            [ Ty.apply (Ty.path "alloc::rc::RcBox") [ T ] ]
                                          |),
                                          [ M.read (| inner |) ]
                                        |)
                                      |);
                                      layout
                                    ]
                                |),
                                [
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                      let left_val := M.copy (| γ0_0 |) in
                                      let right_val := M.copy (| γ0_1 |) in
                                      M.match_operator (|
                                        M.alloc (| Value.Tuple [] |),
                                        [
                                          fun γ =>
                                            ltac:(M.monadic
                                              (let γ :=
                                                M.use
                                                  (M.alloc (|
                                                    UnOp.Pure.not
                                                      (M.call_closure (|
                                                        M.get_trait_method (|
                                                          "core::cmp::PartialEq",
                                                          Ty.path "core::alloc::layout::Layout",
                                                          [ Ty.path "core::alloc::layout::Layout" ],
                                                          "eq",
                                                          []
                                                        |),
                                                        [
                                                          M.read (| left_val |);
                                                          M.read (| right_val |)
                                                        ]
                                                      |))
                                                  |)) in
                                              let _ :=
                                                M.is_constant_or_break_match (|
                                                  M.read (| γ |),
                                                  Value.Bool true
                                                |) in
                                              M.alloc (|
                                                M.never_to_any (|
                                                  M.read (|
                                                    let kind :=
                                                      M.alloc (|
                                                        Value.StructTuple
                                                          "core::panicking::AssertKind::Eq"
                                                          []
                                                      |) in
                                                    M.alloc (|
                                                      M.call_closure (|
                                                        M.get_function (|
                                                          "core::panicking::assert_failed",
                                                          [
                                                            Ty.path "core::alloc::layout::Layout";
                                                            Ty.path "core::alloc::layout::Layout"
                                                          ]
                                                        |),
                                                        [
                                                          M.read (| kind |);
                                                          M.read (| left_val |);
                                                          M.read (| right_val |);
                                                          Value.StructTuple
                                                            "core::option::Option::None"
                                                            []
                                                        ]
                                                      |)
                                                    |)
                                                  |)
                                                |)
                                              |)));
                                          fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                                        ]
                                      |)))
                                ]
                              |) in
                            M.alloc (| Value.Tuple [] |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                      ]
                    |) in
                  let _ :=
                    M.alloc (|
                      M.call_closure (|
                        M.get_function (|
                          "core::ptr::write",
                          [ Ty.apply (Ty.path "core::cell::Cell") [ Ty.path "usize" ] ]
                        |),
                        [
                          M.SubPointer.get_struct_record_field (|
                            M.read (| inner |),
                            "alloc::rc::RcBox",
                            "strong"
                          |);
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply (Ty.path "core::cell::Cell") [ Ty.path "usize" ],
                              "new",
                              []
                            |),
                            [ Value.Integer 1 ]
                          |)
                        ]
                      |)
                    |) in
                  let _ :=
                    M.alloc (|
                      M.call_closure (|
                        M.get_function (|
                          "core::ptr::write",
                          [ Ty.apply (Ty.path "core::cell::Cell") [ Ty.path "usize" ] ]
                        |),
                        [
                          M.SubPointer.get_struct_record_field (|
                            M.read (| inner |),
                            "alloc::rc::RcBox",
                            "weak"
                          |);
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply (Ty.path "core::cell::Cell") [ Ty.path "usize" ],
                              "new",
                              []
                            |),
                            [ Value.Integer 1 ]
                          |)
                        ]
                      |)
                    |) in
                  M.alloc (| Value.Tuple [] |) in
                M.alloc (| Value.StructTuple "core::result::Result::Ok" [ M.read (| inner |) ] |)
              |)))
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_try_allocate_for_layout :
      forall (T : Ty.t),
      M.IsAssociatedFunction (Self T) "try_allocate_for_layout" (try_allocate_for_layout T).
  End Impl_alloc_rc_Rc_T_alloc_alloc_Global.
  
  Module Impl_alloc_rc_Rc_T_A.
    Definition Self (T A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::rc::Rc") [ T; A ].
    
    (*
        fn inner(&self) -> &RcBox<T> {
            // This unsafety is ok because while this Rc is alive we're guaranteed
            // that the inner pointer is valid.
            unsafe { self.ptr.as_ref() }
        }
    *)
    Definition inner (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_associated_function (|
              Ty.apply
                (Ty.path "core::ptr::non_null::NonNull")
                [ Ty.apply (Ty.path "alloc::rc::RcBox") [ T ] ],
              "as_ref",
              []
            |),
            [ M.SubPointer.get_struct_record_field (| M.read (| self |), "alloc::rc::Rc", "ptr" |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_inner :
      forall (T A : Ty.t),
      M.IsAssociatedFunction (Self T A) "inner" (inner T A).
    
    (*
        unsafe fn from_inner_in(ptr: NonNull<RcBox<T>>, alloc: A) -> Self {
            Self { ptr, phantom: PhantomData, alloc }
        }
    *)
    Definition from_inner_in (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match τ, α with
      | [], [ ptr; alloc ] =>
        ltac:(M.monadic
          (let ptr := M.alloc (| ptr |) in
          let alloc := M.alloc (| alloc |) in
          Value.StructRecord
            "alloc::rc::Rc"
            [
              ("ptr", M.read (| ptr |));
              ("phantom", Value.StructTuple "core::marker::PhantomData" []);
              ("alloc", M.read (| alloc |))
            ]))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_from_inner_in :
      forall (T A : Ty.t),
      M.IsAssociatedFunction (Self T A) "from_inner_in" (from_inner_in T A).
    
    (*
        unsafe fn from_ptr_in(ptr: *mut RcBox<T>, alloc: A) -> Self {
            unsafe { Self::from_inner_in(NonNull::new_unchecked(ptr), alloc) }
        }
    *)
    Definition from_ptr_in (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match τ, α with
      | [], [ ptr; alloc ] =>
        ltac:(M.monadic
          (let ptr := M.alloc (| ptr |) in
          let alloc := M.alloc (| alloc |) in
          M.call_closure (|
            M.get_associated_function (|
              Ty.apply (Ty.path "alloc::rc::Rc") [ T; A ],
              "from_inner_in",
              []
            |),
            [
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "core::ptr::non_null::NonNull")
                    [ Ty.apply (Ty.path "alloc::rc::RcBox") [ T ] ],
                  "new_unchecked",
                  []
                |),
                [ M.read (| ptr |) ]
              |);
              M.read (| alloc |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_from_ptr_in :
      forall (T A : Ty.t),
      M.IsAssociatedFunction (Self T A) "from_ptr_in" (from_ptr_in T A).
    (*
        pub fn allocator(this: &Self) -> &A {
            &this.alloc
        }
    *)
    Definition allocator (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match τ, α with
      | [], [ this ] =>
        ltac:(M.monadic
          (let this := M.alloc (| this |) in
          M.SubPointer.get_struct_record_field (| M.read (| this |), "alloc::rc::Rc", "alloc" |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_allocator :
      forall (T A : Ty.t),
      M.IsAssociatedFunction (Self T A) "allocator" (allocator T A).
    
    (*
        pub fn new_in(value: T, alloc: A) -> Rc<T, A> {
            // NOTE: Prefer match over unwrap_or_else since closure sometimes not inlineable.
            // That would make code size bigger.
            match Self::try_new_in(value, alloc) {
                Ok(m) => m,
                Err(_) => handle_alloc_error(Layout::new::<RcBox<T>>()),
            }
        }
    *)
    Definition new_in (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match τ, α with
      | [], [ value; alloc ] =>
        ltac:(M.monadic
          (let value := M.alloc (| value |) in
          let alloc := M.alloc (| alloc |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "alloc::rc::Rc") [ T; A ],
                    "try_new_in",
                    []
                  |),
                  [ M.read (| value |); M.read (| alloc |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 :=
                      M.SubPointer.get_struct_tuple_field (| γ, "core::result::Result::Ok", 0 |) in
                    let m := M.copy (| γ0_0 |) in
                    m));
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 :=
                      M.SubPointer.get_struct_tuple_field (| γ, "core::result::Result::Err", 0 |) in
                    M.alloc (|
                      M.never_to_any (|
                        M.call_closure (|
                          M.get_function (| "alloc::alloc::handle_alloc_error", [] |),
                          [
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.path "core::alloc::layout::Layout",
                                "new",
                                [ Ty.apply (Ty.path "alloc::rc::RcBox") [ T ] ]
                              |),
                              []
                            |)
                          ]
                        |)
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_new_in :
      forall (T A : Ty.t),
      M.IsAssociatedFunction (Self T A) "new_in" (new_in T A).
    
    (*
        pub fn new_uninit_in(alloc: A) -> Rc<mem::MaybeUninit<T>, A> {
            unsafe {
                Rc::from_ptr_in(
                    Rc::allocate_for_layout(
                        Layout::new::<T>(),
                        |layout| alloc.allocate(layout),
                        <*mut u8>::cast,
                    ),
                    alloc,
                )
            }
        }
    *)
    Definition new_uninit_in (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match τ, α with
      | [], [ alloc ] =>
        ltac:(M.monadic
          (let alloc := M.alloc (| alloc |) in
          M.call_closure (|
            M.get_associated_function (|
              Ty.apply
                (Ty.path "alloc::rc::Rc")
                [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ T ]; A ],
              "from_ptr_in",
              []
            |),
            [
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "alloc::rc::Rc")
                    [
                      Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ T ];
                      Ty.path "alloc::alloc::Global"
                    ],
                  "allocate_for_layout",
                  [
                    Ty.function
                      [ Ty.tuple [ Ty.path "core::alloc::layout::Layout" ] ]
                      (Ty.apply
                        (Ty.path "core::result::Result")
                        [
                          Ty.apply
                            (Ty.path "core::ptr::non_null::NonNull")
                            [ Ty.apply (Ty.path "slice") [ Ty.path "u8" ] ];
                          Ty.path "core::alloc::AllocError"
                        ]);
                    Ty.function
                      [ Ty.apply (Ty.path "*mut") [ Ty.path "u8" ] ]
                      (Ty.apply
                        (Ty.path "*mut")
                        [
                          Ty.apply
                            (Ty.path "alloc::rc::RcBox")
                            [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ T ] ]
                        ])
                  ]
                |),
                [
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.path "core::alloc::layout::Layout",
                      "new",
                      [ T ]
                    |),
                    []
                  |);
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0 ] =>
                          M.match_operator (|
                            M.alloc (| α0 |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let layout := M.copy (| γ |) in
                                  M.call_closure (|
                                    M.get_trait_method (|
                                      "core::alloc::Allocator",
                                      A,
                                      [],
                                      "allocate",
                                      []
                                    |),
                                    [ alloc; M.read (| layout |) ]
                                  |)))
                            ]
                          |)
                        | _ => M.impossible (||)
                        end));
                  M.get_associated_function (|
                    Ty.apply (Ty.path "*mut") [ Ty.path "u8" ],
                    "cast",
                    [
                      Ty.apply
                        (Ty.path "alloc::rc::RcBox")
                        [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ T ] ]
                    ]
                  |)
                ]
              |);
              M.read (| alloc |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_new_uninit_in :
      forall (T A : Ty.t),
      M.IsAssociatedFunction (Self T A) "new_uninit_in" (new_uninit_in T A).
    
    (*
        pub fn new_zeroed_in(alloc: A) -> Rc<mem::MaybeUninit<T>, A> {
            unsafe {
                Rc::from_ptr_in(
                    Rc::allocate_for_layout(
                        Layout::new::<T>(),
                        |layout| alloc.allocate_zeroed(layout),
                        <*mut u8>::cast,
                    ),
                    alloc,
                )
            }
        }
    *)
    Definition new_zeroed_in (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match τ, α with
      | [], [ alloc ] =>
        ltac:(M.monadic
          (let alloc := M.alloc (| alloc |) in
          M.call_closure (|
            M.get_associated_function (|
              Ty.apply
                (Ty.path "alloc::rc::Rc")
                [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ T ]; A ],
              "from_ptr_in",
              []
            |),
            [
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "alloc::rc::Rc")
                    [
                      Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ T ];
                      Ty.path "alloc::alloc::Global"
                    ],
                  "allocate_for_layout",
                  [
                    Ty.function
                      [ Ty.tuple [ Ty.path "core::alloc::layout::Layout" ] ]
                      (Ty.apply
                        (Ty.path "core::result::Result")
                        [
                          Ty.apply
                            (Ty.path "core::ptr::non_null::NonNull")
                            [ Ty.apply (Ty.path "slice") [ Ty.path "u8" ] ];
                          Ty.path "core::alloc::AllocError"
                        ]);
                    Ty.function
                      [ Ty.apply (Ty.path "*mut") [ Ty.path "u8" ] ]
                      (Ty.apply
                        (Ty.path "*mut")
                        [
                          Ty.apply
                            (Ty.path "alloc::rc::RcBox")
                            [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ T ] ]
                        ])
                  ]
                |),
                [
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.path "core::alloc::layout::Layout",
                      "new",
                      [ T ]
                    |),
                    []
                  |);
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0 ] =>
                          M.match_operator (|
                            M.alloc (| α0 |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let layout := M.copy (| γ |) in
                                  M.call_closure (|
                                    M.get_trait_method (|
                                      "core::alloc::Allocator",
                                      A,
                                      [],
                                      "allocate_zeroed",
                                      []
                                    |),
                                    [ alloc; M.read (| layout |) ]
                                  |)))
                            ]
                          |)
                        | _ => M.impossible (||)
                        end));
                  M.get_associated_function (|
                    Ty.apply (Ty.path "*mut") [ Ty.path "u8" ],
                    "cast",
                    [
                      Ty.apply
                        (Ty.path "alloc::rc::RcBox")
                        [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ T ] ]
                    ]
                  |)
                ]
              |);
              M.read (| alloc |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_new_zeroed_in :
      forall (T A : Ty.t),
      M.IsAssociatedFunction (Self T A) "new_zeroed_in" (new_zeroed_in T A).
    
    (*
        pub fn try_new_in(value: T, alloc: A) -> Result<Self, AllocError> {
            // There is an implicit weak pointer owned by all the strong
            // pointers, which ensures that the weak destructor never frees
            // the allocation while the strong destructor is running, even
            // if the weak pointer is stored inside the strong one.
            let (ptr, alloc) = Box::into_unique(Box::try_new_in(
                RcBox { strong: Cell::new(1), weak: Cell::new(1), value },
                alloc,
            )?);
            Ok(unsafe { Self::from_inner_in(ptr.into(), alloc) })
        }
    *)
    Definition try_new_in (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match τ, α with
      | [], [ value; alloc ] =>
        ltac:(M.monadic
          (let value := M.alloc (| value |) in
          let alloc := M.alloc (| alloc |) in
          M.catch_return (|
            ltac:(M.monadic
              (M.read (|
                M.match_operator (|
                  M.alloc (|
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "alloc::boxed::Box")
                          [ Ty.apply (Ty.path "alloc::rc::RcBox") [ T ]; A ],
                        "into_unique",
                        []
                      |),
                      [
                        M.read (|
                          M.match_operator (|
                            M.alloc (|
                              M.call_closure (|
                                M.get_trait_method (|
                                  "core::ops::try_trait::Try",
                                  Ty.apply
                                    (Ty.path "core::result::Result")
                                    [
                                      Ty.apply
                                        (Ty.path "alloc::boxed::Box")
                                        [ Ty.apply (Ty.path "alloc::rc::RcBox") [ T ]; A ];
                                      Ty.path "core::alloc::AllocError"
                                    ],
                                  [],
                                  "branch",
                                  []
                                |),
                                [
                                  M.call_closure (|
                                    M.get_associated_function (|
                                      Ty.apply
                                        (Ty.path "alloc::boxed::Box")
                                        [ Ty.apply (Ty.path "alloc::rc::RcBox") [ T ]; A ],
                                      "try_new_in",
                                      []
                                    |),
                                    [
                                      Value.StructRecord
                                        "alloc::rc::RcBox"
                                        [
                                          ("strong",
                                            M.call_closure (|
                                              M.get_associated_function (|
                                                Ty.apply
                                                  (Ty.path "core::cell::Cell")
                                                  [ Ty.path "usize" ],
                                                "new",
                                                []
                                              |),
                                              [ Value.Integer 1 ]
                                            |));
                                          ("weak",
                                            M.call_closure (|
                                              M.get_associated_function (|
                                                Ty.apply
                                                  (Ty.path "core::cell::Cell")
                                                  [ Ty.path "usize" ],
                                                "new",
                                                []
                                              |),
                                              [ Value.Integer 1 ]
                                            |));
                                          ("value", M.read (| value |))
                                        ];
                                      M.read (| alloc |)
                                    ]
                                  |)
                                ]
                              |)
                            |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Break",
                                      0
                                    |) in
                                  let residual := M.copy (| γ0_0 |) in
                                  M.alloc (|
                                    M.never_to_any (|
                                      M.read (|
                                        M.return_ (|
                                          M.call_closure (|
                                            M.get_trait_method (|
                                              "core::ops::try_trait::FromResidual",
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                [
                                                  Ty.apply (Ty.path "alloc::rc::Rc") [ T; A ];
                                                  Ty.path "core::alloc::AllocError"
                                                ],
                                              [
                                                Ty.apply
                                                  (Ty.path "core::result::Result")
                                                  [
                                                    Ty.path "core::convert::Infallible";
                                                    Ty.path "core::alloc::AllocError"
                                                  ]
                                              ],
                                              "from_residual",
                                              []
                                            |),
                                            [ M.read (| residual |) ]
                                          |)
                                        |)
                                      |)
                                    |)
                                  |)));
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Continue",
                                      0
                                    |) in
                                  let val := M.copy (| γ0_0 |) in
                                  val))
                            ]
                          |)
                        |)
                      ]
                    |)
                  |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                        let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                        let ptr := M.copy (| γ0_0 |) in
                        let alloc := M.copy (| γ0_1 |) in
                        M.alloc (|
                          Value.StructTuple
                            "core::result::Result::Ok"
                            [
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "alloc::rc::Rc") [ T; A ],
                                  "from_inner_in",
                                  []
                                |),
                                [
                                  M.call_closure (|
                                    M.get_trait_method (|
                                      "core::convert::Into",
                                      Ty.apply
                                        (Ty.path "core::ptr::unique::Unique")
                                        [ Ty.apply (Ty.path "alloc::rc::RcBox") [ T ] ],
                                      [
                                        Ty.apply
                                          (Ty.path "core::ptr::non_null::NonNull")
                                          [ Ty.apply (Ty.path "alloc::rc::RcBox") [ T ] ]
                                      ],
                                      "into",
                                      []
                                    |),
                                    [ M.read (| ptr |) ]
                                  |);
                                  M.read (| alloc |)
                                ]
                              |)
                            ]
                        |)))
                  ]
                |)
              |)))
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_try_new_in :
      forall (T A : Ty.t),
      M.IsAssociatedFunction (Self T A) "try_new_in" (try_new_in T A).
    
    (*
        pub fn try_new_uninit_in(alloc: A) -> Result<Rc<mem::MaybeUninit<T>, A>, AllocError> {
            unsafe {
                Ok(Rc::from_ptr_in(
                    Rc::try_allocate_for_layout(
                        Layout::new::<T>(),
                        |layout| alloc.allocate(layout),
                        <*mut u8>::cast,
                    )?,
                    alloc,
                ))
            }
        }
    *)
    Definition try_new_uninit_in (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match τ, α with
      | [], [ alloc ] =>
        ltac:(M.monadic
          (let alloc := M.alloc (| alloc |) in
          M.catch_return (|
            ltac:(M.monadic
              (Value.StructTuple
                "core::result::Result::Ok"
                [
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "alloc::rc::Rc")
                        [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ T ]; A ],
                      "from_ptr_in",
                      []
                    |),
                    [
                      M.read (|
                        M.match_operator (|
                          M.alloc (|
                            M.call_closure (|
                              M.get_trait_method (|
                                "core::ops::try_trait::Try",
                                Ty.apply
                                  (Ty.path "core::result::Result")
                                  [
                                    Ty.apply
                                      (Ty.path "*mut")
                                      [
                                        Ty.apply
                                          (Ty.path "alloc::rc::RcBox")
                                          [
                                            Ty.apply
                                              (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                              [ T ]
                                          ]
                                      ];
                                    Ty.path "core::alloc::AllocError"
                                  ],
                                [],
                                "branch",
                                []
                              |),
                              [
                                M.call_closure (|
                                  M.get_associated_function (|
                                    Ty.apply
                                      (Ty.path "alloc::rc::Rc")
                                      [
                                        Ty.apply
                                          (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                          [ T ];
                                        Ty.path "alloc::alloc::Global"
                                      ],
                                    "try_allocate_for_layout",
                                    [
                                      Ty.function
                                        [ Ty.tuple [ Ty.path "core::alloc::layout::Layout" ] ]
                                        (Ty.apply
                                          (Ty.path "core::result::Result")
                                          [
                                            Ty.apply
                                              (Ty.path "core::ptr::non_null::NonNull")
                                              [ Ty.apply (Ty.path "slice") [ Ty.path "u8" ] ];
                                            Ty.path "core::alloc::AllocError"
                                          ]);
                                      Ty.function
                                        [ Ty.apply (Ty.path "*mut") [ Ty.path "u8" ] ]
                                        (Ty.apply
                                          (Ty.path "*mut")
                                          [
                                            Ty.apply
                                              (Ty.path "alloc::rc::RcBox")
                                              [
                                                Ty.apply
                                                  (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                                  [ T ]
                                              ]
                                          ])
                                    ]
                                  |),
                                  [
                                    M.call_closure (|
                                      M.get_associated_function (|
                                        Ty.path "core::alloc::layout::Layout",
                                        "new",
                                        [ T ]
                                      |),
                                      []
                                    |);
                                    M.closure
                                      (fun γ =>
                                        ltac:(M.monadic
                                          match γ with
                                          | [ α0 ] =>
                                            M.match_operator (|
                                              M.alloc (| α0 |),
                                              [
                                                fun γ =>
                                                  ltac:(M.monadic
                                                    (let layout := M.copy (| γ |) in
                                                    M.call_closure (|
                                                      M.get_trait_method (|
                                                        "core::alloc::Allocator",
                                                        A,
                                                        [],
                                                        "allocate",
                                                        []
                                                      |),
                                                      [ alloc; M.read (| layout |) ]
                                                    |)))
                                              ]
                                            |)
                                          | _ => M.impossible (||)
                                          end));
                                    M.get_associated_function (|
                                      Ty.apply (Ty.path "*mut") [ Ty.path "u8" ],
                                      "cast",
                                      [
                                        Ty.apply
                                          (Ty.path "alloc::rc::RcBox")
                                          [
                                            Ty.apply
                                              (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                              [ T ]
                                          ]
                                      ]
                                    |)
                                  ]
                                |)
                              ]
                            |)
                          |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ0_0 :=
                                  M.SubPointer.get_struct_tuple_field (|
                                    γ,
                                    "core::ops::control_flow::ControlFlow::Break",
                                    0
                                  |) in
                                let residual := M.copy (| γ0_0 |) in
                                M.alloc (|
                                  M.never_to_any (|
                                    M.read (|
                                      M.return_ (|
                                        M.call_closure (|
                                          M.get_trait_method (|
                                            "core::ops::try_trait::FromResidual",
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              [
                                                Ty.apply
                                                  (Ty.path "alloc::rc::Rc")
                                                  [
                                                    Ty.apply
                                                      (Ty.path
                                                        "core::mem::maybe_uninit::MaybeUninit")
                                                      [ T ];
                                                    A
                                                  ];
                                                Ty.path "core::alloc::AllocError"
                                              ],
                                            [
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                [
                                                  Ty.path "core::convert::Infallible";
                                                  Ty.path "core::alloc::AllocError"
                                                ]
                                            ],
                                            "from_residual",
                                            []
                                          |),
                                          [ M.read (| residual |) ]
                                        |)
                                      |)
                                    |)
                                  |)
                                |)));
                            fun γ =>
                              ltac:(M.monadic
                                (let γ0_0 :=
                                  M.SubPointer.get_struct_tuple_field (|
                                    γ,
                                    "core::ops::control_flow::ControlFlow::Continue",
                                    0
                                  |) in
                                let val := M.copy (| γ0_0 |) in
                                val))
                          ]
                        |)
                      |);
                      M.read (| alloc |)
                    ]
                  |)
                ]))
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_try_new_uninit_in :
      forall (T A : Ty.t),
      M.IsAssociatedFunction (Self T A) "try_new_uninit_in" (try_new_uninit_in T A).
    
    (*
        pub fn try_new_zeroed_in(alloc: A) -> Result<Rc<mem::MaybeUninit<T>, A>, AllocError> {
            unsafe {
                Ok(Rc::from_ptr_in(
                    Rc::try_allocate_for_layout(
                        Layout::new::<T>(),
                        |layout| alloc.allocate_zeroed(layout),
                        <*mut u8>::cast,
                    )?,
                    alloc,
                ))
            }
        }
    *)
    Definition try_new_zeroed_in (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match τ, α with
      | [], [ alloc ] =>
        ltac:(M.monadic
          (let alloc := M.alloc (| alloc |) in
          M.catch_return (|
            ltac:(M.monadic
              (Value.StructTuple
                "core::result::Result::Ok"
                [
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "alloc::rc::Rc")
                        [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ T ]; A ],
                      "from_ptr_in",
                      []
                    |),
                    [
                      M.read (|
                        M.match_operator (|
                          M.alloc (|
                            M.call_closure (|
                              M.get_trait_method (|
                                "core::ops::try_trait::Try",
                                Ty.apply
                                  (Ty.path "core::result::Result")
                                  [
                                    Ty.apply
                                      (Ty.path "*mut")
                                      [
                                        Ty.apply
                                          (Ty.path "alloc::rc::RcBox")
                                          [
                                            Ty.apply
                                              (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                              [ T ]
                                          ]
                                      ];
                                    Ty.path "core::alloc::AllocError"
                                  ],
                                [],
                                "branch",
                                []
                              |),
                              [
                                M.call_closure (|
                                  M.get_associated_function (|
                                    Ty.apply
                                      (Ty.path "alloc::rc::Rc")
                                      [
                                        Ty.apply
                                          (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                          [ T ];
                                        Ty.path "alloc::alloc::Global"
                                      ],
                                    "try_allocate_for_layout",
                                    [
                                      Ty.function
                                        [ Ty.tuple [ Ty.path "core::alloc::layout::Layout" ] ]
                                        (Ty.apply
                                          (Ty.path "core::result::Result")
                                          [
                                            Ty.apply
                                              (Ty.path "core::ptr::non_null::NonNull")
                                              [ Ty.apply (Ty.path "slice") [ Ty.path "u8" ] ];
                                            Ty.path "core::alloc::AllocError"
                                          ]);
                                      Ty.function
                                        [ Ty.apply (Ty.path "*mut") [ Ty.path "u8" ] ]
                                        (Ty.apply
                                          (Ty.path "*mut")
                                          [
                                            Ty.apply
                                              (Ty.path "alloc::rc::RcBox")
                                              [
                                                Ty.apply
                                                  (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                                  [ T ]
                                              ]
                                          ])
                                    ]
                                  |),
                                  [
                                    M.call_closure (|
                                      M.get_associated_function (|
                                        Ty.path "core::alloc::layout::Layout",
                                        "new",
                                        [ T ]
                                      |),
                                      []
                                    |);
                                    M.closure
                                      (fun γ =>
                                        ltac:(M.monadic
                                          match γ with
                                          | [ α0 ] =>
                                            M.match_operator (|
                                              M.alloc (| α0 |),
                                              [
                                                fun γ =>
                                                  ltac:(M.monadic
                                                    (let layout := M.copy (| γ |) in
                                                    M.call_closure (|
                                                      M.get_trait_method (|
                                                        "core::alloc::Allocator",
                                                        A,
                                                        [],
                                                        "allocate_zeroed",
                                                        []
                                                      |),
                                                      [ alloc; M.read (| layout |) ]
                                                    |)))
                                              ]
                                            |)
                                          | _ => M.impossible (||)
                                          end));
                                    M.get_associated_function (|
                                      Ty.apply (Ty.path "*mut") [ Ty.path "u8" ],
                                      "cast",
                                      [
                                        Ty.apply
                                          (Ty.path "alloc::rc::RcBox")
                                          [
                                            Ty.apply
                                              (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                              [ T ]
                                          ]
                                      ]
                                    |)
                                  ]
                                |)
                              ]
                            |)
                          |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ0_0 :=
                                  M.SubPointer.get_struct_tuple_field (|
                                    γ,
                                    "core::ops::control_flow::ControlFlow::Break",
                                    0
                                  |) in
                                let residual := M.copy (| γ0_0 |) in
                                M.alloc (|
                                  M.never_to_any (|
                                    M.read (|
                                      M.return_ (|
                                        M.call_closure (|
                                          M.get_trait_method (|
                                            "core::ops::try_trait::FromResidual",
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              [
                                                Ty.apply
                                                  (Ty.path "alloc::rc::Rc")
                                                  [
                                                    Ty.apply
                                                      (Ty.path
                                                        "core::mem::maybe_uninit::MaybeUninit")
                                                      [ T ];
                                                    A
                                                  ];
                                                Ty.path "core::alloc::AllocError"
                                              ],
                                            [
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                [
                                                  Ty.path "core::convert::Infallible";
                                                  Ty.path "core::alloc::AllocError"
                                                ]
                                            ],
                                            "from_residual",
                                            []
                                          |),
                                          [ M.read (| residual |) ]
                                        |)
                                      |)
                                    |)
                                  |)
                                |)));
                            fun γ =>
                              ltac:(M.monadic
                                (let γ0_0 :=
                                  M.SubPointer.get_struct_tuple_field (|
                                    γ,
                                    "core::ops::control_flow::ControlFlow::Continue",
                                    0
                                  |) in
                                let val := M.copy (| γ0_0 |) in
                                val))
                          ]
                        |)
                      |);
                      M.read (| alloc |)
                    ]
                  |)
                ]))
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_try_new_zeroed_in :
      forall (T A : Ty.t),
      M.IsAssociatedFunction (Self T A) "try_new_zeroed_in" (try_new_zeroed_in T A).
    
    (*
        pub fn pin_in(value: T, alloc: A) -> Pin<Self> {
            unsafe { Pin::new_unchecked(Rc::new_in(value, alloc)) }
        }
    *)
    Definition pin_in (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match τ, α with
      | [], [ value; alloc ] =>
        ltac:(M.monadic
          (let value := M.alloc (| value |) in
          let alloc := M.alloc (| alloc |) in
          M.call_closure (|
            M.get_associated_function (|
              Ty.apply (Ty.path "core::pin::Pin") [ Ty.apply (Ty.path "alloc::rc::Rc") [ T; A ] ],
              "new_unchecked",
              []
            |),
            [
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply (Ty.path "alloc::rc::Rc") [ T; A ],
                  "new_in",
                  []
                |),
                [ M.read (| value |); M.read (| alloc |) ]
              |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_pin_in :
      forall (T A : Ty.t),
      M.IsAssociatedFunction (Self T A) "pin_in" (pin_in T A).
    
    (*
        pub fn try_unwrap(this: Self) -> Result<T, Self> {
            if Rc::strong_count(&this) == 1 {
                unsafe {
                    let val = ptr::read(&*this); // copy the contained object
                    let alloc = ptr::read(&this.alloc); // copy the allocator
    
                    // Indicate to Weaks that they can't be promoted by decrementing
                    // the strong count, and then remove the implicit "strong weak"
                    // pointer while also handling drop logic by just crafting a
                    // fake Weak.
                    this.inner().dec_strong();
                    let _weak = Weak { ptr: this.ptr, alloc };
                    forget(this);
                    Ok(val)
                }
            } else {
                Err(this)
            }
        }
    *)
    Definition try_unwrap (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match τ, α with
      | [], [ this ] =>
        ltac:(M.monadic
          (let this := M.alloc (| this |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          BinOp.Pure.eq
                            (M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply (Ty.path "alloc::rc::Rc") [ T; A ],
                                "strong_count",
                                []
                              |),
                              [ this ]
                            |))
                            (Value.Integer 1)
                        |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    let val :=
                      M.alloc (|
                        M.call_closure (|
                          M.get_function (| "core::ptr::read", [ T ] |),
                          [
                            M.call_closure (|
                              M.get_trait_method (|
                                "core::ops::deref::Deref",
                                Ty.apply (Ty.path "alloc::rc::Rc") [ T; A ],
                                [],
                                "deref",
                                []
                              |),
                              [ this ]
                            |)
                          ]
                        |)
                      |) in
                    let alloc :=
                      M.alloc (|
                        M.call_closure (|
                          M.get_function (| "core::ptr::read", [ A ] |),
                          [
                            M.SubPointer.get_struct_record_field (|
                              this,
                              "alloc::rc::Rc",
                              "alloc"
                            |)
                          ]
                        |)
                      |) in
                    let _ :=
                      M.alloc (|
                        M.call_closure (|
                          M.get_trait_method (|
                            "alloc::rc::RcInnerPtr",
                            Ty.apply (Ty.path "alloc::rc::RcBox") [ T ],
                            [],
                            "dec_strong",
                            []
                          |),
                          [
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply (Ty.path "alloc::rc::Rc") [ T; A ],
                                "inner",
                                []
                              |),
                              [ this ]
                            |)
                          ]
                        |)
                      |) in
                    let _weak :=
                      M.alloc (|
                        Value.StructRecord
                          "alloc::rc::Weak"
                          [
                            ("ptr",
                              M.read (|
                                M.SubPointer.get_struct_record_field (|
                                  this,
                                  "alloc::rc::Rc",
                                  "ptr"
                                |)
                              |));
                            ("alloc", M.read (| alloc |))
                          ]
                      |) in
                    let _ :=
                      M.alloc (|
                        M.call_closure (|
                          M.get_function (|
                            "core::mem::forget",
                            [ Ty.apply (Ty.path "alloc::rc::Rc") [ T; A ] ]
                          |),
                          [ M.read (| this |) ]
                        |)
                      |) in
                    M.alloc (|
                      Value.StructTuple "core::result::Result::Ok" [ M.read (| val |) ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      Value.StructTuple "core::result::Result::Err" [ M.read (| this |) ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_try_unwrap :
      forall (T A : Ty.t),
      M.IsAssociatedFunction (Self T A) "try_unwrap" (try_unwrap T A).
    
    (*
        pub fn into_inner(this: Self) -> Option<T> {
            Rc::try_unwrap(this).ok()
        }
    *)
    Definition into_inner (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match τ, α with
      | [], [ this ] =>
        ltac:(M.monadic
          (let this := M.alloc (| this |) in
          M.call_closure (|
            M.get_associated_function (|
              Ty.apply
                (Ty.path "core::result::Result")
                [ T; Ty.apply (Ty.path "alloc::rc::Rc") [ T; A ] ],
              "ok",
              []
            |),
            [
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply (Ty.path "alloc::rc::Rc") [ T; A ],
                  "try_unwrap",
                  []
                |),
                [ M.read (| this |) ]
              |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_into_inner :
      forall (T A : Ty.t),
      M.IsAssociatedFunction (Self T A) "into_inner" (into_inner T A).
    (*
        pub fn into_raw(this: Self) -> *const T {
            let ptr = Self::as_ptr(&this);
            mem::forget(this);
            ptr
        }
    *)
    Definition into_raw (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match τ, α with
      | [], [ this ] =>
        ltac:(M.monadic
          (let this := M.alloc (| this |) in
          M.read (|
            let ptr :=
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "alloc::rc::Rc") [ T; A ],
                    "as_ptr",
                    []
                  |),
                  [ this ]
                |)
              |) in
            let _ :=
              M.alloc (|
                M.call_closure (|
                  M.get_function (|
                    "core::mem::forget",
                    [ Ty.apply (Ty.path "alloc::rc::Rc") [ T; A ] ]
                  |),
                  [ M.read (| this |) ]
                |)
              |) in
            ptr
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_into_raw :
      forall (T A : Ty.t),
      M.IsAssociatedFunction (Self T A) "into_raw" (into_raw T A).
    
    (*
        pub fn as_ptr(this: &Self) -> *const T {
            let ptr: *mut RcBox<T> = NonNull::as_ptr(this.ptr);
    
            // SAFETY: This cannot go through Deref::deref or Rc::inner because
            // this is required to retain raw/mut provenance such that e.g. `get_mut` can
            // write through the pointer after the Rc is recovered through `from_raw`.
            unsafe { ptr::addr_of_mut!(( *ptr).value) }
        }
    *)
    Definition as_ptr (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match τ, α with
      | [], [ this ] =>
        ltac:(M.monadic
          (let this := M.alloc (| this |) in
          M.read (|
            let ptr :=
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "core::ptr::non_null::NonNull")
                      [ Ty.apply (Ty.path "alloc::rc::RcBox") [ T ] ],
                    "as_ptr",
                    []
                  |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_record_field (|
                        M.read (| this |),
                        "alloc::rc::Rc",
                        "ptr"
                      |)
                    |)
                  ]
                |)
              |) in
            M.alloc (|
              (* MutToConstPointer *)
              M.pointer_coercion
                (M.SubPointer.get_struct_record_field (|
                  M.read (| ptr |),
                  "alloc::rc::RcBox",
                  "value"
                |))
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_as_ptr :
      forall (T A : Ty.t),
      M.IsAssociatedFunction (Self T A) "as_ptr" (as_ptr T A).
    
    (*
        pub unsafe fn from_raw_in(ptr: *const T, alloc: A) -> Self {
            let offset = unsafe { data_offset(ptr) };
    
            // Reverse the offset to find the original RcBox.
            let rc_ptr = unsafe { ptr.byte_sub(offset) as *mut RcBox<T> };
    
            unsafe { Self::from_ptr_in(rc_ptr, alloc) }
        }
    *)
    Definition from_raw_in (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match τ, α with
      | [], [ ptr; alloc ] =>
        ltac:(M.monadic
          (let ptr := M.alloc (| ptr |) in
          let alloc := M.alloc (| alloc |) in
          M.read (|
            let offset :=
              M.alloc (|
                M.call_closure (|
                  M.get_function (| "alloc::rc::data_offset", [ T ] |),
                  [ M.read (| ptr |) ]
                |)
              |) in
            let rc_ptr :=
              M.alloc (|
                M.rust_cast
                  (M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply (Ty.path "*const") [ T ],
                      "byte_sub",
                      []
                    |),
                    [ M.read (| ptr |); M.read (| offset |) ]
                  |))
              |) in
            M.alloc (|
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply (Ty.path "alloc::rc::Rc") [ T; A ],
                  "from_ptr_in",
                  []
                |),
                [ M.read (| rc_ptr |); M.read (| alloc |) ]
              |)
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_from_raw_in :
      forall (T A : Ty.t),
      M.IsAssociatedFunction (Self T A) "from_raw_in" (from_raw_in T A).
    
    (*
        pub fn downgrade(this: &Self) -> Weak<T, A>
        where
            A: Clone,
        {
            this.inner().inc_weak();
            // Make sure we do not create a dangling Weak
            debug_assert!(!is_dangling(this.ptr.as_ptr()));
            Weak { ptr: this.ptr, alloc: this.alloc.clone() }
        }
    *)
    Definition downgrade (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match τ, α with
      | [], [ this ] =>
        ltac:(M.monadic
          (let this := M.alloc (| this |) in
          M.read (|
            let _ :=
              M.alloc (|
                M.call_closure (|
                  M.get_trait_method (|
                    "alloc::rc::RcInnerPtr",
                    Ty.apply (Ty.path "alloc::rc::RcBox") [ T ],
                    [],
                    "inc_weak",
                    []
                  |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "alloc::rc::Rc") [ T; A ],
                        "inner",
                        []
                      |),
                      [ M.read (| this |) ]
                    |)
                  ]
                |)
              |) in
            let _ :=
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.use (M.alloc (| Value.Bool true |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      let _ :=
                        M.match_operator (|
                          M.alloc (| Value.Tuple [] |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ :=
                                  M.use
                                    (M.alloc (|
                                      UnOp.Pure.not
                                        (UnOp.Pure.not
                                          (M.call_closure (|
                                            M.get_function (|
                                              "alloc::rc::is_dangling",
                                              [ Ty.apply (Ty.path "alloc::rc::RcBox") [ T ] ]
                                            |),
                                            [
                                              M.call_closure (|
                                                M.get_associated_function (|
                                                  Ty.apply
                                                    (Ty.path "core::ptr::non_null::NonNull")
                                                    [ Ty.apply (Ty.path "alloc::rc::RcBox") [ T ] ],
                                                  "as_ptr",
                                                  []
                                                |),
                                                [
                                                  M.read (|
                                                    M.SubPointer.get_struct_record_field (|
                                                      M.read (| this |),
                                                      "alloc::rc::Rc",
                                                      "ptr"
                                                    |)
                                                  |)
                                                ]
                                              |)
                                            ]
                                          |)))
                                    |)) in
                                let _ :=
                                  M.is_constant_or_break_match (|
                                    M.read (| γ |),
                                    Value.Bool true
                                  |) in
                                M.alloc (|
                                  M.never_to_any (|
                                    M.call_closure (|
                                      M.get_function (| "core::panicking::panic", [] |),
                                      [
                                        M.read (|
                                          Value.String
                                            "assertion failed: !is_dangling(this.ptr.as_ptr())"
                                        |)
                                      ]
                                    |)
                                  |)
                                |)));
                            fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                          ]
                        |) in
                      M.alloc (| Value.Tuple [] |)));
                  fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                ]
              |) in
            M.alloc (|
              Value.StructRecord
                "alloc::rc::Weak"
                [
                  ("ptr",
                    M.read (|
                      M.SubPointer.get_struct_record_field (|
                        M.read (| this |),
                        "alloc::rc::Rc",
                        "ptr"
                      |)
                    |));
                  ("alloc",
                    M.call_closure (|
                      M.get_trait_method (| "core::clone::Clone", A, [], "clone", [] |),
                      [
                        M.SubPointer.get_struct_record_field (|
                          M.read (| this |),
                          "alloc::rc::Rc",
                          "alloc"
                        |)
                      ]
                    |))
                ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_downgrade :
      forall (T A : Ty.t),
      M.IsAssociatedFunction (Self T A) "downgrade" (downgrade T A).
    
    (*
        pub fn weak_count(this: &Self) -> usize {
            this.inner().weak() - 1
        }
    *)
    Definition weak_count (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match τ, α with
      | [], [ this ] =>
        ltac:(M.monadic
          (let this := M.alloc (| this |) in
          BinOp.Panic.sub (|
            Integer.Usize,
            M.call_closure (|
              M.get_trait_method (|
                "alloc::rc::RcInnerPtr",
                Ty.apply (Ty.path "alloc::rc::RcBox") [ T ],
                [],
                "weak",
                []
              |),
              [
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "alloc::rc::Rc") [ T; A ],
                    "inner",
                    []
                  |),
                  [ M.read (| this |) ]
                |)
              ]
            |),
            Value.Integer 1
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_weak_count :
      forall (T A : Ty.t),
      M.IsAssociatedFunction (Self T A) "weak_count" (weak_count T A).
    
    (*
        pub fn strong_count(this: &Self) -> usize {
            this.inner().strong()
        }
    *)
    Definition strong_count (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match τ, α with
      | [], [ this ] =>
        ltac:(M.monadic
          (let this := M.alloc (| this |) in
          M.call_closure (|
            M.get_trait_method (|
              "alloc::rc::RcInnerPtr",
              Ty.apply (Ty.path "alloc::rc::RcBox") [ T ],
              [],
              "strong",
              []
            |),
            [
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply (Ty.path "alloc::rc::Rc") [ T; A ],
                  "inner",
                  []
                |),
                [ M.read (| this |) ]
              |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_strong_count :
      forall (T A : Ty.t),
      M.IsAssociatedFunction (Self T A) "strong_count" (strong_count T A).
    
    (*
        pub unsafe fn increment_strong_count_in(ptr: *const T, alloc: A)
        where
            A: Clone,
        {
            // Retain Rc, but don't touch refcount by wrapping in ManuallyDrop
            let rc = unsafe { mem::ManuallyDrop::new(Rc::<T, A>::from_raw_in(ptr, alloc)) };
            // Now increase refcount, but don't drop new refcount either
            let _rc_clone: mem::ManuallyDrop<_> = rc.clone();
        }
    *)
    Definition increment_strong_count_in (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match τ, α with
      | [], [ ptr; alloc ] =>
        ltac:(M.monadic
          (let ptr := M.alloc (| ptr |) in
          let alloc := M.alloc (| alloc |) in
          M.read (|
            let rc :=
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "core::mem::manually_drop::ManuallyDrop")
                      [ Ty.apply (Ty.path "alloc::rc::Rc") [ T; A ] ],
                    "new",
                    []
                  |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "alloc::rc::Rc") [ T; A ],
                        "from_raw_in",
                        []
                      |),
                      [ M.read (| ptr |); M.read (| alloc |) ]
                    |)
                  ]
                |)
              |) in
            let _rc_clone :=
              M.alloc (|
                M.call_closure (|
                  M.get_trait_method (|
                    "core::clone::Clone",
                    Ty.apply
                      (Ty.path "core::mem::manually_drop::ManuallyDrop")
                      [ Ty.apply (Ty.path "alloc::rc::Rc") [ T; A ] ],
                    [],
                    "clone",
                    []
                  |),
                  [ rc ]
                |)
              |) in
            M.alloc (| Value.Tuple [] |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_increment_strong_count_in :
      forall (T A : Ty.t),
      M.IsAssociatedFunction (Self T A) "increment_strong_count_in" (increment_strong_count_in T A).
    
    (*
        pub unsafe fn decrement_strong_count_in(ptr: *const T, alloc: A) {
            unsafe { drop(Rc::from_raw_in(ptr, alloc)) };
        }
    *)
    Definition decrement_strong_count_in (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match τ, α with
      | [], [ ptr; alloc ] =>
        ltac:(M.monadic
          (let ptr := M.alloc (| ptr |) in
          let alloc := M.alloc (| alloc |) in
          M.read (|
            let _ :=
              M.alloc (|
                M.call_closure (|
                  M.get_function (|
                    "core::mem::drop",
                    [ Ty.apply (Ty.path "alloc::rc::Rc") [ T; A ] ]
                  |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "alloc::rc::Rc") [ T; A ],
                        "from_raw_in",
                        []
                      |),
                      [ M.read (| ptr |); M.read (| alloc |) ]
                    |)
                  ]
                |)
              |) in
            M.alloc (| Value.Tuple [] |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_decrement_strong_count_in :
      forall (T A : Ty.t),
      M.IsAssociatedFunction (Self T A) "decrement_strong_count_in" (decrement_strong_count_in T A).
    
    (*
        fn is_unique(this: &Self) -> bool {
            Rc::weak_count(this) == 0 && Rc::strong_count(this) == 1
        }
    *)
    Definition is_unique (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match τ, α with
      | [], [ this ] =>
        ltac:(M.monadic
          (let this := M.alloc (| this |) in
          LogicalOp.and (|
            BinOp.Pure.eq
              (M.call_closure (|
                M.get_associated_function (|
                  Ty.apply (Ty.path "alloc::rc::Rc") [ T; A ],
                  "weak_count",
                  []
                |),
                [ M.read (| this |) ]
              |))
              (Value.Integer 0),
            ltac:(M.monadic
              (BinOp.Pure.eq
                (M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "alloc::rc::Rc") [ T; A ],
                    "strong_count",
                    []
                  |),
                  [ M.read (| this |) ]
                |))
                (Value.Integer 1)))
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_is_unique :
      forall (T A : Ty.t),
      M.IsAssociatedFunction (Self T A) "is_unique" (is_unique T A).
    
    (*
        pub fn get_mut(this: &mut Self) -> Option<&mut T> {
            if Rc::is_unique(this) { unsafe { Some(Rc::get_mut_unchecked(this)) } } else { None }
        }
    *)
    Definition get_mut (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match τ, α with
      | [], [ this ] =>
        ltac:(M.monadic
          (let this := M.alloc (| this |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply (Ty.path "alloc::rc::Rc") [ T; A ],
                              "is_unique",
                              []
                            |),
                            [ M.read (| this |) ]
                          |)
                        |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::option::Option::Some"
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply (Ty.path "alloc::rc::Rc") [ T; A ],
                              "get_mut_unchecked",
                              []
                            |),
                            [ M.read (| this |) ]
                          |)
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic (M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_get_mut :
      forall (T A : Ty.t),
      M.IsAssociatedFunction (Self T A) "get_mut" (get_mut T A).
    
    (*
        pub unsafe fn get_mut_unchecked(this: &mut Self) -> &mut T {
            // We are careful to *not* create a reference covering the "count" fields, as
            // this would conflict with accesses to the reference counts (e.g. by `Weak`).
            unsafe { &mut ( *this.ptr.as_ptr()).value }
        }
    *)
    Definition get_mut_unchecked (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match τ, α with
      | [], [ this ] =>
        ltac:(M.monadic
          (let this := M.alloc (| this |) in
          M.SubPointer.get_struct_record_field (|
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply
                  (Ty.path "core::ptr::non_null::NonNull")
                  [ Ty.apply (Ty.path "alloc::rc::RcBox") [ T ] ],
                "as_ptr",
                []
              |),
              [
                M.read (|
                  M.SubPointer.get_struct_record_field (|
                    M.read (| this |),
                    "alloc::rc::Rc",
                    "ptr"
                  |)
                |)
              ]
            |),
            "alloc::rc::RcBox",
            "value"
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_get_mut_unchecked :
      forall (T A : Ty.t),
      M.IsAssociatedFunction (Self T A) "get_mut_unchecked" (get_mut_unchecked T A).
    
    (*
        pub fn ptr_eq(this: &Self, other: &Self) -> bool {
            ptr::addr_eq(this.ptr.as_ptr(), other.ptr.as_ptr())
        }
    *)
    Definition ptr_eq (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match τ, α with
      | [], [ this; other ] =>
        ltac:(M.monadic
          (let this := M.alloc (| this |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            M.get_function (|
              "core::ptr::addr_eq",
              [
                Ty.apply (Ty.path "alloc::rc::RcBox") [ T ];
                Ty.apply (Ty.path "alloc::rc::RcBox") [ T ]
              ]
            |),
            [
              (* MutToConstPointer *)
              M.pointer_coercion
                (M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "core::ptr::non_null::NonNull")
                      [ Ty.apply (Ty.path "alloc::rc::RcBox") [ T ] ],
                    "as_ptr",
                    []
                  |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_record_field (|
                        M.read (| this |),
                        "alloc::rc::Rc",
                        "ptr"
                      |)
                    |)
                  ]
                |));
              (* MutToConstPointer *)
              M.pointer_coercion
                (M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "core::ptr::non_null::NonNull")
                      [ Ty.apply (Ty.path "alloc::rc::RcBox") [ T ] ],
                    "as_ptr",
                    []
                  |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_record_field (|
                        M.read (| other |),
                        "alloc::rc::Rc",
                        "ptr"
                      |)
                    |)
                  ]
                |))
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_ptr_eq :
      forall (T A : Ty.t),
      M.IsAssociatedFunction (Self T A) "ptr_eq" (ptr_eq T A).
    (*
        pub fn make_mut(this: &mut Self) -> &mut T {
            if Rc::strong_count(this) != 1 {
                // Gotta clone the data, there are other Rcs.
                // Pre-allocate memory to allow writing the cloned value directly.
                let mut rc = Self::new_uninit_in(this.alloc.clone());
                unsafe {
                    let data = Rc::get_mut_unchecked(&mut rc);
                    ( **this).write_clone_into_raw(data.as_mut_ptr());
                    *this = rc.assume_init();
                }
            } else if Rc::weak_count(this) != 0 {
                // Can just steal the data, all that's left is Weaks
                let mut rc = Self::new_uninit_in(this.alloc.clone());
                unsafe {
                    let data = Rc::get_mut_unchecked(&mut rc);
                    data.as_mut_ptr().copy_from_nonoverlapping(&**this, 1);
    
                    this.inner().dec_strong();
                    // Remove implicit strong-weak ref (no need to craft a fake
                    // Weak here -- we know other Weaks can clean up for us)
                    this.inner().dec_weak();
                    ptr::write(this, rc.assume_init());
                }
            }
            // This unsafety is ok because we're guaranteed that the pointer
            // returned is the *only* pointer that will ever be returned to T. Our
            // reference count is guaranteed to be 1 at this point, and we required
            // the `Rc<T>` itself to be `mut`, so we're returning the only possible
            // reference to the allocation.
            unsafe { &mut this.ptr.as_mut().value }
        }
    *)
    Definition make_mut (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match τ, α with
      | [], [ this ] =>
        ltac:(M.monadic
          (let this := M.alloc (| this |) in
          M.read (|
            let _ :=
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            BinOp.Pure.ne
                              (M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "alloc::rc::Rc") [ T; A ],
                                  "strong_count",
                                  []
                                |),
                                [ M.read (| this |) ]
                              |))
                              (Value.Integer 1)
                          |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      let rc :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply (Ty.path "alloc::rc::Rc") [ T; A ],
                              "new_uninit_in",
                              []
                            |),
                            [
                              M.call_closure (|
                                M.get_trait_method (| "core::clone::Clone", A, [], "clone", [] |),
                                [
                                  M.SubPointer.get_struct_record_field (|
                                    M.read (| this |),
                                    "alloc::rc::Rc",
                                    "alloc"
                                  |)
                                ]
                              |)
                            ]
                          |)
                        |) in
                      let data :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply
                                (Ty.path "alloc::rc::Rc")
                                [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ T ]; A
                                ],
                              "get_mut_unchecked",
                              []
                            |),
                            [ rc ]
                          |)
                        |) in
                      let _ :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_trait_method (|
                              "alloc::alloc::WriteCloneIntoRaw",
                              T,
                              [],
                              "write_clone_into_raw",
                              []
                            |),
                            [
                              M.call_closure (|
                                M.get_trait_method (|
                                  "core::ops::deref::Deref",
                                  Ty.apply (Ty.path "alloc::rc::Rc") [ T; A ],
                                  [],
                                  "deref",
                                  []
                                |),
                                [ M.read (| this |) ]
                              |);
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ T ],
                                  "as_mut_ptr",
                                  []
                                |),
                                [ M.read (| data |) ]
                              |)
                            ]
                          |)
                        |) in
                      let _ :=
                        M.write (|
                          M.read (| this |),
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply
                                (Ty.path "alloc::rc::Rc")
                                [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ T ]; A
                                ],
                              "assume_init",
                              []
                            |),
                            [ M.read (| rc |) ]
                          |)
                        |) in
                      M.alloc (| Value.Tuple [] |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.match_operator (|
                        M.alloc (| Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.use
                                  (M.alloc (|
                                    BinOp.Pure.ne
                                      (M.call_closure (|
                                        M.get_associated_function (|
                                          Ty.apply (Ty.path "alloc::rc::Rc") [ T; A ],
                                          "weak_count",
                                          []
                                        |),
                                        [ M.read (| this |) ]
                                      |))
                                      (Value.Integer 0)
                                  |)) in
                              let _ :=
                                M.is_constant_or_break_match (|
                                  M.read (| γ |),
                                  Value.Bool true
                                |) in
                              let rc :=
                                M.alloc (|
                                  M.call_closure (|
                                    M.get_associated_function (|
                                      Ty.apply (Ty.path "alloc::rc::Rc") [ T; A ],
                                      "new_uninit_in",
                                      []
                                    |),
                                    [
                                      M.call_closure (|
                                        M.get_trait_method (|
                                          "core::clone::Clone",
                                          A,
                                          [],
                                          "clone",
                                          []
                                        |),
                                        [
                                          M.SubPointer.get_struct_record_field (|
                                            M.read (| this |),
                                            "alloc::rc::Rc",
                                            "alloc"
                                          |)
                                        ]
                                      |)
                                    ]
                                  |)
                                |) in
                              let data :=
                                M.alloc (|
                                  M.call_closure (|
                                    M.get_associated_function (|
                                      Ty.apply
                                        (Ty.path "alloc::rc::Rc")
                                        [
                                          Ty.apply
                                            (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                            [ T ];
                                          A
                                        ],
                                      "get_mut_unchecked",
                                      []
                                    |),
                                    [ rc ]
                                  |)
                                |) in
                              let _ :=
                                M.alloc (|
                                  M.call_closure (|
                                    M.get_associated_function (|
                                      Ty.apply (Ty.path "*mut") [ T ],
                                      "copy_from_nonoverlapping",
                                      []
                                    |),
                                    [
                                      M.call_closure (|
                                        M.get_associated_function (|
                                          Ty.apply
                                            (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                            [ T ],
                                          "as_mut_ptr",
                                          []
                                        |),
                                        [ M.read (| data |) ]
                                      |);
                                      M.call_closure (|
                                        M.get_trait_method (|
                                          "core::ops::deref::Deref",
                                          Ty.apply (Ty.path "alloc::rc::Rc") [ T; A ],
                                          [],
                                          "deref",
                                          []
                                        |),
                                        [ M.read (| this |) ]
                                      |);
                                      Value.Integer 1
                                    ]
                                  |)
                                |) in
                              let _ :=
                                M.alloc (|
                                  M.call_closure (|
                                    M.get_trait_method (|
                                      "alloc::rc::RcInnerPtr",
                                      Ty.apply (Ty.path "alloc::rc::RcBox") [ T ],
                                      [],
                                      "dec_strong",
                                      []
                                    |),
                                    [
                                      M.call_closure (|
                                        M.get_associated_function (|
                                          Ty.apply (Ty.path "alloc::rc::Rc") [ T; A ],
                                          "inner",
                                          []
                                        |),
                                        [ M.read (| this |) ]
                                      |)
                                    ]
                                  |)
                                |) in
                              let _ :=
                                M.alloc (|
                                  M.call_closure (|
                                    M.get_trait_method (|
                                      "alloc::rc::RcInnerPtr",
                                      Ty.apply (Ty.path "alloc::rc::RcBox") [ T ],
                                      [],
                                      "dec_weak",
                                      []
                                    |),
                                    [
                                      M.call_closure (|
                                        M.get_associated_function (|
                                          Ty.apply (Ty.path "alloc::rc::Rc") [ T; A ],
                                          "inner",
                                          []
                                        |),
                                        [ M.read (| this |) ]
                                      |)
                                    ]
                                  |)
                                |) in
                              let _ :=
                                M.alloc (|
                                  M.call_closure (|
                                    M.get_function (|
                                      "core::ptr::write",
                                      [ Ty.apply (Ty.path "alloc::rc::Rc") [ T; A ] ]
                                    |),
                                    [
                                      M.read (| this |);
                                      M.call_closure (|
                                        M.get_associated_function (|
                                          Ty.apply
                                            (Ty.path "alloc::rc::Rc")
                                            [
                                              Ty.apply
                                                (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                                [ T ];
                                              A
                                            ],
                                          "assume_init",
                                          []
                                        |),
                                        [ M.read (| rc |) ]
                                      |)
                                    ]
                                  |)
                                |) in
                              M.alloc (| Value.Tuple [] |)));
                          fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                        ]
                      |)))
                ]
              |) in
            M.alloc (|
              M.SubPointer.get_struct_record_field (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "core::ptr::non_null::NonNull")
                      [ Ty.apply (Ty.path "alloc::rc::RcBox") [ T ] ],
                    "as_mut",
                    []
                  |),
                  [
                    M.SubPointer.get_struct_record_field (|
                      M.read (| this |),
                      "alloc::rc::Rc",
                      "ptr"
                    |)
                  ]
                |),
                "alloc::rc::RcBox",
                "value"
              |)
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_make_mut :
      forall (T A : Ty.t),
      M.IsAssociatedFunction (Self T A) "make_mut" (make_mut T A).
    
    (*
        pub fn unwrap_or_clone(this: Self) -> T {
            Rc::try_unwrap(this).unwrap_or_else(|rc| ( *rc).clone())
        }
    *)
    Definition unwrap_or_clone (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match τ, α with
      | [], [ this ] =>
        ltac:(M.monadic
          (let this := M.alloc (| this |) in
          M.call_closure (|
            M.get_associated_function (|
              Ty.apply
                (Ty.path "core::result::Result")
                [ T; Ty.apply (Ty.path "alloc::rc::Rc") [ T; A ] ],
              "unwrap_or_else",
              [ Ty.function [ Ty.tuple [ Ty.apply (Ty.path "alloc::rc::Rc") [ T; A ] ] ] T ]
            |),
            [
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply (Ty.path "alloc::rc::Rc") [ T; A ],
                  "try_unwrap",
                  []
                |),
                [ M.read (| this |) ]
              |);
              M.closure
                (fun γ =>
                  ltac:(M.monadic
                    match γ with
                    | [ α0 ] =>
                      M.match_operator (|
                        M.alloc (| α0 |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let rc := M.copy (| γ |) in
                              M.call_closure (|
                                M.get_trait_method (| "core::clone::Clone", T, [], "clone", [] |),
                                [
                                  M.call_closure (|
                                    M.get_trait_method (|
                                      "core::ops::deref::Deref",
                                      Ty.apply (Ty.path "alloc::rc::Rc") [ T; A ],
                                      [],
                                      "deref",
                                      []
                                    |),
                                    [ rc ]
                                  |)
                                ]
                              |)))
                        ]
                      |)
                    | _ => M.impossible (||)
                    end))
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_unwrap_or_clone :
      forall (T A : Ty.t),
      M.IsAssociatedFunction (Self T A) "unwrap_or_clone" (unwrap_or_clone T A).
    (*
        unsafe fn allocate_for_ptr_in(ptr: *const T, alloc: &A) -> *mut RcBox<T> {
            // Allocate for the `RcBox<T>` using the given value.
            unsafe {
                Rc::<T>::allocate_for_layout(
                    Layout::for_value(&*ptr),
                    |layout| alloc.allocate(layout),
                    |mem| mem.with_metadata_of(ptr as *const RcBox<T>),
                )
            }
        }
    *)
    Definition allocate_for_ptr_in (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match τ, α with
      | [], [ ptr; alloc ] =>
        ltac:(M.monadic
          (let ptr := M.alloc (| ptr |) in
          let alloc := M.alloc (| alloc |) in
          M.call_closure (|
            M.get_associated_function (|
              Ty.apply (Ty.path "alloc::rc::Rc") [ T; Ty.path "alloc::alloc::Global" ],
              "allocate_for_layout",
              [
                Ty.function
                  [ Ty.tuple [ Ty.path "core::alloc::layout::Layout" ] ]
                  (Ty.apply
                    (Ty.path "core::result::Result")
                    [
                      Ty.apply
                        (Ty.path "core::ptr::non_null::NonNull")
                        [ Ty.apply (Ty.path "slice") [ Ty.path "u8" ] ];
                      Ty.path "core::alloc::AllocError"
                    ]);
                Ty.function
                  [ Ty.tuple [ Ty.apply (Ty.path "*mut") [ Ty.path "u8" ] ] ]
                  (Ty.apply (Ty.path "*mut") [ Ty.apply (Ty.path "alloc::rc::RcBox") [ T ] ])
              ]
            |),
            [
              M.call_closure (|
                M.get_associated_function (|
                  Ty.path "core::alloc::layout::Layout",
                  "for_value",
                  [ T ]
                |),
                [ M.read (| ptr |) ]
              |);
              M.closure
                (fun γ =>
                  ltac:(M.monadic
                    match γ with
                    | [ α0 ] =>
                      M.match_operator (|
                        M.alloc (| α0 |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let layout := M.copy (| γ |) in
                              M.call_closure (|
                                M.get_trait_method (|
                                  "core::alloc::Allocator",
                                  A,
                                  [],
                                  "allocate",
                                  []
                                |),
                                [ M.read (| alloc |); M.read (| layout |) ]
                              |)))
                        ]
                      |)
                    | _ => M.impossible (||)
                    end));
              M.closure
                (fun γ =>
                  ltac:(M.monadic
                    match γ with
                    | [ α0 ] =>
                      M.match_operator (|
                        M.alloc (| α0 |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let mem := M.copy (| γ |) in
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "*mut") [ Ty.path "u8" ],
                                  "with_metadata_of",
                                  [ Ty.apply (Ty.path "alloc::rc::RcBox") [ T ] ]
                                |),
                                [ M.read (| mem |); M.rust_cast (M.read (| ptr |)) ]
                              |)))
                        ]
                      |)
                    | _ => M.impossible (||)
                    end))
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_allocate_for_ptr_in :
      forall (T A : Ty.t),
      M.IsAssociatedFunction (Self T A) "allocate_for_ptr_in" (allocate_for_ptr_in T A).
    
    (*
        fn from_box_in(src: Box<T, A>) -> Rc<T, A> {
            unsafe {
                let value_size = size_of_val(&*src);
                let ptr = Self::allocate_for_ptr_in(&*src, Box::allocator(&src));
    
                // Copy value as bytes
                ptr::copy_nonoverlapping(
                    &*src as *const T as *const u8,
                    &mut ( *ptr).value as *mut _ as *mut u8,
                    value_size,
                );
    
                // Free the allocation without dropping its contents
                let (bptr, alloc) = Box::into_raw_with_allocator(src);
                let src = Box::from_raw(bptr as *mut mem::ManuallyDrop<T>);
                drop(src);
    
                Self::from_ptr_in(ptr, alloc)
            }
        }
    *)
    Definition from_box_in (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match τ, α with
      | [], [ src ] =>
        ltac:(M.monadic
          (let src := M.alloc (| src |) in
          M.read (|
            let value_size :=
              M.alloc (|
                M.call_closure (|
                  M.get_function (| "core::mem::size_of_val", [ T ] |),
                  [ M.read (| src |) ]
                |)
              |) in
            let ptr :=
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "alloc::rc::Rc") [ T; A ],
                    "allocate_for_ptr_in",
                    []
                  |),
                  [
                    M.read (| src |);
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "alloc::boxed::Box") [ T; A ],
                        "allocator",
                        []
                      |),
                      [ src ]
                    |)
                  ]
                |)
              |) in
            let _ :=
              M.alloc (|
                M.call_closure (|
                  M.get_function (| "core::intrinsics::copy_nonoverlapping", [ Ty.path "u8" ] |),
                  [
                    M.rust_cast (M.read (| M.use (M.alloc (| M.read (| src |) |)) |));
                    M.rust_cast
                      (M.read (|
                        M.use
                          (M.alloc (|
                            M.SubPointer.get_struct_record_field (|
                              M.read (| ptr |),
                              "alloc::rc::RcBox",
                              "value"
                            |)
                          |))
                      |));
                    M.read (| value_size |)
                  ]
                |)
              |) in
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "alloc::boxed::Box") [ T; A ],
                    "into_raw_with_allocator",
                    []
                  |),
                  [ M.read (| src |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let bptr := M.copy (| γ0_0 |) in
                    let alloc := M.copy (| γ0_1 |) in
                    let src :=
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.apply
                              (Ty.path "alloc::boxed::Box")
                              [
                                Ty.apply (Ty.path "core::mem::manually_drop::ManuallyDrop") [ T ];
                                Ty.path "alloc::alloc::Global"
                              ],
                            "from_raw",
                            []
                          |),
                          [ M.rust_cast (M.read (| bptr |)) ]
                        |)
                      |) in
                    let _ :=
                      M.alloc (|
                        M.call_closure (|
                          M.get_function (|
                            "core::mem::drop",
                            [
                              Ty.apply
                                (Ty.path "alloc::boxed::Box")
                                [
                                  Ty.apply (Ty.path "core::mem::manually_drop::ManuallyDrop") [ T ];
                                  Ty.path "alloc::alloc::Global"
                                ]
                            ]
                          |),
                          [ M.read (| src |) ]
                        |)
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "alloc::rc::Rc") [ T; A ],
                          "from_ptr_in",
                          []
                        |),
                        [ M.read (| ptr |); M.read (| alloc |) ]
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_from_box_in :
      forall (T A : Ty.t),
      M.IsAssociatedFunction (Self T A) "from_box_in" (from_box_in T A).
  End Impl_alloc_rc_Rc_T_A.
  
  
  
  Module Impl_alloc_rc_Rc_slice_T_alloc_alloc_Global.
    Definition Self (T : Ty.t) : Ty.t :=
      Ty.apply
        (Ty.path "alloc::rc::Rc")
        [ Ty.apply (Ty.path "slice") [ T ]; Ty.path "alloc::alloc::Global" ].
    
    (*
        pub fn new_uninit_slice(len: usize) -> Rc<[mem::MaybeUninit<T>]> {
            unsafe { Rc::from_ptr(Rc::allocate_for_slice(len)) }
        }
    *)
    Definition new_uninit_slice (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match τ, α with
      | [], [ len ] =>
        ltac:(M.monadic
          (let len := M.alloc (| len |) in
          M.call_closure (|
            M.get_associated_function (|
              Ty.apply
                (Ty.path "alloc::rc::Rc")
                [
                  Ty.apply
                    (Ty.path "slice")
                    [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ T ] ];
                  Ty.path "alloc::alloc::Global"
                ],
              "from_ptr",
              []
            |),
            [
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "alloc::rc::Rc")
                    [
                      Ty.apply
                        (Ty.path "slice")
                        [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ T ] ];
                      Ty.path "alloc::alloc::Global"
                    ],
                  "allocate_for_slice",
                  []
                |),
                [ M.read (| len |) ]
              |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_new_uninit_slice :
      forall (T : Ty.t),
      M.IsAssociatedFunction (Self T) "new_uninit_slice" (new_uninit_slice T).
    
    (*
        pub fn new_zeroed_slice(len: usize) -> Rc<[mem::MaybeUninit<T>]> {
            unsafe {
                Rc::from_ptr(Rc::allocate_for_layout(
                    Layout::array::<T>(len).unwrap(),
                    |layout| Global.allocate_zeroed(layout),
                    |mem| {
                        ptr::slice_from_raw_parts_mut(mem.cast::<T>(), len)
                            as *mut RcBox<[mem::MaybeUninit<T>]>
                    },
                ))
            }
        }
    *)
    Definition new_zeroed_slice (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match τ, α with
      | [], [ len ] =>
        ltac:(M.monadic
          (let len := M.alloc (| len |) in
          M.call_closure (|
            M.get_associated_function (|
              Ty.apply
                (Ty.path "alloc::rc::Rc")
                [
                  Ty.apply
                    (Ty.path "slice")
                    [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ T ] ];
                  Ty.path "alloc::alloc::Global"
                ],
              "from_ptr",
              []
            |),
            [
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "alloc::rc::Rc")
                    [
                      Ty.apply
                        (Ty.path "slice")
                        [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ T ] ];
                      Ty.path "alloc::alloc::Global"
                    ],
                  "allocate_for_layout",
                  [
                    Ty.function
                      [ Ty.tuple [ Ty.path "core::alloc::layout::Layout" ] ]
                      (Ty.apply
                        (Ty.path "core::result::Result")
                        [
                          Ty.apply
                            (Ty.path "core::ptr::non_null::NonNull")
                            [ Ty.apply (Ty.path "slice") [ Ty.path "u8" ] ];
                          Ty.path "core::alloc::AllocError"
                        ]);
                    Ty.function
                      [ Ty.tuple [ Ty.apply (Ty.path "*mut") [ Ty.path "u8" ] ] ]
                      (Ty.apply
                        (Ty.path "*mut")
                        [
                          Ty.apply
                            (Ty.path "alloc::rc::RcBox")
                            [
                              Ty.apply
                                (Ty.path "slice")
                                [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ T ] ]
                            ]
                        ])
                  ]
                |),
                [
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "core::result::Result")
                        [
                          Ty.path "core::alloc::layout::Layout";
                          Ty.path "core::alloc::layout::LayoutError"
                        ],
                      "unwrap",
                      []
                    |),
                    [
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::alloc::layout::Layout",
                          "array",
                          [ T ]
                        |),
                        [ M.read (| len |) ]
                      |)
                    ]
                  |);
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0 ] =>
                          M.match_operator (|
                            M.alloc (| α0 |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let layout := M.copy (| γ |) in
                                  M.call_closure (|
                                    M.get_trait_method (|
                                      "core::alloc::Allocator",
                                      Ty.path "alloc::alloc::Global",
                                      [],
                                      "allocate_zeroed",
                                      []
                                    |),
                                    [
                                      M.alloc (| Value.StructTuple "alloc::alloc::Global" [] |);
                                      M.read (| layout |)
                                    ]
                                  |)))
                            ]
                          |)
                        | _ => M.impossible (||)
                        end));
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0 ] =>
                          M.match_operator (|
                            M.alloc (| α0 |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let mem := M.copy (| γ |) in
                                  M.rust_cast
                                    (M.call_closure (|
                                      M.get_function (|
                                        "core::ptr::slice_from_raw_parts_mut",
                                        [ T ]
                                      |),
                                      [
                                        M.call_closure (|
                                          M.get_associated_function (|
                                            Ty.apply (Ty.path "*mut") [ Ty.path "u8" ],
                                            "cast",
                                            [ T ]
                                          |),
                                          [ M.read (| mem |) ]
                                        |);
                                        M.read (| len |)
                                      ]
                                    |))))
                            ]
                          |)
                        | _ => M.impossible (||)
                        end))
                ]
              |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_new_zeroed_slice :
      forall (T : Ty.t),
      M.IsAssociatedFunction (Self T) "new_zeroed_slice" (new_zeroed_slice T).
    (*
        unsafe fn allocate_for_slice(len: usize) -> *mut RcBox<[T]> {
            unsafe {
                Self::allocate_for_layout(
                    Layout::array::<T>(len).unwrap(),
                    |layout| Global.allocate(layout),
                    |mem| ptr::slice_from_raw_parts_mut(mem.cast::<T>(), len) as *mut RcBox<[T]>,
                )
            }
        }
    *)
    Definition allocate_for_slice (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match τ, α with
      | [], [ len ] =>
        ltac:(M.monadic
          (let len := M.alloc (| len |) in
          M.call_closure (|
            M.get_associated_function (|
              Ty.apply
                (Ty.path "alloc::rc::Rc")
                [ Ty.apply (Ty.path "slice") [ T ]; Ty.path "alloc::alloc::Global" ],
              "allocate_for_layout",
              [
                Ty.function
                  [ Ty.tuple [ Ty.path "core::alloc::layout::Layout" ] ]
                  (Ty.apply
                    (Ty.path "core::result::Result")
                    [
                      Ty.apply
                        (Ty.path "core::ptr::non_null::NonNull")
                        [ Ty.apply (Ty.path "slice") [ Ty.path "u8" ] ];
                      Ty.path "core::alloc::AllocError"
                    ]);
                Ty.function
                  [ Ty.tuple [ Ty.apply (Ty.path "*mut") [ Ty.path "u8" ] ] ]
                  (Ty.apply
                    (Ty.path "*mut")
                    [ Ty.apply (Ty.path "alloc::rc::RcBox") [ Ty.apply (Ty.path "slice") [ T ] ] ])
              ]
            |),
            [
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "core::result::Result")
                    [
                      Ty.path "core::alloc::layout::Layout";
                      Ty.path "core::alloc::layout::LayoutError"
                    ],
                  "unwrap",
                  []
                |),
                [
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.path "core::alloc::layout::Layout",
                      "array",
                      [ T ]
                    |),
                    [ M.read (| len |) ]
                  |)
                ]
              |);
              M.closure
                (fun γ =>
                  ltac:(M.monadic
                    match γ with
                    | [ α0 ] =>
                      M.match_operator (|
                        M.alloc (| α0 |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let layout := M.copy (| γ |) in
                              M.call_closure (|
                                M.get_trait_method (|
                                  "core::alloc::Allocator",
                                  Ty.path "alloc::alloc::Global",
                                  [],
                                  "allocate",
                                  []
                                |),
                                [
                                  M.alloc (| Value.StructTuple "alloc::alloc::Global" [] |);
                                  M.read (| layout |)
                                ]
                              |)))
                        ]
                      |)
                    | _ => M.impossible (||)
                    end));
              M.closure
                (fun γ =>
                  ltac:(M.monadic
                    match γ with
                    | [ α0 ] =>
                      M.match_operator (|
                        M.alloc (| α0 |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let mem := M.copy (| γ |) in
                              M.rust_cast
                                (M.call_closure (|
                                  M.get_function (| "core::ptr::slice_from_raw_parts_mut", [ T ] |),
                                  [
                                    M.call_closure (|
                                      M.get_associated_function (|
                                        Ty.apply (Ty.path "*mut") [ Ty.path "u8" ],
                                        "cast",
                                        [ T ]
                                      |),
                                      [ M.read (| mem |) ]
                                    |);
                                    M.read (| len |)
                                  ]
                                |))))
                        ]
                      |)
                    | _ => M.impossible (||)
                    end))
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_allocate_for_slice :
      forall (T : Ty.t),
      M.IsAssociatedFunction (Self T) "allocate_for_slice" (allocate_for_slice T).
    
    (*
        unsafe fn copy_from_slice(v: &[T]) -> Rc<[T]> {
            unsafe {
                let ptr = Self::allocate_for_slice(v.len());
                ptr::copy_nonoverlapping(v.as_ptr(), &mut ( *ptr).value as *mut [T] as *mut T, v.len());
                Self::from_ptr(ptr)
            }
        }
    *)
    Definition copy_from_slice (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match τ, α with
      | [], [ v ] =>
        ltac:(M.monadic
          (let v := M.alloc (| v |) in
          M.read (|
            let ptr :=
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "alloc::rc::Rc")
                      [ Ty.apply (Ty.path "slice") [ T ]; Ty.path "alloc::alloc::Global" ],
                    "allocate_for_slice",
                    []
                  |),
                  [
                    M.call_closure (|
                      M.get_associated_function (| Ty.apply (Ty.path "slice") [ T ], "len", [] |),
                      [ M.read (| v |) ]
                    |)
                  ]
                |)
              |) in
            let _ :=
              M.alloc (|
                M.call_closure (|
                  M.get_function (| "core::intrinsics::copy_nonoverlapping", [ T ] |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "slice") [ T ],
                        "as_ptr",
                        []
                      |),
                      [ M.read (| v |) ]
                    |);
                    M.rust_cast
                      (M.read (|
                        M.use
                          (M.alloc (|
                            M.SubPointer.get_struct_record_field (|
                              M.read (| ptr |),
                              "alloc::rc::RcBox",
                              "value"
                            |)
                          |))
                      |));
                    M.call_closure (|
                      M.get_associated_function (| Ty.apply (Ty.path "slice") [ T ], "len", [] |),
                      [ M.read (| v |) ]
                    |)
                  ]
                |)
              |) in
            M.alloc (|
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "alloc::rc::Rc")
                    [ Ty.apply (Ty.path "slice") [ T ]; Ty.path "alloc::alloc::Global" ],
                  "from_ptr",
                  []
                |),
                [ M.read (| ptr |) ]
              |)
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_copy_from_slice :
      forall (T : Ty.t),
      M.IsAssociatedFunction (Self T) "copy_from_slice" (copy_from_slice T).
    
    (*
        unsafe fn from_iter_exact(iter: impl Iterator<Item = T>, len: usize) -> Rc<[T]> {
            // Panic guard while cloning T elements.
            // In the event of a panic, elements that have been written
            // into the new RcBox will be dropped, then the memory freed.
            struct Guard<T> {
                mem: NonNull<u8>,
                elems: *mut T,
                layout: Layout,
                n_elems: usize,
            }
    
            impl<T> Drop for Guard<T> {
                fn drop(&mut self) {
                    unsafe {
                        let slice = from_raw_parts_mut(self.elems, self.n_elems);
                        ptr::drop_in_place(slice);
    
                        Global.deallocate(self.mem, self.layout);
                    }
                }
            }
    
            unsafe {
                let ptr = Self::allocate_for_slice(len);
    
                let mem = ptr as *mut _ as *mut u8;
                let layout = Layout::for_value(&*ptr);
    
                // Pointer to first element
                let elems = &mut ( *ptr).value as *mut [T] as *mut T;
    
                let mut guard = Guard { mem: NonNull::new_unchecked(mem), elems, layout, n_elems: 0 };
    
                for (i, item) in iter.enumerate() {
                    ptr::write(elems.add(i), item);
                    guard.n_elems += 1;
                }
    
                // All clear. Forget the guard so it doesn't free the new RcBox.
                forget(guard);
    
                Self::from_ptr(ptr)
            }
        }
    *)
    Definition from_iter_exact (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match τ, α with
      | [ impl_Iterator_Item___T_ ], [ iter; len ] =>
        ltac:(M.monadic
          (let iter := M.alloc (| iter |) in
          let len := M.alloc (| len |) in
          M.read (|
            let ptr :=
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "alloc::rc::Rc")
                      [ Ty.apply (Ty.path "slice") [ T ]; Ty.path "alloc::alloc::Global" ],
                    "allocate_for_slice",
                    []
                  |),
                  [ M.read (| len |) ]
                |)
              |) in
            let mem := M.alloc (| M.rust_cast (M.rust_cast (M.read (| ptr |))) |) in
            let layout :=
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.path "core::alloc::layout::Layout",
                    "for_value",
                    [ Ty.apply (Ty.path "alloc::rc::RcBox") [ Ty.apply (Ty.path "slice") [ T ] ] ]
                  |),
                  [ M.read (| ptr |) ]
                |)
              |) in
            let elems :=
              M.alloc (|
                M.rust_cast
                  (M.read (|
                    M.use
                      (M.alloc (|
                        M.SubPointer.get_struct_record_field (|
                          M.read (| ptr |),
                          "alloc::rc::RcBox",
                          "value"
                        |)
                      |))
                  |))
              |) in
            let guard :=
              M.alloc (|
                Value.StructRecord
                  "alloc::rc::from_iter_exact::Guard"
                  [
                    ("mem",
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "core::ptr::non_null::NonNull") [ Ty.path "u8" ],
                          "new_unchecked",
                          []
                        |),
                        [ M.read (| mem |) ]
                      |));
                    ("elems", M.read (| elems |));
                    ("layout", M.read (| layout |));
                    ("n_elems", Value.Integer 0)
                  ]
              |) in
            let _ :=
              M.use
                (M.match_operator (|
                  M.alloc (|
                    M.call_closure (|
                      M.get_trait_method (|
                        "core::iter::traits::collect::IntoIterator",
                        Ty.apply
                          (Ty.path "core::iter::adapters::enumerate::Enumerate")
                          [ impl_Iterator_Item___T_ ],
                        [],
                        "into_iter",
                        []
                      |),
                      [
                        M.call_closure (|
                          M.get_trait_method (|
                            "core::iter::traits::iterator::Iterator",
                            impl_Iterator_Item___T_,
                            [],
                            "enumerate",
                            []
                          |),
                          [ M.read (| iter |) ]
                        |)
                      ]
                    |)
                  |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let iter := M.copy (| γ |) in
                        M.loop (|
                          ltac:(M.monadic
                            (let _ :=
                              M.match_operator (|
                                M.alloc (|
                                  M.call_closure (|
                                    M.get_trait_method (|
                                      "core::iter::traits::iterator::Iterator",
                                      Ty.apply
                                        (Ty.path "core::iter::adapters::enumerate::Enumerate")
                                        [ impl_Iterator_Item___T_ ],
                                      [],
                                      "next",
                                      []
                                    |),
                                    [ iter ]
                                  |)
                                |),
                                [
                                  fun γ =>
                                    ltac:(M.monadic
                                      (M.alloc (|
                                        M.never_to_any (| M.read (| M.break (||) |) |)
                                      |)));
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let γ0_0 :=
                                        M.SubPointer.get_struct_tuple_field (|
                                          γ,
                                          "core::option::Option::Some",
                                          0
                                        |) in
                                      let γ1_0 := M.SubPointer.get_tuple_field (| γ0_0, 0 |) in
                                      let γ1_1 := M.SubPointer.get_tuple_field (| γ0_0, 1 |) in
                                      let i := M.copy (| γ1_0 |) in
                                      let item := M.copy (| γ1_1 |) in
                                      let _ :=
                                        M.alloc (|
                                          M.call_closure (|
                                            M.get_function (| "core::ptr::write", [ T ] |),
                                            [
                                              M.call_closure (|
                                                M.get_associated_function (|
                                                  Ty.apply (Ty.path "*mut") [ T ],
                                                  "add",
                                                  []
                                                |),
                                                [ M.read (| elems |); M.read (| i |) ]
                                              |);
                                              M.read (| item |)
                                            ]
                                          |)
                                        |) in
                                      let _ :=
                                        let β :=
                                          M.SubPointer.get_struct_record_field (|
                                            guard,
                                            "alloc::rc::from_iter_exact::Guard",
                                            "n_elems"
                                          |) in
                                        M.write (|
                                          β,
                                          BinOp.Panic.add (|
                                            Integer.Usize,
                                            M.read (| β |),
                                            Value.Integer 1
                                          |)
                                        |) in
                                      M.alloc (| Value.Tuple [] |)))
                                ]
                              |) in
                            M.alloc (| Value.Tuple [] |)))
                        |)))
                  ]
                |)) in
            let _ :=
              M.alloc (|
                M.call_closure (|
                  M.get_function (|
                    "core::mem::forget",
                    [ Ty.apply (Ty.path "alloc::rc::from_iter_exact::Guard") [ T ] ]
                  |),
                  [ M.read (| guard |) ]
                |)
              |) in
            M.alloc (|
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "alloc::rc::Rc")
                    [ Ty.apply (Ty.path "slice") [ T ]; Ty.path "alloc::alloc::Global" ],
                  "from_ptr",
                  []
                |),
                [ M.read (| ptr |) ]
              |)
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_from_iter_exact :
      forall (T : Ty.t),
      M.IsAssociatedFunction (Self T) "from_iter_exact" (from_iter_exact T).
  End Impl_alloc_rc_Rc_slice_T_alloc_alloc_Global.
  
  Module Impl_alloc_rc_Rc_slice_T_A.
    Definition Self (T A : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "alloc::rc::Rc") [ Ty.apply (Ty.path "slice") [ T ]; A ].
    
    (*
        pub fn new_uninit_slice_in(len: usize, alloc: A) -> Rc<[mem::MaybeUninit<T>], A> {
            unsafe { Rc::from_ptr_in(Rc::allocate_for_slice_in(len, &alloc), alloc) }
        }
    *)
    Definition new_uninit_slice_in (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match τ, α with
      | [], [ len; alloc ] =>
        ltac:(M.monadic
          (let len := M.alloc (| len |) in
          let alloc := M.alloc (| alloc |) in
          M.call_closure (|
            M.get_associated_function (|
              Ty.apply
                (Ty.path "alloc::rc::Rc")
                [
                  Ty.apply
                    (Ty.path "slice")
                    [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ T ] ];
                  A
                ],
              "from_ptr_in",
              []
            |),
            [
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "alloc::rc::Rc")
                    [
                      Ty.apply
                        (Ty.path "slice")
                        [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ T ] ];
                      A
                    ],
                  "allocate_for_slice_in",
                  []
                |),
                [ M.read (| len |); alloc ]
              |);
              M.read (| alloc |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_new_uninit_slice_in :
      forall (T A : Ty.t),
      M.IsAssociatedFunction (Self T A) "new_uninit_slice_in" (new_uninit_slice_in T A).
    
    (*
        pub fn new_zeroed_slice_in(len: usize, alloc: A) -> Rc<[mem::MaybeUninit<T>], A> {
            unsafe {
                Rc::from_ptr_in(
                    Rc::allocate_for_layout(
                        Layout::array::<T>(len).unwrap(),
                        |layout| alloc.allocate_zeroed(layout),
                        |mem| {
                            ptr::slice_from_raw_parts_mut(mem.cast::<T>(), len)
                                as *mut RcBox<[mem::MaybeUninit<T>]>
                        },
                    ),
                    alloc,
                )
            }
        }
    *)
    Definition new_zeroed_slice_in (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match τ, α with
      | [], [ len; alloc ] =>
        ltac:(M.monadic
          (let len := M.alloc (| len |) in
          let alloc := M.alloc (| alloc |) in
          M.call_closure (|
            M.get_associated_function (|
              Ty.apply
                (Ty.path "alloc::rc::Rc")
                [
                  Ty.apply
                    (Ty.path "slice")
                    [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ T ] ];
                  A
                ],
              "from_ptr_in",
              []
            |),
            [
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "alloc::rc::Rc")
                    [
                      Ty.apply
                        (Ty.path "slice")
                        [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ T ] ];
                      Ty.path "alloc::alloc::Global"
                    ],
                  "allocate_for_layout",
                  [
                    Ty.function
                      [ Ty.tuple [ Ty.path "core::alloc::layout::Layout" ] ]
                      (Ty.apply
                        (Ty.path "core::result::Result")
                        [
                          Ty.apply
                            (Ty.path "core::ptr::non_null::NonNull")
                            [ Ty.apply (Ty.path "slice") [ Ty.path "u8" ] ];
                          Ty.path "core::alloc::AllocError"
                        ]);
                    Ty.function
                      [ Ty.tuple [ Ty.apply (Ty.path "*mut") [ Ty.path "u8" ] ] ]
                      (Ty.apply
                        (Ty.path "*mut")
                        [
                          Ty.apply
                            (Ty.path "alloc::rc::RcBox")
                            [
                              Ty.apply
                                (Ty.path "slice")
                                [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ T ] ]
                            ]
                        ])
                  ]
                |),
                [
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "core::result::Result")
                        [
                          Ty.path "core::alloc::layout::Layout";
                          Ty.path "core::alloc::layout::LayoutError"
                        ],
                      "unwrap",
                      []
                    |),
                    [
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::alloc::layout::Layout",
                          "array",
                          [ T ]
                        |),
                        [ M.read (| len |) ]
                      |)
                    ]
                  |);
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0 ] =>
                          M.match_operator (|
                            M.alloc (| α0 |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let layout := M.copy (| γ |) in
                                  M.call_closure (|
                                    M.get_trait_method (|
                                      "core::alloc::Allocator",
                                      A,
                                      [],
                                      "allocate_zeroed",
                                      []
                                    |),
                                    [ alloc; M.read (| layout |) ]
                                  |)))
                            ]
                          |)
                        | _ => M.impossible (||)
                        end));
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0 ] =>
                          M.match_operator (|
                            M.alloc (| α0 |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let mem := M.copy (| γ |) in
                                  M.rust_cast
                                    (M.call_closure (|
                                      M.get_function (|
                                        "core::ptr::slice_from_raw_parts_mut",
                                        [ T ]
                                      |),
                                      [
                                        M.call_closure (|
                                          M.get_associated_function (|
                                            Ty.apply (Ty.path "*mut") [ Ty.path "u8" ],
                                            "cast",
                                            [ T ]
                                          |),
                                          [ M.read (| mem |) ]
                                        |);
                                        M.read (| len |)
                                      ]
                                    |))))
                            ]
                          |)
                        | _ => M.impossible (||)
                        end))
                ]
              |);
              M.read (| alloc |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_new_zeroed_slice_in :
      forall (T A : Ty.t),
      M.IsAssociatedFunction (Self T A) "new_zeroed_slice_in" (new_zeroed_slice_in T A).
    (*
        unsafe fn allocate_for_slice_in(len: usize, alloc: &A) -> *mut RcBox<[T]> {
            unsafe {
                Rc::<[T]>::allocate_for_layout(
                    Layout::array::<T>(len).unwrap(),
                    |layout| alloc.allocate(layout),
                    |mem| ptr::slice_from_raw_parts_mut(mem.cast::<T>(), len) as *mut RcBox<[T]>,
                )
            }
        }
    *)
    Definition allocate_for_slice_in (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match τ, α with
      | [], [ len; alloc ] =>
        ltac:(M.monadic
          (let len := M.alloc (| len |) in
          let alloc := M.alloc (| alloc |) in
          M.call_closure (|
            M.get_associated_function (|
              Ty.apply
                (Ty.path "alloc::rc::Rc")
                [ Ty.apply (Ty.path "slice") [ T ]; Ty.path "alloc::alloc::Global" ],
              "allocate_for_layout",
              [
                Ty.function
                  [ Ty.tuple [ Ty.path "core::alloc::layout::Layout" ] ]
                  (Ty.apply
                    (Ty.path "core::result::Result")
                    [
                      Ty.apply
                        (Ty.path "core::ptr::non_null::NonNull")
                        [ Ty.apply (Ty.path "slice") [ Ty.path "u8" ] ];
                      Ty.path "core::alloc::AllocError"
                    ]);
                Ty.function
                  [ Ty.tuple [ Ty.apply (Ty.path "*mut") [ Ty.path "u8" ] ] ]
                  (Ty.apply
                    (Ty.path "*mut")
                    [ Ty.apply (Ty.path "alloc::rc::RcBox") [ Ty.apply (Ty.path "slice") [ T ] ] ])
              ]
            |),
            [
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "core::result::Result")
                    [
                      Ty.path "core::alloc::layout::Layout";
                      Ty.path "core::alloc::layout::LayoutError"
                    ],
                  "unwrap",
                  []
                |),
                [
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.path "core::alloc::layout::Layout",
                      "array",
                      [ T ]
                    |),
                    [ M.read (| len |) ]
                  |)
                ]
              |);
              M.closure
                (fun γ =>
                  ltac:(M.monadic
                    match γ with
                    | [ α0 ] =>
                      M.match_operator (|
                        M.alloc (| α0 |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let layout := M.copy (| γ |) in
                              M.call_closure (|
                                M.get_trait_method (|
                                  "core::alloc::Allocator",
                                  A,
                                  [],
                                  "allocate",
                                  []
                                |),
                                [ M.read (| alloc |); M.read (| layout |) ]
                              |)))
                        ]
                      |)
                    | _ => M.impossible (||)
                    end));
              M.closure
                (fun γ =>
                  ltac:(M.monadic
                    match γ with
                    | [ α0 ] =>
                      M.match_operator (|
                        M.alloc (| α0 |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let mem := M.copy (| γ |) in
                              M.rust_cast
                                (M.call_closure (|
                                  M.get_function (| "core::ptr::slice_from_raw_parts_mut", [ T ] |),
                                  [
                                    M.call_closure (|
                                      M.get_associated_function (|
                                        Ty.apply (Ty.path "*mut") [ Ty.path "u8" ],
                                        "cast",
                                        [ T ]
                                      |),
                                      [ M.read (| mem |) ]
                                    |);
                                    M.read (| len |)
                                  ]
                                |))))
                        ]
                      |)
                    | _ => M.impossible (||)
                    end))
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_allocate_for_slice_in :
      forall (T A : Ty.t),
      M.IsAssociatedFunction (Self T A) "allocate_for_slice_in" (allocate_for_slice_in T A).
  End Impl_alloc_rc_Rc_slice_T_A.
  
  Module Impl_alloc_rc_Rc_core_mem_maybe_uninit_MaybeUninit_T_A.
    Definition Self (T A : Ty.t) : Ty.t :=
      Ty.apply
        (Ty.path "alloc::rc::Rc")
        [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ T ]; A ].
    
    (*
        pub unsafe fn assume_init(self) -> Rc<T, A>
        where
            A: Clone,
        {
            let md_self = mem::ManuallyDrop::new(self);
            unsafe { Rc::from_inner_in(md_self.ptr.cast(), md_self.alloc.clone()) }
        }
    *)
    Definition assume_init (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            let md_self :=
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "core::mem::manually_drop::ManuallyDrop")
                      [
                        Ty.apply
                          (Ty.path "alloc::rc::Rc")
                          [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ T ]; A ]
                      ],
                    "new",
                    []
                  |),
                  [ M.read (| self |) ]
                |)
              |) in
            M.alloc (|
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply (Ty.path "alloc::rc::Rc") [ T; A ],
                  "from_inner_in",
                  []
                |),
                [
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "core::ptr::non_null::NonNull")
                        [
                          Ty.apply
                            (Ty.path "alloc::rc::RcBox")
                            [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ T ] ]
                        ],
                      "cast",
                      [ Ty.apply (Ty.path "alloc::rc::RcBox") [ T ] ]
                    |),
                    [
                      M.read (|
                        M.SubPointer.get_struct_record_field (|
                          M.call_closure (|
                            M.get_trait_method (|
                              "core::ops::deref::Deref",
                              Ty.apply
                                (Ty.path "core::mem::manually_drop::ManuallyDrop")
                                [
                                  Ty.apply
                                    (Ty.path "alloc::rc::Rc")
                                    [
                                      Ty.apply
                                        (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                        [ T ];
                                      A
                                    ]
                                ],
                              [],
                              "deref",
                              []
                            |),
                            [ md_self ]
                          |),
                          "alloc::rc::Rc",
                          "ptr"
                        |)
                      |)
                    ]
                  |);
                  M.call_closure (|
                    M.get_trait_method (| "core::clone::Clone", A, [], "clone", [] |),
                    [
                      M.SubPointer.get_struct_record_field (|
                        M.call_closure (|
                          M.get_trait_method (|
                            "core::ops::deref::Deref",
                            Ty.apply
                              (Ty.path "core::mem::manually_drop::ManuallyDrop")
                              [
                                Ty.apply
                                  (Ty.path "alloc::rc::Rc")
                                  [
                                    Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ T ];
                                    A
                                  ]
                              ],
                            [],
                            "deref",
                            []
                          |),
                          [ md_self ]
                        |),
                        "alloc::rc::Rc",
                        "alloc"
                      |)
                    ]
                  |)
                ]
              |)
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_assume_init :
      forall (T A : Ty.t),
      M.IsAssociatedFunction (Self T A) "assume_init" (assume_init T A).
  End Impl_alloc_rc_Rc_core_mem_maybe_uninit_MaybeUninit_T_A.
  
  Module Impl_alloc_rc_Rc_slice_core_mem_maybe_uninit_MaybeUninit_T_A.
    Definition Self (T A : Ty.t) : Ty.t :=
      Ty.apply
        (Ty.path "alloc::rc::Rc")
        [
          Ty.apply
            (Ty.path "slice")
            [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ T ] ];
          A
        ].
    
    (*
        pub unsafe fn assume_init(self) -> Rc<[T], A>
        where
            A: Clone,
        {
            let md_self = mem::ManuallyDrop::new(self);
            unsafe { Rc::from_ptr_in(md_self.ptr.as_ptr() as _, md_self.alloc.clone()) }
        }
    *)
    Definition assume_init (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            let md_self :=
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "core::mem::manually_drop::ManuallyDrop")
                      [
                        Ty.apply
                          (Ty.path "alloc::rc::Rc")
                          [
                            Ty.apply
                              (Ty.path "slice")
                              [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ T ] ];
                            A
                          ]
                      ],
                    "new",
                    []
                  |),
                  [ M.read (| self |) ]
                |)
              |) in
            M.alloc (|
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply (Ty.path "alloc::rc::Rc") [ Ty.apply (Ty.path "slice") [ T ]; A ],
                  "from_ptr_in",
                  []
                |),
                [
                  M.rust_cast
                    (M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "core::ptr::non_null::NonNull")
                          [
                            Ty.apply
                              (Ty.path "alloc::rc::RcBox")
                              [
                                Ty.apply
                                  (Ty.path "slice")
                                  [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ T ]
                                  ]
                              ]
                          ],
                        "as_ptr",
                        []
                      |),
                      [
                        M.read (|
                          M.SubPointer.get_struct_record_field (|
                            M.call_closure (|
                              M.get_trait_method (|
                                "core::ops::deref::Deref",
                                Ty.apply
                                  (Ty.path "core::mem::manually_drop::ManuallyDrop")
                                  [
                                    Ty.apply
                                      (Ty.path "alloc::rc::Rc")
                                      [
                                        Ty.apply
                                          (Ty.path "slice")
                                          [
                                            Ty.apply
                                              (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                              [ T ]
                                          ];
                                        A
                                      ]
                                  ],
                                [],
                                "deref",
                                []
                              |),
                              [ md_self ]
                            |),
                            "alloc::rc::Rc",
                            "ptr"
                          |)
                        |)
                      ]
                    |));
                  M.call_closure (|
                    M.get_trait_method (| "core::clone::Clone", A, [], "clone", [] |),
                    [
                      M.SubPointer.get_struct_record_field (|
                        M.call_closure (|
                          M.get_trait_method (|
                            "core::ops::deref::Deref",
                            Ty.apply
                              (Ty.path "core::mem::manually_drop::ManuallyDrop")
                              [
                                Ty.apply
                                  (Ty.path "alloc::rc::Rc")
                                  [
                                    Ty.apply
                                      (Ty.path "slice")
                                      [
                                        Ty.apply
                                          (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                          [ T ]
                                      ];
                                    A
                                  ]
                              ],
                            [],
                            "deref",
                            []
                          |),
                          [ md_self ]
                        |),
                        "alloc::rc::Rc",
                        "alloc"
                      |)
                    ]
                  |)
                ]
              |)
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_assume_init :
      forall (T A : Ty.t),
      M.IsAssociatedFunction (Self T A) "assume_init" (assume_init T A).
  End Impl_alloc_rc_Rc_slice_core_mem_maybe_uninit_MaybeUninit_T_A.
  
  
  
  
  Module Impl_alloc_rc_Rc_Dyn_core_any_Any_Trait_A.
    Definition Self (A : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "alloc::rc::Rc") [ Ty.dyn [ ("core::any::Any::Trait", []) ]; A ].
    
    (*
        pub fn downcast<T: Any>(self) -> Result<Rc<T, A>, Self> {
            if ( *self).is::<T>() {
                unsafe {
                    let ptr = self.ptr.cast::<RcBox<T>>();
                    let alloc = self.alloc.clone();
                    forget(self);
                    Ok(Rc::from_inner_in(ptr, alloc))
                }
            } else {
                Err(self)
            }
        }
    *)
    Definition downcast (A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self A in
      match τ, α with
      | [ T ], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.dyn [ ("core::any::Any::Trait", []) ],
                              "is",
                              [ T ]
                            |),
                            [
                              M.call_closure (|
                                M.get_trait_method (|
                                  "core::ops::deref::Deref",
                                  Ty.apply
                                    (Ty.path "alloc::rc::Rc")
                                    [ Ty.dyn [ ("core::any::Any::Trait", []) ]; A ],
                                  [],
                                  "deref",
                                  []
                                |),
                                [ self ]
                              |)
                            ]
                          |)
                        |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    let ptr :=
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.apply
                              (Ty.path "core::ptr::non_null::NonNull")
                              [
                                Ty.apply
                                  (Ty.path "alloc::rc::RcBox")
                                  [ Ty.dyn [ ("core::any::Any::Trait", []) ] ]
                              ],
                            "cast",
                            [ Ty.apply (Ty.path "alloc::rc::RcBox") [ T ] ]
                          |),
                          [
                            M.read (|
                              M.SubPointer.get_struct_record_field (|
                                self,
                                "alloc::rc::Rc",
                                "ptr"
                              |)
                            |)
                          ]
                        |)
                      |) in
                    let alloc :=
                      M.alloc (|
                        M.call_closure (|
                          M.get_trait_method (| "core::clone::Clone", A, [], "clone", [] |),
                          [
                            M.SubPointer.get_struct_record_field (|
                              self,
                              "alloc::rc::Rc",
                              "alloc"
                            |)
                          ]
                        |)
                      |) in
                    let _ :=
                      M.alloc (|
                        M.call_closure (|
                          M.get_function (|
                            "core::mem::forget",
                            [
                              Ty.apply
                                (Ty.path "alloc::rc::Rc")
                                [ Ty.dyn [ ("core::any::Any::Trait", []) ]; A ]
                            ]
                          |),
                          [ M.read (| self |) ]
                        |)
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply (Ty.path "alloc::rc::Rc") [ T; A ],
                              "from_inner_in",
                              []
                            |),
                            [ M.read (| ptr |); M.read (| alloc |) ]
                          |)
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Err"
                        [ (* Unsize *) M.pointer_coercion (M.read (| self |)) ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_downcast :
      forall (A : Ty.t),
      M.IsAssociatedFunction (Self A) "downcast" (downcast A).
    
    (*
        pub unsafe fn downcast_unchecked<T: Any>(self) -> Rc<T, A> {
            unsafe {
                let ptr = self.ptr.cast::<RcBox<T>>();
                let alloc = self.alloc.clone();
                mem::forget(self);
                Rc::from_inner_in(ptr, alloc)
            }
        }
    *)
    Definition downcast_unchecked (A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self A in
      match τ, α with
      | [ T ], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            let ptr :=
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "core::ptr::non_null::NonNull")
                      [
                        Ty.apply
                          (Ty.path "alloc::rc::RcBox")
                          [ Ty.dyn [ ("core::any::Any::Trait", []) ] ]
                      ],
                    "cast",
                    [ Ty.apply (Ty.path "alloc::rc::RcBox") [ T ] ]
                  |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_record_field (| self, "alloc::rc::Rc", "ptr" |)
                    |)
                  ]
                |)
              |) in
            let alloc :=
              M.alloc (|
                M.call_closure (|
                  M.get_trait_method (| "core::clone::Clone", A, [], "clone", [] |),
                  [ M.SubPointer.get_struct_record_field (| self, "alloc::rc::Rc", "alloc" |) ]
                |)
              |) in
            let _ :=
              M.alloc (|
                M.call_closure (|
                  M.get_function (|
                    "core::mem::forget",
                    [
                      Ty.apply
                        (Ty.path "alloc::rc::Rc")
                        [ Ty.dyn [ ("core::any::Any::Trait", []) ]; A ]
                    ]
                  |),
                  [ M.read (| self |) ]
                |)
              |) in
            M.alloc (|
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply (Ty.path "alloc::rc::Rc") [ T; A ],
                  "from_inner_in",
                  []
                |),
                [ M.read (| ptr |); M.read (| alloc |) ]
              |)
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_downcast_unchecked :
      forall (A : Ty.t),
      M.IsAssociatedFunction (Self A) "downcast_unchecked" (downcast_unchecked A).
  End Impl_alloc_rc_Rc_Dyn_core_any_Any_Trait_A.
  
  
  
  
  
  (* Trait *)
  (* Empty module 'RcFromSlice' *)
  
  Module Impl_alloc_rc_RcFromSlice_where_core_clone_Clone_T_T_for_alloc_rc_Rc_slice_T_alloc_alloc_Global.
    Definition Self (T : Ty.t) : Ty.t :=
      Ty.apply
        (Ty.path "alloc::rc::Rc")
        [ Ty.apply (Ty.path "slice") [ T ]; Ty.path "alloc::alloc::Global" ].
    
    (*
        default fn from_slice(v: &[T]) -> Self {
            unsafe { Self::from_iter_exact(v.iter().cloned(), v.len()) }
        }
    *)
    Definition from_slice (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match τ, α with
      | [], [ v ] =>
        ltac:(M.monadic
          (let v := M.alloc (| v |) in
          M.call_closure (|
            M.get_associated_function (|
              Ty.apply
                (Ty.path "alloc::rc::Rc")
                [ Ty.apply (Ty.path "slice") [ T ]; Ty.path "alloc::alloc::Global" ],
              "from_iter_exact",
              [
                Ty.apply
                  (Ty.path "core::iter::adapters::cloned::Cloned")
                  [ Ty.apply (Ty.path "core::slice::iter::Iter") [ T ] ]
              ]
            |),
            [
              M.call_closure (|
                M.get_trait_method (|
                  "core::iter::traits::iterator::Iterator",
                  Ty.apply (Ty.path "core::slice::iter::Iter") [ T ],
                  [],
                  "cloned",
                  [ T ]
                |),
                [
                  M.call_closure (|
                    M.get_associated_function (| Ty.apply (Ty.path "slice") [ T ], "iter", [] |),
                    [ M.read (| v |) ]
                  |)
                ]
              |);
              M.call_closure (|
                M.get_associated_function (| Ty.apply (Ty.path "slice") [ T ], "len", [] |),
                [ M.read (| v |) ]
              |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "alloc::rc::RcFromSlice"
        (Self T)
        (* Trait polymorphic types *) [ (* T *) T ]
        (* Instance *) [ ("from_slice", InstanceField.Method (from_slice T)) ].
  End Impl_alloc_rc_RcFromSlice_where_core_clone_Clone_T_T_for_alloc_rc_Rc_slice_T_alloc_alloc_Global.
  
  Module Impl_alloc_rc_RcFromSlice_where_core_marker_Copy_T_T_for_alloc_rc_Rc_slice_T_alloc_alloc_Global.
    Definition Self (T : Ty.t) : Ty.t :=
      Ty.apply
        (Ty.path "alloc::rc::Rc")
        [ Ty.apply (Ty.path "slice") [ T ]; Ty.path "alloc::alloc::Global" ].
    
    (*
        fn from_slice(v: &[T]) -> Self {
            unsafe { Rc::copy_from_slice(v) }
        }
    *)
    Definition from_slice (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match τ, α with
      | [], [ v ] =>
        ltac:(M.monadic
          (let v := M.alloc (| v |) in
          M.call_closure (|
            M.get_associated_function (|
              Ty.apply
                (Ty.path "alloc::rc::Rc")
                [ Ty.apply (Ty.path "slice") [ T ]; Ty.path "alloc::alloc::Global" ],
              "copy_from_slice",
              []
            |),
            [ M.read (| v |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "alloc::rc::RcFromSlice"
        (Self T)
        (* Trait polymorphic types *) [ (* T *) T ]
        (* Instance *) [ ("from_slice", InstanceField.Method (from_slice T)) ].
  End Impl_alloc_rc_RcFromSlice_where_core_marker_Copy_T_T_for_alloc_rc_Rc_slice_T_alloc_alloc_Global.
  
  Module Impl_core_ops_deref_Deref_where_core_marker_Sized_T_where_core_alloc_Allocator_A_for_alloc_rc_Rc_T_A.
    Definition Self (T A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::rc::Rc") [ T; A ].
    
    (*     type Target = T; *)
    Definition _Target (T A : Ty.t) : Ty.t := T.
    
    (*
        fn deref(&self) -> &T {
            &self.inner().value
        }
    *)
    Definition deref (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.SubPointer.get_struct_record_field (|
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply (Ty.path "alloc::rc::Rc") [ T; A ],
                "inner",
                []
              |),
              [ M.read (| self |) ]
            |),
            "alloc::rc::RcBox",
            "value"
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (T A : Ty.t),
      M.IsTraitInstance
        "core::ops::deref::Deref"
        (Self T A)
        (* Trait polymorphic types *) []
        (* Instance *)
        [ ("Target", InstanceField.Ty (_Target T A)); ("deref", InstanceField.Method (deref T A)) ].
  End Impl_core_ops_deref_Deref_where_core_marker_Sized_T_where_core_alloc_Allocator_A_for_alloc_rc_Rc_T_A.
  
  Module Impl_core_ops_deref_Receiver_where_core_marker_Sized_T_for_alloc_rc_Rc_T_alloc_alloc_Global.
    Definition Self (T : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "alloc::rc::Rc") [ T; Ty.path "alloc::alloc::Global" ].
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "core::ops::deref::Receiver"
        (Self T)
        (* Trait polymorphic types *) []
        (* Instance *) [].
  End Impl_core_ops_deref_Receiver_where_core_marker_Sized_T_for_alloc_rc_Rc_T_alloc_alloc_Global.
  
  Module Impl_core_ops_drop_Drop_where_core_marker_Sized_T_where_core_alloc_Allocator_A_for_alloc_rc_Rc_T_A.
    Definition Self (T A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::rc::Rc") [ T; A ].
    
    (*
        fn drop(&mut self) {
            unsafe {
                self.inner().dec_strong();
                if self.inner().strong() == 0 {
                    // destroy the contained object
                    ptr::drop_in_place(Self::get_mut_unchecked(self));
    
                    // remove the implicit "strong weak" pointer now that we've
                    // destroyed the contents.
                    self.inner().dec_weak();
    
                    if self.inner().weak() == 0 {
                        self.alloc.deallocate(self.ptr.cast(), Layout::for_value(self.ptr.as_ref()));
                    }
                }
            }
        }
    *)
    Definition drop (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            let _ :=
              M.alloc (|
                M.call_closure (|
                  M.get_trait_method (|
                    "alloc::rc::RcInnerPtr",
                    Ty.apply (Ty.path "alloc::rc::RcBox") [ T ],
                    [],
                    "dec_strong",
                    []
                  |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "alloc::rc::Rc") [ T; A ],
                        "inner",
                        []
                      |),
                      [ M.read (| self |) ]
                    |)
                  ]
                |)
              |) in
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          BinOp.Pure.eq
                            (M.call_closure (|
                              M.get_trait_method (|
                                "alloc::rc::RcInnerPtr",
                                Ty.apply (Ty.path "alloc::rc::RcBox") [ T ],
                                [],
                                "strong",
                                []
                              |),
                              [
                                M.call_closure (|
                                  M.get_associated_function (|
                                    Ty.apply (Ty.path "alloc::rc::Rc") [ T; A ],
                                    "inner",
                                    []
                                  |),
                                  [ M.read (| self |) ]
                                |)
                              ]
                            |))
                            (Value.Integer 0)
                        |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    let _ :=
                      M.alloc (|
                        M.call_closure (|
                          M.get_function (| "core::ptr::drop_in_place", [ T ] |),
                          [
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply (Ty.path "alloc::rc::Rc") [ T; A ],
                                "get_mut_unchecked",
                                []
                              |),
                              [ M.read (| self |) ]
                            |)
                          ]
                        |)
                      |) in
                    let _ :=
                      M.alloc (|
                        M.call_closure (|
                          M.get_trait_method (|
                            "alloc::rc::RcInnerPtr",
                            Ty.apply (Ty.path "alloc::rc::RcBox") [ T ],
                            [],
                            "dec_weak",
                            []
                          |),
                          [
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply (Ty.path "alloc::rc::Rc") [ T; A ],
                                "inner",
                                []
                              |),
                              [ M.read (| self |) ]
                            |)
                          ]
                        |)
                      |) in
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  BinOp.Pure.eq
                                    (M.call_closure (|
                                      M.get_trait_method (|
                                        "alloc::rc::RcInnerPtr",
                                        Ty.apply (Ty.path "alloc::rc::RcBox") [ T ],
                                        [],
                                        "weak",
                                        []
                                      |),
                                      [
                                        M.call_closure (|
                                          M.get_associated_function (|
                                            Ty.apply (Ty.path "alloc::rc::Rc") [ T; A ],
                                            "inner",
                                            []
                                          |),
                                          [ M.read (| self |) ]
                                        |)
                                      ]
                                    |))
                                    (Value.Integer 0)
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            let _ :=
                              M.alloc (|
                                M.call_closure (|
                                  M.get_trait_method (|
                                    "core::alloc::Allocator",
                                    A,
                                    [],
                                    "deallocate",
                                    []
                                  |),
                                  [
                                    M.SubPointer.get_struct_record_field (|
                                      M.read (| self |),
                                      "alloc::rc::Rc",
                                      "alloc"
                                    |);
                                    M.call_closure (|
                                      M.get_associated_function (|
                                        Ty.apply
                                          (Ty.path "core::ptr::non_null::NonNull")
                                          [ Ty.apply (Ty.path "alloc::rc::RcBox") [ T ] ],
                                        "cast",
                                        [ Ty.path "u8" ]
                                      |),
                                      [
                                        M.read (|
                                          M.SubPointer.get_struct_record_field (|
                                            M.read (| self |),
                                            "alloc::rc::Rc",
                                            "ptr"
                                          |)
                                        |)
                                      ]
                                    |);
                                    M.call_closure (|
                                      M.get_associated_function (|
                                        Ty.path "core::alloc::layout::Layout",
                                        "for_value",
                                        [ Ty.apply (Ty.path "alloc::rc::RcBox") [ T ] ]
                                      |),
                                      [
                                        M.call_closure (|
                                          M.get_associated_function (|
                                            Ty.apply
                                              (Ty.path "core::ptr::non_null::NonNull")
                                              [ Ty.apply (Ty.path "alloc::rc::RcBox") [ T ] ],
                                            "as_ref",
                                            []
                                          |),
                                          [
                                            M.SubPointer.get_struct_record_field (|
                                              M.read (| self |),
                                              "alloc::rc::Rc",
                                              "ptr"
                                            |)
                                          ]
                                        |)
                                      ]
                                    |)
                                  ]
                                |)
                              |) in
                            M.alloc (| Value.Tuple [] |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                      ]
                    |)));
                fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (T A : Ty.t),
      M.IsTraitInstance
        "core::ops::drop::Drop"
        (Self T A)
        (* Trait polymorphic types *) []
        (* Instance *) [ ("drop", InstanceField.Method (drop T A)) ].
  End Impl_core_ops_drop_Drop_where_core_marker_Sized_T_where_core_alloc_Allocator_A_for_alloc_rc_Rc_T_A.
  
  Module Impl_core_clone_Clone_where_core_marker_Sized_T_where_core_alloc_Allocator_A_where_core_clone_Clone_A_for_alloc_rc_Rc_T_A.
    Definition Self (T A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::rc::Rc") [ T; A ].
    
    (*
        fn clone(&self) -> Self {
            unsafe {
                self.inner().inc_strong();
                Self::from_inner_in(self.ptr, self.alloc.clone())
            }
        }
    *)
    Definition clone (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            let _ :=
              M.alloc (|
                M.call_closure (|
                  M.get_trait_method (|
                    "alloc::rc::RcInnerPtr",
                    Ty.apply (Ty.path "alloc::rc::RcBox") [ T ],
                    [],
                    "inc_strong",
                    []
                  |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "alloc::rc::Rc") [ T; A ],
                        "inner",
                        []
                      |),
                      [ M.read (| self |) ]
                    |)
                  ]
                |)
              |) in
            M.alloc (|
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply (Ty.path "alloc::rc::Rc") [ T; A ],
                  "from_inner_in",
                  []
                |),
                [
                  M.read (|
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "alloc::rc::Rc",
                      "ptr"
                    |)
                  |);
                  M.call_closure (|
                    M.get_trait_method (| "core::clone::Clone", A, [], "clone", [] |),
                    [
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "alloc::rc::Rc",
                        "alloc"
                      |)
                    ]
                  |)
                ]
              |)
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (T A : Ty.t),
      M.IsTraitInstance
        "core::clone::Clone"
        (Self T A)
        (* Trait polymorphic types *) []
        (* Instance *) [ ("clone", InstanceField.Method (clone T A)) ].
  End Impl_core_clone_Clone_where_core_marker_Sized_T_where_core_alloc_Allocator_A_where_core_clone_Clone_A_for_alloc_rc_Rc_T_A.
  
  Module Impl_core_default_Default_where_core_default_Default_T_for_alloc_rc_Rc_T_alloc_alloc_Global.
    Definition Self (T : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "alloc::rc::Rc") [ T; Ty.path "alloc::alloc::Global" ].
    
    (*
        fn default() -> Rc<T> {
            Rc::new(Default::default())
        }
    *)
    Definition default (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match τ, α with
      | [], [] =>
        ltac:(M.monadic
          (M.call_closure (|
            M.get_associated_function (|
              Ty.apply (Ty.path "alloc::rc::Rc") [ T; Ty.path "alloc::alloc::Global" ],
              "new",
              []
            |),
            [
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "core::default::Default"
        (Self T)
        (* Trait polymorphic types *) []
        (* Instance *) [ ("default", InstanceField.Method (default T)) ].
  End Impl_core_default_Default_where_core_default_Default_T_for_alloc_rc_Rc_T_alloc_alloc_Global.
  
  (* Trait *)
  (* Empty module 'RcEqIdent' *)
  
  Module Impl_alloc_rc_RcEqIdent_where_core_marker_Sized_T_where_core_cmp_PartialEq_T_where_core_alloc_Allocator_A_T_A_for_alloc_rc_Rc_T_A.
    Definition Self (T A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::rc::Rc") [ T; A ].
    
    (*
        default fn eq(&self, other: &Rc<T, A>) -> bool {
            **self == **other
        }
    *)
    Definition eq (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match τ, α with
      | [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            M.get_trait_method (| "core::cmp::PartialEq", T, [ T ], "eq", [] |),
            [
              M.call_closure (|
                M.get_trait_method (|
                  "core::ops::deref::Deref",
                  Ty.apply (Ty.path "alloc::rc::Rc") [ T; A ],
                  [],
                  "deref",
                  []
                |),
                [ M.read (| self |) ]
              |);
              M.call_closure (|
                M.get_trait_method (|
                  "core::ops::deref::Deref",
                  Ty.apply (Ty.path "alloc::rc::Rc") [ T; A ],
                  [],
                  "deref",
                  []
                |),
                [ M.read (| other |) ]
              |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    (*
        default fn ne(&self, other: &Rc<T, A>) -> bool {
            **self != **other
        }
    *)
    Definition ne (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match τ, α with
      | [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            M.get_trait_method (| "core::cmp::PartialEq", T, [ T ], "ne", [] |),
            [
              M.call_closure (|
                M.get_trait_method (|
                  "core::ops::deref::Deref",
                  Ty.apply (Ty.path "alloc::rc::Rc") [ T; A ],
                  [],
                  "deref",
                  []
                |),
                [ M.read (| self |) ]
              |);
              M.call_closure (|
                M.get_trait_method (|
                  "core::ops::deref::Deref",
                  Ty.apply (Ty.path "alloc::rc::Rc") [ T; A ],
                  [],
                  "deref",
                  []
                |),
                [ M.read (| other |) ]
              |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (T A : Ty.t),
      M.IsTraitInstance
        "alloc::rc::RcEqIdent"
        (Self T A)
        (* Trait polymorphic types *) [ (* T *) T; (* A *) A ]
        (* Instance *)
        [ ("eq", InstanceField.Method (eq T A)); ("ne", InstanceField.Method (ne T A)) ].
  End Impl_alloc_rc_RcEqIdent_where_core_marker_Sized_T_where_core_cmp_PartialEq_T_where_core_alloc_Allocator_A_T_A_for_alloc_rc_Rc_T_A.
  
  (* Trait *)
  (* Empty module 'MarkerEq' *)
  
  Module Impl_alloc_rc_MarkerEq_where_core_cmp_Eq_T_for_T.
    Definition Self (T : Ty.t) : Ty.t := T.
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "alloc::rc::MarkerEq"
        (Self T)
        (* Trait polymorphic types *) []
        (* Instance *) [].
  End Impl_alloc_rc_MarkerEq_where_core_cmp_Eq_T_for_T.
  
  Module Impl_alloc_rc_RcEqIdent_where_core_marker_Sized_T_where_alloc_rc_MarkerEq_T_where_core_alloc_Allocator_A_T_A_for_alloc_rc_Rc_T_A.
    Definition Self (T A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::rc::Rc") [ T; A ].
    
    (*
        fn eq(&self, other: &Rc<T, A>) -> bool {
            Rc::ptr_eq(self, other) || **self == **other
        }
    *)
    Definition eq (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match τ, α with
      | [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          LogicalOp.or (|
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply (Ty.path "alloc::rc::Rc") [ T; A ],
                "ptr_eq",
                []
              |),
              [ M.read (| self |); M.read (| other |) ]
            |),
            ltac:(M.monadic
              (M.call_closure (|
                M.get_trait_method (| "core::cmp::PartialEq", T, [ T ], "eq", [] |),
                [
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::deref::Deref",
                      Ty.apply (Ty.path "alloc::rc::Rc") [ T; A ],
                      [],
                      "deref",
                      []
                    |),
                    [ M.read (| self |) ]
                  |);
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::deref::Deref",
                      Ty.apply (Ty.path "alloc::rc::Rc") [ T; A ],
                      [],
                      "deref",
                      []
                    |),
                    [ M.read (| other |) ]
                  |)
                ]
              |)))
          |)))
      | _, _ => M.impossible
      end.
    
    (*
        fn ne(&self, other: &Rc<T, A>) -> bool {
            !Rc::ptr_eq(self, other) && **self != **other
        }
    *)
    Definition ne (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match τ, α with
      | [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          LogicalOp.and (|
            UnOp.Pure.not
              (M.call_closure (|
                M.get_associated_function (|
                  Ty.apply (Ty.path "alloc::rc::Rc") [ T; A ],
                  "ptr_eq",
                  []
                |),
                [ M.read (| self |); M.read (| other |) ]
              |)),
            ltac:(M.monadic
              (M.call_closure (|
                M.get_trait_method (| "core::cmp::PartialEq", T, [ T ], "ne", [] |),
                [
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::deref::Deref",
                      Ty.apply (Ty.path "alloc::rc::Rc") [ T; A ],
                      [],
                      "deref",
                      []
                    |),
                    [ M.read (| self |) ]
                  |);
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::deref::Deref",
                      Ty.apply (Ty.path "alloc::rc::Rc") [ T; A ],
                      [],
                      "deref",
                      []
                    |),
                    [ M.read (| other |) ]
                  |)
                ]
              |)))
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (T A : Ty.t),
      M.IsTraitInstance
        "alloc::rc::RcEqIdent"
        (Self T A)
        (* Trait polymorphic types *) [ (* T *) T; (* A *) A ]
        (* Instance *)
        [ ("eq", InstanceField.Method (eq T A)); ("ne", InstanceField.Method (ne T A)) ].
  End Impl_alloc_rc_RcEqIdent_where_core_marker_Sized_T_where_alloc_rc_MarkerEq_T_where_core_alloc_Allocator_A_T_A_for_alloc_rc_Rc_T_A.
  
  Module Impl_core_cmp_PartialEq_where_core_marker_Sized_T_where_core_cmp_PartialEq_T_where_core_alloc_Allocator_A_for_alloc_rc_Rc_T_A.
    Definition Self (T A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::rc::Rc") [ T; A ].
    
    (*
        fn eq(&self, other: &Rc<T, A>) -> bool {
            RcEqIdent::eq(self, other)
        }
    *)
    Definition eq (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match τ, α with
      | [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            M.get_trait_method (|
              "alloc::rc::RcEqIdent",
              Ty.apply (Ty.path "alloc::rc::Rc") [ T; A ],
              [ T; A ],
              "eq",
              []
            |),
            [ M.read (| self |); M.read (| other |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    (*
        fn ne(&self, other: &Rc<T, A>) -> bool {
            RcEqIdent::ne(self, other)
        }
    *)
    Definition ne (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match τ, α with
      | [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            M.get_trait_method (|
              "alloc::rc::RcEqIdent",
              Ty.apply (Ty.path "alloc::rc::Rc") [ T; A ],
              [ T; A ],
              "ne",
              []
            |),
            [ M.read (| self |); M.read (| other |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (T A : Ty.t),
      M.IsTraitInstance
        "core::cmp::PartialEq"
        (Self T A)
        (* Trait polymorphic types *) []
        (* Instance *)
        [ ("eq", InstanceField.Method (eq T A)); ("ne", InstanceField.Method (ne T A)) ].
  End Impl_core_cmp_PartialEq_where_core_marker_Sized_T_where_core_cmp_PartialEq_T_where_core_alloc_Allocator_A_for_alloc_rc_Rc_T_A.
  
  Module Impl_core_cmp_Eq_where_core_marker_Sized_T_where_core_cmp_Eq_T_where_core_alloc_Allocator_A_for_alloc_rc_Rc_T_A.
    Definition Self (T A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::rc::Rc") [ T; A ].
    
    Axiom Implements :
      forall (T A : Ty.t),
      M.IsTraitInstance
        "core::cmp::Eq"
        (Self T A)
        (* Trait polymorphic types *) []
        (* Instance *) [].
  End Impl_core_cmp_Eq_where_core_marker_Sized_T_where_core_cmp_Eq_T_where_core_alloc_Allocator_A_for_alloc_rc_Rc_T_A.
  
  Module Impl_core_cmp_PartialOrd_where_core_marker_Sized_T_where_core_cmp_PartialOrd_T_where_core_alloc_Allocator_A_for_alloc_rc_Rc_T_A.
    Definition Self (T A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::rc::Rc") [ T; A ].
    
    (*
        fn partial_cmp(&self, other: &Rc<T, A>) -> Option<Ordering> {
            ( **self).partial_cmp(&**other)
        }
    *)
    Definition partial_cmp (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match τ, α with
      | [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            M.get_trait_method (| "core::cmp::PartialOrd", T, [ T ], "partial_cmp", [] |),
            [
              M.call_closure (|
                M.get_trait_method (|
                  "core::ops::deref::Deref",
                  Ty.apply (Ty.path "alloc::rc::Rc") [ T; A ],
                  [],
                  "deref",
                  []
                |),
                [ M.read (| self |) ]
              |);
              M.call_closure (|
                M.get_trait_method (|
                  "core::ops::deref::Deref",
                  Ty.apply (Ty.path "alloc::rc::Rc") [ T; A ],
                  [],
                  "deref",
                  []
                |),
                [ M.read (| other |) ]
              |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    (*
        fn lt(&self, other: &Rc<T, A>) -> bool {
            **self < **other
        }
    *)
    Definition lt (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match τ, α with
      | [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            M.get_trait_method (| "core::cmp::PartialOrd", T, [ T ], "lt", [] |),
            [
              M.call_closure (|
                M.get_trait_method (|
                  "core::ops::deref::Deref",
                  Ty.apply (Ty.path "alloc::rc::Rc") [ T; A ],
                  [],
                  "deref",
                  []
                |),
                [ M.read (| self |) ]
              |);
              M.call_closure (|
                M.get_trait_method (|
                  "core::ops::deref::Deref",
                  Ty.apply (Ty.path "alloc::rc::Rc") [ T; A ],
                  [],
                  "deref",
                  []
                |),
                [ M.read (| other |) ]
              |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    (*
        fn le(&self, other: &Rc<T, A>) -> bool {
            **self <= **other
        }
    *)
    Definition le (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match τ, α with
      | [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            M.get_trait_method (| "core::cmp::PartialOrd", T, [ T ], "le", [] |),
            [
              M.call_closure (|
                M.get_trait_method (|
                  "core::ops::deref::Deref",
                  Ty.apply (Ty.path "alloc::rc::Rc") [ T; A ],
                  [],
                  "deref",
                  []
                |),
                [ M.read (| self |) ]
              |);
              M.call_closure (|
                M.get_trait_method (|
                  "core::ops::deref::Deref",
                  Ty.apply (Ty.path "alloc::rc::Rc") [ T; A ],
                  [],
                  "deref",
                  []
                |),
                [ M.read (| other |) ]
              |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    (*
        fn gt(&self, other: &Rc<T, A>) -> bool {
            **self > **other
        }
    *)
    Definition gt (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match τ, α with
      | [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            M.get_trait_method (| "core::cmp::PartialOrd", T, [ T ], "gt", [] |),
            [
              M.call_closure (|
                M.get_trait_method (|
                  "core::ops::deref::Deref",
                  Ty.apply (Ty.path "alloc::rc::Rc") [ T; A ],
                  [],
                  "deref",
                  []
                |),
                [ M.read (| self |) ]
              |);
              M.call_closure (|
                M.get_trait_method (|
                  "core::ops::deref::Deref",
                  Ty.apply (Ty.path "alloc::rc::Rc") [ T; A ],
                  [],
                  "deref",
                  []
                |),
                [ M.read (| other |) ]
              |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    (*
        fn ge(&self, other: &Rc<T, A>) -> bool {
            **self >= **other
        }
    *)
    Definition ge (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match τ, α with
      | [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            M.get_trait_method (| "core::cmp::PartialOrd", T, [ T ], "ge", [] |),
            [
              M.call_closure (|
                M.get_trait_method (|
                  "core::ops::deref::Deref",
                  Ty.apply (Ty.path "alloc::rc::Rc") [ T; A ],
                  [],
                  "deref",
                  []
                |),
                [ M.read (| self |) ]
              |);
              M.call_closure (|
                M.get_trait_method (|
                  "core::ops::deref::Deref",
                  Ty.apply (Ty.path "alloc::rc::Rc") [ T; A ],
                  [],
                  "deref",
                  []
                |),
                [ M.read (| other |) ]
              |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (T A : Ty.t),
      M.IsTraitInstance
        "core::cmp::PartialOrd"
        (Self T A)
        (* Trait polymorphic types *) []
        (* Instance *)
        [
          ("partial_cmp", InstanceField.Method (partial_cmp T A));
          ("lt", InstanceField.Method (lt T A));
          ("le", InstanceField.Method (le T A));
          ("gt", InstanceField.Method (gt T A));
          ("ge", InstanceField.Method (ge T A))
        ].
  End Impl_core_cmp_PartialOrd_where_core_marker_Sized_T_where_core_cmp_PartialOrd_T_where_core_alloc_Allocator_A_for_alloc_rc_Rc_T_A.
  
  Module Impl_core_cmp_Ord_where_core_marker_Sized_T_where_core_cmp_Ord_T_where_core_alloc_Allocator_A_for_alloc_rc_Rc_T_A.
    Definition Self (T A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::rc::Rc") [ T; A ].
    
    (*
        fn cmp(&self, other: &Rc<T, A>) -> Ordering {
            ( **self).cmp(&**other)
        }
    *)
    Definition cmp (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match τ, α with
      | [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            M.get_trait_method (| "core::cmp::Ord", T, [], "cmp", [] |),
            [
              M.call_closure (|
                M.get_trait_method (|
                  "core::ops::deref::Deref",
                  Ty.apply (Ty.path "alloc::rc::Rc") [ T; A ],
                  [],
                  "deref",
                  []
                |),
                [ M.read (| self |) ]
              |);
              M.call_closure (|
                M.get_trait_method (|
                  "core::ops::deref::Deref",
                  Ty.apply (Ty.path "alloc::rc::Rc") [ T; A ],
                  [],
                  "deref",
                  []
                |),
                [ M.read (| other |) ]
              |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (T A : Ty.t),
      M.IsTraitInstance
        "core::cmp::Ord"
        (Self T A)
        (* Trait polymorphic types *) []
        (* Instance *) [ ("cmp", InstanceField.Method (cmp T A)) ].
  End Impl_core_cmp_Ord_where_core_marker_Sized_T_where_core_cmp_Ord_T_where_core_alloc_Allocator_A_for_alloc_rc_Rc_T_A.
  
  Module Impl_core_hash_Hash_where_core_marker_Sized_T_where_core_hash_Hash_T_where_core_alloc_Allocator_A_for_alloc_rc_Rc_T_A.
    Definition Self (T A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::rc::Rc") [ T; A ].
    
    (*
        fn hash<H: Hasher>(&self, state: &mut H) {
            ( **self).hash(state);
        }
    *)
    Definition hash (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match τ, α with
      | [ H ], [ self; state ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let state := M.alloc (| state |) in
          M.read (|
            let _ :=
              M.alloc (|
                M.call_closure (|
                  M.get_trait_method (| "core::hash::Hash", T, [], "hash", [ H ] |),
                  [
                    M.call_closure (|
                      M.get_trait_method (|
                        "core::ops::deref::Deref",
                        Ty.apply (Ty.path "alloc::rc::Rc") [ T; A ],
                        [],
                        "deref",
                        []
                      |),
                      [ M.read (| self |) ]
                    |);
                    M.read (| state |)
                  ]
                |)
              |) in
            M.alloc (| Value.Tuple [] |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (T A : Ty.t),
      M.IsTraitInstance
        "core::hash::Hash"
        (Self T A)
        (* Trait polymorphic types *) []
        (* Instance *) [ ("hash", InstanceField.Method (hash T A)) ].
  End Impl_core_hash_Hash_where_core_marker_Sized_T_where_core_hash_Hash_T_where_core_alloc_Allocator_A_for_alloc_rc_Rc_T_A.
  
  Module Impl_core_fmt_Display_where_core_marker_Sized_T_where_core_fmt_Display_T_where_core_alloc_Allocator_A_for_alloc_rc_Rc_T_A.
    Definition Self (T A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::rc::Rc") [ T; A ].
    
    (*
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            fmt::Display::fmt(&**self, f)
        }
    *)
    Definition fmt (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match τ, α with
      | [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.call_closure (|
            M.get_trait_method (| "core::fmt::Display", T, [], "fmt", [] |),
            [
              M.call_closure (|
                M.get_trait_method (|
                  "core::ops::deref::Deref",
                  Ty.apply (Ty.path "alloc::rc::Rc") [ T; A ],
                  [],
                  "deref",
                  []
                |),
                [ M.read (| self |) ]
              |);
              M.read (| f |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (T A : Ty.t),
      M.IsTraitInstance
        "core::fmt::Display"
        (Self T A)
        (* Trait polymorphic types *) []
        (* Instance *) [ ("fmt", InstanceField.Method (fmt T A)) ].
  End Impl_core_fmt_Display_where_core_marker_Sized_T_where_core_fmt_Display_T_where_core_alloc_Allocator_A_for_alloc_rc_Rc_T_A.
  
  Module Impl_core_fmt_Debug_where_core_marker_Sized_T_where_core_fmt_Debug_T_where_core_alloc_Allocator_A_for_alloc_rc_Rc_T_A.
    Definition Self (T A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::rc::Rc") [ T; A ].
    
    (*
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            fmt::Debug::fmt(&**self, f)
        }
    *)
    Definition fmt (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match τ, α with
      | [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.call_closure (|
            M.get_trait_method (| "core::fmt::Debug", T, [], "fmt", [] |),
            [
              M.call_closure (|
                M.get_trait_method (|
                  "core::ops::deref::Deref",
                  Ty.apply (Ty.path "alloc::rc::Rc") [ T; A ],
                  [],
                  "deref",
                  []
                |),
                [ M.read (| self |) ]
              |);
              M.read (| f |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (T A : Ty.t),
      M.IsTraitInstance
        "core::fmt::Debug"
        (Self T A)
        (* Trait polymorphic types *) []
        (* Instance *) [ ("fmt", InstanceField.Method (fmt T A)) ].
  End Impl_core_fmt_Debug_where_core_marker_Sized_T_where_core_fmt_Debug_T_where_core_alloc_Allocator_A_for_alloc_rc_Rc_T_A.
  
  Module Impl_core_fmt_Pointer_where_core_marker_Sized_T_where_core_alloc_Allocator_A_for_alloc_rc_Rc_T_A.
    Definition Self (T A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::rc::Rc") [ T; A ].
    
    (*
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            fmt::Pointer::fmt(&(&**self as *const T), f)
        }
    *)
    Definition fmt (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match τ, α with
      | [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.call_closure (|
            M.get_trait_method (|
              "core::fmt::Pointer",
              Ty.apply (Ty.path "*const") [ T ],
              [],
              "fmt",
              []
            |),
            [
              M.use
                (M.alloc (|
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::deref::Deref",
                      Ty.apply (Ty.path "alloc::rc::Rc") [ T; A ],
                      [],
                      "deref",
                      []
                    |),
                    [ M.read (| self |) ]
                  |)
                |));
              M.read (| f |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (T A : Ty.t),
      M.IsTraitInstance
        "core::fmt::Pointer"
        (Self T A)
        (* Trait polymorphic types *) []
        (* Instance *) [ ("fmt", InstanceField.Method (fmt T A)) ].
  End Impl_core_fmt_Pointer_where_core_marker_Sized_T_where_core_alloc_Allocator_A_for_alloc_rc_Rc_T_A.
  
  Module Impl_core_convert_From_T_for_alloc_rc_Rc_T_alloc_alloc_Global.
    Definition Self (T : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "alloc::rc::Rc") [ T; Ty.path "alloc::alloc::Global" ].
    
    (*
        fn from(t: T) -> Self {
            Rc::new(t)
        }
    *)
    Definition from (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match τ, α with
      | [], [ t ] =>
        ltac:(M.monadic
          (let t := M.alloc (| t |) in
          M.call_closure (|
            M.get_associated_function (|
              Ty.apply (Ty.path "alloc::rc::Rc") [ T; Ty.path "alloc::alloc::Global" ],
              "new",
              []
            |),
            [ M.read (| t |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "core::convert::From"
        (Self T)
        (* Trait polymorphic types *) [ (* T *) T ]
        (* Instance *) [ ("from", InstanceField.Method (from T)) ].
  End Impl_core_convert_From_T_for_alloc_rc_Rc_T_alloc_alloc_Global.
  
  Module Impl_core_convert_From_array_T_for_alloc_rc_Rc_slice_T_alloc_alloc_Global.
    Definition Self (T : Ty.t) : Ty.t :=
      Ty.apply
        (Ty.path "alloc::rc::Rc")
        [ Ty.apply (Ty.path "slice") [ T ]; Ty.path "alloc::alloc::Global" ].
    
    (*
        fn from(v: [T; N]) -> Rc<[T]> {
            Rc::<[T; N]>::from(v)
        }
    *)
    Definition from (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match τ, α with
      | [], [ v ] =>
        ltac:(M.monadic
          (let v := M.alloc (| v |) in
          (* Unsize *)
          M.pointer_coercion
            (M.call_closure (|
              M.get_trait_method (|
                "core::convert::From",
                Ty.apply
                  (Ty.path "alloc::rc::Rc")
                  [ Ty.apply (Ty.path "array") [ T ]; Ty.path "alloc::alloc::Global" ],
                [ Ty.apply (Ty.path "array") [ T ] ],
                "from",
                []
              |),
              [ M.read (| v |) ]
            |))))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "core::convert::From"
        (Self T)
        (* Trait polymorphic types *) [ (* T *) Ty.apply (Ty.path "array") [ T ] ]
        (* Instance *) [ ("from", InstanceField.Method (from T)) ].
  End Impl_core_convert_From_array_T_for_alloc_rc_Rc_slice_T_alloc_alloc_Global.
  
  Module Impl_core_convert_From_where_core_clone_Clone_T_ref__slice_T_for_alloc_rc_Rc_slice_T_alloc_alloc_Global.
    Definition Self (T : Ty.t) : Ty.t :=
      Ty.apply
        (Ty.path "alloc::rc::Rc")
        [ Ty.apply (Ty.path "slice") [ T ]; Ty.path "alloc::alloc::Global" ].
    
    (*
        fn from(v: &[T]) -> Rc<[T]> {
            <Self as RcFromSlice<T>>::from_slice(v)
        }
    *)
    Definition from (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match τ, α with
      | [], [ v ] =>
        ltac:(M.monadic
          (let v := M.alloc (| v |) in
          M.call_closure (|
            M.get_trait_method (|
              "alloc::rc::RcFromSlice",
              Ty.apply
                (Ty.path "alloc::rc::Rc")
                [ Ty.apply (Ty.path "slice") [ T ]; Ty.path "alloc::alloc::Global" ],
              [ T ],
              "from_slice",
              []
            |),
            [ M.read (| v |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "core::convert::From"
        (Self T)
        (* Trait polymorphic types *)
        [ (* T *) Ty.apply (Ty.path "&") [ Ty.apply (Ty.path "slice") [ T ] ] ]
        (* Instance *) [ ("from", InstanceField.Method (from T)) ].
  End Impl_core_convert_From_where_core_clone_Clone_T_ref__slice_T_for_alloc_rc_Rc_slice_T_alloc_alloc_Global.
  
  Module Impl_core_convert_From_ref__str_for_alloc_rc_Rc_str_alloc_alloc_Global.
    Definition Self : Ty.t :=
      Ty.apply (Ty.path "alloc::rc::Rc") [ Ty.path "str"; Ty.path "alloc::alloc::Global" ].
    
    (*
        fn from(v: &str) -> Rc<str> {
            let rc = Rc::<[u8]>::from(v.as_bytes());
            unsafe { Rc::from_raw(Rc::into_raw(rc) as *const str) }
        }
    *)
    Definition from (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ v ] =>
        ltac:(M.monadic
          (let v := M.alloc (| v |) in
          M.read (|
            let rc :=
              M.alloc (|
                M.call_closure (|
                  M.get_trait_method (|
                    "core::convert::From",
                    Ty.apply
                      (Ty.path "alloc::rc::Rc")
                      [ Ty.apply (Ty.path "slice") [ Ty.path "u8" ]; Ty.path "alloc::alloc::Global"
                      ],
                    [ Ty.apply (Ty.path "&") [ Ty.apply (Ty.path "slice") [ Ty.path "u8" ] ] ],
                    "from",
                    []
                  |),
                  [
                    M.call_closure (|
                      M.get_associated_function (| Ty.path "str", "as_bytes", [] |),
                      [ M.read (| v |) ]
                    |)
                  ]
                |)
              |) in
            M.alloc (|
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "alloc::rc::Rc")
                    [ Ty.path "str"; Ty.path "alloc::alloc::Global" ],
                  "from_raw",
                  []
                |),
                [
                  M.rust_cast
                    (M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "alloc::rc::Rc")
                          [
                            Ty.apply (Ty.path "slice") [ Ty.path "u8" ];
                            Ty.path "alloc::alloc::Global"
                          ],
                        "into_raw",
                        []
                      |),
                      [ M.read (| rc |) ]
                    |))
                ]
              |)
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::convert::From"
        Self
        (* Trait polymorphic types *) [ (* T *) Ty.apply (Ty.path "&") [ Ty.path "str" ] ]
        (* Instance *) [ ("from", InstanceField.Method from) ].
  End Impl_core_convert_From_ref__str_for_alloc_rc_Rc_str_alloc_alloc_Global.
  
  Module Impl_core_convert_From_alloc_string_String_for_alloc_rc_Rc_str_alloc_alloc_Global.
    Definition Self : Ty.t :=
      Ty.apply (Ty.path "alloc::rc::Rc") [ Ty.path "str"; Ty.path "alloc::alloc::Global" ].
    
    (*
        fn from(v: String) -> Rc<str> {
            Rc::from(&v[..])
        }
    *)
    Definition from (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ v ] =>
        ltac:(M.monadic
          (let v := M.alloc (| v |) in
          M.call_closure (|
            M.get_trait_method (|
              "core::convert::From",
              Ty.apply (Ty.path "alloc::rc::Rc") [ Ty.path "str"; Ty.path "alloc::alloc::Global" ],
              [ Ty.apply (Ty.path "&") [ Ty.path "str" ] ],
              "from",
              []
            |),
            [
              M.call_closure (|
                M.get_trait_method (|
                  "core::ops::index::Index",
                  Ty.path "alloc::string::String",
                  [ Ty.path "core::ops::range::RangeFull" ],
                  "index",
                  []
                |),
                [ v; Value.StructTuple "core::ops::range::RangeFull" [] ]
              |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::convert::From"
        Self
        (* Trait polymorphic types *) [ (* T *) Ty.path "alloc::string::String" ]
        (* Instance *) [ ("from", InstanceField.Method from) ].
  End Impl_core_convert_From_alloc_string_String_for_alloc_rc_Rc_str_alloc_alloc_Global.
  
  Module Impl_core_convert_From_where_core_marker_Sized_T_where_core_alloc_Allocator_A_alloc_boxed_Box_T_A_for_alloc_rc_Rc_T_A.
    Definition Self (T A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::rc::Rc") [ T; A ].
    
    (*
        fn from(v: Box<T, A>) -> Rc<T, A> {
            Rc::from_box_in(v)
        }
    *)
    Definition from (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match τ, α with
      | [], [ v ] =>
        ltac:(M.monadic
          (let v := M.alloc (| v |) in
          M.call_closure (|
            M.get_associated_function (|
              Ty.apply (Ty.path "alloc::rc::Rc") [ T; A ],
              "from_box_in",
              []
            |),
            [ M.read (| v |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (T A : Ty.t),
      M.IsTraitInstance
        "core::convert::From"
        (Self T A)
        (* Trait polymorphic types *) [ (* T *) Ty.apply (Ty.path "alloc::boxed::Box") [ T; A ] ]
        (* Instance *) [ ("from", InstanceField.Method (from T A)) ].
  End Impl_core_convert_From_where_core_marker_Sized_T_where_core_alloc_Allocator_A_alloc_boxed_Box_T_A_for_alloc_rc_Rc_T_A.
  
  Module Impl_core_convert_From_where_core_alloc_Allocator_A_alloc_vec_Vec_T_A_for_alloc_rc_Rc_slice_T_A.
    Definition Self (T A : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "alloc::rc::Rc") [ Ty.apply (Ty.path "slice") [ T ]; A ].
    
    (*
        fn from(v: Vec<T, A>) -> Rc<[T], A> {
            unsafe {
                let (vec_ptr, len, cap, alloc) = v.into_raw_parts_with_alloc();
    
                let rc_ptr = Self::allocate_for_slice_in(len, &alloc);
                ptr::copy_nonoverlapping(vec_ptr, &mut ( *rc_ptr).value as *mut [T] as *mut T, len);
    
                // Create a `Vec<T, &A>` with length 0, to deallocate the buffer
                // without dropping its contents or the allocator
                let _ = Vec::from_raw_parts_in(vec_ptr, 0, cap, &alloc);
    
                Self::from_ptr_in(rc_ptr, alloc)
            }
        }
    *)
    Definition from (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match τ, α with
      | [], [ v ] =>
        ltac:(M.monadic
          (let v := M.alloc (| v |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "alloc::vec::Vec") [ T; A ],
                    "into_raw_parts_with_alloc",
                    []
                  |),
                  [ M.read (| v |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let γ0_2 := M.SubPointer.get_tuple_field (| γ, 2 |) in
                    let γ0_3 := M.SubPointer.get_tuple_field (| γ, 3 |) in
                    let vec_ptr := M.copy (| γ0_0 |) in
                    let len := M.copy (| γ0_1 |) in
                    let cap := M.copy (| γ0_2 |) in
                    let alloc := M.copy (| γ0_3 |) in
                    let rc_ptr :=
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.apply
                              (Ty.path "alloc::rc::Rc")
                              [ Ty.apply (Ty.path "slice") [ T ]; A ],
                            "allocate_for_slice_in",
                            []
                          |),
                          [ M.read (| len |); alloc ]
                        |)
                      |) in
                    let _ :=
                      M.alloc (|
                        M.call_closure (|
                          M.get_function (| "core::intrinsics::copy_nonoverlapping", [ T ] |),
                          [
                            (* MutToConstPointer *) M.pointer_coercion (M.read (| vec_ptr |));
                            M.rust_cast
                              (M.read (|
                                M.use
                                  (M.alloc (|
                                    M.SubPointer.get_struct_record_field (|
                                      M.read (| rc_ptr |),
                                      "alloc::rc::RcBox",
                                      "value"
                                    |)
                                  |))
                              |));
                            M.read (| len |)
                          ]
                        |)
                      |) in
                    M.match_operator (|
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.apply
                              (Ty.path "alloc::vec::Vec")
                              [ T; Ty.apply (Ty.path "&") [ A ] ],
                            "from_raw_parts_in",
                            []
                          |),
                          [ M.read (| vec_ptr |); Value.Integer 0; M.read (| cap |); alloc ]
                        |)
                      |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (M.alloc (|
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "alloc::rc::Rc")
                                    [ Ty.apply (Ty.path "slice") [ T ]; A ],
                                  "from_ptr_in",
                                  []
                                |),
                                [ M.read (| rc_ptr |); M.read (| alloc |) ]
                              |)
                            |)))
                      ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (T A : Ty.t),
      M.IsTraitInstance
        "core::convert::From"
        (Self T A)
        (* Trait polymorphic types *) [ (* T *) Ty.apply (Ty.path "alloc::vec::Vec") [ T; A ] ]
        (* Instance *) [ ("from", InstanceField.Method (from T A)) ].
  End Impl_core_convert_From_where_core_alloc_Allocator_A_alloc_vec_Vec_T_A_for_alloc_rc_Rc_slice_T_A.
  
  Module Impl_core_convert_From_where_alloc_borrow_ToOwned_B_where_core_marker_Sized_B_where_core_convert_From_alloc_rc_Rc_B_alloc_alloc_Global_ref__B_where_core_convert_From_alloc_rc_Rc_B_alloc_alloc_Global_associated_type_alloc_borrow_Cow_B_for_alloc_rc_Rc_B_alloc_alloc_Global.
    Definition Self (B : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "alloc::rc::Rc") [ B; Ty.path "alloc::alloc::Global" ].
    
    (*
        fn from(cow: Cow<'a, B>) -> Rc<B> {
            match cow {
                Cow::Borrowed(s) => Rc::from(s),
                Cow::Owned(s) => Rc::from(s),
            }
        }
    *)
    Definition from (B : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self B in
      match τ, α with
      | [], [ cow ] =>
        ltac:(M.monadic
          (let cow := M.alloc (| cow |) in
          M.read (|
            M.match_operator (|
              cow,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "alloc::borrow::Cow::Borrowed",
                        0
                      |) in
                    let s := M.copy (| γ0_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_trait_method (|
                          "core::convert::From",
                          Ty.apply (Ty.path "alloc::rc::Rc") [ B; Ty.path "alloc::alloc::Global" ],
                          [ Ty.apply (Ty.path "&") [ B ] ],
                          "from",
                          []
                        |),
                        [ M.read (| s |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 :=
                      M.SubPointer.get_struct_tuple_field (| γ, "alloc::borrow::Cow::Owned", 0 |) in
                    let s := M.copy (| γ0_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_trait_method (|
                          "core::convert::From",
                          Ty.apply (Ty.path "alloc::rc::Rc") [ B; Ty.path "alloc::alloc::Global" ],
                          [ Ty.associated ],
                          "from",
                          []
                        |),
                        [ M.read (| s |) ]
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (B : Ty.t),
      M.IsTraitInstance
        "core::convert::From"
        (Self B)
        (* Trait polymorphic types *) [ (* T *) Ty.apply (Ty.path "alloc::borrow::Cow") [ B ] ]
        (* Instance *) [ ("from", InstanceField.Method (from B)) ].
  End Impl_core_convert_From_where_alloc_borrow_ToOwned_B_where_core_marker_Sized_B_where_core_convert_From_alloc_rc_Rc_B_alloc_alloc_Global_ref__B_where_core_convert_From_alloc_rc_Rc_B_alloc_alloc_Global_associated_type_alloc_borrow_Cow_B_for_alloc_rc_Rc_B_alloc_alloc_Global.
  
  Module Impl_core_convert_From_alloc_rc_Rc_str_alloc_alloc_Global_for_alloc_rc_Rc_slice_u8_alloc_alloc_Global.
    Definition Self : Ty.t :=
      Ty.apply
        (Ty.path "alloc::rc::Rc")
        [ Ty.apply (Ty.path "slice") [ Ty.path "u8" ]; Ty.path "alloc::alloc::Global" ].
    
    (*
        fn from(rc: Rc<str>) -> Self {
            // SAFETY: `str` has the same layout as `[u8]`.
            unsafe { Rc::from_raw(Rc::into_raw(rc) as *const [u8]) }
        }
    *)
    Definition from (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ rc ] =>
        ltac:(M.monadic
          (let rc := M.alloc (| rc |) in
          M.call_closure (|
            M.get_associated_function (|
              Ty.apply
                (Ty.path "alloc::rc::Rc")
                [ Ty.apply (Ty.path "slice") [ Ty.path "u8" ]; Ty.path "alloc::alloc::Global" ],
              "from_raw",
              []
            |),
            [
              M.rust_cast
                (M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "alloc::rc::Rc")
                      [ Ty.path "str"; Ty.path "alloc::alloc::Global" ],
                    "into_raw",
                    []
                  |),
                  [ M.read (| rc |) ]
                |))
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::convert::From"
        Self
        (* Trait polymorphic types *)
        [
          (* T *)
          Ty.apply (Ty.path "alloc::rc::Rc") [ Ty.path "str"; Ty.path "alloc::alloc::Global" ]
        ]
        (* Instance *) [ ("from", InstanceField.Method from) ].
  End Impl_core_convert_From_alloc_rc_Rc_str_alloc_alloc_Global_for_alloc_rc_Rc_slice_u8_alloc_alloc_Global.
  
  Module Impl_core_convert_TryFrom_alloc_rc_Rc_slice_T_alloc_alloc_Global_for_alloc_rc_Rc_array_T_alloc_alloc_Global.
    Definition Self (T : Ty.t) : Ty.t :=
      Ty.apply
        (Ty.path "alloc::rc::Rc")
        [ Ty.apply (Ty.path "array") [ T ]; Ty.path "alloc::alloc::Global" ].
    
    (*     type Error = Rc<[T]>; *)
    Definition _Error (T : Ty.t) : Ty.t :=
      Ty.apply
        (Ty.path "alloc::rc::Rc")
        [ Ty.apply (Ty.path "slice") [ T ]; Ty.path "alloc::alloc::Global" ].
    
    (*
        fn try_from(boxed_slice: Rc<[T]>) -> Result<Self, Self::Error> {
            if boxed_slice.len() == N {
                Ok(unsafe { Rc::from_raw(Rc::into_raw(boxed_slice) as *mut [T; N]) })
            } else {
                Err(boxed_slice)
            }
        }
    *)
    Definition try_from (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match τ, α with
      | [], [ boxed_slice ] =>
        ltac:(M.monadic
          (let boxed_slice := M.alloc (| boxed_slice |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          BinOp.Pure.eq
                            (M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply (Ty.path "slice") [ T ],
                                "len",
                                []
                              |),
                              [
                                M.call_closure (|
                                  M.get_trait_method (|
                                    "core::ops::deref::Deref",
                                    Ty.apply
                                      (Ty.path "alloc::rc::Rc")
                                      [
                                        Ty.apply (Ty.path "slice") [ T ];
                                        Ty.path "alloc::alloc::Global"
                                      ],
                                    [],
                                    "deref",
                                    []
                                  |),
                                  [ boxed_slice ]
                                |)
                              ]
                            |))
                            (M.read (| M.get_constant (| "alloc::rc::N" |) |))
                        |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply
                                (Ty.path "alloc::rc::Rc")
                                [ Ty.apply (Ty.path "array") [ T ]; Ty.path "alloc::alloc::Global"
                                ],
                              "from_raw",
                              []
                            |),
                            [
                              (* MutToConstPointer *)
                              M.pointer_coercion
                                (M.rust_cast
                                  (M.call_closure (|
                                    M.get_associated_function (|
                                      Ty.apply
                                        (Ty.path "alloc::rc::Rc")
                                        [
                                          Ty.apply (Ty.path "slice") [ T ];
                                          Ty.path "alloc::alloc::Global"
                                        ],
                                      "into_raw",
                                      []
                                    |),
                                    [ M.read (| boxed_slice |) ]
                                  |)))
                            ]
                          |)
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      Value.StructTuple "core::result::Result::Err" [ M.read (| boxed_slice |) ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "core::convert::TryFrom"
        (Self T)
        (* Trait polymorphic types *)
        [
          (* T *)
          Ty.apply
            (Ty.path "alloc::rc::Rc")
            [ Ty.apply (Ty.path "slice") [ T ]; Ty.path "alloc::alloc::Global" ]
        ]
        (* Instance *)
        [ ("Error", InstanceField.Ty (_Error T)); ("try_from", InstanceField.Method (try_from T)) ].
  End Impl_core_convert_TryFrom_alloc_rc_Rc_slice_T_alloc_alloc_Global_for_alloc_rc_Rc_array_T_alloc_alloc_Global.
  
  Module Impl_core_iter_traits_collect_FromIterator_T_for_alloc_rc_Rc_slice_T_alloc_alloc_Global.
    Definition Self (T : Ty.t) : Ty.t :=
      Ty.apply
        (Ty.path "alloc::rc::Rc")
        [ Ty.apply (Ty.path "slice") [ T ]; Ty.path "alloc::alloc::Global" ].
    
    (*
        fn from_iter<I: IntoIterator<Item = T>>(iter: I) -> Self {
            ToRcSlice::to_rc_slice(iter.into_iter())
        }
    *)
    Definition from_iter (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match τ, α with
      | [ _ as I ], [ iter ] =>
        ltac:(M.monadic
          (let iter := M.alloc (| iter |) in
          M.call_closure (|
            M.get_trait_method (|
              "alloc::rc::ToRcSlice",
              Ty.associated,
              [ T ],
              "to_rc_slice",
              []
            |),
            [
              M.call_closure (|
                M.get_trait_method (|
                  "core::iter::traits::collect::IntoIterator",
                  I,
                  [],
                  "into_iter",
                  []
                |),
                [ M.read (| iter |) ]
              |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "core::iter::traits::collect::FromIterator"
        (Self T)
        (* Trait polymorphic types *) [ (* A *) T ]
        (* Instance *) [ ("from_iter", InstanceField.Method (from_iter T)) ].
  End Impl_core_iter_traits_collect_FromIterator_T_for_alloc_rc_Rc_slice_T_alloc_alloc_Global.
  
  (* Trait *)
  (* Empty module 'ToRcSlice' *)
  
  Module Impl_alloc_rc_ToRcSlice_where_core_iter_traits_iterator_Iterator_I_T_for_I.
    Definition Self (T I : Ty.t) : Ty.t := I.
    
    (*
        default fn to_rc_slice(self) -> Rc<[T]> {
            self.collect::<Vec<T>>().into()
        }
    *)
    Definition to_rc_slice (T I : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T I in
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_trait_method (|
              "core::convert::Into",
              Ty.apply (Ty.path "alloc::vec::Vec") [ T; Ty.path "alloc::alloc::Global" ],
              [
                Ty.apply
                  (Ty.path "alloc::rc::Rc")
                  [ Ty.apply (Ty.path "slice") [ T ]; Ty.path "alloc::alloc::Global" ]
              ],
              "into",
              []
            |),
            [
              M.call_closure (|
                M.get_trait_method (|
                  "core::iter::traits::iterator::Iterator",
                  I,
                  [],
                  "collect",
                  [ Ty.apply (Ty.path "alloc::vec::Vec") [ T; Ty.path "alloc::alloc::Global" ] ]
                |),
                [ M.read (| self |) ]
              |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (T I : Ty.t),
      M.IsTraitInstance
        "alloc::rc::ToRcSlice"
        (Self T I)
        (* Trait polymorphic types *) [ (* T *) T ]
        (* Instance *) [ ("to_rc_slice", InstanceField.Method (to_rc_slice T I)) ].
  End Impl_alloc_rc_ToRcSlice_where_core_iter_traits_iterator_Iterator_I_T_for_I.
  
  Module Impl_alloc_rc_ToRcSlice_where_core_iter_traits_marker_TrustedLen_I_T_for_I.
    Definition Self (T I : Ty.t) : Ty.t := I.
    
    (*
        fn to_rc_slice(self) -> Rc<[T]> {
            // This is the case for a `TrustedLen` iterator.
            let (low, high) = self.size_hint();
            if let Some(high) = high {
                debug_assert_eq!(
                    low,
                    high,
                    "TrustedLen iterator's size hint is not exact: {:?}",
                    (low, high)
                );
    
                unsafe {
                    // SAFETY: We need to ensure that the iterator has an exact length and we have.
                    Rc::from_iter_exact(self, low)
                }
            } else {
                // TrustedLen contract guarantees that `upper_bound == None` implies an iterator
                // length exceeding `usize::MAX`.
                // The default implementation would collect into a vec which would panic.
                // Thus we panic here immediately without invoking `Vec` code.
                panic!("capacity overflow");
            }
        }
    *)
    Definition to_rc_slice (T I : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T I in
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_trait_method (|
                    "core::iter::traits::iterator::Iterator",
                    I,
                    [],
                    "size_hint",
                    []
                  |),
                  [ self ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let low := M.copy (| γ0_0 |) in
                    let high := M.copy (| γ0_1 |) in
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ := high in
                            let γ0_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "core::option::Option::Some",
                                0
                              |) in
                            let high := M.copy (| γ0_0 |) in
                            let _ :=
                              M.match_operator (|
                                M.alloc (| Value.Tuple [] |),
                                [
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let γ := M.use (M.alloc (| Value.Bool true |)) in
                                      let _ :=
                                        M.is_constant_or_break_match (|
                                          M.read (| γ |),
                                          Value.Bool true
                                        |) in
                                      let _ :=
                                        M.match_operator (|
                                          M.alloc (| Value.Tuple [ low; high ] |),
                                          [
                                            fun γ =>
                                              ltac:(M.monadic
                                                (let γ0_0 :=
                                                  M.SubPointer.get_tuple_field (| γ, 0 |) in
                                                let γ0_1 :=
                                                  M.SubPointer.get_tuple_field (| γ, 1 |) in
                                                let left_val := M.copy (| γ0_0 |) in
                                                let right_val := M.copy (| γ0_1 |) in
                                                M.match_operator (|
                                                  M.alloc (| Value.Tuple [] |),
                                                  [
                                                    fun γ =>
                                                      ltac:(M.monadic
                                                        (let γ :=
                                                          M.use
                                                            (M.alloc (|
                                                              UnOp.Pure.not
                                                                (BinOp.Pure.eq
                                                                  (M.read (|
                                                                    M.read (| left_val |)
                                                                  |))
                                                                  (M.read (|
                                                                    M.read (| right_val |)
                                                                  |)))
                                                            |)) in
                                                        let _ :=
                                                          M.is_constant_or_break_match (|
                                                            M.read (| γ |),
                                                            Value.Bool true
                                                          |) in
                                                        M.alloc (|
                                                          M.never_to_any (|
                                                            M.read (|
                                                              let kind :=
                                                                M.alloc (|
                                                                  Value.StructTuple
                                                                    "core::panicking::AssertKind::Eq"
                                                                    []
                                                                |) in
                                                              M.alloc (|
                                                                M.call_closure (|
                                                                  M.get_function (|
                                                                    "core::panicking::assert_failed",
                                                                    [
                                                                      Ty.path "usize";
                                                                      Ty.path "usize"
                                                                    ]
                                                                  |),
                                                                  [
                                                                    M.read (| kind |);
                                                                    M.read (| left_val |);
                                                                    M.read (| right_val |);
                                                                    Value.StructTuple
                                                                      "core::option::Option::Some"
                                                                      [
                                                                        M.call_closure (|
                                                                          M.get_associated_function (|
                                                                            Ty.path
                                                                              "core::fmt::Arguments",
                                                                            "new_v1",
                                                                            []
                                                                          |),
                                                                          [
                                                                            (* Unsize *)
                                                                            M.pointer_coercion
                                                                              (M.alloc (|
                                                                                Value.Array
                                                                                  [
                                                                                    M.read (|
                                                                                      Value.String
                                                                                        "TrustedLen iterator's size hint is not exact: "
                                                                                    |)
                                                                                  ]
                                                                              |));
                                                                            (* Unsize *)
                                                                            M.pointer_coercion
                                                                              (M.alloc (|
                                                                                Value.Array
                                                                                  [
                                                                                    M.call_closure (|
                                                                                      M.get_associated_function (|
                                                                                        Ty.path
                                                                                          "core::fmt::rt::Argument",
                                                                                        "new_debug",
                                                                                        [
                                                                                          Ty.tuple
                                                                                            [
                                                                                              Ty.path
                                                                                                "usize";
                                                                                              Ty.path
                                                                                                "usize"
                                                                                            ]
                                                                                        ]
                                                                                      |),
                                                                                      [
                                                                                        M.alloc (|
                                                                                          Value.Tuple
                                                                                            [
                                                                                              M.read (|
                                                                                                low
                                                                                              |);
                                                                                              M.read (|
                                                                                                high
                                                                                              |)
                                                                                            ]
                                                                                        |)
                                                                                      ]
                                                                                    |)
                                                                                  ]
                                                                              |))
                                                                          ]
                                                                        |)
                                                                      ]
                                                                  ]
                                                                |)
                                                              |)
                                                            |)
                                                          |)
                                                        |)));
                                                    fun γ =>
                                                      ltac:(M.monadic
                                                        (M.alloc (| Value.Tuple [] |)))
                                                  ]
                                                |)))
                                          ]
                                        |) in
                                      M.alloc (| Value.Tuple [] |)));
                                  fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                                ]
                              |) in
                            M.alloc (|
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "alloc::rc::Rc")
                                    [
                                      Ty.apply (Ty.path "slice") [ T ];
                                      Ty.path "alloc::alloc::Global"
                                    ],
                                  "from_iter_exact",
                                  [ I ]
                                |),
                                [ M.read (| self |); M.read (| low |) ]
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (M.alloc (|
                              M.never_to_any (|
                                M.call_closure (|
                                  M.get_function (| "core::panicking::panic_fmt", [] |),
                                  [
                                    M.call_closure (|
                                      M.get_associated_function (|
                                        Ty.path "core::fmt::Arguments",
                                        "new_const",
                                        []
                                      |),
                                      [
                                        (* Unsize *)
                                        M.pointer_coercion
                                          (M.alloc (|
                                            Value.Array
                                              [ M.read (| Value.String "capacity overflow" |) ]
                                          |))
                                      ]
                                    |)
                                  ]
                                |)
                              |)
                            |)))
                      ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (T I : Ty.t),
      M.IsTraitInstance
        "alloc::rc::ToRcSlice"
        (Self T I)
        (* Trait polymorphic types *) [ (* T *) T ]
        (* Instance *) [ ("to_rc_slice", InstanceField.Method (to_rc_slice T I)) ].
  End Impl_alloc_rc_ToRcSlice_where_core_iter_traits_marker_TrustedLen_I_T_for_I.
  
  (* StructRecord
    {
      name := "Weak";
      ty_params := [ "T"; "A" ];
      fields :=
        [
          ("ptr",
            Ty.apply
              (Ty.path "core::ptr::non_null::NonNull")
              [ Ty.apply (Ty.path "alloc::rc::RcBox") [ T ] ]);
          ("alloc", A)
        ];
    } *)
  
  Module Impl_core_marker_Send_where_core_marker_Sized_T_where_core_alloc_Allocator_A_for_alloc_rc_Weak_T_A.
    Definition Self (T A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::rc::Weak") [ T; A ].
    
    Axiom Implements :
      forall (T A : Ty.t),
      M.IsTraitInstance
        "core::marker::Send"
        (Self T A)
        (* Trait polymorphic types *) []
        (* Instance *) [].
  End Impl_core_marker_Send_where_core_marker_Sized_T_where_core_alloc_Allocator_A_for_alloc_rc_Weak_T_A.
  
  Module Impl_core_marker_Sync_where_core_marker_Sized_T_where_core_alloc_Allocator_A_for_alloc_rc_Weak_T_A.
    Definition Self (T A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::rc::Weak") [ T; A ].
    
    Axiom Implements :
      forall (T A : Ty.t),
      M.IsTraitInstance
        "core::marker::Sync"
        (Self T A)
        (* Trait polymorphic types *) []
        (* Instance *) [].
  End Impl_core_marker_Sync_where_core_marker_Sized_T_where_core_alloc_Allocator_A_for_alloc_rc_Weak_T_A.
  
  Module Impl_core_ops_unsize_CoerceUnsized_where_core_marker_Sized_T_where_core_marker_Unsize_T_U_where_core_marker_Sized_U_where_core_alloc_Allocator_A_alloc_rc_Weak_U_A_for_alloc_rc_Weak_T_A.
    Definition Self (T U A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::rc::Weak") [ T; A ].
    
    Axiom Implements :
      forall (T U A : Ty.t),
      M.IsTraitInstance
        "core::ops::unsize::CoerceUnsized"
        (Self T U A)
        (* Trait polymorphic types *) [ (* T *) Ty.apply (Ty.path "alloc::rc::Weak") [ U; A ] ]
        (* Instance *) [].
  End Impl_core_ops_unsize_CoerceUnsized_where_core_marker_Sized_T_where_core_marker_Unsize_T_U_where_core_marker_Sized_U_where_core_alloc_Allocator_A_alloc_rc_Weak_U_A_for_alloc_rc_Weak_T_A.
  
  Module Impl_core_ops_unsize_DispatchFromDyn_where_core_marker_Sized_T_where_core_marker_Unsize_T_U_where_core_marker_Sized_U_alloc_rc_Weak_U_alloc_alloc_Global_for_alloc_rc_Weak_T_alloc_alloc_Global.
    Definition Self (T U : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "alloc::rc::Weak") [ T; Ty.path "alloc::alloc::Global" ].
    
    Axiom Implements :
      forall (T U : Ty.t),
      M.IsTraitInstance
        "core::ops::unsize::DispatchFromDyn"
        (Self T U)
        (* Trait polymorphic types *)
        [ (* T *) Ty.apply (Ty.path "alloc::rc::Weak") [ U; Ty.path "alloc::alloc::Global" ] ]
        (* Instance *) [].
  End Impl_core_ops_unsize_DispatchFromDyn_where_core_marker_Sized_T_where_core_marker_Unsize_T_U_where_core_marker_Sized_U_alloc_rc_Weak_U_alloc_alloc_Global_for_alloc_rc_Weak_T_alloc_alloc_Global.
  
  Module Impl_alloc_rc_Weak_T_alloc_alloc_Global.
    Definition Self (T : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "alloc::rc::Weak") [ T; Ty.path "alloc::alloc::Global" ].
    
    (*
        pub const fn new() -> Weak<T> {
            Weak {
                ptr: unsafe { NonNull::new_unchecked(ptr::invalid_mut::<RcBox<T>>(usize::MAX)) },
                alloc: Global,
            }
        }
    *)
    Definition new (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match τ, α with
      | [], [] =>
        ltac:(M.monadic
          (Value.StructRecord
            "alloc::rc::Weak"
            [
              ("ptr",
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "core::ptr::non_null::NonNull")
                      [ Ty.apply (Ty.path "alloc::rc::RcBox") [ T ] ],
                    "new_unchecked",
                    []
                  |),
                  [
                    M.call_closure (|
                      M.get_function (|
                        "core::ptr::invalid_mut",
                        [ Ty.apply (Ty.path "alloc::rc::RcBox") [ T ] ]
                      |),
                      [ M.read (| M.get_constant (| "core::num::MAX" |) |) ]
                    |)
                  ]
                |));
              ("alloc", Value.StructTuple "alloc::alloc::Global" [])
            ]))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_new : forall (T : Ty.t), M.IsAssociatedFunction (Self T) "new" (new T).
    (*
        pub unsafe fn from_raw(ptr: *const T) -> Self {
            unsafe { Self::from_raw_in(ptr, Global) }
        }
    *)
    Definition from_raw (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match τ, α with
      | [], [ ptr ] =>
        ltac:(M.monadic
          (let ptr := M.alloc (| ptr |) in
          M.call_closure (|
            M.get_associated_function (|
              Ty.apply (Ty.path "alloc::rc::Weak") [ T; Ty.path "alloc::alloc::Global" ],
              "from_raw_in",
              []
            |),
            [ M.read (| ptr |); Value.StructTuple "alloc::alloc::Global" [] ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_from_raw :
      forall (T : Ty.t),
      M.IsAssociatedFunction (Self T) "from_raw" (from_raw T).
  End Impl_alloc_rc_Weak_T_alloc_alloc_Global.
  
  Module Impl_alloc_rc_Weak_T_A.
    Definition Self (T A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::rc::Weak") [ T; A ].
    
    (*
        pub fn new_in(alloc: A) -> Weak<T, A> {
            Weak {
                ptr: unsafe { NonNull::new_unchecked(ptr::invalid_mut::<RcBox<T>>(usize::MAX)) },
                alloc,
            }
        }
    *)
    Definition new_in (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match τ, α with
      | [], [ alloc ] =>
        ltac:(M.monadic
          (let alloc := M.alloc (| alloc |) in
          Value.StructRecord
            "alloc::rc::Weak"
            [
              ("ptr",
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "core::ptr::non_null::NonNull")
                      [ Ty.apply (Ty.path "alloc::rc::RcBox") [ T ] ],
                    "new_unchecked",
                    []
                  |),
                  [
                    M.call_closure (|
                      M.get_function (|
                        "core::ptr::invalid_mut",
                        [ Ty.apply (Ty.path "alloc::rc::RcBox") [ T ] ]
                      |),
                      [ M.read (| M.get_constant (| "core::num::MAX" |) |) ]
                    |)
                  ]
                |));
              ("alloc", M.read (| alloc |))
            ]))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_new_in :
      forall (T A : Ty.t),
      M.IsAssociatedFunction (Self T A) "new_in" (new_in T A).
    (*
        pub fn as_ptr(&self) -> *const T {
            let ptr: *mut RcBox<T> = NonNull::as_ptr(self.ptr);
    
            if is_dangling(ptr) {
                // If the pointer is dangling, we return the sentinel directly. This cannot be
                // a valid payload address, as the payload is at least as aligned as RcBox (usize).
                ptr as *const T
            } else {
                // SAFETY: if is_dangling returns false, then the pointer is dereferenceable.
                // The payload may be dropped at this point, and we have to maintain provenance,
                // so use raw pointer manipulation.
                unsafe { ptr::addr_of_mut!(( *ptr).value) }
            }
        }
    *)
    Definition as_ptr (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            let ptr :=
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "core::ptr::non_null::NonNull")
                      [ Ty.apply (Ty.path "alloc::rc::RcBox") [ T ] ],
                    "as_ptr",
                    []
                  |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "alloc::rc::Weak",
                        "ptr"
                      |)
                    |)
                  ]
                |)
              |) in
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          M.call_closure (|
                            M.get_function (|
                              "alloc::rc::is_dangling",
                              [ Ty.apply (Ty.path "alloc::rc::RcBox") [ T ] ]
                            |),
                            [ M.read (| ptr |) ]
                          |)
                        |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (| M.rust_cast (M.read (| ptr |)) |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      (* MutToConstPointer *)
                      M.pointer_coercion
                        (M.SubPointer.get_struct_record_field (|
                          M.read (| ptr |),
                          "alloc::rc::RcBox",
                          "value"
                        |))
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_as_ptr :
      forall (T A : Ty.t),
      M.IsAssociatedFunction (Self T A) "as_ptr" (as_ptr T A).
    
    (*
        pub fn into_raw(self) -> *const T {
            let result = self.as_ptr();
            mem::forget(self);
            result
        }
    *)
    Definition into_raw (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            let result :=
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "alloc::rc::Weak") [ T; A ],
                    "as_ptr",
                    []
                  |),
                  [ self ]
                |)
              |) in
            let _ :=
              M.alloc (|
                M.call_closure (|
                  M.get_function (|
                    "core::mem::forget",
                    [ Ty.apply (Ty.path "alloc::rc::Weak") [ T; A ] ]
                  |),
                  [ M.read (| self |) ]
                |)
              |) in
            result
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_into_raw :
      forall (T A : Ty.t),
      M.IsAssociatedFunction (Self T A) "into_raw" (into_raw T A).
    
    (*
        pub fn into_raw_and_alloc(self) -> ( *const T, A)
        where
            A: Clone,
        {
            let result = self.as_ptr();
            let alloc = self.alloc.clone();
            mem::forget(self);
            (result, alloc)
        }
    *)
    Definition into_raw_and_alloc (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            let result :=
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "alloc::rc::Weak") [ T; A ],
                    "as_ptr",
                    []
                  |),
                  [ self ]
                |)
              |) in
            let alloc :=
              M.alloc (|
                M.call_closure (|
                  M.get_trait_method (| "core::clone::Clone", A, [], "clone", [] |),
                  [ M.SubPointer.get_struct_record_field (| self, "alloc::rc::Weak", "alloc" |) ]
                |)
              |) in
            let _ :=
              M.alloc (|
                M.call_closure (|
                  M.get_function (|
                    "core::mem::forget",
                    [ Ty.apply (Ty.path "alloc::rc::Weak") [ T; A ] ]
                  |),
                  [ M.read (| self |) ]
                |)
              |) in
            M.alloc (| Value.Tuple [ M.read (| result |); M.read (| alloc |) ] |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_into_raw_and_alloc :
      forall (T A : Ty.t),
      M.IsAssociatedFunction (Self T A) "into_raw_and_alloc" (into_raw_and_alloc T A).
    
    (*
        pub unsafe fn from_raw_in(ptr: *const T, alloc: A) -> Self {
            // See Weak::as_ptr for context on how the input pointer is derived.
    
            let ptr = if is_dangling(ptr as *mut T) {
                // This is a dangling Weak.
                ptr as *mut RcBox<T>
            } else {
                // Otherwise, we're guaranteed the pointer came from a nondangling Weak.
                // SAFETY: data_offset is safe to call, as ptr references a real (potentially dropped) T.
                let offset = unsafe { data_offset(ptr) };
                // Thus, we reverse the offset to get the whole RcBox.
                // SAFETY: the pointer originated from a Weak, so this offset is safe.
                unsafe { ptr.byte_sub(offset) as *mut RcBox<T> }
            };
    
            // SAFETY: we now have recovered the original Weak pointer, so can create the Weak.
            Weak { ptr: unsafe { NonNull::new_unchecked(ptr) }, alloc }
        }
    *)
    Definition from_raw_in (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match τ, α with
      | [], [ ptr; alloc ] =>
        ltac:(M.monadic
          (let ptr := M.alloc (| ptr |) in
          let alloc := M.alloc (| alloc |) in
          M.read (|
            let ptr :=
              M.copy (|
                M.match_operator (|
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ :=
                          M.use
                            (M.alloc (|
                              M.call_closure (|
                                M.get_function (| "alloc::rc::is_dangling", [ T ] |),
                                [ M.rust_cast (M.read (| ptr |)) ]
                              |)
                            |)) in
                        let _ :=
                          M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        M.alloc (| M.rust_cast (M.read (| ptr |)) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let offset :=
                          M.alloc (|
                            M.call_closure (|
                              M.get_function (| "alloc::rc::data_offset", [ T ] |),
                              [ M.read (| ptr |) ]
                            |)
                          |) in
                        M.alloc (|
                          M.rust_cast
                            (M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply (Ty.path "*const") [ T ],
                                "byte_sub",
                                []
                              |),
                              [ M.read (| ptr |); M.read (| offset |) ]
                            |))
                        |)))
                  ]
                |)
              |) in
            M.alloc (|
              Value.StructRecord
                "alloc::rc::Weak"
                [
                  ("ptr",
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "core::ptr::non_null::NonNull")
                          [ Ty.apply (Ty.path "alloc::rc::RcBox") [ T ] ],
                        "new_unchecked",
                        []
                      |),
                      [ M.read (| ptr |) ]
                    |));
                  ("alloc", M.read (| alloc |))
                ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_from_raw_in :
      forall (T A : Ty.t),
      M.IsAssociatedFunction (Self T A) "from_raw_in" (from_raw_in T A).
    
    (*
        pub fn upgrade(&self) -> Option<Rc<T, A>>
        where
            A: Clone,
        {
            let inner = self.inner()?;
    
            if inner.strong() == 0 {
                None
            } else {
                unsafe {
                    inner.inc_strong();
                    Some(Rc::from_inner_in(self.ptr, self.alloc.clone()))
                }
            }
        }
    *)
    Definition upgrade (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.catch_return (|
            ltac:(M.monadic
              (M.read (|
                let inner :=
                  M.copy (|
                    M.match_operator (|
                      M.alloc (|
                        M.call_closure (|
                          M.get_trait_method (|
                            "core::ops::try_trait::Try",
                            Ty.apply
                              (Ty.path "core::option::Option")
                              [ Ty.path "alloc::rc::WeakInner" ],
                            [],
                            "branch",
                            []
                          |),
                          [
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply (Ty.path "alloc::rc::Weak") [ T; A ],
                                "inner",
                                []
                              |),
                              [ M.read (| self |) ]
                            |)
                          ]
                        |)
                      |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "core::ops::control_flow::ControlFlow::Break",
                                0
                              |) in
                            let residual := M.copy (| γ0_0 |) in
                            M.alloc (|
                              M.never_to_any (|
                                M.read (|
                                  M.return_ (|
                                    M.call_closure (|
                                      M.get_trait_method (|
                                        "core::ops::try_trait::FromResidual",
                                        Ty.apply
                                          (Ty.path "core::option::Option")
                                          [ Ty.apply (Ty.path "alloc::rc::Rc") [ T; A ] ],
                                        [
                                          Ty.apply
                                            (Ty.path "core::option::Option")
                                            [ Ty.path "core::convert::Infallible" ]
                                        ],
                                        "from_residual",
                                        []
                                      |),
                                      [ M.read (| residual |) ]
                                    |)
                                  |)
                                |)
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "core::ops::control_flow::ControlFlow::Continue",
                                0
                              |) in
                            let val := M.copy (| γ0_0 |) in
                            val))
                      ]
                    |)
                  |) in
                M.match_operator (|
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ :=
                          M.use
                            (M.alloc (|
                              BinOp.Pure.eq
                                (M.call_closure (|
                                  M.get_trait_method (|
                                    "alloc::rc::RcInnerPtr",
                                    Ty.path "alloc::rc::WeakInner",
                                    [],
                                    "strong",
                                    []
                                  |),
                                  [ inner ]
                                |))
                                (Value.Integer 0)
                            |)) in
                        let _ :=
                          M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let _ :=
                          M.alloc (|
                            M.call_closure (|
                              M.get_trait_method (|
                                "alloc::rc::RcInnerPtr",
                                Ty.path "alloc::rc::WeakInner",
                                [],
                                "inc_strong",
                                []
                              |),
                              [ inner ]
                            |)
                          |) in
                        M.alloc (|
                          Value.StructTuple
                            "core::option::Option::Some"
                            [
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "alloc::rc::Rc") [ T; A ],
                                  "from_inner_in",
                                  []
                                |),
                                [
                                  M.read (|
                                    M.SubPointer.get_struct_record_field (|
                                      M.read (| self |),
                                      "alloc::rc::Weak",
                                      "ptr"
                                    |)
                                  |);
                                  M.call_closure (|
                                    M.get_trait_method (|
                                      "core::clone::Clone",
                                      A,
                                      [],
                                      "clone",
                                      []
                                    |),
                                    [
                                      M.SubPointer.get_struct_record_field (|
                                        M.read (| self |),
                                        "alloc::rc::Weak",
                                        "alloc"
                                      |)
                                    ]
                                  |)
                                ]
                              |)
                            ]
                        |)))
                  ]
                |)
              |)))
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_upgrade :
      forall (T A : Ty.t),
      M.IsAssociatedFunction (Self T A) "upgrade" (upgrade T A).
    
    (*
        pub fn strong_count(&self) -> usize {
            if let Some(inner) = self.inner() { inner.strong() } else { 0 }
        }
    *)
    Definition strong_count (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.apply (Ty.path "alloc::rc::Weak") [ T; A ],
                            "inner",
                            []
                          |),
                          [ M.read (| self |) ]
                        |)
                      |) in
                    let γ0_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "core::option::Option::Some",
                        0
                      |) in
                    let inner := M.copy (| γ0_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_trait_method (|
                          "alloc::rc::RcInnerPtr",
                          Ty.path "alloc::rc::WeakInner",
                          [],
                          "strong",
                          []
                        |),
                        [ inner ]
                      |)
                    |)));
                fun γ => ltac:(M.monadic (M.alloc (| Value.Integer 0 |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_strong_count :
      forall (T A : Ty.t),
      M.IsAssociatedFunction (Self T A) "strong_count" (strong_count T A).
    
    (*
        pub fn weak_count(&self) -> usize {
            if let Some(inner) = self.inner() {
                if inner.strong() > 0 {
                    inner.weak() - 1 // subtract the implicit weak ptr
                } else {
                    0
                }
            } else {
                0
            }
        }
    *)
    Definition weak_count (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.apply (Ty.path "alloc::rc::Weak") [ T; A ],
                            "inner",
                            []
                          |),
                          [ M.read (| self |) ]
                        |)
                      |) in
                    let γ0_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "core::option::Option::Some",
                        0
                      |) in
                    let inner := M.copy (| γ0_0 |) in
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  BinOp.Pure.gt
                                    (M.call_closure (|
                                      M.get_trait_method (|
                                        "alloc::rc::RcInnerPtr",
                                        Ty.path "alloc::rc::WeakInner",
                                        [],
                                        "strong",
                                        []
                                      |),
                                      [ inner ]
                                    |))
                                    (Value.Integer 0)
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (|
                              BinOp.Panic.sub (|
                                Integer.Usize,
                                M.call_closure (|
                                  M.get_trait_method (|
                                    "alloc::rc::RcInnerPtr",
                                    Ty.path "alloc::rc::WeakInner",
                                    [],
                                    "weak",
                                    []
                                  |),
                                  [ inner ]
                                |),
                                Value.Integer 1
                              |)
                            |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Integer 0 |)))
                      ]
                    |)));
                fun γ => ltac:(M.monadic (M.alloc (| Value.Integer 0 |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_weak_count :
      forall (T A : Ty.t),
      M.IsAssociatedFunction (Self T A) "weak_count" (weak_count T A).
    
    (*
        fn inner(&self) -> Option<WeakInner<'_>> {
            if is_dangling(self.ptr.as_ptr()) {
                None
            } else {
                // We are careful to *not* create a reference covering the "data" field, as
                // the field may be mutated concurrently (for example, if the last `Rc`
                // is dropped, the data field will be dropped in-place).
                Some(unsafe {
                    let ptr = self.ptr.as_ptr();
                    WeakInner { strong: &( *ptr).strong, weak: &( *ptr).weak }
                })
            }
        }
    *)
    Definition inner (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          M.call_closure (|
                            M.get_function (|
                              "alloc::rc::is_dangling",
                              [ Ty.apply (Ty.path "alloc::rc::RcBox") [ T ] ]
                            |),
                            [
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "core::ptr::non_null::NonNull")
                                    [ Ty.apply (Ty.path "alloc::rc::RcBox") [ T ] ],
                                  "as_ptr",
                                  []
                                |),
                                [
                                  M.read (|
                                    M.SubPointer.get_struct_record_field (|
                                      M.read (| self |),
                                      "alloc::rc::Weak",
                                      "ptr"
                                    |)
                                  |)
                                ]
                              |)
                            ]
                          |)
                        |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      Value.StructTuple
                        "core::option::Option::Some"
                        [
                          M.read (|
                            let ptr :=
                              M.alloc (|
                                M.call_closure (|
                                  M.get_associated_function (|
                                    Ty.apply
                                      (Ty.path "core::ptr::non_null::NonNull")
                                      [ Ty.apply (Ty.path "alloc::rc::RcBox") [ T ] ],
                                    "as_ptr",
                                    []
                                  |),
                                  [
                                    M.read (|
                                      M.SubPointer.get_struct_record_field (|
                                        M.read (| self |),
                                        "alloc::rc::Weak",
                                        "ptr"
                                      |)
                                    |)
                                  ]
                                |)
                              |) in
                            M.alloc (|
                              Value.StructRecord
                                "alloc::rc::WeakInner"
                                [
                                  ("strong",
                                    M.SubPointer.get_struct_record_field (|
                                      M.read (| ptr |),
                                      "alloc::rc::RcBox",
                                      "strong"
                                    |));
                                  ("weak",
                                    M.SubPointer.get_struct_record_field (|
                                      M.read (| ptr |),
                                      "alloc::rc::RcBox",
                                      "weak"
                                    |))
                                ]
                            |)
                          |)
                        ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_inner :
      forall (T A : Ty.t),
      M.IsAssociatedFunction (Self T A) "inner" (inner T A).
    
    (*
        pub fn ptr_eq(&self, other: &Self) -> bool {
            ptr::addr_eq(self.ptr.as_ptr(), other.ptr.as_ptr())
        }
    *)
    Definition ptr_eq (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match τ, α with
      | [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            M.get_function (|
              "core::ptr::addr_eq",
              [
                Ty.apply (Ty.path "alloc::rc::RcBox") [ T ];
                Ty.apply (Ty.path "alloc::rc::RcBox") [ T ]
              ]
            |),
            [
              (* MutToConstPointer *)
              M.pointer_coercion
                (M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "core::ptr::non_null::NonNull")
                      [ Ty.apply (Ty.path "alloc::rc::RcBox") [ T ] ],
                    "as_ptr",
                    []
                  |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "alloc::rc::Weak",
                        "ptr"
                      |)
                    |)
                  ]
                |));
              (* MutToConstPointer *)
              M.pointer_coercion
                (M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "core::ptr::non_null::NonNull")
                      [ Ty.apply (Ty.path "alloc::rc::RcBox") [ T ] ],
                    "as_ptr",
                    []
                  |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_record_field (|
                        M.read (| other |),
                        "alloc::rc::Weak",
                        "ptr"
                      |)
                    |)
                  ]
                |))
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_ptr_eq :
      forall (T A : Ty.t),
      M.IsAssociatedFunction (Self T A) "ptr_eq" (ptr_eq T A).
  End Impl_alloc_rc_Weak_T_A.
  
  (*
  pub(crate) fn is_dangling<T: ?Sized>(ptr: *mut T) -> bool {
      (ptr.cast::<()>()).addr() == usize::MAX
  }
  *)
  Definition is_dangling (τ : list Ty.t) (α : list Value.t) : M :=
    match τ, α with
    | [ T ], [ ptr ] =>
      ltac:(M.monadic
        (let ptr := M.alloc (| ptr |) in
        BinOp.Pure.eq
          (M.call_closure (|
            M.get_associated_function (| Ty.apply (Ty.path "*mut") [ Ty.tuple [] ], "addr", [] |),
            [
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply (Ty.path "*mut") [ T ],
                  "cast",
                  [ Ty.tuple [] ]
                |),
                [ M.read (| ptr |) ]
              |)
            ]
          |))
          (M.read (| M.get_constant (| "core::num::MAX" |) |))))
    | _, _ => M.impossible
    end.
  
  (* StructRecord
    {
      name := "WeakInner";
      ty_params := [];
      fields :=
        [
          ("weak",
            Ty.apply (Ty.path "&") [ Ty.apply (Ty.path "core::cell::Cell") [ Ty.path "usize" ] ]);
          ("strong",
            Ty.apply (Ty.path "&") [ Ty.apply (Ty.path "core::cell::Cell") [ Ty.path "usize" ] ])
        ];
    } *)
  
  
  
  Module Impl_core_ops_drop_Drop_where_core_marker_Sized_T_where_core_alloc_Allocator_A_for_alloc_rc_Weak_T_A.
    Definition Self (T A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::rc::Weak") [ T; A ].
    
    (*
        fn drop(&mut self) {
            let inner = if let Some(inner) = self.inner() { inner } else { return };
    
            inner.dec_weak();
            // the weak count starts at 1, and will only go to zero if all
            // the strong pointers have disappeared.
            if inner.weak() == 0 {
                unsafe {
                    self.alloc.deallocate(self.ptr.cast(), Layout::for_value_raw(self.ptr.as_ptr()));
                }
            }
        }
    *)
    Definition drop (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.catch_return (|
            ltac:(M.monadic
              (M.read (|
                let inner :=
                  M.copy (|
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.alloc (|
                                M.call_closure (|
                                  M.get_associated_function (|
                                    Ty.apply (Ty.path "alloc::rc::Weak") [ T; A ],
                                    "inner",
                                    []
                                  |),
                                  [ M.read (| self |) ]
                                |)
                              |) in
                            let γ0_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "core::option::Option::Some",
                                0
                              |) in
                            let inner := M.copy (| γ0_0 |) in
                            inner));
                        fun γ =>
                          ltac:(M.monadic
                            (M.alloc (|
                              M.never_to_any (| M.read (| M.return_ (| Value.Tuple [] |) |) |)
                            |)))
                      ]
                    |)
                  |) in
                let _ :=
                  M.alloc (|
                    M.call_closure (|
                      M.get_trait_method (|
                        "alloc::rc::RcInnerPtr",
                        Ty.path "alloc::rc::WeakInner",
                        [],
                        "dec_weak",
                        []
                      |),
                      [ inner ]
                    |)
                  |) in
                M.match_operator (|
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ :=
                          M.use
                            (M.alloc (|
                              BinOp.Pure.eq
                                (M.call_closure (|
                                  M.get_trait_method (|
                                    "alloc::rc::RcInnerPtr",
                                    Ty.path "alloc::rc::WeakInner",
                                    [],
                                    "weak",
                                    []
                                  |),
                                  [ inner ]
                                |))
                                (Value.Integer 0)
                            |)) in
                        let _ :=
                          M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        let _ :=
                          M.alloc (|
                            M.call_closure (|
                              M.get_trait_method (|
                                "core::alloc::Allocator",
                                A,
                                [],
                                "deallocate",
                                []
                              |),
                              [
                                M.SubPointer.get_struct_record_field (|
                                  M.read (| self |),
                                  "alloc::rc::Weak",
                                  "alloc"
                                |);
                                M.call_closure (|
                                  M.get_associated_function (|
                                    Ty.apply
                                      (Ty.path "core::ptr::non_null::NonNull")
                                      [ Ty.apply (Ty.path "alloc::rc::RcBox") [ T ] ],
                                    "cast",
                                    [ Ty.path "u8" ]
                                  |),
                                  [
                                    M.read (|
                                      M.SubPointer.get_struct_record_field (|
                                        M.read (| self |),
                                        "alloc::rc::Weak",
                                        "ptr"
                                      |)
                                    |)
                                  ]
                                |);
                                M.call_closure (|
                                  M.get_associated_function (|
                                    Ty.path "core::alloc::layout::Layout",
                                    "for_value_raw",
                                    [ Ty.apply (Ty.path "alloc::rc::RcBox") [ T ] ]
                                  |),
                                  [
                                    (* MutToConstPointer *)
                                    M.pointer_coercion
                                      (M.call_closure (|
                                        M.get_associated_function (|
                                          Ty.apply
                                            (Ty.path "core::ptr::non_null::NonNull")
                                            [ Ty.apply (Ty.path "alloc::rc::RcBox") [ T ] ],
                                          "as_ptr",
                                          []
                                        |),
                                        [
                                          M.read (|
                                            M.SubPointer.get_struct_record_field (|
                                              M.read (| self |),
                                              "alloc::rc::Weak",
                                              "ptr"
                                            |)
                                          |)
                                        ]
                                      |))
                                  ]
                                |)
                              ]
                            |)
                          |) in
                        M.alloc (| Value.Tuple [] |)));
                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                  ]
                |)
              |)))
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (T A : Ty.t),
      M.IsTraitInstance
        "core::ops::drop::Drop"
        (Self T A)
        (* Trait polymorphic types *) []
        (* Instance *) [ ("drop", InstanceField.Method (drop T A)) ].
  End Impl_core_ops_drop_Drop_where_core_marker_Sized_T_where_core_alloc_Allocator_A_for_alloc_rc_Weak_T_A.
  
  Module Impl_core_clone_Clone_where_core_marker_Sized_T_where_core_alloc_Allocator_A_where_core_clone_Clone_A_for_alloc_rc_Weak_T_A.
    Definition Self (T A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::rc::Weak") [ T; A ].
    
    (*
        fn clone(&self) -> Weak<T, A> {
            if let Some(inner) = self.inner() {
                inner.inc_weak()
            }
            Weak { ptr: self.ptr, alloc: self.alloc.clone() }
        }
    *)
    Definition clone (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            let _ :=
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply (Ty.path "alloc::rc::Weak") [ T; A ],
                              "inner",
                              []
                            |),
                            [ M.read (| self |) ]
                          |)
                        |) in
                      let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::option::Option::Some",
                          0
                        |) in
                      let inner := M.copy (| γ0_0 |) in
                      M.alloc (|
                        M.call_closure (|
                          M.get_trait_method (|
                            "alloc::rc::RcInnerPtr",
                            Ty.path "alloc::rc::WeakInner",
                            [],
                            "inc_weak",
                            []
                          |),
                          [ inner ]
                        |)
                      |)));
                  fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                ]
              |) in
            M.alloc (|
              Value.StructRecord
                "alloc::rc::Weak"
                [
                  ("ptr",
                    M.read (|
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "alloc::rc::Weak",
                        "ptr"
                      |)
                    |));
                  ("alloc",
                    M.call_closure (|
                      M.get_trait_method (| "core::clone::Clone", A, [], "clone", [] |),
                      [
                        M.SubPointer.get_struct_record_field (|
                          M.read (| self |),
                          "alloc::rc::Weak",
                          "alloc"
                        |)
                      ]
                    |))
                ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (T A : Ty.t),
      M.IsTraitInstance
        "core::clone::Clone"
        (Self T A)
        (* Trait polymorphic types *) []
        (* Instance *) [ ("clone", InstanceField.Method (clone T A)) ].
  End Impl_core_clone_Clone_where_core_marker_Sized_T_where_core_alloc_Allocator_A_where_core_clone_Clone_A_for_alloc_rc_Weak_T_A.
  
  Module Impl_core_fmt_Debug_where_core_marker_Sized_T_where_core_alloc_Allocator_A_for_alloc_rc_Weak_T_A.
    Definition Self (T A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::rc::Weak") [ T; A ].
    
    (*
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            write!(f, "(Weak)")
        }
    *)
    Definition fmt (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match τ, α with
      | [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "core::fmt::Formatter", "write_fmt", [] |),
            [
              M.read (| f |);
              M.call_closure (|
                M.get_associated_function (| Ty.path "core::fmt::Arguments", "new_const", [] |),
                [
                  (* Unsize *)
                  M.pointer_coercion
                    (M.alloc (| Value.Array [ M.read (| Value.String "(Weak)" |) ] |))
                ]
              |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (T A : Ty.t),
      M.IsTraitInstance
        "core::fmt::Debug"
        (Self T A)
        (* Trait polymorphic types *) []
        (* Instance *) [ ("fmt", InstanceField.Method (fmt T A)) ].
  End Impl_core_fmt_Debug_where_core_marker_Sized_T_where_core_alloc_Allocator_A_for_alloc_rc_Weak_T_A.
  
  Module Impl_core_default_Default_for_alloc_rc_Weak_T_alloc_alloc_Global.
    Definition Self (T : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "alloc::rc::Weak") [ T; Ty.path "alloc::alloc::Global" ].
    
    (*
        fn default() -> Weak<T> {
            Weak::new()
        }
    *)
    Definition default (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match τ, α with
      | [], [] =>
        ltac:(M.monadic
          (M.call_closure (|
            M.get_associated_function (|
              Ty.apply (Ty.path "alloc::rc::Weak") [ T; Ty.path "alloc::alloc::Global" ],
              "new",
              []
            |),
            []
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "core::default::Default"
        (Self T)
        (* Trait polymorphic types *) []
        (* Instance *) [ ("default", InstanceField.Method (default T)) ].
  End Impl_core_default_Default_for_alloc_rc_Weak_T_alloc_alloc_Global.
  
  (* Trait *)
  Module RcInnerPtr.
    Definition strong (Self : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_associated_function (|
              Ty.apply (Ty.path "core::cell::Cell") [ Ty.path "usize" ],
              "get",
              []
            |),
            [
              M.call_closure (|
                M.get_trait_method (| "alloc::rc::RcInnerPtr", Self, [], "strong_ref", [] |),
                [ M.read (| self |) ]
              |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom ProvidedMethod_strong : M.IsProvidedMethod "alloc::rc::RcInnerPtr" "strong" strong.
    Definition inc_strong (Self : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            let strong :=
              M.alloc (|
                M.call_closure (|
                  M.get_trait_method (| "alloc::rc::RcInnerPtr", Self, [], "strong", [] |),
                  [ M.read (| self |) ]
                |)
              |) in
            let _ :=
              let _ :=
                M.alloc (|
                  M.call_closure (|
                    M.get_function (| "core::intrinsics::assume", [] |),
                    [ BinOp.Pure.ne (M.read (| strong |)) (Value.Integer 0) ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |) in
            let strong :=
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "usize", "wrapping_add", [] |),
                  [ M.read (| strong |); Value.Integer 1 ]
                |)
              |) in
            let _ :=
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::Cell") [ Ty.path "usize" ],
                    "set",
                    []
                  |),
                  [
                    M.call_closure (|
                      M.get_trait_method (| "alloc::rc::RcInnerPtr", Self, [], "strong_ref", [] |),
                      [ M.read (| self |) ]
                    |);
                    M.read (| strong |)
                  ]
                |)
              |) in
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          M.call_closure (|
                            M.get_function (| "core::intrinsics::unlikely", [] |),
                            [ BinOp.Pure.eq (M.read (| strong |)) (Value.Integer 0) ]
                          |)
                        |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (|
                      M.never_to_any (|
                        M.call_closure (| M.get_function (| "core::intrinsics::abort", [] |), [] |)
                      |)
                    |)));
                fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom ProvidedMethod_inc_strong :
      M.IsProvidedMethod "alloc::rc::RcInnerPtr" "inc_strong" inc_strong.
    Definition dec_strong (Self : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            let _ :=
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::Cell") [ Ty.path "usize" ],
                    "set",
                    []
                  |),
                  [
                    M.call_closure (|
                      M.get_trait_method (| "alloc::rc::RcInnerPtr", Self, [], "strong_ref", [] |),
                      [ M.read (| self |) ]
                    |);
                    BinOp.Panic.sub (|
                      Integer.Usize,
                      M.call_closure (|
                        M.get_trait_method (| "alloc::rc::RcInnerPtr", Self, [], "strong", [] |),
                        [ M.read (| self |) ]
                      |),
                      Value.Integer 1
                    |)
                  ]
                |)
              |) in
            M.alloc (| Value.Tuple [] |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom ProvidedMethod_dec_strong :
      M.IsProvidedMethod "alloc::rc::RcInnerPtr" "dec_strong" dec_strong.
    Definition weak (Self : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_associated_function (|
              Ty.apply (Ty.path "core::cell::Cell") [ Ty.path "usize" ],
              "get",
              []
            |),
            [
              M.call_closure (|
                M.get_trait_method (| "alloc::rc::RcInnerPtr", Self, [], "weak_ref", [] |),
                [ M.read (| self |) ]
              |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom ProvidedMethod_weak : M.IsProvidedMethod "alloc::rc::RcInnerPtr" "weak" weak.
    Definition inc_weak (Self : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            let weak :=
              M.alloc (|
                M.call_closure (|
                  M.get_trait_method (| "alloc::rc::RcInnerPtr", Self, [], "weak", [] |),
                  [ M.read (| self |) ]
                |)
              |) in
            let _ :=
              let _ :=
                M.alloc (|
                  M.call_closure (|
                    M.get_function (| "core::intrinsics::assume", [] |),
                    [ BinOp.Pure.ne (M.read (| weak |)) (Value.Integer 0) ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |) in
            let weak :=
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "usize", "wrapping_add", [] |),
                  [ M.read (| weak |); Value.Integer 1 ]
                |)
              |) in
            let _ :=
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::Cell") [ Ty.path "usize" ],
                    "set",
                    []
                  |),
                  [
                    M.call_closure (|
                      M.get_trait_method (| "alloc::rc::RcInnerPtr", Self, [], "weak_ref", [] |),
                      [ M.read (| self |) ]
                    |);
                    M.read (| weak |)
                  ]
                |)
              |) in
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          M.call_closure (|
                            M.get_function (| "core::intrinsics::unlikely", [] |),
                            [ BinOp.Pure.eq (M.read (| weak |)) (Value.Integer 0) ]
                          |)
                        |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (|
                      M.never_to_any (|
                        M.call_closure (| M.get_function (| "core::intrinsics::abort", [] |), [] |)
                      |)
                    |)));
                fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom ProvidedMethod_inc_weak : M.IsProvidedMethod "alloc::rc::RcInnerPtr" "inc_weak" inc_weak.
    Definition dec_weak (Self : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            let _ :=
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::Cell") [ Ty.path "usize" ],
                    "set",
                    []
                  |),
                  [
                    M.call_closure (|
                      M.get_trait_method (| "alloc::rc::RcInnerPtr", Self, [], "weak_ref", [] |),
                      [ M.read (| self |) ]
                    |);
                    BinOp.Panic.sub (|
                      Integer.Usize,
                      M.call_closure (|
                        M.get_trait_method (| "alloc::rc::RcInnerPtr", Self, [], "weak", [] |),
                        [ M.read (| self |) ]
                      |),
                      Value.Integer 1
                    |)
                  ]
                |)
              |) in
            M.alloc (| Value.Tuple [] |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom ProvidedMethod_dec_weak : M.IsProvidedMethod "alloc::rc::RcInnerPtr" "dec_weak" dec_weak.
  End RcInnerPtr.
  
  Module Impl_alloc_rc_RcInnerPtr_where_core_marker_Sized_T_for_alloc_rc_RcBox_T.
    Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::rc::RcBox") [ T ].
    
    (*
        fn weak_ref(&self) -> &Cell<usize> {
            &self.weak
        }
    *)
    Definition weak_ref (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.SubPointer.get_struct_record_field (| M.read (| self |), "alloc::rc::RcBox", "weak" |)))
      | _, _ => M.impossible
      end.
    
    (*
        fn strong_ref(&self) -> &Cell<usize> {
            &self.strong
        }
    *)
    Definition strong_ref (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.SubPointer.get_struct_record_field (|
            M.read (| self |),
            "alloc::rc::RcBox",
            "strong"
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "alloc::rc::RcInnerPtr"
        (Self T)
        (* Trait polymorphic types *) []
        (* Instance *)
        [
          ("weak_ref", InstanceField.Method (weak_ref T));
          ("strong_ref", InstanceField.Method (strong_ref T))
        ].
  End Impl_alloc_rc_RcInnerPtr_where_core_marker_Sized_T_for_alloc_rc_RcBox_T.
  
  Module Impl_alloc_rc_RcInnerPtr_for_alloc_rc_WeakInner.
    Definition Self : Ty.t := Ty.path "alloc::rc::WeakInner".
    
    (*
        fn weak_ref(&self) -> &Cell<usize> {
            self.weak
        }
    *)
    Definition weak_ref (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.SubPointer.get_struct_record_field (|
              M.read (| self |),
              "alloc::rc::WeakInner",
              "weak"
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    (*
        fn strong_ref(&self) -> &Cell<usize> {
            self.strong
        }
    *)
    Definition strong_ref (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.SubPointer.get_struct_record_field (|
              M.read (| self |),
              "alloc::rc::WeakInner",
              "strong"
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "alloc::rc::RcInnerPtr"
        Self
        (* Trait polymorphic types *) []
        (* Instance *)
        [
          ("weak_ref", InstanceField.Method weak_ref);
          ("strong_ref", InstanceField.Method strong_ref)
        ].
  End Impl_alloc_rc_RcInnerPtr_for_alloc_rc_WeakInner.
  
  Module Impl_core_borrow_Borrow_where_core_marker_Sized_T_where_core_alloc_Allocator_A_T_for_alloc_rc_Rc_T_A.
    Definition Self (T A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::rc::Rc") [ T; A ].
    
    (*
        fn borrow(&self) -> &T {
            &**self
        }
    *)
    Definition borrow (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_trait_method (|
              "core::ops::deref::Deref",
              Ty.apply (Ty.path "alloc::rc::Rc") [ T; A ],
              [],
              "deref",
              []
            |),
            [ M.read (| self |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (T A : Ty.t),
      M.IsTraitInstance
        "core::borrow::Borrow"
        (Self T A)
        (* Trait polymorphic types *) [ (* Borrowed *) T ]
        (* Instance *) [ ("borrow", InstanceField.Method (borrow T A)) ].
  End Impl_core_borrow_Borrow_where_core_marker_Sized_T_where_core_alloc_Allocator_A_T_for_alloc_rc_Rc_T_A.
  
  Module Impl_core_convert_AsRef_where_core_marker_Sized_T_where_core_alloc_Allocator_A_T_for_alloc_rc_Rc_T_A.
    Definition Self (T A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::rc::Rc") [ T; A ].
    
    (*
        fn as_ref(&self) -> &T {
            &**self
        }
    *)
    Definition as_ref (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_trait_method (|
              "core::ops::deref::Deref",
              Ty.apply (Ty.path "alloc::rc::Rc") [ T; A ],
              [],
              "deref",
              []
            |),
            [ M.read (| self |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (T A : Ty.t),
      M.IsTraitInstance
        "core::convert::AsRef"
        (Self T A)
        (* Trait polymorphic types *) [ (* T *) T ]
        (* Instance *) [ ("as_ref", InstanceField.Method (as_ref T A)) ].
  End Impl_core_convert_AsRef_where_core_marker_Sized_T_where_core_alloc_Allocator_A_T_for_alloc_rc_Rc_T_A.
  
  Module Impl_core_marker_Unpin_where_core_marker_Sized_T_where_core_alloc_Allocator_A_for_alloc_rc_Rc_T_A.
    Definition Self (T A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::rc::Rc") [ T; A ].
    
    Axiom Implements :
      forall (T A : Ty.t),
      M.IsTraitInstance
        "core::marker::Unpin"
        (Self T A)
        (* Trait polymorphic types *) []
        (* Instance *) [].
  End Impl_core_marker_Unpin_where_core_marker_Sized_T_where_core_alloc_Allocator_A_for_alloc_rc_Rc_T_A.
  
  (*
  unsafe fn data_offset<T: ?Sized>(ptr: *const T) -> usize {
      // Align the unsized value to the end of the RcBox.
      // Because RcBox is repr(C), it will always be the last field in memory.
      // SAFETY: since the only unsized types possible are slices, trait objects,
      // and extern types, the input safety requirement is currently enough to
      // satisfy the requirements of align_of_val_raw; this is an implementation
      // detail of the language that must not be relied upon outside of std.
      unsafe { data_offset_align(align_of_val_raw(ptr)) }
  }
  *)
  Definition data_offset (τ : list Ty.t) (α : list Value.t) : M :=
    match τ, α with
    | [ T ], [ ptr ] =>
      ltac:(M.monadic
        (let ptr := M.alloc (| ptr |) in
        M.call_closure (|
          M.get_function (| "alloc::rc::data_offset_align", [] |),
          [
            M.call_closure (|
              M.get_function (| "core::mem::align_of_val_raw", [ T ] |),
              [ M.read (| ptr |) ]
            |)
          ]
        |)))
    | _, _ => M.impossible
    end.
  
  (*
  fn data_offset_align(align: usize) -> usize {
      let layout = Layout::new::<RcBox<()>>();
      layout.size() + layout.padding_needed_for(align)
  }
  *)
  Definition data_offset_align (τ : list Ty.t) (α : list Value.t) : M :=
    match τ, α with
    | [], [ align ] =>
      ltac:(M.monadic
        (let align := M.alloc (| align |) in
        M.read (|
          let layout :=
            M.alloc (|
              M.call_closure (|
                M.get_associated_function (|
                  Ty.path "core::alloc::layout::Layout",
                  "new",
                  [ Ty.apply (Ty.path "alloc::rc::RcBox") [ Ty.tuple [] ] ]
                |),
                []
              |)
            |) in
          M.alloc (|
            BinOp.Panic.add (|
              Integer.Usize,
              M.call_closure (|
                M.get_associated_function (| Ty.path "core::alloc::layout::Layout", "size", [] |),
                [ layout ]
              |),
              M.call_closure (|
                M.get_associated_function (|
                  Ty.path "core::alloc::layout::Layout",
                  "padding_needed_for",
                  []
                |),
                [ layout; M.read (| align |) ]
              |)
            |)
          |)
        |)))
    | _, _ => M.impossible
    end.
  
  (* StructRecord
    {
      name := "UniqueRc";
      ty_params := [ "T" ];
      fields :=
        [
          ("ptr",
            Ty.apply
              (Ty.path "core::ptr::non_null::NonNull")
              [ Ty.apply (Ty.path "alloc::rc::RcBox") [ T ] ]);
          ("phantom",
            Ty.apply
              (Ty.path "core::marker::PhantomData")
              [ Ty.apply (Ty.path "alloc::rc::RcBox") [ T ] ])
        ];
    } *)
  
  Module Impl_core_fmt_Debug_where_core_fmt_Debug_T_for_alloc_rc_UniqueRc_T.
    Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::rc::UniqueRc") [ T ].
    
    (* Debug *)
    Definition fmt (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match τ, α with
      | [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.call_closure (|
            M.get_associated_function (|
              Ty.path "core::fmt::Formatter",
              "debug_struct_field2_finish",
              []
            |),
            [
              M.read (| f |);
              M.read (| Value.String "UniqueRc" |);
              M.read (| Value.String "ptr" |);
              (* Unsize *)
              M.pointer_coercion
                (M.SubPointer.get_struct_record_field (|
                  M.read (| self |),
                  "alloc::rc::UniqueRc",
                  "ptr"
                |));
              M.read (| Value.String "phantom" |);
              (* Unsize *)
              M.pointer_coercion
                (M.alloc (|
                  M.SubPointer.get_struct_record_field (|
                    M.read (| self |),
                    "alloc::rc::UniqueRc",
                    "phantom"
                  |)
                |))
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "core::fmt::Debug"
        (Self T)
        (* Trait polymorphic types *) []
        (* Instance *) [ ("fmt", InstanceField.Method (fmt T)) ].
  End Impl_core_fmt_Debug_where_core_fmt_Debug_T_for_alloc_rc_UniqueRc_T.
  
  Module Impl_alloc_rc_UniqueRc_T.
    Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::rc::UniqueRc") [ T ].
    
    (*
        pub fn new(value: T) -> Self {
            Self {
                ptr: Box::leak(Box::new(RcBox {
                    strong: Cell::new(0),
                    // keep one weak reference so if all the weak pointers that are created are dropped
                    // the UniqueRc still stays valid.
                    weak: Cell::new(1),
                    value,
                }))
                .into(),
                phantom: PhantomData,
            }
        }
    *)
    Definition new (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match τ, α with
      | [], [ value ] =>
        ltac:(M.monadic
          (let value := M.alloc (| value |) in
          Value.StructRecord
            "alloc::rc::UniqueRc"
            [
              ("ptr",
                M.call_closure (|
                  M.get_trait_method (|
                    "core::convert::Into",
                    Ty.apply (Ty.path "&mut") [ Ty.apply (Ty.path "alloc::rc::RcBox") [ T ] ],
                    [
                      Ty.apply
                        (Ty.path "core::ptr::non_null::NonNull")
                        [ Ty.apply (Ty.path "alloc::rc::RcBox") [ T ] ]
                    ],
                    "into",
                    []
                  |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "alloc::boxed::Box")
                          [
                            Ty.apply (Ty.path "alloc::rc::RcBox") [ T ];
                            Ty.path "alloc::alloc::Global"
                          ],
                        "leak",
                        []
                      |),
                      [
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.apply
                              (Ty.path "alloc::boxed::Box")
                              [
                                Ty.apply (Ty.path "alloc::rc::RcBox") [ T ];
                                Ty.path "alloc::alloc::Global"
                              ],
                            "new",
                            []
                          |),
                          [
                            Value.StructRecord
                              "alloc::rc::RcBox"
                              [
                                ("strong",
                                  M.call_closure (|
                                    M.get_associated_function (|
                                      Ty.apply (Ty.path "core::cell::Cell") [ Ty.path "usize" ],
                                      "new",
                                      []
                                    |),
                                    [ Value.Integer 0 ]
                                  |));
                                ("weak",
                                  M.call_closure (|
                                    M.get_associated_function (|
                                      Ty.apply (Ty.path "core::cell::Cell") [ Ty.path "usize" ],
                                      "new",
                                      []
                                    |),
                                    [ Value.Integer 1 ]
                                  |));
                                ("value", M.read (| value |))
                              ]
                          ]
                        |)
                      ]
                    |)
                  ]
                |));
              ("phantom", Value.StructTuple "core::marker::PhantomData" [])
            ]))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_new : forall (T : Ty.t), M.IsAssociatedFunction (Self T) "new" (new T).
    
    (*
        pub fn downgrade(this: &Self) -> Weak<T> {
            // SAFETY: This pointer was allocated at creation time and we guarantee that we only have
            // one strong reference before converting to a regular Rc.
            unsafe {
                this.ptr.as_ref().inc_weak();
            }
            Weak { ptr: this.ptr, alloc: Global }
        }
    *)
    Definition downgrade (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match τ, α with
      | [], [ this ] =>
        ltac:(M.monadic
          (let this := M.alloc (| this |) in
          M.read (|
            let _ :=
              let _ :=
                M.alloc (|
                  M.call_closure (|
                    M.get_trait_method (|
                      "alloc::rc::RcInnerPtr",
                      Ty.apply (Ty.path "alloc::rc::RcBox") [ T ],
                      [],
                      "inc_weak",
                      []
                    |),
                    [
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply
                            (Ty.path "core::ptr::non_null::NonNull")
                            [ Ty.apply (Ty.path "alloc::rc::RcBox") [ T ] ],
                          "as_ref",
                          []
                        |),
                        [
                          M.SubPointer.get_struct_record_field (|
                            M.read (| this |),
                            "alloc::rc::UniqueRc",
                            "ptr"
                          |)
                        ]
                      |)
                    ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |) in
            M.alloc (|
              Value.StructRecord
                "alloc::rc::Weak"
                [
                  ("ptr",
                    M.read (|
                      M.SubPointer.get_struct_record_field (|
                        M.read (| this |),
                        "alloc::rc::UniqueRc",
                        "ptr"
                      |)
                    |));
                  ("alloc", Value.StructTuple "alloc::alloc::Global" [])
                ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_downgrade :
      forall (T : Ty.t),
      M.IsAssociatedFunction (Self T) "downgrade" (downgrade T).
    
    (*
        pub fn into_rc(this: Self) -> Rc<T> {
            let mut this = ManuallyDrop::new(this);
            // SAFETY: This pointer was allocated at creation time so we know it is valid.
            unsafe {
                // Convert our weak reference into a strong reference
                this.ptr.as_mut().strong.set(1);
                Rc::from_inner(this.ptr)
            }
        }
    *)
    Definition into_rc (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match τ, α with
      | [], [ this ] =>
        ltac:(M.monadic
          (let this := M.alloc (| this |) in
          M.read (|
            let this :=
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "core::mem::manually_drop::ManuallyDrop")
                      [ Ty.apply (Ty.path "alloc::rc::UniqueRc") [ T ] ],
                    "new",
                    []
                  |),
                  [ M.read (| this |) ]
                |)
              |) in
            let _ :=
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::cell::Cell") [ Ty.path "usize" ],
                    "set",
                    []
                  |),
                  [
                    M.SubPointer.get_struct_record_field (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply
                            (Ty.path "core::ptr::non_null::NonNull")
                            [ Ty.apply (Ty.path "alloc::rc::RcBox") [ T ] ],
                          "as_mut",
                          []
                        |),
                        [
                          M.SubPointer.get_struct_record_field (|
                            M.call_closure (|
                              M.get_trait_method (|
                                "core::ops::deref::DerefMut",
                                Ty.apply
                                  (Ty.path "core::mem::manually_drop::ManuallyDrop")
                                  [ Ty.apply (Ty.path "alloc::rc::UniqueRc") [ T ] ],
                                [],
                                "deref_mut",
                                []
                              |),
                              [ this ]
                            |),
                            "alloc::rc::UniqueRc",
                            "ptr"
                          |)
                        ]
                      |),
                      "alloc::rc::RcBox",
                      "strong"
                    |);
                    Value.Integer 1
                  ]
                |)
              |) in
            M.alloc (|
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply (Ty.path "alloc::rc::Rc") [ T; Ty.path "alloc::alloc::Global" ],
                  "from_inner",
                  []
                |),
                [
                  M.read (|
                    M.SubPointer.get_struct_record_field (|
                      M.call_closure (|
                        M.get_trait_method (|
                          "core::ops::deref::Deref",
                          Ty.apply
                            (Ty.path "core::mem::manually_drop::ManuallyDrop")
                            [ Ty.apply (Ty.path "alloc::rc::UniqueRc") [ T ] ],
                          [],
                          "deref",
                          []
                        |),
                        [ this ]
                      |),
                      "alloc::rc::UniqueRc",
                      "ptr"
                    |)
                  |)
                ]
              |)
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_into_rc :
      forall (T : Ty.t),
      M.IsAssociatedFunction (Self T) "into_rc" (into_rc T).
  End Impl_alloc_rc_UniqueRc_T.
  
  Module Impl_core_ops_deref_Deref_for_alloc_rc_UniqueRc_T.
    Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::rc::UniqueRc") [ T ].
    
    (*     type Target = T; *)
    Definition _Target (T : Ty.t) : Ty.t := T.
    
    (*
        fn deref(&self) -> &T {
            // SAFETY: This pointer was allocated at creation time so we know it is valid.
            unsafe { &self.ptr.as_ref().value }
        }
    *)
    Definition deref (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.SubPointer.get_struct_record_field (|
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply
                  (Ty.path "core::ptr::non_null::NonNull")
                  [ Ty.apply (Ty.path "alloc::rc::RcBox") [ T ] ],
                "as_ref",
                []
              |),
              [
                M.SubPointer.get_struct_record_field (|
                  M.read (| self |),
                  "alloc::rc::UniqueRc",
                  "ptr"
                |)
              ]
            |),
            "alloc::rc::RcBox",
            "value"
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "core::ops::deref::Deref"
        (Self T)
        (* Trait polymorphic types *) []
        (* Instance *)
        [ ("Target", InstanceField.Ty (_Target T)); ("deref", InstanceField.Method (deref T)) ].
  End Impl_core_ops_deref_Deref_for_alloc_rc_UniqueRc_T.
  
  Module Impl_core_ops_deref_DerefMut_for_alloc_rc_UniqueRc_T.
    Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::rc::UniqueRc") [ T ].
    
    (*
        fn deref_mut(&mut self) -> &mut T {
            // SAFETY: This pointer was allocated at creation time so we know it is valid. We know we
            // have unique ownership and therefore it's safe to make a mutable reference because
            // `UniqueRc` owns the only strong reference to itself.
            unsafe { &mut ( *self.ptr.as_ptr()).value }
        }
    *)
    Definition deref_mut (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.SubPointer.get_struct_record_field (|
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply
                  (Ty.path "core::ptr::non_null::NonNull")
                  [ Ty.apply (Ty.path "alloc::rc::RcBox") [ T ] ],
                "as_ptr",
                []
              |),
              [
                M.read (|
                  M.SubPointer.get_struct_record_field (|
                    M.read (| self |),
                    "alloc::rc::UniqueRc",
                    "ptr"
                  |)
                |)
              ]
            |),
            "alloc::rc::RcBox",
            "value"
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "core::ops::deref::DerefMut"
        (Self T)
        (* Trait polymorphic types *) []
        (* Instance *) [ ("deref_mut", InstanceField.Method (deref_mut T)) ].
  End Impl_core_ops_deref_DerefMut_for_alloc_rc_UniqueRc_T.
  
  Module Impl_core_ops_drop_Drop_for_alloc_rc_UniqueRc_T.
    Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::rc::UniqueRc") [ T ].
    
    (*
        fn drop(&mut self) {
            unsafe {
                // destroy the contained object
                drop_in_place(DerefMut::deref_mut(self));
    
                // remove the implicit "strong weak" pointer now that we've destroyed the contents.
                self.ptr.as_ref().dec_weak();
    
                if self.ptr.as_ref().weak() == 0 {
                    Global.deallocate(self.ptr.cast(), Layout::for_value(self.ptr.as_ref()));
                }
            }
        }
    *)
    Definition drop (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            let _ :=
              M.alloc (|
                M.call_closure (|
                  M.get_function (| "core::ptr::drop_in_place", [ T ] |),
                  [
                    M.call_closure (|
                      M.get_trait_method (|
                        "core::ops::deref::DerefMut",
                        Ty.apply (Ty.path "alloc::rc::UniqueRc") [ T ],
                        [],
                        "deref_mut",
                        []
                      |),
                      [ M.read (| self |) ]
                    |)
                  ]
                |)
              |) in
            let _ :=
              M.alloc (|
                M.call_closure (|
                  M.get_trait_method (|
                    "alloc::rc::RcInnerPtr",
                    Ty.apply (Ty.path "alloc::rc::RcBox") [ T ],
                    [],
                    "dec_weak",
                    []
                  |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "core::ptr::non_null::NonNull")
                          [ Ty.apply (Ty.path "alloc::rc::RcBox") [ T ] ],
                        "as_ref",
                        []
                      |),
                      [
                        M.SubPointer.get_struct_record_field (|
                          M.read (| self |),
                          "alloc::rc::UniqueRc",
                          "ptr"
                        |)
                      ]
                    |)
                  ]
                |)
              |) in
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          BinOp.Pure.eq
                            (M.call_closure (|
                              M.get_trait_method (|
                                "alloc::rc::RcInnerPtr",
                                Ty.apply (Ty.path "alloc::rc::RcBox") [ T ],
                                [],
                                "weak",
                                []
                              |),
                              [
                                M.call_closure (|
                                  M.get_associated_function (|
                                    Ty.apply
                                      (Ty.path "core::ptr::non_null::NonNull")
                                      [ Ty.apply (Ty.path "alloc::rc::RcBox") [ T ] ],
                                    "as_ref",
                                    []
                                  |),
                                  [
                                    M.SubPointer.get_struct_record_field (|
                                      M.read (| self |),
                                      "alloc::rc::UniqueRc",
                                      "ptr"
                                    |)
                                  ]
                                |)
                              ]
                            |))
                            (Value.Integer 0)
                        |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    let _ :=
                      M.alloc (|
                        M.call_closure (|
                          M.get_trait_method (|
                            "core::alloc::Allocator",
                            Ty.path "alloc::alloc::Global",
                            [],
                            "deallocate",
                            []
                          |),
                          [
                            M.alloc (| Value.StructTuple "alloc::alloc::Global" [] |);
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "core::ptr::non_null::NonNull")
                                  [ Ty.apply (Ty.path "alloc::rc::RcBox") [ T ] ],
                                "cast",
                                [ Ty.path "u8" ]
                              |),
                              [
                                M.read (|
                                  M.SubPointer.get_struct_record_field (|
                                    M.read (| self |),
                                    "alloc::rc::UniqueRc",
                                    "ptr"
                                  |)
                                |)
                              ]
                            |);
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.path "core::alloc::layout::Layout",
                                "for_value",
                                [ Ty.apply (Ty.path "alloc::rc::RcBox") [ T ] ]
                              |),
                              [
                                M.call_closure (|
                                  M.get_associated_function (|
                                    Ty.apply
                                      (Ty.path "core::ptr::non_null::NonNull")
                                      [ Ty.apply (Ty.path "alloc::rc::RcBox") [ T ] ],
                                    "as_ref",
                                    []
                                  |),
                                  [
                                    M.SubPointer.get_struct_record_field (|
                                      M.read (| self |),
                                      "alloc::rc::UniqueRc",
                                      "ptr"
                                    |)
                                  ]
                                |)
                              ]
                            |)
                          ]
                        |)
                      |) in
                    M.alloc (| Value.Tuple [] |)));
                fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "core::ops::drop::Drop"
        (Self T)
        (* Trait polymorphic types *) []
        (* Instance *) [ ("drop", InstanceField.Method (drop T)) ].
  End Impl_core_ops_drop_Drop_for_alloc_rc_UniqueRc_T.
End rc.
