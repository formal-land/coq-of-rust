(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module sync.
  Definition value_MAX_REFCOUNT : Value.t :=
    M.run
      ltac:(M.monadic
        (M.alloc (| M.rust_cast (M.read (| M.get_constant (| "core::num::MAX" |) |)) |))).
  
  Definition value_INTERNAL_OVERFLOW_ERROR : Value.t :=
    M.run ltac:(M.monadic (Value.String "Arc counter overflow")).
  
  (* StructRecord
    {
      name := "Arc";
      ty_params := [ "T"; "A" ];
      fields :=
        [
          ("ptr",
            Ty.apply
              (Ty.path "core::ptr::non_null::NonNull")
              [ Ty.apply (Ty.path "alloc::sync::ArcInner") [ T ] ]);
          ("phantom",
            Ty.apply
              (Ty.path "core::marker::PhantomData")
              [ Ty.apply (Ty.path "alloc::sync::ArcInner") [ T ] ]);
          ("alloc", A)
        ];
    } *)
  
  Module Impl_core_marker_Send_where_core_marker_Sized_T_where_core_marker_Sync_T_where_core_marker_Send_T_where_core_alloc_Allocator_A_where_core_marker_Send_A_for_alloc_sync_Arc_T_A.
    Definition Self (T A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::sync::Arc") [ T; A ].
    
    Axiom Implements :
      forall (T A : Ty.t),
      M.IsTraitInstance
        "core::marker::Send"
        (Self T A)
        (* Trait polymorphic types *) []
        (* Instance *) [].
  End Impl_core_marker_Send_where_core_marker_Sized_T_where_core_marker_Sync_T_where_core_marker_Send_T_where_core_alloc_Allocator_A_where_core_marker_Send_A_for_alloc_sync_Arc_T_A.
  
  Module Impl_core_marker_Sync_where_core_marker_Sized_T_where_core_marker_Sync_T_where_core_marker_Send_T_where_core_alloc_Allocator_A_where_core_marker_Sync_A_for_alloc_sync_Arc_T_A.
    Definition Self (T A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::sync::Arc") [ T; A ].
    
    Axiom Implements :
      forall (T A : Ty.t),
      M.IsTraitInstance
        "core::marker::Sync"
        (Self T A)
        (* Trait polymorphic types *) []
        (* Instance *) [].
  End Impl_core_marker_Sync_where_core_marker_Sized_T_where_core_marker_Sync_T_where_core_marker_Send_T_where_core_alloc_Allocator_A_where_core_marker_Sync_A_for_alloc_sync_Arc_T_A.
  
  Module Impl_core_panic_unwind_safe_UnwindSafe_where_core_panic_unwind_safe_RefUnwindSafe_T_where_core_marker_Sized_T_where_core_alloc_Allocator_A_where_core_panic_unwind_safe_UnwindSafe_A_for_alloc_sync_Arc_T_A.
    Definition Self (T A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::sync::Arc") [ T; A ].
    
    Axiom Implements :
      forall (T A : Ty.t),
      M.IsTraitInstance
        "core::panic::unwind_safe::UnwindSafe"
        (Self T A)
        (* Trait polymorphic types *) []
        (* Instance *) [].
  End Impl_core_panic_unwind_safe_UnwindSafe_where_core_panic_unwind_safe_RefUnwindSafe_T_where_core_marker_Sized_T_where_core_alloc_Allocator_A_where_core_panic_unwind_safe_UnwindSafe_A_for_alloc_sync_Arc_T_A.
  
  Module Impl_core_ops_unsize_CoerceUnsized_where_core_marker_Sized_T_where_core_marker_Unsize_T_U_where_core_marker_Sized_U_where_core_alloc_Allocator_A_alloc_sync_Arc_U_A_for_alloc_sync_Arc_T_A.
    Definition Self (T U A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::sync::Arc") [ T; A ].
    
    Axiom Implements :
      forall (T U A : Ty.t),
      M.IsTraitInstance
        "core::ops::unsize::CoerceUnsized"
        (Self T U A)
        (* Trait polymorphic types *) [ (* T *) Ty.apply (Ty.path "alloc::sync::Arc") [ U; A ] ]
        (* Instance *) [].
  End Impl_core_ops_unsize_CoerceUnsized_where_core_marker_Sized_T_where_core_marker_Unsize_T_U_where_core_marker_Sized_U_where_core_alloc_Allocator_A_alloc_sync_Arc_U_A_for_alloc_sync_Arc_T_A.
  
  Module Impl_core_ops_unsize_DispatchFromDyn_where_core_marker_Sized_T_where_core_marker_Unsize_T_U_where_core_marker_Sized_U_alloc_sync_Arc_U_alloc_alloc_Global_for_alloc_sync_Arc_T_alloc_alloc_Global.
    Definition Self (T U : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "alloc::sync::Arc") [ T; Ty.path "alloc::alloc::Global" ].
    
    Axiom Implements :
      forall (T U : Ty.t),
      M.IsTraitInstance
        "core::ops::unsize::DispatchFromDyn"
        (Self T U)
        (* Trait polymorphic types *)
        [ (* T *) Ty.apply (Ty.path "alloc::sync::Arc") [ U; Ty.path "alloc::alloc::Global" ] ]
        (* Instance *) [].
  End Impl_core_ops_unsize_DispatchFromDyn_where_core_marker_Sized_T_where_core_marker_Unsize_T_U_where_core_marker_Sized_U_alloc_sync_Arc_U_alloc_alloc_Global_for_alloc_sync_Arc_T_alloc_alloc_Global.
  
  Module Impl_alloc_sync_Arc_T_alloc_alloc_Global.
    Definition Self (T : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "alloc::sync::Arc") [ T; Ty.path "alloc::alloc::Global" ].
    
    (*
        unsafe fn from_inner(ptr: NonNull<ArcInner<T>>) -> Self {
            unsafe { Self::from_inner_in(ptr, Global) }
        }
    *)
    Definition from_inner (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match τ, α with
      | [], [ ptr ] =>
        ltac:(M.monadic
          (let ptr := M.alloc (| ptr |) in
          M.call_closure (|
            M.get_associated_function (|
              Ty.apply (Ty.path "alloc::sync::Arc") [ T; Ty.path "alloc::alloc::Global" ],
              "from_inner_in",
              []
            |),
            [ M.read (| ptr |); Value.StructTuple "alloc::alloc::Global" [] ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_from_inner :
      forall (T : Ty.t),
      M.IsAssociatedFunction (Self T) "from_inner" (from_inner T).
    
    (*
        unsafe fn from_ptr(ptr: *mut ArcInner<T>) -> Self {
            unsafe { Self::from_ptr_in(ptr, Global) }
        }
    *)
    Definition from_ptr (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match τ, α with
      | [], [ ptr ] =>
        ltac:(M.monadic
          (let ptr := M.alloc (| ptr |) in
          M.call_closure (|
            M.get_associated_function (|
              Ty.apply (Ty.path "alloc::sync::Arc") [ T; Ty.path "alloc::alloc::Global" ],
              "from_ptr_in",
              []
            |),
            [ M.read (| ptr |); Value.StructTuple "alloc::alloc::Global" [] ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_from_ptr :
      forall (T : Ty.t),
      M.IsAssociatedFunction (Self T) "from_ptr" (from_ptr T).
    (*
        pub fn new(data: T) -> Arc<T> {
            // Start the weak pointer count as 1 which is the weak pointer that's
            // held by all the strong pointers (kinda), see std/rc.rs for more info
            let x: Box<_> = Box::new(ArcInner {
                strong: atomic::AtomicUsize::new(1),
                weak: atomic::AtomicUsize::new(1),
                data,
            });
            unsafe { Self::from_inner(Box::leak(x).into()) }
        }
    *)
    Definition new (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match τ, α with
      | [], [ data ] =>
        ltac:(M.monadic
          (let data := M.alloc (| data |) in
          M.read (|
            let x :=
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "alloc::boxed::Box")
                      [
                        Ty.apply (Ty.path "alloc::sync::ArcInner") [ T ];
                        Ty.path "alloc::alloc::Global"
                      ],
                    "new",
                    []
                  |),
                  [
                    Value.StructRecord
                      "alloc::sync::ArcInner"
                      [
                        ("strong",
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::sync::atomic::AtomicUsize",
                              "new",
                              []
                            |),
                            [ Value.Integer 1 ]
                          |));
                        ("weak",
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::sync::atomic::AtomicUsize",
                              "new",
                              []
                            |),
                            [ Value.Integer 1 ]
                          |));
                        ("data", M.read (| data |))
                      ]
                  ]
                |)
              |) in
            M.alloc (|
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply (Ty.path "alloc::sync::Arc") [ T; Ty.path "alloc::alloc::Global" ],
                  "from_inner",
                  []
                |),
                [
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::convert::Into",
                      Ty.apply
                        (Ty.path "&mut")
                        [ Ty.apply (Ty.path "alloc::sync::ArcInner") [ T ] ],
                      [
                        Ty.apply
                          (Ty.path "core::ptr::non_null::NonNull")
                          [ Ty.apply (Ty.path "alloc::sync::ArcInner") [ T ] ]
                      ],
                      "into",
                      []
                    |),
                    [
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply
                            (Ty.path "alloc::boxed::Box")
                            [
                              Ty.apply (Ty.path "alloc::sync::ArcInner") [ T ];
                              Ty.path "alloc::alloc::Global"
                            ],
                          "leak",
                          []
                        |),
                        [ M.read (| x |) ]
                      |)
                    ]
                  |)
                ]
              |)
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_new : forall (T : Ty.t), M.IsAssociatedFunction (Self T) "new" (new T).
    
    (*
        pub fn new_cyclic<F>(data_fn: F) -> Arc<T>
        where
            F: FnOnce(&Weak<T>) -> T,
        {
            // Construct the inner in the "uninitialized" state with a single
            // weak reference.
            let uninit_ptr: NonNull<_> = Box::leak(Box::new(ArcInner {
                strong: atomic::AtomicUsize::new(0),
                weak: atomic::AtomicUsize::new(1),
                data: mem::MaybeUninit::<T>::uninit(),
            }))
            .into();
            let init_ptr: NonNull<ArcInner<T>> = uninit_ptr.cast();
    
            let weak = Weak { ptr: init_ptr, alloc: Global };
    
            // It's important we don't give up ownership of the weak pointer, or
            // else the memory might be freed by the time `data_fn` returns. If
            // we really wanted to pass ownership, we could create an additional
            // weak pointer for ourselves, but this would result in additional
            // updates to the weak reference count which might not be necessary
            // otherwise.
            let data = data_fn(&weak);
    
            // Now we can properly initialize the inner value and turn our weak
            // reference into a strong reference.
            let strong = unsafe {
                let inner = init_ptr.as_ptr();
                ptr::write(ptr::addr_of_mut!(( *inner).data), data);
    
                // The above write to the data field must be visible to any threads which
                // observe a non-zero strong count. Therefore we need at least "Release" ordering
                // in order to synchronize with the `compare_exchange_weak` in `Weak::upgrade`.
                //
                // "Acquire" ordering is not required. When considering the possible behaviours
                // of `data_fn` we only need to look at what it could do with a reference to a
                // non-upgradeable `Weak`:
                // - It can *clone* the `Weak`, increasing the weak reference count.
                // - It can drop those clones, decreasing the weak reference count (but never to zero).
                //
                // These side effects do not impact us in any way, and no other side effects are
                // possible with safe code alone.
                let prev_value = ( *inner).strong.fetch_add(1, Release);
                debug_assert_eq!(prev_value, 0, "No prior strong references should exist");
    
                Arc::from_inner(init_ptr)
            };
    
            // Strong references should collectively own a shared weak reference,
            // so don't run the destructor for our old weak reference.
            mem::forget(weak);
            strong
        }
    *)
    Definition new_cyclic (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match τ, α with
      | [ F ], [ data_fn ] =>
        ltac:(M.monadic
          (let data_fn := M.alloc (| data_fn |) in
          M.read (|
            let uninit_ptr :=
              M.alloc (|
                M.call_closure (|
                  M.get_trait_method (|
                    "core::convert::Into",
                    Ty.apply
                      (Ty.path "&mut")
                      [
                        Ty.apply
                          (Ty.path "alloc::sync::ArcInner")
                          [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ T ] ]
                      ],
                    [
                      Ty.apply
                        (Ty.path "core::ptr::non_null::NonNull")
                        [
                          Ty.apply
                            (Ty.path "alloc::sync::ArcInner")
                            [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ T ] ]
                        ]
                    ],
                    "into",
                    []
                  |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "alloc::boxed::Box")
                          [
                            Ty.apply
                              (Ty.path "alloc::sync::ArcInner")
                              [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ T ] ];
                            Ty.path "alloc::alloc::Global"
                          ],
                        "leak",
                        []
                      |),
                      [
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.apply
                              (Ty.path "alloc::boxed::Box")
                              [
                                Ty.apply
                                  (Ty.path "alloc::sync::ArcInner")
                                  [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ T ]
                                  ];
                                Ty.path "alloc::alloc::Global"
                              ],
                            "new",
                            []
                          |),
                          [
                            Value.StructRecord
                              "alloc::sync::ArcInner"
                              [
                                ("strong",
                                  M.call_closure (|
                                    M.get_associated_function (|
                                      Ty.path "core::sync::atomic::AtomicUsize",
                                      "new",
                                      []
                                    |),
                                    [ Value.Integer 0 ]
                                  |));
                                ("weak",
                                  M.call_closure (|
                                    M.get_associated_function (|
                                      Ty.path "core::sync::atomic::AtomicUsize",
                                      "new",
                                      []
                                    |),
                                    [ Value.Integer 1 ]
                                  |));
                                ("data",
                                  M.call_closure (|
                                    M.get_associated_function (|
                                      Ty.apply
                                        (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                        [ T ],
                                      "uninit",
                                      []
                                    |),
                                    []
                                  |))
                              ]
                          ]
                        |)
                      ]
                    |)
                  ]
                |)
              |) in
            let init_ptr :=
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "core::ptr::non_null::NonNull")
                      [
                        Ty.apply
                          (Ty.path "alloc::sync::ArcInner")
                          [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ T ] ]
                      ],
                    "cast",
                    [ Ty.apply (Ty.path "alloc::sync::ArcInner") [ T ] ]
                  |),
                  [ M.read (| uninit_ptr |) ]
                |)
              |) in
            let weak :=
              M.alloc (|
                Value.StructRecord
                  "alloc::sync::Weak"
                  [
                    ("ptr", M.read (| init_ptr |));
                    ("alloc", Value.StructTuple "alloc::alloc::Global" [])
                  ]
              |) in
            let data :=
              M.alloc (|
                M.call_closure (|
                  M.get_trait_method (|
                    "core::ops::function::FnOnce",
                    F,
                    [
                      Ty.tuple
                        [
                          Ty.apply
                            (Ty.path "&")
                            [
                              Ty.apply
                                (Ty.path "alloc::sync::Weak")
                                [ T; Ty.path "alloc::alloc::Global" ]
                            ]
                        ]
                    ],
                    "call_once",
                    []
                  |),
                  [ M.read (| data_fn |); Value.Tuple [ weak ] ]
                |)
              |) in
            let strong :=
              M.copy (|
                let inner :=
                  M.alloc (|
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "core::ptr::non_null::NonNull")
                          [ Ty.apply (Ty.path "alloc::sync::ArcInner") [ T ] ],
                        "as_ptr",
                        []
                      |),
                      [ M.read (| init_ptr |) ]
                    |)
                  |) in
                let _ :=
                  M.alloc (|
                    M.call_closure (|
                      M.get_function (| "core::ptr::write", [ T ] |),
                      [
                        M.SubPointer.get_struct_record_field (|
                          M.read (| inner |),
                          "alloc::sync::ArcInner",
                          "data"
                        |);
                        M.read (| data |)
                      ]
                    |)
                  |) in
                let prev_value :=
                  M.alloc (|
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.path "core::sync::atomic::AtomicUsize",
                        "fetch_add",
                        []
                      |),
                      [
                        M.SubPointer.get_struct_record_field (|
                          M.read (| inner |),
                          "alloc::sync::ArcInner",
                          "strong"
                        |);
                        Value.Integer 1;
                        Value.StructTuple "core::sync::atomic::Ordering::Release" []
                      ]
                    |)
                  |) in
                let _ :=
                  M.match_operator (|
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ := M.use (M.alloc (| Value.Bool true |)) in
                          let _ :=
                            M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          let _ :=
                            M.match_operator (|
                              M.alloc (|
                                Value.Tuple [ prev_value; M.alloc (| Value.Integer 0 |) ]
                              |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                    let left_val := M.copy (| γ0_0 |) in
                                    let right_val := M.copy (| γ0_1 |) in
                                    M.match_operator (|
                                      M.alloc (| Value.Tuple [] |),
                                      [
                                        fun γ =>
                                          ltac:(M.monadic
                                            (let γ :=
                                              M.use
                                                (M.alloc (|
                                                  UnOp.Pure.not
                                                    (BinOp.Pure.eq
                                                      (M.read (| M.read (| left_val |) |))
                                                      (M.read (| M.read (| right_val |) |)))
                                                |)) in
                                            let _ :=
                                              M.is_constant_or_break_match (|
                                                M.read (| γ |),
                                                Value.Bool true
                                              |) in
                                            M.alloc (|
                                              M.never_to_any (|
                                                M.read (|
                                                  let kind :=
                                                    M.alloc (|
                                                      Value.StructTuple
                                                        "core::panicking::AssertKind::Eq"
                                                        []
                                                    |) in
                                                  M.alloc (|
                                                    M.call_closure (|
                                                      M.get_function (|
                                                        "core::panicking::assert_failed",
                                                        [ Ty.path "usize"; Ty.path "usize" ]
                                                      |),
                                                      [
                                                        M.read (| kind |);
                                                        M.read (| left_val |);
                                                        M.read (| right_val |);
                                                        Value.StructTuple
                                                          "core::option::Option::Some"
                                                          [
                                                            M.call_closure (|
                                                              M.get_associated_function (|
                                                                Ty.path "core::fmt::Arguments",
                                                                "new_const",
                                                                []
                                                              |),
                                                              [
                                                                (* Unsize *)
                                                                M.pointer_coercion
                                                                  (M.alloc (|
                                                                    Value.Array
                                                                      [
                                                                        M.read (|
                                                                          Value.String
                                                                            "No prior strong references should exist"
                                                                        |)
                                                                      ]
                                                                  |))
                                                              ]
                                                            |)
                                                          ]
                                                      ]
                                                    |)
                                                  |)
                                                |)
                                              |)
                                            |)));
                                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                                      ]
                                    |)))
                              ]
                            |) in
                          M.alloc (| Value.Tuple [] |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply (Ty.path "alloc::sync::Arc") [ T; Ty.path "alloc::alloc::Global" ],
                      "from_inner",
                      []
                    |),
                    [ M.read (| init_ptr |) ]
                  |)
                |)
              |) in
            let _ :=
              M.alloc (|
                M.call_closure (|
                  M.get_function (|
                    "core::mem::forget",
                    [ Ty.apply (Ty.path "alloc::sync::Weak") [ T; Ty.path "alloc::alloc::Global" ] ]
                  |),
                  [ M.read (| weak |) ]
                |)
              |) in
            strong
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_new_cyclic :
      forall (T : Ty.t),
      M.IsAssociatedFunction (Self T) "new_cyclic" (new_cyclic T).
    
    (*
        pub fn new_uninit() -> Arc<mem::MaybeUninit<T>> {
            unsafe {
                Arc::from_ptr(Arc::allocate_for_layout(
                    Layout::new::<T>(),
                    |layout| Global.allocate(layout),
                    <*mut u8>::cast,
                ))
            }
        }
    *)
    Definition new_uninit (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match τ, α with
      | [], [] =>
        ltac:(M.monadic
          (M.call_closure (|
            M.get_associated_function (|
              Ty.apply
                (Ty.path "alloc::sync::Arc")
                [
                  Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ T ];
                  Ty.path "alloc::alloc::Global"
                ],
              "from_ptr",
              []
            |),
            [
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "alloc::sync::Arc")
                    [
                      Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ T ];
                      Ty.path "alloc::alloc::Global"
                    ],
                  "allocate_for_layout",
                  [
                    Ty.function
                      [ Ty.tuple [ Ty.path "core::alloc::layout::Layout" ] ]
                      (Ty.apply
                        (Ty.path "core::result::Result")
                        [
                          Ty.apply
                            (Ty.path "core::ptr::non_null::NonNull")
                            [ Ty.apply (Ty.path "slice") [ Ty.path "u8" ] ];
                          Ty.path "core::alloc::AllocError"
                        ]);
                    Ty.function
                      [ Ty.apply (Ty.path "*mut") [ Ty.path "u8" ] ]
                      (Ty.apply
                        (Ty.path "*mut")
                        [
                          Ty.apply
                            (Ty.path "alloc::sync::ArcInner")
                            [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ T ] ]
                        ])
                  ]
                |),
                [
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.path "core::alloc::layout::Layout",
                      "new",
                      [ T ]
                    |),
                    []
                  |);
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0 ] =>
                          M.match_operator (|
                            M.alloc (| α0 |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let layout := M.copy (| γ |) in
                                  M.call_closure (|
                                    M.get_trait_method (|
                                      "core::alloc::Allocator",
                                      Ty.path "alloc::alloc::Global",
                                      [],
                                      "allocate",
                                      []
                                    |),
                                    [
                                      M.alloc (| Value.StructTuple "alloc::alloc::Global" [] |);
                                      M.read (| layout |)
                                    ]
                                  |)))
                            ]
                          |)
                        | _ => M.impossible (||)
                        end));
                  M.get_associated_function (|
                    Ty.apply (Ty.path "*mut") [ Ty.path "u8" ],
                    "cast",
                    [
                      Ty.apply
                        (Ty.path "alloc::sync::ArcInner")
                        [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ T ] ]
                    ]
                  |)
                ]
              |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_new_uninit :
      forall (T : Ty.t),
      M.IsAssociatedFunction (Self T) "new_uninit" (new_uninit T).
    
    (*
        pub fn new_zeroed() -> Arc<mem::MaybeUninit<T>> {
            unsafe {
                Arc::from_ptr(Arc::allocate_for_layout(
                    Layout::new::<T>(),
                    |layout| Global.allocate_zeroed(layout),
                    <*mut u8>::cast,
                ))
            }
        }
    *)
    Definition new_zeroed (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match τ, α with
      | [], [] =>
        ltac:(M.monadic
          (M.call_closure (|
            M.get_associated_function (|
              Ty.apply
                (Ty.path "alloc::sync::Arc")
                [
                  Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ T ];
                  Ty.path "alloc::alloc::Global"
                ],
              "from_ptr",
              []
            |),
            [
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "alloc::sync::Arc")
                    [
                      Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ T ];
                      Ty.path "alloc::alloc::Global"
                    ],
                  "allocate_for_layout",
                  [
                    Ty.function
                      [ Ty.tuple [ Ty.path "core::alloc::layout::Layout" ] ]
                      (Ty.apply
                        (Ty.path "core::result::Result")
                        [
                          Ty.apply
                            (Ty.path "core::ptr::non_null::NonNull")
                            [ Ty.apply (Ty.path "slice") [ Ty.path "u8" ] ];
                          Ty.path "core::alloc::AllocError"
                        ]);
                    Ty.function
                      [ Ty.apply (Ty.path "*mut") [ Ty.path "u8" ] ]
                      (Ty.apply
                        (Ty.path "*mut")
                        [
                          Ty.apply
                            (Ty.path "alloc::sync::ArcInner")
                            [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ T ] ]
                        ])
                  ]
                |),
                [
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.path "core::alloc::layout::Layout",
                      "new",
                      [ T ]
                    |),
                    []
                  |);
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0 ] =>
                          M.match_operator (|
                            M.alloc (| α0 |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let layout := M.copy (| γ |) in
                                  M.call_closure (|
                                    M.get_trait_method (|
                                      "core::alloc::Allocator",
                                      Ty.path "alloc::alloc::Global",
                                      [],
                                      "allocate_zeroed",
                                      []
                                    |),
                                    [
                                      M.alloc (| Value.StructTuple "alloc::alloc::Global" [] |);
                                      M.read (| layout |)
                                    ]
                                  |)))
                            ]
                          |)
                        | _ => M.impossible (||)
                        end));
                  M.get_associated_function (|
                    Ty.apply (Ty.path "*mut") [ Ty.path "u8" ],
                    "cast",
                    [
                      Ty.apply
                        (Ty.path "alloc::sync::ArcInner")
                        [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ T ] ]
                    ]
                  |)
                ]
              |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_new_zeroed :
      forall (T : Ty.t),
      M.IsAssociatedFunction (Self T) "new_zeroed" (new_zeroed T).
    
    (*
        pub fn pin(data: T) -> Pin<Arc<T>> {
            unsafe { Pin::new_unchecked(Arc::new(data)) }
        }
    *)
    Definition pin (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match τ, α with
      | [], [ data ] =>
        ltac:(M.monadic
          (let data := M.alloc (| data |) in
          M.call_closure (|
            M.get_associated_function (|
              Ty.apply
                (Ty.path "core::pin::Pin")
                [ Ty.apply (Ty.path "alloc::sync::Arc") [ T; Ty.path "alloc::alloc::Global" ] ],
              "new_unchecked",
              []
            |),
            [
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply (Ty.path "alloc::sync::Arc") [ T; Ty.path "alloc::alloc::Global" ],
                  "new",
                  []
                |),
                [ M.read (| data |) ]
              |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_pin : forall (T : Ty.t), M.IsAssociatedFunction (Self T) "pin" (pin T).
    
    (*
        pub fn try_pin(data: T) -> Result<Pin<Arc<T>>, AllocError> {
            unsafe { Ok(Pin::new_unchecked(Arc::try_new(data)?)) }
        }
    *)
    Definition try_pin (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match τ, α with
      | [], [ data ] =>
        ltac:(M.monadic
          (let data := M.alloc (| data |) in
          M.catch_return (|
            ltac:(M.monadic
              (Value.StructTuple
                "core::result::Result::Ok"
                [
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "core::pin::Pin")
                        [
                          Ty.apply
                            (Ty.path "alloc::sync::Arc")
                            [ T; Ty.path "alloc::alloc::Global" ]
                        ],
                      "new_unchecked",
                      []
                    |),
                    [
                      M.read (|
                        M.match_operator (|
                          M.alloc (|
                            M.call_closure (|
                              M.get_trait_method (|
                                "core::ops::try_trait::Try",
                                Ty.apply
                                  (Ty.path "core::result::Result")
                                  [
                                    Ty.apply
                                      (Ty.path "alloc::sync::Arc")
                                      [ T; Ty.path "alloc::alloc::Global" ];
                                    Ty.path "core::alloc::AllocError"
                                  ],
                                [],
                                "branch",
                                []
                              |),
                              [
                                M.call_closure (|
                                  M.get_associated_function (|
                                    Ty.apply
                                      (Ty.path "alloc::sync::Arc")
                                      [ T; Ty.path "alloc::alloc::Global" ],
                                    "try_new",
                                    []
                                  |),
                                  [ M.read (| data |) ]
                                |)
                              ]
                            |)
                          |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ0_0 :=
                                  M.SubPointer.get_struct_tuple_field (|
                                    γ,
                                    "core::ops::control_flow::ControlFlow::Break",
                                    0
                                  |) in
                                let residual := M.copy (| γ0_0 |) in
                                M.alloc (|
                                  M.never_to_any (|
                                    M.read (|
                                      M.return_ (|
                                        M.call_closure (|
                                          M.get_trait_method (|
                                            "core::ops::try_trait::FromResidual",
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              [
                                                Ty.apply
                                                  (Ty.path "core::pin::Pin")
                                                  [
                                                    Ty.apply
                                                      (Ty.path "alloc::sync::Arc")
                                                      [ T; Ty.path "alloc::alloc::Global" ]
                                                  ];
                                                Ty.path "core::alloc::AllocError"
                                              ],
                                            [
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                [
                                                  Ty.path "core::convert::Infallible";
                                                  Ty.path "core::alloc::AllocError"
                                                ]
                                            ],
                                            "from_residual",
                                            []
                                          |),
                                          [ M.read (| residual |) ]
                                        |)
                                      |)
                                    |)
                                  |)
                                |)));
                            fun γ =>
                              ltac:(M.monadic
                                (let γ0_0 :=
                                  M.SubPointer.get_struct_tuple_field (|
                                    γ,
                                    "core::ops::control_flow::ControlFlow::Continue",
                                    0
                                  |) in
                                let val := M.copy (| γ0_0 |) in
                                val))
                          ]
                        |)
                      |)
                    ]
                  |)
                ]))
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_try_pin :
      forall (T : Ty.t),
      M.IsAssociatedFunction (Self T) "try_pin" (try_pin T).
    
    (*
        pub fn try_new(data: T) -> Result<Arc<T>, AllocError> {
            // Start the weak pointer count as 1 which is the weak pointer that's
            // held by all the strong pointers (kinda), see std/rc.rs for more info
            let x: Box<_> = Box::try_new(ArcInner {
                strong: atomic::AtomicUsize::new(1),
                weak: atomic::AtomicUsize::new(1),
                data,
            })?;
            unsafe { Ok(Self::from_inner(Box::leak(x).into())) }
        }
    *)
    Definition try_new (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match τ, α with
      | [], [ data ] =>
        ltac:(M.monadic
          (let data := M.alloc (| data |) in
          M.catch_return (|
            ltac:(M.monadic
              (M.read (|
                let x :=
                  M.copy (|
                    M.match_operator (|
                      M.alloc (|
                        M.call_closure (|
                          M.get_trait_method (|
                            "core::ops::try_trait::Try",
                            Ty.apply
                              (Ty.path "core::result::Result")
                              [
                                Ty.apply
                                  (Ty.path "alloc::boxed::Box")
                                  [
                                    Ty.apply (Ty.path "alloc::sync::ArcInner") [ T ];
                                    Ty.path "alloc::alloc::Global"
                                  ];
                                Ty.path "core::alloc::AllocError"
                              ],
                            [],
                            "branch",
                            []
                          |),
                          [
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "alloc::boxed::Box")
                                  [
                                    Ty.apply (Ty.path "alloc::sync::ArcInner") [ T ];
                                    Ty.path "alloc::alloc::Global"
                                  ],
                                "try_new",
                                []
                              |),
                              [
                                Value.StructRecord
                                  "alloc::sync::ArcInner"
                                  [
                                    ("strong",
                                      M.call_closure (|
                                        M.get_associated_function (|
                                          Ty.path "core::sync::atomic::AtomicUsize",
                                          "new",
                                          []
                                        |),
                                        [ Value.Integer 1 ]
                                      |));
                                    ("weak",
                                      M.call_closure (|
                                        M.get_associated_function (|
                                          Ty.path "core::sync::atomic::AtomicUsize",
                                          "new",
                                          []
                                        |),
                                        [ Value.Integer 1 ]
                                      |));
                                    ("data", M.read (| data |))
                                  ]
                              ]
                            |)
                          ]
                        |)
                      |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "core::ops::control_flow::ControlFlow::Break",
                                0
                              |) in
                            let residual := M.copy (| γ0_0 |) in
                            M.alloc (|
                              M.never_to_any (|
                                M.read (|
                                  M.return_ (|
                                    M.call_closure (|
                                      M.get_trait_method (|
                                        "core::ops::try_trait::FromResidual",
                                        Ty.apply
                                          (Ty.path "core::result::Result")
                                          [
                                            Ty.apply
                                              (Ty.path "alloc::sync::Arc")
                                              [ T; Ty.path "alloc::alloc::Global" ];
                                            Ty.path "core::alloc::AllocError"
                                          ],
                                        [
                                          Ty.apply
                                            (Ty.path "core::result::Result")
                                            [
                                              Ty.path "core::convert::Infallible";
                                              Ty.path "core::alloc::AllocError"
                                            ]
                                        ],
                                        "from_residual",
                                        []
                                      |),
                                      [ M.read (| residual |) ]
                                    |)
                                  |)
                                |)
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "core::ops::control_flow::ControlFlow::Continue",
                                0
                              |) in
                            let val := M.copy (| γ0_0 |) in
                            val))
                      ]
                    |)
                  |) in
                M.alloc (|
                  Value.StructTuple
                    "core::result::Result::Ok"
                    [
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply
                            (Ty.path "alloc::sync::Arc")
                            [ T; Ty.path "alloc::alloc::Global" ],
                          "from_inner",
                          []
                        |),
                        [
                          M.call_closure (|
                            M.get_trait_method (|
                              "core::convert::Into",
                              Ty.apply
                                (Ty.path "&mut")
                                [ Ty.apply (Ty.path "alloc::sync::ArcInner") [ T ] ],
                              [
                                Ty.apply
                                  (Ty.path "core::ptr::non_null::NonNull")
                                  [ Ty.apply (Ty.path "alloc::sync::ArcInner") [ T ] ]
                              ],
                              "into",
                              []
                            |),
                            [
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "alloc::boxed::Box")
                                    [
                                      Ty.apply (Ty.path "alloc::sync::ArcInner") [ T ];
                                      Ty.path "alloc::alloc::Global"
                                    ],
                                  "leak",
                                  []
                                |),
                                [ M.read (| x |) ]
                              |)
                            ]
                          |)
                        ]
                      |)
                    ]
                |)
              |)))
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_try_new :
      forall (T : Ty.t),
      M.IsAssociatedFunction (Self T) "try_new" (try_new T).
    
    (*
        pub fn try_new_uninit() -> Result<Arc<mem::MaybeUninit<T>>, AllocError> {
            unsafe {
                Ok(Arc::from_ptr(Arc::try_allocate_for_layout(
                    Layout::new::<T>(),
                    |layout| Global.allocate(layout),
                    <*mut u8>::cast,
                )?))
            }
        }
    *)
    Definition try_new_uninit (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match τ, α with
      | [], [] =>
        ltac:(M.monadic
          (M.catch_return (|
            ltac:(M.monadic
              (Value.StructTuple
                "core::result::Result::Ok"
                [
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "alloc::sync::Arc")
                        [
                          Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ T ];
                          Ty.path "alloc::alloc::Global"
                        ],
                      "from_ptr",
                      []
                    |),
                    [
                      M.read (|
                        M.match_operator (|
                          M.alloc (|
                            M.call_closure (|
                              M.get_trait_method (|
                                "core::ops::try_trait::Try",
                                Ty.apply
                                  (Ty.path "core::result::Result")
                                  [
                                    Ty.apply
                                      (Ty.path "*mut")
                                      [
                                        Ty.apply
                                          (Ty.path "alloc::sync::ArcInner")
                                          [
                                            Ty.apply
                                              (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                              [ T ]
                                          ]
                                      ];
                                    Ty.path "core::alloc::AllocError"
                                  ],
                                [],
                                "branch",
                                []
                              |),
                              [
                                M.call_closure (|
                                  M.get_associated_function (|
                                    Ty.apply
                                      (Ty.path "alloc::sync::Arc")
                                      [
                                        Ty.apply
                                          (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                          [ T ];
                                        Ty.path "alloc::alloc::Global"
                                      ],
                                    "try_allocate_for_layout",
                                    [
                                      Ty.function
                                        [ Ty.tuple [ Ty.path "core::alloc::layout::Layout" ] ]
                                        (Ty.apply
                                          (Ty.path "core::result::Result")
                                          [
                                            Ty.apply
                                              (Ty.path "core::ptr::non_null::NonNull")
                                              [ Ty.apply (Ty.path "slice") [ Ty.path "u8" ] ];
                                            Ty.path "core::alloc::AllocError"
                                          ]);
                                      Ty.function
                                        [ Ty.apply (Ty.path "*mut") [ Ty.path "u8" ] ]
                                        (Ty.apply
                                          (Ty.path "*mut")
                                          [
                                            Ty.apply
                                              (Ty.path "alloc::sync::ArcInner")
                                              [
                                                Ty.apply
                                                  (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                                  [ T ]
                                              ]
                                          ])
                                    ]
                                  |),
                                  [
                                    M.call_closure (|
                                      M.get_associated_function (|
                                        Ty.path "core::alloc::layout::Layout",
                                        "new",
                                        [ T ]
                                      |),
                                      []
                                    |);
                                    M.closure
                                      (fun γ =>
                                        ltac:(M.monadic
                                          match γ with
                                          | [ α0 ] =>
                                            M.match_operator (|
                                              M.alloc (| α0 |),
                                              [
                                                fun γ =>
                                                  ltac:(M.monadic
                                                    (let layout := M.copy (| γ |) in
                                                    M.call_closure (|
                                                      M.get_trait_method (|
                                                        "core::alloc::Allocator",
                                                        Ty.path "alloc::alloc::Global",
                                                        [],
                                                        "allocate",
                                                        []
                                                      |),
                                                      [
                                                        M.alloc (|
                                                          Value.StructTuple
                                                            "alloc::alloc::Global"
                                                            []
                                                        |);
                                                        M.read (| layout |)
                                                      ]
                                                    |)))
                                              ]
                                            |)
                                          | _ => M.impossible (||)
                                          end));
                                    M.get_associated_function (|
                                      Ty.apply (Ty.path "*mut") [ Ty.path "u8" ],
                                      "cast",
                                      [
                                        Ty.apply
                                          (Ty.path "alloc::sync::ArcInner")
                                          [
                                            Ty.apply
                                              (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                              [ T ]
                                          ]
                                      ]
                                    |)
                                  ]
                                |)
                              ]
                            |)
                          |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ0_0 :=
                                  M.SubPointer.get_struct_tuple_field (|
                                    γ,
                                    "core::ops::control_flow::ControlFlow::Break",
                                    0
                                  |) in
                                let residual := M.copy (| γ0_0 |) in
                                M.alloc (|
                                  M.never_to_any (|
                                    M.read (|
                                      M.return_ (|
                                        M.call_closure (|
                                          M.get_trait_method (|
                                            "core::ops::try_trait::FromResidual",
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              [
                                                Ty.apply
                                                  (Ty.path "alloc::sync::Arc")
                                                  [
                                                    Ty.apply
                                                      (Ty.path
                                                        "core::mem::maybe_uninit::MaybeUninit")
                                                      [ T ];
                                                    Ty.path "alloc::alloc::Global"
                                                  ];
                                                Ty.path "core::alloc::AllocError"
                                              ],
                                            [
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                [
                                                  Ty.path "core::convert::Infallible";
                                                  Ty.path "core::alloc::AllocError"
                                                ]
                                            ],
                                            "from_residual",
                                            []
                                          |),
                                          [ M.read (| residual |) ]
                                        |)
                                      |)
                                    |)
                                  |)
                                |)));
                            fun γ =>
                              ltac:(M.monadic
                                (let γ0_0 :=
                                  M.SubPointer.get_struct_tuple_field (|
                                    γ,
                                    "core::ops::control_flow::ControlFlow::Continue",
                                    0
                                  |) in
                                let val := M.copy (| γ0_0 |) in
                                val))
                          ]
                        |)
                      |)
                    ]
                  |)
                ]))
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_try_new_uninit :
      forall (T : Ty.t),
      M.IsAssociatedFunction (Self T) "try_new_uninit" (try_new_uninit T).
    
    (*
        pub fn try_new_zeroed() -> Result<Arc<mem::MaybeUninit<T>>, AllocError> {
            unsafe {
                Ok(Arc::from_ptr(Arc::try_allocate_for_layout(
                    Layout::new::<T>(),
                    |layout| Global.allocate_zeroed(layout),
                    <*mut u8>::cast,
                )?))
            }
        }
    *)
    Definition try_new_zeroed (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match τ, α with
      | [], [] =>
        ltac:(M.monadic
          (M.catch_return (|
            ltac:(M.monadic
              (Value.StructTuple
                "core::result::Result::Ok"
                [
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "alloc::sync::Arc")
                        [
                          Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ T ];
                          Ty.path "alloc::alloc::Global"
                        ],
                      "from_ptr",
                      []
                    |),
                    [
                      M.read (|
                        M.match_operator (|
                          M.alloc (|
                            M.call_closure (|
                              M.get_trait_method (|
                                "core::ops::try_trait::Try",
                                Ty.apply
                                  (Ty.path "core::result::Result")
                                  [
                                    Ty.apply
                                      (Ty.path "*mut")
                                      [
                                        Ty.apply
                                          (Ty.path "alloc::sync::ArcInner")
                                          [
                                            Ty.apply
                                              (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                              [ T ]
                                          ]
                                      ];
                                    Ty.path "core::alloc::AllocError"
                                  ],
                                [],
                                "branch",
                                []
                              |),
                              [
                                M.call_closure (|
                                  M.get_associated_function (|
                                    Ty.apply
                                      (Ty.path "alloc::sync::Arc")
                                      [
                                        Ty.apply
                                          (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                          [ T ];
                                        Ty.path "alloc::alloc::Global"
                                      ],
                                    "try_allocate_for_layout",
                                    [
                                      Ty.function
                                        [ Ty.tuple [ Ty.path "core::alloc::layout::Layout" ] ]
                                        (Ty.apply
                                          (Ty.path "core::result::Result")
                                          [
                                            Ty.apply
                                              (Ty.path "core::ptr::non_null::NonNull")
                                              [ Ty.apply (Ty.path "slice") [ Ty.path "u8" ] ];
                                            Ty.path "core::alloc::AllocError"
                                          ]);
                                      Ty.function
                                        [ Ty.apply (Ty.path "*mut") [ Ty.path "u8" ] ]
                                        (Ty.apply
                                          (Ty.path "*mut")
                                          [
                                            Ty.apply
                                              (Ty.path "alloc::sync::ArcInner")
                                              [
                                                Ty.apply
                                                  (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                                  [ T ]
                                              ]
                                          ])
                                    ]
                                  |),
                                  [
                                    M.call_closure (|
                                      M.get_associated_function (|
                                        Ty.path "core::alloc::layout::Layout",
                                        "new",
                                        [ T ]
                                      |),
                                      []
                                    |);
                                    M.closure
                                      (fun γ =>
                                        ltac:(M.monadic
                                          match γ with
                                          | [ α0 ] =>
                                            M.match_operator (|
                                              M.alloc (| α0 |),
                                              [
                                                fun γ =>
                                                  ltac:(M.monadic
                                                    (let layout := M.copy (| γ |) in
                                                    M.call_closure (|
                                                      M.get_trait_method (|
                                                        "core::alloc::Allocator",
                                                        Ty.path "alloc::alloc::Global",
                                                        [],
                                                        "allocate_zeroed",
                                                        []
                                                      |),
                                                      [
                                                        M.alloc (|
                                                          Value.StructTuple
                                                            "alloc::alloc::Global"
                                                            []
                                                        |);
                                                        M.read (| layout |)
                                                      ]
                                                    |)))
                                              ]
                                            |)
                                          | _ => M.impossible (||)
                                          end));
                                    M.get_associated_function (|
                                      Ty.apply (Ty.path "*mut") [ Ty.path "u8" ],
                                      "cast",
                                      [
                                        Ty.apply
                                          (Ty.path "alloc::sync::ArcInner")
                                          [
                                            Ty.apply
                                              (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                              [ T ]
                                          ]
                                      ]
                                    |)
                                  ]
                                |)
                              ]
                            |)
                          |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ0_0 :=
                                  M.SubPointer.get_struct_tuple_field (|
                                    γ,
                                    "core::ops::control_flow::ControlFlow::Break",
                                    0
                                  |) in
                                let residual := M.copy (| γ0_0 |) in
                                M.alloc (|
                                  M.never_to_any (|
                                    M.read (|
                                      M.return_ (|
                                        M.call_closure (|
                                          M.get_trait_method (|
                                            "core::ops::try_trait::FromResidual",
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              [
                                                Ty.apply
                                                  (Ty.path "alloc::sync::Arc")
                                                  [
                                                    Ty.apply
                                                      (Ty.path
                                                        "core::mem::maybe_uninit::MaybeUninit")
                                                      [ T ];
                                                    Ty.path "alloc::alloc::Global"
                                                  ];
                                                Ty.path "core::alloc::AllocError"
                                              ],
                                            [
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                [
                                                  Ty.path "core::convert::Infallible";
                                                  Ty.path "core::alloc::AllocError"
                                                ]
                                            ],
                                            "from_residual",
                                            []
                                          |),
                                          [ M.read (| residual |) ]
                                        |)
                                      |)
                                    |)
                                  |)
                                |)));
                            fun γ =>
                              ltac:(M.monadic
                                (let γ0_0 :=
                                  M.SubPointer.get_struct_tuple_field (|
                                    γ,
                                    "core::ops::control_flow::ControlFlow::Continue",
                                    0
                                  |) in
                                let val := M.copy (| γ0_0 |) in
                                val))
                          ]
                        |)
                      |)
                    ]
                  |)
                ]))
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_try_new_zeroed :
      forall (T : Ty.t),
      M.IsAssociatedFunction (Self T) "try_new_zeroed" (try_new_zeroed T).
    (*
        pub unsafe fn from_raw(ptr: *const T) -> Self {
            unsafe { Arc::from_raw_in(ptr, Global) }
        }
    *)
    Definition from_raw (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match τ, α with
      | [], [ ptr ] =>
        ltac:(M.monadic
          (let ptr := M.alloc (| ptr |) in
          M.call_closure (|
            M.get_associated_function (|
              Ty.apply (Ty.path "alloc::sync::Arc") [ T; Ty.path "alloc::alloc::Global" ],
              "from_raw_in",
              []
            |),
            [ M.read (| ptr |); Value.StructTuple "alloc::alloc::Global" [] ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_from_raw :
      forall (T : Ty.t),
      M.IsAssociatedFunction (Self T) "from_raw" (from_raw T).
    
    (*
        pub unsafe fn increment_strong_count(ptr: *const T) {
            unsafe { Arc::increment_strong_count_in(ptr, Global) }
        }
    *)
    Definition increment_strong_count (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match τ, α with
      | [], [ ptr ] =>
        ltac:(M.monadic
          (let ptr := M.alloc (| ptr |) in
          M.call_closure (|
            M.get_associated_function (|
              Ty.apply (Ty.path "alloc::sync::Arc") [ T; Ty.path "alloc::alloc::Global" ],
              "increment_strong_count_in",
              []
            |),
            [ M.read (| ptr |); Value.StructTuple "alloc::alloc::Global" [] ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_increment_strong_count :
      forall (T : Ty.t),
      M.IsAssociatedFunction (Self T) "increment_strong_count" (increment_strong_count T).
    
    (*
        pub unsafe fn decrement_strong_count(ptr: *const T) {
            unsafe { Arc::decrement_strong_count_in(ptr, Global) }
        }
    *)
    Definition decrement_strong_count (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match τ, α with
      | [], [ ptr ] =>
        ltac:(M.monadic
          (let ptr := M.alloc (| ptr |) in
          M.call_closure (|
            M.get_associated_function (|
              Ty.apply (Ty.path "alloc::sync::Arc") [ T; Ty.path "alloc::alloc::Global" ],
              "decrement_strong_count_in",
              []
            |),
            [ M.read (| ptr |); Value.StructTuple "alloc::alloc::Global" [] ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_decrement_strong_count :
      forall (T : Ty.t),
      M.IsAssociatedFunction (Self T) "decrement_strong_count" (decrement_strong_count T).
    (*
        unsafe fn allocate_for_layout(
            value_layout: Layout,
            allocate: impl FnOnce(Layout) -> Result<NonNull<[u8]>, AllocError>,
            mem_to_arcinner: impl FnOnce( *mut u8) -> *mut ArcInner<T>,
        ) -> *mut ArcInner<T> {
            let layout = arcinner_layout_for_value_layout(value_layout);
    
            let ptr = allocate(layout).unwrap_or_else(|_| handle_alloc_error(layout));
    
            unsafe { Self::initialize_arcinner(ptr, layout, mem_to_arcinner) }
        }
    *)
    Definition allocate_for_layout (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match τ, α with
      | [
            impl_FnOnce_Layout__arrow_Result_NonNull__u8____AllocError_;
            impl_FnOnce__mut_u8__arrow__mut_ArcInner_T_
          ],
          [ value_layout; allocate; mem_to_arcinner ] =>
        ltac:(M.monadic
          (let value_layout := M.alloc (| value_layout |) in
          let allocate := M.alloc (| allocate |) in
          let mem_to_arcinner := M.alloc (| mem_to_arcinner |) in
          M.read (|
            let layout :=
              M.alloc (|
                M.call_closure (|
                  M.get_function (| "alloc::sync::arcinner_layout_for_value_layout", [] |),
                  [ M.read (| value_layout |) ]
                |)
              |) in
            let ptr :=
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "core::result::Result")
                      [
                        Ty.apply
                          (Ty.path "core::ptr::non_null::NonNull")
                          [ Ty.apply (Ty.path "slice") [ Ty.path "u8" ] ];
                        Ty.path "core::alloc::AllocError"
                      ],
                    "unwrap_or_else",
                    [
                      Ty.function
                        [ Ty.tuple [ Ty.path "core::alloc::AllocError" ] ]
                        (Ty.apply
                          (Ty.path "core::ptr::non_null::NonNull")
                          [ Ty.apply (Ty.path "slice") [ Ty.path "u8" ] ])
                    ]
                  |),
                  [
                    M.call_closure (|
                      M.get_trait_method (|
                        "core::ops::function::FnOnce",
                        impl_FnOnce_Layout__arrow_Result_NonNull__u8____AllocError_,
                        [ Ty.tuple [ Ty.path "core::alloc::layout::Layout" ] ],
                        "call_once",
                        []
                      |),
                      [ M.read (| allocate |); Value.Tuple [ M.read (| layout |) ] ]
                    |);
                    M.closure
                      (fun γ =>
                        ltac:(M.monadic
                          match γ with
                          | [ α0 ] =>
                            M.match_operator (|
                              M.alloc (| α0 |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (M.never_to_any (|
                                      M.call_closure (|
                                        M.get_function (| "alloc::alloc::handle_alloc_error", [] |),
                                        [ M.read (| layout |) ]
                                      |)
                                    |)))
                              ]
                            |)
                          | _ => M.impossible (||)
                          end))
                  ]
                |)
              |) in
            M.alloc (|
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply (Ty.path "alloc::sync::Arc") [ T; Ty.path "alloc::alloc::Global" ],
                  "initialize_arcinner",
                  [ impl_FnOnce__mut_u8__arrow__mut_ArcInner_T_ ]
                |),
                [ M.read (| ptr |); M.read (| layout |); M.read (| mem_to_arcinner |) ]
              |)
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_allocate_for_layout :
      forall (T : Ty.t),
      M.IsAssociatedFunction (Self T) "allocate_for_layout" (allocate_for_layout T).
    
    (*
        unsafe fn try_allocate_for_layout(
            value_layout: Layout,
            allocate: impl FnOnce(Layout) -> Result<NonNull<[u8]>, AllocError>,
            mem_to_arcinner: impl FnOnce( *mut u8) -> *mut ArcInner<T>,
        ) -> Result<*mut ArcInner<T>, AllocError> {
            let layout = arcinner_layout_for_value_layout(value_layout);
    
            let ptr = allocate(layout)?;
    
            let inner = unsafe { Self::initialize_arcinner(ptr, layout, mem_to_arcinner) };
    
            Ok(inner)
        }
    *)
    Definition try_allocate_for_layout (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match τ, α with
      | [
            impl_FnOnce_Layout__arrow_Result_NonNull__u8____AllocError_;
            impl_FnOnce__mut_u8__arrow__mut_ArcInner_T_
          ],
          [ value_layout; allocate; mem_to_arcinner ] =>
        ltac:(M.monadic
          (let value_layout := M.alloc (| value_layout |) in
          let allocate := M.alloc (| allocate |) in
          let mem_to_arcinner := M.alloc (| mem_to_arcinner |) in
          M.catch_return (|
            ltac:(M.monadic
              (M.read (|
                let layout :=
                  M.alloc (|
                    M.call_closure (|
                      M.get_function (| "alloc::sync::arcinner_layout_for_value_layout", [] |),
                      [ M.read (| value_layout |) ]
                    |)
                  |) in
                let ptr :=
                  M.copy (|
                    M.match_operator (|
                      M.alloc (|
                        M.call_closure (|
                          M.get_trait_method (|
                            "core::ops::try_trait::Try",
                            Ty.apply
                              (Ty.path "core::result::Result")
                              [
                                Ty.apply
                                  (Ty.path "core::ptr::non_null::NonNull")
                                  [ Ty.apply (Ty.path "slice") [ Ty.path "u8" ] ];
                                Ty.path "core::alloc::AllocError"
                              ],
                            [],
                            "branch",
                            []
                          |),
                          [
                            M.call_closure (|
                              M.get_trait_method (|
                                "core::ops::function::FnOnce",
                                impl_FnOnce_Layout__arrow_Result_NonNull__u8____AllocError_,
                                [ Ty.tuple [ Ty.path "core::alloc::layout::Layout" ] ],
                                "call_once",
                                []
                              |),
                              [ M.read (| allocate |); Value.Tuple [ M.read (| layout |) ] ]
                            |)
                          ]
                        |)
                      |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "core::ops::control_flow::ControlFlow::Break",
                                0
                              |) in
                            let residual := M.copy (| γ0_0 |) in
                            M.alloc (|
                              M.never_to_any (|
                                M.read (|
                                  M.return_ (|
                                    M.call_closure (|
                                      M.get_trait_method (|
                                        "core::ops::try_trait::FromResidual",
                                        Ty.apply
                                          (Ty.path "core::result::Result")
                                          [
                                            Ty.apply
                                              (Ty.path "*mut")
                                              [ Ty.apply (Ty.path "alloc::sync::ArcInner") [ T ] ];
                                            Ty.path "core::alloc::AllocError"
                                          ],
                                        [
                                          Ty.apply
                                            (Ty.path "core::result::Result")
                                            [
                                              Ty.path "core::convert::Infallible";
                                              Ty.path "core::alloc::AllocError"
                                            ]
                                        ],
                                        "from_residual",
                                        []
                                      |),
                                      [ M.read (| residual |) ]
                                    |)
                                  |)
                                |)
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "core::ops::control_flow::ControlFlow::Continue",
                                0
                              |) in
                            let val := M.copy (| γ0_0 |) in
                            val))
                      ]
                    |)
                  |) in
                let inner :=
                  M.alloc (|
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "alloc::sync::Arc") [ T; Ty.path "alloc::alloc::Global" ],
                        "initialize_arcinner",
                        [ impl_FnOnce__mut_u8__arrow__mut_ArcInner_T_ ]
                      |),
                      [ M.read (| ptr |); M.read (| layout |); M.read (| mem_to_arcinner |) ]
                    |)
                  |) in
                M.alloc (| Value.StructTuple "core::result::Result::Ok" [ M.read (| inner |) ] |)
              |)))
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_try_allocate_for_layout :
      forall (T : Ty.t),
      M.IsAssociatedFunction (Self T) "try_allocate_for_layout" (try_allocate_for_layout T).
    
    (*
        unsafe fn initialize_arcinner(
            ptr: NonNull<[u8]>,
            layout: Layout,
            mem_to_arcinner: impl FnOnce( *mut u8) -> *mut ArcInner<T>,
        ) -> *mut ArcInner<T> {
            let inner = mem_to_arcinner(ptr.as_non_null_ptr().as_ptr());
            debug_assert_eq!(unsafe { Layout::for_value(&*inner) }, layout);
    
            unsafe {
                ptr::write(&mut ( *inner).strong, atomic::AtomicUsize::new(1));
                ptr::write(&mut ( *inner).weak, atomic::AtomicUsize::new(1));
            }
    
            inner
        }
    *)
    Definition initialize_arcinner (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match τ, α with
      | [ impl_FnOnce__mut_u8__arrow__mut_ArcInner_T_ ], [ ptr; layout; mem_to_arcinner ] =>
        ltac:(M.monadic
          (let ptr := M.alloc (| ptr |) in
          let layout := M.alloc (| layout |) in
          let mem_to_arcinner := M.alloc (| mem_to_arcinner |) in
          M.read (|
            let inner :=
              M.alloc (|
                M.call_closure (|
                  M.get_trait_method (|
                    "core::ops::function::FnOnce",
                    impl_FnOnce__mut_u8__arrow__mut_ArcInner_T_,
                    [ Ty.tuple [ Ty.apply (Ty.path "*mut") [ Ty.path "u8" ] ] ],
                    "call_once",
                    []
                  |),
                  [
                    M.read (| mem_to_arcinner |);
                    Value.Tuple
                      [
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.apply (Ty.path "core::ptr::non_null::NonNull") [ Ty.path "u8" ],
                            "as_ptr",
                            []
                          |),
                          [
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "core::ptr::non_null::NonNull")
                                  [ Ty.apply (Ty.path "slice") [ Ty.path "u8" ] ],
                                "as_non_null_ptr",
                                []
                              |),
                              [ M.read (| ptr |) ]
                            |)
                          ]
                        |)
                      ]
                  ]
                |)
              |) in
            let _ :=
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.use (M.alloc (| Value.Bool true |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      let _ :=
                        M.match_operator (|
                          M.alloc (|
                            Value.Tuple
                              [
                                M.alloc (|
                                  M.call_closure (|
                                    M.get_associated_function (|
                                      Ty.path "core::alloc::layout::Layout",
                                      "for_value",
                                      [ Ty.apply (Ty.path "alloc::sync::ArcInner") [ T ] ]
                                    |),
                                    [ M.read (| inner |) ]
                                  |)
                                |);
                                layout
                              ]
                          |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                                let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                let left_val := M.copy (| γ0_0 |) in
                                let right_val := M.copy (| γ0_1 |) in
                                M.match_operator (|
                                  M.alloc (| Value.Tuple [] |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ :=
                                          M.use
                                            (M.alloc (|
                                              UnOp.Pure.not
                                                (M.call_closure (|
                                                  M.get_trait_method (|
                                                    "core::cmp::PartialEq",
                                                    Ty.path "core::alloc::layout::Layout",
                                                    [ Ty.path "core::alloc::layout::Layout" ],
                                                    "eq",
                                                    []
                                                  |),
                                                  [ M.read (| left_val |); M.read (| right_val |) ]
                                                |))
                                            |)) in
                                        let _ :=
                                          M.is_constant_or_break_match (|
                                            M.read (| γ |),
                                            Value.Bool true
                                          |) in
                                        M.alloc (|
                                          M.never_to_any (|
                                            M.read (|
                                              let kind :=
                                                M.alloc (|
                                                  Value.StructTuple
                                                    "core::panicking::AssertKind::Eq"
                                                    []
                                                |) in
                                              M.alloc (|
                                                M.call_closure (|
                                                  M.get_function (|
                                                    "core::panicking::assert_failed",
                                                    [
                                                      Ty.path "core::alloc::layout::Layout";
                                                      Ty.path "core::alloc::layout::Layout"
                                                    ]
                                                  |),
                                                  [
                                                    M.read (| kind |);
                                                    M.read (| left_val |);
                                                    M.read (| right_val |);
                                                    Value.StructTuple
                                                      "core::option::Option::None"
                                                      []
                                                  ]
                                                |)
                                              |)
                                            |)
                                          |)
                                        |)));
                                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                                  ]
                                |)))
                          ]
                        |) in
                      M.alloc (| Value.Tuple [] |)));
                  fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                ]
              |) in
            let _ :=
              let _ :=
                M.alloc (|
                  M.call_closure (|
                    M.get_function (|
                      "core::ptr::write",
                      [ Ty.path "core::sync::atomic::AtomicUsize" ]
                    |),
                    [
                      M.SubPointer.get_struct_record_field (|
                        M.read (| inner |),
                        "alloc::sync::ArcInner",
                        "strong"
                      |);
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::sync::atomic::AtomicUsize",
                          "new",
                          []
                        |),
                        [ Value.Integer 1 ]
                      |)
                    ]
                  |)
                |) in
              let _ :=
                M.alloc (|
                  M.call_closure (|
                    M.get_function (|
                      "core::ptr::write",
                      [ Ty.path "core::sync::atomic::AtomicUsize" ]
                    |),
                    [
                      M.SubPointer.get_struct_record_field (|
                        M.read (| inner |),
                        "alloc::sync::ArcInner",
                        "weak"
                      |);
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::sync::atomic::AtomicUsize",
                          "new",
                          []
                        |),
                        [ Value.Integer 1 ]
                      |)
                    ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |) in
            inner
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_initialize_arcinner :
      forall (T : Ty.t),
      M.IsAssociatedFunction (Self T) "initialize_arcinner" (initialize_arcinner T).
  End Impl_alloc_sync_Arc_T_alloc_alloc_Global.
  
  Module Impl_alloc_sync_Arc_T_A.
    Definition Self (T A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::sync::Arc") [ T; A ].
    
    (*
        unsafe fn from_inner_in(ptr: NonNull<ArcInner<T>>, alloc: A) -> Self {
            Self { ptr, phantom: PhantomData, alloc }
        }
    *)
    Definition from_inner_in (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match τ, α with
      | [], [ ptr; alloc ] =>
        ltac:(M.monadic
          (let ptr := M.alloc (| ptr |) in
          let alloc := M.alloc (| alloc |) in
          Value.StructRecord
            "alloc::sync::Arc"
            [
              ("ptr", M.read (| ptr |));
              ("phantom", Value.StructTuple "core::marker::PhantomData" []);
              ("alloc", M.read (| alloc |))
            ]))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_from_inner_in :
      forall (T A : Ty.t),
      M.IsAssociatedFunction (Self T A) "from_inner_in" (from_inner_in T A).
    
    (*
        unsafe fn from_ptr_in(ptr: *mut ArcInner<T>, alloc: A) -> Self {
            unsafe { Self::from_inner_in(NonNull::new_unchecked(ptr), alloc) }
        }
    *)
    Definition from_ptr_in (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match τ, α with
      | [], [ ptr; alloc ] =>
        ltac:(M.monadic
          (let ptr := M.alloc (| ptr |) in
          let alloc := M.alloc (| alloc |) in
          M.call_closure (|
            M.get_associated_function (|
              Ty.apply (Ty.path "alloc::sync::Arc") [ T; A ],
              "from_inner_in",
              []
            |),
            [
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "core::ptr::non_null::NonNull")
                    [ Ty.apply (Ty.path "alloc::sync::ArcInner") [ T ] ],
                  "new_unchecked",
                  []
                |),
                [ M.read (| ptr |) ]
              |);
              M.read (| alloc |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_from_ptr_in :
      forall (T A : Ty.t),
      M.IsAssociatedFunction (Self T A) "from_ptr_in" (from_ptr_in T A).
    (*
        pub fn allocator(this: &Self) -> &A {
            &this.alloc
        }
    *)
    Definition allocator (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match τ, α with
      | [], [ this ] =>
        ltac:(M.monadic
          (let this := M.alloc (| this |) in
          M.SubPointer.get_struct_record_field (|
            M.read (| this |),
            "alloc::sync::Arc",
            "alloc"
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_allocator :
      forall (T A : Ty.t),
      M.IsAssociatedFunction (Self T A) "allocator" (allocator T A).
    
    (*
        pub fn new_in(data: T, alloc: A) -> Arc<T, A> {
            // Start the weak pointer count as 1 which is the weak pointer that's
            // held by all the strong pointers (kinda), see std/rc.rs for more info
            let x = Box::new_in(
                ArcInner {
                    strong: atomic::AtomicUsize::new(1),
                    weak: atomic::AtomicUsize::new(1),
                    data,
                },
                alloc,
            );
            let (ptr, alloc) = Box::into_unique(x);
            unsafe { Self::from_inner_in(ptr.into(), alloc) }
        }
    *)
    Definition new_in (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match τ, α with
      | [], [ data; alloc ] =>
        ltac:(M.monadic
          (let data := M.alloc (| data |) in
          let alloc := M.alloc (| alloc |) in
          M.read (|
            let x :=
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "alloc::boxed::Box")
                      [ Ty.apply (Ty.path "alloc::sync::ArcInner") [ T ]; A ],
                    "new_in",
                    []
                  |),
                  [
                    Value.StructRecord
                      "alloc::sync::ArcInner"
                      [
                        ("strong",
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::sync::atomic::AtomicUsize",
                              "new",
                              []
                            |),
                            [ Value.Integer 1 ]
                          |));
                        ("weak",
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::sync::atomic::AtomicUsize",
                              "new",
                              []
                            |),
                            [ Value.Integer 1 ]
                          |));
                        ("data", M.read (| data |))
                      ];
                    M.read (| alloc |)
                  ]
                |)
              |) in
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "alloc::boxed::Box")
                      [ Ty.apply (Ty.path "alloc::sync::ArcInner") [ T ]; A ],
                    "into_unique",
                    []
                  |),
                  [ M.read (| x |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let ptr := M.copy (| γ0_0 |) in
                    let alloc := M.copy (| γ0_1 |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "alloc::sync::Arc") [ T; A ],
                          "from_inner_in",
                          []
                        |),
                        [
                          M.call_closure (|
                            M.get_trait_method (|
                              "core::convert::Into",
                              Ty.apply
                                (Ty.path "core::ptr::unique::Unique")
                                [ Ty.apply (Ty.path "alloc::sync::ArcInner") [ T ] ],
                              [
                                Ty.apply
                                  (Ty.path "core::ptr::non_null::NonNull")
                                  [ Ty.apply (Ty.path "alloc::sync::ArcInner") [ T ] ]
                              ],
                              "into",
                              []
                            |),
                            [ M.read (| ptr |) ]
                          |);
                          M.read (| alloc |)
                        ]
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_new_in :
      forall (T A : Ty.t),
      M.IsAssociatedFunction (Self T A) "new_in" (new_in T A).
    
    (*
        pub fn new_uninit_in(alloc: A) -> Arc<mem::MaybeUninit<T>, A> {
            unsafe {
                Arc::from_ptr_in(
                    Arc::allocate_for_layout(
                        Layout::new::<T>(),
                        |layout| alloc.allocate(layout),
                        <*mut u8>::cast,
                    ),
                    alloc,
                )
            }
        }
    *)
    Definition new_uninit_in (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match τ, α with
      | [], [ alloc ] =>
        ltac:(M.monadic
          (let alloc := M.alloc (| alloc |) in
          M.call_closure (|
            M.get_associated_function (|
              Ty.apply
                (Ty.path "alloc::sync::Arc")
                [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ T ]; A ],
              "from_ptr_in",
              []
            |),
            [
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "alloc::sync::Arc")
                    [
                      Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ T ];
                      Ty.path "alloc::alloc::Global"
                    ],
                  "allocate_for_layout",
                  [
                    Ty.function
                      [ Ty.tuple [ Ty.path "core::alloc::layout::Layout" ] ]
                      (Ty.apply
                        (Ty.path "core::result::Result")
                        [
                          Ty.apply
                            (Ty.path "core::ptr::non_null::NonNull")
                            [ Ty.apply (Ty.path "slice") [ Ty.path "u8" ] ];
                          Ty.path "core::alloc::AllocError"
                        ]);
                    Ty.function
                      [ Ty.apply (Ty.path "*mut") [ Ty.path "u8" ] ]
                      (Ty.apply
                        (Ty.path "*mut")
                        [
                          Ty.apply
                            (Ty.path "alloc::sync::ArcInner")
                            [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ T ] ]
                        ])
                  ]
                |),
                [
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.path "core::alloc::layout::Layout",
                      "new",
                      [ T ]
                    |),
                    []
                  |);
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0 ] =>
                          M.match_operator (|
                            M.alloc (| α0 |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let layout := M.copy (| γ |) in
                                  M.call_closure (|
                                    M.get_trait_method (|
                                      "core::alloc::Allocator",
                                      A,
                                      [],
                                      "allocate",
                                      []
                                    |),
                                    [ alloc; M.read (| layout |) ]
                                  |)))
                            ]
                          |)
                        | _ => M.impossible (||)
                        end));
                  M.get_associated_function (|
                    Ty.apply (Ty.path "*mut") [ Ty.path "u8" ],
                    "cast",
                    [
                      Ty.apply
                        (Ty.path "alloc::sync::ArcInner")
                        [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ T ] ]
                    ]
                  |)
                ]
              |);
              M.read (| alloc |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_new_uninit_in :
      forall (T A : Ty.t),
      M.IsAssociatedFunction (Self T A) "new_uninit_in" (new_uninit_in T A).
    
    (*
        pub fn new_zeroed_in(alloc: A) -> Arc<mem::MaybeUninit<T>, A> {
            unsafe {
                Arc::from_ptr_in(
                    Arc::allocate_for_layout(
                        Layout::new::<T>(),
                        |layout| alloc.allocate_zeroed(layout),
                        <*mut u8>::cast,
                    ),
                    alloc,
                )
            }
        }
    *)
    Definition new_zeroed_in (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match τ, α with
      | [], [ alloc ] =>
        ltac:(M.monadic
          (let alloc := M.alloc (| alloc |) in
          M.call_closure (|
            M.get_associated_function (|
              Ty.apply
                (Ty.path "alloc::sync::Arc")
                [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ T ]; A ],
              "from_ptr_in",
              []
            |),
            [
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "alloc::sync::Arc")
                    [
                      Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ T ];
                      Ty.path "alloc::alloc::Global"
                    ],
                  "allocate_for_layout",
                  [
                    Ty.function
                      [ Ty.tuple [ Ty.path "core::alloc::layout::Layout" ] ]
                      (Ty.apply
                        (Ty.path "core::result::Result")
                        [
                          Ty.apply
                            (Ty.path "core::ptr::non_null::NonNull")
                            [ Ty.apply (Ty.path "slice") [ Ty.path "u8" ] ];
                          Ty.path "core::alloc::AllocError"
                        ]);
                    Ty.function
                      [ Ty.apply (Ty.path "*mut") [ Ty.path "u8" ] ]
                      (Ty.apply
                        (Ty.path "*mut")
                        [
                          Ty.apply
                            (Ty.path "alloc::sync::ArcInner")
                            [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ T ] ]
                        ])
                  ]
                |),
                [
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.path "core::alloc::layout::Layout",
                      "new",
                      [ T ]
                    |),
                    []
                  |);
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0 ] =>
                          M.match_operator (|
                            M.alloc (| α0 |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let layout := M.copy (| γ |) in
                                  M.call_closure (|
                                    M.get_trait_method (|
                                      "core::alloc::Allocator",
                                      A,
                                      [],
                                      "allocate_zeroed",
                                      []
                                    |),
                                    [ alloc; M.read (| layout |) ]
                                  |)))
                            ]
                          |)
                        | _ => M.impossible (||)
                        end));
                  M.get_associated_function (|
                    Ty.apply (Ty.path "*mut") [ Ty.path "u8" ],
                    "cast",
                    [
                      Ty.apply
                        (Ty.path "alloc::sync::ArcInner")
                        [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ T ] ]
                    ]
                  |)
                ]
              |);
              M.read (| alloc |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_new_zeroed_in :
      forall (T A : Ty.t),
      M.IsAssociatedFunction (Self T A) "new_zeroed_in" (new_zeroed_in T A).
    
    (*
        pub fn pin_in(data: T, alloc: A) -> Pin<Arc<T, A>> {
            unsafe { Pin::new_unchecked(Arc::new_in(data, alloc)) }
        }
    *)
    Definition pin_in (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match τ, α with
      | [], [ data; alloc ] =>
        ltac:(M.monadic
          (let data := M.alloc (| data |) in
          let alloc := M.alloc (| alloc |) in
          M.call_closure (|
            M.get_associated_function (|
              Ty.apply
                (Ty.path "core::pin::Pin")
                [ Ty.apply (Ty.path "alloc::sync::Arc") [ T; A ] ],
              "new_unchecked",
              []
            |),
            [
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply (Ty.path "alloc::sync::Arc") [ T; A ],
                  "new_in",
                  []
                |),
                [ M.read (| data |); M.read (| alloc |) ]
              |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_pin_in :
      forall (T A : Ty.t),
      M.IsAssociatedFunction (Self T A) "pin_in" (pin_in T A).
    
    (*
        pub fn try_pin_in(data: T, alloc: A) -> Result<Pin<Arc<T, A>>, AllocError> {
            unsafe { Ok(Pin::new_unchecked(Arc::try_new_in(data, alloc)?)) }
        }
    *)
    Definition try_pin_in (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match τ, α with
      | [], [ data; alloc ] =>
        ltac:(M.monadic
          (let data := M.alloc (| data |) in
          let alloc := M.alloc (| alloc |) in
          M.catch_return (|
            ltac:(M.monadic
              (Value.StructTuple
                "core::result::Result::Ok"
                [
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "core::pin::Pin")
                        [ Ty.apply (Ty.path "alloc::sync::Arc") [ T; A ] ],
                      "new_unchecked",
                      []
                    |),
                    [
                      M.read (|
                        M.match_operator (|
                          M.alloc (|
                            M.call_closure (|
                              M.get_trait_method (|
                                "core::ops::try_trait::Try",
                                Ty.apply
                                  (Ty.path "core::result::Result")
                                  [
                                    Ty.apply (Ty.path "alloc::sync::Arc") [ T; A ];
                                    Ty.path "core::alloc::AllocError"
                                  ],
                                [],
                                "branch",
                                []
                              |),
                              [
                                M.call_closure (|
                                  M.get_associated_function (|
                                    Ty.apply (Ty.path "alloc::sync::Arc") [ T; A ],
                                    "try_new_in",
                                    []
                                  |),
                                  [ M.read (| data |); M.read (| alloc |) ]
                                |)
                              ]
                            |)
                          |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ0_0 :=
                                  M.SubPointer.get_struct_tuple_field (|
                                    γ,
                                    "core::ops::control_flow::ControlFlow::Break",
                                    0
                                  |) in
                                let residual := M.copy (| γ0_0 |) in
                                M.alloc (|
                                  M.never_to_any (|
                                    M.read (|
                                      M.return_ (|
                                        M.call_closure (|
                                          M.get_trait_method (|
                                            "core::ops::try_trait::FromResidual",
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              [
                                                Ty.apply
                                                  (Ty.path "core::pin::Pin")
                                                  [ Ty.apply (Ty.path "alloc::sync::Arc") [ T; A ]
                                                  ];
                                                Ty.path "core::alloc::AllocError"
                                              ],
                                            [
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                [
                                                  Ty.path "core::convert::Infallible";
                                                  Ty.path "core::alloc::AllocError"
                                                ]
                                            ],
                                            "from_residual",
                                            []
                                          |),
                                          [ M.read (| residual |) ]
                                        |)
                                      |)
                                    |)
                                  |)
                                |)));
                            fun γ =>
                              ltac:(M.monadic
                                (let γ0_0 :=
                                  M.SubPointer.get_struct_tuple_field (|
                                    γ,
                                    "core::ops::control_flow::ControlFlow::Continue",
                                    0
                                  |) in
                                let val := M.copy (| γ0_0 |) in
                                val))
                          ]
                        |)
                      |)
                    ]
                  |)
                ]))
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_try_pin_in :
      forall (T A : Ty.t),
      M.IsAssociatedFunction (Self T A) "try_pin_in" (try_pin_in T A).
    
    (*
        pub fn try_new_in(data: T, alloc: A) -> Result<Arc<T, A>, AllocError> {
            // Start the weak pointer count as 1 which is the weak pointer that's
            // held by all the strong pointers (kinda), see std/rc.rs for more info
            let x = Box::try_new_in(
                ArcInner {
                    strong: atomic::AtomicUsize::new(1),
                    weak: atomic::AtomicUsize::new(1),
                    data,
                },
                alloc,
            )?;
            let (ptr, alloc) = Box::into_unique(x);
            Ok(unsafe { Self::from_inner_in(ptr.into(), alloc) })
        }
    *)
    Definition try_new_in (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match τ, α with
      | [], [ data; alloc ] =>
        ltac:(M.monadic
          (let data := M.alloc (| data |) in
          let alloc := M.alloc (| alloc |) in
          M.catch_return (|
            ltac:(M.monadic
              (M.read (|
                let x :=
                  M.copy (|
                    M.match_operator (|
                      M.alloc (|
                        M.call_closure (|
                          M.get_trait_method (|
                            "core::ops::try_trait::Try",
                            Ty.apply
                              (Ty.path "core::result::Result")
                              [
                                Ty.apply
                                  (Ty.path "alloc::boxed::Box")
                                  [ Ty.apply (Ty.path "alloc::sync::ArcInner") [ T ]; A ];
                                Ty.path "core::alloc::AllocError"
                              ],
                            [],
                            "branch",
                            []
                          |),
                          [
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "alloc::boxed::Box")
                                  [ Ty.apply (Ty.path "alloc::sync::ArcInner") [ T ]; A ],
                                "try_new_in",
                                []
                              |),
                              [
                                Value.StructRecord
                                  "alloc::sync::ArcInner"
                                  [
                                    ("strong",
                                      M.call_closure (|
                                        M.get_associated_function (|
                                          Ty.path "core::sync::atomic::AtomicUsize",
                                          "new",
                                          []
                                        |),
                                        [ Value.Integer 1 ]
                                      |));
                                    ("weak",
                                      M.call_closure (|
                                        M.get_associated_function (|
                                          Ty.path "core::sync::atomic::AtomicUsize",
                                          "new",
                                          []
                                        |),
                                        [ Value.Integer 1 ]
                                      |));
                                    ("data", M.read (| data |))
                                  ];
                                M.read (| alloc |)
                              ]
                            |)
                          ]
                        |)
                      |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "core::ops::control_flow::ControlFlow::Break",
                                0
                              |) in
                            let residual := M.copy (| γ0_0 |) in
                            M.alloc (|
                              M.never_to_any (|
                                M.read (|
                                  M.return_ (|
                                    M.call_closure (|
                                      M.get_trait_method (|
                                        "core::ops::try_trait::FromResidual",
                                        Ty.apply
                                          (Ty.path "core::result::Result")
                                          [
                                            Ty.apply (Ty.path "alloc::sync::Arc") [ T; A ];
                                            Ty.path "core::alloc::AllocError"
                                          ],
                                        [
                                          Ty.apply
                                            (Ty.path "core::result::Result")
                                            [
                                              Ty.path "core::convert::Infallible";
                                              Ty.path "core::alloc::AllocError"
                                            ]
                                        ],
                                        "from_residual",
                                        []
                                      |),
                                      [ M.read (| residual |) ]
                                    |)
                                  |)
                                |)
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "core::ops::control_flow::ControlFlow::Continue",
                                0
                              |) in
                            let val := M.copy (| γ0_0 |) in
                            val))
                      ]
                    |)
                  |) in
                M.match_operator (|
                  M.alloc (|
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "alloc::boxed::Box")
                          [ Ty.apply (Ty.path "alloc::sync::ArcInner") [ T ]; A ],
                        "into_unique",
                        []
                      |),
                      [ M.read (| x |) ]
                    |)
                  |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                        let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                        let ptr := M.copy (| γ0_0 |) in
                        let alloc := M.copy (| γ0_1 |) in
                        M.alloc (|
                          Value.StructTuple
                            "core::result::Result::Ok"
                            [
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "alloc::sync::Arc") [ T; A ],
                                  "from_inner_in",
                                  []
                                |),
                                [
                                  M.call_closure (|
                                    M.get_trait_method (|
                                      "core::convert::Into",
                                      Ty.apply
                                        (Ty.path "core::ptr::unique::Unique")
                                        [ Ty.apply (Ty.path "alloc::sync::ArcInner") [ T ] ],
                                      [
                                        Ty.apply
                                          (Ty.path "core::ptr::non_null::NonNull")
                                          [ Ty.apply (Ty.path "alloc::sync::ArcInner") [ T ] ]
                                      ],
                                      "into",
                                      []
                                    |),
                                    [ M.read (| ptr |) ]
                                  |);
                                  M.read (| alloc |)
                                ]
                              |)
                            ]
                        |)))
                  ]
                |)
              |)))
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_try_new_in :
      forall (T A : Ty.t),
      M.IsAssociatedFunction (Self T A) "try_new_in" (try_new_in T A).
    
    (*
        pub fn try_new_uninit_in(alloc: A) -> Result<Arc<mem::MaybeUninit<T>, A>, AllocError> {
            unsafe {
                Ok(Arc::from_ptr_in(
                    Arc::try_allocate_for_layout(
                        Layout::new::<T>(),
                        |layout| alloc.allocate(layout),
                        <*mut u8>::cast,
                    )?,
                    alloc,
                ))
            }
        }
    *)
    Definition try_new_uninit_in (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match τ, α with
      | [], [ alloc ] =>
        ltac:(M.monadic
          (let alloc := M.alloc (| alloc |) in
          M.catch_return (|
            ltac:(M.monadic
              (Value.StructTuple
                "core::result::Result::Ok"
                [
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "alloc::sync::Arc")
                        [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ T ]; A ],
                      "from_ptr_in",
                      []
                    |),
                    [
                      M.read (|
                        M.match_operator (|
                          M.alloc (|
                            M.call_closure (|
                              M.get_trait_method (|
                                "core::ops::try_trait::Try",
                                Ty.apply
                                  (Ty.path "core::result::Result")
                                  [
                                    Ty.apply
                                      (Ty.path "*mut")
                                      [
                                        Ty.apply
                                          (Ty.path "alloc::sync::ArcInner")
                                          [
                                            Ty.apply
                                              (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                              [ T ]
                                          ]
                                      ];
                                    Ty.path "core::alloc::AllocError"
                                  ],
                                [],
                                "branch",
                                []
                              |),
                              [
                                M.call_closure (|
                                  M.get_associated_function (|
                                    Ty.apply
                                      (Ty.path "alloc::sync::Arc")
                                      [
                                        Ty.apply
                                          (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                          [ T ];
                                        Ty.path "alloc::alloc::Global"
                                      ],
                                    "try_allocate_for_layout",
                                    [
                                      Ty.function
                                        [ Ty.tuple [ Ty.path "core::alloc::layout::Layout" ] ]
                                        (Ty.apply
                                          (Ty.path "core::result::Result")
                                          [
                                            Ty.apply
                                              (Ty.path "core::ptr::non_null::NonNull")
                                              [ Ty.apply (Ty.path "slice") [ Ty.path "u8" ] ];
                                            Ty.path "core::alloc::AllocError"
                                          ]);
                                      Ty.function
                                        [ Ty.apply (Ty.path "*mut") [ Ty.path "u8" ] ]
                                        (Ty.apply
                                          (Ty.path "*mut")
                                          [
                                            Ty.apply
                                              (Ty.path "alloc::sync::ArcInner")
                                              [
                                                Ty.apply
                                                  (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                                  [ T ]
                                              ]
                                          ])
                                    ]
                                  |),
                                  [
                                    M.call_closure (|
                                      M.get_associated_function (|
                                        Ty.path "core::alloc::layout::Layout",
                                        "new",
                                        [ T ]
                                      |),
                                      []
                                    |);
                                    M.closure
                                      (fun γ =>
                                        ltac:(M.monadic
                                          match γ with
                                          | [ α0 ] =>
                                            M.match_operator (|
                                              M.alloc (| α0 |),
                                              [
                                                fun γ =>
                                                  ltac:(M.monadic
                                                    (let layout := M.copy (| γ |) in
                                                    M.call_closure (|
                                                      M.get_trait_method (|
                                                        "core::alloc::Allocator",
                                                        A,
                                                        [],
                                                        "allocate",
                                                        []
                                                      |),
                                                      [ alloc; M.read (| layout |) ]
                                                    |)))
                                              ]
                                            |)
                                          | _ => M.impossible (||)
                                          end));
                                    M.get_associated_function (|
                                      Ty.apply (Ty.path "*mut") [ Ty.path "u8" ],
                                      "cast",
                                      [
                                        Ty.apply
                                          (Ty.path "alloc::sync::ArcInner")
                                          [
                                            Ty.apply
                                              (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                              [ T ]
                                          ]
                                      ]
                                    |)
                                  ]
                                |)
                              ]
                            |)
                          |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ0_0 :=
                                  M.SubPointer.get_struct_tuple_field (|
                                    γ,
                                    "core::ops::control_flow::ControlFlow::Break",
                                    0
                                  |) in
                                let residual := M.copy (| γ0_0 |) in
                                M.alloc (|
                                  M.never_to_any (|
                                    M.read (|
                                      M.return_ (|
                                        M.call_closure (|
                                          M.get_trait_method (|
                                            "core::ops::try_trait::FromResidual",
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              [
                                                Ty.apply
                                                  (Ty.path "alloc::sync::Arc")
                                                  [
                                                    Ty.apply
                                                      (Ty.path
                                                        "core::mem::maybe_uninit::MaybeUninit")
                                                      [ T ];
                                                    A
                                                  ];
                                                Ty.path "core::alloc::AllocError"
                                              ],
                                            [
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                [
                                                  Ty.path "core::convert::Infallible";
                                                  Ty.path "core::alloc::AllocError"
                                                ]
                                            ],
                                            "from_residual",
                                            []
                                          |),
                                          [ M.read (| residual |) ]
                                        |)
                                      |)
                                    |)
                                  |)
                                |)));
                            fun γ =>
                              ltac:(M.monadic
                                (let γ0_0 :=
                                  M.SubPointer.get_struct_tuple_field (|
                                    γ,
                                    "core::ops::control_flow::ControlFlow::Continue",
                                    0
                                  |) in
                                let val := M.copy (| γ0_0 |) in
                                val))
                          ]
                        |)
                      |);
                      M.read (| alloc |)
                    ]
                  |)
                ]))
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_try_new_uninit_in :
      forall (T A : Ty.t),
      M.IsAssociatedFunction (Self T A) "try_new_uninit_in" (try_new_uninit_in T A).
    
    (*
        pub fn try_new_zeroed_in(alloc: A) -> Result<Arc<mem::MaybeUninit<T>, A>, AllocError> {
            unsafe {
                Ok(Arc::from_ptr_in(
                    Arc::try_allocate_for_layout(
                        Layout::new::<T>(),
                        |layout| alloc.allocate_zeroed(layout),
                        <*mut u8>::cast,
                    )?,
                    alloc,
                ))
            }
        }
    *)
    Definition try_new_zeroed_in (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match τ, α with
      | [], [ alloc ] =>
        ltac:(M.monadic
          (let alloc := M.alloc (| alloc |) in
          M.catch_return (|
            ltac:(M.monadic
              (Value.StructTuple
                "core::result::Result::Ok"
                [
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "alloc::sync::Arc")
                        [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ T ]; A ],
                      "from_ptr_in",
                      []
                    |),
                    [
                      M.read (|
                        M.match_operator (|
                          M.alloc (|
                            M.call_closure (|
                              M.get_trait_method (|
                                "core::ops::try_trait::Try",
                                Ty.apply
                                  (Ty.path "core::result::Result")
                                  [
                                    Ty.apply
                                      (Ty.path "*mut")
                                      [
                                        Ty.apply
                                          (Ty.path "alloc::sync::ArcInner")
                                          [
                                            Ty.apply
                                              (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                              [ T ]
                                          ]
                                      ];
                                    Ty.path "core::alloc::AllocError"
                                  ],
                                [],
                                "branch",
                                []
                              |),
                              [
                                M.call_closure (|
                                  M.get_associated_function (|
                                    Ty.apply
                                      (Ty.path "alloc::sync::Arc")
                                      [
                                        Ty.apply
                                          (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                          [ T ];
                                        Ty.path "alloc::alloc::Global"
                                      ],
                                    "try_allocate_for_layout",
                                    [
                                      Ty.function
                                        [ Ty.tuple [ Ty.path "core::alloc::layout::Layout" ] ]
                                        (Ty.apply
                                          (Ty.path "core::result::Result")
                                          [
                                            Ty.apply
                                              (Ty.path "core::ptr::non_null::NonNull")
                                              [ Ty.apply (Ty.path "slice") [ Ty.path "u8" ] ];
                                            Ty.path "core::alloc::AllocError"
                                          ]);
                                      Ty.function
                                        [ Ty.apply (Ty.path "*mut") [ Ty.path "u8" ] ]
                                        (Ty.apply
                                          (Ty.path "*mut")
                                          [
                                            Ty.apply
                                              (Ty.path "alloc::sync::ArcInner")
                                              [
                                                Ty.apply
                                                  (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                                  [ T ]
                                              ]
                                          ])
                                    ]
                                  |),
                                  [
                                    M.call_closure (|
                                      M.get_associated_function (|
                                        Ty.path "core::alloc::layout::Layout",
                                        "new",
                                        [ T ]
                                      |),
                                      []
                                    |);
                                    M.closure
                                      (fun γ =>
                                        ltac:(M.monadic
                                          match γ with
                                          | [ α0 ] =>
                                            M.match_operator (|
                                              M.alloc (| α0 |),
                                              [
                                                fun γ =>
                                                  ltac:(M.monadic
                                                    (let layout := M.copy (| γ |) in
                                                    M.call_closure (|
                                                      M.get_trait_method (|
                                                        "core::alloc::Allocator",
                                                        A,
                                                        [],
                                                        "allocate_zeroed",
                                                        []
                                                      |),
                                                      [ alloc; M.read (| layout |) ]
                                                    |)))
                                              ]
                                            |)
                                          | _ => M.impossible (||)
                                          end));
                                    M.get_associated_function (|
                                      Ty.apply (Ty.path "*mut") [ Ty.path "u8" ],
                                      "cast",
                                      [
                                        Ty.apply
                                          (Ty.path "alloc::sync::ArcInner")
                                          [
                                            Ty.apply
                                              (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                              [ T ]
                                          ]
                                      ]
                                    |)
                                  ]
                                |)
                              ]
                            |)
                          |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ0_0 :=
                                  M.SubPointer.get_struct_tuple_field (|
                                    γ,
                                    "core::ops::control_flow::ControlFlow::Break",
                                    0
                                  |) in
                                let residual := M.copy (| γ0_0 |) in
                                M.alloc (|
                                  M.never_to_any (|
                                    M.read (|
                                      M.return_ (|
                                        M.call_closure (|
                                          M.get_trait_method (|
                                            "core::ops::try_trait::FromResidual",
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              [
                                                Ty.apply
                                                  (Ty.path "alloc::sync::Arc")
                                                  [
                                                    Ty.apply
                                                      (Ty.path
                                                        "core::mem::maybe_uninit::MaybeUninit")
                                                      [ T ];
                                                    A
                                                  ];
                                                Ty.path "core::alloc::AllocError"
                                              ],
                                            [
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                [
                                                  Ty.path "core::convert::Infallible";
                                                  Ty.path "core::alloc::AllocError"
                                                ]
                                            ],
                                            "from_residual",
                                            []
                                          |),
                                          [ M.read (| residual |) ]
                                        |)
                                      |)
                                    |)
                                  |)
                                |)));
                            fun γ =>
                              ltac:(M.monadic
                                (let γ0_0 :=
                                  M.SubPointer.get_struct_tuple_field (|
                                    γ,
                                    "core::ops::control_flow::ControlFlow::Continue",
                                    0
                                  |) in
                                let val := M.copy (| γ0_0 |) in
                                val))
                          ]
                        |)
                      |);
                      M.read (| alloc |)
                    ]
                  |)
                ]))
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_try_new_zeroed_in :
      forall (T A : Ty.t),
      M.IsAssociatedFunction (Self T A) "try_new_zeroed_in" (try_new_zeroed_in T A).
    
    (*
        pub fn try_unwrap(this: Self) -> Result<T, Self> {
            if this.inner().strong.compare_exchange(1, 0, Relaxed, Relaxed).is_err() {
                return Err(this);
            }
    
            acquire!(this.inner().strong);
    
            unsafe {
                let elem = ptr::read(&this.ptr.as_ref().data);
                let alloc = ptr::read(&this.alloc); // copy the allocator
    
                // Make a weak pointer to clean up the implicit strong-weak reference
                let _weak = Weak { ptr: this.ptr, alloc };
                mem::forget(this);
    
                Ok(elem)
            }
        }
    *)
    Definition try_unwrap (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match τ, α with
      | [], [ this ] =>
        ltac:(M.monadic
          (let this := M.alloc (| this |) in
          M.catch_return (|
            ltac:(M.monadic
              (M.read (|
                let _ :=
                  M.match_operator (|
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                M.call_closure (|
                                  M.get_associated_function (|
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      [ Ty.path "usize"; Ty.path "usize" ],
                                    "is_err",
                                    []
                                  |),
                                  [
                                    M.alloc (|
                                      M.call_closure (|
                                        M.get_associated_function (|
                                          Ty.path "core::sync::atomic::AtomicUsize",
                                          "compare_exchange",
                                          []
                                        |),
                                        [
                                          M.SubPointer.get_struct_record_field (|
                                            M.call_closure (|
                                              M.get_associated_function (|
                                                Ty.apply (Ty.path "alloc::sync::Arc") [ T; A ],
                                                "inner",
                                                []
                                              |),
                                              [ this ]
                                            |),
                                            "alloc::sync::ArcInner",
                                            "strong"
                                          |);
                                          Value.Integer 1;
                                          Value.Integer 0;
                                          Value.StructTuple
                                            "core::sync::atomic::Ordering::Relaxed"
                                            [];
                                          Value.StructTuple
                                            "core::sync::atomic::Ordering::Relaxed"
                                            []
                                        ]
                                      |)
                                    |)
                                  ]
                                |)
                              |)) in
                          let _ :=
                            M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (|
                            M.never_to_any (|
                              M.read (|
                                M.return_ (|
                                  Value.StructTuple
                                    "core::result::Result::Err"
                                    [ M.read (| this |) ]
                                |)
                              |)
                            |)
                          |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                let _ :=
                  M.alloc (|
                    M.call_closure (|
                      M.get_function (| "core::sync::atomic::fence", [] |),
                      [ Value.StructTuple "core::sync::atomic::Ordering::Acquire" [] ]
                    |)
                  |) in
                let elem :=
                  M.alloc (|
                    M.call_closure (|
                      M.get_function (| "core::ptr::read", [ T ] |),
                      [
                        M.SubPointer.get_struct_record_field (|
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply
                                (Ty.path "core::ptr::non_null::NonNull")
                                [ Ty.apply (Ty.path "alloc::sync::ArcInner") [ T ] ],
                              "as_ref",
                              []
                            |),
                            [
                              M.SubPointer.get_struct_record_field (|
                                this,
                                "alloc::sync::Arc",
                                "ptr"
                              |)
                            ]
                          |),
                          "alloc::sync::ArcInner",
                          "data"
                        |)
                      ]
                    |)
                  |) in
                let alloc :=
                  M.alloc (|
                    M.call_closure (|
                      M.get_function (| "core::ptr::read", [ A ] |),
                      [ M.SubPointer.get_struct_record_field (| this, "alloc::sync::Arc", "alloc" |)
                      ]
                    |)
                  |) in
                let _weak :=
                  M.alloc (|
                    Value.StructRecord
                      "alloc::sync::Weak"
                      [
                        ("ptr",
                          M.read (|
                            M.SubPointer.get_struct_record_field (|
                              this,
                              "alloc::sync::Arc",
                              "ptr"
                            |)
                          |));
                        ("alloc", M.read (| alloc |))
                      ]
                  |) in
                let _ :=
                  M.alloc (|
                    M.call_closure (|
                      M.get_function (|
                        "core::mem::forget",
                        [ Ty.apply (Ty.path "alloc::sync::Arc") [ T; A ] ]
                      |),
                      [ M.read (| this |) ]
                    |)
                  |) in
                M.alloc (| Value.StructTuple "core::result::Result::Ok" [ M.read (| elem |) ] |)
              |)))
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_try_unwrap :
      forall (T A : Ty.t),
      M.IsAssociatedFunction (Self T A) "try_unwrap" (try_unwrap T A).
    
    (*
        pub fn into_inner(this: Self) -> Option<T> {
            // Make sure that the ordinary `Drop` implementation isn’t called as well
            let mut this = mem::ManuallyDrop::new(this);
    
            // Following the implementation of `drop` and `drop_slow`
            if this.inner().strong.fetch_sub(1, Release) != 1 {
                return None;
            }
    
            acquire!(this.inner().strong);
    
            // SAFETY: This mirrors the line
            //
            //     unsafe { ptr::drop_in_place(Self::get_mut_unchecked(self)) };
            //
            // in `drop_slow`. Instead of dropping the value behind the pointer,
            // it is read and eventually returned; `ptr::read` has the same
            // safety conditions as `ptr::drop_in_place`.
    
            let inner = unsafe { ptr::read(Self::get_mut_unchecked(&mut this)) };
            let alloc = unsafe { ptr::read(&this.alloc) };
    
            drop(Weak { ptr: this.ptr, alloc });
    
            Some(inner)
        }
    *)
    Definition into_inner (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match τ, α with
      | [], [ this ] =>
        ltac:(M.monadic
          (let this := M.alloc (| this |) in
          M.catch_return (|
            ltac:(M.monadic
              (M.read (|
                let this :=
                  M.alloc (|
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "core::mem::manually_drop::ManuallyDrop")
                          [ Ty.apply (Ty.path "alloc::sync::Arc") [ T; A ] ],
                        "new",
                        []
                      |),
                      [ M.read (| this |) ]
                    |)
                  |) in
                let _ :=
                  M.match_operator (|
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                BinOp.Pure.ne
                                  (M.call_closure (|
                                    M.get_associated_function (|
                                      Ty.path "core::sync::atomic::AtomicUsize",
                                      "fetch_sub",
                                      []
                                    |),
                                    [
                                      M.SubPointer.get_struct_record_field (|
                                        M.call_closure (|
                                          M.get_associated_function (|
                                            Ty.apply (Ty.path "alloc::sync::Arc") [ T; A ],
                                            "inner",
                                            []
                                          |),
                                          [
                                            M.call_closure (|
                                              M.get_trait_method (|
                                                "core::ops::deref::Deref",
                                                Ty.apply
                                                  (Ty.path "core::mem::manually_drop::ManuallyDrop")
                                                  [ Ty.apply (Ty.path "alloc::sync::Arc") [ T; A ]
                                                  ],
                                                [],
                                                "deref",
                                                []
                                              |),
                                              [ this ]
                                            |)
                                          ]
                                        |),
                                        "alloc::sync::ArcInner",
                                        "strong"
                                      |);
                                      Value.Integer 1;
                                      Value.StructTuple "core::sync::atomic::Ordering::Release" []
                                    ]
                                  |))
                                  (Value.Integer 1)
                              |)) in
                          let _ :=
                            M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (|
                            M.never_to_any (|
                              M.read (|
                                M.return_ (| Value.StructTuple "core::option::Option::None" [] |)
                              |)
                            |)
                          |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                let _ :=
                  M.alloc (|
                    M.call_closure (|
                      M.get_function (| "core::sync::atomic::fence", [] |),
                      [ Value.StructTuple "core::sync::atomic::Ordering::Acquire" [] ]
                    |)
                  |) in
                let inner :=
                  M.alloc (|
                    M.call_closure (|
                      M.get_function (| "core::ptr::read", [ T ] |),
                      [
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.apply (Ty.path "alloc::sync::Arc") [ T; A ],
                            "get_mut_unchecked",
                            []
                          |),
                          [
                            M.call_closure (|
                              M.get_trait_method (|
                                "core::ops::deref::DerefMut",
                                Ty.apply
                                  (Ty.path "core::mem::manually_drop::ManuallyDrop")
                                  [ Ty.apply (Ty.path "alloc::sync::Arc") [ T; A ] ],
                                [],
                                "deref_mut",
                                []
                              |),
                              [ this ]
                            |)
                          ]
                        |)
                      ]
                    |)
                  |) in
                let alloc :=
                  M.alloc (|
                    M.call_closure (|
                      M.get_function (| "core::ptr::read", [ A ] |),
                      [
                        M.SubPointer.get_struct_record_field (|
                          M.call_closure (|
                            M.get_trait_method (|
                              "core::ops::deref::Deref",
                              Ty.apply
                                (Ty.path "core::mem::manually_drop::ManuallyDrop")
                                [ Ty.apply (Ty.path "alloc::sync::Arc") [ T; A ] ],
                              [],
                              "deref",
                              []
                            |),
                            [ this ]
                          |),
                          "alloc::sync::Arc",
                          "alloc"
                        |)
                      ]
                    |)
                  |) in
                let _ :=
                  M.alloc (|
                    M.call_closure (|
                      M.get_function (|
                        "core::mem::drop",
                        [ Ty.apply (Ty.path "alloc::sync::Weak") [ T; A ] ]
                      |),
                      [
                        Value.StructRecord
                          "alloc::sync::Weak"
                          [
                            ("ptr",
                              M.read (|
                                M.SubPointer.get_struct_record_field (|
                                  M.call_closure (|
                                    M.get_trait_method (|
                                      "core::ops::deref::Deref",
                                      Ty.apply
                                        (Ty.path "core::mem::manually_drop::ManuallyDrop")
                                        [ Ty.apply (Ty.path "alloc::sync::Arc") [ T; A ] ],
                                      [],
                                      "deref",
                                      []
                                    |),
                                    [ this ]
                                  |),
                                  "alloc::sync::Arc",
                                  "ptr"
                                |)
                              |));
                            ("alloc", M.read (| alloc |))
                          ]
                      ]
                    |)
                  |) in
                M.alloc (| Value.StructTuple "core::option::Option::Some" [ M.read (| inner |) ] |)
              |)))
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_into_inner :
      forall (T A : Ty.t),
      M.IsAssociatedFunction (Self T A) "into_inner" (into_inner T A).
    (*
        pub fn into_raw(this: Self) -> *const T {
            let ptr = Self::as_ptr(&this);
            mem::forget(this);
            ptr
        }
    *)
    Definition into_raw (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match τ, α with
      | [], [ this ] =>
        ltac:(M.monadic
          (let this := M.alloc (| this |) in
          M.read (|
            let ptr :=
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "alloc::sync::Arc") [ T; A ],
                    "as_ptr",
                    []
                  |),
                  [ this ]
                |)
              |) in
            let _ :=
              M.alloc (|
                M.call_closure (|
                  M.get_function (|
                    "core::mem::forget",
                    [ Ty.apply (Ty.path "alloc::sync::Arc") [ T; A ] ]
                  |),
                  [ M.read (| this |) ]
                |)
              |) in
            ptr
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_into_raw :
      forall (T A : Ty.t),
      M.IsAssociatedFunction (Self T A) "into_raw" (into_raw T A).
    
    (*
        pub fn as_ptr(this: &Self) -> *const T {
            let ptr: *mut ArcInner<T> = NonNull::as_ptr(this.ptr);
    
            // SAFETY: This cannot go through Deref::deref or RcBoxPtr::inner because
            // this is required to retain raw/mut provenance such that e.g. `get_mut` can
            // write through the pointer after the Rc is recovered through `from_raw`.
            unsafe { ptr::addr_of_mut!(( *ptr).data) }
        }
    *)
    Definition as_ptr (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match τ, α with
      | [], [ this ] =>
        ltac:(M.monadic
          (let this := M.alloc (| this |) in
          M.read (|
            let ptr :=
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "core::ptr::non_null::NonNull")
                      [ Ty.apply (Ty.path "alloc::sync::ArcInner") [ T ] ],
                    "as_ptr",
                    []
                  |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_record_field (|
                        M.read (| this |),
                        "alloc::sync::Arc",
                        "ptr"
                      |)
                    |)
                  ]
                |)
              |) in
            M.alloc (|
              (* MutToConstPointer *)
              M.pointer_coercion
                (M.SubPointer.get_struct_record_field (|
                  M.read (| ptr |),
                  "alloc::sync::ArcInner",
                  "data"
                |))
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_as_ptr :
      forall (T A : Ty.t),
      M.IsAssociatedFunction (Self T A) "as_ptr" (as_ptr T A).
    
    (*
        pub unsafe fn from_raw_in(ptr: *const T, alloc: A) -> Self {
            unsafe {
                let offset = data_offset(ptr);
    
                // Reverse the offset to find the original ArcInner.
                let arc_ptr = ptr.byte_sub(offset) as *mut ArcInner<T>;
    
                Self::from_ptr_in(arc_ptr, alloc)
            }
        }
    *)
    Definition from_raw_in (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match τ, α with
      | [], [ ptr; alloc ] =>
        ltac:(M.monadic
          (let ptr := M.alloc (| ptr |) in
          let alloc := M.alloc (| alloc |) in
          M.read (|
            let offset :=
              M.alloc (|
                M.call_closure (|
                  M.get_function (| "alloc::sync::data_offset", [ T ] |),
                  [ M.read (| ptr |) ]
                |)
              |) in
            let arc_ptr :=
              M.alloc (|
                M.rust_cast
                  (M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply (Ty.path "*const") [ T ],
                      "byte_sub",
                      []
                    |),
                    [ M.read (| ptr |); M.read (| offset |) ]
                  |))
              |) in
            M.alloc (|
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply (Ty.path "alloc::sync::Arc") [ T; A ],
                  "from_ptr_in",
                  []
                |),
                [ M.read (| arc_ptr |); M.read (| alloc |) ]
              |)
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_from_raw_in :
      forall (T A : Ty.t),
      M.IsAssociatedFunction (Self T A) "from_raw_in" (from_raw_in T A).
    
    (*
        pub fn downgrade(this: &Self) -> Weak<T, A>
        where
            A: Clone,
        {
            // This Relaxed is OK because we're checking the value in the CAS
            // below.
            let mut cur = this.inner().weak.load(Relaxed);
    
            loop {
                // check if the weak counter is currently "locked"; if so, spin.
                if cur == usize::MAX {
                    hint::spin_loop();
                    cur = this.inner().weak.load(Relaxed);
                    continue;
                }
    
                // We can't allow the refcount to increase much past `MAX_REFCOUNT`.
                assert!(cur <= MAX_REFCOUNT, "{}", INTERNAL_OVERFLOW_ERROR);
    
                // NOTE: this code currently ignores the possibility of overflow
                // into usize::MAX; in general both Rc and Arc need to be adjusted
                // to deal with overflow.
    
                // Unlike with Clone(), we need this to be an Acquire read to
                // synchronize with the write coming from `is_unique`, so that the
                // events prior to that write happen before this read.
                match this.inner().weak.compare_exchange_weak(cur, cur + 1, Acquire, Relaxed) {
                    Ok(_) => {
                        // Make sure we do not create a dangling Weak
                        debug_assert!(!is_dangling(this.ptr.as_ptr()));
                        return Weak { ptr: this.ptr, alloc: this.alloc.clone() };
                    }
                    Err(old) => cur = old,
                }
            }
        }
    *)
    Definition downgrade (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match τ, α with
      | [], [ this ] =>
        ltac:(M.monadic
          (let this := M.alloc (| this |) in
          M.catch_return (|
            ltac:(M.monadic
              (M.read (|
                let cur :=
                  M.alloc (|
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.path "core::sync::atomic::AtomicUsize",
                        "load",
                        []
                      |),
                      [
                        M.SubPointer.get_struct_record_field (|
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply (Ty.path "alloc::sync::Arc") [ T; A ],
                              "inner",
                              []
                            |),
                            [ M.read (| this |) ]
                          |),
                          "alloc::sync::ArcInner",
                          "weak"
                        |);
                        Value.StructTuple "core::sync::atomic::Ordering::Relaxed" []
                      ]
                    |)
                  |) in
                M.alloc (|
                  M.never_to_any (|
                    M.read (|
                      M.loop (|
                        ltac:(M.monadic
                          (let _ :=
                            M.match_operator (|
                              M.alloc (| Value.Tuple [] |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let γ :=
                                      M.use
                                        (M.alloc (|
                                          BinOp.Pure.eq
                                            (M.read (| cur |))
                                            (M.read (| M.get_constant (| "core::num::MAX" |) |))
                                        |)) in
                                    let _ :=
                                      M.is_constant_or_break_match (|
                                        M.read (| γ |),
                                        Value.Bool true
                                      |) in
                                    M.alloc (|
                                      M.never_to_any (|
                                        M.read (|
                                          let _ :=
                                            M.alloc (|
                                              M.call_closure (|
                                                M.get_function (| "core::hint::spin_loop", [] |),
                                                []
                                              |)
                                            |) in
                                          let _ :=
                                            M.write (|
                                              cur,
                                              M.call_closure (|
                                                M.get_associated_function (|
                                                  Ty.path "core::sync::atomic::AtomicUsize",
                                                  "load",
                                                  []
                                                |),
                                                [
                                                  M.SubPointer.get_struct_record_field (|
                                                    M.call_closure (|
                                                      M.get_associated_function (|
                                                        Ty.apply
                                                          (Ty.path "alloc::sync::Arc")
                                                          [ T; A ],
                                                        "inner",
                                                        []
                                                      |),
                                                      [ M.read (| this |) ]
                                                    |),
                                                    "alloc::sync::ArcInner",
                                                    "weak"
                                                  |);
                                                  Value.StructTuple
                                                    "core::sync::atomic::Ordering::Relaxed"
                                                    []
                                                ]
                                              |)
                                            |) in
                                          M.continue (||)
                                        |)
                                      |)
                                    |)));
                                fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                              ]
                            |) in
                          let _ :=
                            M.match_operator (|
                              M.alloc (| Value.Tuple [] |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let γ :=
                                      M.use
                                        (M.alloc (|
                                          UnOp.Pure.not
                                            (BinOp.Pure.le
                                              (M.read (| cur |))
                                              (M.read (|
                                                M.get_constant (| "alloc::sync::MAX_REFCOUNT" |)
                                              |)))
                                        |)) in
                                    let _ :=
                                      M.is_constant_or_break_match (|
                                        M.read (| γ |),
                                        Value.Bool true
                                      |) in
                                    M.alloc (|
                                      M.never_to_any (|
                                        M.call_closure (|
                                          M.get_associated_function (|
                                            Self,
                                            "panic_cold_display.downgrade",
                                            []
                                          |),
                                          [
                                            M.get_constant (|
                                              "alloc::sync::INTERNAL_OVERFLOW_ERROR"
                                            |)
                                          ]
                                        |)
                                      |)
                                    |)));
                                fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                              ]
                            |) in
                          M.match_operator (|
                            M.alloc (|
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.path "core::sync::atomic::AtomicUsize",
                                  "compare_exchange_weak",
                                  []
                                |),
                                [
                                  M.SubPointer.get_struct_record_field (|
                                    M.call_closure (|
                                      M.get_associated_function (|
                                        Ty.apply (Ty.path "alloc::sync::Arc") [ T; A ],
                                        "inner",
                                        []
                                      |),
                                      [ M.read (| this |) ]
                                    |),
                                    "alloc::sync::ArcInner",
                                    "weak"
                                  |);
                                  M.read (| cur |);
                                  BinOp.Panic.add (|
                                    Integer.Usize,
                                    M.read (| cur |),
                                    Value.Integer 1
                                  |);
                                  Value.StructTuple "core::sync::atomic::Ordering::Acquire" [];
                                  Value.StructTuple "core::sync::atomic::Ordering::Relaxed" []
                                ]
                              |)
                            |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::result::Result::Ok",
                                      0
                                    |) in
                                  M.alloc (|
                                    M.never_to_any (|
                                      M.read (|
                                        let _ :=
                                          M.match_operator (|
                                            M.alloc (| Value.Tuple [] |),
                                            [
                                              fun γ =>
                                                ltac:(M.monadic
                                                  (let γ := M.use (M.alloc (| Value.Bool true |)) in
                                                  let _ :=
                                                    M.is_constant_or_break_match (|
                                                      M.read (| γ |),
                                                      Value.Bool true
                                                    |) in
                                                  let _ :=
                                                    M.match_operator (|
                                                      M.alloc (| Value.Tuple [] |),
                                                      [
                                                        fun γ =>
                                                          ltac:(M.monadic
                                                            (let γ :=
                                                              M.use
                                                                (M.alloc (|
                                                                  UnOp.Pure.not
                                                                    (UnOp.Pure.not
                                                                      (M.call_closure (|
                                                                        M.get_function (|
                                                                          "alloc::rc::is_dangling",
                                                                          [
                                                                            Ty.apply
                                                                              (Ty.path
                                                                                "alloc::sync::ArcInner")
                                                                              [ T ]
                                                                          ]
                                                                        |),
                                                                        [
                                                                          M.call_closure (|
                                                                            M.get_associated_function (|
                                                                              Ty.apply
                                                                                (Ty.path
                                                                                  "core::ptr::non_null::NonNull")
                                                                                [
                                                                                  Ty.apply
                                                                                    (Ty.path
                                                                                      "alloc::sync::ArcInner")
                                                                                    [ T ]
                                                                                ],
                                                                              "as_ptr",
                                                                              []
                                                                            |),
                                                                            [
                                                                              M.read (|
                                                                                M.SubPointer.get_struct_record_field (|
                                                                                  M.read (| this |),
                                                                                  "alloc::sync::Arc",
                                                                                  "ptr"
                                                                                |)
                                                                              |)
                                                                            ]
                                                                          |)
                                                                        ]
                                                                      |)))
                                                                |)) in
                                                            let _ :=
                                                              M.is_constant_or_break_match (|
                                                                M.read (| γ |),
                                                                Value.Bool true
                                                              |) in
                                                            M.alloc (|
                                                              M.never_to_any (|
                                                                M.call_closure (|
                                                                  M.get_function (|
                                                                    "core::panicking::panic",
                                                                    []
                                                                  |),
                                                                  [
                                                                    M.read (|
                                                                      Value.String
                                                                        "assertion failed: !is_dangling(this.ptr.as_ptr())"
                                                                    |)
                                                                  ]
                                                                |)
                                                              |)
                                                            |)));
                                                        fun γ =>
                                                          ltac:(M.monadic
                                                            (M.alloc (| Value.Tuple [] |)))
                                                      ]
                                                    |) in
                                                  M.alloc (| Value.Tuple [] |)));
                                              fun γ =>
                                                ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                                            ]
                                          |) in
                                        M.return_ (|
                                          Value.StructRecord
                                            "alloc::sync::Weak"
                                            [
                                              ("ptr",
                                                M.read (|
                                                  M.SubPointer.get_struct_record_field (|
                                                    M.read (| this |),
                                                    "alloc::sync::Arc",
                                                    "ptr"
                                                  |)
                                                |));
                                              ("alloc",
                                                M.call_closure (|
                                                  M.get_trait_method (|
                                                    "core::clone::Clone",
                                                    A,
                                                    [],
                                                    "clone",
                                                    []
                                                  |),
                                                  [
                                                    M.SubPointer.get_struct_record_field (|
                                                      M.read (| this |),
                                                      "alloc::sync::Arc",
                                                      "alloc"
                                                    |)
                                                  ]
                                                |))
                                            ]
                                        |)
                                      |)
                                    |)
                                  |)));
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::result::Result::Err",
                                      0
                                    |) in
                                  let old := M.copy (| γ0_0 |) in
                                  M.write (| cur, M.read (| old |) |)))
                            ]
                          |)))
                      |)
                    |)
                  |)
                |)
              |)))
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_downgrade :
      forall (T A : Ty.t),
      M.IsAssociatedFunction (Self T A) "downgrade" (downgrade T A).
    
    (*
        pub fn weak_count(this: &Self) -> usize {
            let cnt = this.inner().weak.load(Relaxed);
            // If the weak count is currently locked, the value of the
            // count was 0 just before taking the lock.
            if cnt == usize::MAX { 0 } else { cnt - 1 }
        }
    *)
    Definition weak_count (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match τ, α with
      | [], [ this ] =>
        ltac:(M.monadic
          (let this := M.alloc (| this |) in
          M.read (|
            let cnt :=
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.path "core::sync::atomic::AtomicUsize",
                    "load",
                    []
                  |),
                  [
                    M.SubPointer.get_struct_record_field (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "alloc::sync::Arc") [ T; A ],
                          "inner",
                          []
                        |),
                        [ M.read (| this |) ]
                      |),
                      "alloc::sync::ArcInner",
                      "weak"
                    |);
                    Value.StructTuple "core::sync::atomic::Ordering::Relaxed" []
                  ]
                |)
              |) in
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          BinOp.Pure.eq
                            (M.read (| cnt |))
                            (M.read (| M.get_constant (| "core::num::MAX" |) |))
                        |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (| Value.Integer 0 |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      BinOp.Panic.sub (| Integer.Usize, M.read (| cnt |), Value.Integer 1 |)
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_weak_count :
      forall (T A : Ty.t),
      M.IsAssociatedFunction (Self T A) "weak_count" (weak_count T A).
    
    (*
        pub fn strong_count(this: &Self) -> usize {
            this.inner().strong.load(Relaxed)
        }
    *)
    Definition strong_count (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match τ, α with
      | [], [ this ] =>
        ltac:(M.monadic
          (let this := M.alloc (| this |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "core::sync::atomic::AtomicUsize", "load", [] |),
            [
              M.SubPointer.get_struct_record_field (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "alloc::sync::Arc") [ T; A ],
                    "inner",
                    []
                  |),
                  [ M.read (| this |) ]
                |),
                "alloc::sync::ArcInner",
                "strong"
              |);
              Value.StructTuple "core::sync::atomic::Ordering::Relaxed" []
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_strong_count :
      forall (T A : Ty.t),
      M.IsAssociatedFunction (Self T A) "strong_count" (strong_count T A).
    
    (*
        pub unsafe fn increment_strong_count_in(ptr: *const T, alloc: A)
        where
            A: Clone,
        {
            // Retain Arc, but don't touch refcount by wrapping in ManuallyDrop
            let arc = unsafe { mem::ManuallyDrop::new(Arc::from_raw_in(ptr, alloc)) };
            // Now increase refcount, but don't drop new refcount either
            let _arc_clone: mem::ManuallyDrop<_> = arc.clone();
        }
    *)
    Definition increment_strong_count_in (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match τ, α with
      | [], [ ptr; alloc ] =>
        ltac:(M.monadic
          (let ptr := M.alloc (| ptr |) in
          let alloc := M.alloc (| alloc |) in
          M.read (|
            let arc :=
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "core::mem::manually_drop::ManuallyDrop")
                      [ Ty.apply (Ty.path "alloc::sync::Arc") [ T; A ] ],
                    "new",
                    []
                  |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "alloc::sync::Arc") [ T; A ],
                        "from_raw_in",
                        []
                      |),
                      [ M.read (| ptr |); M.read (| alloc |) ]
                    |)
                  ]
                |)
              |) in
            let _arc_clone :=
              M.alloc (|
                M.call_closure (|
                  M.get_trait_method (|
                    "core::clone::Clone",
                    Ty.apply
                      (Ty.path "core::mem::manually_drop::ManuallyDrop")
                      [ Ty.apply (Ty.path "alloc::sync::Arc") [ T; A ] ],
                    [],
                    "clone",
                    []
                  |),
                  [ arc ]
                |)
              |) in
            M.alloc (| Value.Tuple [] |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_increment_strong_count_in :
      forall (T A : Ty.t),
      M.IsAssociatedFunction (Self T A) "increment_strong_count_in" (increment_strong_count_in T A).
    
    (*
        pub unsafe fn decrement_strong_count_in(ptr: *const T, alloc: A) {
            unsafe { drop(Arc::from_raw_in(ptr, alloc)) };
        }
    *)
    Definition decrement_strong_count_in (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match τ, α with
      | [], [ ptr; alloc ] =>
        ltac:(M.monadic
          (let ptr := M.alloc (| ptr |) in
          let alloc := M.alloc (| alloc |) in
          M.read (|
            let _ :=
              M.alloc (|
                M.call_closure (|
                  M.get_function (|
                    "core::mem::drop",
                    [ Ty.apply (Ty.path "alloc::sync::Arc") [ T; A ] ]
                  |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "alloc::sync::Arc") [ T; A ],
                        "from_raw_in",
                        []
                      |),
                      [ M.read (| ptr |); M.read (| alloc |) ]
                    |)
                  ]
                |)
              |) in
            M.alloc (| Value.Tuple [] |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_decrement_strong_count_in :
      forall (T A : Ty.t),
      M.IsAssociatedFunction (Self T A) "decrement_strong_count_in" (decrement_strong_count_in T A).
    
    (*
        fn inner(&self) -> &ArcInner<T> {
            // This unsafety is ok because while this arc is alive we're guaranteed
            // that the inner pointer is valid. Furthermore, we know that the
            // `ArcInner` structure itself is `Sync` because the inner data is
            // `Sync` as well, so we're ok loaning out an immutable pointer to these
            // contents.
            unsafe { self.ptr.as_ref() }
        }
    *)
    Definition inner (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_associated_function (|
              Ty.apply
                (Ty.path "core::ptr::non_null::NonNull")
                [ Ty.apply (Ty.path "alloc::sync::ArcInner") [ T ] ],
              "as_ref",
              []
            |),
            [
              M.SubPointer.get_struct_record_field (|
                M.read (| self |),
                "alloc::sync::Arc",
                "ptr"
              |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_inner :
      forall (T A : Ty.t),
      M.IsAssociatedFunction (Self T A) "inner" (inner T A).
    
    (*
        unsafe fn drop_slow(&mut self) {
            // Destroy the data at this time, even though we must not free the box
            // allocation itself (there might still be weak pointers lying around).
            unsafe { ptr::drop_in_place(Self::get_mut_unchecked(self)) };
    
            // Drop the weak ref collectively held by all strong references
            // Take a reference to `self.alloc` instead of cloning because 1. it'll
            // last long enough, and 2. you should be able to drop `Arc`s with
            // unclonable allocators
            drop(Weak { ptr: self.ptr, alloc: &self.alloc });
        }
    *)
    Definition drop_slow (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            let _ :=
              M.alloc (|
                M.call_closure (|
                  M.get_function (| "core::ptr::drop_in_place", [ T ] |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "alloc::sync::Arc") [ T; A ],
                        "get_mut_unchecked",
                        []
                      |),
                      [ M.read (| self |) ]
                    |)
                  ]
                |)
              |) in
            let _ :=
              M.alloc (|
                M.call_closure (|
                  M.get_function (|
                    "core::mem::drop",
                    [ Ty.apply (Ty.path "alloc::sync::Weak") [ T; Ty.apply (Ty.path "&") [ A ] ] ]
                  |),
                  [
                    Value.StructRecord
                      "alloc::sync::Weak"
                      [
                        ("ptr",
                          M.read (|
                            M.SubPointer.get_struct_record_field (|
                              M.read (| self |),
                              "alloc::sync::Arc",
                              "ptr"
                            |)
                          |));
                        ("alloc",
                          M.SubPointer.get_struct_record_field (|
                            M.read (| self |),
                            "alloc::sync::Arc",
                            "alloc"
                          |))
                      ]
                  ]
                |)
              |) in
            M.alloc (| Value.Tuple [] |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_drop_slow :
      forall (T A : Ty.t),
      M.IsAssociatedFunction (Self T A) "drop_slow" (drop_slow T A).
    
    (*
        pub fn ptr_eq(this: &Self, other: &Self) -> bool {
            ptr::addr_eq(this.ptr.as_ptr(), other.ptr.as_ptr())
        }
    *)
    Definition ptr_eq (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match τ, α with
      | [], [ this; other ] =>
        ltac:(M.monadic
          (let this := M.alloc (| this |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            M.get_function (|
              "core::ptr::addr_eq",
              [
                Ty.apply (Ty.path "alloc::sync::ArcInner") [ T ];
                Ty.apply (Ty.path "alloc::sync::ArcInner") [ T ]
              ]
            |),
            [
              (* MutToConstPointer *)
              M.pointer_coercion
                (M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "core::ptr::non_null::NonNull")
                      [ Ty.apply (Ty.path "alloc::sync::ArcInner") [ T ] ],
                    "as_ptr",
                    []
                  |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_record_field (|
                        M.read (| this |),
                        "alloc::sync::Arc",
                        "ptr"
                      |)
                    |)
                  ]
                |));
              (* MutToConstPointer *)
              M.pointer_coercion
                (M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "core::ptr::non_null::NonNull")
                      [ Ty.apply (Ty.path "alloc::sync::ArcInner") [ T ] ],
                    "as_ptr",
                    []
                  |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_record_field (|
                        M.read (| other |),
                        "alloc::sync::Arc",
                        "ptr"
                      |)
                    |)
                  ]
                |))
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_ptr_eq :
      forall (T A : Ty.t),
      M.IsAssociatedFunction (Self T A) "ptr_eq" (ptr_eq T A).
    (*
        unsafe fn allocate_for_ptr_in(ptr: *const T, alloc: &A) -> *mut ArcInner<T> {
            // Allocate for the `ArcInner<T>` using the given value.
            unsafe {
                Arc::allocate_for_layout(
                    Layout::for_value(&*ptr),
                    |layout| alloc.allocate(layout),
                    |mem| mem.with_metadata_of(ptr as *const ArcInner<T>),
                )
            }
        }
    *)
    Definition allocate_for_ptr_in (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match τ, α with
      | [], [ ptr; alloc ] =>
        ltac:(M.monadic
          (let ptr := M.alloc (| ptr |) in
          let alloc := M.alloc (| alloc |) in
          M.call_closure (|
            M.get_associated_function (|
              Ty.apply (Ty.path "alloc::sync::Arc") [ T; Ty.path "alloc::alloc::Global" ],
              "allocate_for_layout",
              [
                Ty.function
                  [ Ty.tuple [ Ty.path "core::alloc::layout::Layout" ] ]
                  (Ty.apply
                    (Ty.path "core::result::Result")
                    [
                      Ty.apply
                        (Ty.path "core::ptr::non_null::NonNull")
                        [ Ty.apply (Ty.path "slice") [ Ty.path "u8" ] ];
                      Ty.path "core::alloc::AllocError"
                    ]);
                Ty.function
                  [ Ty.tuple [ Ty.apply (Ty.path "*mut") [ Ty.path "u8" ] ] ]
                  (Ty.apply (Ty.path "*mut") [ Ty.apply (Ty.path "alloc::sync::ArcInner") [ T ] ])
              ]
            |),
            [
              M.call_closure (|
                M.get_associated_function (|
                  Ty.path "core::alloc::layout::Layout",
                  "for_value",
                  [ T ]
                |),
                [ M.read (| ptr |) ]
              |);
              M.closure
                (fun γ =>
                  ltac:(M.monadic
                    match γ with
                    | [ α0 ] =>
                      M.match_operator (|
                        M.alloc (| α0 |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let layout := M.copy (| γ |) in
                              M.call_closure (|
                                M.get_trait_method (|
                                  "core::alloc::Allocator",
                                  A,
                                  [],
                                  "allocate",
                                  []
                                |),
                                [ M.read (| alloc |); M.read (| layout |) ]
                              |)))
                        ]
                      |)
                    | _ => M.impossible (||)
                    end));
              M.closure
                (fun γ =>
                  ltac:(M.monadic
                    match γ with
                    | [ α0 ] =>
                      M.match_operator (|
                        M.alloc (| α0 |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let mem := M.copy (| γ |) in
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "*mut") [ Ty.path "u8" ],
                                  "with_metadata_of",
                                  [ Ty.apply (Ty.path "alloc::sync::ArcInner") [ T ] ]
                                |),
                                [ M.read (| mem |); M.rust_cast (M.read (| ptr |)) ]
                              |)))
                        ]
                      |)
                    | _ => M.impossible (||)
                    end))
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_allocate_for_ptr_in :
      forall (T A : Ty.t),
      M.IsAssociatedFunction (Self T A) "allocate_for_ptr_in" (allocate_for_ptr_in T A).
    
    (*
        fn from_box_in(src: Box<T, A>) -> Arc<T, A> {
            unsafe {
                let value_size = size_of_val(&*src);
                let ptr = Self::allocate_for_ptr_in(&*src, Box::allocator(&src));
    
                // Copy value as bytes
                ptr::copy_nonoverlapping(
                    &*src as *const T as *const u8,
                    &mut ( *ptr).data as *mut _ as *mut u8,
                    value_size,
                );
    
                // Free the allocation without dropping its contents
                let (bptr, alloc) = Box::into_raw_with_allocator(src);
                let src = Box::from_raw(bptr as *mut mem::ManuallyDrop<T>);
                drop(src);
    
                Self::from_ptr_in(ptr, alloc)
            }
        }
    *)
    Definition from_box_in (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match τ, α with
      | [], [ src ] =>
        ltac:(M.monadic
          (let src := M.alloc (| src |) in
          M.read (|
            let value_size :=
              M.alloc (|
                M.call_closure (|
                  M.get_function (| "core::mem::size_of_val", [ T ] |),
                  [ M.read (| src |) ]
                |)
              |) in
            let ptr :=
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "alloc::sync::Arc") [ T; A ],
                    "allocate_for_ptr_in",
                    []
                  |),
                  [
                    M.read (| src |);
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "alloc::boxed::Box") [ T; A ],
                        "allocator",
                        []
                      |),
                      [ src ]
                    |)
                  ]
                |)
              |) in
            let _ :=
              M.alloc (|
                M.call_closure (|
                  M.get_function (| "core::intrinsics::copy_nonoverlapping", [ Ty.path "u8" ] |),
                  [
                    M.rust_cast (M.read (| M.use (M.alloc (| M.read (| src |) |)) |));
                    M.rust_cast
                      (M.read (|
                        M.use
                          (M.alloc (|
                            M.SubPointer.get_struct_record_field (|
                              M.read (| ptr |),
                              "alloc::sync::ArcInner",
                              "data"
                            |)
                          |))
                      |));
                    M.read (| value_size |)
                  ]
                |)
              |) in
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "alloc::boxed::Box") [ T; A ],
                    "into_raw_with_allocator",
                    []
                  |),
                  [ M.read (| src |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let bptr := M.copy (| γ0_0 |) in
                    let alloc := M.copy (| γ0_1 |) in
                    let src :=
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.apply
                              (Ty.path "alloc::boxed::Box")
                              [
                                Ty.apply (Ty.path "core::mem::manually_drop::ManuallyDrop") [ T ];
                                Ty.path "alloc::alloc::Global"
                              ],
                            "from_raw",
                            []
                          |),
                          [ M.rust_cast (M.read (| bptr |)) ]
                        |)
                      |) in
                    let _ :=
                      M.alloc (|
                        M.call_closure (|
                          M.get_function (|
                            "core::mem::drop",
                            [
                              Ty.apply
                                (Ty.path "alloc::boxed::Box")
                                [
                                  Ty.apply (Ty.path "core::mem::manually_drop::ManuallyDrop") [ T ];
                                  Ty.path "alloc::alloc::Global"
                                ]
                            ]
                          |),
                          [ M.read (| src |) ]
                        |)
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "alloc::sync::Arc") [ T; A ],
                          "from_ptr_in",
                          []
                        |),
                        [ M.read (| ptr |); M.read (| alloc |) ]
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_from_box_in :
      forall (T A : Ty.t),
      M.IsAssociatedFunction (Self T A) "from_box_in" (from_box_in T A).
    (*
        pub fn make_mut(this: &mut Self) -> &mut T {
            // Note that we hold both a strong reference and a weak reference.
            // Thus, releasing our strong reference only will not, by itself, cause
            // the memory to be deallocated.
            //
            // Use Acquire to ensure that we see any writes to `weak` that happen
            // before release writes (i.e., decrements) to `strong`. Since we hold a
            // weak count, there's no chance the ArcInner itself could be
            // deallocated.
            if this.inner().strong.compare_exchange(1, 0, Acquire, Relaxed).is_err() {
                // Another strong pointer exists, so we must clone.
                // Pre-allocate memory to allow writing the cloned value directly.
                let mut arc = Self::new_uninit_in(this.alloc.clone());
                unsafe {
                    let data = Arc::get_mut_unchecked(&mut arc);
                    ( **this).write_clone_into_raw(data.as_mut_ptr());
                    *this = arc.assume_init();
                }
            } else if this.inner().weak.load(Relaxed) != 1 {
                // Relaxed suffices in the above because this is fundamentally an
                // optimization: we are always racing with weak pointers being
                // dropped. Worst case, we end up allocated a new Arc unnecessarily.
    
                // We removed the last strong ref, but there are additional weak
                // refs remaining. We'll move the contents to a new Arc, and
                // invalidate the other weak refs.
    
                // Note that it is not possible for the read of `weak` to yield
                // usize::MAX (i.e., locked), since the weak count can only be
                // locked by a thread with a strong reference.
    
                // Materialize our own implicit weak pointer, so that it can clean
                // up the ArcInner as needed.
                let _weak = Weak { ptr: this.ptr, alloc: this.alloc.clone() };
    
                // Can just steal the data, all that's left is Weaks
                let mut arc = Self::new_uninit_in(this.alloc.clone());
                unsafe {
                    let data = Arc::get_mut_unchecked(&mut arc);
                    data.as_mut_ptr().copy_from_nonoverlapping(&**this, 1);
                    ptr::write(this, arc.assume_init());
                }
            } else {
                // We were the sole reference of either kind; bump back up the
                // strong ref count.
                this.inner().strong.store(1, Release);
            }
    
            // As with `get_mut()`, the unsafety is ok because our reference was
            // either unique to begin with, or became one upon cloning the contents.
            unsafe { Self::get_mut_unchecked(this) }
        }
    *)
    Definition make_mut (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match τ, α with
      | [], [ this ] =>
        ltac:(M.monadic
          (let this := M.alloc (| this |) in
          M.read (|
            let _ :=
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "core::result::Result")
                                  [ Ty.path "usize"; Ty.path "usize" ],
                                "is_err",
                                []
                              |),
                              [
                                M.alloc (|
                                  M.call_closure (|
                                    M.get_associated_function (|
                                      Ty.path "core::sync::atomic::AtomicUsize",
                                      "compare_exchange",
                                      []
                                    |),
                                    [
                                      M.SubPointer.get_struct_record_field (|
                                        M.call_closure (|
                                          M.get_associated_function (|
                                            Ty.apply (Ty.path "alloc::sync::Arc") [ T; A ],
                                            "inner",
                                            []
                                          |),
                                          [ M.read (| this |) ]
                                        |),
                                        "alloc::sync::ArcInner",
                                        "strong"
                                      |);
                                      Value.Integer 1;
                                      Value.Integer 0;
                                      Value.StructTuple "core::sync::atomic::Ordering::Acquire" [];
                                      Value.StructTuple "core::sync::atomic::Ordering::Relaxed" []
                                    ]
                                  |)
                                |)
                              ]
                            |)
                          |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      let arc :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply (Ty.path "alloc::sync::Arc") [ T; A ],
                              "new_uninit_in",
                              []
                            |),
                            [
                              M.call_closure (|
                                M.get_trait_method (| "core::clone::Clone", A, [], "clone", [] |),
                                [
                                  M.SubPointer.get_struct_record_field (|
                                    M.read (| this |),
                                    "alloc::sync::Arc",
                                    "alloc"
                                  |)
                                ]
                              |)
                            ]
                          |)
                        |) in
                      let data :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply
                                (Ty.path "alloc::sync::Arc")
                                [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ T ]; A
                                ],
                              "get_mut_unchecked",
                              []
                            |),
                            [ arc ]
                          |)
                        |) in
                      let _ :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_trait_method (|
                              "alloc::alloc::WriteCloneIntoRaw",
                              T,
                              [],
                              "write_clone_into_raw",
                              []
                            |),
                            [
                              M.call_closure (|
                                M.get_trait_method (|
                                  "core::ops::deref::Deref",
                                  Ty.apply (Ty.path "alloc::sync::Arc") [ T; A ],
                                  [],
                                  "deref",
                                  []
                                |),
                                [ M.read (| this |) ]
                              |);
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ T ],
                                  "as_mut_ptr",
                                  []
                                |),
                                [ M.read (| data |) ]
                              |)
                            ]
                          |)
                        |) in
                      let _ :=
                        M.write (|
                          M.read (| this |),
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply
                                (Ty.path "alloc::sync::Arc")
                                [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ T ]; A
                                ],
                              "assume_init",
                              []
                            |),
                            [ M.read (| arc |) ]
                          |)
                        |) in
                      M.alloc (| Value.Tuple [] |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.match_operator (|
                        M.alloc (| Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.use
                                  (M.alloc (|
                                    BinOp.Pure.ne
                                      (M.call_closure (|
                                        M.get_associated_function (|
                                          Ty.path "core::sync::atomic::AtomicUsize",
                                          "load",
                                          []
                                        |),
                                        [
                                          M.SubPointer.get_struct_record_field (|
                                            M.call_closure (|
                                              M.get_associated_function (|
                                                Ty.apply (Ty.path "alloc::sync::Arc") [ T; A ],
                                                "inner",
                                                []
                                              |),
                                              [ M.read (| this |) ]
                                            |),
                                            "alloc::sync::ArcInner",
                                            "weak"
                                          |);
                                          Value.StructTuple
                                            "core::sync::atomic::Ordering::Relaxed"
                                            []
                                        ]
                                      |))
                                      (Value.Integer 1)
                                  |)) in
                              let _ :=
                                M.is_constant_or_break_match (|
                                  M.read (| γ |),
                                  Value.Bool true
                                |) in
                              let _weak :=
                                M.alloc (|
                                  Value.StructRecord
                                    "alloc::sync::Weak"
                                    [
                                      ("ptr",
                                        M.read (|
                                          M.SubPointer.get_struct_record_field (|
                                            M.read (| this |),
                                            "alloc::sync::Arc",
                                            "ptr"
                                          |)
                                        |));
                                      ("alloc",
                                        M.call_closure (|
                                          M.get_trait_method (|
                                            "core::clone::Clone",
                                            A,
                                            [],
                                            "clone",
                                            []
                                          |),
                                          [
                                            M.SubPointer.get_struct_record_field (|
                                              M.read (| this |),
                                              "alloc::sync::Arc",
                                              "alloc"
                                            |)
                                          ]
                                        |))
                                    ]
                                |) in
                              let arc :=
                                M.alloc (|
                                  M.call_closure (|
                                    M.get_associated_function (|
                                      Ty.apply (Ty.path "alloc::sync::Arc") [ T; A ],
                                      "new_uninit_in",
                                      []
                                    |),
                                    [
                                      M.call_closure (|
                                        M.get_trait_method (|
                                          "core::clone::Clone",
                                          A,
                                          [],
                                          "clone",
                                          []
                                        |),
                                        [
                                          M.SubPointer.get_struct_record_field (|
                                            M.read (| this |),
                                            "alloc::sync::Arc",
                                            "alloc"
                                          |)
                                        ]
                                      |)
                                    ]
                                  |)
                                |) in
                              let data :=
                                M.alloc (|
                                  M.call_closure (|
                                    M.get_associated_function (|
                                      Ty.apply
                                        (Ty.path "alloc::sync::Arc")
                                        [
                                          Ty.apply
                                            (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                            [ T ];
                                          A
                                        ],
                                      "get_mut_unchecked",
                                      []
                                    |),
                                    [ arc ]
                                  |)
                                |) in
                              let _ :=
                                M.alloc (|
                                  M.call_closure (|
                                    M.get_associated_function (|
                                      Ty.apply (Ty.path "*mut") [ T ],
                                      "copy_from_nonoverlapping",
                                      []
                                    |),
                                    [
                                      M.call_closure (|
                                        M.get_associated_function (|
                                          Ty.apply
                                            (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                            [ T ],
                                          "as_mut_ptr",
                                          []
                                        |),
                                        [ M.read (| data |) ]
                                      |);
                                      M.call_closure (|
                                        M.get_trait_method (|
                                          "core::ops::deref::Deref",
                                          Ty.apply (Ty.path "alloc::sync::Arc") [ T; A ],
                                          [],
                                          "deref",
                                          []
                                        |),
                                        [ M.read (| this |) ]
                                      |);
                                      Value.Integer 1
                                    ]
                                  |)
                                |) in
                              let _ :=
                                M.alloc (|
                                  M.call_closure (|
                                    M.get_function (|
                                      "core::ptr::write",
                                      [ Ty.apply (Ty.path "alloc::sync::Arc") [ T; A ] ]
                                    |),
                                    [
                                      M.read (| this |);
                                      M.call_closure (|
                                        M.get_associated_function (|
                                          Ty.apply
                                            (Ty.path "alloc::sync::Arc")
                                            [
                                              Ty.apply
                                                (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                                [ T ];
                                              A
                                            ],
                                          "assume_init",
                                          []
                                        |),
                                        [ M.read (| arc |) ]
                                      |)
                                    ]
                                  |)
                                |) in
                              M.alloc (| Value.Tuple [] |)));
                          fun γ =>
                            ltac:(M.monadic
                              (let _ :=
                                M.alloc (|
                                  M.call_closure (|
                                    M.get_associated_function (|
                                      Ty.path "core::sync::atomic::AtomicUsize",
                                      "store",
                                      []
                                    |),
                                    [
                                      M.SubPointer.get_struct_record_field (|
                                        M.call_closure (|
                                          M.get_associated_function (|
                                            Ty.apply (Ty.path "alloc::sync::Arc") [ T; A ],
                                            "inner",
                                            []
                                          |),
                                          [ M.read (| this |) ]
                                        |),
                                        "alloc::sync::ArcInner",
                                        "strong"
                                      |);
                                      Value.Integer 1;
                                      Value.StructTuple "core::sync::atomic::Ordering::Release" []
                                    ]
                                  |)
                                |) in
                              M.alloc (| Value.Tuple [] |)))
                        ]
                      |)))
                ]
              |) in
            M.alloc (|
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply (Ty.path "alloc::sync::Arc") [ T; A ],
                  "get_mut_unchecked",
                  []
                |),
                [ M.read (| this |) ]
              |)
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_make_mut :
      forall (T A : Ty.t),
      M.IsAssociatedFunction (Self T A) "make_mut" (make_mut T A).
    
    (*
        pub fn unwrap_or_clone(this: Self) -> T {
            Arc::try_unwrap(this).unwrap_or_else(|arc| ( *arc).clone())
        }
    *)
    Definition unwrap_or_clone (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match τ, α with
      | [], [ this ] =>
        ltac:(M.monadic
          (let this := M.alloc (| this |) in
          M.call_closure (|
            M.get_associated_function (|
              Ty.apply
                (Ty.path "core::result::Result")
                [ T; Ty.apply (Ty.path "alloc::sync::Arc") [ T; A ] ],
              "unwrap_or_else",
              [ Ty.function [ Ty.tuple [ Ty.apply (Ty.path "alloc::sync::Arc") [ T; A ] ] ] T ]
            |),
            [
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply (Ty.path "alloc::sync::Arc") [ T; A ],
                  "try_unwrap",
                  []
                |),
                [ M.read (| this |) ]
              |);
              M.closure
                (fun γ =>
                  ltac:(M.monadic
                    match γ with
                    | [ α0 ] =>
                      M.match_operator (|
                        M.alloc (| α0 |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let arc := M.copy (| γ |) in
                              M.call_closure (|
                                M.get_trait_method (| "core::clone::Clone", T, [], "clone", [] |),
                                [
                                  M.call_closure (|
                                    M.get_trait_method (|
                                      "core::ops::deref::Deref",
                                      Ty.apply (Ty.path "alloc::sync::Arc") [ T; A ],
                                      [],
                                      "deref",
                                      []
                                    |),
                                    [ arc ]
                                  |)
                                ]
                              |)))
                        ]
                      |)
                    | _ => M.impossible (||)
                    end))
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_unwrap_or_clone :
      forall (T A : Ty.t),
      M.IsAssociatedFunction (Self T A) "unwrap_or_clone" (unwrap_or_clone T A).
    (*
        pub fn get_mut(this: &mut Self) -> Option<&mut T> {
            if this.is_unique() {
                // This unsafety is ok because we're guaranteed that the pointer
                // returned is the *only* pointer that will ever be returned to T. Our
                // reference count is guaranteed to be 1 at this point, and we required
                // the Arc itself to be `mut`, so we're returning the only possible
                // reference to the inner data.
                unsafe { Some(Arc::get_mut_unchecked(this)) }
            } else {
                None
            }
        }
    *)
    Definition get_mut (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match τ, α with
      | [], [ this ] =>
        ltac:(M.monadic
          (let this := M.alloc (| this |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply (Ty.path "alloc::sync::Arc") [ T; A ],
                              "is_unique",
                              []
                            |),
                            [ M.read (| this |) ]
                          |)
                        |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::option::Option::Some"
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply (Ty.path "alloc::sync::Arc") [ T; A ],
                              "get_mut_unchecked",
                              []
                            |),
                            [ M.read (| this |) ]
                          |)
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic (M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_get_mut :
      forall (T A : Ty.t),
      M.IsAssociatedFunction (Self T A) "get_mut" (get_mut T A).
    
    (*
        pub unsafe fn get_mut_unchecked(this: &mut Self) -> &mut T {
            // We are careful to *not* create a reference covering the "count" fields, as
            // this would alias with concurrent access to the reference counts (e.g. by `Weak`).
            unsafe { &mut ( *this.ptr.as_ptr()).data }
        }
    *)
    Definition get_mut_unchecked (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match τ, α with
      | [], [ this ] =>
        ltac:(M.monadic
          (let this := M.alloc (| this |) in
          M.SubPointer.get_struct_record_field (|
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply
                  (Ty.path "core::ptr::non_null::NonNull")
                  [ Ty.apply (Ty.path "alloc::sync::ArcInner") [ T ] ],
                "as_ptr",
                []
              |),
              [
                M.read (|
                  M.SubPointer.get_struct_record_field (|
                    M.read (| this |),
                    "alloc::sync::Arc",
                    "ptr"
                  |)
                |)
              ]
            |),
            "alloc::sync::ArcInner",
            "data"
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_get_mut_unchecked :
      forall (T A : Ty.t),
      M.IsAssociatedFunction (Self T A) "get_mut_unchecked" (get_mut_unchecked T A).
    
    (*
        fn is_unique(&mut self) -> bool {
            // lock the weak pointer count if we appear to be the sole weak pointer
            // holder.
            //
            // The acquire label here ensures a happens-before relationship with any
            // writes to `strong` (in particular in `Weak::upgrade`) prior to decrements
            // of the `weak` count (via `Weak::drop`, which uses release). If the upgraded
            // weak ref was never dropped, the CAS here will fail so we do not care to synchronize.
            if self.inner().weak.compare_exchange(1, usize::MAX, Acquire, Relaxed).is_ok() {
                // This needs to be an `Acquire` to synchronize with the decrement of the `strong`
                // counter in `drop` -- the only access that happens when any but the last reference
                // is being dropped.
                let unique = self.inner().strong.load(Acquire) == 1;
    
                // The release write here synchronizes with a read in `downgrade`,
                // effectively preventing the above read of `strong` from happening
                // after the write.
                self.inner().weak.store(1, Release); // release the lock
                unique
            } else {
                false
            }
        }
    *)
    Definition is_unique (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply
                                (Ty.path "core::result::Result")
                                [ Ty.path "usize"; Ty.path "usize" ],
                              "is_ok",
                              []
                            |),
                            [
                              M.alloc (|
                                M.call_closure (|
                                  M.get_associated_function (|
                                    Ty.path "core::sync::atomic::AtomicUsize",
                                    "compare_exchange",
                                    []
                                  |),
                                  [
                                    M.SubPointer.get_struct_record_field (|
                                      M.call_closure (|
                                        M.get_associated_function (|
                                          Ty.apply (Ty.path "alloc::sync::Arc") [ T; A ],
                                          "inner",
                                          []
                                        |),
                                        [ M.read (| self |) ]
                                      |),
                                      "alloc::sync::ArcInner",
                                      "weak"
                                    |);
                                    Value.Integer 1;
                                    M.read (| M.get_constant (| "core::num::MAX" |) |);
                                    Value.StructTuple "core::sync::atomic::Ordering::Acquire" [];
                                    Value.StructTuple "core::sync::atomic::Ordering::Relaxed" []
                                  ]
                                |)
                              |)
                            ]
                          |)
                        |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    let unique :=
                      M.alloc (|
                        BinOp.Pure.eq
                          (M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::sync::atomic::AtomicUsize",
                              "load",
                              []
                            |),
                            [
                              M.SubPointer.get_struct_record_field (|
                                M.call_closure (|
                                  M.get_associated_function (|
                                    Ty.apply (Ty.path "alloc::sync::Arc") [ T; A ],
                                    "inner",
                                    []
                                  |),
                                  [ M.read (| self |) ]
                                |),
                                "alloc::sync::ArcInner",
                                "strong"
                              |);
                              Value.StructTuple "core::sync::atomic::Ordering::Acquire" []
                            ]
                          |))
                          (Value.Integer 1)
                      |) in
                    let _ :=
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.path "core::sync::atomic::AtomicUsize",
                            "store",
                            []
                          |),
                          [
                            M.SubPointer.get_struct_record_field (|
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "alloc::sync::Arc") [ T; A ],
                                  "inner",
                                  []
                                |),
                                [ M.read (| self |) ]
                              |),
                              "alloc::sync::ArcInner",
                              "weak"
                            |);
                            Value.Integer 1;
                            Value.StructTuple "core::sync::atomic::Ordering::Release" []
                          ]
                        |)
                      |) in
                    unique));
                fun γ => ltac:(M.monadic (M.alloc (| Value.Bool false |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_is_unique :
      forall (T A : Ty.t),
      M.IsAssociatedFunction (Self T A) "is_unique" (is_unique T A).
  End Impl_alloc_sync_Arc_T_A.
  
  (* StructRecord
    {
      name := "Weak";
      ty_params := [ "T"; "A" ];
      fields :=
        [
          ("ptr",
            Ty.apply
              (Ty.path "core::ptr::non_null::NonNull")
              [ Ty.apply (Ty.path "alloc::sync::ArcInner") [ T ] ]);
          ("alloc", A)
        ];
    } *)
  
  Module Impl_core_marker_Send_where_core_marker_Sized_T_where_core_marker_Sync_T_where_core_marker_Send_T_where_core_alloc_Allocator_A_where_core_marker_Send_A_for_alloc_sync_Weak_T_A.
    Definition Self (T A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::sync::Weak") [ T; A ].
    
    Axiom Implements :
      forall (T A : Ty.t),
      M.IsTraitInstance
        "core::marker::Send"
        (Self T A)
        (* Trait polymorphic types *) []
        (* Instance *) [].
  End Impl_core_marker_Send_where_core_marker_Sized_T_where_core_marker_Sync_T_where_core_marker_Send_T_where_core_alloc_Allocator_A_where_core_marker_Send_A_for_alloc_sync_Weak_T_A.
  
  Module Impl_core_marker_Sync_where_core_marker_Sized_T_where_core_marker_Sync_T_where_core_marker_Send_T_where_core_alloc_Allocator_A_where_core_marker_Sync_A_for_alloc_sync_Weak_T_A.
    Definition Self (T A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::sync::Weak") [ T; A ].
    
    Axiom Implements :
      forall (T A : Ty.t),
      M.IsTraitInstance
        "core::marker::Sync"
        (Self T A)
        (* Trait polymorphic types *) []
        (* Instance *) [].
  End Impl_core_marker_Sync_where_core_marker_Sized_T_where_core_marker_Sync_T_where_core_marker_Send_T_where_core_alloc_Allocator_A_where_core_marker_Sync_A_for_alloc_sync_Weak_T_A.
  
  Module Impl_core_ops_unsize_CoerceUnsized_where_core_marker_Sized_T_where_core_marker_Unsize_T_U_where_core_marker_Sized_U_where_core_alloc_Allocator_A_alloc_sync_Weak_U_A_for_alloc_sync_Weak_T_A.
    Definition Self (T U A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::sync::Weak") [ T; A ].
    
    Axiom Implements :
      forall (T U A : Ty.t),
      M.IsTraitInstance
        "core::ops::unsize::CoerceUnsized"
        (Self T U A)
        (* Trait polymorphic types *) [ (* T *) Ty.apply (Ty.path "alloc::sync::Weak") [ U; A ] ]
        (* Instance *) [].
  End Impl_core_ops_unsize_CoerceUnsized_where_core_marker_Sized_T_where_core_marker_Unsize_T_U_where_core_marker_Sized_U_where_core_alloc_Allocator_A_alloc_sync_Weak_U_A_for_alloc_sync_Weak_T_A.
  
  Module Impl_core_ops_unsize_DispatchFromDyn_where_core_marker_Sized_T_where_core_marker_Unsize_T_U_where_core_marker_Sized_U_alloc_sync_Weak_U_alloc_alloc_Global_for_alloc_sync_Weak_T_alloc_alloc_Global.
    Definition Self (T U : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "alloc::sync::Weak") [ T; Ty.path "alloc::alloc::Global" ].
    
    Axiom Implements :
      forall (T U : Ty.t),
      M.IsTraitInstance
        "core::ops::unsize::DispatchFromDyn"
        (Self T U)
        (* Trait polymorphic types *)
        [ (* T *) Ty.apply (Ty.path "alloc::sync::Weak") [ U; Ty.path "alloc::alloc::Global" ] ]
        (* Instance *) [].
  End Impl_core_ops_unsize_DispatchFromDyn_where_core_marker_Sized_T_where_core_marker_Unsize_T_U_where_core_marker_Sized_U_alloc_sync_Weak_U_alloc_alloc_Global_for_alloc_sync_Weak_T_alloc_alloc_Global.
  
  Module Impl_core_fmt_Debug_where_core_marker_Sized_T_for_alloc_sync_Weak_T_alloc_alloc_Global.
    Definition Self (T : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "alloc::sync::Weak") [ T; Ty.path "alloc::alloc::Global" ].
    
    (*
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            write!(f, "(Weak)")
        }
    *)
    Definition fmt (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match τ, α with
      | [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "core::fmt::Formatter", "write_fmt", [] |),
            [
              M.read (| f |);
              M.call_closure (|
                M.get_associated_function (| Ty.path "core::fmt::Arguments", "new_const", [] |),
                [
                  (* Unsize *)
                  M.pointer_coercion
                    (M.alloc (| Value.Array [ M.read (| Value.String "(Weak)" |) ] |))
                ]
              |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "core::fmt::Debug"
        (Self T)
        (* Trait polymorphic types *) []
        (* Instance *) [ ("fmt", InstanceField.Method (fmt T)) ].
  End Impl_core_fmt_Debug_where_core_marker_Sized_T_for_alloc_sync_Weak_T_alloc_alloc_Global.
  
  (* StructRecord
    {
      name := "ArcInner";
      ty_params := [ "T" ];
      fields :=
        [
          ("strong", Ty.path "core::sync::atomic::AtomicUsize");
          ("weak", Ty.path "core::sync::atomic::AtomicUsize");
          ("data", T)
        ];
    } *)
  
  (*
  fn arcinner_layout_for_value_layout(layout: Layout) -> Layout {
      // Calculate layout using the given value layout.
      // Previously, layout was calculated on the expression
      // `&*(ptr as *const ArcInner<T>)`, but this created a misaligned
      // reference (see #54908).
      Layout::new::<ArcInner<()>>().extend(layout).unwrap().0.pad_to_align()
  }
  *)
  Definition arcinner_layout_for_value_layout (τ : list Ty.t) (α : list Value.t) : M :=
    match τ, α with
    | [], [ layout ] =>
      ltac:(M.monadic
        (let layout := M.alloc (| layout |) in
        M.call_closure (|
          M.get_associated_function (| Ty.path "core::alloc::layout::Layout", "pad_to_align", [] |),
          [
            M.SubPointer.get_tuple_field (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "core::result::Result")
                      [
                        Ty.tuple [ Ty.path "core::alloc::layout::Layout"; Ty.path "usize" ];
                        Ty.path "core::alloc::layout::LayoutError"
                      ],
                    "unwrap",
                    []
                  |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.path "core::alloc::layout::Layout",
                        "extend",
                        []
                      |),
                      [
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::alloc::layout::Layout",
                              "new",
                              [ Ty.apply (Ty.path "alloc::sync::ArcInner") [ Ty.tuple [] ] ]
                            |),
                            []
                          |)
                        |);
                        M.read (| layout |)
                      ]
                    |)
                  ]
                |)
              |),
              0
            |)
          ]
        |)))
    | _, _ => M.impossible
    end.
  
  Module Impl_core_marker_Send_where_core_marker_Sized_T_where_core_marker_Sync_T_where_core_marker_Send_T_for_alloc_sync_ArcInner_T.
    Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::sync::ArcInner") [ T ].
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "core::marker::Send"
        (Self T)
        (* Trait polymorphic types *) []
        (* Instance *) [].
  End Impl_core_marker_Send_where_core_marker_Sized_T_where_core_marker_Sync_T_where_core_marker_Send_T_for_alloc_sync_ArcInner_T.
  
  Module Impl_core_marker_Sync_where_core_marker_Sized_T_where_core_marker_Sync_T_where_core_marker_Send_T_for_alloc_sync_ArcInner_T.
    Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::sync::ArcInner") [ T ].
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "core::marker::Sync"
        (Self T)
        (* Trait polymorphic types *) []
        (* Instance *) [].
  End Impl_core_marker_Sync_where_core_marker_Sized_T_where_core_marker_Sync_T_where_core_marker_Send_T_for_alloc_sync_ArcInner_T.
  
  
  
  Module Impl_alloc_sync_Arc_slice_T_alloc_alloc_Global.
    Definition Self (T : Ty.t) : Ty.t :=
      Ty.apply
        (Ty.path "alloc::sync::Arc")
        [ Ty.apply (Ty.path "slice") [ T ]; Ty.path "alloc::alloc::Global" ].
    
    (*
        pub fn new_uninit_slice(len: usize) -> Arc<[mem::MaybeUninit<T>]> {
            unsafe { Arc::from_ptr(Arc::allocate_for_slice(len)) }
        }
    *)
    Definition new_uninit_slice (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match τ, α with
      | [], [ len ] =>
        ltac:(M.monadic
          (let len := M.alloc (| len |) in
          M.call_closure (|
            M.get_associated_function (|
              Ty.apply
                (Ty.path "alloc::sync::Arc")
                [
                  Ty.apply
                    (Ty.path "slice")
                    [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ T ] ];
                  Ty.path "alloc::alloc::Global"
                ],
              "from_ptr",
              []
            |),
            [
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "alloc::sync::Arc")
                    [
                      Ty.apply
                        (Ty.path "slice")
                        [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ T ] ];
                      Ty.path "alloc::alloc::Global"
                    ],
                  "allocate_for_slice",
                  []
                |),
                [ M.read (| len |) ]
              |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_new_uninit_slice :
      forall (T : Ty.t),
      M.IsAssociatedFunction (Self T) "new_uninit_slice" (new_uninit_slice T).
    
    (*
        pub fn new_zeroed_slice(len: usize) -> Arc<[mem::MaybeUninit<T>]> {
            unsafe {
                Arc::from_ptr(Arc::allocate_for_layout(
                    Layout::array::<T>(len).unwrap(),
                    |layout| Global.allocate_zeroed(layout),
                    |mem| {
                        ptr::slice_from_raw_parts_mut(mem as *mut T, len)
                            as *mut ArcInner<[mem::MaybeUninit<T>]>
                    },
                ))
            }
        }
    *)
    Definition new_zeroed_slice (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match τ, α with
      | [], [ len ] =>
        ltac:(M.monadic
          (let len := M.alloc (| len |) in
          M.call_closure (|
            M.get_associated_function (|
              Ty.apply
                (Ty.path "alloc::sync::Arc")
                [
                  Ty.apply
                    (Ty.path "slice")
                    [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ T ] ];
                  Ty.path "alloc::alloc::Global"
                ],
              "from_ptr",
              []
            |),
            [
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "alloc::sync::Arc")
                    [
                      Ty.apply
                        (Ty.path "slice")
                        [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ T ] ];
                      Ty.path "alloc::alloc::Global"
                    ],
                  "allocate_for_layout",
                  [
                    Ty.function
                      [ Ty.tuple [ Ty.path "core::alloc::layout::Layout" ] ]
                      (Ty.apply
                        (Ty.path "core::result::Result")
                        [
                          Ty.apply
                            (Ty.path "core::ptr::non_null::NonNull")
                            [ Ty.apply (Ty.path "slice") [ Ty.path "u8" ] ];
                          Ty.path "core::alloc::AllocError"
                        ]);
                    Ty.function
                      [ Ty.tuple [ Ty.apply (Ty.path "*mut") [ Ty.path "u8" ] ] ]
                      (Ty.apply
                        (Ty.path "*mut")
                        [
                          Ty.apply
                            (Ty.path "alloc::sync::ArcInner")
                            [
                              Ty.apply
                                (Ty.path "slice")
                                [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ T ] ]
                            ]
                        ])
                  ]
                |),
                [
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "core::result::Result")
                        [
                          Ty.path "core::alloc::layout::Layout";
                          Ty.path "core::alloc::layout::LayoutError"
                        ],
                      "unwrap",
                      []
                    |),
                    [
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::alloc::layout::Layout",
                          "array",
                          [ T ]
                        |),
                        [ M.read (| len |) ]
                      |)
                    ]
                  |);
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0 ] =>
                          M.match_operator (|
                            M.alloc (| α0 |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let layout := M.copy (| γ |) in
                                  M.call_closure (|
                                    M.get_trait_method (|
                                      "core::alloc::Allocator",
                                      Ty.path "alloc::alloc::Global",
                                      [],
                                      "allocate_zeroed",
                                      []
                                    |),
                                    [
                                      M.alloc (| Value.StructTuple "alloc::alloc::Global" [] |);
                                      M.read (| layout |)
                                    ]
                                  |)))
                            ]
                          |)
                        | _ => M.impossible (||)
                        end));
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0 ] =>
                          M.match_operator (|
                            M.alloc (| α0 |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let mem := M.copy (| γ |) in
                                  M.rust_cast
                                    (M.call_closure (|
                                      M.get_function (|
                                        "core::ptr::slice_from_raw_parts_mut",
                                        [ T ]
                                      |),
                                      [ M.rust_cast (M.read (| mem |)); M.read (| len |) ]
                                    |))))
                            ]
                          |)
                        | _ => M.impossible (||)
                        end))
                ]
              |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_new_zeroed_slice :
      forall (T : Ty.t),
      M.IsAssociatedFunction (Self T) "new_zeroed_slice" (new_zeroed_slice T).
    (*
        unsafe fn allocate_for_slice(len: usize) -> *mut ArcInner<[T]> {
            unsafe {
                Self::allocate_for_layout(
                    Layout::array::<T>(len).unwrap(),
                    |layout| Global.allocate(layout),
                    |mem| ptr::slice_from_raw_parts_mut(mem.cast::<T>(), len) as *mut ArcInner<[T]>,
                )
            }
        }
    *)
    Definition allocate_for_slice (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match τ, α with
      | [], [ len ] =>
        ltac:(M.monadic
          (let len := M.alloc (| len |) in
          M.call_closure (|
            M.get_associated_function (|
              Ty.apply
                (Ty.path "alloc::sync::Arc")
                [ Ty.apply (Ty.path "slice") [ T ]; Ty.path "alloc::alloc::Global" ],
              "allocate_for_layout",
              [
                Ty.function
                  [ Ty.tuple [ Ty.path "core::alloc::layout::Layout" ] ]
                  (Ty.apply
                    (Ty.path "core::result::Result")
                    [
                      Ty.apply
                        (Ty.path "core::ptr::non_null::NonNull")
                        [ Ty.apply (Ty.path "slice") [ Ty.path "u8" ] ];
                      Ty.path "core::alloc::AllocError"
                    ]);
                Ty.function
                  [ Ty.tuple [ Ty.apply (Ty.path "*mut") [ Ty.path "u8" ] ] ]
                  (Ty.apply
                    (Ty.path "*mut")
                    [
                      Ty.apply
                        (Ty.path "alloc::sync::ArcInner")
                        [ Ty.apply (Ty.path "slice") [ T ] ]
                    ])
              ]
            |),
            [
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "core::result::Result")
                    [
                      Ty.path "core::alloc::layout::Layout";
                      Ty.path "core::alloc::layout::LayoutError"
                    ],
                  "unwrap",
                  []
                |),
                [
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.path "core::alloc::layout::Layout",
                      "array",
                      [ T ]
                    |),
                    [ M.read (| len |) ]
                  |)
                ]
              |);
              M.closure
                (fun γ =>
                  ltac:(M.monadic
                    match γ with
                    | [ α0 ] =>
                      M.match_operator (|
                        M.alloc (| α0 |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let layout := M.copy (| γ |) in
                              M.call_closure (|
                                M.get_trait_method (|
                                  "core::alloc::Allocator",
                                  Ty.path "alloc::alloc::Global",
                                  [],
                                  "allocate",
                                  []
                                |),
                                [
                                  M.alloc (| Value.StructTuple "alloc::alloc::Global" [] |);
                                  M.read (| layout |)
                                ]
                              |)))
                        ]
                      |)
                    | _ => M.impossible (||)
                    end));
              M.closure
                (fun γ =>
                  ltac:(M.monadic
                    match γ with
                    | [ α0 ] =>
                      M.match_operator (|
                        M.alloc (| α0 |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let mem := M.copy (| γ |) in
                              M.rust_cast
                                (M.call_closure (|
                                  M.get_function (| "core::ptr::slice_from_raw_parts_mut", [ T ] |),
                                  [
                                    M.call_closure (|
                                      M.get_associated_function (|
                                        Ty.apply (Ty.path "*mut") [ Ty.path "u8" ],
                                        "cast",
                                        [ T ]
                                      |),
                                      [ M.read (| mem |) ]
                                    |);
                                    M.read (| len |)
                                  ]
                                |))))
                        ]
                      |)
                    | _ => M.impossible (||)
                    end))
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_allocate_for_slice :
      forall (T : Ty.t),
      M.IsAssociatedFunction (Self T) "allocate_for_slice" (allocate_for_slice T).
    
    (*
        unsafe fn copy_from_slice(v: &[T]) -> Arc<[T]> {
            unsafe {
                let ptr = Self::allocate_for_slice(v.len());
    
                ptr::copy_nonoverlapping(v.as_ptr(), &mut ( *ptr).data as *mut [T] as *mut T, v.len());
    
                Self::from_ptr(ptr)
            }
        }
    *)
    Definition copy_from_slice (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match τ, α with
      | [], [ v ] =>
        ltac:(M.monadic
          (let v := M.alloc (| v |) in
          M.read (|
            let ptr :=
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "alloc::sync::Arc")
                      [ Ty.apply (Ty.path "slice") [ T ]; Ty.path "alloc::alloc::Global" ],
                    "allocate_for_slice",
                    []
                  |),
                  [
                    M.call_closure (|
                      M.get_associated_function (| Ty.apply (Ty.path "slice") [ T ], "len", [] |),
                      [ M.read (| v |) ]
                    |)
                  ]
                |)
              |) in
            let _ :=
              M.alloc (|
                M.call_closure (|
                  M.get_function (| "core::intrinsics::copy_nonoverlapping", [ T ] |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "slice") [ T ],
                        "as_ptr",
                        []
                      |),
                      [ M.read (| v |) ]
                    |);
                    M.rust_cast
                      (M.read (|
                        M.use
                          (M.alloc (|
                            M.SubPointer.get_struct_record_field (|
                              M.read (| ptr |),
                              "alloc::sync::ArcInner",
                              "data"
                            |)
                          |))
                      |));
                    M.call_closure (|
                      M.get_associated_function (| Ty.apply (Ty.path "slice") [ T ], "len", [] |),
                      [ M.read (| v |) ]
                    |)
                  ]
                |)
              |) in
            M.alloc (|
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "alloc::sync::Arc")
                    [ Ty.apply (Ty.path "slice") [ T ]; Ty.path "alloc::alloc::Global" ],
                  "from_ptr",
                  []
                |),
                [ M.read (| ptr |) ]
              |)
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_copy_from_slice :
      forall (T : Ty.t),
      M.IsAssociatedFunction (Self T) "copy_from_slice" (copy_from_slice T).
    
    (*
        unsafe fn from_iter_exact(iter: impl Iterator<Item = T>, len: usize) -> Arc<[T]> {
            // Panic guard while cloning T elements.
            // In the event of a panic, elements that have been written
            // into the new ArcInner will be dropped, then the memory freed.
            struct Guard<T> {
                mem: NonNull<u8>,
                elems: *mut T,
                layout: Layout,
                n_elems: usize,
            }
    
            impl<T> Drop for Guard<T> {
                fn drop(&mut self) {
                    unsafe {
                        let slice = from_raw_parts_mut(self.elems, self.n_elems);
                        ptr::drop_in_place(slice);
    
                        Global.deallocate(self.mem, self.layout);
                    }
                }
            }
    
            unsafe {
                let ptr = Self::allocate_for_slice(len);
    
                let mem = ptr as *mut _ as *mut u8;
                let layout = Layout::for_value(&*ptr);
    
                // Pointer to first element
                let elems = &mut ( *ptr).data as *mut [T] as *mut T;
    
                let mut guard = Guard { mem: NonNull::new_unchecked(mem), elems, layout, n_elems: 0 };
    
                for (i, item) in iter.enumerate() {
                    ptr::write(elems.add(i), item);
                    guard.n_elems += 1;
                }
    
                // All clear. Forget the guard so it doesn't free the new ArcInner.
                mem::forget(guard);
    
                Self::from_ptr(ptr)
            }
        }
    *)
    Definition from_iter_exact (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match τ, α with
      | [ impl_Iterator_Item___T_ ], [ iter; len ] =>
        ltac:(M.monadic
          (let iter := M.alloc (| iter |) in
          let len := M.alloc (| len |) in
          M.read (|
            let ptr :=
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "alloc::sync::Arc")
                      [ Ty.apply (Ty.path "slice") [ T ]; Ty.path "alloc::alloc::Global" ],
                    "allocate_for_slice",
                    []
                  |),
                  [ M.read (| len |) ]
                |)
              |) in
            let mem := M.alloc (| M.rust_cast (M.rust_cast (M.read (| ptr |))) |) in
            let layout :=
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.path "core::alloc::layout::Layout",
                    "for_value",
                    [
                      Ty.apply
                        (Ty.path "alloc::sync::ArcInner")
                        [ Ty.apply (Ty.path "slice") [ T ] ]
                    ]
                  |),
                  [ M.read (| ptr |) ]
                |)
              |) in
            let elems :=
              M.alloc (|
                M.rust_cast
                  (M.read (|
                    M.use
                      (M.alloc (|
                        M.SubPointer.get_struct_record_field (|
                          M.read (| ptr |),
                          "alloc::sync::ArcInner",
                          "data"
                        |)
                      |))
                  |))
              |) in
            let guard :=
              M.alloc (|
                Value.StructRecord
                  "alloc::sync::from_iter_exact::Guard"
                  [
                    ("mem",
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "core::ptr::non_null::NonNull") [ Ty.path "u8" ],
                          "new_unchecked",
                          []
                        |),
                        [ M.read (| mem |) ]
                      |));
                    ("elems", M.read (| elems |));
                    ("layout", M.read (| layout |));
                    ("n_elems", Value.Integer 0)
                  ]
              |) in
            let _ :=
              M.use
                (M.match_operator (|
                  M.alloc (|
                    M.call_closure (|
                      M.get_trait_method (|
                        "core::iter::traits::collect::IntoIterator",
                        Ty.apply
                          (Ty.path "core::iter::adapters::enumerate::Enumerate")
                          [ impl_Iterator_Item___T_ ],
                        [],
                        "into_iter",
                        []
                      |),
                      [
                        M.call_closure (|
                          M.get_trait_method (|
                            "core::iter::traits::iterator::Iterator",
                            impl_Iterator_Item___T_,
                            [],
                            "enumerate",
                            []
                          |),
                          [ M.read (| iter |) ]
                        |)
                      ]
                    |)
                  |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let iter := M.copy (| γ |) in
                        M.loop (|
                          ltac:(M.monadic
                            (let _ :=
                              M.match_operator (|
                                M.alloc (|
                                  M.call_closure (|
                                    M.get_trait_method (|
                                      "core::iter::traits::iterator::Iterator",
                                      Ty.apply
                                        (Ty.path "core::iter::adapters::enumerate::Enumerate")
                                        [ impl_Iterator_Item___T_ ],
                                      [],
                                      "next",
                                      []
                                    |),
                                    [ iter ]
                                  |)
                                |),
                                [
                                  fun γ =>
                                    ltac:(M.monadic
                                      (M.alloc (|
                                        M.never_to_any (| M.read (| M.break (||) |) |)
                                      |)));
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let γ0_0 :=
                                        M.SubPointer.get_struct_tuple_field (|
                                          γ,
                                          "core::option::Option::Some",
                                          0
                                        |) in
                                      let γ1_0 := M.SubPointer.get_tuple_field (| γ0_0, 0 |) in
                                      let γ1_1 := M.SubPointer.get_tuple_field (| γ0_0, 1 |) in
                                      let i := M.copy (| γ1_0 |) in
                                      let item := M.copy (| γ1_1 |) in
                                      let _ :=
                                        M.alloc (|
                                          M.call_closure (|
                                            M.get_function (| "core::ptr::write", [ T ] |),
                                            [
                                              M.call_closure (|
                                                M.get_associated_function (|
                                                  Ty.apply (Ty.path "*mut") [ T ],
                                                  "add",
                                                  []
                                                |),
                                                [ M.read (| elems |); M.read (| i |) ]
                                              |);
                                              M.read (| item |)
                                            ]
                                          |)
                                        |) in
                                      let _ :=
                                        let β :=
                                          M.SubPointer.get_struct_record_field (|
                                            guard,
                                            "alloc::sync::from_iter_exact::Guard",
                                            "n_elems"
                                          |) in
                                        M.write (|
                                          β,
                                          BinOp.Panic.add (|
                                            Integer.Usize,
                                            M.read (| β |),
                                            Value.Integer 1
                                          |)
                                        |) in
                                      M.alloc (| Value.Tuple [] |)))
                                ]
                              |) in
                            M.alloc (| Value.Tuple [] |)))
                        |)))
                  ]
                |)) in
            let _ :=
              M.alloc (|
                M.call_closure (|
                  M.get_function (|
                    "core::mem::forget",
                    [ Ty.apply (Ty.path "alloc::sync::from_iter_exact::Guard") [ T ] ]
                  |),
                  [ M.read (| guard |) ]
                |)
              |) in
            M.alloc (|
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "alloc::sync::Arc")
                    [ Ty.apply (Ty.path "slice") [ T ]; Ty.path "alloc::alloc::Global" ],
                  "from_ptr",
                  []
                |),
                [ M.read (| ptr |) ]
              |)
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_from_iter_exact :
      forall (T : Ty.t),
      M.IsAssociatedFunction (Self T) "from_iter_exact" (from_iter_exact T).
  End Impl_alloc_sync_Arc_slice_T_alloc_alloc_Global.
  
  Module Impl_alloc_sync_Arc_slice_T_A.
    Definition Self (T A : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "alloc::sync::Arc") [ Ty.apply (Ty.path "slice") [ T ]; A ].
    
    (*
        pub fn new_uninit_slice_in(len: usize, alloc: A) -> Arc<[mem::MaybeUninit<T>], A> {
            unsafe { Arc::from_ptr_in(Arc::allocate_for_slice_in(len, &alloc), alloc) }
        }
    *)
    Definition new_uninit_slice_in (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match τ, α with
      | [], [ len; alloc ] =>
        ltac:(M.monadic
          (let len := M.alloc (| len |) in
          let alloc := M.alloc (| alloc |) in
          M.call_closure (|
            M.get_associated_function (|
              Ty.apply
                (Ty.path "alloc::sync::Arc")
                [
                  Ty.apply
                    (Ty.path "slice")
                    [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ T ] ];
                  A
                ],
              "from_ptr_in",
              []
            |),
            [
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "alloc::sync::Arc")
                    [
                      Ty.apply
                        (Ty.path "slice")
                        [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ T ] ];
                      A
                    ],
                  "allocate_for_slice_in",
                  []
                |),
                [ M.read (| len |); alloc ]
              |);
              M.read (| alloc |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_new_uninit_slice_in :
      forall (T A : Ty.t),
      M.IsAssociatedFunction (Self T A) "new_uninit_slice_in" (new_uninit_slice_in T A).
    
    (*
        pub fn new_zeroed_slice_in(len: usize, alloc: A) -> Arc<[mem::MaybeUninit<T>], A> {
            unsafe {
                Arc::from_ptr_in(
                    Arc::allocate_for_layout(
                        Layout::array::<T>(len).unwrap(),
                        |layout| alloc.allocate_zeroed(layout),
                        |mem| {
                            ptr::slice_from_raw_parts_mut(mem.cast::<T>(), len)
                                as *mut ArcInner<[mem::MaybeUninit<T>]>
                        },
                    ),
                    alloc,
                )
            }
        }
    *)
    Definition new_zeroed_slice_in (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match τ, α with
      | [], [ len; alloc ] =>
        ltac:(M.monadic
          (let len := M.alloc (| len |) in
          let alloc := M.alloc (| alloc |) in
          M.call_closure (|
            M.get_associated_function (|
              Ty.apply
                (Ty.path "alloc::sync::Arc")
                [
                  Ty.apply
                    (Ty.path "slice")
                    [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ T ] ];
                  A
                ],
              "from_ptr_in",
              []
            |),
            [
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "alloc::sync::Arc")
                    [
                      Ty.apply
                        (Ty.path "slice")
                        [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ T ] ];
                      Ty.path "alloc::alloc::Global"
                    ],
                  "allocate_for_layout",
                  [
                    Ty.function
                      [ Ty.tuple [ Ty.path "core::alloc::layout::Layout" ] ]
                      (Ty.apply
                        (Ty.path "core::result::Result")
                        [
                          Ty.apply
                            (Ty.path "core::ptr::non_null::NonNull")
                            [ Ty.apply (Ty.path "slice") [ Ty.path "u8" ] ];
                          Ty.path "core::alloc::AllocError"
                        ]);
                    Ty.function
                      [ Ty.tuple [ Ty.apply (Ty.path "*mut") [ Ty.path "u8" ] ] ]
                      (Ty.apply
                        (Ty.path "*mut")
                        [
                          Ty.apply
                            (Ty.path "alloc::sync::ArcInner")
                            [
                              Ty.apply
                                (Ty.path "slice")
                                [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ T ] ]
                            ]
                        ])
                  ]
                |),
                [
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "core::result::Result")
                        [
                          Ty.path "core::alloc::layout::Layout";
                          Ty.path "core::alloc::layout::LayoutError"
                        ],
                      "unwrap",
                      []
                    |),
                    [
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::alloc::layout::Layout",
                          "array",
                          [ T ]
                        |),
                        [ M.read (| len |) ]
                      |)
                    ]
                  |);
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0 ] =>
                          M.match_operator (|
                            M.alloc (| α0 |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let layout := M.copy (| γ |) in
                                  M.call_closure (|
                                    M.get_trait_method (|
                                      "core::alloc::Allocator",
                                      A,
                                      [],
                                      "allocate_zeroed",
                                      []
                                    |),
                                    [ alloc; M.read (| layout |) ]
                                  |)))
                            ]
                          |)
                        | _ => M.impossible (||)
                        end));
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0 ] =>
                          M.match_operator (|
                            M.alloc (| α0 |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let mem := M.copy (| γ |) in
                                  M.rust_cast
                                    (M.call_closure (|
                                      M.get_function (|
                                        "core::ptr::slice_from_raw_parts_mut",
                                        [ T ]
                                      |),
                                      [
                                        M.call_closure (|
                                          M.get_associated_function (|
                                            Ty.apply (Ty.path "*mut") [ Ty.path "u8" ],
                                            "cast",
                                            [ T ]
                                          |),
                                          [ M.read (| mem |) ]
                                        |);
                                        M.read (| len |)
                                      ]
                                    |))))
                            ]
                          |)
                        | _ => M.impossible (||)
                        end))
                ]
              |);
              M.read (| alloc |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_new_zeroed_slice_in :
      forall (T A : Ty.t),
      M.IsAssociatedFunction (Self T A) "new_zeroed_slice_in" (new_zeroed_slice_in T A).
    (*
        unsafe fn allocate_for_slice_in(len: usize, alloc: &A) -> *mut ArcInner<[T]> {
            unsafe {
                Arc::allocate_for_layout(
                    Layout::array::<T>(len).unwrap(),
                    |layout| alloc.allocate(layout),
                    |mem| ptr::slice_from_raw_parts_mut(mem.cast::<T>(), len) as *mut ArcInner<[T]>,
                )
            }
        }
    *)
    Definition allocate_for_slice_in (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match τ, α with
      | [], [ len; alloc ] =>
        ltac:(M.monadic
          (let len := M.alloc (| len |) in
          let alloc := M.alloc (| alloc |) in
          M.call_closure (|
            M.get_associated_function (|
              Ty.apply
                (Ty.path "alloc::sync::Arc")
                [ Ty.apply (Ty.path "slice") [ T ]; Ty.path "alloc::alloc::Global" ],
              "allocate_for_layout",
              [
                Ty.function
                  [ Ty.tuple [ Ty.path "core::alloc::layout::Layout" ] ]
                  (Ty.apply
                    (Ty.path "core::result::Result")
                    [
                      Ty.apply
                        (Ty.path "core::ptr::non_null::NonNull")
                        [ Ty.apply (Ty.path "slice") [ Ty.path "u8" ] ];
                      Ty.path "core::alloc::AllocError"
                    ]);
                Ty.function
                  [ Ty.tuple [ Ty.apply (Ty.path "*mut") [ Ty.path "u8" ] ] ]
                  (Ty.apply
                    (Ty.path "*mut")
                    [
                      Ty.apply
                        (Ty.path "alloc::sync::ArcInner")
                        [ Ty.apply (Ty.path "slice") [ T ] ]
                    ])
              ]
            |),
            [
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "core::result::Result")
                    [
                      Ty.path "core::alloc::layout::Layout";
                      Ty.path "core::alloc::layout::LayoutError"
                    ],
                  "unwrap",
                  []
                |),
                [
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.path "core::alloc::layout::Layout",
                      "array",
                      [ T ]
                    |),
                    [ M.read (| len |) ]
                  |)
                ]
              |);
              M.closure
                (fun γ =>
                  ltac:(M.monadic
                    match γ with
                    | [ α0 ] =>
                      M.match_operator (|
                        M.alloc (| α0 |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let layout := M.copy (| γ |) in
                              M.call_closure (|
                                M.get_trait_method (|
                                  "core::alloc::Allocator",
                                  A,
                                  [],
                                  "allocate",
                                  []
                                |),
                                [ M.read (| alloc |); M.read (| layout |) ]
                              |)))
                        ]
                      |)
                    | _ => M.impossible (||)
                    end));
              M.closure
                (fun γ =>
                  ltac:(M.monadic
                    match γ with
                    | [ α0 ] =>
                      M.match_operator (|
                        M.alloc (| α0 |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let mem := M.copy (| γ |) in
                              M.rust_cast
                                (M.call_closure (|
                                  M.get_function (| "core::ptr::slice_from_raw_parts_mut", [ T ] |),
                                  [
                                    M.call_closure (|
                                      M.get_associated_function (|
                                        Ty.apply (Ty.path "*mut") [ Ty.path "u8" ],
                                        "cast",
                                        [ T ]
                                      |),
                                      [ M.read (| mem |) ]
                                    |);
                                    M.read (| len |)
                                  ]
                                |))))
                        ]
                      |)
                    | _ => M.impossible (||)
                    end))
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_allocate_for_slice_in :
      forall (T A : Ty.t),
      M.IsAssociatedFunction (Self T A) "allocate_for_slice_in" (allocate_for_slice_in T A).
  End Impl_alloc_sync_Arc_slice_T_A.
  
  Module Impl_alloc_sync_Arc_core_mem_maybe_uninit_MaybeUninit_T_A.
    Definition Self (T A : Ty.t) : Ty.t :=
      Ty.apply
        (Ty.path "alloc::sync::Arc")
        [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ T ]; A ].
    
    (*
        pub unsafe fn assume_init(self) -> Arc<T, A>
        where
            A: Clone,
        {
            let md_self = mem::ManuallyDrop::new(self);
            unsafe { Arc::from_inner_in(md_self.ptr.cast(), md_self.alloc.clone()) }
        }
    *)
    Definition assume_init (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            let md_self :=
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "core::mem::manually_drop::ManuallyDrop")
                      [
                        Ty.apply
                          (Ty.path "alloc::sync::Arc")
                          [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ T ]; A ]
                      ],
                    "new",
                    []
                  |),
                  [ M.read (| self |) ]
                |)
              |) in
            M.alloc (|
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply (Ty.path "alloc::sync::Arc") [ T; A ],
                  "from_inner_in",
                  []
                |),
                [
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "core::ptr::non_null::NonNull")
                        [
                          Ty.apply
                            (Ty.path "alloc::sync::ArcInner")
                            [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ T ] ]
                        ],
                      "cast",
                      [ Ty.apply (Ty.path "alloc::sync::ArcInner") [ T ] ]
                    |),
                    [
                      M.read (|
                        M.SubPointer.get_struct_record_field (|
                          M.call_closure (|
                            M.get_trait_method (|
                              "core::ops::deref::Deref",
                              Ty.apply
                                (Ty.path "core::mem::manually_drop::ManuallyDrop")
                                [
                                  Ty.apply
                                    (Ty.path "alloc::sync::Arc")
                                    [
                                      Ty.apply
                                        (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                        [ T ];
                                      A
                                    ]
                                ],
                              [],
                              "deref",
                              []
                            |),
                            [ md_self ]
                          |),
                          "alloc::sync::Arc",
                          "ptr"
                        |)
                      |)
                    ]
                  |);
                  M.call_closure (|
                    M.get_trait_method (| "core::clone::Clone", A, [], "clone", [] |),
                    [
                      M.SubPointer.get_struct_record_field (|
                        M.call_closure (|
                          M.get_trait_method (|
                            "core::ops::deref::Deref",
                            Ty.apply
                              (Ty.path "core::mem::manually_drop::ManuallyDrop")
                              [
                                Ty.apply
                                  (Ty.path "alloc::sync::Arc")
                                  [
                                    Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ T ];
                                    A
                                  ]
                              ],
                            [],
                            "deref",
                            []
                          |),
                          [ md_self ]
                        |),
                        "alloc::sync::Arc",
                        "alloc"
                      |)
                    ]
                  |)
                ]
              |)
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_assume_init :
      forall (T A : Ty.t),
      M.IsAssociatedFunction (Self T A) "assume_init" (assume_init T A).
  End Impl_alloc_sync_Arc_core_mem_maybe_uninit_MaybeUninit_T_A.
  
  Module Impl_alloc_sync_Arc_slice_core_mem_maybe_uninit_MaybeUninit_T_A.
    Definition Self (T A : Ty.t) : Ty.t :=
      Ty.apply
        (Ty.path "alloc::sync::Arc")
        [
          Ty.apply
            (Ty.path "slice")
            [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ T ] ];
          A
        ].
    
    (*
        pub unsafe fn assume_init(self) -> Arc<[T], A>
        where
            A: Clone,
        {
            let md_self = mem::ManuallyDrop::new(self);
            unsafe { Arc::from_ptr_in(md_self.ptr.as_ptr() as _, md_self.alloc.clone()) }
        }
    *)
    Definition assume_init (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            let md_self :=
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "core::mem::manually_drop::ManuallyDrop")
                      [
                        Ty.apply
                          (Ty.path "alloc::sync::Arc")
                          [
                            Ty.apply
                              (Ty.path "slice")
                              [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ T ] ];
                            A
                          ]
                      ],
                    "new",
                    []
                  |),
                  [ M.read (| self |) ]
                |)
              |) in
            M.alloc (|
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply (Ty.path "alloc::sync::Arc") [ Ty.apply (Ty.path "slice") [ T ]; A ],
                  "from_ptr_in",
                  []
                |),
                [
                  M.rust_cast
                    (M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "core::ptr::non_null::NonNull")
                          [
                            Ty.apply
                              (Ty.path "alloc::sync::ArcInner")
                              [
                                Ty.apply
                                  (Ty.path "slice")
                                  [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ T ]
                                  ]
                              ]
                          ],
                        "as_ptr",
                        []
                      |),
                      [
                        M.read (|
                          M.SubPointer.get_struct_record_field (|
                            M.call_closure (|
                              M.get_trait_method (|
                                "core::ops::deref::Deref",
                                Ty.apply
                                  (Ty.path "core::mem::manually_drop::ManuallyDrop")
                                  [
                                    Ty.apply
                                      (Ty.path "alloc::sync::Arc")
                                      [
                                        Ty.apply
                                          (Ty.path "slice")
                                          [
                                            Ty.apply
                                              (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                              [ T ]
                                          ];
                                        A
                                      ]
                                  ],
                                [],
                                "deref",
                                []
                              |),
                              [ md_self ]
                            |),
                            "alloc::sync::Arc",
                            "ptr"
                          |)
                        |)
                      ]
                    |));
                  M.call_closure (|
                    M.get_trait_method (| "core::clone::Clone", A, [], "clone", [] |),
                    [
                      M.SubPointer.get_struct_record_field (|
                        M.call_closure (|
                          M.get_trait_method (|
                            "core::ops::deref::Deref",
                            Ty.apply
                              (Ty.path "core::mem::manually_drop::ManuallyDrop")
                              [
                                Ty.apply
                                  (Ty.path "alloc::sync::Arc")
                                  [
                                    Ty.apply
                                      (Ty.path "slice")
                                      [
                                        Ty.apply
                                          (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                          [ T ]
                                      ];
                                    A
                                  ]
                              ],
                            [],
                            "deref",
                            []
                          |),
                          [ md_self ]
                        |),
                        "alloc::sync::Arc",
                        "alloc"
                      |)
                    ]
                  |)
                ]
              |)
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_assume_init :
      forall (T A : Ty.t),
      M.IsAssociatedFunction (Self T A) "assume_init" (assume_init T A).
  End Impl_alloc_sync_Arc_slice_core_mem_maybe_uninit_MaybeUninit_T_A.
  
  
  
  
  
  
  
  (* Trait *)
  (* Empty module 'ArcFromSlice' *)
  
  Module Impl_alloc_sync_ArcFromSlice_where_core_clone_Clone_T_T_for_alloc_sync_Arc_slice_T_alloc_alloc_Global.
    Definition Self (T : Ty.t) : Ty.t :=
      Ty.apply
        (Ty.path "alloc::sync::Arc")
        [ Ty.apply (Ty.path "slice") [ T ]; Ty.path "alloc::alloc::Global" ].
    
    (*
        default fn from_slice(v: &[T]) -> Self {
            unsafe { Self::from_iter_exact(v.iter().cloned(), v.len()) }
        }
    *)
    Definition from_slice (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match τ, α with
      | [], [ v ] =>
        ltac:(M.monadic
          (let v := M.alloc (| v |) in
          M.call_closure (|
            M.get_associated_function (|
              Ty.apply
                (Ty.path "alloc::sync::Arc")
                [ Ty.apply (Ty.path "slice") [ T ]; Ty.path "alloc::alloc::Global" ],
              "from_iter_exact",
              [
                Ty.apply
                  (Ty.path "core::iter::adapters::cloned::Cloned")
                  [ Ty.apply (Ty.path "core::slice::iter::Iter") [ T ] ]
              ]
            |),
            [
              M.call_closure (|
                M.get_trait_method (|
                  "core::iter::traits::iterator::Iterator",
                  Ty.apply (Ty.path "core::slice::iter::Iter") [ T ],
                  [],
                  "cloned",
                  [ T ]
                |),
                [
                  M.call_closure (|
                    M.get_associated_function (| Ty.apply (Ty.path "slice") [ T ], "iter", [] |),
                    [ M.read (| v |) ]
                  |)
                ]
              |);
              M.call_closure (|
                M.get_associated_function (| Ty.apply (Ty.path "slice") [ T ], "len", [] |),
                [ M.read (| v |) ]
              |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "alloc::sync::ArcFromSlice"
        (Self T)
        (* Trait polymorphic types *) [ (* T *) T ]
        (* Instance *) [ ("from_slice", InstanceField.Method (from_slice T)) ].
  End Impl_alloc_sync_ArcFromSlice_where_core_clone_Clone_T_T_for_alloc_sync_Arc_slice_T_alloc_alloc_Global.
  
  Module Impl_alloc_sync_ArcFromSlice_where_core_marker_Copy_T_T_for_alloc_sync_Arc_slice_T_alloc_alloc_Global.
    Definition Self (T : Ty.t) : Ty.t :=
      Ty.apply
        (Ty.path "alloc::sync::Arc")
        [ Ty.apply (Ty.path "slice") [ T ]; Ty.path "alloc::alloc::Global" ].
    
    (*
        fn from_slice(v: &[T]) -> Self {
            unsafe { Arc::copy_from_slice(v) }
        }
    *)
    Definition from_slice (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match τ, α with
      | [], [ v ] =>
        ltac:(M.monadic
          (let v := M.alloc (| v |) in
          M.call_closure (|
            M.get_associated_function (|
              Ty.apply
                (Ty.path "alloc::sync::Arc")
                [ Ty.apply (Ty.path "slice") [ T ]; Ty.path "alloc::alloc::Global" ],
              "copy_from_slice",
              []
            |),
            [ M.read (| v |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "alloc::sync::ArcFromSlice"
        (Self T)
        (* Trait polymorphic types *) [ (* T *) T ]
        (* Instance *) [ ("from_slice", InstanceField.Method (from_slice T)) ].
  End Impl_alloc_sync_ArcFromSlice_where_core_marker_Copy_T_T_for_alloc_sync_Arc_slice_T_alloc_alloc_Global.
  
  Module Impl_core_clone_Clone_where_core_marker_Sized_T_where_core_alloc_Allocator_A_where_core_clone_Clone_A_for_alloc_sync_Arc_T_A.
    Definition Self (T A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::sync::Arc") [ T; A ].
    
    (*
        fn clone(&self) -> Arc<T, A> {
            // Using a relaxed ordering is alright here, as knowledge of the
            // original reference prevents other threads from erroneously deleting
            // the object.
            //
            // As explained in the [Boost documentation][1], Increasing the
            // reference counter can always be done with memory_order_relaxed: New
            // references to an object can only be formed from an existing
            // reference, and passing an existing reference from one thread to
            // another must already provide any required synchronization.
            //
            // [1]: (www.boost.org/doc/libs/1_55_0/doc/html/atomic/usage_examples.html)
            let old_size = self.inner().strong.fetch_add(1, Relaxed);
    
            // However we need to guard against massive refcounts in case someone is `mem::forget`ing
            // Arcs. If we don't do this the count can overflow and users will use-after free. This
            // branch will never be taken in any realistic program. We abort because such a program is
            // incredibly degenerate, and we don't care to support it.
            //
            // This check is not 100% water-proof: we error when the refcount grows beyond `isize::MAX`.
            // But we do that check *after* having done the increment, so there is a chance here that
            // the worst already happened and we actually do overflow the `usize` counter. However, that
            // requires the counter to grow from `isize::MAX` to `usize::MAX` between the increment
            // above and the `abort` below, which seems exceedingly unlikely.
            //
            // This is a global invariant, and also applies when using a compare-exchange loop to increment
            // counters in other methods.
            // Otherwise, the counter could be brought to an almost-overflow using a compare-exchange loop,
            // and then overflow using a few `fetch_add`s.
            if old_size > MAX_REFCOUNT {
                abort();
            }
    
            unsafe { Self::from_inner_in(self.ptr, self.alloc.clone()) }
        }
    *)
    Definition clone (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            let old_size :=
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.path "core::sync::atomic::AtomicUsize",
                    "fetch_add",
                    []
                  |),
                  [
                    M.SubPointer.get_struct_record_field (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "alloc::sync::Arc") [ T; A ],
                          "inner",
                          []
                        |),
                        [ M.read (| self |) ]
                      |),
                      "alloc::sync::ArcInner",
                      "strong"
                    |);
                    Value.Integer 1;
                    Value.StructTuple "core::sync::atomic::Ordering::Relaxed" []
                  ]
                |)
              |) in
            let _ :=
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            BinOp.Pure.gt
                              (M.read (| old_size |))
                              (M.read (| M.get_constant (| "alloc::sync::MAX_REFCOUNT" |) |))
                          |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (|
                        M.never_to_any (|
                          M.call_closure (|
                            M.get_function (| "core::intrinsics::abort", [] |),
                            []
                          |)
                        |)
                      |)));
                  fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                ]
              |) in
            M.alloc (|
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply (Ty.path "alloc::sync::Arc") [ T; A ],
                  "from_inner_in",
                  []
                |),
                [
                  M.read (|
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "alloc::sync::Arc",
                      "ptr"
                    |)
                  |);
                  M.call_closure (|
                    M.get_trait_method (| "core::clone::Clone", A, [], "clone", [] |),
                    [
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "alloc::sync::Arc",
                        "alloc"
                      |)
                    ]
                  |)
                ]
              |)
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (T A : Ty.t),
      M.IsTraitInstance
        "core::clone::Clone"
        (Self T A)
        (* Trait polymorphic types *) []
        (* Instance *) [ ("clone", InstanceField.Method (clone T A)) ].
  End Impl_core_clone_Clone_where_core_marker_Sized_T_where_core_alloc_Allocator_A_where_core_clone_Clone_A_for_alloc_sync_Arc_T_A.
  
  Module Impl_core_ops_deref_Deref_where_core_marker_Sized_T_where_core_alloc_Allocator_A_for_alloc_sync_Arc_T_A.
    Definition Self (T A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::sync::Arc") [ T; A ].
    
    (*     type Target = T; *)
    Definition _Target (T A : Ty.t) : Ty.t := T.
    
    (*
        fn deref(&self) -> &T {
            &self.inner().data
        }
    *)
    Definition deref (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.SubPointer.get_struct_record_field (|
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply (Ty.path "alloc::sync::Arc") [ T; A ],
                "inner",
                []
              |),
              [ M.read (| self |) ]
            |),
            "alloc::sync::ArcInner",
            "data"
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (T A : Ty.t),
      M.IsTraitInstance
        "core::ops::deref::Deref"
        (Self T A)
        (* Trait polymorphic types *) []
        (* Instance *)
        [ ("Target", InstanceField.Ty (_Target T A)); ("deref", InstanceField.Method (deref T A)) ].
  End Impl_core_ops_deref_Deref_where_core_marker_Sized_T_where_core_alloc_Allocator_A_for_alloc_sync_Arc_T_A.
  
  Module Impl_core_ops_deref_Receiver_where_core_marker_Sized_T_for_alloc_sync_Arc_T_alloc_alloc_Global.
    Definition Self (T : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "alloc::sync::Arc") [ T; Ty.path "alloc::alloc::Global" ].
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "core::ops::deref::Receiver"
        (Self T)
        (* Trait polymorphic types *) []
        (* Instance *) [].
  End Impl_core_ops_deref_Receiver_where_core_marker_Sized_T_for_alloc_sync_Arc_T_alloc_alloc_Global.
  
  
  
  Module Impl_core_ops_drop_Drop_where_core_marker_Sized_T_where_core_alloc_Allocator_A_for_alloc_sync_Arc_T_A.
    Definition Self (T A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::sync::Arc") [ T; A ].
    
    (*
        fn drop(&mut self) {
            // Because `fetch_sub` is already atomic, we do not need to synchronize
            // with other threads unless we are going to delete the object. This
            // same logic applies to the below `fetch_sub` to the `weak` count.
            if self.inner().strong.fetch_sub(1, Release) != 1 {
                return;
            }
    
            // This fence is needed to prevent reordering of use of the data and
            // deletion of the data. Because it is marked `Release`, the decreasing
            // of the reference count synchronizes with this `Acquire` fence. This
            // means that use of the data happens before decreasing the reference
            // count, which happens before this fence, which happens before the
            // deletion of the data.
            //
            // As explained in the [Boost documentation][1],
            //
            // > It is important to enforce any possible access to the object in one
            // > thread (through an existing reference) to *happen before* deleting
            // > the object in a different thread. This is achieved by a "release"
            // > operation after dropping a reference (any access to the object
            // > through this reference must obviously happened before), and an
            // > "acquire" operation before deleting the object.
            //
            // In particular, while the contents of an Arc are usually immutable, it's
            // possible to have interior writes to something like a Mutex<T>. Since a
            // Mutex is not acquired when it is deleted, we can't rely on its
            // synchronization logic to make writes in thread A visible to a destructor
            // running in thread B.
            //
            // Also note that the Acquire fence here could probably be replaced with an
            // Acquire load, which could improve performance in highly-contended
            // situations. See [2].
            //
            // [1]: (www.boost.org/doc/libs/1_55_0/doc/html/atomic/usage_examples.html)
            // [2]: (https://github.com/rust-lang/rust/pull/41714)
            acquire!(self.inner().strong);
    
            unsafe {
                self.drop_slow();
            }
        }
    *)
    Definition drop (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.catch_return (|
            ltac:(M.monadic
              (M.read (|
                let _ :=
                  M.match_operator (|
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                BinOp.Pure.ne
                                  (M.call_closure (|
                                    M.get_associated_function (|
                                      Ty.path "core::sync::atomic::AtomicUsize",
                                      "fetch_sub",
                                      []
                                    |),
                                    [
                                      M.SubPointer.get_struct_record_field (|
                                        M.call_closure (|
                                          M.get_associated_function (|
                                            Ty.apply (Ty.path "alloc::sync::Arc") [ T; A ],
                                            "inner",
                                            []
                                          |),
                                          [ M.read (| self |) ]
                                        |),
                                        "alloc::sync::ArcInner",
                                        "strong"
                                      |);
                                      Value.Integer 1;
                                      Value.StructTuple "core::sync::atomic::Ordering::Release" []
                                    ]
                                  |))
                                  (Value.Integer 1)
                              |)) in
                          let _ :=
                            M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (|
                            M.never_to_any (| M.read (| M.return_ (| Value.Tuple [] |) |) |)
                          |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                let _ :=
                  M.alloc (|
                    M.call_closure (|
                      M.get_function (| "core::sync::atomic::fence", [] |),
                      [ Value.StructTuple "core::sync::atomic::Ordering::Acquire" [] ]
                    |)
                  |) in
                let _ :=
                  M.alloc (|
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "alloc::sync::Arc") [ T; A ],
                        "drop_slow",
                        []
                      |),
                      [ M.read (| self |) ]
                    |)
                  |) in
                M.alloc (| Value.Tuple [] |)
              |)))
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (T A : Ty.t),
      M.IsTraitInstance
        "core::ops::drop::Drop"
        (Self T A)
        (* Trait polymorphic types *) []
        (* Instance *) [ ("drop", InstanceField.Method (drop T A)) ].
  End Impl_core_ops_drop_Drop_where_core_marker_Sized_T_where_core_alloc_Allocator_A_for_alloc_sync_Arc_T_A.
  
  Module Impl_alloc_sync_Arc_Dyn_core_any_Any_Trait_A.
    Definition Self (A : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "alloc::sync::Arc") [ Ty.dyn [ ("core::any::Any::Trait", []) ]; A ].
    
    (*
        pub fn downcast<T>(self) -> Result<Arc<T, A>, Self>
        where
            T: Any + Send + Sync,
        {
            if ( *self).is::<T>() {
                unsafe {
                    let ptr = self.ptr.cast::<ArcInner<T>>();
                    let alloc = self.alloc.clone();
                    mem::forget(self);
                    Ok(Arc::from_inner_in(ptr, alloc))
                }
            } else {
                Err(self)
            }
        }
    *)
    Definition downcast (A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self A in
      match τ, α with
      | [ T ], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.dyn [ ("core::any::Any::Trait", []) ],
                              "is",
                              [ T ]
                            |),
                            [
                              M.call_closure (|
                                M.get_trait_method (|
                                  "core::ops::deref::Deref",
                                  Ty.apply
                                    (Ty.path "alloc::sync::Arc")
                                    [ Ty.dyn [ ("core::any::Any::Trait", []) ]; A ],
                                  [],
                                  "deref",
                                  []
                                |),
                                [ self ]
                              |)
                            ]
                          |)
                        |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    let ptr :=
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.apply
                              (Ty.path "core::ptr::non_null::NonNull")
                              [
                                Ty.apply
                                  (Ty.path "alloc::sync::ArcInner")
                                  [ Ty.dyn [ ("core::any::Any::Trait", []) ] ]
                              ],
                            "cast",
                            [ Ty.apply (Ty.path "alloc::sync::ArcInner") [ T ] ]
                          |),
                          [
                            M.read (|
                              M.SubPointer.get_struct_record_field (|
                                self,
                                "alloc::sync::Arc",
                                "ptr"
                              |)
                            |)
                          ]
                        |)
                      |) in
                    let alloc :=
                      M.alloc (|
                        M.call_closure (|
                          M.get_trait_method (| "core::clone::Clone", A, [], "clone", [] |),
                          [
                            M.SubPointer.get_struct_record_field (|
                              self,
                              "alloc::sync::Arc",
                              "alloc"
                            |)
                          ]
                        |)
                      |) in
                    let _ :=
                      M.alloc (|
                        M.call_closure (|
                          M.get_function (|
                            "core::mem::forget",
                            [
                              Ty.apply
                                (Ty.path "alloc::sync::Arc")
                                [ Ty.dyn [ ("core::any::Any::Trait", []) ]; A ]
                            ]
                          |),
                          [ M.read (| self |) ]
                        |)
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply (Ty.path "alloc::sync::Arc") [ T; A ],
                              "from_inner_in",
                              []
                            |),
                            [ M.read (| ptr |); M.read (| alloc |) ]
                          |)
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Err"
                        [ (* Unsize *) M.pointer_coercion (M.read (| self |)) ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_downcast :
      forall (A : Ty.t),
      M.IsAssociatedFunction (Self A) "downcast" (downcast A).
    
    (*
        pub unsafe fn downcast_unchecked<T>(self) -> Arc<T, A>
        where
            T: Any + Send + Sync,
        {
            unsafe {
                let ptr = self.ptr.cast::<ArcInner<T>>();
                let alloc = self.alloc.clone();
                mem::forget(self);
                Arc::from_inner_in(ptr, alloc)
            }
        }
    *)
    Definition downcast_unchecked (A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self A in
      match τ, α with
      | [ T ], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            let ptr :=
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "core::ptr::non_null::NonNull")
                      [
                        Ty.apply
                          (Ty.path "alloc::sync::ArcInner")
                          [ Ty.dyn [ ("core::any::Any::Trait", []) ] ]
                      ],
                    "cast",
                    [ Ty.apply (Ty.path "alloc::sync::ArcInner") [ T ] ]
                  |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_record_field (| self, "alloc::sync::Arc", "ptr" |)
                    |)
                  ]
                |)
              |) in
            let alloc :=
              M.alloc (|
                M.call_closure (|
                  M.get_trait_method (| "core::clone::Clone", A, [], "clone", [] |),
                  [ M.SubPointer.get_struct_record_field (| self, "alloc::sync::Arc", "alloc" |) ]
                |)
              |) in
            let _ :=
              M.alloc (|
                M.call_closure (|
                  M.get_function (|
                    "core::mem::forget",
                    [
                      Ty.apply
                        (Ty.path "alloc::sync::Arc")
                        [ Ty.dyn [ ("core::any::Any::Trait", []) ]; A ]
                    ]
                  |),
                  [ M.read (| self |) ]
                |)
              |) in
            M.alloc (|
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply (Ty.path "alloc::sync::Arc") [ T; A ],
                  "from_inner_in",
                  []
                |),
                [ M.read (| ptr |); M.read (| alloc |) ]
              |)
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_downcast_unchecked :
      forall (A : Ty.t),
      M.IsAssociatedFunction (Self A) "downcast_unchecked" (downcast_unchecked A).
  End Impl_alloc_sync_Arc_Dyn_core_any_Any_Trait_A.
  
  Module Impl_alloc_sync_Weak_T_alloc_alloc_Global.
    Definition Self (T : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "alloc::sync::Weak") [ T; Ty.path "alloc::alloc::Global" ].
    
    (*
        pub const fn new() -> Weak<T> {
            Weak {
                ptr: unsafe { NonNull::new_unchecked(ptr::invalid_mut::<ArcInner<T>>(usize::MAX)) },
                alloc: Global,
            }
        }
    *)
    Definition new (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match τ, α with
      | [], [] =>
        ltac:(M.monadic
          (Value.StructRecord
            "alloc::sync::Weak"
            [
              ("ptr",
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "core::ptr::non_null::NonNull")
                      [ Ty.apply (Ty.path "alloc::sync::ArcInner") [ T ] ],
                    "new_unchecked",
                    []
                  |),
                  [
                    M.call_closure (|
                      M.get_function (|
                        "core::ptr::invalid_mut",
                        [ Ty.apply (Ty.path "alloc::sync::ArcInner") [ T ] ]
                      |),
                      [ M.read (| M.get_constant (| "core::num::MAX" |) |) ]
                    |)
                  ]
                |));
              ("alloc", Value.StructTuple "alloc::alloc::Global" [])
            ]))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_new : forall (T : Ty.t), M.IsAssociatedFunction (Self T) "new" (new T).
    (*
        pub unsafe fn from_raw(ptr: *const T) -> Self {
            unsafe { Weak::from_raw_in(ptr, Global) }
        }
    *)
    Definition from_raw (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match τ, α with
      | [], [ ptr ] =>
        ltac:(M.monadic
          (let ptr := M.alloc (| ptr |) in
          M.call_closure (|
            M.get_associated_function (|
              Ty.apply (Ty.path "alloc::sync::Weak") [ T; Ty.path "alloc::alloc::Global" ],
              "from_raw_in",
              []
            |),
            [ M.read (| ptr |); Value.StructTuple "alloc::alloc::Global" [] ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_from_raw :
      forall (T : Ty.t),
      M.IsAssociatedFunction (Self T) "from_raw" (from_raw T).
  End Impl_alloc_sync_Weak_T_alloc_alloc_Global.
  
  Module Impl_alloc_sync_Weak_T_A.
    Definition Self (T A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::sync::Weak") [ T; A ].
    
    (*
        pub fn new_in(alloc: A) -> Weak<T, A> {
            Weak {
                ptr: unsafe { NonNull::new_unchecked(ptr::invalid_mut::<ArcInner<T>>(usize::MAX)) },
                alloc,
            }
        }
    *)
    Definition new_in (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match τ, α with
      | [], [ alloc ] =>
        ltac:(M.monadic
          (let alloc := M.alloc (| alloc |) in
          Value.StructRecord
            "alloc::sync::Weak"
            [
              ("ptr",
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "core::ptr::non_null::NonNull")
                      [ Ty.apply (Ty.path "alloc::sync::ArcInner") [ T ] ],
                    "new_unchecked",
                    []
                  |),
                  [
                    M.call_closure (|
                      M.get_function (|
                        "core::ptr::invalid_mut",
                        [ Ty.apply (Ty.path "alloc::sync::ArcInner") [ T ] ]
                      |),
                      [ M.read (| M.get_constant (| "core::num::MAX" |) |) ]
                    |)
                  ]
                |));
              ("alloc", M.read (| alloc |))
            ]))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_new_in :
      forall (T A : Ty.t),
      M.IsAssociatedFunction (Self T A) "new_in" (new_in T A).
    (*
        pub fn as_ptr(&self) -> *const T {
            let ptr: *mut ArcInner<T> = NonNull::as_ptr(self.ptr);
    
            if is_dangling(ptr) {
                // If the pointer is dangling, we return the sentinel directly. This cannot be
                // a valid payload address, as the payload is at least as aligned as ArcInner (usize).
                ptr as *const T
            } else {
                // SAFETY: if is_dangling returns false, then the pointer is dereferenceable.
                // The payload may be dropped at this point, and we have to maintain provenance,
                // so use raw pointer manipulation.
                unsafe { ptr::addr_of_mut!(( *ptr).data) }
            }
        }
    *)
    Definition as_ptr (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            let ptr :=
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "core::ptr::non_null::NonNull")
                      [ Ty.apply (Ty.path "alloc::sync::ArcInner") [ T ] ],
                    "as_ptr",
                    []
                  |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "alloc::sync::Weak",
                        "ptr"
                      |)
                    |)
                  ]
                |)
              |) in
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          M.call_closure (|
                            M.get_function (|
                              "alloc::rc::is_dangling",
                              [ Ty.apply (Ty.path "alloc::sync::ArcInner") [ T ] ]
                            |),
                            [ M.read (| ptr |) ]
                          |)
                        |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (| M.rust_cast (M.read (| ptr |)) |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      (* MutToConstPointer *)
                      M.pointer_coercion
                        (M.SubPointer.get_struct_record_field (|
                          M.read (| ptr |),
                          "alloc::sync::ArcInner",
                          "data"
                        |))
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_as_ptr :
      forall (T A : Ty.t),
      M.IsAssociatedFunction (Self T A) "as_ptr" (as_ptr T A).
    
    (*
        pub fn into_raw(self) -> *const T {
            let result = self.as_ptr();
            mem::forget(self);
            result
        }
    *)
    Definition into_raw (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            let result :=
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "alloc::sync::Weak") [ T; A ],
                    "as_ptr",
                    []
                  |),
                  [ self ]
                |)
              |) in
            let _ :=
              M.alloc (|
                M.call_closure (|
                  M.get_function (|
                    "core::mem::forget",
                    [ Ty.apply (Ty.path "alloc::sync::Weak") [ T; A ] ]
                  |),
                  [ M.read (| self |) ]
                |)
              |) in
            result
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_into_raw :
      forall (T A : Ty.t),
      M.IsAssociatedFunction (Self T A) "into_raw" (into_raw T A).
    
    (*
        pub unsafe fn from_raw_in(ptr: *const T, alloc: A) -> Self {
            // See Weak::as_ptr for context on how the input pointer is derived.
    
            let ptr = if is_dangling(ptr as *mut T) {
                // This is a dangling Weak.
                ptr as *mut ArcInner<T>
            } else {
                // Otherwise, we're guaranteed the pointer came from a nondangling Weak.
                // SAFETY: data_offset is safe to call, as ptr references a real (potentially dropped) T.
                let offset = unsafe { data_offset(ptr) };
                // Thus, we reverse the offset to get the whole RcBox.
                // SAFETY: the pointer originated from a Weak, so this offset is safe.
                unsafe { ptr.byte_sub(offset) as *mut ArcInner<T> }
            };
    
            // SAFETY: we now have recovered the original Weak pointer, so can create the Weak.
            Weak { ptr: unsafe { NonNull::new_unchecked(ptr) }, alloc }
        }
    *)
    Definition from_raw_in (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match τ, α with
      | [], [ ptr; alloc ] =>
        ltac:(M.monadic
          (let ptr := M.alloc (| ptr |) in
          let alloc := M.alloc (| alloc |) in
          M.read (|
            let ptr :=
              M.copy (|
                M.match_operator (|
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ :=
                          M.use
                            (M.alloc (|
                              M.call_closure (|
                                M.get_function (| "alloc::rc::is_dangling", [ T ] |),
                                [ M.rust_cast (M.read (| ptr |)) ]
                              |)
                            |)) in
                        let _ :=
                          M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        M.alloc (| M.rust_cast (M.read (| ptr |)) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let offset :=
                          M.alloc (|
                            M.call_closure (|
                              M.get_function (| "alloc::sync::data_offset", [ T ] |),
                              [ M.read (| ptr |) ]
                            |)
                          |) in
                        M.alloc (|
                          M.rust_cast
                            (M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply (Ty.path "*const") [ T ],
                                "byte_sub",
                                []
                              |),
                              [ M.read (| ptr |); M.read (| offset |) ]
                            |))
                        |)))
                  ]
                |)
              |) in
            M.alloc (|
              Value.StructRecord
                "alloc::sync::Weak"
                [
                  ("ptr",
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "core::ptr::non_null::NonNull")
                          [ Ty.apply (Ty.path "alloc::sync::ArcInner") [ T ] ],
                        "new_unchecked",
                        []
                      |),
                      [ M.read (| ptr |) ]
                    |));
                  ("alloc", M.read (| alloc |))
                ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_from_raw_in :
      forall (T A : Ty.t),
      M.IsAssociatedFunction (Self T A) "from_raw_in" (from_raw_in T A).
    (*
        pub fn upgrade(&self) -> Option<Arc<T, A>>
        where
            A: Clone,
        {
            #[inline]
            fn checked_increment(n: usize) -> Option<usize> {
                // Any write of 0 we can observe leaves the field in permanently zero state.
                if n == 0 {
                    return None;
                }
                // See comments in `Arc::clone` for why we do this (for `mem::forget`).
                assert!(n <= MAX_REFCOUNT, "{}", INTERNAL_OVERFLOW_ERROR);
                Some(n + 1)
            }
    
            // We use a CAS loop to increment the strong count instead of a
            // fetch_add as this function should never take the reference count
            // from zero to one.
            //
            // Relaxed is fine for the failure case because we don't have any expectations about the new state.
            // Acquire is necessary for the success case to synchronise with `Arc::new_cyclic`, when the inner
            // value can be initialized after `Weak` references have already been created. In that case, we
            // expect to observe the fully initialized value.
            if self.inner()?.strong.fetch_update(Acquire, Relaxed, checked_increment).is_ok() {
                // SAFETY: pointer is not null, verified in checked_increment
                unsafe { Some(Arc::from_inner_in(self.ptr, self.alloc.clone())) }
            } else {
                None
            }
        }
    *)
    Definition upgrade (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.catch_return (|
            ltac:(M.monadic
              (M.read (|
                M.match_operator (|
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ :=
                          M.use
                            (M.alloc (|
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "core::result::Result")
                                    [ Ty.path "usize"; Ty.path "usize" ],
                                  "is_ok",
                                  []
                                |),
                                [
                                  M.alloc (|
                                    M.call_closure (|
                                      M.get_associated_function (|
                                        Ty.path "core::sync::atomic::AtomicUsize",
                                        "fetch_update",
                                        [
                                          Ty.function
                                            [ Ty.path "usize" ]
                                            (Ty.apply
                                              (Ty.path "core::option::Option")
                                              [ Ty.path "usize" ])
                                        ]
                                      |),
                                      [
                                        M.read (|
                                          M.SubPointer.get_struct_record_field (|
                                            M.match_operator (|
                                              M.alloc (|
                                                M.call_closure (|
                                                  M.get_trait_method (|
                                                    "core::ops::try_trait::Try",
                                                    Ty.apply
                                                      (Ty.path "core::option::Option")
                                                      [ Ty.path "alloc::sync::WeakInner" ],
                                                    [],
                                                    "branch",
                                                    []
                                                  |),
                                                  [
                                                    M.call_closure (|
                                                      M.get_associated_function (|
                                                        Ty.apply
                                                          (Ty.path "alloc::sync::Weak")
                                                          [ T; A ],
                                                        "inner",
                                                        []
                                                      |),
                                                      [ M.read (| self |) ]
                                                    |)
                                                  ]
                                                |)
                                              |),
                                              [
                                                fun γ =>
                                                  ltac:(M.monadic
                                                    (let γ0_0 :=
                                                      M.SubPointer.get_struct_tuple_field (|
                                                        γ,
                                                        "core::ops::control_flow::ControlFlow::Break",
                                                        0
                                                      |) in
                                                    let residual := M.copy (| γ0_0 |) in
                                                    M.alloc (|
                                                      M.never_to_any (|
                                                        M.read (|
                                                          M.return_ (|
                                                            M.call_closure (|
                                                              M.get_trait_method (|
                                                                "core::ops::try_trait::FromResidual",
                                                                Ty.apply
                                                                  (Ty.path "core::option::Option")
                                                                  [
                                                                    Ty.apply
                                                                      (Ty.path "alloc::sync::Arc")
                                                                      [ T; A ]
                                                                  ],
                                                                [
                                                                  Ty.apply
                                                                    (Ty.path "core::option::Option")
                                                                    [
                                                                      Ty.path
                                                                        "core::convert::Infallible"
                                                                    ]
                                                                ],
                                                                "from_residual",
                                                                []
                                                              |),
                                                              [ M.read (| residual |) ]
                                                            |)
                                                          |)
                                                        |)
                                                      |)
                                                    |)));
                                                fun γ =>
                                                  ltac:(M.monadic
                                                    (let γ0_0 :=
                                                      M.SubPointer.get_struct_tuple_field (|
                                                        γ,
                                                        "core::ops::control_flow::ControlFlow::Continue",
                                                        0
                                                      |) in
                                                    let val := M.copy (| γ0_0 |) in
                                                    val))
                                              ]
                                            |),
                                            "alloc::sync::WeakInner",
                                            "strong"
                                          |)
                                        |);
                                        Value.StructTuple
                                          "core::sync::atomic::Ordering::Acquire"
                                          [];
                                        Value.StructTuple
                                          "core::sync::atomic::Ordering::Relaxed"
                                          [];
                                        M.get_associated_function (|
                                          Self,
                                          "checked_increment.upgrade",
                                          []
                                        |)
                                      ]
                                    |)
                                  |)
                                ]
                              |)
                            |)) in
                        let _ :=
                          M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        M.alloc (|
                          Value.StructTuple
                            "core::option::Option::Some"
                            [
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "alloc::sync::Arc") [ T; A ],
                                  "from_inner_in",
                                  []
                                |),
                                [
                                  M.read (|
                                    M.SubPointer.get_struct_record_field (|
                                      M.read (| self |),
                                      "alloc::sync::Weak",
                                      "ptr"
                                    |)
                                  |);
                                  M.call_closure (|
                                    M.get_trait_method (|
                                      "core::clone::Clone",
                                      A,
                                      [],
                                      "clone",
                                      []
                                    |),
                                    [
                                      M.SubPointer.get_struct_record_field (|
                                        M.read (| self |),
                                        "alloc::sync::Weak",
                                        "alloc"
                                      |)
                                    ]
                                  |)
                                ]
                              |)
                            ]
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
                  ]
                |)
              |)))
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_upgrade :
      forall (T A : Ty.t),
      M.IsAssociatedFunction (Self T A) "upgrade" (upgrade T A).
    
    (*
        pub fn strong_count(&self) -> usize {
            if let Some(inner) = self.inner() { inner.strong.load(Relaxed) } else { 0 }
        }
    *)
    Definition strong_count (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.apply (Ty.path "alloc::sync::Weak") [ T; A ],
                            "inner",
                            []
                          |),
                          [ M.read (| self |) ]
                        |)
                      |) in
                    let γ0_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "core::option::Option::Some",
                        0
                      |) in
                    let inner := M.copy (| γ0_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::sync::atomic::AtomicUsize",
                          "load",
                          []
                        |),
                        [
                          M.read (|
                            M.SubPointer.get_struct_record_field (|
                              inner,
                              "alloc::sync::WeakInner",
                              "strong"
                            |)
                          |);
                          Value.StructTuple "core::sync::atomic::Ordering::Relaxed" []
                        ]
                      |)
                    |)));
                fun γ => ltac:(M.monadic (M.alloc (| Value.Integer 0 |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_strong_count :
      forall (T A : Ty.t),
      M.IsAssociatedFunction (Self T A) "strong_count" (strong_count T A).
    
    (*
        pub fn weak_count(&self) -> usize {
            if let Some(inner) = self.inner() {
                let weak = inner.weak.load(Acquire);
                let strong = inner.strong.load(Relaxed);
                if strong == 0 {
                    0
                } else {
                    // Since we observed that there was at least one strong pointer
                    // after reading the weak count, we know that the implicit weak
                    // reference (present whenever any strong references are alive)
                    // was still around when we observed the weak count, and can
                    // therefore safely subtract it.
                    weak - 1
                }
            } else {
                0
            }
        }
    *)
    Definition weak_count (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.apply (Ty.path "alloc::sync::Weak") [ T; A ],
                            "inner",
                            []
                          |),
                          [ M.read (| self |) ]
                        |)
                      |) in
                    let γ0_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "core::option::Option::Some",
                        0
                      |) in
                    let inner := M.copy (| γ0_0 |) in
                    let weak :=
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.path "core::sync::atomic::AtomicUsize",
                            "load",
                            []
                          |),
                          [
                            M.read (|
                              M.SubPointer.get_struct_record_field (|
                                inner,
                                "alloc::sync::WeakInner",
                                "weak"
                              |)
                            |);
                            Value.StructTuple "core::sync::atomic::Ordering::Acquire" []
                          ]
                        |)
                      |) in
                    let strong :=
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.path "core::sync::atomic::AtomicUsize",
                            "load",
                            []
                          |),
                          [
                            M.read (|
                              M.SubPointer.get_struct_record_field (|
                                inner,
                                "alloc::sync::WeakInner",
                                "strong"
                              |)
                            |);
                            Value.StructTuple "core::sync::atomic::Ordering::Relaxed" []
                          ]
                        |)
                      |) in
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  BinOp.Pure.eq (M.read (| strong |)) (Value.Integer 0)
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (| Value.Integer 0 |)));
                        fun γ =>
                          ltac:(M.monadic
                            (M.alloc (|
                              BinOp.Panic.sub (|
                                Integer.Usize,
                                M.read (| weak |),
                                Value.Integer 1
                              |)
                            |)))
                      ]
                    |)));
                fun γ => ltac:(M.monadic (M.alloc (| Value.Integer 0 |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_weak_count :
      forall (T A : Ty.t),
      M.IsAssociatedFunction (Self T A) "weak_count" (weak_count T A).
    
    (*
        fn inner(&self) -> Option<WeakInner<'_>> {
            let ptr = self.ptr.as_ptr();
            if is_dangling(ptr) {
                None
            } else {
                // We are careful to *not* create a reference covering the "data" field, as
                // the field may be mutated concurrently (for example, if the last `Arc`
                // is dropped, the data field will be dropped in-place).
                Some(unsafe { WeakInner { strong: &( *ptr).strong, weak: &( *ptr).weak } })
            }
        }
    *)
    Definition inner (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            let ptr :=
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "core::ptr::non_null::NonNull")
                      [ Ty.apply (Ty.path "alloc::sync::ArcInner") [ T ] ],
                    "as_ptr",
                    []
                  |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "alloc::sync::Weak",
                        "ptr"
                      |)
                    |)
                  ]
                |)
              |) in
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          M.call_closure (|
                            M.get_function (|
                              "alloc::rc::is_dangling",
                              [ Ty.apply (Ty.path "alloc::sync::ArcInner") [ T ] ]
                            |),
                            [ M.read (| ptr |) ]
                          |)
                        |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      Value.StructTuple
                        "core::option::Option::Some"
                        [
                          Value.StructRecord
                            "alloc::sync::WeakInner"
                            [
                              ("strong",
                                M.SubPointer.get_struct_record_field (|
                                  M.read (| ptr |),
                                  "alloc::sync::ArcInner",
                                  "strong"
                                |));
                              ("weak",
                                M.SubPointer.get_struct_record_field (|
                                  M.read (| ptr |),
                                  "alloc::sync::ArcInner",
                                  "weak"
                                |))
                            ]
                        ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_inner :
      forall (T A : Ty.t),
      M.IsAssociatedFunction (Self T A) "inner" (inner T A).
    
    (*
        pub fn ptr_eq(&self, other: &Self) -> bool {
            ptr::addr_eq(self.ptr.as_ptr(), other.ptr.as_ptr())
        }
    *)
    Definition ptr_eq (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match τ, α with
      | [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            M.get_function (|
              "core::ptr::addr_eq",
              [
                Ty.apply (Ty.path "alloc::sync::ArcInner") [ T ];
                Ty.apply (Ty.path "alloc::sync::ArcInner") [ T ]
              ]
            |),
            [
              (* MutToConstPointer *)
              M.pointer_coercion
                (M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "core::ptr::non_null::NonNull")
                      [ Ty.apply (Ty.path "alloc::sync::ArcInner") [ T ] ],
                    "as_ptr",
                    []
                  |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "alloc::sync::Weak",
                        "ptr"
                      |)
                    |)
                  ]
                |));
              (* MutToConstPointer *)
              M.pointer_coercion
                (M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "core::ptr::non_null::NonNull")
                      [ Ty.apply (Ty.path "alloc::sync::ArcInner") [ T ] ],
                    "as_ptr",
                    []
                  |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_record_field (|
                        M.read (| other |),
                        "alloc::sync::Weak",
                        "ptr"
                      |)
                    |)
                  ]
                |))
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_ptr_eq :
      forall (T A : Ty.t),
      M.IsAssociatedFunction (Self T A) "ptr_eq" (ptr_eq T A).
  End Impl_alloc_sync_Weak_T_A.
  
  (* StructRecord
    {
      name := "WeakInner";
      ty_params := [];
      fields :=
        [
          ("weak", Ty.apply (Ty.path "&") [ Ty.path "core::sync::atomic::AtomicUsize" ]);
          ("strong", Ty.apply (Ty.path "&") [ Ty.path "core::sync::atomic::AtomicUsize" ])
        ];
    } *)
  
  
  
  
  Module Impl_core_clone_Clone_where_core_marker_Sized_T_where_core_alloc_Allocator_A_where_core_clone_Clone_A_for_alloc_sync_Weak_T_A.
    Definition Self (T A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::sync::Weak") [ T; A ].
    
    (*
        fn clone(&self) -> Weak<T, A> {
            let inner = if let Some(inner) = self.inner() {
                inner
            } else {
                return Weak { ptr: self.ptr, alloc: self.alloc.clone() };
            };
            // See comments in Arc::clone() for why this is relaxed. This can use a
            // fetch_add (ignoring the lock) because the weak count is only locked
            // where are *no other* weak pointers in existence. (So we can't be
            // running this code in that case).
            let old_size = inner.weak.fetch_add(1, Relaxed);
    
            // See comments in Arc::clone() for why we do this (for mem::forget).
            if old_size > MAX_REFCOUNT {
                abort();
            }
    
            Weak { ptr: self.ptr, alloc: self.alloc.clone() }
        }
    *)
    Definition clone (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.catch_return (|
            ltac:(M.monadic
              (M.read (|
                let inner :=
                  M.copy (|
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.alloc (|
                                M.call_closure (|
                                  M.get_associated_function (|
                                    Ty.apply (Ty.path "alloc::sync::Weak") [ T; A ],
                                    "inner",
                                    []
                                  |),
                                  [ M.read (| self |) ]
                                |)
                              |) in
                            let γ0_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "core::option::Option::Some",
                                0
                              |) in
                            let inner := M.copy (| γ0_0 |) in
                            inner));
                        fun γ =>
                          ltac:(M.monadic
                            (M.alloc (|
                              M.never_to_any (|
                                M.read (|
                                  M.return_ (|
                                    Value.StructRecord
                                      "alloc::sync::Weak"
                                      [
                                        ("ptr",
                                          M.read (|
                                            M.SubPointer.get_struct_record_field (|
                                              M.read (| self |),
                                              "alloc::sync::Weak",
                                              "ptr"
                                            |)
                                          |));
                                        ("alloc",
                                          M.call_closure (|
                                            M.get_trait_method (|
                                              "core::clone::Clone",
                                              A,
                                              [],
                                              "clone",
                                              []
                                            |),
                                            [
                                              M.SubPointer.get_struct_record_field (|
                                                M.read (| self |),
                                                "alloc::sync::Weak",
                                                "alloc"
                                              |)
                                            ]
                                          |))
                                      ]
                                  |)
                                |)
                              |)
                            |)))
                      ]
                    |)
                  |) in
                let old_size :=
                  M.alloc (|
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.path "core::sync::atomic::AtomicUsize",
                        "fetch_add",
                        []
                      |),
                      [
                        M.read (|
                          M.SubPointer.get_struct_record_field (|
                            inner,
                            "alloc::sync::WeakInner",
                            "weak"
                          |)
                        |);
                        Value.Integer 1;
                        Value.StructTuple "core::sync::atomic::Ordering::Relaxed" []
                      ]
                    |)
                  |) in
                let _ :=
                  M.match_operator (|
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                BinOp.Pure.gt
                                  (M.read (| old_size |))
                                  (M.read (| M.get_constant (| "alloc::sync::MAX_REFCOUNT" |) |))
                              |)) in
                          let _ :=
                            M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (|
                            M.never_to_any (|
                              M.call_closure (|
                                M.get_function (| "core::intrinsics::abort", [] |),
                                []
                              |)
                            |)
                          |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                M.alloc (|
                  Value.StructRecord
                    "alloc::sync::Weak"
                    [
                      ("ptr",
                        M.read (|
                          M.SubPointer.get_struct_record_field (|
                            M.read (| self |),
                            "alloc::sync::Weak",
                            "ptr"
                          |)
                        |));
                      ("alloc",
                        M.call_closure (|
                          M.get_trait_method (| "core::clone::Clone", A, [], "clone", [] |),
                          [
                            M.SubPointer.get_struct_record_field (|
                              M.read (| self |),
                              "alloc::sync::Weak",
                              "alloc"
                            |)
                          ]
                        |))
                    ]
                |)
              |)))
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (T A : Ty.t),
      M.IsTraitInstance
        "core::clone::Clone"
        (Self T A)
        (* Trait polymorphic types *) []
        (* Instance *) [ ("clone", InstanceField.Method (clone T A)) ].
  End Impl_core_clone_Clone_where_core_marker_Sized_T_where_core_alloc_Allocator_A_where_core_clone_Clone_A_for_alloc_sync_Weak_T_A.
  
  Module Impl_core_default_Default_for_alloc_sync_Weak_T_alloc_alloc_Global.
    Definition Self (T : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "alloc::sync::Weak") [ T; Ty.path "alloc::alloc::Global" ].
    
    (*
        fn default() -> Weak<T> {
            Weak::new()
        }
    *)
    Definition default (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match τ, α with
      | [], [] =>
        ltac:(M.monadic
          (M.call_closure (|
            M.get_associated_function (|
              Ty.apply (Ty.path "alloc::sync::Weak") [ T; Ty.path "alloc::alloc::Global" ],
              "new",
              []
            |),
            []
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "core::default::Default"
        (Self T)
        (* Trait polymorphic types *) []
        (* Instance *) [ ("default", InstanceField.Method (default T)) ].
  End Impl_core_default_Default_for_alloc_sync_Weak_T_alloc_alloc_Global.
  
  Module Impl_core_ops_drop_Drop_where_core_marker_Sized_T_where_core_alloc_Allocator_A_for_alloc_sync_Weak_T_A.
    Definition Self (T A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::sync::Weak") [ T; A ].
    
    (*
        fn drop(&mut self) {
            // If we find out that we were the last weak pointer, then its time to
            // deallocate the data entirely. See the discussion in Arc::drop() about
            // the memory orderings
            //
            // It's not necessary to check for the locked state here, because the
            // weak count can only be locked if there was precisely one weak ref,
            // meaning that drop could only subsequently run ON that remaining weak
            // ref, which can only happen after the lock is released.
            let inner = if let Some(inner) = self.inner() { inner } else { return };
    
            if inner.weak.fetch_sub(1, Release) == 1 {
                acquire!(inner.weak);
                unsafe {
                    self.alloc.deallocate(self.ptr.cast(), Layout::for_value_raw(self.ptr.as_ptr()))
                }
            }
        }
    *)
    Definition drop (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.catch_return (|
            ltac:(M.monadic
              (M.read (|
                let inner :=
                  M.copy (|
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.alloc (|
                                M.call_closure (|
                                  M.get_associated_function (|
                                    Ty.apply (Ty.path "alloc::sync::Weak") [ T; A ],
                                    "inner",
                                    []
                                  |),
                                  [ M.read (| self |) ]
                                |)
                              |) in
                            let γ0_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "core::option::Option::Some",
                                0
                              |) in
                            let inner := M.copy (| γ0_0 |) in
                            inner));
                        fun γ =>
                          ltac:(M.monadic
                            (M.alloc (|
                              M.never_to_any (| M.read (| M.return_ (| Value.Tuple [] |) |) |)
                            |)))
                      ]
                    |)
                  |) in
                M.match_operator (|
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ :=
                          M.use
                            (M.alloc (|
                              BinOp.Pure.eq
                                (M.call_closure (|
                                  M.get_associated_function (|
                                    Ty.path "core::sync::atomic::AtomicUsize",
                                    "fetch_sub",
                                    []
                                  |),
                                  [
                                    M.read (|
                                      M.SubPointer.get_struct_record_field (|
                                        inner,
                                        "alloc::sync::WeakInner",
                                        "weak"
                                      |)
                                    |);
                                    Value.Integer 1;
                                    Value.StructTuple "core::sync::atomic::Ordering::Release" []
                                  ]
                                |))
                                (Value.Integer 1)
                            |)) in
                        let _ :=
                          M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        let _ :=
                          M.alloc (|
                            M.call_closure (|
                              M.get_function (| "core::sync::atomic::fence", [] |),
                              [ Value.StructTuple "core::sync::atomic::Ordering::Acquire" [] ]
                            |)
                          |) in
                        M.alloc (|
                          M.call_closure (|
                            M.get_trait_method (|
                              "core::alloc::Allocator",
                              A,
                              [],
                              "deallocate",
                              []
                            |),
                            [
                              M.SubPointer.get_struct_record_field (|
                                M.read (| self |),
                                "alloc::sync::Weak",
                                "alloc"
                              |);
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "core::ptr::non_null::NonNull")
                                    [ Ty.apply (Ty.path "alloc::sync::ArcInner") [ T ] ],
                                  "cast",
                                  [ Ty.path "u8" ]
                                |),
                                [
                                  M.read (|
                                    M.SubPointer.get_struct_record_field (|
                                      M.read (| self |),
                                      "alloc::sync::Weak",
                                      "ptr"
                                    |)
                                  |)
                                ]
                              |);
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.path "core::alloc::layout::Layout",
                                  "for_value_raw",
                                  [ Ty.apply (Ty.path "alloc::sync::ArcInner") [ T ] ]
                                |),
                                [
                                  (* MutToConstPointer *)
                                  M.pointer_coercion
                                    (M.call_closure (|
                                      M.get_associated_function (|
                                        Ty.apply
                                          (Ty.path "core::ptr::non_null::NonNull")
                                          [ Ty.apply (Ty.path "alloc::sync::ArcInner") [ T ] ],
                                        "as_ptr",
                                        []
                                      |),
                                      [
                                        M.read (|
                                          M.SubPointer.get_struct_record_field (|
                                            M.read (| self |),
                                            "alloc::sync::Weak",
                                            "ptr"
                                          |)
                                        |)
                                      ]
                                    |))
                                ]
                              |)
                            ]
                          |)
                        |)));
                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                  ]
                |)
              |)))
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (T A : Ty.t),
      M.IsTraitInstance
        "core::ops::drop::Drop"
        (Self T A)
        (* Trait polymorphic types *) []
        (* Instance *) [ ("drop", InstanceField.Method (drop T A)) ].
  End Impl_core_ops_drop_Drop_where_core_marker_Sized_T_where_core_alloc_Allocator_A_for_alloc_sync_Weak_T_A.
  
  (* Trait *)
  (* Empty module 'ArcEqIdent' *)
  
  Module Impl_alloc_sync_ArcEqIdent_where_core_marker_Sized_T_where_core_cmp_PartialEq_T_where_core_alloc_Allocator_A_T_A_for_alloc_sync_Arc_T_A.
    Definition Self (T A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::sync::Arc") [ T; A ].
    
    (*
        default fn eq(&self, other: &Arc<T, A>) -> bool {
            **self == **other
        }
    *)
    Definition eq (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match τ, α with
      | [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            M.get_trait_method (| "core::cmp::PartialEq", T, [ T ], "eq", [] |),
            [
              M.call_closure (|
                M.get_trait_method (|
                  "core::ops::deref::Deref",
                  Ty.apply (Ty.path "alloc::sync::Arc") [ T; A ],
                  [],
                  "deref",
                  []
                |),
                [ M.read (| self |) ]
              |);
              M.call_closure (|
                M.get_trait_method (|
                  "core::ops::deref::Deref",
                  Ty.apply (Ty.path "alloc::sync::Arc") [ T; A ],
                  [],
                  "deref",
                  []
                |),
                [ M.read (| other |) ]
              |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    (*
        default fn ne(&self, other: &Arc<T, A>) -> bool {
            **self != **other
        }
    *)
    Definition ne (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match τ, α with
      | [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            M.get_trait_method (| "core::cmp::PartialEq", T, [ T ], "ne", [] |),
            [
              M.call_closure (|
                M.get_trait_method (|
                  "core::ops::deref::Deref",
                  Ty.apply (Ty.path "alloc::sync::Arc") [ T; A ],
                  [],
                  "deref",
                  []
                |),
                [ M.read (| self |) ]
              |);
              M.call_closure (|
                M.get_trait_method (|
                  "core::ops::deref::Deref",
                  Ty.apply (Ty.path "alloc::sync::Arc") [ T; A ],
                  [],
                  "deref",
                  []
                |),
                [ M.read (| other |) ]
              |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (T A : Ty.t),
      M.IsTraitInstance
        "alloc::sync::ArcEqIdent"
        (Self T A)
        (* Trait polymorphic types *) [ (* T *) T; (* A *) A ]
        (* Instance *)
        [ ("eq", InstanceField.Method (eq T A)); ("ne", InstanceField.Method (ne T A)) ].
  End Impl_alloc_sync_ArcEqIdent_where_core_marker_Sized_T_where_core_cmp_PartialEq_T_where_core_alloc_Allocator_A_T_A_for_alloc_sync_Arc_T_A.
  
  Module Impl_alloc_sync_ArcEqIdent_where_core_marker_Sized_T_where_alloc_rc_MarkerEq_T_where_core_alloc_Allocator_A_T_A_for_alloc_sync_Arc_T_A.
    Definition Self (T A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::sync::Arc") [ T; A ].
    
    (*
        fn eq(&self, other: &Arc<T, A>) -> bool {
            Arc::ptr_eq(self, other) || **self == **other
        }
    *)
    Definition eq (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match τ, α with
      | [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          LogicalOp.or (|
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply (Ty.path "alloc::sync::Arc") [ T; A ],
                "ptr_eq",
                []
              |),
              [ M.read (| self |); M.read (| other |) ]
            |),
            ltac:(M.monadic
              (M.call_closure (|
                M.get_trait_method (| "core::cmp::PartialEq", T, [ T ], "eq", [] |),
                [
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::deref::Deref",
                      Ty.apply (Ty.path "alloc::sync::Arc") [ T; A ],
                      [],
                      "deref",
                      []
                    |),
                    [ M.read (| self |) ]
                  |);
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::deref::Deref",
                      Ty.apply (Ty.path "alloc::sync::Arc") [ T; A ],
                      [],
                      "deref",
                      []
                    |),
                    [ M.read (| other |) ]
                  |)
                ]
              |)))
          |)))
      | _, _ => M.impossible
      end.
    
    (*
        fn ne(&self, other: &Arc<T, A>) -> bool {
            !Arc::ptr_eq(self, other) && **self != **other
        }
    *)
    Definition ne (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match τ, α with
      | [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          LogicalOp.and (|
            UnOp.Pure.not
              (M.call_closure (|
                M.get_associated_function (|
                  Ty.apply (Ty.path "alloc::sync::Arc") [ T; A ],
                  "ptr_eq",
                  []
                |),
                [ M.read (| self |); M.read (| other |) ]
              |)),
            ltac:(M.monadic
              (M.call_closure (|
                M.get_trait_method (| "core::cmp::PartialEq", T, [ T ], "ne", [] |),
                [
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::deref::Deref",
                      Ty.apply (Ty.path "alloc::sync::Arc") [ T; A ],
                      [],
                      "deref",
                      []
                    |),
                    [ M.read (| self |) ]
                  |);
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::deref::Deref",
                      Ty.apply (Ty.path "alloc::sync::Arc") [ T; A ],
                      [],
                      "deref",
                      []
                    |),
                    [ M.read (| other |) ]
                  |)
                ]
              |)))
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (T A : Ty.t),
      M.IsTraitInstance
        "alloc::sync::ArcEqIdent"
        (Self T A)
        (* Trait polymorphic types *) [ (* T *) T; (* A *) A ]
        (* Instance *)
        [ ("eq", InstanceField.Method (eq T A)); ("ne", InstanceField.Method (ne T A)) ].
  End Impl_alloc_sync_ArcEqIdent_where_core_marker_Sized_T_where_alloc_rc_MarkerEq_T_where_core_alloc_Allocator_A_T_A_for_alloc_sync_Arc_T_A.
  
  Module Impl_core_cmp_PartialEq_where_core_marker_Sized_T_where_core_cmp_PartialEq_T_where_core_alloc_Allocator_A_for_alloc_sync_Arc_T_A.
    Definition Self (T A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::sync::Arc") [ T; A ].
    
    (*
        fn eq(&self, other: &Arc<T, A>) -> bool {
            ArcEqIdent::eq(self, other)
        }
    *)
    Definition eq (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match τ, α with
      | [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            M.get_trait_method (|
              "alloc::sync::ArcEqIdent",
              Ty.apply (Ty.path "alloc::sync::Arc") [ T; A ],
              [ T; A ],
              "eq",
              []
            |),
            [ M.read (| self |); M.read (| other |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    (*
        fn ne(&self, other: &Arc<T, A>) -> bool {
            ArcEqIdent::ne(self, other)
        }
    *)
    Definition ne (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match τ, α with
      | [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            M.get_trait_method (|
              "alloc::sync::ArcEqIdent",
              Ty.apply (Ty.path "alloc::sync::Arc") [ T; A ],
              [ T; A ],
              "ne",
              []
            |),
            [ M.read (| self |); M.read (| other |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (T A : Ty.t),
      M.IsTraitInstance
        "core::cmp::PartialEq"
        (Self T A)
        (* Trait polymorphic types *) []
        (* Instance *)
        [ ("eq", InstanceField.Method (eq T A)); ("ne", InstanceField.Method (ne T A)) ].
  End Impl_core_cmp_PartialEq_where_core_marker_Sized_T_where_core_cmp_PartialEq_T_where_core_alloc_Allocator_A_for_alloc_sync_Arc_T_A.
  
  Module Impl_core_cmp_PartialOrd_where_core_marker_Sized_T_where_core_cmp_PartialOrd_T_where_core_alloc_Allocator_A_for_alloc_sync_Arc_T_A.
    Definition Self (T A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::sync::Arc") [ T; A ].
    
    (*
        fn partial_cmp(&self, other: &Arc<T, A>) -> Option<Ordering> {
            ( **self).partial_cmp(&**other)
        }
    *)
    Definition partial_cmp (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match τ, α with
      | [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            M.get_trait_method (| "core::cmp::PartialOrd", T, [ T ], "partial_cmp", [] |),
            [
              M.call_closure (|
                M.get_trait_method (|
                  "core::ops::deref::Deref",
                  Ty.apply (Ty.path "alloc::sync::Arc") [ T; A ],
                  [],
                  "deref",
                  []
                |),
                [ M.read (| self |) ]
              |);
              M.call_closure (|
                M.get_trait_method (|
                  "core::ops::deref::Deref",
                  Ty.apply (Ty.path "alloc::sync::Arc") [ T; A ],
                  [],
                  "deref",
                  []
                |),
                [ M.read (| other |) ]
              |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    (*
        fn lt(&self, other: &Arc<T, A>) -> bool {
            *( *self) < *( *other)
        }
    *)
    Definition lt (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match τ, α with
      | [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            M.get_trait_method (| "core::cmp::PartialOrd", T, [ T ], "lt", [] |),
            [
              M.call_closure (|
                M.get_trait_method (|
                  "core::ops::deref::Deref",
                  Ty.apply (Ty.path "alloc::sync::Arc") [ T; A ],
                  [],
                  "deref",
                  []
                |),
                [ M.read (| self |) ]
              |);
              M.call_closure (|
                M.get_trait_method (|
                  "core::ops::deref::Deref",
                  Ty.apply (Ty.path "alloc::sync::Arc") [ T; A ],
                  [],
                  "deref",
                  []
                |),
                [ M.read (| other |) ]
              |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    (*
        fn le(&self, other: &Arc<T, A>) -> bool {
            *( *self) <= *( *other)
        }
    *)
    Definition le (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match τ, α with
      | [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            M.get_trait_method (| "core::cmp::PartialOrd", T, [ T ], "le", [] |),
            [
              M.call_closure (|
                M.get_trait_method (|
                  "core::ops::deref::Deref",
                  Ty.apply (Ty.path "alloc::sync::Arc") [ T; A ],
                  [],
                  "deref",
                  []
                |),
                [ M.read (| self |) ]
              |);
              M.call_closure (|
                M.get_trait_method (|
                  "core::ops::deref::Deref",
                  Ty.apply (Ty.path "alloc::sync::Arc") [ T; A ],
                  [],
                  "deref",
                  []
                |),
                [ M.read (| other |) ]
              |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    (*
        fn gt(&self, other: &Arc<T, A>) -> bool {
            *( *self) > *( *other)
        }
    *)
    Definition gt (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match τ, α with
      | [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            M.get_trait_method (| "core::cmp::PartialOrd", T, [ T ], "gt", [] |),
            [
              M.call_closure (|
                M.get_trait_method (|
                  "core::ops::deref::Deref",
                  Ty.apply (Ty.path "alloc::sync::Arc") [ T; A ],
                  [],
                  "deref",
                  []
                |),
                [ M.read (| self |) ]
              |);
              M.call_closure (|
                M.get_trait_method (|
                  "core::ops::deref::Deref",
                  Ty.apply (Ty.path "alloc::sync::Arc") [ T; A ],
                  [],
                  "deref",
                  []
                |),
                [ M.read (| other |) ]
              |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    (*
        fn ge(&self, other: &Arc<T, A>) -> bool {
            *( *self) >= *( *other)
        }
    *)
    Definition ge (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match τ, α with
      | [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            M.get_trait_method (| "core::cmp::PartialOrd", T, [ T ], "ge", [] |),
            [
              M.call_closure (|
                M.get_trait_method (|
                  "core::ops::deref::Deref",
                  Ty.apply (Ty.path "alloc::sync::Arc") [ T; A ],
                  [],
                  "deref",
                  []
                |),
                [ M.read (| self |) ]
              |);
              M.call_closure (|
                M.get_trait_method (|
                  "core::ops::deref::Deref",
                  Ty.apply (Ty.path "alloc::sync::Arc") [ T; A ],
                  [],
                  "deref",
                  []
                |),
                [ M.read (| other |) ]
              |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (T A : Ty.t),
      M.IsTraitInstance
        "core::cmp::PartialOrd"
        (Self T A)
        (* Trait polymorphic types *) []
        (* Instance *)
        [
          ("partial_cmp", InstanceField.Method (partial_cmp T A));
          ("lt", InstanceField.Method (lt T A));
          ("le", InstanceField.Method (le T A));
          ("gt", InstanceField.Method (gt T A));
          ("ge", InstanceField.Method (ge T A))
        ].
  End Impl_core_cmp_PartialOrd_where_core_marker_Sized_T_where_core_cmp_PartialOrd_T_where_core_alloc_Allocator_A_for_alloc_sync_Arc_T_A.
  
  Module Impl_core_cmp_Ord_where_core_marker_Sized_T_where_core_cmp_Ord_T_where_core_alloc_Allocator_A_for_alloc_sync_Arc_T_A.
    Definition Self (T A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::sync::Arc") [ T; A ].
    
    (*
        fn cmp(&self, other: &Arc<T, A>) -> Ordering {
            ( **self).cmp(&**other)
        }
    *)
    Definition cmp (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match τ, α with
      | [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            M.get_trait_method (| "core::cmp::Ord", T, [], "cmp", [] |),
            [
              M.call_closure (|
                M.get_trait_method (|
                  "core::ops::deref::Deref",
                  Ty.apply (Ty.path "alloc::sync::Arc") [ T; A ],
                  [],
                  "deref",
                  []
                |),
                [ M.read (| self |) ]
              |);
              M.call_closure (|
                M.get_trait_method (|
                  "core::ops::deref::Deref",
                  Ty.apply (Ty.path "alloc::sync::Arc") [ T; A ],
                  [],
                  "deref",
                  []
                |),
                [ M.read (| other |) ]
              |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (T A : Ty.t),
      M.IsTraitInstance
        "core::cmp::Ord"
        (Self T A)
        (* Trait polymorphic types *) []
        (* Instance *) [ ("cmp", InstanceField.Method (cmp T A)) ].
  End Impl_core_cmp_Ord_where_core_marker_Sized_T_where_core_cmp_Ord_T_where_core_alloc_Allocator_A_for_alloc_sync_Arc_T_A.
  
  Module Impl_core_cmp_Eq_where_core_marker_Sized_T_where_core_cmp_Eq_T_where_core_alloc_Allocator_A_for_alloc_sync_Arc_T_A.
    Definition Self (T A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::sync::Arc") [ T; A ].
    
    Axiom Implements :
      forall (T A : Ty.t),
      M.IsTraitInstance
        "core::cmp::Eq"
        (Self T A)
        (* Trait polymorphic types *) []
        (* Instance *) [].
  End Impl_core_cmp_Eq_where_core_marker_Sized_T_where_core_cmp_Eq_T_where_core_alloc_Allocator_A_for_alloc_sync_Arc_T_A.
  
  Module Impl_core_fmt_Display_where_core_marker_Sized_T_where_core_fmt_Display_T_where_core_alloc_Allocator_A_for_alloc_sync_Arc_T_A.
    Definition Self (T A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::sync::Arc") [ T; A ].
    
    (*
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            fmt::Display::fmt(&**self, f)
        }
    *)
    Definition fmt (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match τ, α with
      | [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.call_closure (|
            M.get_trait_method (| "core::fmt::Display", T, [], "fmt", [] |),
            [
              M.call_closure (|
                M.get_trait_method (|
                  "core::ops::deref::Deref",
                  Ty.apply (Ty.path "alloc::sync::Arc") [ T; A ],
                  [],
                  "deref",
                  []
                |),
                [ M.read (| self |) ]
              |);
              M.read (| f |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (T A : Ty.t),
      M.IsTraitInstance
        "core::fmt::Display"
        (Self T A)
        (* Trait polymorphic types *) []
        (* Instance *) [ ("fmt", InstanceField.Method (fmt T A)) ].
  End Impl_core_fmt_Display_where_core_marker_Sized_T_where_core_fmt_Display_T_where_core_alloc_Allocator_A_for_alloc_sync_Arc_T_A.
  
  Module Impl_core_fmt_Debug_where_core_marker_Sized_T_where_core_fmt_Debug_T_where_core_alloc_Allocator_A_for_alloc_sync_Arc_T_A.
    Definition Self (T A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::sync::Arc") [ T; A ].
    
    (*
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            fmt::Debug::fmt(&**self, f)
        }
    *)
    Definition fmt (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match τ, α with
      | [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.call_closure (|
            M.get_trait_method (| "core::fmt::Debug", T, [], "fmt", [] |),
            [
              M.call_closure (|
                M.get_trait_method (|
                  "core::ops::deref::Deref",
                  Ty.apply (Ty.path "alloc::sync::Arc") [ T; A ],
                  [],
                  "deref",
                  []
                |),
                [ M.read (| self |) ]
              |);
              M.read (| f |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (T A : Ty.t),
      M.IsTraitInstance
        "core::fmt::Debug"
        (Self T A)
        (* Trait polymorphic types *) []
        (* Instance *) [ ("fmt", InstanceField.Method (fmt T A)) ].
  End Impl_core_fmt_Debug_where_core_marker_Sized_T_where_core_fmt_Debug_T_where_core_alloc_Allocator_A_for_alloc_sync_Arc_T_A.
  
  Module Impl_core_fmt_Pointer_where_core_marker_Sized_T_where_core_alloc_Allocator_A_for_alloc_sync_Arc_T_A.
    Definition Self (T A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::sync::Arc") [ T; A ].
    
    (*
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            fmt::Pointer::fmt(&(&**self as *const T), f)
        }
    *)
    Definition fmt (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match τ, α with
      | [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.call_closure (|
            M.get_trait_method (|
              "core::fmt::Pointer",
              Ty.apply (Ty.path "*const") [ T ],
              [],
              "fmt",
              []
            |),
            [
              M.use
                (M.alloc (|
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::deref::Deref",
                      Ty.apply (Ty.path "alloc::sync::Arc") [ T; A ],
                      [],
                      "deref",
                      []
                    |),
                    [ M.read (| self |) ]
                  |)
                |));
              M.read (| f |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (T A : Ty.t),
      M.IsTraitInstance
        "core::fmt::Pointer"
        (Self T A)
        (* Trait polymorphic types *) []
        (* Instance *) [ ("fmt", InstanceField.Method (fmt T A)) ].
  End Impl_core_fmt_Pointer_where_core_marker_Sized_T_where_core_alloc_Allocator_A_for_alloc_sync_Arc_T_A.
  
  Module Impl_core_default_Default_where_core_default_Default_T_for_alloc_sync_Arc_T_alloc_alloc_Global.
    Definition Self (T : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "alloc::sync::Arc") [ T; Ty.path "alloc::alloc::Global" ].
    
    (*
        fn default() -> Arc<T> {
            Arc::new(Default::default())
        }
    *)
    Definition default (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match τ, α with
      | [], [] =>
        ltac:(M.monadic
          (M.call_closure (|
            M.get_associated_function (|
              Ty.apply (Ty.path "alloc::sync::Arc") [ T; Ty.path "alloc::alloc::Global" ],
              "new",
              []
            |),
            [
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "core::default::Default"
        (Self T)
        (* Trait polymorphic types *) []
        (* Instance *) [ ("default", InstanceField.Method (default T)) ].
  End Impl_core_default_Default_where_core_default_Default_T_for_alloc_sync_Arc_T_alloc_alloc_Global.
  
  Module Impl_core_hash_Hash_where_core_marker_Sized_T_where_core_hash_Hash_T_where_core_alloc_Allocator_A_for_alloc_sync_Arc_T_A.
    Definition Self (T A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::sync::Arc") [ T; A ].
    
    (*
        fn hash<H: Hasher>(&self, state: &mut H) {
            ( **self).hash(state)
        }
    *)
    Definition hash (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match τ, α with
      | [ H ], [ self; state ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let state := M.alloc (| state |) in
          M.call_closure (|
            M.get_trait_method (| "core::hash::Hash", T, [], "hash", [ H ] |),
            [
              M.call_closure (|
                M.get_trait_method (|
                  "core::ops::deref::Deref",
                  Ty.apply (Ty.path "alloc::sync::Arc") [ T; A ],
                  [],
                  "deref",
                  []
                |),
                [ M.read (| self |) ]
              |);
              M.read (| state |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (T A : Ty.t),
      M.IsTraitInstance
        "core::hash::Hash"
        (Self T A)
        (* Trait polymorphic types *) []
        (* Instance *) [ ("hash", InstanceField.Method (hash T A)) ].
  End Impl_core_hash_Hash_where_core_marker_Sized_T_where_core_hash_Hash_T_where_core_alloc_Allocator_A_for_alloc_sync_Arc_T_A.
  
  Module Impl_core_convert_From_T_for_alloc_sync_Arc_T_alloc_alloc_Global.
    Definition Self (T : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "alloc::sync::Arc") [ T; Ty.path "alloc::alloc::Global" ].
    
    (*
        fn from(t: T) -> Self {
            Arc::new(t)
        }
    *)
    Definition from (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match τ, α with
      | [], [ t ] =>
        ltac:(M.monadic
          (let t := M.alloc (| t |) in
          M.call_closure (|
            M.get_associated_function (|
              Ty.apply (Ty.path "alloc::sync::Arc") [ T; Ty.path "alloc::alloc::Global" ],
              "new",
              []
            |),
            [ M.read (| t |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "core::convert::From"
        (Self T)
        (* Trait polymorphic types *) [ (* T *) T ]
        (* Instance *) [ ("from", InstanceField.Method (from T)) ].
  End Impl_core_convert_From_T_for_alloc_sync_Arc_T_alloc_alloc_Global.
  
  Module Impl_core_convert_From_array_T_for_alloc_sync_Arc_slice_T_alloc_alloc_Global.
    Definition Self (T : Ty.t) : Ty.t :=
      Ty.apply
        (Ty.path "alloc::sync::Arc")
        [ Ty.apply (Ty.path "slice") [ T ]; Ty.path "alloc::alloc::Global" ].
    
    (*
        fn from(v: [T; N]) -> Arc<[T]> {
            Arc::<[T; N]>::from(v)
        }
    *)
    Definition from (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match τ, α with
      | [], [ v ] =>
        ltac:(M.monadic
          (let v := M.alloc (| v |) in
          (* Unsize *)
          M.pointer_coercion
            (M.call_closure (|
              M.get_trait_method (|
                "core::convert::From",
                Ty.apply
                  (Ty.path "alloc::sync::Arc")
                  [ Ty.apply (Ty.path "array") [ T ]; Ty.path "alloc::alloc::Global" ],
                [ Ty.apply (Ty.path "array") [ T ] ],
                "from",
                []
              |),
              [ M.read (| v |) ]
            |))))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "core::convert::From"
        (Self T)
        (* Trait polymorphic types *) [ (* T *) Ty.apply (Ty.path "array") [ T ] ]
        (* Instance *) [ ("from", InstanceField.Method (from T)) ].
  End Impl_core_convert_From_array_T_for_alloc_sync_Arc_slice_T_alloc_alloc_Global.
  
  Module Impl_core_convert_From_where_core_clone_Clone_T_ref__slice_T_for_alloc_sync_Arc_slice_T_alloc_alloc_Global.
    Definition Self (T : Ty.t) : Ty.t :=
      Ty.apply
        (Ty.path "alloc::sync::Arc")
        [ Ty.apply (Ty.path "slice") [ T ]; Ty.path "alloc::alloc::Global" ].
    
    (*
        fn from(v: &[T]) -> Arc<[T]> {
            <Self as ArcFromSlice<T>>::from_slice(v)
        }
    *)
    Definition from (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match τ, α with
      | [], [ v ] =>
        ltac:(M.monadic
          (let v := M.alloc (| v |) in
          M.call_closure (|
            M.get_trait_method (|
              "alloc::sync::ArcFromSlice",
              Ty.apply
                (Ty.path "alloc::sync::Arc")
                [ Ty.apply (Ty.path "slice") [ T ]; Ty.path "alloc::alloc::Global" ],
              [ T ],
              "from_slice",
              []
            |),
            [ M.read (| v |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "core::convert::From"
        (Self T)
        (* Trait polymorphic types *)
        [ (* T *) Ty.apply (Ty.path "&") [ Ty.apply (Ty.path "slice") [ T ] ] ]
        (* Instance *) [ ("from", InstanceField.Method (from T)) ].
  End Impl_core_convert_From_where_core_clone_Clone_T_ref__slice_T_for_alloc_sync_Arc_slice_T_alloc_alloc_Global.
  
  Module Impl_core_convert_From_ref__str_for_alloc_sync_Arc_str_alloc_alloc_Global.
    Definition Self : Ty.t :=
      Ty.apply (Ty.path "alloc::sync::Arc") [ Ty.path "str"; Ty.path "alloc::alloc::Global" ].
    
    (*
        fn from(v: &str) -> Arc<str> {
            let arc = Arc::<[u8]>::from(v.as_bytes());
            unsafe { Arc::from_raw(Arc::into_raw(arc) as *const str) }
        }
    *)
    Definition from (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ v ] =>
        ltac:(M.monadic
          (let v := M.alloc (| v |) in
          M.read (|
            let arc :=
              M.alloc (|
                M.call_closure (|
                  M.get_trait_method (|
                    "core::convert::From",
                    Ty.apply
                      (Ty.path "alloc::sync::Arc")
                      [ Ty.apply (Ty.path "slice") [ Ty.path "u8" ]; Ty.path "alloc::alloc::Global"
                      ],
                    [ Ty.apply (Ty.path "&") [ Ty.apply (Ty.path "slice") [ Ty.path "u8" ] ] ],
                    "from",
                    []
                  |),
                  [
                    M.call_closure (|
                      M.get_associated_function (| Ty.path "str", "as_bytes", [] |),
                      [ M.read (| v |) ]
                    |)
                  ]
                |)
              |) in
            M.alloc (|
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "alloc::sync::Arc")
                    [ Ty.path "str"; Ty.path "alloc::alloc::Global" ],
                  "from_raw",
                  []
                |),
                [
                  M.rust_cast
                    (M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "alloc::sync::Arc")
                          [
                            Ty.apply (Ty.path "slice") [ Ty.path "u8" ];
                            Ty.path "alloc::alloc::Global"
                          ],
                        "into_raw",
                        []
                      |),
                      [ M.read (| arc |) ]
                    |))
                ]
              |)
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::convert::From"
        Self
        (* Trait polymorphic types *) [ (* T *) Ty.apply (Ty.path "&") [ Ty.path "str" ] ]
        (* Instance *) [ ("from", InstanceField.Method from) ].
  End Impl_core_convert_From_ref__str_for_alloc_sync_Arc_str_alloc_alloc_Global.
  
  Module Impl_core_convert_From_alloc_string_String_for_alloc_sync_Arc_str_alloc_alloc_Global.
    Definition Self : Ty.t :=
      Ty.apply (Ty.path "alloc::sync::Arc") [ Ty.path "str"; Ty.path "alloc::alloc::Global" ].
    
    (*
        fn from(v: String) -> Arc<str> {
            Arc::from(&v[..])
        }
    *)
    Definition from (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ v ] =>
        ltac:(M.monadic
          (let v := M.alloc (| v |) in
          M.call_closure (|
            M.get_trait_method (|
              "core::convert::From",
              Ty.apply
                (Ty.path "alloc::sync::Arc")
                [ Ty.path "str"; Ty.path "alloc::alloc::Global" ],
              [ Ty.apply (Ty.path "&") [ Ty.path "str" ] ],
              "from",
              []
            |),
            [
              M.call_closure (|
                M.get_trait_method (|
                  "core::ops::index::Index",
                  Ty.path "alloc::string::String",
                  [ Ty.path "core::ops::range::RangeFull" ],
                  "index",
                  []
                |),
                [ v; Value.StructTuple "core::ops::range::RangeFull" [] ]
              |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::convert::From"
        Self
        (* Trait polymorphic types *) [ (* T *) Ty.path "alloc::string::String" ]
        (* Instance *) [ ("from", InstanceField.Method from) ].
  End Impl_core_convert_From_alloc_string_String_for_alloc_sync_Arc_str_alloc_alloc_Global.
  
  Module Impl_core_convert_From_where_core_marker_Sized_T_where_core_alloc_Allocator_A_alloc_boxed_Box_T_A_for_alloc_sync_Arc_T_A.
    Definition Self (T A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::sync::Arc") [ T; A ].
    
    (*
        fn from(v: Box<T, A>) -> Arc<T, A> {
            Arc::from_box_in(v)
        }
    *)
    Definition from (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match τ, α with
      | [], [ v ] =>
        ltac:(M.monadic
          (let v := M.alloc (| v |) in
          M.call_closure (|
            M.get_associated_function (|
              Ty.apply (Ty.path "alloc::sync::Arc") [ T; A ],
              "from_box_in",
              []
            |),
            [ M.read (| v |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (T A : Ty.t),
      M.IsTraitInstance
        "core::convert::From"
        (Self T A)
        (* Trait polymorphic types *) [ (* T *) Ty.apply (Ty.path "alloc::boxed::Box") [ T; A ] ]
        (* Instance *) [ ("from", InstanceField.Method (from T A)) ].
  End Impl_core_convert_From_where_core_marker_Sized_T_where_core_alloc_Allocator_A_alloc_boxed_Box_T_A_for_alloc_sync_Arc_T_A.
  
  Module Impl_core_convert_From_where_core_alloc_Allocator_A_where_core_clone_Clone_A_alloc_vec_Vec_T_A_for_alloc_sync_Arc_slice_T_A.
    Definition Self (T A : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "alloc::sync::Arc") [ Ty.apply (Ty.path "slice") [ T ]; A ].
    
    (*
        fn from(v: Vec<T, A>) -> Arc<[T], A> {
            unsafe {
                let (vec_ptr, len, cap, alloc) = v.into_raw_parts_with_alloc();
    
                let rc_ptr = Self::allocate_for_slice_in(len, &alloc);
                ptr::copy_nonoverlapping(vec_ptr, &mut ( *rc_ptr).data as *mut [T] as *mut T, len);
    
                // Create a `Vec<T, &A>` with length 0, to deallocate the buffer
                // without dropping its contents or the allocator
                let _ = Vec::from_raw_parts_in(vec_ptr, 0, cap, &alloc);
    
                Self::from_ptr_in(rc_ptr, alloc)
            }
        }
    *)
    Definition from (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match τ, α with
      | [], [ v ] =>
        ltac:(M.monadic
          (let v := M.alloc (| v |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "alloc::vec::Vec") [ T; A ],
                    "into_raw_parts_with_alloc",
                    []
                  |),
                  [ M.read (| v |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let γ0_2 := M.SubPointer.get_tuple_field (| γ, 2 |) in
                    let γ0_3 := M.SubPointer.get_tuple_field (| γ, 3 |) in
                    let vec_ptr := M.copy (| γ0_0 |) in
                    let len := M.copy (| γ0_1 |) in
                    let cap := M.copy (| γ0_2 |) in
                    let alloc := M.copy (| γ0_3 |) in
                    let rc_ptr :=
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.apply
                              (Ty.path "alloc::sync::Arc")
                              [ Ty.apply (Ty.path "slice") [ T ]; A ],
                            "allocate_for_slice_in",
                            []
                          |),
                          [ M.read (| len |); alloc ]
                        |)
                      |) in
                    let _ :=
                      M.alloc (|
                        M.call_closure (|
                          M.get_function (| "core::intrinsics::copy_nonoverlapping", [ T ] |),
                          [
                            (* MutToConstPointer *) M.pointer_coercion (M.read (| vec_ptr |));
                            M.rust_cast
                              (M.read (|
                                M.use
                                  (M.alloc (|
                                    M.SubPointer.get_struct_record_field (|
                                      M.read (| rc_ptr |),
                                      "alloc::sync::ArcInner",
                                      "data"
                                    |)
                                  |))
                              |));
                            M.read (| len |)
                          ]
                        |)
                      |) in
                    M.match_operator (|
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.apply
                              (Ty.path "alloc::vec::Vec")
                              [ T; Ty.apply (Ty.path "&") [ A ] ],
                            "from_raw_parts_in",
                            []
                          |),
                          [ M.read (| vec_ptr |); Value.Integer 0; M.read (| cap |); alloc ]
                        |)
                      |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (M.alloc (|
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "alloc::sync::Arc")
                                    [ Ty.apply (Ty.path "slice") [ T ]; A ],
                                  "from_ptr_in",
                                  []
                                |),
                                [ M.read (| rc_ptr |); M.read (| alloc |) ]
                              |)
                            |)))
                      ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (T A : Ty.t),
      M.IsTraitInstance
        "core::convert::From"
        (Self T A)
        (* Trait polymorphic types *) [ (* T *) Ty.apply (Ty.path "alloc::vec::Vec") [ T; A ] ]
        (* Instance *) [ ("from", InstanceField.Method (from T A)) ].
  End Impl_core_convert_From_where_core_alloc_Allocator_A_where_core_clone_Clone_A_alloc_vec_Vec_T_A_for_alloc_sync_Arc_slice_T_A.
  
  Module Impl_core_convert_From_where_alloc_borrow_ToOwned_B_where_core_marker_Sized_B_where_core_convert_From_alloc_sync_Arc_B_alloc_alloc_Global_ref__B_where_core_convert_From_alloc_sync_Arc_B_alloc_alloc_Global_associated_type_alloc_borrow_Cow_B_for_alloc_sync_Arc_B_alloc_alloc_Global.
    Definition Self (B : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "alloc::sync::Arc") [ B; Ty.path "alloc::alloc::Global" ].
    
    (*
        fn from(cow: Cow<'a, B>) -> Arc<B> {
            match cow {
                Cow::Borrowed(s) => Arc::from(s),
                Cow::Owned(s) => Arc::from(s),
            }
        }
    *)
    Definition from (B : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self B in
      match τ, α with
      | [], [ cow ] =>
        ltac:(M.monadic
          (let cow := M.alloc (| cow |) in
          M.read (|
            M.match_operator (|
              cow,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "alloc::borrow::Cow::Borrowed",
                        0
                      |) in
                    let s := M.copy (| γ0_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_trait_method (|
                          "core::convert::From",
                          Ty.apply
                            (Ty.path "alloc::sync::Arc")
                            [ B; Ty.path "alloc::alloc::Global" ],
                          [ Ty.apply (Ty.path "&") [ B ] ],
                          "from",
                          []
                        |),
                        [ M.read (| s |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 :=
                      M.SubPointer.get_struct_tuple_field (| γ, "alloc::borrow::Cow::Owned", 0 |) in
                    let s := M.copy (| γ0_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_trait_method (|
                          "core::convert::From",
                          Ty.apply
                            (Ty.path "alloc::sync::Arc")
                            [ B; Ty.path "alloc::alloc::Global" ],
                          [ Ty.associated ],
                          "from",
                          []
                        |),
                        [ M.read (| s |) ]
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (B : Ty.t),
      M.IsTraitInstance
        "core::convert::From"
        (Self B)
        (* Trait polymorphic types *) [ (* T *) Ty.apply (Ty.path "alloc::borrow::Cow") [ B ] ]
        (* Instance *) [ ("from", InstanceField.Method (from B)) ].
  End Impl_core_convert_From_where_alloc_borrow_ToOwned_B_where_core_marker_Sized_B_where_core_convert_From_alloc_sync_Arc_B_alloc_alloc_Global_ref__B_where_core_convert_From_alloc_sync_Arc_B_alloc_alloc_Global_associated_type_alloc_borrow_Cow_B_for_alloc_sync_Arc_B_alloc_alloc_Global.
  
  Module Impl_core_convert_From_alloc_sync_Arc_str_alloc_alloc_Global_for_alloc_sync_Arc_slice_u8_alloc_alloc_Global.
    Definition Self : Ty.t :=
      Ty.apply
        (Ty.path "alloc::sync::Arc")
        [ Ty.apply (Ty.path "slice") [ Ty.path "u8" ]; Ty.path "alloc::alloc::Global" ].
    
    (*
        fn from(rc: Arc<str>) -> Self {
            // SAFETY: `str` has the same layout as `[u8]`.
            unsafe { Arc::from_raw(Arc::into_raw(rc) as *const [u8]) }
        }
    *)
    Definition from (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ rc ] =>
        ltac:(M.monadic
          (let rc := M.alloc (| rc |) in
          M.call_closure (|
            M.get_associated_function (|
              Ty.apply
                (Ty.path "alloc::sync::Arc")
                [ Ty.apply (Ty.path "slice") [ Ty.path "u8" ]; Ty.path "alloc::alloc::Global" ],
              "from_raw",
              []
            |),
            [
              M.rust_cast
                (M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "alloc::sync::Arc")
                      [ Ty.path "str"; Ty.path "alloc::alloc::Global" ],
                    "into_raw",
                    []
                  |),
                  [ M.read (| rc |) ]
                |))
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::convert::From"
        Self
        (* Trait polymorphic types *)
        [
          (* T *)
          Ty.apply (Ty.path "alloc::sync::Arc") [ Ty.path "str"; Ty.path "alloc::alloc::Global" ]
        ]
        (* Instance *) [ ("from", InstanceField.Method from) ].
  End Impl_core_convert_From_alloc_sync_Arc_str_alloc_alloc_Global_for_alloc_sync_Arc_slice_u8_alloc_alloc_Global.
  
  Module Impl_core_convert_TryFrom_where_core_alloc_Allocator_A_where_core_clone_Clone_A_alloc_sync_Arc_slice_T_A_for_alloc_sync_Arc_array_T_A.
    Definition Self (T A : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "alloc::sync::Arc") [ Ty.apply (Ty.path "array") [ T ]; A ].
    
    (*     type Error = Arc<[T], A>; *)
    Definition _Error (T A : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "alloc::sync::Arc") [ Ty.apply (Ty.path "slice") [ T ]; A ].
    
    (*
        fn try_from(boxed_slice: Arc<[T], A>) -> Result<Self, Self::Error> {
            if boxed_slice.len() == N {
                let alloc = boxed_slice.alloc.clone();
                Ok(unsafe { Arc::from_raw_in(Arc::into_raw(boxed_slice) as *mut [T; N], alloc) })
            } else {
                Err(boxed_slice)
            }
        }
    *)
    Definition try_from (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match τ, α with
      | [], [ boxed_slice ] =>
        ltac:(M.monadic
          (let boxed_slice := M.alloc (| boxed_slice |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          BinOp.Pure.eq
                            (M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply (Ty.path "slice") [ T ],
                                "len",
                                []
                              |),
                              [
                                M.call_closure (|
                                  M.get_trait_method (|
                                    "core::ops::deref::Deref",
                                    Ty.apply
                                      (Ty.path "alloc::sync::Arc")
                                      [ Ty.apply (Ty.path "slice") [ T ]; A ],
                                    [],
                                    "deref",
                                    []
                                  |),
                                  [ boxed_slice ]
                                |)
                              ]
                            |))
                            (M.read (| M.get_constant (| "alloc::sync::N" |) |))
                        |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    let alloc :=
                      M.alloc (|
                        M.call_closure (|
                          M.get_trait_method (| "core::clone::Clone", A, [], "clone", [] |),
                          [
                            M.SubPointer.get_struct_record_field (|
                              boxed_slice,
                              "alloc::sync::Arc",
                              "alloc"
                            |)
                          ]
                        |)
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply
                                (Ty.path "alloc::sync::Arc")
                                [ Ty.apply (Ty.path "array") [ T ]; A ],
                              "from_raw_in",
                              []
                            |),
                            [
                              (* MutToConstPointer *)
                              M.pointer_coercion
                                (M.rust_cast
                                  (M.call_closure (|
                                    M.get_associated_function (|
                                      Ty.apply
                                        (Ty.path "alloc::sync::Arc")
                                        [ Ty.apply (Ty.path "slice") [ T ]; A ],
                                      "into_raw",
                                      []
                                    |),
                                    [ M.read (| boxed_slice |) ]
                                  |)));
                              M.read (| alloc |)
                            ]
                          |)
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      Value.StructTuple "core::result::Result::Err" [ M.read (| boxed_slice |) ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (T A : Ty.t),
      M.IsTraitInstance
        "core::convert::TryFrom"
        (Self T A)
        (* Trait polymorphic types *)
        [ (* T *) Ty.apply (Ty.path "alloc::sync::Arc") [ Ty.apply (Ty.path "slice") [ T ]; A ] ]
        (* Instance *)
        [
          ("Error", InstanceField.Ty (_Error T A));
          ("try_from", InstanceField.Method (try_from T A))
        ].
  End Impl_core_convert_TryFrom_where_core_alloc_Allocator_A_where_core_clone_Clone_A_alloc_sync_Arc_slice_T_A_for_alloc_sync_Arc_array_T_A.
  
  Module Impl_core_iter_traits_collect_FromIterator_T_for_alloc_sync_Arc_slice_T_alloc_alloc_Global.
    Definition Self (T : Ty.t) : Ty.t :=
      Ty.apply
        (Ty.path "alloc::sync::Arc")
        [ Ty.apply (Ty.path "slice") [ T ]; Ty.path "alloc::alloc::Global" ].
    
    (*
        fn from_iter<I: IntoIterator<Item = T>>(iter: I) -> Self {
            ToArcSlice::to_arc_slice(iter.into_iter())
        }
    *)
    Definition from_iter (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match τ, α with
      | [ _ as I ], [ iter ] =>
        ltac:(M.monadic
          (let iter := M.alloc (| iter |) in
          M.call_closure (|
            M.get_trait_method (|
              "alloc::sync::ToArcSlice",
              Ty.associated,
              [ T ],
              "to_arc_slice",
              []
            |),
            [
              M.call_closure (|
                M.get_trait_method (|
                  "core::iter::traits::collect::IntoIterator",
                  I,
                  [],
                  "into_iter",
                  []
                |),
                [ M.read (| iter |) ]
              |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "core::iter::traits::collect::FromIterator"
        (Self T)
        (* Trait polymorphic types *) [ (* A *) T ]
        (* Instance *) [ ("from_iter", InstanceField.Method (from_iter T)) ].
  End Impl_core_iter_traits_collect_FromIterator_T_for_alloc_sync_Arc_slice_T_alloc_alloc_Global.
  
  (* Trait *)
  (* Empty module 'ToArcSlice' *)
  
  Module Impl_alloc_sync_ToArcSlice_where_core_iter_traits_iterator_Iterator_I_T_for_I.
    Definition Self (T I : Ty.t) : Ty.t := I.
    
    (*
        default fn to_arc_slice(self) -> Arc<[T]> {
            self.collect::<Vec<T>>().into()
        }
    *)
    Definition to_arc_slice (T I : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T I in
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_trait_method (|
              "core::convert::Into",
              Ty.apply (Ty.path "alloc::vec::Vec") [ T; Ty.path "alloc::alloc::Global" ],
              [
                Ty.apply
                  (Ty.path "alloc::sync::Arc")
                  [ Ty.apply (Ty.path "slice") [ T ]; Ty.path "alloc::alloc::Global" ]
              ],
              "into",
              []
            |),
            [
              M.call_closure (|
                M.get_trait_method (|
                  "core::iter::traits::iterator::Iterator",
                  I,
                  [],
                  "collect",
                  [ Ty.apply (Ty.path "alloc::vec::Vec") [ T; Ty.path "alloc::alloc::Global" ] ]
                |),
                [ M.read (| self |) ]
              |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (T I : Ty.t),
      M.IsTraitInstance
        "alloc::sync::ToArcSlice"
        (Self T I)
        (* Trait polymorphic types *) [ (* T *) T ]
        (* Instance *) [ ("to_arc_slice", InstanceField.Method (to_arc_slice T I)) ].
  End Impl_alloc_sync_ToArcSlice_where_core_iter_traits_iterator_Iterator_I_T_for_I.
  
  Module Impl_alloc_sync_ToArcSlice_where_core_iter_traits_marker_TrustedLen_I_T_for_I.
    Definition Self (T I : Ty.t) : Ty.t := I.
    
    (*
        fn to_arc_slice(self) -> Arc<[T]> {
            // This is the case for a `TrustedLen` iterator.
            let (low, high) = self.size_hint();
            if let Some(high) = high {
                debug_assert_eq!(
                    low,
                    high,
                    "TrustedLen iterator's size hint is not exact: {:?}",
                    (low, high)
                );
    
                unsafe {
                    // SAFETY: We need to ensure that the iterator has an exact length and we have.
                    Arc::from_iter_exact(self, low)
                }
            } else {
                // TrustedLen contract guarantees that `upper_bound == None` implies an iterator
                // length exceeding `usize::MAX`.
                // The default implementation would collect into a vec which would panic.
                // Thus we panic here immediately without invoking `Vec` code.
                panic!("capacity overflow");
            }
        }
    *)
    Definition to_arc_slice (T I : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T I in
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_trait_method (|
                    "core::iter::traits::iterator::Iterator",
                    I,
                    [],
                    "size_hint",
                    []
                  |),
                  [ self ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let low := M.copy (| γ0_0 |) in
                    let high := M.copy (| γ0_1 |) in
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ := high in
                            let γ0_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "core::option::Option::Some",
                                0
                              |) in
                            let high := M.copy (| γ0_0 |) in
                            let _ :=
                              M.match_operator (|
                                M.alloc (| Value.Tuple [] |),
                                [
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let γ := M.use (M.alloc (| Value.Bool true |)) in
                                      let _ :=
                                        M.is_constant_or_break_match (|
                                          M.read (| γ |),
                                          Value.Bool true
                                        |) in
                                      let _ :=
                                        M.match_operator (|
                                          M.alloc (| Value.Tuple [ low; high ] |),
                                          [
                                            fun γ =>
                                              ltac:(M.monadic
                                                (let γ0_0 :=
                                                  M.SubPointer.get_tuple_field (| γ, 0 |) in
                                                let γ0_1 :=
                                                  M.SubPointer.get_tuple_field (| γ, 1 |) in
                                                let left_val := M.copy (| γ0_0 |) in
                                                let right_val := M.copy (| γ0_1 |) in
                                                M.match_operator (|
                                                  M.alloc (| Value.Tuple [] |),
                                                  [
                                                    fun γ =>
                                                      ltac:(M.monadic
                                                        (let γ :=
                                                          M.use
                                                            (M.alloc (|
                                                              UnOp.Pure.not
                                                                (BinOp.Pure.eq
                                                                  (M.read (|
                                                                    M.read (| left_val |)
                                                                  |))
                                                                  (M.read (|
                                                                    M.read (| right_val |)
                                                                  |)))
                                                            |)) in
                                                        let _ :=
                                                          M.is_constant_or_break_match (|
                                                            M.read (| γ |),
                                                            Value.Bool true
                                                          |) in
                                                        M.alloc (|
                                                          M.never_to_any (|
                                                            M.read (|
                                                              let kind :=
                                                                M.alloc (|
                                                                  Value.StructTuple
                                                                    "core::panicking::AssertKind::Eq"
                                                                    []
                                                                |) in
                                                              M.alloc (|
                                                                M.call_closure (|
                                                                  M.get_function (|
                                                                    "core::panicking::assert_failed",
                                                                    [
                                                                      Ty.path "usize";
                                                                      Ty.path "usize"
                                                                    ]
                                                                  |),
                                                                  [
                                                                    M.read (| kind |);
                                                                    M.read (| left_val |);
                                                                    M.read (| right_val |);
                                                                    Value.StructTuple
                                                                      "core::option::Option::Some"
                                                                      [
                                                                        M.call_closure (|
                                                                          M.get_associated_function (|
                                                                            Ty.path
                                                                              "core::fmt::Arguments",
                                                                            "new_v1",
                                                                            []
                                                                          |),
                                                                          [
                                                                            (* Unsize *)
                                                                            M.pointer_coercion
                                                                              (M.alloc (|
                                                                                Value.Array
                                                                                  [
                                                                                    M.read (|
                                                                                      Value.String
                                                                                        "TrustedLen iterator's size hint is not exact: "
                                                                                    |)
                                                                                  ]
                                                                              |));
                                                                            (* Unsize *)
                                                                            M.pointer_coercion
                                                                              (M.alloc (|
                                                                                Value.Array
                                                                                  [
                                                                                    M.call_closure (|
                                                                                      M.get_associated_function (|
                                                                                        Ty.path
                                                                                          "core::fmt::rt::Argument",
                                                                                        "new_debug",
                                                                                        [
                                                                                          Ty.tuple
                                                                                            [
                                                                                              Ty.path
                                                                                                "usize";
                                                                                              Ty.path
                                                                                                "usize"
                                                                                            ]
                                                                                        ]
                                                                                      |),
                                                                                      [
                                                                                        M.alloc (|
                                                                                          Value.Tuple
                                                                                            [
                                                                                              M.read (|
                                                                                                low
                                                                                              |);
                                                                                              M.read (|
                                                                                                high
                                                                                              |)
                                                                                            ]
                                                                                        |)
                                                                                      ]
                                                                                    |)
                                                                                  ]
                                                                              |))
                                                                          ]
                                                                        |)
                                                                      ]
                                                                  ]
                                                                |)
                                                              |)
                                                            |)
                                                          |)
                                                        |)));
                                                    fun γ =>
                                                      ltac:(M.monadic
                                                        (M.alloc (| Value.Tuple [] |)))
                                                  ]
                                                |)))
                                          ]
                                        |) in
                                      M.alloc (| Value.Tuple [] |)));
                                  fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                                ]
                              |) in
                            M.alloc (|
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "alloc::sync::Arc")
                                    [
                                      Ty.apply (Ty.path "slice") [ T ];
                                      Ty.path "alloc::alloc::Global"
                                    ],
                                  "from_iter_exact",
                                  [ I ]
                                |),
                                [ M.read (| self |); M.read (| low |) ]
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (M.alloc (|
                              M.never_to_any (|
                                M.call_closure (|
                                  M.get_function (| "core::panicking::panic_fmt", [] |),
                                  [
                                    M.call_closure (|
                                      M.get_associated_function (|
                                        Ty.path "core::fmt::Arguments",
                                        "new_const",
                                        []
                                      |),
                                      [
                                        (* Unsize *)
                                        M.pointer_coercion
                                          (M.alloc (|
                                            Value.Array
                                              [ M.read (| Value.String "capacity overflow" |) ]
                                          |))
                                      ]
                                    |)
                                  ]
                                |)
                              |)
                            |)))
                      ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (T I : Ty.t),
      M.IsTraitInstance
        "alloc::sync::ToArcSlice"
        (Self T I)
        (* Trait polymorphic types *) [ (* T *) T ]
        (* Instance *) [ ("to_arc_slice", InstanceField.Method (to_arc_slice T I)) ].
  End Impl_alloc_sync_ToArcSlice_where_core_iter_traits_marker_TrustedLen_I_T_for_I.
  
  Module Impl_core_borrow_Borrow_where_core_marker_Sized_T_where_core_alloc_Allocator_A_T_for_alloc_sync_Arc_T_A.
    Definition Self (T A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::sync::Arc") [ T; A ].
    
    (*
        fn borrow(&self) -> &T {
            &**self
        }
    *)
    Definition borrow (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_trait_method (|
              "core::ops::deref::Deref",
              Ty.apply (Ty.path "alloc::sync::Arc") [ T; A ],
              [],
              "deref",
              []
            |),
            [ M.read (| self |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (T A : Ty.t),
      M.IsTraitInstance
        "core::borrow::Borrow"
        (Self T A)
        (* Trait polymorphic types *) [ (* Borrowed *) T ]
        (* Instance *) [ ("borrow", InstanceField.Method (borrow T A)) ].
  End Impl_core_borrow_Borrow_where_core_marker_Sized_T_where_core_alloc_Allocator_A_T_for_alloc_sync_Arc_T_A.
  
  Module Impl_core_convert_AsRef_where_core_marker_Sized_T_where_core_alloc_Allocator_A_T_for_alloc_sync_Arc_T_A.
    Definition Self (T A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::sync::Arc") [ T; A ].
    
    (*
        fn as_ref(&self) -> &T {
            &**self
        }
    *)
    Definition as_ref (T A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_trait_method (|
              "core::ops::deref::Deref",
              Ty.apply (Ty.path "alloc::sync::Arc") [ T; A ],
              [],
              "deref",
              []
            |),
            [ M.read (| self |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (T A : Ty.t),
      M.IsTraitInstance
        "core::convert::AsRef"
        (Self T A)
        (* Trait polymorphic types *) [ (* T *) T ]
        (* Instance *) [ ("as_ref", InstanceField.Method (as_ref T A)) ].
  End Impl_core_convert_AsRef_where_core_marker_Sized_T_where_core_alloc_Allocator_A_T_for_alloc_sync_Arc_T_A.
  
  Module Impl_core_marker_Unpin_where_core_marker_Sized_T_where_core_alloc_Allocator_A_for_alloc_sync_Arc_T_A.
    Definition Self (T A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::sync::Arc") [ T; A ].
    
    Axiom Implements :
      forall (T A : Ty.t),
      M.IsTraitInstance
        "core::marker::Unpin"
        (Self T A)
        (* Trait polymorphic types *) []
        (* Instance *) [].
  End Impl_core_marker_Unpin_where_core_marker_Sized_T_where_core_alloc_Allocator_A_for_alloc_sync_Arc_T_A.
  
  (*
  unsafe fn data_offset<T: ?Sized>(ptr: *const T) -> usize {
      // Align the unsized value to the end of the ArcInner.
      // Because RcBox is repr(C), it will always be the last field in memory.
      // SAFETY: since the only unsized types possible are slices, trait objects,
      // and extern types, the input safety requirement is currently enough to
      // satisfy the requirements of align_of_val_raw; this is an implementation
      // detail of the language that must not be relied upon outside of std.
      unsafe { data_offset_align(align_of_val_raw(ptr)) }
  }
  *)
  Definition data_offset (τ : list Ty.t) (α : list Value.t) : M :=
    match τ, α with
    | [ T ], [ ptr ] =>
      ltac:(M.monadic
        (let ptr := M.alloc (| ptr |) in
        M.call_closure (|
          M.get_function (| "alloc::sync::data_offset_align", [] |),
          [
            M.call_closure (|
              M.get_function (| "core::mem::align_of_val_raw", [ T ] |),
              [ M.read (| ptr |) ]
            |)
          ]
        |)))
    | _, _ => M.impossible
    end.
  
  (*
  fn data_offset_align(align: usize) -> usize {
      let layout = Layout::new::<ArcInner<()>>();
      layout.size() + layout.padding_needed_for(align)
  }
  *)
  Definition data_offset_align (τ : list Ty.t) (α : list Value.t) : M :=
    match τ, α with
    | [], [ align ] =>
      ltac:(M.monadic
        (let align := M.alloc (| align |) in
        M.read (|
          let layout :=
            M.alloc (|
              M.call_closure (|
                M.get_associated_function (|
                  Ty.path "core::alloc::layout::Layout",
                  "new",
                  [ Ty.apply (Ty.path "alloc::sync::ArcInner") [ Ty.tuple [] ] ]
                |),
                []
              |)
            |) in
          M.alloc (|
            BinOp.Panic.add (|
              Integer.Usize,
              M.call_closure (|
                M.get_associated_function (| Ty.path "core::alloc::layout::Layout", "size", [] |),
                [ layout ]
              |),
              M.call_closure (|
                M.get_associated_function (|
                  Ty.path "core::alloc::layout::Layout",
                  "padding_needed_for",
                  []
                |),
                [ layout; M.read (| align |) ]
              |)
            |)
          |)
        |)))
    | _, _ => M.impossible
    end.
  
  Module Impl_core_error_Error_where_core_error_Error_T_where_core_marker_Sized_T_for_alloc_sync_Arc_T_alloc_alloc_Global.
    Definition Self (T : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "alloc::sync::Arc") [ T; Ty.path "alloc::alloc::Global" ].
    
    (*
        fn description(&self) -> &str {
            core::error::Error::description(&**self)
        }
    *)
    Definition description (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_trait_method (| "core::error::Error", T, [], "description", [] |),
            [
              M.call_closure (|
                M.get_trait_method (|
                  "core::ops::deref::Deref",
                  Ty.apply (Ty.path "alloc::sync::Arc") [ T; Ty.path "alloc::alloc::Global" ],
                  [],
                  "deref",
                  []
                |),
                [ M.read (| self |) ]
              |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    (*
        fn cause(&self) -> Option<&dyn core::error::Error> {
            core::error::Error::cause(&**self)
        }
    *)
    Definition cause (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_trait_method (| "core::error::Error", T, [], "cause", [] |),
            [
              M.call_closure (|
                M.get_trait_method (|
                  "core::ops::deref::Deref",
                  Ty.apply (Ty.path "alloc::sync::Arc") [ T; Ty.path "alloc::alloc::Global" ],
                  [],
                  "deref",
                  []
                |),
                [ M.read (| self |) ]
              |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    (*
        fn source(&self) -> Option<&(dyn core::error::Error + 'static)> {
            core::error::Error::source(&**self)
        }
    *)
    Definition source (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_trait_method (| "core::error::Error", T, [], "source", [] |),
            [
              M.call_closure (|
                M.get_trait_method (|
                  "core::ops::deref::Deref",
                  Ty.apply (Ty.path "alloc::sync::Arc") [ T; Ty.path "alloc::alloc::Global" ],
                  [],
                  "deref",
                  []
                |),
                [ M.read (| self |) ]
              |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    (*
        fn provide<'a>(&'a self, req: &mut core::error::Request<'a>) {
            core::error::Error::provide(&**self, req);
        }
    *)
    Definition provide (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match τ, α with
      | [], [ self; req ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let req := M.alloc (| req |) in
          M.read (|
            let _ :=
              M.alloc (|
                M.call_closure (|
                  M.get_trait_method (| "core::error::Error", T, [], "provide", [] |),
                  [
                    M.call_closure (|
                      M.get_trait_method (|
                        "core::ops::deref::Deref",
                        Ty.apply (Ty.path "alloc::sync::Arc") [ T; Ty.path "alloc::alloc::Global" ],
                        [],
                        "deref",
                        []
                      |),
                      [ M.read (| self |) ]
                    |);
                    M.read (| req |)
                  ]
                |)
              |) in
            M.alloc (| Value.Tuple [] |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "core::error::Error"
        (Self T)
        (* Trait polymorphic types *) []
        (* Instance *)
        [
          ("description", InstanceField.Method (description T));
          ("cause", InstanceField.Method (cause T));
          ("source", InstanceField.Method (source T));
          ("provide", InstanceField.Method (provide T))
        ].
  End Impl_core_error_Error_where_core_error_Error_T_where_core_marker_Sized_T_for_alloc_sync_Arc_T_alloc_alloc_Global.
End sync.
