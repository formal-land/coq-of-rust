(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module sync.
  Definition value_MAX_REFCOUNT (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    ltac:(M.monadic
      (M.alloc (|
        M.cast
          (Ty.path "usize")
          (M.read (| get_associated_constant (| Ty.path "isize", "MAX", Ty.path "isize" |) |))
      |))).
  
  Global Instance Instance_IsConstant_value_MAX_REFCOUNT :
    M.IsFunction.C "alloc::sync::MAX_REFCOUNT" value_MAX_REFCOUNT.
  Admitted.
  Global Typeclasses Opaque value_MAX_REFCOUNT.
  
  Definition value_INTERNAL_OVERFLOW_ERROR
      (ε : list Value.t)
      (τ : list Ty.t)
      (α : list Value.t)
      : M :=
    ltac:(M.monadic (M.alloc (| mk_str (| "Arc counter overflow" |) |))).
  
  Global Instance Instance_IsConstant_value_INTERNAL_OVERFLOW_ERROR :
    M.IsFunction.C "alloc::sync::INTERNAL_OVERFLOW_ERROR" value_INTERNAL_OVERFLOW_ERROR.
  Admitted.
  Global Typeclasses Opaque value_INTERNAL_OVERFLOW_ERROR.
  
  (* StructRecord
    {
      name := "Arc";
      const_params := [];
      ty_params := [ "T"; "A" ];
      fields :=
        [
          ("ptr",
            Ty.apply
              (Ty.path "core::ptr::non_null::NonNull")
              []
              [ Ty.apply (Ty.path "alloc::sync::ArcInner") [] [ T ] ]);
          ("phantom",
            Ty.apply
              (Ty.path "core::marker::PhantomData")
              []
              [ Ty.apply (Ty.path "alloc::sync::ArcInner") [] [ T ] ]);
          ("alloc", A)
        ];
    } *)
  
  Module Impl_core_marker_Send_where_core_marker_Sized_T_where_core_marker_Sync_T_where_core_marker_Send_T_where_core_alloc_Allocator_A_where_core_marker_Send_A_for_alloc_sync_Arc_T_A.
    Definition Self (T A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; A ].
    
    Axiom Implements :
      forall (T A : Ty.t),
      M.IsTraitInstance
        "core::marker::Send"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self T A)
        (* Instance *) [].
  End Impl_core_marker_Send_where_core_marker_Sized_T_where_core_marker_Sync_T_where_core_marker_Send_T_where_core_alloc_Allocator_A_where_core_marker_Send_A_for_alloc_sync_Arc_T_A.
  
  Module Impl_core_marker_Sync_where_core_marker_Sized_T_where_core_marker_Sync_T_where_core_marker_Send_T_where_core_alloc_Allocator_A_where_core_marker_Sync_A_for_alloc_sync_Arc_T_A.
    Definition Self (T A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; A ].
    
    Axiom Implements :
      forall (T A : Ty.t),
      M.IsTraitInstance
        "core::marker::Sync"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self T A)
        (* Instance *) [].
  End Impl_core_marker_Sync_where_core_marker_Sized_T_where_core_marker_Sync_T_where_core_marker_Send_T_where_core_alloc_Allocator_A_where_core_marker_Sync_A_for_alloc_sync_Arc_T_A.
  
  Module Impl_core_panic_unwind_safe_UnwindSafe_where_core_panic_unwind_safe_RefUnwindSafe_T_where_core_marker_Sized_T_where_core_alloc_Allocator_A_where_core_panic_unwind_safe_UnwindSafe_A_for_alloc_sync_Arc_T_A.
    Definition Self (T A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; A ].
    
    Axiom Implements :
      forall (T A : Ty.t),
      M.IsTraitInstance
        "core::panic::unwind_safe::UnwindSafe"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self T A)
        (* Instance *) [].
  End Impl_core_panic_unwind_safe_UnwindSafe_where_core_panic_unwind_safe_RefUnwindSafe_T_where_core_marker_Sized_T_where_core_alloc_Allocator_A_where_core_panic_unwind_safe_UnwindSafe_A_for_alloc_sync_Arc_T_A.
  
  Module Impl_core_ops_unsize_CoerceUnsized_where_core_marker_Sized_T_where_core_marker_Unsize_T_U_where_core_marker_Sized_U_where_core_alloc_Allocator_A_alloc_sync_Arc_U_A_for_alloc_sync_Arc_T_A.
    Definition Self (T U A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; A ].
    
    Axiom Implements :
      forall (T U A : Ty.t),
      M.IsTraitInstance
        "core::ops::unsize::CoerceUnsized"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.apply (Ty.path "alloc::sync::Arc") [] [ U; A ] ]
        (Self T U A)
        (* Instance *) [].
  End Impl_core_ops_unsize_CoerceUnsized_where_core_marker_Sized_T_where_core_marker_Unsize_T_U_where_core_marker_Sized_U_where_core_alloc_Allocator_A_alloc_sync_Arc_U_A_for_alloc_sync_Arc_T_A.
  
  Module Impl_core_ops_unsize_DispatchFromDyn_where_core_marker_Sized_T_where_core_marker_Unsize_T_U_where_core_marker_Sized_U_alloc_sync_Arc_U_alloc_alloc_Global_for_alloc_sync_Arc_T_alloc_alloc_Global.
    Definition Self (T U : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; Ty.path "alloc::alloc::Global" ].
    
    Axiom Implements :
      forall (T U : Ty.t),
      M.IsTraitInstance
        "core::ops::unsize::DispatchFromDyn"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *)
        [ Ty.apply (Ty.path "alloc::sync::Arc") [] [ U; Ty.path "alloc::alloc::Global" ] ]
        (Self T U)
        (* Instance *) [].
  End Impl_core_ops_unsize_DispatchFromDyn_where_core_marker_Sized_T_where_core_marker_Unsize_T_U_where_core_marker_Sized_U_alloc_sync_Arc_U_alloc_alloc_Global_for_alloc_sync_Arc_T_alloc_alloc_Global.
  
  Module Impl_alloc_sync_Arc_T_alloc_alloc_Global.
    Definition Self (T : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; Ty.path "alloc::alloc::Global" ].
    
    (*
        unsafe fn from_inner(ptr: NonNull<ArcInner<T>>) -> Self {
            unsafe { Self::from_inner_in(ptr, Global) }
        }
    *)
    Definition from_inner (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [], [ ptr ] =>
        ltac:(M.monadic
          (let ptr := M.alloc (| ptr |) in
          M.call_closure (|
            Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; Ty.path "alloc::alloc::Global" ],
            M.get_associated_function (|
              Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; Ty.path "alloc::alloc::Global" ],
              "from_inner_in",
              [],
              []
            |),
            [ M.read (| ptr |); Value.StructTuple "alloc::alloc::Global" [] ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_from_inner :
      forall (T : Ty.t),
      M.IsAssociatedFunction.C (Self T) "from_inner" (from_inner T).
    Admitted.
    Global Typeclasses Opaque from_inner.
    
    (*
        unsafe fn from_ptr(ptr: *mut ArcInner<T>) -> Self {
            unsafe { Self::from_ptr_in(ptr, Global) }
        }
    *)
    Definition from_ptr (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [], [ ptr ] =>
        ltac:(M.monadic
          (let ptr := M.alloc (| ptr |) in
          M.call_closure (|
            Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; Ty.path "alloc::alloc::Global" ],
            M.get_associated_function (|
              Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; Ty.path "alloc::alloc::Global" ],
              "from_ptr_in",
              [],
              []
            |),
            [ M.read (| ptr |); Value.StructTuple "alloc::alloc::Global" [] ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_from_ptr :
      forall (T : Ty.t),
      M.IsAssociatedFunction.C (Self T) "from_ptr" (from_ptr T).
    Admitted.
    Global Typeclasses Opaque from_ptr.
    (*
        pub fn new(data: T) -> Arc<T> {
            // Start the weak pointer count as 1 which is the weak pointer that's
            // held by all the strong pointers (kinda), see std/rc.rs for more info
            let x: Box<_> = Box::new(ArcInner {
                strong: atomic::AtomicUsize::new(1),
                weak: atomic::AtomicUsize::new(1),
                data,
            });
            unsafe { Self::from_inner(Box::leak(x).into()) }
        }
    *)
    Definition new (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [], [ data ] =>
        ltac:(M.monadic
          (let data := M.alloc (| data |) in
          M.read (|
            let~ x :
                Ty.apply
                  (Ty.path "*")
                  []
                  [
                    Ty.apply
                      (Ty.path "alloc::boxed::Box")
                      []
                      [
                        Ty.apply (Ty.path "alloc::sync::ArcInner") [] [ T ];
                        Ty.path "alloc::alloc::Global"
                      ]
                  ] :=
              M.alloc (|
                M.call_closure (|
                  Ty.apply
                    (Ty.path "alloc::boxed::Box")
                    []
                    [
                      Ty.apply (Ty.path "alloc::sync::ArcInner") [] [ T ];
                      Ty.path "alloc::alloc::Global"
                    ],
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "alloc::boxed::Box")
                      []
                      [
                        Ty.apply (Ty.path "alloc::sync::ArcInner") [] [ T ];
                        Ty.path "alloc::alloc::Global"
                      ],
                    "new",
                    [],
                    []
                  |),
                  [
                    Value.StructRecord
                      "alloc::sync::ArcInner"
                      [
                        ("strong",
                          M.call_closure (|
                            Ty.path "core::sync::atomic::AtomicUsize",
                            M.get_associated_function (|
                              Ty.path "core::sync::atomic::AtomicUsize",
                              "new",
                              [],
                              []
                            |),
                            [ Value.Integer IntegerKind.Usize 1 ]
                          |));
                        ("weak",
                          M.call_closure (|
                            Ty.path "core::sync::atomic::AtomicUsize",
                            M.get_associated_function (|
                              Ty.path "core::sync::atomic::AtomicUsize",
                              "new",
                              [],
                              []
                            |),
                            [ Value.Integer IntegerKind.Usize 1 ]
                          |));
                        ("data", M.read (| data |))
                      ]
                  ]
                |)
              |) in
            M.alloc (|
              M.call_closure (|
                Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; Ty.path "alloc::alloc::Global" ],
                M.get_associated_function (|
                  Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; Ty.path "alloc::alloc::Global" ],
                  "from_inner",
                  [],
                  []
                |),
                [
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "core::ptr::non_null::NonNull")
                      []
                      [ Ty.apply (Ty.path "alloc::sync::ArcInner") [] [ T ] ],
                    M.get_trait_method (|
                      "core::convert::Into",
                      Ty.apply
                        (Ty.path "&mut")
                        []
                        [ Ty.apply (Ty.path "alloc::sync::ArcInner") [] [ T ] ],
                      [],
                      [
                        Ty.apply
                          (Ty.path "core::ptr::non_null::NonNull")
                          []
                          [ Ty.apply (Ty.path "alloc::sync::ArcInner") [] [ T ] ]
                      ],
                      "into",
                      [],
                      []
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.MutRef,
                        M.deref (|
                          M.call_closure (|
                            Ty.apply
                              (Ty.path "&mut")
                              []
                              [ Ty.apply (Ty.path "alloc::sync::ArcInner") [] [ T ] ],
                            M.get_associated_function (|
                              Ty.apply
                                (Ty.path "alloc::boxed::Box")
                                []
                                [
                                  Ty.apply (Ty.path "alloc::sync::ArcInner") [] [ T ];
                                  Ty.path "alloc::alloc::Global"
                                ],
                              "leak",
                              [],
                              []
                            |),
                            [ M.read (| x |) ]
                          |)
                        |)
                      |)
                    ]
                  |)
                ]
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_new :
      forall (T : Ty.t),
      M.IsAssociatedFunction.C (Self T) "new" (new T).
    Admitted.
    Global Typeclasses Opaque new.
    
    (*
        pub fn new_cyclic<F>(data_fn: F) -> Arc<T>
        where
            F: FnOnce(&Weak<T>) -> T,
        {
            Self::new_cyclic_in(data_fn, Global)
        }
    *)
    Definition new_cyclic (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [ F ], [ data_fn ] =>
        ltac:(M.monadic
          (let data_fn := M.alloc (| data_fn |) in
          M.call_closure (|
            Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; Ty.path "alloc::alloc::Global" ],
            M.get_associated_function (|
              Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; Ty.path "alloc::alloc::Global" ],
              "new_cyclic_in",
              [],
              [ F ]
            |),
            [ M.read (| data_fn |); Value.StructTuple "alloc::alloc::Global" [] ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_new_cyclic :
      forall (T : Ty.t),
      M.IsAssociatedFunction.C (Self T) "new_cyclic" (new_cyclic T).
    Admitted.
    Global Typeclasses Opaque new_cyclic.
    
    (*
        pub fn new_uninit() -> Arc<mem::MaybeUninit<T>> {
            unsafe {
                Arc::from_ptr(Arc::allocate_for_layout(
                    Layout::new::<T>(),
                    |layout| Global.allocate(layout),
                    <*mut u8>::cast,
                ))
            }
        }
    *)
    Definition new_uninit (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [], [] =>
        ltac:(M.monadic
          (M.call_closure (|
            Ty.apply
              (Ty.path "alloc::sync::Arc")
              []
              [
                Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ];
                Ty.path "alloc::alloc::Global"
              ],
            M.get_associated_function (|
              Ty.apply
                (Ty.path "alloc::sync::Arc")
                []
                [
                  Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ];
                  Ty.path "alloc::alloc::Global"
                ],
              "from_ptr",
              [],
              []
            |),
            [
              M.call_closure (|
                Ty.apply
                  (Ty.path "*mut")
                  []
                  [
                    Ty.apply
                      (Ty.path "alloc::sync::ArcInner")
                      []
                      [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ] ]
                  ],
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "alloc::sync::Arc")
                    []
                    [
                      Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ];
                      Ty.path "alloc::alloc::Global"
                    ],
                  "allocate_for_layout",
                  [],
                  [
                    Ty.function
                      [ Ty.tuple [ Ty.path "core::alloc::layout::Layout" ] ]
                      (Ty.apply
                        (Ty.path "core::result::Result")
                        []
                        [
                          Ty.apply
                            (Ty.path "core::ptr::non_null::NonNull")
                            []
                            [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ];
                          Ty.path "core::alloc::AllocError"
                        ]);
                    Ty.function
                      [ Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ] ]
                      (Ty.apply
                        (Ty.path "*mut")
                        []
                        [
                          Ty.apply
                            (Ty.path "alloc::sync::ArcInner")
                            []
                            [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ] ]
                        ])
                  ]
                |),
                [
                  M.call_closure (|
                    Ty.path "core::alloc::layout::Layout",
                    M.get_associated_function (|
                      Ty.path "core::alloc::layout::Layout",
                      "new",
                      [],
                      [ T ]
                    |),
                    []
                  |);
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0 ] =>
                          ltac:(M.monadic
                            (M.match_operator (|
                              Ty.apply
                                (Ty.path "*")
                                []
                                [
                                  Ty.function
                                    [ Ty.tuple [ Ty.path "core::alloc::layout::Layout" ] ]
                                    (Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [
                                        Ty.apply
                                          (Ty.path "core::ptr::non_null::NonNull")
                                          []
                                          [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ];
                                        Ty.path "core::alloc::AllocError"
                                      ])
                                ],
                              M.alloc (| α0 |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let layout := M.copy (| γ |) in
                                    M.call_closure (|
                                      Ty.apply
                                        (Ty.path "core::result::Result")
                                        []
                                        [
                                          Ty.apply
                                            (Ty.path "core::ptr::non_null::NonNull")
                                            []
                                            [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ];
                                          Ty.path "core::alloc::AllocError"
                                        ],
                                      M.get_trait_method (|
                                        "core::alloc::Allocator",
                                        Ty.path "alloc::alloc::Global",
                                        [],
                                        [],
                                        "allocate",
                                        [],
                                        []
                                      |),
                                      [
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.alloc (| Value.StructTuple "alloc::alloc::Global" [] |)
                                        |);
                                        M.read (| layout |)
                                      ]
                                    |)))
                              ]
                            |)))
                        | _ => M.impossible "wrong number of arguments"
                        end));
                  M.get_associated_function (|
                    Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ],
                    "cast",
                    [],
                    [
                      Ty.apply
                        (Ty.path "alloc::sync::ArcInner")
                        []
                        [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ] ]
                    ]
                  |)
                ]
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_new_uninit :
      forall (T : Ty.t),
      M.IsAssociatedFunction.C (Self T) "new_uninit" (new_uninit T).
    Admitted.
    Global Typeclasses Opaque new_uninit.
    
    (*
        pub fn new_zeroed() -> Arc<mem::MaybeUninit<T>> {
            unsafe {
                Arc::from_ptr(Arc::allocate_for_layout(
                    Layout::new::<T>(),
                    |layout| Global.allocate_zeroed(layout),
                    <*mut u8>::cast,
                ))
            }
        }
    *)
    Definition new_zeroed (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [], [] =>
        ltac:(M.monadic
          (M.call_closure (|
            Ty.apply
              (Ty.path "alloc::sync::Arc")
              []
              [
                Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ];
                Ty.path "alloc::alloc::Global"
              ],
            M.get_associated_function (|
              Ty.apply
                (Ty.path "alloc::sync::Arc")
                []
                [
                  Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ];
                  Ty.path "alloc::alloc::Global"
                ],
              "from_ptr",
              [],
              []
            |),
            [
              M.call_closure (|
                Ty.apply
                  (Ty.path "*mut")
                  []
                  [
                    Ty.apply
                      (Ty.path "alloc::sync::ArcInner")
                      []
                      [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ] ]
                  ],
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "alloc::sync::Arc")
                    []
                    [
                      Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ];
                      Ty.path "alloc::alloc::Global"
                    ],
                  "allocate_for_layout",
                  [],
                  [
                    Ty.function
                      [ Ty.tuple [ Ty.path "core::alloc::layout::Layout" ] ]
                      (Ty.apply
                        (Ty.path "core::result::Result")
                        []
                        [
                          Ty.apply
                            (Ty.path "core::ptr::non_null::NonNull")
                            []
                            [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ];
                          Ty.path "core::alloc::AllocError"
                        ]);
                    Ty.function
                      [ Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ] ]
                      (Ty.apply
                        (Ty.path "*mut")
                        []
                        [
                          Ty.apply
                            (Ty.path "alloc::sync::ArcInner")
                            []
                            [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ] ]
                        ])
                  ]
                |),
                [
                  M.call_closure (|
                    Ty.path "core::alloc::layout::Layout",
                    M.get_associated_function (|
                      Ty.path "core::alloc::layout::Layout",
                      "new",
                      [],
                      [ T ]
                    |),
                    []
                  |);
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0 ] =>
                          ltac:(M.monadic
                            (M.match_operator (|
                              Ty.apply
                                (Ty.path "*")
                                []
                                [
                                  Ty.function
                                    [ Ty.tuple [ Ty.path "core::alloc::layout::Layout" ] ]
                                    (Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [
                                        Ty.apply
                                          (Ty.path "core::ptr::non_null::NonNull")
                                          []
                                          [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ];
                                        Ty.path "core::alloc::AllocError"
                                      ])
                                ],
                              M.alloc (| α0 |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let layout := M.copy (| γ |) in
                                    M.call_closure (|
                                      Ty.apply
                                        (Ty.path "core::result::Result")
                                        []
                                        [
                                          Ty.apply
                                            (Ty.path "core::ptr::non_null::NonNull")
                                            []
                                            [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ];
                                          Ty.path "core::alloc::AllocError"
                                        ],
                                      M.get_trait_method (|
                                        "core::alloc::Allocator",
                                        Ty.path "alloc::alloc::Global",
                                        [],
                                        [],
                                        "allocate_zeroed",
                                        [],
                                        []
                                      |),
                                      [
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.alloc (| Value.StructTuple "alloc::alloc::Global" [] |)
                                        |);
                                        M.read (| layout |)
                                      ]
                                    |)))
                              ]
                            |)))
                        | _ => M.impossible "wrong number of arguments"
                        end));
                  M.get_associated_function (|
                    Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ],
                    "cast",
                    [],
                    [
                      Ty.apply
                        (Ty.path "alloc::sync::ArcInner")
                        []
                        [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ] ]
                    ]
                  |)
                ]
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_new_zeroed :
      forall (T : Ty.t),
      M.IsAssociatedFunction.C (Self T) "new_zeroed" (new_zeroed T).
    Admitted.
    Global Typeclasses Opaque new_zeroed.
    
    (*
        pub fn pin(data: T) -> Pin<Arc<T>> {
            unsafe { Pin::new_unchecked(Arc::new(data)) }
        }
    *)
    Definition pin (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [], [ data ] =>
        ltac:(M.monadic
          (let data := M.alloc (| data |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "core::pin::Pin")
              []
              [ Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; Ty.path "alloc::alloc::Global" ] ],
            M.get_associated_function (|
              Ty.apply
                (Ty.path "core::pin::Pin")
                []
                [ Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; Ty.path "alloc::alloc::Global" ] ],
              "new_unchecked",
              [],
              []
            |),
            [
              M.call_closure (|
                Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; Ty.path "alloc::alloc::Global" ],
                M.get_associated_function (|
                  Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; Ty.path "alloc::alloc::Global" ],
                  "new",
                  [],
                  []
                |),
                [ M.read (| data |) ]
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_pin :
      forall (T : Ty.t),
      M.IsAssociatedFunction.C (Self T) "pin" (pin T).
    Admitted.
    Global Typeclasses Opaque pin.
    
    (*
        pub fn try_pin(data: T) -> Result<Pin<Arc<T>>, AllocError> {
            unsafe { Ok(Pin::new_unchecked(Arc::try_new(data)?)) }
        }
    *)
    Definition try_pin (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [], [ data ] =>
        ltac:(M.monadic
          (let data := M.alloc (| data |) in
          M.catch_return
            (Ty.apply
              (Ty.path "core::result::Result")
              []
              [
                Ty.apply
                  (Ty.path "core::pin::Pin")
                  []
                  [ Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; Ty.path "alloc::alloc::Global" ]
                  ];
                Ty.path "core::alloc::AllocError"
              ]) (|
            ltac:(M.monadic
              (Value.StructTuple
                "core::result::Result::Ok"
                [
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "core::pin::Pin")
                      []
                      [
                        Ty.apply
                          (Ty.path "alloc::sync::Arc")
                          []
                          [ T; Ty.path "alloc::alloc::Global" ]
                      ],
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "core::pin::Pin")
                        []
                        [
                          Ty.apply
                            (Ty.path "alloc::sync::Arc")
                            []
                            [ T; Ty.path "alloc::alloc::Global" ]
                        ],
                      "new_unchecked",
                      [],
                      []
                    |),
                    [
                      M.read (|
                        M.match_operator (|
                          Ty.apply
                            (Ty.path "*")
                            []
                            [
                              Ty.apply
                                (Ty.path "alloc::sync::Arc")
                                []
                                [ T; Ty.path "alloc::alloc::Global" ]
                            ],
                          M.alloc (|
                            M.call_closure (|
                              Ty.apply
                                (Ty.path "core::ops::control_flow::ControlFlow")
                                []
                                [
                                  Ty.apply
                                    (Ty.path "core::result::Result")
                                    []
                                    [
                                      Ty.path "core::convert::Infallible";
                                      Ty.path "core::alloc::AllocError"
                                    ];
                                  Ty.apply
                                    (Ty.path "alloc::sync::Arc")
                                    []
                                    [ T; Ty.path "alloc::alloc::Global" ]
                                ],
                              M.get_trait_method (|
                                "core::ops::try_trait::Try",
                                Ty.apply
                                  (Ty.path "core::result::Result")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "alloc::sync::Arc")
                                      []
                                      [ T; Ty.path "alloc::alloc::Global" ];
                                    Ty.path "core::alloc::AllocError"
                                  ],
                                [],
                                [],
                                "branch",
                                [],
                                []
                              |),
                              [
                                M.call_closure (|
                                  Ty.apply
                                    (Ty.path "core::result::Result")
                                    []
                                    [
                                      Ty.apply
                                        (Ty.path "alloc::sync::Arc")
                                        []
                                        [ T; Ty.path "alloc::alloc::Global" ];
                                      Ty.path "core::alloc::AllocError"
                                    ],
                                  M.get_associated_function (|
                                    Ty.apply
                                      (Ty.path "alloc::sync::Arc")
                                      []
                                      [ T; Ty.path "alloc::alloc::Global" ],
                                    "try_new",
                                    [],
                                    []
                                  |),
                                  [ M.read (| data |) ]
                                |)
                              ]
                            |)
                          |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ0_0 :=
                                  M.SubPointer.get_struct_tuple_field (|
                                    γ,
                                    "core::ops::control_flow::ControlFlow::Break",
                                    0
                                  |) in
                                let residual := M.copy (| γ0_0 |) in
                                M.alloc (|
                                  M.never_to_any (|
                                    M.read (|
                                      M.return_ (|
                                        M.call_closure (|
                                          Ty.apply
                                            (Ty.path "core::result::Result")
                                            []
                                            [
                                              Ty.apply
                                                (Ty.path "core::pin::Pin")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path "alloc::sync::Arc")
                                                    []
                                                    [ T; Ty.path "alloc::alloc::Global" ]
                                                ];
                                              Ty.path "core::alloc::AllocError"
                                            ],
                                          M.get_trait_method (|
                                            "core::ops::try_trait::FromResidual",
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "core::pin::Pin")
                                                  []
                                                  [
                                                    Ty.apply
                                                      (Ty.path "alloc::sync::Arc")
                                                      []
                                                      [ T; Ty.path "alloc::alloc::Global" ]
                                                  ];
                                                Ty.path "core::alloc::AllocError"
                                              ],
                                            [],
                                            [
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                []
                                                [
                                                  Ty.path "core::convert::Infallible";
                                                  Ty.path "core::alloc::AllocError"
                                                ]
                                            ],
                                            "from_residual",
                                            [],
                                            []
                                          |),
                                          [ M.read (| residual |) ]
                                        |)
                                      |)
                                    |)
                                  |)
                                |)));
                            fun γ =>
                              ltac:(M.monadic
                                (let γ0_0 :=
                                  M.SubPointer.get_struct_tuple_field (|
                                    γ,
                                    "core::ops::control_flow::ControlFlow::Continue",
                                    0
                                  |) in
                                let val := M.copy (| γ0_0 |) in
                                val))
                          ]
                        |)
                      |)
                    ]
                  |)
                ]))
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_try_pin :
      forall (T : Ty.t),
      M.IsAssociatedFunction.C (Self T) "try_pin" (try_pin T).
    Admitted.
    Global Typeclasses Opaque try_pin.
    
    (*
        pub fn try_new(data: T) -> Result<Arc<T>, AllocError> {
            // Start the weak pointer count as 1 which is the weak pointer that's
            // held by all the strong pointers (kinda), see std/rc.rs for more info
            let x: Box<_> = Box::try_new(ArcInner {
                strong: atomic::AtomicUsize::new(1),
                weak: atomic::AtomicUsize::new(1),
                data,
            })?;
            unsafe { Ok(Self::from_inner(Box::leak(x).into())) }
        }
    *)
    Definition try_new (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [], [ data ] =>
        ltac:(M.monadic
          (let data := M.alloc (| data |) in
          M.catch_return
            (Ty.apply
              (Ty.path "core::result::Result")
              []
              [
                Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; Ty.path "alloc::alloc::Global" ];
                Ty.path "core::alloc::AllocError"
              ]) (|
            ltac:(M.monadic
              (M.read (|
                let~ x :
                    Ty.apply
                      (Ty.path "*")
                      []
                      [
                        Ty.apply
                          (Ty.path "alloc::boxed::Box")
                          []
                          [
                            Ty.apply (Ty.path "alloc::sync::ArcInner") [] [ T ];
                            Ty.path "alloc::alloc::Global"
                          ]
                      ] :=
                  M.copy (|
                    M.match_operator (|
                      Ty.apply
                        (Ty.path "*")
                        []
                        [
                          Ty.apply
                            (Ty.path "alloc::boxed::Box")
                            []
                            [
                              Ty.apply (Ty.path "alloc::sync::ArcInner") [] [ T ];
                              Ty.path "alloc::alloc::Global"
                            ]
                        ],
                      M.alloc (|
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "core::ops::control_flow::ControlFlow")
                            []
                            [
                              Ty.apply
                                (Ty.path "core::result::Result")
                                []
                                [
                                  Ty.path "core::convert::Infallible";
                                  Ty.path "core::alloc::AllocError"
                                ];
                              Ty.apply
                                (Ty.path "alloc::boxed::Box")
                                []
                                [
                                  Ty.apply (Ty.path "alloc::sync::ArcInner") [] [ T ];
                                  Ty.path "alloc::alloc::Global"
                                ]
                            ],
                          M.get_trait_method (|
                            "core::ops::try_trait::Try",
                            Ty.apply
                              (Ty.path "core::result::Result")
                              []
                              [
                                Ty.apply
                                  (Ty.path "alloc::boxed::Box")
                                  []
                                  [
                                    Ty.apply (Ty.path "alloc::sync::ArcInner") [] [ T ];
                                    Ty.path "alloc::alloc::Global"
                                  ];
                                Ty.path "core::alloc::AllocError"
                              ],
                            [],
                            [],
                            "branch",
                            [],
                            []
                          |),
                          [
                            M.call_closure (|
                              Ty.apply
                                (Ty.path "core::result::Result")
                                []
                                [
                                  Ty.apply
                                    (Ty.path "alloc::boxed::Box")
                                    []
                                    [
                                      Ty.apply (Ty.path "alloc::sync::ArcInner") [] [ T ];
                                      Ty.path "alloc::alloc::Global"
                                    ];
                                  Ty.path "core::alloc::AllocError"
                                ],
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "alloc::boxed::Box")
                                  []
                                  [
                                    Ty.apply (Ty.path "alloc::sync::ArcInner") [] [ T ];
                                    Ty.path "alloc::alloc::Global"
                                  ],
                                "try_new",
                                [],
                                []
                              |),
                              [
                                Value.StructRecord
                                  "alloc::sync::ArcInner"
                                  [
                                    ("strong",
                                      M.call_closure (|
                                        Ty.path "core::sync::atomic::AtomicUsize",
                                        M.get_associated_function (|
                                          Ty.path "core::sync::atomic::AtomicUsize",
                                          "new",
                                          [],
                                          []
                                        |),
                                        [ Value.Integer IntegerKind.Usize 1 ]
                                      |));
                                    ("weak",
                                      M.call_closure (|
                                        Ty.path "core::sync::atomic::AtomicUsize",
                                        M.get_associated_function (|
                                          Ty.path "core::sync::atomic::AtomicUsize",
                                          "new",
                                          [],
                                          []
                                        |),
                                        [ Value.Integer IntegerKind.Usize 1 ]
                                      |));
                                    ("data", M.read (| data |))
                                  ]
                              ]
                            |)
                          ]
                        |)
                      |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "core::ops::control_flow::ControlFlow::Break",
                                0
                              |) in
                            let residual := M.copy (| γ0_0 |) in
                            M.alloc (|
                              M.never_to_any (|
                                M.read (|
                                  M.return_ (|
                                    M.call_closure (|
                                      Ty.apply
                                        (Ty.path "core::result::Result")
                                        []
                                        [
                                          Ty.apply
                                            (Ty.path "alloc::sync::Arc")
                                            []
                                            [ T; Ty.path "alloc::alloc::Global" ];
                                          Ty.path "core::alloc::AllocError"
                                        ],
                                      M.get_trait_method (|
                                        "core::ops::try_trait::FromResidual",
                                        Ty.apply
                                          (Ty.path "core::result::Result")
                                          []
                                          [
                                            Ty.apply
                                              (Ty.path "alloc::sync::Arc")
                                              []
                                              [ T; Ty.path "alloc::alloc::Global" ];
                                            Ty.path "core::alloc::AllocError"
                                          ],
                                        [],
                                        [
                                          Ty.apply
                                            (Ty.path "core::result::Result")
                                            []
                                            [
                                              Ty.path "core::convert::Infallible";
                                              Ty.path "core::alloc::AllocError"
                                            ]
                                        ],
                                        "from_residual",
                                        [],
                                        []
                                      |),
                                      [ M.read (| residual |) ]
                                    |)
                                  |)
                                |)
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "core::ops::control_flow::ControlFlow::Continue",
                                0
                              |) in
                            let val := M.copy (| γ0_0 |) in
                            val))
                      ]
                    |)
                  |) in
                M.alloc (|
                  Value.StructTuple
                    "core::result::Result::Ok"
                    [
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "alloc::sync::Arc")
                          []
                          [ T; Ty.path "alloc::alloc::Global" ],
                        M.get_associated_function (|
                          Ty.apply
                            (Ty.path "alloc::sync::Arc")
                            []
                            [ T; Ty.path "alloc::alloc::Global" ],
                          "from_inner",
                          [],
                          []
                        |),
                        [
                          M.call_closure (|
                            Ty.apply
                              (Ty.path "core::ptr::non_null::NonNull")
                              []
                              [ Ty.apply (Ty.path "alloc::sync::ArcInner") [] [ T ] ],
                            M.get_trait_method (|
                              "core::convert::Into",
                              Ty.apply
                                (Ty.path "&mut")
                                []
                                [ Ty.apply (Ty.path "alloc::sync::ArcInner") [] [ T ] ],
                              [],
                              [
                                Ty.apply
                                  (Ty.path "core::ptr::non_null::NonNull")
                                  []
                                  [ Ty.apply (Ty.path "alloc::sync::ArcInner") [] [ T ] ]
                              ],
                              "into",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.MutRef,
                                M.deref (|
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "&mut")
                                      []
                                      [ Ty.apply (Ty.path "alloc::sync::ArcInner") [] [ T ] ],
                                    M.get_associated_function (|
                                      Ty.apply
                                        (Ty.path "alloc::boxed::Box")
                                        []
                                        [
                                          Ty.apply (Ty.path "alloc::sync::ArcInner") [] [ T ];
                                          Ty.path "alloc::alloc::Global"
                                        ],
                                      "leak",
                                      [],
                                      []
                                    |),
                                    [ M.read (| x |) ]
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    ]
                |)
              |)))
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_try_new :
      forall (T : Ty.t),
      M.IsAssociatedFunction.C (Self T) "try_new" (try_new T).
    Admitted.
    Global Typeclasses Opaque try_new.
    
    (*
        pub fn try_new_uninit() -> Result<Arc<mem::MaybeUninit<T>>, AllocError> {
            unsafe {
                Ok(Arc::from_ptr(Arc::try_allocate_for_layout(
                    Layout::new::<T>(),
                    |layout| Global.allocate(layout),
                    <*mut u8>::cast,
                )?))
            }
        }
    *)
    Definition try_new_uninit
        (T : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [], [] =>
        ltac:(M.monadic
          (M.catch_return
            (Ty.apply
              (Ty.path "core::result::Result")
              []
              [
                Ty.apply
                  (Ty.path "alloc::sync::Arc")
                  []
                  [
                    Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ];
                    Ty.path "alloc::alloc::Global"
                  ];
                Ty.path "core::alloc::AllocError"
              ]) (|
            ltac:(M.monadic
              (Value.StructTuple
                "core::result::Result::Ok"
                [
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "alloc::sync::Arc")
                      []
                      [
                        Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ];
                        Ty.path "alloc::alloc::Global"
                      ],
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "alloc::sync::Arc")
                        []
                        [
                          Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ];
                          Ty.path "alloc::alloc::Global"
                        ],
                      "from_ptr",
                      [],
                      []
                    |),
                    [
                      M.read (|
                        M.match_operator (|
                          Ty.apply
                            (Ty.path "*")
                            []
                            [
                              Ty.apply
                                (Ty.path "*mut")
                                []
                                [
                                  Ty.apply
                                    (Ty.path "alloc::sync::ArcInner")
                                    []
                                    [
                                      Ty.apply
                                        (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                        []
                                        [ T ]
                                    ]
                                ]
                            ],
                          M.alloc (|
                            M.call_closure (|
                              Ty.apply
                                (Ty.path "core::ops::control_flow::ControlFlow")
                                []
                                [
                                  Ty.apply
                                    (Ty.path "core::result::Result")
                                    []
                                    [
                                      Ty.path "core::convert::Infallible";
                                      Ty.path "core::alloc::AllocError"
                                    ];
                                  Ty.apply
                                    (Ty.path "*mut")
                                    []
                                    [
                                      Ty.apply
                                        (Ty.path "alloc::sync::ArcInner")
                                        []
                                        [
                                          Ty.apply
                                            (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                            []
                                            [ T ]
                                        ]
                                    ]
                                ],
                              M.get_trait_method (|
                                "core::ops::try_trait::Try",
                                Ty.apply
                                  (Ty.path "core::result::Result")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "*mut")
                                      []
                                      [
                                        Ty.apply
                                          (Ty.path "alloc::sync::ArcInner")
                                          []
                                          [
                                            Ty.apply
                                              (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                              []
                                              [ T ]
                                          ]
                                      ];
                                    Ty.path "core::alloc::AllocError"
                                  ],
                                [],
                                [],
                                "branch",
                                [],
                                []
                              |),
                              [
                                M.call_closure (|
                                  Ty.apply
                                    (Ty.path "core::result::Result")
                                    []
                                    [
                                      Ty.apply
                                        (Ty.path "*mut")
                                        []
                                        [
                                          Ty.apply
                                            (Ty.path "alloc::sync::ArcInner")
                                            []
                                            [
                                              Ty.apply
                                                (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                                []
                                                [ T ]
                                            ]
                                        ];
                                      Ty.path "core::alloc::AllocError"
                                    ],
                                  M.get_associated_function (|
                                    Ty.apply
                                      (Ty.path "alloc::sync::Arc")
                                      []
                                      [
                                        Ty.apply
                                          (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                          []
                                          [ T ];
                                        Ty.path "alloc::alloc::Global"
                                      ],
                                    "try_allocate_for_layout",
                                    [],
                                    [
                                      Ty.function
                                        [ Ty.tuple [ Ty.path "core::alloc::layout::Layout" ] ]
                                        (Ty.apply
                                          (Ty.path "core::result::Result")
                                          []
                                          [
                                            Ty.apply
                                              (Ty.path "core::ptr::non_null::NonNull")
                                              []
                                              [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ];
                                            Ty.path "core::alloc::AllocError"
                                          ]);
                                      Ty.function
                                        [ Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ] ]
                                        (Ty.apply
                                          (Ty.path "*mut")
                                          []
                                          [
                                            Ty.apply
                                              (Ty.path "alloc::sync::ArcInner")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                                  []
                                                  [ T ]
                                              ]
                                          ])
                                    ]
                                  |),
                                  [
                                    M.call_closure (|
                                      Ty.path "core::alloc::layout::Layout",
                                      M.get_associated_function (|
                                        Ty.path "core::alloc::layout::Layout",
                                        "new",
                                        [],
                                        [ T ]
                                      |),
                                      []
                                    |);
                                    M.closure
                                      (fun γ =>
                                        ltac:(M.monadic
                                          match γ with
                                          | [ α0 ] =>
                                            ltac:(M.monadic
                                              (M.match_operator (|
                                                Ty.apply
                                                  (Ty.path "*")
                                                  []
                                                  [
                                                    Ty.function
                                                      [
                                                        Ty.tuple
                                                          [ Ty.path "core::alloc::layout::Layout" ]
                                                      ]
                                                      (Ty.apply
                                                        (Ty.path "core::result::Result")
                                                        []
                                                        [
                                                          Ty.apply
                                                            (Ty.path "core::ptr::non_null::NonNull")
                                                            []
                                                            [
                                                              Ty.apply
                                                                (Ty.path "slice")
                                                                []
                                                                [ Ty.path "u8" ]
                                                            ];
                                                          Ty.path "core::alloc::AllocError"
                                                        ])
                                                  ],
                                                M.alloc (| α0 |),
                                                [
                                                  fun γ =>
                                                    ltac:(M.monadic
                                                      (let layout := M.copy (| γ |) in
                                                      M.call_closure (|
                                                        Ty.apply
                                                          (Ty.path "core::result::Result")
                                                          []
                                                          [
                                                            Ty.apply
                                                              (Ty.path
                                                                "core::ptr::non_null::NonNull")
                                                              []
                                                              [
                                                                Ty.apply
                                                                  (Ty.path "slice")
                                                                  []
                                                                  [ Ty.path "u8" ]
                                                              ];
                                                            Ty.path "core::alloc::AllocError"
                                                          ],
                                                        M.get_trait_method (|
                                                          "core::alloc::Allocator",
                                                          Ty.path "alloc::alloc::Global",
                                                          [],
                                                          [],
                                                          "allocate",
                                                          [],
                                                          []
                                                        |),
                                                        [
                                                          M.borrow (|
                                                            Pointer.Kind.Ref,
                                                            M.alloc (|
                                                              Value.StructTuple
                                                                "alloc::alloc::Global"
                                                                []
                                                            |)
                                                          |);
                                                          M.read (| layout |)
                                                        ]
                                                      |)))
                                                ]
                                              |)))
                                          | _ => M.impossible "wrong number of arguments"
                                          end));
                                    M.get_associated_function (|
                                      Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ],
                                      "cast",
                                      [],
                                      [
                                        Ty.apply
                                          (Ty.path "alloc::sync::ArcInner")
                                          []
                                          [
                                            Ty.apply
                                              (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                              []
                                              [ T ]
                                          ]
                                      ]
                                    |)
                                  ]
                                |)
                              ]
                            |)
                          |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ0_0 :=
                                  M.SubPointer.get_struct_tuple_field (|
                                    γ,
                                    "core::ops::control_flow::ControlFlow::Break",
                                    0
                                  |) in
                                let residual := M.copy (| γ0_0 |) in
                                M.alloc (|
                                  M.never_to_any (|
                                    M.read (|
                                      M.return_ (|
                                        M.call_closure (|
                                          Ty.apply
                                            (Ty.path "core::result::Result")
                                            []
                                            [
                                              Ty.apply
                                                (Ty.path "alloc::sync::Arc")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                                    []
                                                    [ T ];
                                                  Ty.path "alloc::alloc::Global"
                                                ];
                                              Ty.path "core::alloc::AllocError"
                                            ],
                                          M.get_trait_method (|
                                            "core::ops::try_trait::FromResidual",
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "alloc::sync::Arc")
                                                  []
                                                  [
                                                    Ty.apply
                                                      (Ty.path
                                                        "core::mem::maybe_uninit::MaybeUninit")
                                                      []
                                                      [ T ];
                                                    Ty.path "alloc::alloc::Global"
                                                  ];
                                                Ty.path "core::alloc::AllocError"
                                              ],
                                            [],
                                            [
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                []
                                                [
                                                  Ty.path "core::convert::Infallible";
                                                  Ty.path "core::alloc::AllocError"
                                                ]
                                            ],
                                            "from_residual",
                                            [],
                                            []
                                          |),
                                          [ M.read (| residual |) ]
                                        |)
                                      |)
                                    |)
                                  |)
                                |)));
                            fun γ =>
                              ltac:(M.monadic
                                (let γ0_0 :=
                                  M.SubPointer.get_struct_tuple_field (|
                                    γ,
                                    "core::ops::control_flow::ControlFlow::Continue",
                                    0
                                  |) in
                                let val := M.copy (| γ0_0 |) in
                                val))
                          ]
                        |)
                      |)
                    ]
                  |)
                ]))
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_try_new_uninit :
      forall (T : Ty.t),
      M.IsAssociatedFunction.C (Self T) "try_new_uninit" (try_new_uninit T).
    Admitted.
    Global Typeclasses Opaque try_new_uninit.
    
    (*
        pub fn try_new_zeroed() -> Result<Arc<mem::MaybeUninit<T>>, AllocError> {
            unsafe {
                Ok(Arc::from_ptr(Arc::try_allocate_for_layout(
                    Layout::new::<T>(),
                    |layout| Global.allocate_zeroed(layout),
                    <*mut u8>::cast,
                )?))
            }
        }
    *)
    Definition try_new_zeroed
        (T : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [], [] =>
        ltac:(M.monadic
          (M.catch_return
            (Ty.apply
              (Ty.path "core::result::Result")
              []
              [
                Ty.apply
                  (Ty.path "alloc::sync::Arc")
                  []
                  [
                    Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ];
                    Ty.path "alloc::alloc::Global"
                  ];
                Ty.path "core::alloc::AllocError"
              ]) (|
            ltac:(M.monadic
              (Value.StructTuple
                "core::result::Result::Ok"
                [
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "alloc::sync::Arc")
                      []
                      [
                        Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ];
                        Ty.path "alloc::alloc::Global"
                      ],
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "alloc::sync::Arc")
                        []
                        [
                          Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ];
                          Ty.path "alloc::alloc::Global"
                        ],
                      "from_ptr",
                      [],
                      []
                    |),
                    [
                      M.read (|
                        M.match_operator (|
                          Ty.apply
                            (Ty.path "*")
                            []
                            [
                              Ty.apply
                                (Ty.path "*mut")
                                []
                                [
                                  Ty.apply
                                    (Ty.path "alloc::sync::ArcInner")
                                    []
                                    [
                                      Ty.apply
                                        (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                        []
                                        [ T ]
                                    ]
                                ]
                            ],
                          M.alloc (|
                            M.call_closure (|
                              Ty.apply
                                (Ty.path "core::ops::control_flow::ControlFlow")
                                []
                                [
                                  Ty.apply
                                    (Ty.path "core::result::Result")
                                    []
                                    [
                                      Ty.path "core::convert::Infallible";
                                      Ty.path "core::alloc::AllocError"
                                    ];
                                  Ty.apply
                                    (Ty.path "*mut")
                                    []
                                    [
                                      Ty.apply
                                        (Ty.path "alloc::sync::ArcInner")
                                        []
                                        [
                                          Ty.apply
                                            (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                            []
                                            [ T ]
                                        ]
                                    ]
                                ],
                              M.get_trait_method (|
                                "core::ops::try_trait::Try",
                                Ty.apply
                                  (Ty.path "core::result::Result")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "*mut")
                                      []
                                      [
                                        Ty.apply
                                          (Ty.path "alloc::sync::ArcInner")
                                          []
                                          [
                                            Ty.apply
                                              (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                              []
                                              [ T ]
                                          ]
                                      ];
                                    Ty.path "core::alloc::AllocError"
                                  ],
                                [],
                                [],
                                "branch",
                                [],
                                []
                              |),
                              [
                                M.call_closure (|
                                  Ty.apply
                                    (Ty.path "core::result::Result")
                                    []
                                    [
                                      Ty.apply
                                        (Ty.path "*mut")
                                        []
                                        [
                                          Ty.apply
                                            (Ty.path "alloc::sync::ArcInner")
                                            []
                                            [
                                              Ty.apply
                                                (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                                []
                                                [ T ]
                                            ]
                                        ];
                                      Ty.path "core::alloc::AllocError"
                                    ],
                                  M.get_associated_function (|
                                    Ty.apply
                                      (Ty.path "alloc::sync::Arc")
                                      []
                                      [
                                        Ty.apply
                                          (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                          []
                                          [ T ];
                                        Ty.path "alloc::alloc::Global"
                                      ],
                                    "try_allocate_for_layout",
                                    [],
                                    [
                                      Ty.function
                                        [ Ty.tuple [ Ty.path "core::alloc::layout::Layout" ] ]
                                        (Ty.apply
                                          (Ty.path "core::result::Result")
                                          []
                                          [
                                            Ty.apply
                                              (Ty.path "core::ptr::non_null::NonNull")
                                              []
                                              [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ];
                                            Ty.path "core::alloc::AllocError"
                                          ]);
                                      Ty.function
                                        [ Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ] ]
                                        (Ty.apply
                                          (Ty.path "*mut")
                                          []
                                          [
                                            Ty.apply
                                              (Ty.path "alloc::sync::ArcInner")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                                  []
                                                  [ T ]
                                              ]
                                          ])
                                    ]
                                  |),
                                  [
                                    M.call_closure (|
                                      Ty.path "core::alloc::layout::Layout",
                                      M.get_associated_function (|
                                        Ty.path "core::alloc::layout::Layout",
                                        "new",
                                        [],
                                        [ T ]
                                      |),
                                      []
                                    |);
                                    M.closure
                                      (fun γ =>
                                        ltac:(M.monadic
                                          match γ with
                                          | [ α0 ] =>
                                            ltac:(M.monadic
                                              (M.match_operator (|
                                                Ty.apply
                                                  (Ty.path "*")
                                                  []
                                                  [
                                                    Ty.function
                                                      [
                                                        Ty.tuple
                                                          [ Ty.path "core::alloc::layout::Layout" ]
                                                      ]
                                                      (Ty.apply
                                                        (Ty.path "core::result::Result")
                                                        []
                                                        [
                                                          Ty.apply
                                                            (Ty.path "core::ptr::non_null::NonNull")
                                                            []
                                                            [
                                                              Ty.apply
                                                                (Ty.path "slice")
                                                                []
                                                                [ Ty.path "u8" ]
                                                            ];
                                                          Ty.path "core::alloc::AllocError"
                                                        ])
                                                  ],
                                                M.alloc (| α0 |),
                                                [
                                                  fun γ =>
                                                    ltac:(M.monadic
                                                      (let layout := M.copy (| γ |) in
                                                      M.call_closure (|
                                                        Ty.apply
                                                          (Ty.path "core::result::Result")
                                                          []
                                                          [
                                                            Ty.apply
                                                              (Ty.path
                                                                "core::ptr::non_null::NonNull")
                                                              []
                                                              [
                                                                Ty.apply
                                                                  (Ty.path "slice")
                                                                  []
                                                                  [ Ty.path "u8" ]
                                                              ];
                                                            Ty.path "core::alloc::AllocError"
                                                          ],
                                                        M.get_trait_method (|
                                                          "core::alloc::Allocator",
                                                          Ty.path "alloc::alloc::Global",
                                                          [],
                                                          [],
                                                          "allocate_zeroed",
                                                          [],
                                                          []
                                                        |),
                                                        [
                                                          M.borrow (|
                                                            Pointer.Kind.Ref,
                                                            M.alloc (|
                                                              Value.StructTuple
                                                                "alloc::alloc::Global"
                                                                []
                                                            |)
                                                          |);
                                                          M.read (| layout |)
                                                        ]
                                                      |)))
                                                ]
                                              |)))
                                          | _ => M.impossible "wrong number of arguments"
                                          end));
                                    M.get_associated_function (|
                                      Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ],
                                      "cast",
                                      [],
                                      [
                                        Ty.apply
                                          (Ty.path "alloc::sync::ArcInner")
                                          []
                                          [
                                            Ty.apply
                                              (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                              []
                                              [ T ]
                                          ]
                                      ]
                                    |)
                                  ]
                                |)
                              ]
                            |)
                          |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ0_0 :=
                                  M.SubPointer.get_struct_tuple_field (|
                                    γ,
                                    "core::ops::control_flow::ControlFlow::Break",
                                    0
                                  |) in
                                let residual := M.copy (| γ0_0 |) in
                                M.alloc (|
                                  M.never_to_any (|
                                    M.read (|
                                      M.return_ (|
                                        M.call_closure (|
                                          Ty.apply
                                            (Ty.path "core::result::Result")
                                            []
                                            [
                                              Ty.apply
                                                (Ty.path "alloc::sync::Arc")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                                    []
                                                    [ T ];
                                                  Ty.path "alloc::alloc::Global"
                                                ];
                                              Ty.path "core::alloc::AllocError"
                                            ],
                                          M.get_trait_method (|
                                            "core::ops::try_trait::FromResidual",
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "alloc::sync::Arc")
                                                  []
                                                  [
                                                    Ty.apply
                                                      (Ty.path
                                                        "core::mem::maybe_uninit::MaybeUninit")
                                                      []
                                                      [ T ];
                                                    Ty.path "alloc::alloc::Global"
                                                  ];
                                                Ty.path "core::alloc::AllocError"
                                              ],
                                            [],
                                            [
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                []
                                                [
                                                  Ty.path "core::convert::Infallible";
                                                  Ty.path "core::alloc::AllocError"
                                                ]
                                            ],
                                            "from_residual",
                                            [],
                                            []
                                          |),
                                          [ M.read (| residual |) ]
                                        |)
                                      |)
                                    |)
                                  |)
                                |)));
                            fun γ =>
                              ltac:(M.monadic
                                (let γ0_0 :=
                                  M.SubPointer.get_struct_tuple_field (|
                                    γ,
                                    "core::ops::control_flow::ControlFlow::Continue",
                                    0
                                  |) in
                                let val := M.copy (| γ0_0 |) in
                                val))
                          ]
                        |)
                      |)
                    ]
                  |)
                ]))
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_try_new_zeroed :
      forall (T : Ty.t),
      M.IsAssociatedFunction.C (Self T) "try_new_zeroed" (try_new_zeroed T).
    Admitted.
    Global Typeclasses Opaque try_new_zeroed.
    (*
        pub unsafe fn from_raw(ptr: *const T) -> Self {
            unsafe { Arc::from_raw_in(ptr, Global) }
        }
    *)
    Definition from_raw (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [], [ ptr ] =>
        ltac:(M.monadic
          (let ptr := M.alloc (| ptr |) in
          M.call_closure (|
            Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; Ty.path "alloc::alloc::Global" ],
            M.get_associated_function (|
              Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; Ty.path "alloc::alloc::Global" ],
              "from_raw_in",
              [],
              []
            |),
            [ M.read (| ptr |); Value.StructTuple "alloc::alloc::Global" [] ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_from_raw :
      forall (T : Ty.t),
      M.IsAssociatedFunction.C (Self T) "from_raw" (from_raw T).
    Admitted.
    Global Typeclasses Opaque from_raw.
    
    (*
        pub unsafe fn increment_strong_count(ptr: *const T) {
            unsafe { Arc::increment_strong_count_in(ptr, Global) }
        }
    *)
    Definition increment_strong_count
        (T : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [], [ ptr ] =>
        ltac:(M.monadic
          (let ptr := M.alloc (| ptr |) in
          M.call_closure (|
            Ty.tuple [],
            M.get_associated_function (|
              Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; Ty.path "alloc::alloc::Global" ],
              "increment_strong_count_in",
              [],
              []
            |),
            [ M.read (| ptr |); Value.StructTuple "alloc::alloc::Global" [] ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_increment_strong_count :
      forall (T : Ty.t),
      M.IsAssociatedFunction.C (Self T) "increment_strong_count" (increment_strong_count T).
    Admitted.
    Global Typeclasses Opaque increment_strong_count.
    
    (*
        pub unsafe fn decrement_strong_count(ptr: *const T) {
            unsafe { Arc::decrement_strong_count_in(ptr, Global) }
        }
    *)
    Definition decrement_strong_count
        (T : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [], [ ptr ] =>
        ltac:(M.monadic
          (let ptr := M.alloc (| ptr |) in
          M.call_closure (|
            Ty.tuple [],
            M.get_associated_function (|
              Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; Ty.path "alloc::alloc::Global" ],
              "decrement_strong_count_in",
              [],
              []
            |),
            [ M.read (| ptr |); Value.StructTuple "alloc::alloc::Global" [] ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_decrement_strong_count :
      forall (T : Ty.t),
      M.IsAssociatedFunction.C (Self T) "decrement_strong_count" (decrement_strong_count T).
    Admitted.
    Global Typeclasses Opaque decrement_strong_count.
    (*
        unsafe fn allocate_for_layout(
            value_layout: Layout,
            allocate: impl FnOnce(Layout) -> Result<NonNull<[u8]>, AllocError>,
            mem_to_arcinner: impl FnOnce( *mut u8) -> *mut ArcInner<T>,
        ) -> *mut ArcInner<T> {
            let layout = arcinner_layout_for_value_layout(value_layout);
    
            let ptr = allocate(layout).unwrap_or_else(|_| handle_alloc_error(layout));
    
            unsafe { Self::initialize_arcinner(ptr, layout, mem_to_arcinner) }
        }
    *)
    Definition allocate_for_layout
        (T : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [],
          [
            impl_FnOnce_Layout__arrow_Result_NonNull__u8____AllocError_;
            impl_FnOnce__mut_u8__arrow__mut_ArcInner_T_
          ],
          [ value_layout; allocate; mem_to_arcinner ] =>
        ltac:(M.monadic
          (let value_layout := M.alloc (| value_layout |) in
          let allocate := M.alloc (| allocate |) in
          let mem_to_arcinner := M.alloc (| mem_to_arcinner |) in
          M.read (|
            let~ layout : Ty.apply (Ty.path "*") [] [ Ty.path "core::alloc::layout::Layout" ] :=
              M.alloc (|
                M.call_closure (|
                  Ty.path "core::alloc::layout::Layout",
                  M.get_function (| "alloc::sync::arcinner_layout_for_value_layout", [], [] |),
                  [ M.read (| value_layout |) ]
                |)
              |) in
            let~ ptr :
                Ty.apply
                  (Ty.path "*")
                  []
                  [
                    Ty.apply
                      (Ty.path "core::ptr::non_null::NonNull")
                      []
                      [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
                  ] :=
              M.alloc (|
                M.call_closure (|
                  Ty.apply
                    (Ty.path "core::ptr::non_null::NonNull")
                    []
                    [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "core::result::Result")
                      []
                      [
                        Ty.apply
                          (Ty.path "core::ptr::non_null::NonNull")
                          []
                          [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ];
                        Ty.path "core::alloc::AllocError"
                      ],
                    "unwrap_or_else",
                    [],
                    [
                      Ty.function
                        [ Ty.tuple [ Ty.path "core::alloc::AllocError" ] ]
                        (Ty.apply
                          (Ty.path "core::ptr::non_null::NonNull")
                          []
                          [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ])
                    ]
                  |),
                  [
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "core::result::Result")
                        []
                        [
                          Ty.apply
                            (Ty.path "core::ptr::non_null::NonNull")
                            []
                            [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ];
                          Ty.path "core::alloc::AllocError"
                        ],
                      M.get_trait_method (|
                        "core::ops::function::FnOnce",
                        impl_FnOnce_Layout__arrow_Result_NonNull__u8____AllocError_,
                        [],
                        [ Ty.tuple [ Ty.path "core::alloc::layout::Layout" ] ],
                        "call_once",
                        [],
                        []
                      |),
                      [ M.read (| allocate |); Value.Tuple [ M.read (| layout |) ] ]
                    |);
                    M.closure
                      (fun γ =>
                        ltac:(M.monadic
                          match γ with
                          | [ α0 ] =>
                            ltac:(M.monadic
                              (M.match_operator (|
                                Ty.apply
                                  (Ty.path "*")
                                  []
                                  [
                                    Ty.function
                                      [ Ty.tuple [ Ty.path "core::alloc::AllocError" ] ]
                                      (Ty.apply
                                        (Ty.path "core::ptr::non_null::NonNull")
                                        []
                                        [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ])
                                  ],
                                M.alloc (| α0 |),
                                [
                                  fun γ =>
                                    ltac:(M.monadic
                                      (M.never_to_any (|
                                        M.call_closure (|
                                          Ty.path "never",
                                          M.get_function (|
                                            "alloc::alloc::handle_alloc_error",
                                            [],
                                            []
                                          |),
                                          [ M.read (| layout |) ]
                                        |)
                                      |)))
                                ]
                              |)))
                          | _ => M.impossible "wrong number of arguments"
                          end))
                  ]
                |)
              |) in
            M.alloc (|
              M.call_closure (|
                Ty.apply
                  (Ty.path "*mut")
                  []
                  [ Ty.apply (Ty.path "alloc::sync::ArcInner") [] [ T ] ],
                M.get_associated_function (|
                  Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; Ty.path "alloc::alloc::Global" ],
                  "initialize_arcinner",
                  [],
                  [ impl_FnOnce__mut_u8__arrow__mut_ArcInner_T_ ]
                |),
                [ M.read (| ptr |); M.read (| layout |); M.read (| mem_to_arcinner |) ]
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_allocate_for_layout :
      forall (T : Ty.t),
      M.IsAssociatedFunction.C (Self T) "allocate_for_layout" (allocate_for_layout T).
    Admitted.
    Global Typeclasses Opaque allocate_for_layout.
    
    (*
        unsafe fn try_allocate_for_layout(
            value_layout: Layout,
            allocate: impl FnOnce(Layout) -> Result<NonNull<[u8]>, AllocError>,
            mem_to_arcinner: impl FnOnce( *mut u8) -> *mut ArcInner<T>,
        ) -> Result<*mut ArcInner<T>, AllocError> {
            let layout = arcinner_layout_for_value_layout(value_layout);
    
            let ptr = allocate(layout)?;
    
            let inner = unsafe { Self::initialize_arcinner(ptr, layout, mem_to_arcinner) };
    
            Ok(inner)
        }
    *)
    Definition try_allocate_for_layout
        (T : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [],
          [
            impl_FnOnce_Layout__arrow_Result_NonNull__u8____AllocError_;
            impl_FnOnce__mut_u8__arrow__mut_ArcInner_T_
          ],
          [ value_layout; allocate; mem_to_arcinner ] =>
        ltac:(M.monadic
          (let value_layout := M.alloc (| value_layout |) in
          let allocate := M.alloc (| allocate |) in
          let mem_to_arcinner := M.alloc (| mem_to_arcinner |) in
          M.catch_return
            (Ty.apply
              (Ty.path "core::result::Result")
              []
              [
                Ty.apply
                  (Ty.path "*mut")
                  []
                  [ Ty.apply (Ty.path "alloc::sync::ArcInner") [] [ T ] ];
                Ty.path "core::alloc::AllocError"
              ]) (|
            ltac:(M.monadic
              (M.read (|
                let~ layout : Ty.apply (Ty.path "*") [] [ Ty.path "core::alloc::layout::Layout" ] :=
                  M.alloc (|
                    M.call_closure (|
                      Ty.path "core::alloc::layout::Layout",
                      M.get_function (| "alloc::sync::arcinner_layout_for_value_layout", [], [] |),
                      [ M.read (| value_layout |) ]
                    |)
                  |) in
                let~ ptr :
                    Ty.apply
                      (Ty.path "*")
                      []
                      [
                        Ty.apply
                          (Ty.path "core::ptr::non_null::NonNull")
                          []
                          [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
                      ] :=
                  M.copy (|
                    M.match_operator (|
                      Ty.apply
                        (Ty.path "*")
                        []
                        [
                          Ty.apply
                            (Ty.path "core::ptr::non_null::NonNull")
                            []
                            [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
                        ],
                      M.alloc (|
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "core::ops::control_flow::ControlFlow")
                            []
                            [
                              Ty.apply
                                (Ty.path "core::result::Result")
                                []
                                [
                                  Ty.path "core::convert::Infallible";
                                  Ty.path "core::alloc::AllocError"
                                ];
                              Ty.apply
                                (Ty.path "core::ptr::non_null::NonNull")
                                []
                                [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
                            ],
                          M.get_trait_method (|
                            "core::ops::try_trait::Try",
                            Ty.apply
                              (Ty.path "core::result::Result")
                              []
                              [
                                Ty.apply
                                  (Ty.path "core::ptr::non_null::NonNull")
                                  []
                                  [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ];
                                Ty.path "core::alloc::AllocError"
                              ],
                            [],
                            [],
                            "branch",
                            [],
                            []
                          |),
                          [
                            M.call_closure (|
                              Ty.apply
                                (Ty.path "core::result::Result")
                                []
                                [
                                  Ty.apply
                                    (Ty.path "core::ptr::non_null::NonNull")
                                    []
                                    [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ];
                                  Ty.path "core::alloc::AllocError"
                                ],
                              M.get_trait_method (|
                                "core::ops::function::FnOnce",
                                impl_FnOnce_Layout__arrow_Result_NonNull__u8____AllocError_,
                                [],
                                [ Ty.tuple [ Ty.path "core::alloc::layout::Layout" ] ],
                                "call_once",
                                [],
                                []
                              |),
                              [ M.read (| allocate |); Value.Tuple [ M.read (| layout |) ] ]
                            |)
                          ]
                        |)
                      |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "core::ops::control_flow::ControlFlow::Break",
                                0
                              |) in
                            let residual := M.copy (| γ0_0 |) in
                            M.alloc (|
                              M.never_to_any (|
                                M.read (|
                                  M.return_ (|
                                    M.call_closure (|
                                      Ty.apply
                                        (Ty.path "core::result::Result")
                                        []
                                        [
                                          Ty.apply
                                            (Ty.path "*mut")
                                            []
                                            [ Ty.apply (Ty.path "alloc::sync::ArcInner") [] [ T ] ];
                                          Ty.path "core::alloc::AllocError"
                                        ],
                                      M.get_trait_method (|
                                        "core::ops::try_trait::FromResidual",
                                        Ty.apply
                                          (Ty.path "core::result::Result")
                                          []
                                          [
                                            Ty.apply
                                              (Ty.path "*mut")
                                              []
                                              [ Ty.apply (Ty.path "alloc::sync::ArcInner") [] [ T ]
                                              ];
                                            Ty.path "core::alloc::AllocError"
                                          ],
                                        [],
                                        [
                                          Ty.apply
                                            (Ty.path "core::result::Result")
                                            []
                                            [
                                              Ty.path "core::convert::Infallible";
                                              Ty.path "core::alloc::AllocError"
                                            ]
                                        ],
                                        "from_residual",
                                        [],
                                        []
                                      |),
                                      [ M.read (| residual |) ]
                                    |)
                                  |)
                                |)
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "core::ops::control_flow::ControlFlow::Continue",
                                0
                              |) in
                            let val := M.copy (| γ0_0 |) in
                            val))
                      ]
                    |)
                  |) in
                let~ inner :
                    Ty.apply
                      (Ty.path "*")
                      []
                      [
                        Ty.apply
                          (Ty.path "*mut")
                          []
                          [ Ty.apply (Ty.path "alloc::sync::ArcInner") [] [ T ] ]
                      ] :=
                  M.alloc (|
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "*mut")
                        []
                        [ Ty.apply (Ty.path "alloc::sync::ArcInner") [] [ T ] ],
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "alloc::sync::Arc")
                          []
                          [ T; Ty.path "alloc::alloc::Global" ],
                        "initialize_arcinner",
                        [],
                        [ impl_FnOnce__mut_u8__arrow__mut_ArcInner_T_ ]
                      |),
                      [ M.read (| ptr |); M.read (| layout |); M.read (| mem_to_arcinner |) ]
                    |)
                  |) in
                M.alloc (| Value.StructTuple "core::result::Result::Ok" [ M.read (| inner |) ] |)
              |)))
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_try_allocate_for_layout :
      forall (T : Ty.t),
      M.IsAssociatedFunction.C (Self T) "try_allocate_for_layout" (try_allocate_for_layout T).
    Admitted.
    Global Typeclasses Opaque try_allocate_for_layout.
    
    (*
        unsafe fn initialize_arcinner(
            ptr: NonNull<[u8]>,
            layout: Layout,
            mem_to_arcinner: impl FnOnce( *mut u8) -> *mut ArcInner<T>,
        ) -> *mut ArcInner<T> {
            let inner = mem_to_arcinner(ptr.as_non_null_ptr().as_ptr());
            debug_assert_eq!(unsafe { Layout::for_value_raw(inner) }, layout);
    
            unsafe {
                (&raw mut ( *inner).strong).write(atomic::AtomicUsize::new(1));
                (&raw mut ( *inner).weak).write(atomic::AtomicUsize::new(1));
            }
    
            inner
        }
    *)
    Definition initialize_arcinner
        (T : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [ impl_FnOnce__mut_u8__arrow__mut_ArcInner_T_ ], [ ptr; layout; mem_to_arcinner ] =>
        ltac:(M.monadic
          (let ptr := M.alloc (| ptr |) in
          let layout := M.alloc (| layout |) in
          let mem_to_arcinner := M.alloc (| mem_to_arcinner |) in
          M.read (|
            let~ inner :
                Ty.apply
                  (Ty.path "*")
                  []
                  [
                    Ty.apply
                      (Ty.path "*mut")
                      []
                      [ Ty.apply (Ty.path "alloc::sync::ArcInner") [] [ T ] ]
                  ] :=
              M.alloc (|
                M.call_closure (|
                  Ty.apply
                    (Ty.path "*mut")
                    []
                    [ Ty.apply (Ty.path "alloc::sync::ArcInner") [] [ T ] ],
                  M.get_trait_method (|
                    "core::ops::function::FnOnce",
                    impl_FnOnce__mut_u8__arrow__mut_ArcInner_T_,
                    [],
                    [ Ty.tuple [ Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ] ] ],
                    "call_once",
                    [],
                    []
                  |),
                  [
                    M.read (| mem_to_arcinner |);
                    Value.Tuple
                      [
                        M.call_closure (|
                          Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ],
                          M.get_associated_function (|
                            Ty.apply (Ty.path "core::ptr::non_null::NonNull") [] [ Ty.path "u8" ],
                            "as_ptr",
                            [],
                            []
                          |),
                          [
                            M.call_closure (|
                              Ty.apply (Ty.path "core::ptr::non_null::NonNull") [] [ Ty.path "u8" ],
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "core::ptr::non_null::NonNull")
                                  []
                                  [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                                "as_non_null_ptr",
                                [],
                                []
                              |),
                              [ M.read (| ptr |) ]
                            |)
                          ]
                        |)
                      ]
                  ]
                |)
              |) in
            let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
              M.match_operator (|
                Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.use (M.alloc (| Value.Bool true |)) in
                      let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                        M.match_operator (|
                          Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                          M.alloc (|
                            Value.Tuple
                              [
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.alloc (|
                                    M.call_closure (|
                                      Ty.path "core::alloc::layout::Layout",
                                      M.get_associated_function (|
                                        Ty.path "core::alloc::layout::Layout",
                                        "for_value_raw",
                                        [],
                                        [ Ty.apply (Ty.path "alloc::sync::ArcInner") [] [ T ] ]
                                      |),
                                      [
                                        (* MutToConstPointer *)
                                        M.pointer_coercion (M.read (| inner |))
                                      ]
                                    |)
                                  |)
                                |);
                                M.borrow (| Pointer.Kind.Ref, layout |)
                              ]
                          |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                                let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                let left_val := M.copy (| γ0_0 |) in
                                let right_val := M.copy (| γ0_1 |) in
                                M.match_operator (|
                                  Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                                  M.alloc (| Value.Tuple [] |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ :=
                                          M.use
                                            (M.alloc (|
                                              UnOp.not (|
                                                M.call_closure (|
                                                  Ty.path "bool",
                                                  M.get_trait_method (|
                                                    "core::cmp::PartialEq",
                                                    Ty.path "core::alloc::layout::Layout",
                                                    [],
                                                    [ Ty.path "core::alloc::layout::Layout" ],
                                                    "eq",
                                                    [],
                                                    []
                                                  |),
                                                  [
                                                    M.borrow (|
                                                      Pointer.Kind.Ref,
                                                      M.deref (| M.read (| left_val |) |)
                                                    |);
                                                    M.borrow (|
                                                      Pointer.Kind.Ref,
                                                      M.deref (| M.read (| right_val |) |)
                                                    |)
                                                  ]
                                                |)
                                              |)
                                            |)) in
                                        let _ :=
                                          is_constant_or_break_match (|
                                            M.read (| γ |),
                                            Value.Bool true
                                          |) in
                                        M.alloc (|
                                          M.never_to_any (|
                                            M.read (|
                                              let~ kind :
                                                  Ty.apply
                                                    (Ty.path "*")
                                                    []
                                                    [ Ty.path "core::panicking::AssertKind" ] :=
                                                M.alloc (|
                                                  Value.StructTuple
                                                    "core::panicking::AssertKind::Eq"
                                                    []
                                                |) in
                                              M.alloc (|
                                                M.call_closure (|
                                                  Ty.path "never",
                                                  M.get_function (|
                                                    "core::panicking::assert_failed",
                                                    [],
                                                    [
                                                      Ty.path "core::alloc::layout::Layout";
                                                      Ty.path "core::alloc::layout::Layout"
                                                    ]
                                                  |),
                                                  [
                                                    M.read (| kind |);
                                                    M.borrow (|
                                                      Pointer.Kind.Ref,
                                                      M.deref (|
                                                        M.borrow (|
                                                          Pointer.Kind.Ref,
                                                          M.deref (| M.read (| left_val |) |)
                                                        |)
                                                      |)
                                                    |);
                                                    M.borrow (|
                                                      Pointer.Kind.Ref,
                                                      M.deref (|
                                                        M.borrow (|
                                                          Pointer.Kind.Ref,
                                                          M.deref (| M.read (| right_val |) |)
                                                        |)
                                                      |)
                                                    |);
                                                    Value.StructTuple
                                                      "core::option::Option::None"
                                                      []
                                                  ]
                                                |)
                                              |)
                                            |)
                                          |)
                                        |)));
                                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                                  ]
                                |)))
                          ]
                        |) in
                      M.alloc (| Value.Tuple [] |)));
                  fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                ]
              |) in
            let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.call_closure (|
                    Ty.tuple [],
                    M.get_associated_function (|
                      Ty.apply (Ty.path "*mut") [] [ Ty.path "core::sync::atomic::AtomicUsize" ],
                      "write",
                      [],
                      []
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.MutPointer,
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| inner |) |),
                          "alloc::sync::ArcInner",
                          "strong"
                        |)
                      |);
                      M.call_closure (|
                        Ty.path "core::sync::atomic::AtomicUsize",
                        M.get_associated_function (|
                          Ty.path "core::sync::atomic::AtomicUsize",
                          "new",
                          [],
                          []
                        |),
                        [ Value.Integer IntegerKind.Usize 1 ]
                      |)
                    ]
                  |)
                |) in
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.call_closure (|
                    Ty.tuple [],
                    M.get_associated_function (|
                      Ty.apply (Ty.path "*mut") [] [ Ty.path "core::sync::atomic::AtomicUsize" ],
                      "write",
                      [],
                      []
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.MutPointer,
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| inner |) |),
                          "alloc::sync::ArcInner",
                          "weak"
                        |)
                      |);
                      M.call_closure (|
                        Ty.path "core::sync::atomic::AtomicUsize",
                        M.get_associated_function (|
                          Ty.path "core::sync::atomic::AtomicUsize",
                          "new",
                          [],
                          []
                        |),
                        [ Value.Integer IntegerKind.Usize 1 ]
                      |)
                    ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |) in
            inner
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_initialize_arcinner :
      forall (T : Ty.t),
      M.IsAssociatedFunction.C (Self T) "initialize_arcinner" (initialize_arcinner T).
    Admitted.
    Global Typeclasses Opaque initialize_arcinner.
  End Impl_alloc_sync_Arc_T_alloc_alloc_Global.
  
  Module Impl_alloc_sync_Arc_T_A.
    Definition Self (T A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; A ].
    
    (*
        fn into_inner_with_allocator(this: Self) -> (NonNull<ArcInner<T>>, A) {
            let this = mem::ManuallyDrop::new(this);
            (this.ptr, unsafe { ptr::read(&this.alloc) })
        }
    *)
    Definition into_inner_with_allocator
        (T A : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ this ] =>
        ltac:(M.monadic
          (let this := M.alloc (| this |) in
          M.read (|
            let~ this :
                Ty.apply
                  (Ty.path "*")
                  []
                  [
                    Ty.apply
                      (Ty.path "core::mem::manually_drop::ManuallyDrop")
                      []
                      [ Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; A ] ]
                  ] :=
              M.alloc (|
                M.call_closure (|
                  Ty.apply
                    (Ty.path "core::mem::manually_drop::ManuallyDrop")
                    []
                    [ Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; A ] ],
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "core::mem::manually_drop::ManuallyDrop")
                      []
                      [ Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; A ] ],
                    "new",
                    [],
                    []
                  |),
                  [ M.read (| this |) ]
                |)
              |) in
            M.alloc (|
              Value.Tuple
                [
                  M.read (|
                    M.SubPointer.get_struct_record_field (|
                      M.deref (|
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "&")
                            []
                            [ Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; A ] ],
                          M.get_trait_method (|
                            "core::ops::deref::Deref",
                            Ty.apply
                              (Ty.path "core::mem::manually_drop::ManuallyDrop")
                              []
                              [ Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; A ] ],
                            [],
                            [],
                            "deref",
                            [],
                            []
                          |),
                          [ M.borrow (| Pointer.Kind.Ref, this |) ]
                        |)
                      |),
                      "alloc::sync::Arc",
                      "ptr"
                    |)
                  |);
                  M.call_closure (|
                    A,
                    M.get_function (| "core::ptr::read", [], [ A ] |),
                    [
                      M.borrow (|
                        Pointer.Kind.ConstPointer,
                        M.deref (|
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.SubPointer.get_struct_record_field (|
                              M.deref (|
                                M.call_closure (|
                                  Ty.apply
                                    (Ty.path "&")
                                    []
                                    [ Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; A ] ],
                                  M.get_trait_method (|
                                    "core::ops::deref::Deref",
                                    Ty.apply
                                      (Ty.path "core::mem::manually_drop::ManuallyDrop")
                                      []
                                      [ Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; A ] ],
                                    [],
                                    [],
                                    "deref",
                                    [],
                                    []
                                  |),
                                  [ M.borrow (| Pointer.Kind.Ref, this |) ]
                                |)
                              |),
                              "alloc::sync::Arc",
                              "alloc"
                            |)
                          |)
                        |)
                      |)
                    ]
                  |)
                ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_into_inner_with_allocator :
      forall (T A : Ty.t),
      M.IsAssociatedFunction.C
        (Self T A)
        "into_inner_with_allocator"
        (into_inner_with_allocator T A).
    Admitted.
    Global Typeclasses Opaque into_inner_with_allocator.
    
    (*
        unsafe fn from_inner_in(ptr: NonNull<ArcInner<T>>, alloc: A) -> Self {
            Self { ptr, phantom: PhantomData, alloc }
        }
    *)
    Definition from_inner_in
        (T A : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ ptr; alloc ] =>
        ltac:(M.monadic
          (let ptr := M.alloc (| ptr |) in
          let alloc := M.alloc (| alloc |) in
          Value.StructRecord
            "alloc::sync::Arc"
            [
              ("ptr", M.read (| ptr |));
              ("phantom", Value.StructTuple "core::marker::PhantomData" []);
              ("alloc", M.read (| alloc |))
            ]))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_from_inner_in :
      forall (T A : Ty.t),
      M.IsAssociatedFunction.C (Self T A) "from_inner_in" (from_inner_in T A).
    Admitted.
    Global Typeclasses Opaque from_inner_in.
    
    (*
        unsafe fn from_ptr_in(ptr: *mut ArcInner<T>, alloc: A) -> Self {
            unsafe { Self::from_inner_in(NonNull::new_unchecked(ptr), alloc) }
        }
    *)
    Definition from_ptr_in (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ ptr; alloc ] =>
        ltac:(M.monadic
          (let ptr := M.alloc (| ptr |) in
          let alloc := M.alloc (| alloc |) in
          M.call_closure (|
            Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; A ],
            M.get_associated_function (|
              Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; A ],
              "from_inner_in",
              [],
              []
            |),
            [
              M.call_closure (|
                Ty.apply
                  (Ty.path "core::ptr::non_null::NonNull")
                  []
                  [ Ty.apply (Ty.path "alloc::sync::ArcInner") [] [ T ] ],
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "core::ptr::non_null::NonNull")
                    []
                    [ Ty.apply (Ty.path "alloc::sync::ArcInner") [] [ T ] ],
                  "new_unchecked",
                  [],
                  []
                |),
                [ M.read (| ptr |) ]
              |);
              M.read (| alloc |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_from_ptr_in :
      forall (T A : Ty.t),
      M.IsAssociatedFunction.C (Self T A) "from_ptr_in" (from_ptr_in T A).
    Admitted.
    Global Typeclasses Opaque from_ptr_in.
    (*
        pub fn new_in(data: T, alloc: A) -> Arc<T, A> {
            // Start the weak pointer count as 1 which is the weak pointer that's
            // held by all the strong pointers (kinda), see std/rc.rs for more info
            let x = Box::new_in(
                ArcInner {
                    strong: atomic::AtomicUsize::new(1),
                    weak: atomic::AtomicUsize::new(1),
                    data,
                },
                alloc,
            );
            let (ptr, alloc) = Box::into_unique(x);
            unsafe { Self::from_inner_in(ptr.into(), alloc) }
        }
    *)
    Definition new_in (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ data; alloc ] =>
        ltac:(M.monadic
          (let data := M.alloc (| data |) in
          let alloc := M.alloc (| alloc |) in
          M.read (|
            let~ x :
                Ty.apply
                  (Ty.path "*")
                  []
                  [
                    Ty.apply
                      (Ty.path "alloc::boxed::Box")
                      []
                      [ Ty.apply (Ty.path "alloc::sync::ArcInner") [] [ T ]; A ]
                  ] :=
              M.alloc (|
                M.call_closure (|
                  Ty.apply
                    (Ty.path "alloc::boxed::Box")
                    []
                    [ Ty.apply (Ty.path "alloc::sync::ArcInner") [] [ T ]; A ],
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "alloc::boxed::Box")
                      []
                      [ Ty.apply (Ty.path "alloc::sync::ArcInner") [] [ T ]; A ],
                    "new_in",
                    [],
                    []
                  |),
                  [
                    Value.StructRecord
                      "alloc::sync::ArcInner"
                      [
                        ("strong",
                          M.call_closure (|
                            Ty.path "core::sync::atomic::AtomicUsize",
                            M.get_associated_function (|
                              Ty.path "core::sync::atomic::AtomicUsize",
                              "new",
                              [],
                              []
                            |),
                            [ Value.Integer IntegerKind.Usize 1 ]
                          |));
                        ("weak",
                          M.call_closure (|
                            Ty.path "core::sync::atomic::AtomicUsize",
                            M.get_associated_function (|
                              Ty.path "core::sync::atomic::AtomicUsize",
                              "new",
                              [],
                              []
                            |),
                            [ Value.Integer IntegerKind.Usize 1 ]
                          |));
                        ("data", M.read (| data |))
                      ];
                    M.read (| alloc |)
                  ]
                |)
              |) in
            M.match_operator (|
              Ty.apply (Ty.path "*") [] [ Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; A ] ],
              M.alloc (|
                M.call_closure (|
                  Ty.tuple
                    [
                      Ty.apply
                        (Ty.path "core::ptr::unique::Unique")
                        []
                        [ Ty.apply (Ty.path "alloc::sync::ArcInner") [] [ T ] ];
                      A
                    ],
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "alloc::boxed::Box")
                      []
                      [ Ty.apply (Ty.path "alloc::sync::ArcInner") [] [ T ]; A ],
                    "into_unique",
                    [],
                    []
                  |),
                  [ M.read (| x |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let ptr := M.copy (| γ0_0 |) in
                    let alloc := M.copy (| γ0_1 |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; A ],
                        M.get_associated_function (|
                          Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; A ],
                          "from_inner_in",
                          [],
                          []
                        |),
                        [
                          M.call_closure (|
                            Ty.apply
                              (Ty.path "core::ptr::non_null::NonNull")
                              []
                              [ Ty.apply (Ty.path "alloc::sync::ArcInner") [] [ T ] ],
                            M.get_trait_method (|
                              "core::convert::Into",
                              Ty.apply
                                (Ty.path "core::ptr::unique::Unique")
                                []
                                [ Ty.apply (Ty.path "alloc::sync::ArcInner") [] [ T ] ],
                              [],
                              [
                                Ty.apply
                                  (Ty.path "core::ptr::non_null::NonNull")
                                  []
                                  [ Ty.apply (Ty.path "alloc::sync::ArcInner") [] [ T ] ]
                              ],
                              "into",
                              [],
                              []
                            |),
                            [ M.read (| ptr |) ]
                          |);
                          M.read (| alloc |)
                        ]
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_new_in :
      forall (T A : Ty.t),
      M.IsAssociatedFunction.C (Self T A) "new_in" (new_in T A).
    Admitted.
    Global Typeclasses Opaque new_in.
    
    (*
        pub fn new_uninit_in(alloc: A) -> Arc<mem::MaybeUninit<T>, A> {
            unsafe {
                Arc::from_ptr_in(
                    Arc::allocate_for_layout(
                        Layout::new::<T>(),
                        |layout| alloc.allocate(layout),
                        <*mut u8>::cast,
                    ),
                    alloc,
                )
            }
        }
    *)
    Definition new_uninit_in
        (T A : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ alloc ] =>
        ltac:(M.monadic
          (let alloc := M.alloc (| alloc |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "alloc::sync::Arc")
              []
              [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ]; A ],
            M.get_associated_function (|
              Ty.apply
                (Ty.path "alloc::sync::Arc")
                []
                [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ]; A ],
              "from_ptr_in",
              [],
              []
            |),
            [
              M.call_closure (|
                Ty.apply
                  (Ty.path "*mut")
                  []
                  [
                    Ty.apply
                      (Ty.path "alloc::sync::ArcInner")
                      []
                      [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ] ]
                  ],
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "alloc::sync::Arc")
                    []
                    [
                      Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ];
                      Ty.path "alloc::alloc::Global"
                    ],
                  "allocate_for_layout",
                  [],
                  [
                    Ty.function
                      [ Ty.tuple [ Ty.path "core::alloc::layout::Layout" ] ]
                      (Ty.apply
                        (Ty.path "core::result::Result")
                        []
                        [
                          Ty.apply
                            (Ty.path "core::ptr::non_null::NonNull")
                            []
                            [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ];
                          Ty.path "core::alloc::AllocError"
                        ]);
                    Ty.function
                      [ Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ] ]
                      (Ty.apply
                        (Ty.path "*mut")
                        []
                        [
                          Ty.apply
                            (Ty.path "alloc::sync::ArcInner")
                            []
                            [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ] ]
                        ])
                  ]
                |),
                [
                  M.call_closure (|
                    Ty.path "core::alloc::layout::Layout",
                    M.get_associated_function (|
                      Ty.path "core::alloc::layout::Layout",
                      "new",
                      [],
                      [ T ]
                    |),
                    []
                  |);
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0 ] =>
                          ltac:(M.monadic
                            (M.match_operator (|
                              Ty.apply
                                (Ty.path "*")
                                []
                                [
                                  Ty.function
                                    [ Ty.tuple [ Ty.path "core::alloc::layout::Layout" ] ]
                                    (Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [
                                        Ty.apply
                                          (Ty.path "core::ptr::non_null::NonNull")
                                          []
                                          [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ];
                                        Ty.path "core::alloc::AllocError"
                                      ])
                                ],
                              M.alloc (| α0 |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let layout := M.copy (| γ |) in
                                    M.call_closure (|
                                      Ty.apply
                                        (Ty.path "core::result::Result")
                                        []
                                        [
                                          Ty.apply
                                            (Ty.path "core::ptr::non_null::NonNull")
                                            []
                                            [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ];
                                          Ty.path "core::alloc::AllocError"
                                        ],
                                      M.get_trait_method (|
                                        "core::alloc::Allocator",
                                        A,
                                        [],
                                        [],
                                        "allocate",
                                        [],
                                        []
                                      |),
                                      [ M.borrow (| Pointer.Kind.Ref, alloc |); M.read (| layout |)
                                      ]
                                    |)))
                              ]
                            |)))
                        | _ => M.impossible "wrong number of arguments"
                        end));
                  M.get_associated_function (|
                    Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ],
                    "cast",
                    [],
                    [
                      Ty.apply
                        (Ty.path "alloc::sync::ArcInner")
                        []
                        [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ] ]
                    ]
                  |)
                ]
              |);
              M.read (| alloc |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_new_uninit_in :
      forall (T A : Ty.t),
      M.IsAssociatedFunction.C (Self T A) "new_uninit_in" (new_uninit_in T A).
    Admitted.
    Global Typeclasses Opaque new_uninit_in.
    
    (*
        pub fn new_zeroed_in(alloc: A) -> Arc<mem::MaybeUninit<T>, A> {
            unsafe {
                Arc::from_ptr_in(
                    Arc::allocate_for_layout(
                        Layout::new::<T>(),
                        |layout| alloc.allocate_zeroed(layout),
                        <*mut u8>::cast,
                    ),
                    alloc,
                )
            }
        }
    *)
    Definition new_zeroed_in
        (T A : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ alloc ] =>
        ltac:(M.monadic
          (let alloc := M.alloc (| alloc |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "alloc::sync::Arc")
              []
              [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ]; A ],
            M.get_associated_function (|
              Ty.apply
                (Ty.path "alloc::sync::Arc")
                []
                [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ]; A ],
              "from_ptr_in",
              [],
              []
            |),
            [
              M.call_closure (|
                Ty.apply
                  (Ty.path "*mut")
                  []
                  [
                    Ty.apply
                      (Ty.path "alloc::sync::ArcInner")
                      []
                      [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ] ]
                  ],
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "alloc::sync::Arc")
                    []
                    [
                      Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ];
                      Ty.path "alloc::alloc::Global"
                    ],
                  "allocate_for_layout",
                  [],
                  [
                    Ty.function
                      [ Ty.tuple [ Ty.path "core::alloc::layout::Layout" ] ]
                      (Ty.apply
                        (Ty.path "core::result::Result")
                        []
                        [
                          Ty.apply
                            (Ty.path "core::ptr::non_null::NonNull")
                            []
                            [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ];
                          Ty.path "core::alloc::AllocError"
                        ]);
                    Ty.function
                      [ Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ] ]
                      (Ty.apply
                        (Ty.path "*mut")
                        []
                        [
                          Ty.apply
                            (Ty.path "alloc::sync::ArcInner")
                            []
                            [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ] ]
                        ])
                  ]
                |),
                [
                  M.call_closure (|
                    Ty.path "core::alloc::layout::Layout",
                    M.get_associated_function (|
                      Ty.path "core::alloc::layout::Layout",
                      "new",
                      [],
                      [ T ]
                    |),
                    []
                  |);
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0 ] =>
                          ltac:(M.monadic
                            (M.match_operator (|
                              Ty.apply
                                (Ty.path "*")
                                []
                                [
                                  Ty.function
                                    [ Ty.tuple [ Ty.path "core::alloc::layout::Layout" ] ]
                                    (Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [
                                        Ty.apply
                                          (Ty.path "core::ptr::non_null::NonNull")
                                          []
                                          [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ];
                                        Ty.path "core::alloc::AllocError"
                                      ])
                                ],
                              M.alloc (| α0 |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let layout := M.copy (| γ |) in
                                    M.call_closure (|
                                      Ty.apply
                                        (Ty.path "core::result::Result")
                                        []
                                        [
                                          Ty.apply
                                            (Ty.path "core::ptr::non_null::NonNull")
                                            []
                                            [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ];
                                          Ty.path "core::alloc::AllocError"
                                        ],
                                      M.get_trait_method (|
                                        "core::alloc::Allocator",
                                        A,
                                        [],
                                        [],
                                        "allocate_zeroed",
                                        [],
                                        []
                                      |),
                                      [ M.borrow (| Pointer.Kind.Ref, alloc |); M.read (| layout |)
                                      ]
                                    |)))
                              ]
                            |)))
                        | _ => M.impossible "wrong number of arguments"
                        end));
                  M.get_associated_function (|
                    Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ],
                    "cast",
                    [],
                    [
                      Ty.apply
                        (Ty.path "alloc::sync::ArcInner")
                        []
                        [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ] ]
                    ]
                  |)
                ]
              |);
              M.read (| alloc |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_new_zeroed_in :
      forall (T A : Ty.t),
      M.IsAssociatedFunction.C (Self T A) "new_zeroed_in" (new_zeroed_in T A).
    Admitted.
    Global Typeclasses Opaque new_zeroed_in.
    
    (*
        pub fn new_cyclic_in<F>(data_fn: F, alloc: A) -> Arc<T, A>
        where
            F: FnOnce(&Weak<T, A>) -> T,
        {
            // Construct the inner in the "uninitialized" state with a single
            // weak reference.
            let (uninit_raw_ptr, alloc) = Box::into_raw_with_allocator(Box::new_in(
                ArcInner {
                    strong: atomic::AtomicUsize::new(0),
                    weak: atomic::AtomicUsize::new(1),
                    data: mem::MaybeUninit::<T>::uninit(),
                },
                alloc,
            ));
            let uninit_ptr: NonNull<_> = (unsafe { &mut *uninit_raw_ptr }).into();
            let init_ptr: NonNull<ArcInner<T>> = uninit_ptr.cast();
    
            let weak = Weak { ptr: init_ptr, alloc: alloc };
    
            // It's important we don't give up ownership of the weak pointer, or
            // else the memory might be freed by the time `data_fn` returns. If
            // we really wanted to pass ownership, we could create an additional
            // weak pointer for ourselves, but this would result in additional
            // updates to the weak reference count which might not be necessary
            // otherwise.
            let data = data_fn(&weak);
    
            // Now we can properly initialize the inner value and turn our weak
            // reference into a strong reference.
            let strong = unsafe {
                let inner = init_ptr.as_ptr();
                ptr::write(&raw mut ( *inner).data, data);
    
                // The above write to the data field must be visible to any threads which
                // observe a non-zero strong count. Therefore we need at least "Release" ordering
                // in order to synchronize with the `compare_exchange_weak` in `Weak::upgrade`.
                //
                // "Acquire" ordering is not required. When considering the possible behaviors
                // of `data_fn` we only need to look at what it could do with a reference to a
                // non-upgradeable `Weak`:
                // - It can *clone* the `Weak`, increasing the weak reference count.
                // - It can drop those clones, decreasing the weak reference count (but never to zero).
                //
                // These side effects do not impact us in any way, and no other side effects are
                // possible with safe code alone.
                let prev_value = ( *inner).strong.fetch_add(1, Release);
                debug_assert_eq!(prev_value, 0, "No prior strong references should exist");
    
                // Strong references should collectively own a shared weak reference,
                // so don't run the destructor for our old weak reference.
                // Calling into_raw_with_allocator has the double effect of giving us back the allocator,
                // and forgetting the weak reference.
                let alloc = weak.into_raw_with_allocator().1;
    
                Arc::from_inner_in(init_ptr, alloc)
            };
    
            strong
        }
    *)
    Definition new_cyclic_in
        (T A : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [ F ], [ data_fn; alloc ] =>
        ltac:(M.monadic
          (let data_fn := M.alloc (| data_fn |) in
          let alloc := M.alloc (| alloc |) in
          M.read (|
            M.match_operator (|
              Ty.apply (Ty.path "*") [] [ Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; A ] ],
              M.alloc (|
                M.call_closure (|
                  Ty.tuple
                    [
                      Ty.apply
                        (Ty.path "*mut")
                        []
                        [
                          Ty.apply
                            (Ty.path "alloc::sync::ArcInner")
                            []
                            [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ] ]
                        ];
                      A
                    ],
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "alloc::boxed::Box")
                      []
                      [
                        Ty.apply
                          (Ty.path "alloc::sync::ArcInner")
                          []
                          [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ] ];
                        A
                      ],
                    "into_raw_with_allocator",
                    [],
                    []
                  |),
                  [
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "alloc::boxed::Box")
                        []
                        [
                          Ty.apply
                            (Ty.path "alloc::sync::ArcInner")
                            []
                            [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ] ];
                          A
                        ],
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "alloc::boxed::Box")
                          []
                          [
                            Ty.apply
                              (Ty.path "alloc::sync::ArcInner")
                              []
                              [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ]
                              ];
                            A
                          ],
                        "new_in",
                        [],
                        []
                      |),
                      [
                        Value.StructRecord
                          "alloc::sync::ArcInner"
                          [
                            ("strong",
                              M.call_closure (|
                                Ty.path "core::sync::atomic::AtomicUsize",
                                M.get_associated_function (|
                                  Ty.path "core::sync::atomic::AtomicUsize",
                                  "new",
                                  [],
                                  []
                                |),
                                [ Value.Integer IntegerKind.Usize 0 ]
                              |));
                            ("weak",
                              M.call_closure (|
                                Ty.path "core::sync::atomic::AtomicUsize",
                                M.get_associated_function (|
                                  Ty.path "core::sync::atomic::AtomicUsize",
                                  "new",
                                  [],
                                  []
                                |),
                                [ Value.Integer IntegerKind.Usize 1 ]
                              |));
                            ("data",
                              M.call_closure (|
                                Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ],
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                    []
                                    [ T ],
                                  "uninit",
                                  [],
                                  []
                                |),
                                []
                              |))
                          ];
                        M.read (| alloc |)
                      ]
                    |)
                  ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let uninit_raw_ptr := M.copy (| γ0_0 |) in
                    let alloc := M.copy (| γ0_1 |) in
                    let~ uninit_ptr :
                        Ty.apply
                          (Ty.path "*")
                          []
                          [
                            Ty.apply
                              (Ty.path "core::ptr::non_null::NonNull")
                              []
                              [
                                Ty.apply
                                  (Ty.path "alloc::sync::ArcInner")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                      []
                                      [ T ]
                                  ]
                              ]
                          ] :=
                      M.alloc (|
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "core::ptr::non_null::NonNull")
                            []
                            [
                              Ty.apply
                                (Ty.path "alloc::sync::ArcInner")
                                []
                                [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ]
                                ]
                            ],
                          M.get_trait_method (|
                            "core::convert::Into",
                            Ty.apply
                              (Ty.path "&mut")
                              []
                              [
                                Ty.apply
                                  (Ty.path "alloc::sync::ArcInner")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                      []
                                      [ T ]
                                  ]
                              ],
                            [],
                            [
                              Ty.apply
                                (Ty.path "core::ptr::non_null::NonNull")
                                []
                                [
                                  Ty.apply
                                    (Ty.path "alloc::sync::ArcInner")
                                    []
                                    [
                                      Ty.apply
                                        (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                        []
                                        [ T ]
                                    ]
                                ]
                            ],
                            "into",
                            [],
                            []
                          |),
                          [
                            M.borrow (|
                              Pointer.Kind.MutRef,
                              M.deref (|
                                M.borrow (|
                                  Pointer.Kind.MutRef,
                                  M.deref (| M.read (| uninit_raw_ptr |) |)
                                |)
                              |)
                            |)
                          ]
                        |)
                      |) in
                    let~ init_ptr :
                        Ty.apply
                          (Ty.path "*")
                          []
                          [
                            Ty.apply
                              (Ty.path "core::ptr::non_null::NonNull")
                              []
                              [ Ty.apply (Ty.path "alloc::sync::ArcInner") [] [ T ] ]
                          ] :=
                      M.alloc (|
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "core::ptr::non_null::NonNull")
                            []
                            [ Ty.apply (Ty.path "alloc::sync::ArcInner") [] [ T ] ],
                          M.get_associated_function (|
                            Ty.apply
                              (Ty.path "core::ptr::non_null::NonNull")
                              []
                              [
                                Ty.apply
                                  (Ty.path "alloc::sync::ArcInner")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                      []
                                      [ T ]
                                  ]
                              ],
                            "cast",
                            [],
                            [ Ty.apply (Ty.path "alloc::sync::ArcInner") [] [ T ] ]
                          |),
                          [ M.read (| uninit_ptr |) ]
                        |)
                      |) in
                    let~ weak :
                        Ty.apply
                          (Ty.path "*")
                          []
                          [ Ty.apply (Ty.path "alloc::sync::Weak") [] [ T; A ] ] :=
                      M.alloc (|
                        Value.StructRecord
                          "alloc::sync::Weak"
                          [ ("ptr", M.read (| init_ptr |)); ("alloc", M.read (| alloc |)) ]
                      |) in
                    let~ data : Ty.apply (Ty.path "*") [] [ T ] :=
                      M.alloc (|
                        M.call_closure (|
                          T,
                          M.get_trait_method (|
                            "core::ops::function::FnOnce",
                            F,
                            [],
                            [
                              Ty.tuple
                                [
                                  Ty.apply
                                    (Ty.path "&")
                                    []
                                    [ Ty.apply (Ty.path "alloc::sync::Weak") [] [ T; A ] ]
                                ]
                            ],
                            "call_once",
                            [],
                            []
                          |),
                          [
                            M.read (| data_fn |);
                            Value.Tuple
                              [
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.deref (| M.borrow (| Pointer.Kind.Ref, weak |) |)
                                |)
                              ]
                          ]
                        |)
                      |) in
                    let~ strong :
                        Ty.apply
                          (Ty.path "*")
                          []
                          [ Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; A ] ] :=
                      M.copy (|
                        let~ inner :
                            Ty.apply
                              (Ty.path "*")
                              []
                              [
                                Ty.apply
                                  (Ty.path "*mut")
                                  []
                                  [ Ty.apply (Ty.path "alloc::sync::ArcInner") [] [ T ] ]
                              ] :=
                          M.alloc (|
                            M.call_closure (|
                              Ty.apply
                                (Ty.path "*mut")
                                []
                                [ Ty.apply (Ty.path "alloc::sync::ArcInner") [] [ T ] ],
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "core::ptr::non_null::NonNull")
                                  []
                                  [ Ty.apply (Ty.path "alloc::sync::ArcInner") [] [ T ] ],
                                "as_ptr",
                                [],
                                []
                              |),
                              [ M.read (| init_ptr |) ]
                            |)
                          |) in
                        let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                          M.alloc (|
                            M.call_closure (|
                              Ty.tuple [],
                              M.get_function (| "core::ptr::write", [], [ T ] |),
                              [
                                M.borrow (|
                                  Pointer.Kind.MutPointer,
                                  M.SubPointer.get_struct_record_field (|
                                    M.deref (| M.read (| inner |) |),
                                    "alloc::sync::ArcInner",
                                    "data"
                                  |)
                                |);
                                M.read (| data |)
                              ]
                            |)
                          |) in
                        let~ prev_value : Ty.apply (Ty.path "*") [] [ Ty.path "usize" ] :=
                          M.alloc (|
                            M.call_closure (|
                              Ty.path "usize",
                              M.get_associated_function (|
                                Ty.path "core::sync::atomic::AtomicUsize",
                                "fetch_add",
                                [],
                                []
                              |),
                              [
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.SubPointer.get_struct_record_field (|
                                    M.deref (| M.read (| inner |) |),
                                    "alloc::sync::ArcInner",
                                    "strong"
                                  |)
                                |);
                                Value.Integer IntegerKind.Usize 1;
                                Value.StructTuple "core::sync::atomic::Ordering::Release" []
                              ]
                            |)
                          |) in
                        let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                          M.match_operator (|
                            Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                            M.alloc (| Value.Tuple [] |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ := M.use (M.alloc (| Value.Bool true |)) in
                                  let _ :=
                                    is_constant_or_break_match (|
                                      M.read (| γ |),
                                      Value.Bool true
                                    |) in
                                  let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                                    M.match_operator (|
                                      Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                                      M.alloc (|
                                        Value.Tuple
                                          [
                                            M.borrow (| Pointer.Kind.Ref, prev_value |);
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.alloc (| Value.Integer IntegerKind.Usize 0 |)
                                            |)
                                          ]
                                      |),
                                      [
                                        fun γ =>
                                          ltac:(M.monadic
                                            (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                                            let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                            let left_val := M.copy (| γ0_0 |) in
                                            let right_val := M.copy (| γ0_1 |) in
                                            M.match_operator (|
                                              Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                                              M.alloc (| Value.Tuple [] |),
                                              [
                                                fun γ =>
                                                  ltac:(M.monadic
                                                    (let γ :=
                                                      M.use
                                                        (M.alloc (|
                                                          UnOp.not (|
                                                            M.call_closure (|
                                                              Ty.path "bool",
                                                              BinOp.eq,
                                                              [
                                                                M.read (|
                                                                  M.deref (|
                                                                    M.read (| left_val |)
                                                                  |)
                                                                |);
                                                                M.read (|
                                                                  M.deref (|
                                                                    M.read (| right_val |)
                                                                  |)
                                                                |)
                                                              ]
                                                            |)
                                                          |)
                                                        |)) in
                                                    let _ :=
                                                      is_constant_or_break_match (|
                                                        M.read (| γ |),
                                                        Value.Bool true
                                                      |) in
                                                    M.alloc (|
                                                      M.never_to_any (|
                                                        M.read (|
                                                          let~ kind :
                                                              Ty.apply
                                                                (Ty.path "*")
                                                                []
                                                                [
                                                                  Ty.path
                                                                    "core::panicking::AssertKind"
                                                                ] :=
                                                            M.alloc (|
                                                              Value.StructTuple
                                                                "core::panicking::AssertKind::Eq"
                                                                []
                                                            |) in
                                                          M.alloc (|
                                                            M.call_closure (|
                                                              Ty.path "never",
                                                              M.get_function (|
                                                                "core::panicking::assert_failed",
                                                                [],
                                                                [ Ty.path "usize"; Ty.path "usize" ]
                                                              |),
                                                              [
                                                                M.read (| kind |);
                                                                M.borrow (|
                                                                  Pointer.Kind.Ref,
                                                                  M.deref (|
                                                                    M.borrow (|
                                                                      Pointer.Kind.Ref,
                                                                      M.deref (|
                                                                        M.read (| left_val |)
                                                                      |)
                                                                    |)
                                                                  |)
                                                                |);
                                                                M.borrow (|
                                                                  Pointer.Kind.Ref,
                                                                  M.deref (|
                                                                    M.borrow (|
                                                                      Pointer.Kind.Ref,
                                                                      M.deref (|
                                                                        M.read (| right_val |)
                                                                      |)
                                                                    |)
                                                                  |)
                                                                |);
                                                                Value.StructTuple
                                                                  "core::option::Option::Some"
                                                                  [
                                                                    M.call_closure (|
                                                                      Ty.path
                                                                        "core::fmt::Arguments",
                                                                      M.get_associated_function (|
                                                                        Ty.path
                                                                          "core::fmt::Arguments",
                                                                        "new_const",
                                                                        [
                                                                          Value.Integer
                                                                            IntegerKind.Usize
                                                                            1
                                                                        ],
                                                                        []
                                                                      |),
                                                                      [
                                                                        M.borrow (|
                                                                          Pointer.Kind.Ref,
                                                                          M.deref (|
                                                                            M.borrow (|
                                                                              Pointer.Kind.Ref,
                                                                              M.alloc (|
                                                                                Value.Array
                                                                                  [
                                                                                    mk_str (|
                                                                                      "No prior strong references should exist"
                                                                                    |)
                                                                                  ]
                                                                              |)
                                                                            |)
                                                                          |)
                                                                        |)
                                                                      ]
                                                                    |)
                                                                  ]
                                                              ]
                                                            |)
                                                          |)
                                                        |)
                                                      |)
                                                    |)));
                                                fun γ =>
                                                  ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                                              ]
                                            |)))
                                      ]
                                    |) in
                                  M.alloc (| Value.Tuple [] |)));
                              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                            ]
                          |) in
                        let~ alloc : Ty.apply (Ty.path "*") [] [ A ] :=
                          M.copy (|
                            M.SubPointer.get_tuple_field (|
                              M.alloc (|
                                M.call_closure (|
                                  Ty.tuple [ Ty.apply (Ty.path "*const") [] [ T ]; A ],
                                  M.get_associated_function (|
                                    Ty.apply (Ty.path "alloc::sync::Weak") [] [ T; A ],
                                    "into_raw_with_allocator",
                                    [],
                                    []
                                  |),
                                  [ M.read (| weak |) ]
                                |)
                              |),
                              1
                            |)
                          |) in
                        M.alloc (|
                          M.call_closure (|
                            Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; A ],
                            M.get_associated_function (|
                              Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; A ],
                              "from_inner_in",
                              [],
                              []
                            |),
                            [ M.read (| init_ptr |); M.read (| alloc |) ]
                          |)
                        |)
                      |) in
                    strong))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_new_cyclic_in :
      forall (T A : Ty.t),
      M.IsAssociatedFunction.C (Self T A) "new_cyclic_in" (new_cyclic_in T A).
    Admitted.
    Global Typeclasses Opaque new_cyclic_in.
    
    (*
        pub fn pin_in(data: T, alloc: A) -> Pin<Arc<T, A>>
        where
            A: 'static,
        {
            unsafe { Pin::new_unchecked(Arc::new_in(data, alloc)) }
        }
    *)
    Definition pin_in (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ data; alloc ] =>
        ltac:(M.monadic
          (let data := M.alloc (| data |) in
          let alloc := M.alloc (| alloc |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "core::pin::Pin")
              []
              [ Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; A ] ],
            M.get_associated_function (|
              Ty.apply
                (Ty.path "core::pin::Pin")
                []
                [ Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; A ] ],
              "new_unchecked",
              [],
              []
            |),
            [
              M.call_closure (|
                Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; A ],
                M.get_associated_function (|
                  Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; A ],
                  "new_in",
                  [],
                  []
                |),
                [ M.read (| data |); M.read (| alloc |) ]
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_pin_in :
      forall (T A : Ty.t),
      M.IsAssociatedFunction.C (Self T A) "pin_in" (pin_in T A).
    Admitted.
    Global Typeclasses Opaque pin_in.
    
    (*
        pub fn try_pin_in(data: T, alloc: A) -> Result<Pin<Arc<T, A>>, AllocError>
        where
            A: 'static,
        {
            unsafe { Ok(Pin::new_unchecked(Arc::try_new_in(data, alloc)?)) }
        }
    *)
    Definition try_pin_in (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ data; alloc ] =>
        ltac:(M.monadic
          (let data := M.alloc (| data |) in
          let alloc := M.alloc (| alloc |) in
          M.catch_return
            (Ty.apply
              (Ty.path "core::result::Result")
              []
              [
                Ty.apply
                  (Ty.path "core::pin::Pin")
                  []
                  [ Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; A ] ];
                Ty.path "core::alloc::AllocError"
              ]) (|
            ltac:(M.monadic
              (Value.StructTuple
                "core::result::Result::Ok"
                [
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "core::pin::Pin")
                      []
                      [ Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; A ] ],
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "core::pin::Pin")
                        []
                        [ Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; A ] ],
                      "new_unchecked",
                      [],
                      []
                    |),
                    [
                      M.read (|
                        M.match_operator (|
                          Ty.apply
                            (Ty.path "*")
                            []
                            [ Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; A ] ],
                          M.alloc (|
                            M.call_closure (|
                              Ty.apply
                                (Ty.path "core::ops::control_flow::ControlFlow")
                                []
                                [
                                  Ty.apply
                                    (Ty.path "core::result::Result")
                                    []
                                    [
                                      Ty.path "core::convert::Infallible";
                                      Ty.path "core::alloc::AllocError"
                                    ];
                                  Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; A ]
                                ],
                              M.get_trait_method (|
                                "core::ops::try_trait::Try",
                                Ty.apply
                                  (Ty.path "core::result::Result")
                                  []
                                  [
                                    Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; A ];
                                    Ty.path "core::alloc::AllocError"
                                  ],
                                [],
                                [],
                                "branch",
                                [],
                                []
                              |),
                              [
                                M.call_closure (|
                                  Ty.apply
                                    (Ty.path "core::result::Result")
                                    []
                                    [
                                      Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; A ];
                                      Ty.path "core::alloc::AllocError"
                                    ],
                                  M.get_associated_function (|
                                    Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; A ],
                                    "try_new_in",
                                    [],
                                    []
                                  |),
                                  [ M.read (| data |); M.read (| alloc |) ]
                                |)
                              ]
                            |)
                          |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ0_0 :=
                                  M.SubPointer.get_struct_tuple_field (|
                                    γ,
                                    "core::ops::control_flow::ControlFlow::Break",
                                    0
                                  |) in
                                let residual := M.copy (| γ0_0 |) in
                                M.alloc (|
                                  M.never_to_any (|
                                    M.read (|
                                      M.return_ (|
                                        M.call_closure (|
                                          Ty.apply
                                            (Ty.path "core::result::Result")
                                            []
                                            [
                                              Ty.apply
                                                (Ty.path "core::pin::Pin")
                                                []
                                                [ Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; A ]
                                                ];
                                              Ty.path "core::alloc::AllocError"
                                            ],
                                          M.get_trait_method (|
                                            "core::ops::try_trait::FromResidual",
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "core::pin::Pin")
                                                  []
                                                  [
                                                    Ty.apply
                                                      (Ty.path "alloc::sync::Arc")
                                                      []
                                                      [ T; A ]
                                                  ];
                                                Ty.path "core::alloc::AllocError"
                                              ],
                                            [],
                                            [
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                []
                                                [
                                                  Ty.path "core::convert::Infallible";
                                                  Ty.path "core::alloc::AllocError"
                                                ]
                                            ],
                                            "from_residual",
                                            [],
                                            []
                                          |),
                                          [ M.read (| residual |) ]
                                        |)
                                      |)
                                    |)
                                  |)
                                |)));
                            fun γ =>
                              ltac:(M.monadic
                                (let γ0_0 :=
                                  M.SubPointer.get_struct_tuple_field (|
                                    γ,
                                    "core::ops::control_flow::ControlFlow::Continue",
                                    0
                                  |) in
                                let val := M.copy (| γ0_0 |) in
                                val))
                          ]
                        |)
                      |)
                    ]
                  |)
                ]))
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_try_pin_in :
      forall (T A : Ty.t),
      M.IsAssociatedFunction.C (Self T A) "try_pin_in" (try_pin_in T A).
    Admitted.
    Global Typeclasses Opaque try_pin_in.
    
    (*
        pub fn try_new_in(data: T, alloc: A) -> Result<Arc<T, A>, AllocError> {
            // Start the weak pointer count as 1 which is the weak pointer that's
            // held by all the strong pointers (kinda), see std/rc.rs for more info
            let x = Box::try_new_in(
                ArcInner {
                    strong: atomic::AtomicUsize::new(1),
                    weak: atomic::AtomicUsize::new(1),
                    data,
                },
                alloc,
            )?;
            let (ptr, alloc) = Box::into_unique(x);
            Ok(unsafe { Self::from_inner_in(ptr.into(), alloc) })
        }
    *)
    Definition try_new_in (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ data; alloc ] =>
        ltac:(M.monadic
          (let data := M.alloc (| data |) in
          let alloc := M.alloc (| alloc |) in
          M.catch_return
            (Ty.apply
              (Ty.path "core::result::Result")
              []
              [ Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; A ]; Ty.path "core::alloc::AllocError"
              ]) (|
            ltac:(M.monadic
              (M.read (|
                let~ x :
                    Ty.apply
                      (Ty.path "*")
                      []
                      [
                        Ty.apply
                          (Ty.path "alloc::boxed::Box")
                          []
                          [ Ty.apply (Ty.path "alloc::sync::ArcInner") [] [ T ]; A ]
                      ] :=
                  M.copy (|
                    M.match_operator (|
                      Ty.apply
                        (Ty.path "*")
                        []
                        [
                          Ty.apply
                            (Ty.path "alloc::boxed::Box")
                            []
                            [ Ty.apply (Ty.path "alloc::sync::ArcInner") [] [ T ]; A ]
                        ],
                      M.alloc (|
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "core::ops::control_flow::ControlFlow")
                            []
                            [
                              Ty.apply
                                (Ty.path "core::result::Result")
                                []
                                [
                                  Ty.path "core::convert::Infallible";
                                  Ty.path "core::alloc::AllocError"
                                ];
                              Ty.apply
                                (Ty.path "alloc::boxed::Box")
                                []
                                [ Ty.apply (Ty.path "alloc::sync::ArcInner") [] [ T ]; A ]
                            ],
                          M.get_trait_method (|
                            "core::ops::try_trait::Try",
                            Ty.apply
                              (Ty.path "core::result::Result")
                              []
                              [
                                Ty.apply
                                  (Ty.path "alloc::boxed::Box")
                                  []
                                  [ Ty.apply (Ty.path "alloc::sync::ArcInner") [] [ T ]; A ];
                                Ty.path "core::alloc::AllocError"
                              ],
                            [],
                            [],
                            "branch",
                            [],
                            []
                          |),
                          [
                            M.call_closure (|
                              Ty.apply
                                (Ty.path "core::result::Result")
                                []
                                [
                                  Ty.apply
                                    (Ty.path "alloc::boxed::Box")
                                    []
                                    [ Ty.apply (Ty.path "alloc::sync::ArcInner") [] [ T ]; A ];
                                  Ty.path "core::alloc::AllocError"
                                ],
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "alloc::boxed::Box")
                                  []
                                  [ Ty.apply (Ty.path "alloc::sync::ArcInner") [] [ T ]; A ],
                                "try_new_in",
                                [],
                                []
                              |),
                              [
                                Value.StructRecord
                                  "alloc::sync::ArcInner"
                                  [
                                    ("strong",
                                      M.call_closure (|
                                        Ty.path "core::sync::atomic::AtomicUsize",
                                        M.get_associated_function (|
                                          Ty.path "core::sync::atomic::AtomicUsize",
                                          "new",
                                          [],
                                          []
                                        |),
                                        [ Value.Integer IntegerKind.Usize 1 ]
                                      |));
                                    ("weak",
                                      M.call_closure (|
                                        Ty.path "core::sync::atomic::AtomicUsize",
                                        M.get_associated_function (|
                                          Ty.path "core::sync::atomic::AtomicUsize",
                                          "new",
                                          [],
                                          []
                                        |),
                                        [ Value.Integer IntegerKind.Usize 1 ]
                                      |));
                                    ("data", M.read (| data |))
                                  ];
                                M.read (| alloc |)
                              ]
                            |)
                          ]
                        |)
                      |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "core::ops::control_flow::ControlFlow::Break",
                                0
                              |) in
                            let residual := M.copy (| γ0_0 |) in
                            M.alloc (|
                              M.never_to_any (|
                                M.read (|
                                  M.return_ (|
                                    M.call_closure (|
                                      Ty.apply
                                        (Ty.path "core::result::Result")
                                        []
                                        [
                                          Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; A ];
                                          Ty.path "core::alloc::AllocError"
                                        ],
                                      M.get_trait_method (|
                                        "core::ops::try_trait::FromResidual",
                                        Ty.apply
                                          (Ty.path "core::result::Result")
                                          []
                                          [
                                            Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; A ];
                                            Ty.path "core::alloc::AllocError"
                                          ],
                                        [],
                                        [
                                          Ty.apply
                                            (Ty.path "core::result::Result")
                                            []
                                            [
                                              Ty.path "core::convert::Infallible";
                                              Ty.path "core::alloc::AllocError"
                                            ]
                                        ],
                                        "from_residual",
                                        [],
                                        []
                                      |),
                                      [ M.read (| residual |) ]
                                    |)
                                  |)
                                |)
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "core::ops::control_flow::ControlFlow::Continue",
                                0
                              |) in
                            let val := M.copy (| γ0_0 |) in
                            val))
                      ]
                    |)
                  |) in
                M.match_operator (|
                  Ty.apply
                    (Ty.path "*")
                    []
                    [
                      Ty.apply
                        (Ty.path "core::result::Result")
                        []
                        [
                          Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; A ];
                          Ty.path "core::alloc::AllocError"
                        ]
                    ],
                  M.alloc (|
                    M.call_closure (|
                      Ty.tuple
                        [
                          Ty.apply
                            (Ty.path "core::ptr::unique::Unique")
                            []
                            [ Ty.apply (Ty.path "alloc::sync::ArcInner") [] [ T ] ];
                          A
                        ],
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "alloc::boxed::Box")
                          []
                          [ Ty.apply (Ty.path "alloc::sync::ArcInner") [] [ T ]; A ],
                        "into_unique",
                        [],
                        []
                      |),
                      [ M.read (| x |) ]
                    |)
                  |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                        let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                        let ptr := M.copy (| γ0_0 |) in
                        let alloc := M.copy (| γ0_1 |) in
                        M.alloc (|
                          Value.StructTuple
                            "core::result::Result::Ok"
                            [
                              M.call_closure (|
                                Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; A ],
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; A ],
                                  "from_inner_in",
                                  [],
                                  []
                                |),
                                [
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "core::ptr::non_null::NonNull")
                                      []
                                      [ Ty.apply (Ty.path "alloc::sync::ArcInner") [] [ T ] ],
                                    M.get_trait_method (|
                                      "core::convert::Into",
                                      Ty.apply
                                        (Ty.path "core::ptr::unique::Unique")
                                        []
                                        [ Ty.apply (Ty.path "alloc::sync::ArcInner") [] [ T ] ],
                                      [],
                                      [
                                        Ty.apply
                                          (Ty.path "core::ptr::non_null::NonNull")
                                          []
                                          [ Ty.apply (Ty.path "alloc::sync::ArcInner") [] [ T ] ]
                                      ],
                                      "into",
                                      [],
                                      []
                                    |),
                                    [ M.read (| ptr |) ]
                                  |);
                                  M.read (| alloc |)
                                ]
                              |)
                            ]
                        |)))
                  ]
                |)
              |)))
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_try_new_in :
      forall (T A : Ty.t),
      M.IsAssociatedFunction.C (Self T A) "try_new_in" (try_new_in T A).
    Admitted.
    Global Typeclasses Opaque try_new_in.
    
    (*
        pub fn try_new_uninit_in(alloc: A) -> Result<Arc<mem::MaybeUninit<T>, A>, AllocError> {
            unsafe {
                Ok(Arc::from_ptr_in(
                    Arc::try_allocate_for_layout(
                        Layout::new::<T>(),
                        |layout| alloc.allocate(layout),
                        <*mut u8>::cast,
                    )?,
                    alloc,
                ))
            }
        }
    *)
    Definition try_new_uninit_in
        (T A : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ alloc ] =>
        ltac:(M.monadic
          (let alloc := M.alloc (| alloc |) in
          M.catch_return
            (Ty.apply
              (Ty.path "core::result::Result")
              []
              [
                Ty.apply
                  (Ty.path "alloc::sync::Arc")
                  []
                  [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ]; A ];
                Ty.path "core::alloc::AllocError"
              ]) (|
            ltac:(M.monadic
              (Value.StructTuple
                "core::result::Result::Ok"
                [
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "alloc::sync::Arc")
                      []
                      [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ]; A ],
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "alloc::sync::Arc")
                        []
                        [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ]; A ],
                      "from_ptr_in",
                      [],
                      []
                    |),
                    [
                      M.read (|
                        M.match_operator (|
                          Ty.apply
                            (Ty.path "*")
                            []
                            [
                              Ty.apply
                                (Ty.path "*mut")
                                []
                                [
                                  Ty.apply
                                    (Ty.path "alloc::sync::ArcInner")
                                    []
                                    [
                                      Ty.apply
                                        (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                        []
                                        [ T ]
                                    ]
                                ]
                            ],
                          M.alloc (|
                            M.call_closure (|
                              Ty.apply
                                (Ty.path "core::ops::control_flow::ControlFlow")
                                []
                                [
                                  Ty.apply
                                    (Ty.path "core::result::Result")
                                    []
                                    [
                                      Ty.path "core::convert::Infallible";
                                      Ty.path "core::alloc::AllocError"
                                    ];
                                  Ty.apply
                                    (Ty.path "*mut")
                                    []
                                    [
                                      Ty.apply
                                        (Ty.path "alloc::sync::ArcInner")
                                        []
                                        [
                                          Ty.apply
                                            (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                            []
                                            [ T ]
                                        ]
                                    ]
                                ],
                              M.get_trait_method (|
                                "core::ops::try_trait::Try",
                                Ty.apply
                                  (Ty.path "core::result::Result")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "*mut")
                                      []
                                      [
                                        Ty.apply
                                          (Ty.path "alloc::sync::ArcInner")
                                          []
                                          [
                                            Ty.apply
                                              (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                              []
                                              [ T ]
                                          ]
                                      ];
                                    Ty.path "core::alloc::AllocError"
                                  ],
                                [],
                                [],
                                "branch",
                                [],
                                []
                              |),
                              [
                                M.call_closure (|
                                  Ty.apply
                                    (Ty.path "core::result::Result")
                                    []
                                    [
                                      Ty.apply
                                        (Ty.path "*mut")
                                        []
                                        [
                                          Ty.apply
                                            (Ty.path "alloc::sync::ArcInner")
                                            []
                                            [
                                              Ty.apply
                                                (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                                []
                                                [ T ]
                                            ]
                                        ];
                                      Ty.path "core::alloc::AllocError"
                                    ],
                                  M.get_associated_function (|
                                    Ty.apply
                                      (Ty.path "alloc::sync::Arc")
                                      []
                                      [
                                        Ty.apply
                                          (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                          []
                                          [ T ];
                                        Ty.path "alloc::alloc::Global"
                                      ],
                                    "try_allocate_for_layout",
                                    [],
                                    [
                                      Ty.function
                                        [ Ty.tuple [ Ty.path "core::alloc::layout::Layout" ] ]
                                        (Ty.apply
                                          (Ty.path "core::result::Result")
                                          []
                                          [
                                            Ty.apply
                                              (Ty.path "core::ptr::non_null::NonNull")
                                              []
                                              [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ];
                                            Ty.path "core::alloc::AllocError"
                                          ]);
                                      Ty.function
                                        [ Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ] ]
                                        (Ty.apply
                                          (Ty.path "*mut")
                                          []
                                          [
                                            Ty.apply
                                              (Ty.path "alloc::sync::ArcInner")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                                  []
                                                  [ T ]
                                              ]
                                          ])
                                    ]
                                  |),
                                  [
                                    M.call_closure (|
                                      Ty.path "core::alloc::layout::Layout",
                                      M.get_associated_function (|
                                        Ty.path "core::alloc::layout::Layout",
                                        "new",
                                        [],
                                        [ T ]
                                      |),
                                      []
                                    |);
                                    M.closure
                                      (fun γ =>
                                        ltac:(M.monadic
                                          match γ with
                                          | [ α0 ] =>
                                            ltac:(M.monadic
                                              (M.match_operator (|
                                                Ty.apply
                                                  (Ty.path "*")
                                                  []
                                                  [
                                                    Ty.function
                                                      [
                                                        Ty.tuple
                                                          [ Ty.path "core::alloc::layout::Layout" ]
                                                      ]
                                                      (Ty.apply
                                                        (Ty.path "core::result::Result")
                                                        []
                                                        [
                                                          Ty.apply
                                                            (Ty.path "core::ptr::non_null::NonNull")
                                                            []
                                                            [
                                                              Ty.apply
                                                                (Ty.path "slice")
                                                                []
                                                                [ Ty.path "u8" ]
                                                            ];
                                                          Ty.path "core::alloc::AllocError"
                                                        ])
                                                  ],
                                                M.alloc (| α0 |),
                                                [
                                                  fun γ =>
                                                    ltac:(M.monadic
                                                      (let layout := M.copy (| γ |) in
                                                      M.call_closure (|
                                                        Ty.apply
                                                          (Ty.path "core::result::Result")
                                                          []
                                                          [
                                                            Ty.apply
                                                              (Ty.path
                                                                "core::ptr::non_null::NonNull")
                                                              []
                                                              [
                                                                Ty.apply
                                                                  (Ty.path "slice")
                                                                  []
                                                                  [ Ty.path "u8" ]
                                                              ];
                                                            Ty.path "core::alloc::AllocError"
                                                          ],
                                                        M.get_trait_method (|
                                                          "core::alloc::Allocator",
                                                          A,
                                                          [],
                                                          [],
                                                          "allocate",
                                                          [],
                                                          []
                                                        |),
                                                        [
                                                          M.borrow (| Pointer.Kind.Ref, alloc |);
                                                          M.read (| layout |)
                                                        ]
                                                      |)))
                                                ]
                                              |)))
                                          | _ => M.impossible "wrong number of arguments"
                                          end));
                                    M.get_associated_function (|
                                      Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ],
                                      "cast",
                                      [],
                                      [
                                        Ty.apply
                                          (Ty.path "alloc::sync::ArcInner")
                                          []
                                          [
                                            Ty.apply
                                              (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                              []
                                              [ T ]
                                          ]
                                      ]
                                    |)
                                  ]
                                |)
                              ]
                            |)
                          |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ0_0 :=
                                  M.SubPointer.get_struct_tuple_field (|
                                    γ,
                                    "core::ops::control_flow::ControlFlow::Break",
                                    0
                                  |) in
                                let residual := M.copy (| γ0_0 |) in
                                M.alloc (|
                                  M.never_to_any (|
                                    M.read (|
                                      M.return_ (|
                                        M.call_closure (|
                                          Ty.apply
                                            (Ty.path "core::result::Result")
                                            []
                                            [
                                              Ty.apply
                                                (Ty.path "alloc::sync::Arc")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                                    []
                                                    [ T ];
                                                  A
                                                ];
                                              Ty.path "core::alloc::AllocError"
                                            ],
                                          M.get_trait_method (|
                                            "core::ops::try_trait::FromResidual",
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "alloc::sync::Arc")
                                                  []
                                                  [
                                                    Ty.apply
                                                      (Ty.path
                                                        "core::mem::maybe_uninit::MaybeUninit")
                                                      []
                                                      [ T ];
                                                    A
                                                  ];
                                                Ty.path "core::alloc::AllocError"
                                              ],
                                            [],
                                            [
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                []
                                                [
                                                  Ty.path "core::convert::Infallible";
                                                  Ty.path "core::alloc::AllocError"
                                                ]
                                            ],
                                            "from_residual",
                                            [],
                                            []
                                          |),
                                          [ M.read (| residual |) ]
                                        |)
                                      |)
                                    |)
                                  |)
                                |)));
                            fun γ =>
                              ltac:(M.monadic
                                (let γ0_0 :=
                                  M.SubPointer.get_struct_tuple_field (|
                                    γ,
                                    "core::ops::control_flow::ControlFlow::Continue",
                                    0
                                  |) in
                                let val := M.copy (| γ0_0 |) in
                                val))
                          ]
                        |)
                      |);
                      M.read (| alloc |)
                    ]
                  |)
                ]))
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_try_new_uninit_in :
      forall (T A : Ty.t),
      M.IsAssociatedFunction.C (Self T A) "try_new_uninit_in" (try_new_uninit_in T A).
    Admitted.
    Global Typeclasses Opaque try_new_uninit_in.
    
    (*
        pub fn try_new_zeroed_in(alloc: A) -> Result<Arc<mem::MaybeUninit<T>, A>, AllocError> {
            unsafe {
                Ok(Arc::from_ptr_in(
                    Arc::try_allocate_for_layout(
                        Layout::new::<T>(),
                        |layout| alloc.allocate_zeroed(layout),
                        <*mut u8>::cast,
                    )?,
                    alloc,
                ))
            }
        }
    *)
    Definition try_new_zeroed_in
        (T A : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ alloc ] =>
        ltac:(M.monadic
          (let alloc := M.alloc (| alloc |) in
          M.catch_return
            (Ty.apply
              (Ty.path "core::result::Result")
              []
              [
                Ty.apply
                  (Ty.path "alloc::sync::Arc")
                  []
                  [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ]; A ];
                Ty.path "core::alloc::AllocError"
              ]) (|
            ltac:(M.monadic
              (Value.StructTuple
                "core::result::Result::Ok"
                [
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "alloc::sync::Arc")
                      []
                      [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ]; A ],
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "alloc::sync::Arc")
                        []
                        [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ]; A ],
                      "from_ptr_in",
                      [],
                      []
                    |),
                    [
                      M.read (|
                        M.match_operator (|
                          Ty.apply
                            (Ty.path "*")
                            []
                            [
                              Ty.apply
                                (Ty.path "*mut")
                                []
                                [
                                  Ty.apply
                                    (Ty.path "alloc::sync::ArcInner")
                                    []
                                    [
                                      Ty.apply
                                        (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                        []
                                        [ T ]
                                    ]
                                ]
                            ],
                          M.alloc (|
                            M.call_closure (|
                              Ty.apply
                                (Ty.path "core::ops::control_flow::ControlFlow")
                                []
                                [
                                  Ty.apply
                                    (Ty.path "core::result::Result")
                                    []
                                    [
                                      Ty.path "core::convert::Infallible";
                                      Ty.path "core::alloc::AllocError"
                                    ];
                                  Ty.apply
                                    (Ty.path "*mut")
                                    []
                                    [
                                      Ty.apply
                                        (Ty.path "alloc::sync::ArcInner")
                                        []
                                        [
                                          Ty.apply
                                            (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                            []
                                            [ T ]
                                        ]
                                    ]
                                ],
                              M.get_trait_method (|
                                "core::ops::try_trait::Try",
                                Ty.apply
                                  (Ty.path "core::result::Result")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "*mut")
                                      []
                                      [
                                        Ty.apply
                                          (Ty.path "alloc::sync::ArcInner")
                                          []
                                          [
                                            Ty.apply
                                              (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                              []
                                              [ T ]
                                          ]
                                      ];
                                    Ty.path "core::alloc::AllocError"
                                  ],
                                [],
                                [],
                                "branch",
                                [],
                                []
                              |),
                              [
                                M.call_closure (|
                                  Ty.apply
                                    (Ty.path "core::result::Result")
                                    []
                                    [
                                      Ty.apply
                                        (Ty.path "*mut")
                                        []
                                        [
                                          Ty.apply
                                            (Ty.path "alloc::sync::ArcInner")
                                            []
                                            [
                                              Ty.apply
                                                (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                                []
                                                [ T ]
                                            ]
                                        ];
                                      Ty.path "core::alloc::AllocError"
                                    ],
                                  M.get_associated_function (|
                                    Ty.apply
                                      (Ty.path "alloc::sync::Arc")
                                      []
                                      [
                                        Ty.apply
                                          (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                          []
                                          [ T ];
                                        Ty.path "alloc::alloc::Global"
                                      ],
                                    "try_allocate_for_layout",
                                    [],
                                    [
                                      Ty.function
                                        [ Ty.tuple [ Ty.path "core::alloc::layout::Layout" ] ]
                                        (Ty.apply
                                          (Ty.path "core::result::Result")
                                          []
                                          [
                                            Ty.apply
                                              (Ty.path "core::ptr::non_null::NonNull")
                                              []
                                              [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ];
                                            Ty.path "core::alloc::AllocError"
                                          ]);
                                      Ty.function
                                        [ Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ] ]
                                        (Ty.apply
                                          (Ty.path "*mut")
                                          []
                                          [
                                            Ty.apply
                                              (Ty.path "alloc::sync::ArcInner")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                                  []
                                                  [ T ]
                                              ]
                                          ])
                                    ]
                                  |),
                                  [
                                    M.call_closure (|
                                      Ty.path "core::alloc::layout::Layout",
                                      M.get_associated_function (|
                                        Ty.path "core::alloc::layout::Layout",
                                        "new",
                                        [],
                                        [ T ]
                                      |),
                                      []
                                    |);
                                    M.closure
                                      (fun γ =>
                                        ltac:(M.monadic
                                          match γ with
                                          | [ α0 ] =>
                                            ltac:(M.monadic
                                              (M.match_operator (|
                                                Ty.apply
                                                  (Ty.path "*")
                                                  []
                                                  [
                                                    Ty.function
                                                      [
                                                        Ty.tuple
                                                          [ Ty.path "core::alloc::layout::Layout" ]
                                                      ]
                                                      (Ty.apply
                                                        (Ty.path "core::result::Result")
                                                        []
                                                        [
                                                          Ty.apply
                                                            (Ty.path "core::ptr::non_null::NonNull")
                                                            []
                                                            [
                                                              Ty.apply
                                                                (Ty.path "slice")
                                                                []
                                                                [ Ty.path "u8" ]
                                                            ];
                                                          Ty.path "core::alloc::AllocError"
                                                        ])
                                                  ],
                                                M.alloc (| α0 |),
                                                [
                                                  fun γ =>
                                                    ltac:(M.monadic
                                                      (let layout := M.copy (| γ |) in
                                                      M.call_closure (|
                                                        Ty.apply
                                                          (Ty.path "core::result::Result")
                                                          []
                                                          [
                                                            Ty.apply
                                                              (Ty.path
                                                                "core::ptr::non_null::NonNull")
                                                              []
                                                              [
                                                                Ty.apply
                                                                  (Ty.path "slice")
                                                                  []
                                                                  [ Ty.path "u8" ]
                                                              ];
                                                            Ty.path "core::alloc::AllocError"
                                                          ],
                                                        M.get_trait_method (|
                                                          "core::alloc::Allocator",
                                                          A,
                                                          [],
                                                          [],
                                                          "allocate_zeroed",
                                                          [],
                                                          []
                                                        |),
                                                        [
                                                          M.borrow (| Pointer.Kind.Ref, alloc |);
                                                          M.read (| layout |)
                                                        ]
                                                      |)))
                                                ]
                                              |)))
                                          | _ => M.impossible "wrong number of arguments"
                                          end));
                                    M.get_associated_function (|
                                      Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ],
                                      "cast",
                                      [],
                                      [
                                        Ty.apply
                                          (Ty.path "alloc::sync::ArcInner")
                                          []
                                          [
                                            Ty.apply
                                              (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                              []
                                              [ T ]
                                          ]
                                      ]
                                    |)
                                  ]
                                |)
                              ]
                            |)
                          |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ0_0 :=
                                  M.SubPointer.get_struct_tuple_field (|
                                    γ,
                                    "core::ops::control_flow::ControlFlow::Break",
                                    0
                                  |) in
                                let residual := M.copy (| γ0_0 |) in
                                M.alloc (|
                                  M.never_to_any (|
                                    M.read (|
                                      M.return_ (|
                                        M.call_closure (|
                                          Ty.apply
                                            (Ty.path "core::result::Result")
                                            []
                                            [
                                              Ty.apply
                                                (Ty.path "alloc::sync::Arc")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                                    []
                                                    [ T ];
                                                  A
                                                ];
                                              Ty.path "core::alloc::AllocError"
                                            ],
                                          M.get_trait_method (|
                                            "core::ops::try_trait::FromResidual",
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "alloc::sync::Arc")
                                                  []
                                                  [
                                                    Ty.apply
                                                      (Ty.path
                                                        "core::mem::maybe_uninit::MaybeUninit")
                                                      []
                                                      [ T ];
                                                    A
                                                  ];
                                                Ty.path "core::alloc::AllocError"
                                              ],
                                            [],
                                            [
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                []
                                                [
                                                  Ty.path "core::convert::Infallible";
                                                  Ty.path "core::alloc::AllocError"
                                                ]
                                            ],
                                            "from_residual",
                                            [],
                                            []
                                          |),
                                          [ M.read (| residual |) ]
                                        |)
                                      |)
                                    |)
                                  |)
                                |)));
                            fun γ =>
                              ltac:(M.monadic
                                (let γ0_0 :=
                                  M.SubPointer.get_struct_tuple_field (|
                                    γ,
                                    "core::ops::control_flow::ControlFlow::Continue",
                                    0
                                  |) in
                                let val := M.copy (| γ0_0 |) in
                                val))
                          ]
                        |)
                      |);
                      M.read (| alloc |)
                    ]
                  |)
                ]))
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_try_new_zeroed_in :
      forall (T A : Ty.t),
      M.IsAssociatedFunction.C (Self T A) "try_new_zeroed_in" (try_new_zeroed_in T A).
    Admitted.
    Global Typeclasses Opaque try_new_zeroed_in.
    
    (*
        pub fn try_unwrap(this: Self) -> Result<T, Self> {
            if this.inner().strong.compare_exchange(1, 0, Relaxed, Relaxed).is_err() {
                return Err(this);
            }
    
            acquire!(this.inner().strong);
    
            let this = ManuallyDrop::new(this);
            let elem: T = unsafe { ptr::read(&this.ptr.as_ref().data) };
            let alloc: A = unsafe { ptr::read(&this.alloc) }; // copy the allocator
    
            // Make a weak pointer to clean up the implicit strong-weak reference
            let _weak = Weak { ptr: this.ptr, alloc };
    
            Ok(elem)
        }
    *)
    Definition try_unwrap (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ this ] =>
        ltac:(M.monadic
          (let this := M.alloc (| this |) in
          M.catch_return
            (Ty.apply
              (Ty.path "core::result::Result")
              []
              [ T; Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; A ] ]) (|
            ltac:(M.monadic
              (M.read (|
                let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                  M.match_operator (|
                    Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                M.call_closure (|
                                  Ty.path "bool",
                                  M.get_associated_function (|
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [ Ty.path "usize"; Ty.path "usize" ],
                                    "is_err",
                                    [],
                                    []
                                  |),
                                  [
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.alloc (|
                                        M.call_closure (|
                                          Ty.apply
                                            (Ty.path "core::result::Result")
                                            []
                                            [ Ty.path "usize"; Ty.path "usize" ],
                                          M.get_associated_function (|
                                            Ty.path "core::sync::atomic::AtomicUsize",
                                            "compare_exchange",
                                            [],
                                            []
                                          |),
                                          [
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.SubPointer.get_struct_record_field (|
                                                M.deref (|
                                                  M.call_closure (|
                                                    Ty.apply
                                                      (Ty.path "&")
                                                      []
                                                      [
                                                        Ty.apply
                                                          (Ty.path "alloc::sync::ArcInner")
                                                          []
                                                          [ T ]
                                                      ],
                                                    M.get_associated_function (|
                                                      Ty.apply
                                                        (Ty.path "alloc::sync::Arc")
                                                        []
                                                        [ T; A ],
                                                      "inner",
                                                      [],
                                                      []
                                                    |),
                                                    [ M.borrow (| Pointer.Kind.Ref, this |) ]
                                                  |)
                                                |),
                                                "alloc::sync::ArcInner",
                                                "strong"
                                              |)
                                            |);
                                            Value.Integer IntegerKind.Usize 1;
                                            Value.Integer IntegerKind.Usize 0;
                                            Value.StructTuple
                                              "core::sync::atomic::Ordering::Relaxed"
                                              [];
                                            Value.StructTuple
                                              "core::sync::atomic::Ordering::Relaxed"
                                              []
                                          ]
                                        |)
                                      |)
                                    |)
                                  ]
                                |)
                              |)) in
                          let _ :=
                            is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (|
                            M.never_to_any (|
                              M.read (|
                                M.return_ (|
                                  Value.StructTuple
                                    "core::result::Result::Err"
                                    [ M.read (| this |) ]
                                |)
                              |)
                            |)
                          |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                  M.alloc (|
                    M.call_closure (|
                      Ty.tuple [],
                      M.get_function (| "core::sync::atomic::fence", [], [] |),
                      [ Value.StructTuple "core::sync::atomic::Ordering::Acquire" [] ]
                    |)
                  |) in
                let~ this :
                    Ty.apply
                      (Ty.path "*")
                      []
                      [
                        Ty.apply
                          (Ty.path "core::mem::manually_drop::ManuallyDrop")
                          []
                          [ Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; A ] ]
                      ] :=
                  M.alloc (|
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "core::mem::manually_drop::ManuallyDrop")
                        []
                        [ Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; A ] ],
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "core::mem::manually_drop::ManuallyDrop")
                          []
                          [ Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; A ] ],
                        "new",
                        [],
                        []
                      |),
                      [ M.read (| this |) ]
                    |)
                  |) in
                let~ elem : Ty.apply (Ty.path "*") [] [ T ] :=
                  M.alloc (|
                    M.call_closure (|
                      T,
                      M.get_function (| "core::ptr::read", [], [ T ] |),
                      [
                        M.borrow (|
                          Pointer.Kind.ConstPointer,
                          M.deref (|
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.SubPointer.get_struct_record_field (|
                                M.deref (|
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "&")
                                      []
                                      [ Ty.apply (Ty.path "alloc::sync::ArcInner") [] [ T ] ],
                                    M.get_associated_function (|
                                      Ty.apply
                                        (Ty.path "core::ptr::non_null::NonNull")
                                        []
                                        [ Ty.apply (Ty.path "alloc::sync::ArcInner") [] [ T ] ],
                                      "as_ref",
                                      [],
                                      []
                                    |),
                                    [
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.SubPointer.get_struct_record_field (|
                                          M.deref (|
                                            M.call_closure (|
                                              Ty.apply
                                                (Ty.path "&")
                                                []
                                                [ Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; A ]
                                                ],
                                              M.get_trait_method (|
                                                "core::ops::deref::Deref",
                                                Ty.apply
                                                  (Ty.path "core::mem::manually_drop::ManuallyDrop")
                                                  []
                                                  [
                                                    Ty.apply
                                                      (Ty.path "alloc::sync::Arc")
                                                      []
                                                      [ T; A ]
                                                  ],
                                                [],
                                                [],
                                                "deref",
                                                [],
                                                []
                                              |),
                                              [ M.borrow (| Pointer.Kind.Ref, this |) ]
                                            |)
                                          |),
                                          "alloc::sync::Arc",
                                          "ptr"
                                        |)
                                      |)
                                    ]
                                  |)
                                |),
                                "alloc::sync::ArcInner",
                                "data"
                              |)
                            |)
                          |)
                        |)
                      ]
                    |)
                  |) in
                let~ alloc : Ty.apply (Ty.path "*") [] [ A ] :=
                  M.alloc (|
                    M.call_closure (|
                      A,
                      M.get_function (| "core::ptr::read", [], [ A ] |),
                      [
                        M.borrow (|
                          Pointer.Kind.ConstPointer,
                          M.deref (|
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.SubPointer.get_struct_record_field (|
                                M.deref (|
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "&")
                                      []
                                      [ Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; A ] ],
                                    M.get_trait_method (|
                                      "core::ops::deref::Deref",
                                      Ty.apply
                                        (Ty.path "core::mem::manually_drop::ManuallyDrop")
                                        []
                                        [ Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; A ] ],
                                      [],
                                      [],
                                      "deref",
                                      [],
                                      []
                                    |),
                                    [ M.borrow (| Pointer.Kind.Ref, this |) ]
                                  |)
                                |),
                                "alloc::sync::Arc",
                                "alloc"
                              |)
                            |)
                          |)
                        |)
                      ]
                    |)
                  |) in
                let~ _weak :
                    Ty.apply
                      (Ty.path "*")
                      []
                      [ Ty.apply (Ty.path "alloc::sync::Weak") [] [ T; A ] ] :=
                  M.alloc (|
                    Value.StructRecord
                      "alloc::sync::Weak"
                      [
                        ("ptr",
                          M.read (|
                            M.SubPointer.get_struct_record_field (|
                              M.deref (|
                                M.call_closure (|
                                  Ty.apply
                                    (Ty.path "&")
                                    []
                                    [ Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; A ] ],
                                  M.get_trait_method (|
                                    "core::ops::deref::Deref",
                                    Ty.apply
                                      (Ty.path "core::mem::manually_drop::ManuallyDrop")
                                      []
                                      [ Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; A ] ],
                                    [],
                                    [],
                                    "deref",
                                    [],
                                    []
                                  |),
                                  [ M.borrow (| Pointer.Kind.Ref, this |) ]
                                |)
                              |),
                              "alloc::sync::Arc",
                              "ptr"
                            |)
                          |));
                        ("alloc", M.read (| alloc |))
                      ]
                  |) in
                M.alloc (| Value.StructTuple "core::result::Result::Ok" [ M.read (| elem |) ] |)
              |)))
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_try_unwrap :
      forall (T A : Ty.t),
      M.IsAssociatedFunction.C (Self T A) "try_unwrap" (try_unwrap T A).
    Admitted.
    Global Typeclasses Opaque try_unwrap.
    
    (*
        pub fn into_inner(this: Self) -> Option<T> {
            // Make sure that the ordinary `Drop` implementation isn’t called as well
            let mut this = mem::ManuallyDrop::new(this);
    
            // Following the implementation of `drop` and `drop_slow`
            if this.inner().strong.fetch_sub(1, Release) != 1 {
                return None;
            }
    
            acquire!(this.inner().strong);
    
            // SAFETY: This mirrors the line
            //
            //     unsafe { ptr::drop_in_place(Self::get_mut_unchecked(self)) };
            //
            // in `drop_slow`. Instead of dropping the value behind the pointer,
            // it is read and eventually returned; `ptr::read` has the same
            // safety conditions as `ptr::drop_in_place`.
    
            let inner = unsafe { ptr::read(Self::get_mut_unchecked(&mut this)) };
            let alloc = unsafe { ptr::read(&this.alloc) };
    
            drop(Weak { ptr: this.ptr, alloc });
    
            Some(inner)
        }
    *)
    Definition into_inner (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ this ] =>
        ltac:(M.monadic
          (let this := M.alloc (| this |) in
          M.catch_return (Ty.apply (Ty.path "core::option::Option") [] [ T ]) (|
            ltac:(M.monadic
              (M.read (|
                let~ this :
                    Ty.apply
                      (Ty.path "*")
                      []
                      [
                        Ty.apply
                          (Ty.path "core::mem::manually_drop::ManuallyDrop")
                          []
                          [ Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; A ] ]
                      ] :=
                  M.alloc (|
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "core::mem::manually_drop::ManuallyDrop")
                        []
                        [ Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; A ] ],
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "core::mem::manually_drop::ManuallyDrop")
                          []
                          [ Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; A ] ],
                        "new",
                        [],
                        []
                      |),
                      [ M.read (| this |) ]
                    |)
                  |) in
                let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                  M.match_operator (|
                    Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                M.call_closure (|
                                  Ty.path "bool",
                                  BinOp.ne,
                                  [
                                    M.call_closure (|
                                      Ty.path "usize",
                                      M.get_associated_function (|
                                        Ty.path "core::sync::atomic::AtomicUsize",
                                        "fetch_sub",
                                        [],
                                        []
                                      |),
                                      [
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.SubPointer.get_struct_record_field (|
                                            M.deref (|
                                              M.call_closure (|
                                                Ty.apply
                                                  (Ty.path "&")
                                                  []
                                                  [
                                                    Ty.apply
                                                      (Ty.path "alloc::sync::ArcInner")
                                                      []
                                                      [ T ]
                                                  ],
                                                M.get_associated_function (|
                                                  Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; A ],
                                                  "inner",
                                                  [],
                                                  []
                                                |),
                                                [
                                                  M.borrow (|
                                                    Pointer.Kind.Ref,
                                                    M.deref (|
                                                      M.call_closure (|
                                                        Ty.apply
                                                          (Ty.path "&")
                                                          []
                                                          [
                                                            Ty.apply
                                                              (Ty.path "alloc::sync::Arc")
                                                              []
                                                              [ T; A ]
                                                          ],
                                                        M.get_trait_method (|
                                                          "core::ops::deref::Deref",
                                                          Ty.apply
                                                            (Ty.path
                                                              "core::mem::manually_drop::ManuallyDrop")
                                                            []
                                                            [
                                                              Ty.apply
                                                                (Ty.path "alloc::sync::Arc")
                                                                []
                                                                [ T; A ]
                                                            ],
                                                          [],
                                                          [],
                                                          "deref",
                                                          [],
                                                          []
                                                        |),
                                                        [ M.borrow (| Pointer.Kind.Ref, this |) ]
                                                      |)
                                                    |)
                                                  |)
                                                ]
                                              |)
                                            |),
                                            "alloc::sync::ArcInner",
                                            "strong"
                                          |)
                                        |);
                                        Value.Integer IntegerKind.Usize 1;
                                        Value.StructTuple "core::sync::atomic::Ordering::Release" []
                                      ]
                                    |);
                                    Value.Integer IntegerKind.Usize 1
                                  ]
                                |)
                              |)) in
                          let _ :=
                            is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (|
                            M.never_to_any (|
                              M.read (|
                                M.return_ (| Value.StructTuple "core::option::Option::None" [] |)
                              |)
                            |)
                          |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                  M.alloc (|
                    M.call_closure (|
                      Ty.tuple [],
                      M.get_function (| "core::sync::atomic::fence", [], [] |),
                      [ Value.StructTuple "core::sync::atomic::Ordering::Acquire" [] ]
                    |)
                  |) in
                let~ inner : Ty.apply (Ty.path "*") [] [ T ] :=
                  M.alloc (|
                    M.call_closure (|
                      T,
                      M.get_function (| "core::ptr::read", [], [ T ] |),
                      [
                        M.borrow (|
                          Pointer.Kind.ConstPointer,
                          M.deref (|
                            M.call_closure (|
                              Ty.apply (Ty.path "&mut") [] [ T ],
                              M.get_associated_function (|
                                Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; A ],
                                "get_mut_unchecked",
                                [],
                                []
                              |),
                              [
                                M.borrow (|
                                  Pointer.Kind.MutRef,
                                  M.deref (|
                                    M.call_closure (|
                                      Ty.apply
                                        (Ty.path "&mut")
                                        []
                                        [ Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; A ] ],
                                      M.get_trait_method (|
                                        "core::ops::deref::DerefMut",
                                        Ty.apply
                                          (Ty.path "core::mem::manually_drop::ManuallyDrop")
                                          []
                                          [ Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; A ] ],
                                        [],
                                        [],
                                        "deref_mut",
                                        [],
                                        []
                                      |),
                                      [
                                        M.borrow (|
                                          Pointer.Kind.MutRef,
                                          M.deref (| M.borrow (| Pointer.Kind.MutRef, this |) |)
                                        |)
                                      ]
                                    |)
                                  |)
                                |)
                              ]
                            |)
                          |)
                        |)
                      ]
                    |)
                  |) in
                let~ alloc : Ty.apply (Ty.path "*") [] [ A ] :=
                  M.alloc (|
                    M.call_closure (|
                      A,
                      M.get_function (| "core::ptr::read", [], [ A ] |),
                      [
                        M.borrow (|
                          Pointer.Kind.ConstPointer,
                          M.deref (|
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.SubPointer.get_struct_record_field (|
                                M.deref (|
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "&")
                                      []
                                      [ Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; A ] ],
                                    M.get_trait_method (|
                                      "core::ops::deref::Deref",
                                      Ty.apply
                                        (Ty.path "core::mem::manually_drop::ManuallyDrop")
                                        []
                                        [ Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; A ] ],
                                      [],
                                      [],
                                      "deref",
                                      [],
                                      []
                                    |),
                                    [ M.borrow (| Pointer.Kind.Ref, this |) ]
                                  |)
                                |),
                                "alloc::sync::Arc",
                                "alloc"
                              |)
                            |)
                          |)
                        |)
                      ]
                    |)
                  |) in
                let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                  M.alloc (|
                    M.call_closure (|
                      Ty.tuple [],
                      M.get_function (|
                        "core::mem::drop",
                        [],
                        [ Ty.apply (Ty.path "alloc::sync::Weak") [] [ T; A ] ]
                      |),
                      [
                        Value.StructRecord
                          "alloc::sync::Weak"
                          [
                            ("ptr",
                              M.read (|
                                M.SubPointer.get_struct_record_field (|
                                  M.deref (|
                                    M.call_closure (|
                                      Ty.apply
                                        (Ty.path "&")
                                        []
                                        [ Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; A ] ],
                                      M.get_trait_method (|
                                        "core::ops::deref::Deref",
                                        Ty.apply
                                          (Ty.path "core::mem::manually_drop::ManuallyDrop")
                                          []
                                          [ Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; A ] ],
                                        [],
                                        [],
                                        "deref",
                                        [],
                                        []
                                      |),
                                      [ M.borrow (| Pointer.Kind.Ref, this |) ]
                                    |)
                                  |),
                                  "alloc::sync::Arc",
                                  "ptr"
                                |)
                              |));
                            ("alloc", M.read (| alloc |))
                          ]
                      ]
                    |)
                  |) in
                M.alloc (| Value.StructTuple "core::option::Option::Some" [ M.read (| inner |) ] |)
              |)))
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_into_inner :
      forall (T A : Ty.t),
      M.IsAssociatedFunction.C (Self T A) "into_inner" (into_inner T A).
    Admitted.
    Global Typeclasses Opaque into_inner.
    (*
        pub fn allocator(this: &Self) -> &A {
            &this.alloc
        }
    *)
    Definition allocator (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ this ] =>
        ltac:(M.monadic
          (let this := M.alloc (| this |) in
          M.borrow (|
            Pointer.Kind.Ref,
            M.deref (|
              M.borrow (|
                Pointer.Kind.Ref,
                M.SubPointer.get_struct_record_field (|
                  M.deref (| M.read (| this |) |),
                  "alloc::sync::Arc",
                  "alloc"
                |)
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_allocator :
      forall (T A : Ty.t),
      M.IsAssociatedFunction.C (Self T A) "allocator" (allocator T A).
    Admitted.
    Global Typeclasses Opaque allocator.
    
    (*
        pub fn into_raw(this: Self) -> *const T {
            let this = ManuallyDrop::new(this);
            Self::as_ptr(&*this)
        }
    *)
    Definition into_raw (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ this ] =>
        ltac:(M.monadic
          (let this := M.alloc (| this |) in
          M.read (|
            let~ this :
                Ty.apply
                  (Ty.path "*")
                  []
                  [
                    Ty.apply
                      (Ty.path "core::mem::manually_drop::ManuallyDrop")
                      []
                      [ Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; A ] ]
                  ] :=
              M.alloc (|
                M.call_closure (|
                  Ty.apply
                    (Ty.path "core::mem::manually_drop::ManuallyDrop")
                    []
                    [ Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; A ] ],
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "core::mem::manually_drop::ManuallyDrop")
                      []
                      [ Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; A ] ],
                    "new",
                    [],
                    []
                  |),
                  [ M.read (| this |) ]
                |)
              |) in
            M.alloc (|
              M.call_closure (|
                Ty.apply (Ty.path "*const") [] [ T ],
                M.get_associated_function (|
                  Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; A ],
                  "as_ptr",
                  [],
                  []
                |),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.deref (|
                          M.call_closure (|
                            Ty.apply
                              (Ty.path "&")
                              []
                              [ Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; A ] ],
                            M.get_trait_method (|
                              "core::ops::deref::Deref",
                              Ty.apply
                                (Ty.path "core::mem::manually_drop::ManuallyDrop")
                                []
                                [ Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; A ] ],
                              [],
                              [],
                              "deref",
                              [],
                              []
                            |),
                            [ M.borrow (| Pointer.Kind.Ref, this |) ]
                          |)
                        |)
                      |)
                    |)
                  |)
                ]
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_into_raw :
      forall (T A : Ty.t),
      M.IsAssociatedFunction.C (Self T A) "into_raw" (into_raw T A).
    Admitted.
    Global Typeclasses Opaque into_raw.
    
    (*
        pub fn into_raw_with_allocator(this: Self) -> ( *const T, A) {
            let this = mem::ManuallyDrop::new(this);
            let ptr = Self::as_ptr(&this);
            // Safety: `this` is ManuallyDrop so the allocator will not be double-dropped
            let alloc = unsafe { ptr::read(&this.alloc) };
            (ptr, alloc)
        }
    *)
    Definition into_raw_with_allocator
        (T A : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ this ] =>
        ltac:(M.monadic
          (let this := M.alloc (| this |) in
          M.read (|
            let~ this :
                Ty.apply
                  (Ty.path "*")
                  []
                  [
                    Ty.apply
                      (Ty.path "core::mem::manually_drop::ManuallyDrop")
                      []
                      [ Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; A ] ]
                  ] :=
              M.alloc (|
                M.call_closure (|
                  Ty.apply
                    (Ty.path "core::mem::manually_drop::ManuallyDrop")
                    []
                    [ Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; A ] ],
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "core::mem::manually_drop::ManuallyDrop")
                      []
                      [ Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; A ] ],
                    "new",
                    [],
                    []
                  |),
                  [ M.read (| this |) ]
                |)
              |) in
            let~ ptr : Ty.apply (Ty.path "*") [] [ Ty.apply (Ty.path "*const") [] [ T ] ] :=
              M.alloc (|
                M.call_closure (|
                  Ty.apply (Ty.path "*const") [] [ T ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; A ],
                    "as_ptr",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "&")
                            []
                            [ Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; A ] ],
                          M.get_trait_method (|
                            "core::ops::deref::Deref",
                            Ty.apply
                              (Ty.path "core::mem::manually_drop::ManuallyDrop")
                              []
                              [ Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; A ] ],
                            [],
                            [],
                            "deref",
                            [],
                            []
                          |),
                          [
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.deref (| M.borrow (| Pointer.Kind.Ref, this |) |)
                            |)
                          ]
                        |)
                      |)
                    |)
                  ]
                |)
              |) in
            let~ alloc : Ty.apply (Ty.path "*") [] [ A ] :=
              M.alloc (|
                M.call_closure (|
                  A,
                  M.get_function (| "core::ptr::read", [], [ A ] |),
                  [
                    M.borrow (|
                      Pointer.Kind.ConstPointer,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (|
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "&")
                                  []
                                  [ Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; A ] ],
                                M.get_trait_method (|
                                  "core::ops::deref::Deref",
                                  Ty.apply
                                    (Ty.path "core::mem::manually_drop::ManuallyDrop")
                                    []
                                    [ Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; A ] ],
                                  [],
                                  [],
                                  "deref",
                                  [],
                                  []
                                |),
                                [ M.borrow (| Pointer.Kind.Ref, this |) ]
                              |)
                            |),
                            "alloc::sync::Arc",
                            "alloc"
                          |)
                        |)
                      |)
                    |)
                  ]
                |)
              |) in
            M.alloc (| Value.Tuple [ M.read (| ptr |); M.read (| alloc |) ] |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_into_raw_with_allocator :
      forall (T A : Ty.t),
      M.IsAssociatedFunction.C (Self T A) "into_raw_with_allocator" (into_raw_with_allocator T A).
    Admitted.
    Global Typeclasses Opaque into_raw_with_allocator.
    
    (*
        pub fn as_ptr(this: &Self) -> *const T {
            let ptr: *mut ArcInner<T> = NonNull::as_ptr(this.ptr);
    
            // SAFETY: This cannot go through Deref::deref or RcInnerPtr::inner because
            // this is required to retain raw/mut provenance such that e.g. `get_mut` can
            // write through the pointer after the Rc is recovered through `from_raw`.
            unsafe { &raw mut ( *ptr).data }
        }
    *)
    Definition as_ptr (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ this ] =>
        ltac:(M.monadic
          (let this := M.alloc (| this |) in
          M.read (|
            let~ ptr :
                Ty.apply
                  (Ty.path "*")
                  []
                  [
                    Ty.apply
                      (Ty.path "*mut")
                      []
                      [ Ty.apply (Ty.path "alloc::sync::ArcInner") [] [ T ] ]
                  ] :=
              M.alloc (|
                M.call_closure (|
                  Ty.apply
                    (Ty.path "*mut")
                    []
                    [ Ty.apply (Ty.path "alloc::sync::ArcInner") [] [ T ] ],
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "core::ptr::non_null::NonNull")
                      []
                      [ Ty.apply (Ty.path "alloc::sync::ArcInner") [] [ T ] ],
                    "as_ptr",
                    [],
                    []
                  |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| this |) |),
                        "alloc::sync::Arc",
                        "ptr"
                      |)
                    |)
                  ]
                |)
              |) in
            M.alloc (|
              (* MutToConstPointer *)
              M.pointer_coercion
                (M.borrow (|
                  Pointer.Kind.MutPointer,
                  M.SubPointer.get_struct_record_field (|
                    M.deref (| M.read (| ptr |) |),
                    "alloc::sync::ArcInner",
                    "data"
                  |)
                |))
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_as_ptr :
      forall (T A : Ty.t),
      M.IsAssociatedFunction.C (Self T A) "as_ptr" (as_ptr T A).
    Admitted.
    Global Typeclasses Opaque as_ptr.
    
    (*
        pub unsafe fn from_raw_in(ptr: *const T, alloc: A) -> Self {
            unsafe {
                let offset = data_offset(ptr);
    
                // Reverse the offset to find the original ArcInner.
                let arc_ptr = ptr.byte_sub(offset) as *mut ArcInner<T>;
    
                Self::from_ptr_in(arc_ptr, alloc)
            }
        }
    *)
    Definition from_raw_in (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ ptr; alloc ] =>
        ltac:(M.monadic
          (let ptr := M.alloc (| ptr |) in
          let alloc := M.alloc (| alloc |) in
          M.read (|
            let~ offset : Ty.apply (Ty.path "*") [] [ Ty.path "usize" ] :=
              M.alloc (|
                M.call_closure (|
                  Ty.path "usize",
                  M.get_function (| "alloc::sync::data_offset", [], [ T ] |),
                  [ M.read (| ptr |) ]
                |)
              |) in
            let~ arc_ptr :
                Ty.apply
                  (Ty.path "*")
                  []
                  [
                    Ty.apply
                      (Ty.path "*mut")
                      []
                      [ Ty.apply (Ty.path "alloc::sync::ArcInner") [] [ T ] ]
                  ] :=
              M.alloc (|
                M.cast
                  (Ty.apply
                    (Ty.path "*mut")
                    []
                    [ Ty.apply (Ty.path "alloc::sync::ArcInner") [] [ T ] ])
                  (M.call_closure (|
                    Ty.apply (Ty.path "*const") [] [ T ],
                    M.get_associated_function (|
                      Ty.apply (Ty.path "*const") [] [ T ],
                      "byte_sub",
                      [],
                      []
                    |),
                    [ M.read (| ptr |); M.read (| offset |) ]
                  |))
              |) in
            M.alloc (|
              M.call_closure (|
                Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; A ],
                M.get_associated_function (|
                  Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; A ],
                  "from_ptr_in",
                  [],
                  []
                |),
                [ M.read (| arc_ptr |); M.read (| alloc |) ]
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_from_raw_in :
      forall (T A : Ty.t),
      M.IsAssociatedFunction.C (Self T A) "from_raw_in" (from_raw_in T A).
    Admitted.
    Global Typeclasses Opaque from_raw_in.
    
    (*
        pub fn downgrade(this: &Self) -> Weak<T, A>
        where
            A: Clone,
        {
            // This Relaxed is OK because we're checking the value in the CAS
            // below.
            let mut cur = this.inner().weak.load(Relaxed);
    
            loop {
                // check if the weak counter is currently "locked"; if so, spin.
                if cur == usize::MAX {
                    hint::spin_loop();
                    cur = this.inner().weak.load(Relaxed);
                    continue;
                }
    
                // We can't allow the refcount to increase much past `MAX_REFCOUNT`.
                assert!(cur <= MAX_REFCOUNT, "{}", INTERNAL_OVERFLOW_ERROR);
    
                // NOTE: this code currently ignores the possibility of overflow
                // into usize::MAX; in general both Rc and Arc need to be adjusted
                // to deal with overflow.
    
                // Unlike with Clone(), we need this to be an Acquire read to
                // synchronize with the write coming from `is_unique`, so that the
                // events prior to that write happen before this read.
                match this.inner().weak.compare_exchange_weak(cur, cur + 1, Acquire, Relaxed) {
                    Ok(_) => {
                        // Make sure we do not create a dangling Weak
                        debug_assert!(!is_dangling(this.ptr.as_ptr()));
                        return Weak { ptr: this.ptr, alloc: this.alloc.clone() };
                    }
                    Err(old) => cur = old,
                }
            }
        }
    *)
    Definition downgrade (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ this ] =>
        ltac:(M.monadic
          (let this := M.alloc (| this |) in
          M.catch_return (Ty.apply (Ty.path "alloc::sync::Weak") [] [ T; A ]) (|
            ltac:(M.monadic
              (M.read (|
                let~ cur : Ty.apply (Ty.path "*") [] [ Ty.path "usize" ] :=
                  M.alloc (|
                    M.call_closure (|
                      Ty.path "usize",
                      M.get_associated_function (|
                        Ty.path "core::sync::atomic::AtomicUsize",
                        "load",
                        [],
                        []
                      |),
                      [
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (|
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "&")
                                  []
                                  [ Ty.apply (Ty.path "alloc::sync::ArcInner") [] [ T ] ],
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; A ],
                                  "inner",
                                  [],
                                  []
                                |),
                                [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| this |) |) |) ]
                              |)
                            |),
                            "alloc::sync::ArcInner",
                            "weak"
                          |)
                        |);
                        Value.StructTuple "core::sync::atomic::Ordering::Relaxed" []
                      ]
                    |)
                  |) in
                M.alloc (|
                  M.never_to_any (|
                    M.read (|
                      M.loop (|
                        Ty.apply (Ty.path "*") [] [ Ty.path "never" ],
                        ltac:(M.monadic
                          (let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                            M.match_operator (|
                              Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                              M.alloc (| Value.Tuple [] |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let γ :=
                                      M.use
                                        (M.alloc (|
                                          M.call_closure (|
                                            Ty.path "bool",
                                            BinOp.eq,
                                            [
                                              M.read (| cur |);
                                              M.read (|
                                                get_associated_constant (|
                                                  Ty.path "usize",
                                                  "MAX",
                                                  Ty.path "usize"
                                                |)
                                              |)
                                            ]
                                          |)
                                        |)) in
                                    let _ :=
                                      is_constant_or_break_match (|
                                        M.read (| γ |),
                                        Value.Bool true
                                      |) in
                                    M.alloc (|
                                      M.never_to_any (|
                                        M.read (|
                                          let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                                            M.alloc (|
                                              M.call_closure (|
                                                Ty.tuple [],
                                                M.get_function (|
                                                  "core::hint::spin_loop",
                                                  [],
                                                  []
                                                |),
                                                []
                                              |)
                                            |) in
                                          let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                                            M.alloc (|
                                              M.write (|
                                                cur,
                                                M.call_closure (|
                                                  Ty.path "usize",
                                                  M.get_associated_function (|
                                                    Ty.path "core::sync::atomic::AtomicUsize",
                                                    "load",
                                                    [],
                                                    []
                                                  |),
                                                  [
                                                    M.borrow (|
                                                      Pointer.Kind.Ref,
                                                      M.SubPointer.get_struct_record_field (|
                                                        M.deref (|
                                                          M.call_closure (|
                                                            Ty.apply
                                                              (Ty.path "&")
                                                              []
                                                              [
                                                                Ty.apply
                                                                  (Ty.path "alloc::sync::ArcInner")
                                                                  []
                                                                  [ T ]
                                                              ],
                                                            M.get_associated_function (|
                                                              Ty.apply
                                                                (Ty.path "alloc::sync::Arc")
                                                                []
                                                                [ T; A ],
                                                              "inner",
                                                              [],
                                                              []
                                                            |),
                                                            [
                                                              M.borrow (|
                                                                Pointer.Kind.Ref,
                                                                M.deref (| M.read (| this |) |)
                                                              |)
                                                            ]
                                                          |)
                                                        |),
                                                        "alloc::sync::ArcInner",
                                                        "weak"
                                                      |)
                                                    |);
                                                    Value.StructTuple
                                                      "core::sync::atomic::Ordering::Relaxed"
                                                      []
                                                  ]
                                                |)
                                              |)
                                            |) in
                                          M.continue (||)
                                        |)
                                      |)
                                    |)));
                                fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                              ]
                            |) in
                          let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                            M.match_operator (|
                              Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                              M.alloc (| Value.Tuple [] |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let γ :=
                                      M.use
                                        (M.alloc (|
                                          UnOp.not (|
                                            M.call_closure (|
                                              Ty.path "bool",
                                              BinOp.le,
                                              [
                                                M.read (| cur |);
                                                M.read (|
                                                  get_constant (|
                                                    "alloc::sync::MAX_REFCOUNT",
                                                    Ty.path "usize"
                                                  |)
                                                |)
                                              ]
                                            |)
                                          |)
                                        |)) in
                                    let _ :=
                                      is_constant_or_break_match (|
                                        M.read (| γ |),
                                        Value.Bool true
                                      |) in
                                    M.alloc (|
                                      M.never_to_any (|
                                        M.call_closure (|
                                          Ty.path "never",
                                          M.get_associated_function (|
                                            Self,
                                            "panic_cold_display.downgrade",
                                            [],
                                            []
                                          |),
                                          [
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.deref (|
                                                M.borrow (|
                                                  Pointer.Kind.Ref,
                                                  get_constant (|
                                                    "alloc::sync::INTERNAL_OVERFLOW_ERROR",
                                                    Ty.apply (Ty.path "&") [] [ Ty.path "str" ]
                                                  |)
                                                |)
                                              |)
                                            |)
                                          ]
                                        |)
                                      |)
                                    |)));
                                fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                              ]
                            |) in
                          M.match_operator (|
                            Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                            M.alloc (|
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "core::result::Result")
                                  []
                                  [ Ty.path "usize"; Ty.path "usize" ],
                                M.get_associated_function (|
                                  Ty.path "core::sync::atomic::AtomicUsize",
                                  "compare_exchange_weak",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.SubPointer.get_struct_record_field (|
                                      M.deref (|
                                        M.call_closure (|
                                          Ty.apply
                                            (Ty.path "&")
                                            []
                                            [ Ty.apply (Ty.path "alloc::sync::ArcInner") [] [ T ] ],
                                          M.get_associated_function (|
                                            Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; A ],
                                            "inner",
                                            [],
                                            []
                                          |),
                                          [
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.deref (| M.read (| this |) |)
                                            |)
                                          ]
                                        |)
                                      |),
                                      "alloc::sync::ArcInner",
                                      "weak"
                                    |)
                                  |);
                                  M.read (| cur |);
                                  M.call_closure (|
                                    Ty.path "usize",
                                    BinOp.Wrap.add,
                                    [ M.read (| cur |); Value.Integer IntegerKind.Usize 1 ]
                                  |);
                                  Value.StructTuple "core::sync::atomic::Ordering::Acquire" [];
                                  Value.StructTuple "core::sync::atomic::Ordering::Relaxed" []
                                ]
                              |)
                            |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::result::Result::Ok",
                                      0
                                    |) in
                                  M.alloc (|
                                    M.never_to_any (|
                                      M.read (|
                                        let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                                          M.match_operator (|
                                            Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                                            M.alloc (| Value.Tuple [] |),
                                            [
                                              fun γ =>
                                                ltac:(M.monadic
                                                  (let γ := M.use (M.alloc (| Value.Bool true |)) in
                                                  let _ :=
                                                    is_constant_or_break_match (|
                                                      M.read (| γ |),
                                                      Value.Bool true
                                                    |) in
                                                  let~ _ :
                                                      Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                                                    M.match_operator (|
                                                      Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                                                      M.alloc (| Value.Tuple [] |),
                                                      [
                                                        fun γ =>
                                                          ltac:(M.monadic
                                                            (let γ :=
                                                              M.use
                                                                (M.alloc (|
                                                                  UnOp.not (|
                                                                    UnOp.not (|
                                                                      M.call_closure (|
                                                                        Ty.path "bool",
                                                                        M.get_function (|
                                                                          "alloc::rc::is_dangling",
                                                                          [],
                                                                          [
                                                                            Ty.apply
                                                                              (Ty.path
                                                                                "alloc::sync::ArcInner")
                                                                              []
                                                                              [ T ]
                                                                          ]
                                                                        |),
                                                                        [
                                                                          (* MutToConstPointer *)
                                                                          M.pointer_coercion
                                                                            (M.call_closure (|
                                                                              Ty.apply
                                                                                (Ty.path "*mut")
                                                                                []
                                                                                [
                                                                                  Ty.apply
                                                                                    (Ty.path
                                                                                      "alloc::sync::ArcInner")
                                                                                    []
                                                                                    [ T ]
                                                                                ],
                                                                              M.get_associated_function (|
                                                                                Ty.apply
                                                                                  (Ty.path
                                                                                    "core::ptr::non_null::NonNull")
                                                                                  []
                                                                                  [
                                                                                    Ty.apply
                                                                                      (Ty.path
                                                                                        "alloc::sync::ArcInner")
                                                                                      []
                                                                                      [ T ]
                                                                                  ],
                                                                                "as_ptr",
                                                                                [],
                                                                                []
                                                                              |),
                                                                              [
                                                                                M.read (|
                                                                                  M.SubPointer.get_struct_record_field (|
                                                                                    M.deref (|
                                                                                      M.read (|
                                                                                        this
                                                                                      |)
                                                                                    |),
                                                                                    "alloc::sync::Arc",
                                                                                    "ptr"
                                                                                  |)
                                                                                |)
                                                                              ]
                                                                            |))
                                                                        ]
                                                                      |)
                                                                    |)
                                                                  |)
                                                                |)) in
                                                            let _ :=
                                                              is_constant_or_break_match (|
                                                                M.read (| γ |),
                                                                Value.Bool true
                                                              |) in
                                                            M.alloc (|
                                                              M.never_to_any (|
                                                                M.call_closure (|
                                                                  Ty.path "never",
                                                                  M.get_function (|
                                                                    "core::panicking::panic",
                                                                    [],
                                                                    []
                                                                  |),
                                                                  [
                                                                    mk_str (|
                                                                      "assertion failed: !is_dangling(this.ptr.as_ptr())"
                                                                    |)
                                                                  ]
                                                                |)
                                                              |)
                                                            |)));
                                                        fun γ =>
                                                          ltac:(M.monadic
                                                            (M.alloc (| Value.Tuple [] |)))
                                                      ]
                                                    |) in
                                                  M.alloc (| Value.Tuple [] |)));
                                              fun γ =>
                                                ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                                            ]
                                          |) in
                                        M.return_ (|
                                          Value.StructRecord
                                            "alloc::sync::Weak"
                                            [
                                              ("ptr",
                                                M.read (|
                                                  M.SubPointer.get_struct_record_field (|
                                                    M.deref (| M.read (| this |) |),
                                                    "alloc::sync::Arc",
                                                    "ptr"
                                                  |)
                                                |));
                                              ("alloc",
                                                M.call_closure (|
                                                  A,
                                                  M.get_trait_method (|
                                                    "core::clone::Clone",
                                                    A,
                                                    [],
                                                    [],
                                                    "clone",
                                                    [],
                                                    []
                                                  |),
                                                  [
                                                    M.borrow (|
                                                      Pointer.Kind.Ref,
                                                      M.SubPointer.get_struct_record_field (|
                                                        M.deref (| M.read (| this |) |),
                                                        "alloc::sync::Arc",
                                                        "alloc"
                                                      |)
                                                    |)
                                                  ]
                                                |))
                                            ]
                                        |)
                                      |)
                                    |)
                                  |)));
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::result::Result::Err",
                                      0
                                    |) in
                                  let old := M.copy (| γ0_0 |) in
                                  M.alloc (| M.write (| cur, M.read (| old |) |) |)))
                            ]
                          |)))
                      |)
                    |)
                  |)
                |)
              |)))
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_downgrade :
      forall (T A : Ty.t),
      M.IsAssociatedFunction.C (Self T A) "downgrade" (downgrade T A).
    Admitted.
    Global Typeclasses Opaque downgrade.
    
    (*
        pub fn weak_count(this: &Self) -> usize {
            let cnt = this.inner().weak.load(Relaxed);
            // If the weak count is currently locked, the value of the
            // count was 0 just before taking the lock.
            if cnt == usize::MAX { 0 } else { cnt - 1 }
        }
    *)
    Definition weak_count (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ this ] =>
        ltac:(M.monadic
          (let this := M.alloc (| this |) in
          M.read (|
            let~ cnt : Ty.apply (Ty.path "*") [] [ Ty.path "usize" ] :=
              M.alloc (|
                M.call_closure (|
                  Ty.path "usize",
                  M.get_associated_function (|
                    Ty.path "core::sync::atomic::AtomicUsize",
                    "load",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (|
                          M.call_closure (|
                            Ty.apply
                              (Ty.path "&")
                              []
                              [ Ty.apply (Ty.path "alloc::sync::ArcInner") [] [ T ] ],
                            M.get_associated_function (|
                              Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; A ],
                              "inner",
                              [],
                              []
                            |),
                            [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| this |) |) |) ]
                          |)
                        |),
                        "alloc::sync::ArcInner",
                        "weak"
                      |)
                    |);
                    Value.StructTuple "core::sync::atomic::Ordering::Relaxed" []
                  ]
                |)
              |) in
            M.match_operator (|
              Ty.apply (Ty.path "*") [] [ Ty.path "usize" ],
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          M.call_closure (|
                            Ty.path "bool",
                            BinOp.eq,
                            [
                              M.read (| cnt |);
                              M.read (|
                                get_associated_constant (|
                                  Ty.path "usize",
                                  "MAX",
                                  Ty.path "usize"
                                |)
                              |)
                            ]
                          |)
                        |)) in
                    let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (| Value.Integer IntegerKind.Usize 0 |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      M.call_closure (|
                        Ty.path "usize",
                        BinOp.Wrap.sub,
                        [ M.read (| cnt |); Value.Integer IntegerKind.Usize 1 ]
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_weak_count :
      forall (T A : Ty.t),
      M.IsAssociatedFunction.C (Self T A) "weak_count" (weak_count T A).
    Admitted.
    Global Typeclasses Opaque weak_count.
    
    (*
        pub fn strong_count(this: &Self) -> usize {
            this.inner().strong.load(Relaxed)
        }
    *)
    Definition strong_count
        (T A : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ this ] =>
        ltac:(M.monadic
          (let this := M.alloc (| this |) in
          M.call_closure (|
            Ty.path "usize",
            M.get_associated_function (|
              Ty.path "core::sync::atomic::AtomicUsize",
              "load",
              [],
              []
            |),
            [
              M.borrow (|
                Pointer.Kind.Ref,
                M.SubPointer.get_struct_record_field (|
                  M.deref (|
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "&")
                        []
                        [ Ty.apply (Ty.path "alloc::sync::ArcInner") [] [ T ] ],
                      M.get_associated_function (|
                        Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; A ],
                        "inner",
                        [],
                        []
                      |),
                      [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| this |) |) |) ]
                    |)
                  |),
                  "alloc::sync::ArcInner",
                  "strong"
                |)
              |);
              Value.StructTuple "core::sync::atomic::Ordering::Relaxed" []
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_strong_count :
      forall (T A : Ty.t),
      M.IsAssociatedFunction.C (Self T A) "strong_count" (strong_count T A).
    Admitted.
    Global Typeclasses Opaque strong_count.
    
    (*
        pub unsafe fn increment_strong_count_in(ptr: *const T, alloc: A)
        where
            A: Clone,
        {
            // Retain Arc, but don't touch refcount by wrapping in ManuallyDrop
            let arc = unsafe { mem::ManuallyDrop::new(Arc::from_raw_in(ptr, alloc)) };
            // Now increase refcount, but don't drop new refcount either
            let _arc_clone: mem::ManuallyDrop<_> = arc.clone();
        }
    *)
    Definition increment_strong_count_in
        (T A : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ ptr; alloc ] =>
        ltac:(M.monadic
          (let ptr := M.alloc (| ptr |) in
          let alloc := M.alloc (| alloc |) in
          M.read (|
            let~ arc :
                Ty.apply
                  (Ty.path "*")
                  []
                  [
                    Ty.apply
                      (Ty.path "core::mem::manually_drop::ManuallyDrop")
                      []
                      [ Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; A ] ]
                  ] :=
              M.alloc (|
                M.call_closure (|
                  Ty.apply
                    (Ty.path "core::mem::manually_drop::ManuallyDrop")
                    []
                    [ Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; A ] ],
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "core::mem::manually_drop::ManuallyDrop")
                      []
                      [ Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; A ] ],
                    "new",
                    [],
                    []
                  |),
                  [
                    M.call_closure (|
                      Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; A ],
                      M.get_associated_function (|
                        Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; A ],
                        "from_raw_in",
                        [],
                        []
                      |),
                      [ M.read (| ptr |); M.read (| alloc |) ]
                    |)
                  ]
                |)
              |) in
            let~ _arc_clone :
                Ty.apply
                  (Ty.path "*")
                  []
                  [
                    Ty.apply
                      (Ty.path "core::mem::manually_drop::ManuallyDrop")
                      []
                      [ Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; A ] ]
                  ] :=
              M.alloc (|
                M.call_closure (|
                  Ty.apply
                    (Ty.path "core::mem::manually_drop::ManuallyDrop")
                    []
                    [ Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; A ] ],
                  M.get_trait_method (|
                    "core::clone::Clone",
                    Ty.apply
                      (Ty.path "core::mem::manually_drop::ManuallyDrop")
                      []
                      [ Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; A ] ],
                    [],
                    [],
                    "clone",
                    [],
                    []
                  |),
                  [ M.borrow (| Pointer.Kind.Ref, arc |) ]
                |)
              |) in
            M.alloc (| Value.Tuple [] |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_increment_strong_count_in :
      forall (T A : Ty.t),
      M.IsAssociatedFunction.C
        (Self T A)
        "increment_strong_count_in"
        (increment_strong_count_in T A).
    Admitted.
    Global Typeclasses Opaque increment_strong_count_in.
    
    (*
        pub unsafe fn decrement_strong_count_in(ptr: *const T, alloc: A) {
            unsafe { drop(Arc::from_raw_in(ptr, alloc)) };
        }
    *)
    Definition decrement_strong_count_in
        (T A : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ ptr; alloc ] =>
        ltac:(M.monadic
          (let ptr := M.alloc (| ptr |) in
          let alloc := M.alloc (| alloc |) in
          M.read (|
            let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
              M.alloc (|
                M.call_closure (|
                  Ty.tuple [],
                  M.get_function (|
                    "core::mem::drop",
                    [],
                    [ Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; A ] ]
                  |),
                  [
                    M.call_closure (|
                      Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; A ],
                      M.get_associated_function (|
                        Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; A ],
                        "from_raw_in",
                        [],
                        []
                      |),
                      [ M.read (| ptr |); M.read (| alloc |) ]
                    |)
                  ]
                |)
              |) in
            M.alloc (| Value.Tuple [] |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_decrement_strong_count_in :
      forall (T A : Ty.t),
      M.IsAssociatedFunction.C
        (Self T A)
        "decrement_strong_count_in"
        (decrement_strong_count_in T A).
    Admitted.
    Global Typeclasses Opaque decrement_strong_count_in.
    
    (*
        fn inner(&self) -> &ArcInner<T> {
            // This unsafety is ok because while this arc is alive we're guaranteed
            // that the inner pointer is valid. Furthermore, we know that the
            // `ArcInner` structure itself is `Sync` because the inner data is
            // `Sync` as well, so we're ok loaning out an immutable pointer to these
            // contents.
            unsafe { self.ptr.as_ref() }
        }
    *)
    Definition inner (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.borrow (|
            Pointer.Kind.Ref,
            M.deref (|
              M.call_closure (|
                Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "alloc::sync::ArcInner") [] [ T ] ],
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "core::ptr::non_null::NonNull")
                    []
                    [ Ty.apply (Ty.path "alloc::sync::ArcInner") [] [ T ] ],
                  "as_ref",
                  [],
                  []
                |),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| self |) |),
                      "alloc::sync::Arc",
                      "ptr"
                    |)
                  |)
                ]
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_inner :
      forall (T A : Ty.t),
      M.IsAssociatedFunction.C (Self T A) "inner" (inner T A).
    Admitted.
    Global Typeclasses Opaque inner.
    
    (*
        unsafe fn drop_slow(&mut self) {
            // Drop the weak ref collectively held by all strong references when this
            // variable goes out of scope. This ensures that the memory is deallocated
            // even if the destructor of `T` panics.
            // Take a reference to `self.alloc` instead of cloning because 1. it'll last long
            // enough, and 2. you should be able to drop `Arc`s with unclonable allocators
            let _weak = Weak { ptr: self.ptr, alloc: &self.alloc };
    
            // Destroy the data at this time, even though we must not free the box
            // allocation itself (there might still be weak pointers lying around).
            // We cannot use `get_mut_unchecked` here, because `self.alloc` is borrowed.
            unsafe { ptr::drop_in_place(&mut ( *self.ptr.as_ptr()).data) };
        }
    *)
    Definition drop_slow (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            let~ _weak :
                Ty.apply
                  (Ty.path "*")
                  []
                  [ Ty.apply (Ty.path "alloc::sync::Weak") [] [ T; Ty.apply (Ty.path "&") [] [ A ] ]
                  ] :=
              M.alloc (|
                Value.StructRecord
                  "alloc::sync::Weak"
                  [
                    ("ptr",
                      M.read (|
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "alloc::sync::Arc",
                          "ptr"
                        |)
                      |));
                    ("alloc",
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "alloc::sync::Arc",
                          "alloc"
                        |)
                      |))
                  ]
              |) in
            let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
              M.alloc (|
                M.call_closure (|
                  Ty.tuple [],
                  M.get_function (| "core::ptr::drop_in_place", [], [ T ] |),
                  [
                    M.borrow (|
                      Pointer.Kind.MutPointer,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.MutRef,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (|
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "*mut")
                                  []
                                  [ Ty.apply (Ty.path "alloc::sync::ArcInner") [] [ T ] ],
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "core::ptr::non_null::NonNull")
                                    []
                                    [ Ty.apply (Ty.path "alloc::sync::ArcInner") [] [ T ] ],
                                  "as_ptr",
                                  [],
                                  []
                                |),
                                [
                                  M.read (|
                                    M.SubPointer.get_struct_record_field (|
                                      M.deref (| M.read (| self |) |),
                                      "alloc::sync::Arc",
                                      "ptr"
                                    |)
                                  |)
                                ]
                              |)
                            |),
                            "alloc::sync::ArcInner",
                            "data"
                          |)
                        |)
                      |)
                    |)
                  ]
                |)
              |) in
            M.alloc (| Value.Tuple [] |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_drop_slow :
      forall (T A : Ty.t),
      M.IsAssociatedFunction.C (Self T A) "drop_slow" (drop_slow T A).
    Admitted.
    Global Typeclasses Opaque drop_slow.
    
    (*
        pub fn ptr_eq(this: &Self, other: &Self) -> bool {
            ptr::addr_eq(this.ptr.as_ptr(), other.ptr.as_ptr())
        }
    *)
    Definition ptr_eq (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ this; other ] =>
        ltac:(M.monadic
          (let this := M.alloc (| this |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            Ty.path "bool",
            M.get_function (|
              "core::ptr::addr_eq",
              [],
              [
                Ty.apply (Ty.path "alloc::sync::ArcInner") [] [ T ];
                Ty.apply (Ty.path "alloc::sync::ArcInner") [] [ T ]
              ]
            |),
            [
              (* MutToConstPointer *)
              M.pointer_coercion
                (M.call_closure (|
                  Ty.apply
                    (Ty.path "*mut")
                    []
                    [ Ty.apply (Ty.path "alloc::sync::ArcInner") [] [ T ] ],
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "core::ptr::non_null::NonNull")
                      []
                      [ Ty.apply (Ty.path "alloc::sync::ArcInner") [] [ T ] ],
                    "as_ptr",
                    [],
                    []
                  |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| this |) |),
                        "alloc::sync::Arc",
                        "ptr"
                      |)
                    |)
                  ]
                |));
              (* MutToConstPointer *)
              M.pointer_coercion
                (M.call_closure (|
                  Ty.apply
                    (Ty.path "*mut")
                    []
                    [ Ty.apply (Ty.path "alloc::sync::ArcInner") [] [ T ] ],
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "core::ptr::non_null::NonNull")
                      []
                      [ Ty.apply (Ty.path "alloc::sync::ArcInner") [] [ T ] ],
                    "as_ptr",
                    [],
                    []
                  |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| other |) |),
                        "alloc::sync::Arc",
                        "ptr"
                      |)
                    |)
                  ]
                |))
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_ptr_eq :
      forall (T A : Ty.t),
      M.IsAssociatedFunction.C (Self T A) "ptr_eq" (ptr_eq T A).
    Admitted.
    Global Typeclasses Opaque ptr_eq.
    (*
        unsafe fn allocate_for_ptr_in(ptr: *const T, alloc: &A) -> *mut ArcInner<T> {
            // Allocate for the `ArcInner<T>` using the given value.
            unsafe {
                Arc::allocate_for_layout(
                    Layout::for_value_raw(ptr),
                    |layout| alloc.allocate(layout),
                    |mem| mem.with_metadata_of(ptr as *const ArcInner<T>),
                )
            }
        }
    *)
    Definition allocate_for_ptr_in
        (T A : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ ptr; alloc ] =>
        ltac:(M.monadic
          (let ptr := M.alloc (| ptr |) in
          let alloc := M.alloc (| alloc |) in
          M.call_closure (|
            Ty.apply (Ty.path "*mut") [] [ Ty.apply (Ty.path "alloc::sync::ArcInner") [] [ T ] ],
            M.get_associated_function (|
              Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; Ty.path "alloc::alloc::Global" ],
              "allocate_for_layout",
              [],
              [
                Ty.function
                  [ Ty.tuple [ Ty.path "core::alloc::layout::Layout" ] ]
                  (Ty.apply
                    (Ty.path "core::result::Result")
                    []
                    [
                      Ty.apply
                        (Ty.path "core::ptr::non_null::NonNull")
                        []
                        [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ];
                      Ty.path "core::alloc::AllocError"
                    ]);
                Ty.function
                  [ Ty.tuple [ Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ] ] ]
                  (Ty.apply
                    (Ty.path "*mut")
                    []
                    [ Ty.apply (Ty.path "alloc::sync::ArcInner") [] [ T ] ])
              ]
            |),
            [
              M.call_closure (|
                Ty.path "core::alloc::layout::Layout",
                M.get_associated_function (|
                  Ty.path "core::alloc::layout::Layout",
                  "for_value_raw",
                  [],
                  [ T ]
                |),
                [ M.read (| ptr |) ]
              |);
              M.closure
                (fun γ =>
                  ltac:(M.monadic
                    match γ with
                    | [ α0 ] =>
                      ltac:(M.monadic
                        (M.match_operator (|
                          Ty.apply
                            (Ty.path "*")
                            []
                            [
                              Ty.function
                                [ Ty.tuple [ Ty.path "core::alloc::layout::Layout" ] ]
                                (Ty.apply
                                  (Ty.path "core::result::Result")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "core::ptr::non_null::NonNull")
                                      []
                                      [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ];
                                    Ty.path "core::alloc::AllocError"
                                  ])
                            ],
                          M.alloc (| α0 |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let layout := M.copy (| γ |) in
                                M.call_closure (|
                                  Ty.apply
                                    (Ty.path "core::result::Result")
                                    []
                                    [
                                      Ty.apply
                                        (Ty.path "core::ptr::non_null::NonNull")
                                        []
                                        [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ];
                                      Ty.path "core::alloc::AllocError"
                                    ],
                                  M.get_trait_method (|
                                    "core::alloc::Allocator",
                                    A,
                                    [],
                                    [],
                                    "allocate",
                                    [],
                                    []
                                  |),
                                  [
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.deref (| M.read (| alloc |) |)
                                    |);
                                    M.read (| layout |)
                                  ]
                                |)))
                          ]
                        |)))
                    | _ => M.impossible "wrong number of arguments"
                    end));
              M.closure
                (fun γ =>
                  ltac:(M.monadic
                    match γ with
                    | [ α0 ] =>
                      ltac:(M.monadic
                        (M.match_operator (|
                          Ty.apply
                            (Ty.path "*")
                            []
                            [
                              Ty.function
                                [ Ty.tuple [ Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ] ] ]
                                (Ty.apply
                                  (Ty.path "*mut")
                                  []
                                  [ Ty.apply (Ty.path "alloc::sync::ArcInner") [] [ T ] ])
                            ],
                          M.alloc (| α0 |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let mem := M.copy (| γ |) in
                                M.call_closure (|
                                  Ty.apply
                                    (Ty.path "*mut")
                                    []
                                    [ Ty.apply (Ty.path "alloc::sync::ArcInner") [] [ T ] ],
                                  M.get_associated_function (|
                                    Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ],
                                    "with_metadata_of",
                                    [],
                                    [ Ty.apply (Ty.path "alloc::sync::ArcInner") [] [ T ] ]
                                  |),
                                  [
                                    M.read (| mem |);
                                    M.cast
                                      (Ty.apply
                                        (Ty.path "*const")
                                        []
                                        [ Ty.apply (Ty.path "alloc::sync::ArcInner") [] [ T ] ])
                                      (M.read (| ptr |))
                                  ]
                                |)))
                          ]
                        |)))
                    | _ => M.impossible "wrong number of arguments"
                    end))
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_allocate_for_ptr_in :
      forall (T A : Ty.t),
      M.IsAssociatedFunction.C (Self T A) "allocate_for_ptr_in" (allocate_for_ptr_in T A).
    Admitted.
    Global Typeclasses Opaque allocate_for_ptr_in.
    
    (*
        fn from_box_in(src: Box<T, A>) -> Arc<T, A> {
            unsafe {
                let value_size = size_of_val(&*src);
                let ptr = Self::allocate_for_ptr_in(&*src, Box::allocator(&src));
    
                // Copy value as bytes
                ptr::copy_nonoverlapping(
                    (&raw const *src) as *const u8,
                    (&raw mut ( *ptr).data) as *mut u8,
                    value_size,
                );
    
                // Free the allocation without dropping its contents
                let (bptr, alloc) = Box::into_raw_with_allocator(src);
                let src = Box::from_raw_in(bptr as *mut mem::ManuallyDrop<T>, alloc.by_ref());
                drop(src);
    
                Self::from_ptr_in(ptr, alloc)
            }
        }
    *)
    Definition from_box_in (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ src ] =>
        ltac:(M.monadic
          (let src := M.alloc (| src |) in
          M.read (|
            let~ value_size : Ty.apply (Ty.path "*") [] [ Ty.path "usize" ] :=
              M.alloc (|
                M.call_closure (|
                  Ty.path "usize",
                  M.get_function (| "core::mem::size_of_val", [], [ T ] |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (| M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| src |) |) |) |)
                    |)
                  ]
                |)
              |) in
            let~ ptr :
                Ty.apply
                  (Ty.path "*")
                  []
                  [
                    Ty.apply
                      (Ty.path "*mut")
                      []
                      [ Ty.apply (Ty.path "alloc::sync::ArcInner") [] [ T ] ]
                  ] :=
              M.alloc (|
                M.call_closure (|
                  Ty.apply
                    (Ty.path "*mut")
                    []
                    [ Ty.apply (Ty.path "alloc::sync::ArcInner") [] [ T ] ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; A ],
                    "allocate_for_ptr_in",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.ConstPointer,
                      M.deref (| M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| src |) |) |) |)
                    |);
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.call_closure (|
                          Ty.apply (Ty.path "&") [] [ A ],
                          M.get_associated_function (|
                            Ty.apply (Ty.path "alloc::boxed::Box") [] [ T; A ],
                            "allocator",
                            [],
                            []
                          |),
                          [
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.deref (| M.borrow (| Pointer.Kind.Ref, src |) |)
                            |)
                          ]
                        |)
                      |)
                    |)
                  ]
                |)
              |) in
            let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
              M.alloc (|
                M.call_closure (|
                  Ty.tuple [],
                  M.get_function (|
                    "core::intrinsics::copy_nonoverlapping",
                    [],
                    [ Ty.path "u8" ]
                  |),
                  [
                    M.cast
                      (Ty.apply (Ty.path "*const") [] [ Ty.path "u8" ])
                      (M.borrow (| Pointer.Kind.ConstPointer, M.deref (| M.read (| src |) |) |));
                    M.cast
                      (Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ])
                      (M.borrow (|
                        Pointer.Kind.MutPointer,
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| ptr |) |),
                          "alloc::sync::ArcInner",
                          "data"
                        |)
                      |));
                    M.read (| value_size |)
                  ]
                |)
              |) in
            M.match_operator (|
              Ty.apply (Ty.path "*") [] [ Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; A ] ],
              M.alloc (|
                M.call_closure (|
                  Ty.tuple [ Ty.apply (Ty.path "*mut") [] [ T ]; A ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "alloc::boxed::Box") [] [ T; A ],
                    "into_raw_with_allocator",
                    [],
                    []
                  |),
                  [ M.read (| src |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let bptr := M.copy (| γ0_0 |) in
                    let alloc := M.copy (| γ0_1 |) in
                    let~ src :
                        Ty.apply
                          (Ty.path "*")
                          []
                          [
                            Ty.apply
                              (Ty.path "alloc::boxed::Box")
                              []
                              [
                                Ty.apply
                                  (Ty.path "core::mem::manually_drop::ManuallyDrop")
                                  []
                                  [ T ];
                                Ty.apply (Ty.path "&") [] [ A ]
                              ]
                          ] :=
                      M.alloc (|
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "alloc::boxed::Box")
                            []
                            [
                              Ty.apply (Ty.path "core::mem::manually_drop::ManuallyDrop") [] [ T ];
                              Ty.apply (Ty.path "&") [] [ A ]
                            ],
                          M.get_associated_function (|
                            Ty.apply
                              (Ty.path "alloc::boxed::Box")
                              []
                              [
                                Ty.apply
                                  (Ty.path "core::mem::manually_drop::ManuallyDrop")
                                  []
                                  [ T ];
                                Ty.apply (Ty.path "&") [] [ A ]
                              ],
                            "from_raw_in",
                            [],
                            []
                          |),
                          [
                            M.cast
                              (Ty.apply
                                (Ty.path "*mut")
                                []
                                [
                                  Ty.apply
                                    (Ty.path "core::mem::manually_drop::ManuallyDrop")
                                    []
                                    [ T ]
                                ])
                              (M.read (| bptr |));
                            M.call_closure (|
                              Ty.apply (Ty.path "&") [] [ A ],
                              M.get_trait_method (|
                                "core::alloc::Allocator",
                                A,
                                [],
                                [],
                                "by_ref",
                                [],
                                []
                              |),
                              [ M.borrow (| Pointer.Kind.Ref, alloc |) ]
                            |)
                          ]
                        |)
                      |) in
                    let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                      M.alloc (|
                        M.call_closure (|
                          Ty.tuple [],
                          M.get_function (|
                            "core::mem::drop",
                            [],
                            [
                              Ty.apply
                                (Ty.path "alloc::boxed::Box")
                                []
                                [
                                  Ty.apply
                                    (Ty.path "core::mem::manually_drop::ManuallyDrop")
                                    []
                                    [ T ];
                                  Ty.apply (Ty.path "&") [] [ A ]
                                ]
                            ]
                          |),
                          [ M.read (| src |) ]
                        |)
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; A ],
                        M.get_associated_function (|
                          Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; A ],
                          "from_ptr_in",
                          [],
                          []
                        |),
                        [ M.read (| ptr |); M.read (| alloc |) ]
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_from_box_in :
      forall (T A : Ty.t),
      M.IsAssociatedFunction.C (Self T A) "from_box_in" (from_box_in T A).
    Admitted.
    Global Typeclasses Opaque from_box_in.
    (*
        pub fn make_mut(this: &mut Self) -> &mut T {
            let size_of_val = mem::size_of_val::<T>(&**this);
    
            // Note that we hold both a strong reference and a weak reference.
            // Thus, releasing our strong reference only will not, by itself, cause
            // the memory to be deallocated.
            //
            // Use Acquire to ensure that we see any writes to `weak` that happen
            // before release writes (i.e., decrements) to `strong`. Since we hold a
            // weak count, there's no chance the ArcInner itself could be
            // deallocated.
            if this.inner().strong.compare_exchange(1, 0, Acquire, Relaxed).is_err() {
                // Another strong pointer exists, so we must clone.
    
                let this_data_ref: &T = &**this;
                // `in_progress` drops the allocation if we panic before finishing initializing it.
                let mut in_progress: UniqueArcUninit<T, A> =
                    UniqueArcUninit::new(this_data_ref, this.alloc.clone());
    
                let initialized_clone = unsafe {
                    // Clone. If the clone panics, `in_progress` will be dropped and clean up.
                    this_data_ref.clone_to_uninit(in_progress.data_ptr().cast());
                    // Cast type of pointer, now that it is initialized.
                    in_progress.into_arc()
                };
                *this = initialized_clone;
            } else if this.inner().weak.load(Relaxed) != 1 {
                // Relaxed suffices in the above because this is fundamentally an
                // optimization: we are always racing with weak pointers being
                // dropped. Worst case, we end up allocated a new Arc unnecessarily.
    
                // We removed the last strong ref, but there are additional weak
                // refs remaining. We'll move the contents to a new Arc, and
                // invalidate the other weak refs.
    
                // Note that it is not possible for the read of `weak` to yield
                // usize::MAX (i.e., locked), since the weak count can only be
                // locked by a thread with a strong reference.
    
                // Materialize our own implicit weak pointer, so that it can clean
                // up the ArcInner as needed.
                let _weak = Weak { ptr: this.ptr, alloc: this.alloc.clone() };
    
                // Can just steal the data, all that's left is Weaks
                //
                // We don't need panic-protection like the above branch does, but we might as well
                // use the same mechanism.
                let mut in_progress: UniqueArcUninit<T, A> =
                    UniqueArcUninit::new(&**this, this.alloc.clone());
                unsafe {
                    // Initialize `in_progress` with move of **this.
                    // We have to express this in terms of bytes because `T: ?Sized`; there is no
                    // operation that just copies a value based on its `size_of_val()`.
                    ptr::copy_nonoverlapping(
                        ptr::from_ref(&**this).cast::<u8>(),
                        in_progress.data_ptr().cast::<u8>(),
                        size_of_val,
                    );
    
                    ptr::write(this, in_progress.into_arc());
                }
            } else {
                // We were the sole reference of either kind; bump back up the
                // strong ref count.
                this.inner().strong.store(1, Release);
            }
    
            // As with `get_mut()`, the unsafety is ok because our reference was
            // either unique to begin with, or became one upon cloning the contents.
            unsafe { Self::get_mut_unchecked(this) }
        }
    *)
    Definition make_mut (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ this ] =>
        ltac:(M.monadic
          (let this := M.alloc (| this |) in
          M.borrow (|
            Pointer.Kind.MutRef,
            M.deref (|
              M.read (|
                let~ size_of_val : Ty.apply (Ty.path "*") [] [ Ty.path "usize" ] :=
                  M.alloc (|
                    M.call_closure (|
                      Ty.path "usize",
                      M.get_function (| "core::mem::size_of_val", [], [ T ] |),
                      [
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.deref (|
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.deref (|
                                M.call_closure (|
                                  Ty.apply (Ty.path "&") [] [ T ],
                                  M.get_trait_method (|
                                    "core::ops::deref::Deref",
                                    Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; A ],
                                    [],
                                    [],
                                    "deref",
                                    [],
                                    []
                                  |),
                                  [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| this |) |) |)
                                  ]
                                |)
                              |)
                            |)
                          |)
                        |)
                      ]
                    |)
                  |) in
                let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                  M.match_operator (|
                    Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                M.call_closure (|
                                  Ty.path "bool",
                                  M.get_associated_function (|
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [ Ty.path "usize"; Ty.path "usize" ],
                                    "is_err",
                                    [],
                                    []
                                  |),
                                  [
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.alloc (|
                                        M.call_closure (|
                                          Ty.apply
                                            (Ty.path "core::result::Result")
                                            []
                                            [ Ty.path "usize"; Ty.path "usize" ],
                                          M.get_associated_function (|
                                            Ty.path "core::sync::atomic::AtomicUsize",
                                            "compare_exchange",
                                            [],
                                            []
                                          |),
                                          [
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.SubPointer.get_struct_record_field (|
                                                M.deref (|
                                                  M.call_closure (|
                                                    Ty.apply
                                                      (Ty.path "&")
                                                      []
                                                      [
                                                        Ty.apply
                                                          (Ty.path "alloc::sync::ArcInner")
                                                          []
                                                          [ T ]
                                                      ],
                                                    M.get_associated_function (|
                                                      Ty.apply
                                                        (Ty.path "alloc::sync::Arc")
                                                        []
                                                        [ T; A ],
                                                      "inner",
                                                      [],
                                                      []
                                                    |),
                                                    [
                                                      M.borrow (|
                                                        Pointer.Kind.Ref,
                                                        M.deref (| M.read (| this |) |)
                                                      |)
                                                    ]
                                                  |)
                                                |),
                                                "alloc::sync::ArcInner",
                                                "strong"
                                              |)
                                            |);
                                            Value.Integer IntegerKind.Usize 1;
                                            Value.Integer IntegerKind.Usize 0;
                                            Value.StructTuple
                                              "core::sync::atomic::Ordering::Acquire"
                                              [];
                                            Value.StructTuple
                                              "core::sync::atomic::Ordering::Relaxed"
                                              []
                                          ]
                                        |)
                                      |)
                                    |)
                                  ]
                                |)
                              |)) in
                          let _ :=
                            is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          let~ this_data_ref :
                              Ty.apply (Ty.path "*") [] [ Ty.apply (Ty.path "&") [] [ T ] ] :=
                            M.alloc (|
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (|
                                      M.call_closure (|
                                        Ty.apply (Ty.path "&") [] [ T ],
                                        M.get_trait_method (|
                                          "core::ops::deref::Deref",
                                          Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; A ],
                                          [],
                                          [],
                                          "deref",
                                          [],
                                          []
                                        |),
                                        [
                                          M.borrow (|
                                            Pointer.Kind.Ref,
                                            M.deref (| M.read (| this |) |)
                                          |)
                                        ]
                                      |)
                                    |)
                                  |)
                                |)
                              |)
                            |) in
                          let~ in_progress :
                              Ty.apply
                                (Ty.path "*")
                                []
                                [ Ty.apply (Ty.path "alloc::sync::UniqueArcUninit") [] [ T; A ] ] :=
                            M.alloc (|
                              M.call_closure (|
                                Ty.apply (Ty.path "alloc::sync::UniqueArcUninit") [] [ T; A ],
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "alloc::sync::UniqueArcUninit") [] [ T; A ],
                                  "new",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (| M.read (| this_data_ref |) |)
                                  |);
                                  M.call_closure (|
                                    A,
                                    M.get_trait_method (|
                                      "core::clone::Clone",
                                      A,
                                      [],
                                      [],
                                      "clone",
                                      [],
                                      []
                                    |),
                                    [
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.SubPointer.get_struct_record_field (|
                                          M.deref (| M.read (| this |) |),
                                          "alloc::sync::Arc",
                                          "alloc"
                                        |)
                                      |)
                                    ]
                                  |)
                                ]
                              |)
                            |) in
                          let~ initialized_clone :
                              Ty.apply
                                (Ty.path "*")
                                []
                                [ Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; A ] ] :=
                            M.copy (|
                              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                                M.alloc (|
                                  M.call_closure (|
                                    Ty.tuple [],
                                    M.get_trait_method (|
                                      "core::clone::CloneToUninit",
                                      T,
                                      [],
                                      [],
                                      "clone_to_uninit",
                                      [],
                                      []
                                    |),
                                    [
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.deref (| M.read (| this_data_ref |) |)
                                      |);
                                      M.call_closure (|
                                        Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ],
                                        M.get_associated_function (|
                                          Ty.apply (Ty.path "*mut") [] [ T ],
                                          "cast",
                                          [],
                                          [ Ty.path "u8" ]
                                        |),
                                        [
                                          M.call_closure (|
                                            Ty.apply (Ty.path "*mut") [] [ T ],
                                            M.get_associated_function (|
                                              Ty.apply
                                                (Ty.path "alloc::sync::UniqueArcUninit")
                                                []
                                                [ T; A ],
                                              "data_ptr",
                                              [],
                                              []
                                            |),
                                            [ M.borrow (| Pointer.Kind.MutRef, in_progress |) ]
                                          |)
                                        ]
                                      |)
                                    ]
                                  |)
                                |) in
                              M.alloc (|
                                M.call_closure (|
                                  Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; A ],
                                  M.get_associated_function (|
                                    Ty.apply (Ty.path "alloc::sync::UniqueArcUninit") [] [ T; A ],
                                    "into_arc",
                                    [],
                                    []
                                  |),
                                  [ M.read (| in_progress |) ]
                                |)
                              |)
                            |) in
                          let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                            M.alloc (|
                              M.write (|
                                M.deref (| M.read (| this |) |),
                                M.read (| initialized_clone |)
                              |)
                            |) in
                          M.alloc (| Value.Tuple [] |)));
                      fun γ =>
                        ltac:(M.monadic
                          (M.match_operator (|
                            Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                            M.alloc (| Value.Tuple [] |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ :=
                                    M.use
                                      (M.alloc (|
                                        M.call_closure (|
                                          Ty.path "bool",
                                          BinOp.ne,
                                          [
                                            M.call_closure (|
                                              Ty.path "usize",
                                              M.get_associated_function (|
                                                Ty.path "core::sync::atomic::AtomicUsize",
                                                "load",
                                                [],
                                                []
                                              |),
                                              [
                                                M.borrow (|
                                                  Pointer.Kind.Ref,
                                                  M.SubPointer.get_struct_record_field (|
                                                    M.deref (|
                                                      M.call_closure (|
                                                        Ty.apply
                                                          (Ty.path "&")
                                                          []
                                                          [
                                                            Ty.apply
                                                              (Ty.path "alloc::sync::ArcInner")
                                                              []
                                                              [ T ]
                                                          ],
                                                        M.get_associated_function (|
                                                          Ty.apply
                                                            (Ty.path "alloc::sync::Arc")
                                                            []
                                                            [ T; A ],
                                                          "inner",
                                                          [],
                                                          []
                                                        |),
                                                        [
                                                          M.borrow (|
                                                            Pointer.Kind.Ref,
                                                            M.deref (| M.read (| this |) |)
                                                          |)
                                                        ]
                                                      |)
                                                    |),
                                                    "alloc::sync::ArcInner",
                                                    "weak"
                                                  |)
                                                |);
                                                Value.StructTuple
                                                  "core::sync::atomic::Ordering::Relaxed"
                                                  []
                                              ]
                                            |);
                                            Value.Integer IntegerKind.Usize 1
                                          ]
                                        |)
                                      |)) in
                                  let _ :=
                                    is_constant_or_break_match (|
                                      M.read (| γ |),
                                      Value.Bool true
                                    |) in
                                  let~ _weak :
                                      Ty.apply
                                        (Ty.path "*")
                                        []
                                        [ Ty.apply (Ty.path "alloc::sync::Weak") [] [ T; A ] ] :=
                                    M.alloc (|
                                      Value.StructRecord
                                        "alloc::sync::Weak"
                                        [
                                          ("ptr",
                                            M.read (|
                                              M.SubPointer.get_struct_record_field (|
                                                M.deref (| M.read (| this |) |),
                                                "alloc::sync::Arc",
                                                "ptr"
                                              |)
                                            |));
                                          ("alloc",
                                            M.call_closure (|
                                              A,
                                              M.get_trait_method (|
                                                "core::clone::Clone",
                                                A,
                                                [],
                                                [],
                                                "clone",
                                                [],
                                                []
                                              |),
                                              [
                                                M.borrow (|
                                                  Pointer.Kind.Ref,
                                                  M.SubPointer.get_struct_record_field (|
                                                    M.deref (| M.read (| this |) |),
                                                    "alloc::sync::Arc",
                                                    "alloc"
                                                  |)
                                                |)
                                              ]
                                            |))
                                        ]
                                    |) in
                                  let~ in_progress :
                                      Ty.apply
                                        (Ty.path "*")
                                        []
                                        [
                                          Ty.apply
                                            (Ty.path "alloc::sync::UniqueArcUninit")
                                            []
                                            [ T; A ]
                                        ] :=
                                    M.alloc (|
                                      M.call_closure (|
                                        Ty.apply
                                          (Ty.path "alloc::sync::UniqueArcUninit")
                                          []
                                          [ T; A ],
                                        M.get_associated_function (|
                                          Ty.apply
                                            (Ty.path "alloc::sync::UniqueArcUninit")
                                            []
                                            [ T; A ],
                                          "new",
                                          [],
                                          []
                                        |),
                                        [
                                          M.borrow (|
                                            Pointer.Kind.Ref,
                                            M.deref (|
                                              M.borrow (|
                                                Pointer.Kind.Ref,
                                                M.deref (|
                                                  M.call_closure (|
                                                    Ty.apply (Ty.path "&") [] [ T ],
                                                    M.get_trait_method (|
                                                      "core::ops::deref::Deref",
                                                      Ty.apply
                                                        (Ty.path "alloc::sync::Arc")
                                                        []
                                                        [ T; A ],
                                                      [],
                                                      [],
                                                      "deref",
                                                      [],
                                                      []
                                                    |),
                                                    [
                                                      M.borrow (|
                                                        Pointer.Kind.Ref,
                                                        M.deref (| M.read (| this |) |)
                                                      |)
                                                    ]
                                                  |)
                                                |)
                                              |)
                                            |)
                                          |);
                                          M.call_closure (|
                                            A,
                                            M.get_trait_method (|
                                              "core::clone::Clone",
                                              A,
                                              [],
                                              [],
                                              "clone",
                                              [],
                                              []
                                            |),
                                            [
                                              M.borrow (|
                                                Pointer.Kind.Ref,
                                                M.SubPointer.get_struct_record_field (|
                                                  M.deref (| M.read (| this |) |),
                                                  "alloc::sync::Arc",
                                                  "alloc"
                                                |)
                                              |)
                                            ]
                                          |)
                                        ]
                                      |)
                                    |) in
                                  let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                                    M.alloc (|
                                      M.call_closure (|
                                        Ty.tuple [],
                                        M.get_function (|
                                          "core::intrinsics::copy_nonoverlapping",
                                          [],
                                          [ Ty.path "u8" ]
                                        |),
                                        [
                                          M.call_closure (|
                                            Ty.apply (Ty.path "*const") [] [ Ty.path "u8" ],
                                            M.get_associated_function (|
                                              Ty.apply (Ty.path "*const") [] [ T ],
                                              "cast",
                                              [],
                                              [ Ty.path "u8" ]
                                            |),
                                            [
                                              M.call_closure (|
                                                Ty.apply (Ty.path "*const") [] [ T ],
                                                M.get_function (|
                                                  "core::ptr::from_ref",
                                                  [],
                                                  [ T ]
                                                |),
                                                [
                                                  M.borrow (|
                                                    Pointer.Kind.Ref,
                                                    M.deref (|
                                                      M.borrow (|
                                                        Pointer.Kind.Ref,
                                                        M.deref (|
                                                          M.call_closure (|
                                                            Ty.apply (Ty.path "&") [] [ T ],
                                                            M.get_trait_method (|
                                                              "core::ops::deref::Deref",
                                                              Ty.apply
                                                                (Ty.path "alloc::sync::Arc")
                                                                []
                                                                [ T; A ],
                                                              [],
                                                              [],
                                                              "deref",
                                                              [],
                                                              []
                                                            |),
                                                            [
                                                              M.borrow (|
                                                                Pointer.Kind.Ref,
                                                                M.deref (| M.read (| this |) |)
                                                              |)
                                                            ]
                                                          |)
                                                        |)
                                                      |)
                                                    |)
                                                  |)
                                                ]
                                              |)
                                            ]
                                          |);
                                          M.call_closure (|
                                            Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ],
                                            M.get_associated_function (|
                                              Ty.apply (Ty.path "*mut") [] [ T ],
                                              "cast",
                                              [],
                                              [ Ty.path "u8" ]
                                            |),
                                            [
                                              M.call_closure (|
                                                Ty.apply (Ty.path "*mut") [] [ T ],
                                                M.get_associated_function (|
                                                  Ty.apply
                                                    (Ty.path "alloc::sync::UniqueArcUninit")
                                                    []
                                                    [ T; A ],
                                                  "data_ptr",
                                                  [],
                                                  []
                                                |),
                                                [ M.borrow (| Pointer.Kind.MutRef, in_progress |) ]
                                              |)
                                            ]
                                          |);
                                          M.read (| size_of_val |)
                                        ]
                                      |)
                                    |) in
                                  let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                                    M.alloc (|
                                      M.call_closure (|
                                        Ty.tuple [],
                                        M.get_function (|
                                          "core::ptr::write",
                                          [],
                                          [ Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; A ] ]
                                        |),
                                        [
                                          M.borrow (|
                                            Pointer.Kind.MutPointer,
                                            M.deref (| M.read (| this |) |)
                                          |);
                                          M.call_closure (|
                                            Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; A ],
                                            M.get_associated_function (|
                                              Ty.apply
                                                (Ty.path "alloc::sync::UniqueArcUninit")
                                                []
                                                [ T; A ],
                                              "into_arc",
                                              [],
                                              []
                                            |),
                                            [ M.read (| in_progress |) ]
                                          |)
                                        ]
                                      |)
                                    |) in
                                  M.alloc (| Value.Tuple [] |)));
                              fun γ =>
                                ltac:(M.monadic
                                  (let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                                    M.alloc (|
                                      M.call_closure (|
                                        Ty.tuple [],
                                        M.get_associated_function (|
                                          Ty.path "core::sync::atomic::AtomicUsize",
                                          "store",
                                          [],
                                          []
                                        |),
                                        [
                                          M.borrow (|
                                            Pointer.Kind.Ref,
                                            M.SubPointer.get_struct_record_field (|
                                              M.deref (|
                                                M.call_closure (|
                                                  Ty.apply
                                                    (Ty.path "&")
                                                    []
                                                    [
                                                      Ty.apply
                                                        (Ty.path "alloc::sync::ArcInner")
                                                        []
                                                        [ T ]
                                                    ],
                                                  M.get_associated_function (|
                                                    Ty.apply
                                                      (Ty.path "alloc::sync::Arc")
                                                      []
                                                      [ T; A ],
                                                    "inner",
                                                    [],
                                                    []
                                                  |),
                                                  [
                                                    M.borrow (|
                                                      Pointer.Kind.Ref,
                                                      M.deref (| M.read (| this |) |)
                                                    |)
                                                  ]
                                                |)
                                              |),
                                              "alloc::sync::ArcInner",
                                              "strong"
                                            |)
                                          |);
                                          Value.Integer IntegerKind.Usize 1;
                                          Value.StructTuple
                                            "core::sync::atomic::Ordering::Release"
                                            []
                                        ]
                                      |)
                                    |) in
                                  M.alloc (| Value.Tuple [] |)))
                            ]
                          |)))
                    ]
                  |) in
                M.alloc (|
                  M.borrow (|
                    Pointer.Kind.MutRef,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.MutRef,
                        M.deref (|
                          M.call_closure (|
                            Ty.apply (Ty.path "&mut") [] [ T ],
                            M.get_associated_function (|
                              Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; A ],
                              "get_mut_unchecked",
                              [],
                              []
                            |),
                            [ M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| this |) |) |) ]
                          |)
                        |)
                      |)
                    |)
                  |)
                |)
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_make_mut :
      forall (T A : Ty.t),
      M.IsAssociatedFunction.C (Self T A) "make_mut" (make_mut T A).
    Admitted.
    Global Typeclasses Opaque make_mut.
    (*
        pub fn unwrap_or_clone(this: Self) -> T {
            Arc::try_unwrap(this).unwrap_or_else(|arc| ( *arc).clone())
        }
    *)
    Definition unwrap_or_clone
        (T A : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ this ] =>
        ltac:(M.monadic
          (let this := M.alloc (| this |) in
          M.call_closure (|
            T,
            M.get_associated_function (|
              Ty.apply
                (Ty.path "core::result::Result")
                []
                [ T; Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; A ] ],
              "unwrap_or_else",
              [],
              [ Ty.function [ Ty.tuple [ Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; A ] ] ] T ]
            |),
            [
              M.call_closure (|
                Ty.apply
                  (Ty.path "core::result::Result")
                  []
                  [ T; Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; A ] ],
                M.get_associated_function (|
                  Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; A ],
                  "try_unwrap",
                  [],
                  []
                |),
                [ M.read (| this |) ]
              |);
              M.closure
                (fun γ =>
                  ltac:(M.monadic
                    match γ with
                    | [ α0 ] =>
                      ltac:(M.monadic
                        (M.match_operator (|
                          Ty.apply
                            (Ty.path "*")
                            []
                            [
                              Ty.function
                                [ Ty.tuple [ Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; A ] ] ]
                                T
                            ],
                          M.alloc (| α0 |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let arc := M.copy (| γ |) in
                                M.call_closure (|
                                  T,
                                  M.get_trait_method (|
                                    "core::clone::Clone",
                                    T,
                                    [],
                                    [],
                                    "clone",
                                    [],
                                    []
                                  |),
                                  [
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.deref (|
                                        M.call_closure (|
                                          Ty.apply (Ty.path "&") [] [ T ],
                                          M.get_trait_method (|
                                            "core::ops::deref::Deref",
                                            Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; A ],
                                            [],
                                            [],
                                            "deref",
                                            [],
                                            []
                                          |),
                                          [ M.borrow (| Pointer.Kind.Ref, arc |) ]
                                        |)
                                      |)
                                    |)
                                  ]
                                |)))
                          ]
                        |)))
                    | _ => M.impossible "wrong number of arguments"
                    end))
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_unwrap_or_clone :
      forall (T A : Ty.t),
      M.IsAssociatedFunction.C (Self T A) "unwrap_or_clone" (unwrap_or_clone T A).
    Admitted.
    Global Typeclasses Opaque unwrap_or_clone.
    (*
        pub fn get_mut(this: &mut Self) -> Option<&mut T> {
            if this.is_unique() {
                // This unsafety is ok because we're guaranteed that the pointer
                // returned is the *only* pointer that will ever be returned to T. Our
                // reference count is guaranteed to be 1 at this point, and we required
                // the Arc itself to be `mut`, so we're returning the only possible
                // reference to the inner data.
                unsafe { Some(Arc::get_mut_unchecked(this)) }
            } else {
                None
            }
        }
    *)
    Definition get_mut (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ this ] =>
        ltac:(M.monadic
          (let this := M.alloc (| this |) in
          M.read (|
            M.match_operator (|
              Ty.apply
                (Ty.path "*")
                []
                [
                  Ty.apply
                    (Ty.path "core::option::Option")
                    []
                    [ Ty.apply (Ty.path "&mut") [] [ T ] ]
                ],
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          M.call_closure (|
                            Ty.path "bool",
                            M.get_associated_function (|
                              Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; A ],
                              "is_unique",
                              [],
                              []
                            |),
                            [ M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| this |) |) |) ]
                          |)
                        |)) in
                    let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::option::Option::Some"
                        [
                          M.borrow (|
                            Pointer.Kind.MutRef,
                            M.deref (|
                              M.call_closure (|
                                Ty.apply (Ty.path "&mut") [] [ T ],
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; A ],
                                  "get_mut_unchecked",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (|
                                    Pointer.Kind.MutRef,
                                    M.deref (| M.read (| this |) |)
                                  |)
                                ]
                              |)
                            |)
                          |)
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic (M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_get_mut :
      forall (T A : Ty.t),
      M.IsAssociatedFunction.C (Self T A) "get_mut" (get_mut T A).
    Admitted.
    Global Typeclasses Opaque get_mut.
    
    (*
        pub unsafe fn get_mut_unchecked(this: &mut Self) -> &mut T {
            // We are careful to *not* create a reference covering the "count" fields, as
            // this would alias with concurrent access to the reference counts (e.g. by `Weak`).
            unsafe { &mut ( *this.ptr.as_ptr()).data }
        }
    *)
    Definition get_mut_unchecked
        (T A : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ this ] =>
        ltac:(M.monadic
          (let this := M.alloc (| this |) in
          M.borrow (|
            Pointer.Kind.MutRef,
            M.deref (|
              M.borrow (|
                Pointer.Kind.MutRef,
                M.deref (|
                  M.borrow (|
                    Pointer.Kind.MutRef,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.MutRef,
                        M.SubPointer.get_struct_record_field (|
                          M.deref (|
                            M.call_closure (|
                              Ty.apply
                                (Ty.path "*mut")
                                []
                                [ Ty.apply (Ty.path "alloc::sync::ArcInner") [] [ T ] ],
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "core::ptr::non_null::NonNull")
                                  []
                                  [ Ty.apply (Ty.path "alloc::sync::ArcInner") [] [ T ] ],
                                "as_ptr",
                                [],
                                []
                              |),
                              [
                                M.read (|
                                  M.SubPointer.get_struct_record_field (|
                                    M.deref (| M.read (| this |) |),
                                    "alloc::sync::Arc",
                                    "ptr"
                                  |)
                                |)
                              ]
                            |)
                          |),
                          "alloc::sync::ArcInner",
                          "data"
                        |)
                      |)
                    |)
                  |)
                |)
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_get_mut_unchecked :
      forall (T A : Ty.t),
      M.IsAssociatedFunction.C (Self T A) "get_mut_unchecked" (get_mut_unchecked T A).
    Admitted.
    Global Typeclasses Opaque get_mut_unchecked.
    
    (*
        fn is_unique(&mut self) -> bool {
            // lock the weak pointer count if we appear to be the sole weak pointer
            // holder.
            //
            // The acquire label here ensures a happens-before relationship with any
            // writes to `strong` (in particular in `Weak::upgrade`) prior to decrements
            // of the `weak` count (via `Weak::drop`, which uses release). If the upgraded
            // weak ref was never dropped, the CAS here will fail so we do not care to synchronize.
            if self.inner().weak.compare_exchange(1, usize::MAX, Acquire, Relaxed).is_ok() {
                // This needs to be an `Acquire` to synchronize with the decrement of the `strong`
                // counter in `drop` -- the only access that happens when any but the last reference
                // is being dropped.
                let unique = self.inner().strong.load(Acquire) == 1;
    
                // The release write here synchronizes with a read in `downgrade`,
                // effectively preventing the above read of `strong` from happening
                // after the write.
                self.inner().weak.store(1, Release); // release the lock
                unique
            } else {
                false
            }
        }
    *)
    Definition is_unique (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              Ty.apply (Ty.path "*") [] [ Ty.path "bool" ],
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          M.call_closure (|
                            Ty.path "bool",
                            M.get_associated_function (|
                              Ty.apply
                                (Ty.path "core::result::Result")
                                []
                                [ Ty.path "usize"; Ty.path "usize" ],
                              "is_ok",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.alloc (|
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [ Ty.path "usize"; Ty.path "usize" ],
                                    M.get_associated_function (|
                                      Ty.path "core::sync::atomic::AtomicUsize",
                                      "compare_exchange",
                                      [],
                                      []
                                    |),
                                    [
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.SubPointer.get_struct_record_field (|
                                          M.deref (|
                                            M.call_closure (|
                                              Ty.apply
                                                (Ty.path "&")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path "alloc::sync::ArcInner")
                                                    []
                                                    [ T ]
                                                ],
                                              M.get_associated_function (|
                                                Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; A ],
                                                "inner",
                                                [],
                                                []
                                              |),
                                              [
                                                M.borrow (|
                                                  Pointer.Kind.Ref,
                                                  M.deref (| M.read (| self |) |)
                                                |)
                                              ]
                                            |)
                                          |),
                                          "alloc::sync::ArcInner",
                                          "weak"
                                        |)
                                      |);
                                      Value.Integer IntegerKind.Usize 1;
                                      M.read (|
                                        get_associated_constant (|
                                          Ty.path "usize",
                                          "MAX",
                                          Ty.path "usize"
                                        |)
                                      |);
                                      Value.StructTuple "core::sync::atomic::Ordering::Acquire" [];
                                      Value.StructTuple "core::sync::atomic::Ordering::Relaxed" []
                                    ]
                                  |)
                                |)
                              |)
                            ]
                          |)
                        |)) in
                    let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    let~ unique : Ty.apply (Ty.path "*") [] [ Ty.path "bool" ] :=
                      M.alloc (|
                        M.call_closure (|
                          Ty.path "bool",
                          BinOp.eq,
                          [
                            M.call_closure (|
                              Ty.path "usize",
                              M.get_associated_function (|
                                Ty.path "core::sync::atomic::AtomicUsize",
                                "load",
                                [],
                                []
                              |),
                              [
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.SubPointer.get_struct_record_field (|
                                    M.deref (|
                                      M.call_closure (|
                                        Ty.apply
                                          (Ty.path "&")
                                          []
                                          [ Ty.apply (Ty.path "alloc::sync::ArcInner") [] [ T ] ],
                                        M.get_associated_function (|
                                          Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; A ],
                                          "inner",
                                          [],
                                          []
                                        |),
                                        [
                                          M.borrow (|
                                            Pointer.Kind.Ref,
                                            M.deref (| M.read (| self |) |)
                                          |)
                                        ]
                                      |)
                                    |),
                                    "alloc::sync::ArcInner",
                                    "strong"
                                  |)
                                |);
                                Value.StructTuple "core::sync::atomic::Ordering::Acquire" []
                              ]
                            |);
                            Value.Integer IntegerKind.Usize 1
                          ]
                        |)
                      |) in
                    let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                      M.alloc (|
                        M.call_closure (|
                          Ty.tuple [],
                          M.get_associated_function (|
                            Ty.path "core::sync::atomic::AtomicUsize",
                            "store",
                            [],
                            []
                          |),
                          [
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.SubPointer.get_struct_record_field (|
                                M.deref (|
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "&")
                                      []
                                      [ Ty.apply (Ty.path "alloc::sync::ArcInner") [] [ T ] ],
                                    M.get_associated_function (|
                                      Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; A ],
                                      "inner",
                                      [],
                                      []
                                    |),
                                    [
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.deref (| M.read (| self |) |)
                                      |)
                                    ]
                                  |)
                                |),
                                "alloc::sync::ArcInner",
                                "weak"
                              |)
                            |);
                            Value.Integer IntegerKind.Usize 1;
                            Value.StructTuple "core::sync::atomic::Ordering::Release" []
                          ]
                        |)
                      |) in
                    unique));
                fun γ => ltac:(M.monadic (M.alloc (| Value.Bool false |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_is_unique :
      forall (T A : Ty.t),
      M.IsAssociatedFunction.C (Self T A) "is_unique" (is_unique T A).
    Admitted.
    Global Typeclasses Opaque is_unique.
  End Impl_alloc_sync_Arc_T_A.
  
  (* StructRecord
    {
      name := "Weak";
      const_params := [];
      ty_params := [ "T"; "A" ];
      fields :=
        [
          ("ptr",
            Ty.apply
              (Ty.path "core::ptr::non_null::NonNull")
              []
              [ Ty.apply (Ty.path "alloc::sync::ArcInner") [] [ T ] ]);
          ("alloc", A)
        ];
    } *)
  
  Module Impl_core_marker_Send_where_core_marker_Sized_T_where_core_marker_Sync_T_where_core_marker_Send_T_where_core_alloc_Allocator_A_where_core_marker_Send_A_for_alloc_sync_Weak_T_A.
    Definition Self (T A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::sync::Weak") [] [ T; A ].
    
    Axiom Implements :
      forall (T A : Ty.t),
      M.IsTraitInstance
        "core::marker::Send"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self T A)
        (* Instance *) [].
  End Impl_core_marker_Send_where_core_marker_Sized_T_where_core_marker_Sync_T_where_core_marker_Send_T_where_core_alloc_Allocator_A_where_core_marker_Send_A_for_alloc_sync_Weak_T_A.
  
  Module Impl_core_marker_Sync_where_core_marker_Sized_T_where_core_marker_Sync_T_where_core_marker_Send_T_where_core_alloc_Allocator_A_where_core_marker_Sync_A_for_alloc_sync_Weak_T_A.
    Definition Self (T A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::sync::Weak") [] [ T; A ].
    
    Axiom Implements :
      forall (T A : Ty.t),
      M.IsTraitInstance
        "core::marker::Sync"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self T A)
        (* Instance *) [].
  End Impl_core_marker_Sync_where_core_marker_Sized_T_where_core_marker_Sync_T_where_core_marker_Send_T_where_core_alloc_Allocator_A_where_core_marker_Sync_A_for_alloc_sync_Weak_T_A.
  
  Module Impl_core_ops_unsize_CoerceUnsized_where_core_marker_Sized_T_where_core_marker_Unsize_T_U_where_core_marker_Sized_U_where_core_alloc_Allocator_A_alloc_sync_Weak_U_A_for_alloc_sync_Weak_T_A.
    Definition Self (T U A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::sync::Weak") [] [ T; A ].
    
    Axiom Implements :
      forall (T U A : Ty.t),
      M.IsTraitInstance
        "core::ops::unsize::CoerceUnsized"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.apply (Ty.path "alloc::sync::Weak") [] [ U; A ] ]
        (Self T U A)
        (* Instance *) [].
  End Impl_core_ops_unsize_CoerceUnsized_where_core_marker_Sized_T_where_core_marker_Unsize_T_U_where_core_marker_Sized_U_where_core_alloc_Allocator_A_alloc_sync_Weak_U_A_for_alloc_sync_Weak_T_A.
  
  Module Impl_core_ops_unsize_DispatchFromDyn_where_core_marker_Sized_T_where_core_marker_Unsize_T_U_where_core_marker_Sized_U_alloc_sync_Weak_U_alloc_alloc_Global_for_alloc_sync_Weak_T_alloc_alloc_Global.
    Definition Self (T U : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "alloc::sync::Weak") [] [ T; Ty.path "alloc::alloc::Global" ].
    
    Axiom Implements :
      forall (T U : Ty.t),
      M.IsTraitInstance
        "core::ops::unsize::DispatchFromDyn"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *)
        [ Ty.apply (Ty.path "alloc::sync::Weak") [] [ U; Ty.path "alloc::alloc::Global" ] ]
        (Self T U)
        (* Instance *) [].
  End Impl_core_ops_unsize_DispatchFromDyn_where_core_marker_Sized_T_where_core_marker_Unsize_T_U_where_core_marker_Sized_U_alloc_sync_Weak_U_alloc_alloc_Global_for_alloc_sync_Weak_T_alloc_alloc_Global.
  
  Module Impl_core_fmt_Debug_where_core_marker_Sized_T_where_core_alloc_Allocator_A_for_alloc_sync_Weak_T_A.
    Definition Self (T A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::sync::Weak") [] [ T; A ].
    
    (*
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            write!(f, "(Weak)")
        }
    *)
    Definition fmt (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "core::result::Result")
              []
              [ Ty.tuple []; Ty.path "core::fmt::Error" ],
            M.get_associated_function (| Ty.path "core::fmt::Formatter", "write_fmt", [], [] |),
            [
              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
              M.call_closure (|
                Ty.path "core::fmt::Arguments",
                M.get_associated_function (|
                  Ty.path "core::fmt::Arguments",
                  "new_const",
                  [ Value.Integer IntegerKind.Usize 1 ],
                  []
                |),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.alloc (| Value.Array [ mk_str (| "(Weak)" |) ] |)
                      |)
                    |)
                  |)
                ]
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (T A : Ty.t),
      M.IsTraitInstance
        "core::fmt::Debug"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self T A)
        (* Instance *) [ ("fmt", InstanceField.Method (fmt T A)) ].
  End Impl_core_fmt_Debug_where_core_marker_Sized_T_where_core_alloc_Allocator_A_for_alloc_sync_Weak_T_A.
  
  (* StructRecord
    {
      name := "ArcInner";
      const_params := [];
      ty_params := [ "T" ];
      fields :=
        [
          ("strong", Ty.path "core::sync::atomic::AtomicUsize");
          ("weak", Ty.path "core::sync::atomic::AtomicUsize");
          ("data", T)
        ];
    } *)
  
  (*
  fn arcinner_layout_for_value_layout(layout: Layout) -> Layout {
      // Calculate layout using the given value layout.
      // Previously, layout was calculated on the expression
      // `&*(ptr as *const ArcInner<T>)`, but this created a misaligned
      // reference (see #54908).
      Layout::new::<ArcInner<()>>().extend(layout).unwrap().0.pad_to_align()
  }
  *)
  Definition arcinner_layout_for_value_layout
      (ε : list Value.t)
      (τ : list Ty.t)
      (α : list Value.t)
      : M :=
    match ε, τ, α with
    | [], [], [ layout ] =>
      ltac:(M.monadic
        (let layout := M.alloc (| layout |) in
        M.call_closure (|
          Ty.path "core::alloc::layout::Layout",
          M.get_associated_function (|
            Ty.path "core::alloc::layout::Layout",
            "pad_to_align",
            [],
            []
          |),
          [
            M.borrow (|
              Pointer.Kind.Ref,
              M.SubPointer.get_tuple_field (|
                M.alloc (|
                  M.call_closure (|
                    Ty.tuple [ Ty.path "core::alloc::layout::Layout"; Ty.path "usize" ],
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "core::result::Result")
                        []
                        [
                          Ty.tuple [ Ty.path "core::alloc::layout::Layout"; Ty.path "usize" ];
                          Ty.path "core::alloc::layout::LayoutError"
                        ],
                      "unwrap",
                      [],
                      []
                    |),
                    [
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [
                            Ty.tuple [ Ty.path "core::alloc::layout::Layout"; Ty.path "usize" ];
                            Ty.path "core::alloc::layout::LayoutError"
                          ],
                        M.get_associated_function (|
                          Ty.path "core::alloc::layout::Layout",
                          "extend",
                          [],
                          []
                        |),
                        [
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.alloc (|
                              M.call_closure (|
                                Ty.path "core::alloc::layout::Layout",
                                M.get_associated_function (|
                                  Ty.path "core::alloc::layout::Layout",
                                  "new",
                                  [],
                                  [ Ty.apply (Ty.path "alloc::sync::ArcInner") [] [ Ty.tuple [] ] ]
                                |),
                                []
                              |)
                            |)
                          |);
                          M.read (| layout |)
                        ]
                      |)
                    ]
                  |)
                |),
                0
              |)
            |)
          ]
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_arcinner_layout_for_value_layout :
    M.IsFunction.C "alloc::sync::arcinner_layout_for_value_layout" arcinner_layout_for_value_layout.
  Admitted.
  Global Typeclasses Opaque arcinner_layout_for_value_layout.
  
  Module Impl_core_marker_Send_where_core_marker_Sized_T_where_core_marker_Sync_T_where_core_marker_Send_T_for_alloc_sync_ArcInner_T.
    Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::sync::ArcInner") [] [ T ].
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "core::marker::Send"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self T)
        (* Instance *) [].
  End Impl_core_marker_Send_where_core_marker_Sized_T_where_core_marker_Sync_T_where_core_marker_Send_T_for_alloc_sync_ArcInner_T.
  
  Module Impl_core_marker_Sync_where_core_marker_Sized_T_where_core_marker_Sync_T_where_core_marker_Send_T_for_alloc_sync_ArcInner_T.
    Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::sync::ArcInner") [] [ T ].
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "core::marker::Sync"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self T)
        (* Instance *) [].
  End Impl_core_marker_Sync_where_core_marker_Sized_T_where_core_marker_Sync_T_where_core_marker_Send_T_for_alloc_sync_ArcInner_T.
  
  
  
  Module Impl_alloc_sync_Arc_slice_T_alloc_alloc_Global.
    Definition Self (T : Ty.t) : Ty.t :=
      Ty.apply
        (Ty.path "alloc::sync::Arc")
        []
        [ Ty.apply (Ty.path "slice") [] [ T ]; Ty.path "alloc::alloc::Global" ].
    
    (*
        pub fn new_uninit_slice(len: usize) -> Arc<[mem::MaybeUninit<T>]> {
            unsafe { Arc::from_ptr(Arc::allocate_for_slice(len)) }
        }
    *)
    Definition new_uninit_slice
        (T : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [], [ len ] =>
        ltac:(M.monadic
          (let len := M.alloc (| len |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "alloc::sync::Arc")
              []
              [
                Ty.apply
                  (Ty.path "slice")
                  []
                  [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ] ];
                Ty.path "alloc::alloc::Global"
              ],
            M.get_associated_function (|
              Ty.apply
                (Ty.path "alloc::sync::Arc")
                []
                [
                  Ty.apply
                    (Ty.path "slice")
                    []
                    [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ] ];
                  Ty.path "alloc::alloc::Global"
                ],
              "from_ptr",
              [],
              []
            |),
            [
              M.call_closure (|
                Ty.apply
                  (Ty.path "*mut")
                  []
                  [
                    Ty.apply
                      (Ty.path "alloc::sync::ArcInner")
                      []
                      [
                        Ty.apply
                          (Ty.path "slice")
                          []
                          [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ] ]
                      ]
                  ],
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "alloc::sync::Arc")
                    []
                    [
                      Ty.apply
                        (Ty.path "slice")
                        []
                        [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ] ];
                      Ty.path "alloc::alloc::Global"
                    ],
                  "allocate_for_slice",
                  [],
                  []
                |),
                [ M.read (| len |) ]
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_new_uninit_slice :
      forall (T : Ty.t),
      M.IsAssociatedFunction.C (Self T) "new_uninit_slice" (new_uninit_slice T).
    Admitted.
    Global Typeclasses Opaque new_uninit_slice.
    
    (*
        pub fn new_zeroed_slice(len: usize) -> Arc<[mem::MaybeUninit<T>]> {
            unsafe {
                Arc::from_ptr(Arc::allocate_for_layout(
                    Layout::array::<T>(len).unwrap(),
                    |layout| Global.allocate_zeroed(layout),
                    |mem| {
                        ptr::slice_from_raw_parts_mut(mem as *mut T, len)
                            as *mut ArcInner<[mem::MaybeUninit<T>]>
                    },
                ))
            }
        }
    *)
    Definition new_zeroed_slice
        (T : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [], [ len ] =>
        ltac:(M.monadic
          (let len := M.alloc (| len |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "alloc::sync::Arc")
              []
              [
                Ty.apply
                  (Ty.path "slice")
                  []
                  [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ] ];
                Ty.path "alloc::alloc::Global"
              ],
            M.get_associated_function (|
              Ty.apply
                (Ty.path "alloc::sync::Arc")
                []
                [
                  Ty.apply
                    (Ty.path "slice")
                    []
                    [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ] ];
                  Ty.path "alloc::alloc::Global"
                ],
              "from_ptr",
              [],
              []
            |),
            [
              M.call_closure (|
                Ty.apply
                  (Ty.path "*mut")
                  []
                  [
                    Ty.apply
                      (Ty.path "alloc::sync::ArcInner")
                      []
                      [
                        Ty.apply
                          (Ty.path "slice")
                          []
                          [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ] ]
                      ]
                  ],
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "alloc::sync::Arc")
                    []
                    [
                      Ty.apply
                        (Ty.path "slice")
                        []
                        [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ] ];
                      Ty.path "alloc::alloc::Global"
                    ],
                  "allocate_for_layout",
                  [],
                  [
                    Ty.function
                      [ Ty.tuple [ Ty.path "core::alloc::layout::Layout" ] ]
                      (Ty.apply
                        (Ty.path "core::result::Result")
                        []
                        [
                          Ty.apply
                            (Ty.path "core::ptr::non_null::NonNull")
                            []
                            [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ];
                          Ty.path "core::alloc::AllocError"
                        ]);
                    Ty.function
                      [ Ty.tuple [ Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ] ] ]
                      (Ty.apply
                        (Ty.path "*mut")
                        []
                        [
                          Ty.apply
                            (Ty.path "alloc::sync::ArcInner")
                            []
                            [
                              Ty.apply
                                (Ty.path "slice")
                                []
                                [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ]
                                ]
                            ]
                        ])
                  ]
                |),
                [
                  M.call_closure (|
                    Ty.path "core::alloc::layout::Layout",
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "core::result::Result")
                        []
                        [
                          Ty.path "core::alloc::layout::Layout";
                          Ty.path "core::alloc::layout::LayoutError"
                        ],
                      "unwrap",
                      [],
                      []
                    |),
                    [
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [
                            Ty.path "core::alloc::layout::Layout";
                            Ty.path "core::alloc::layout::LayoutError"
                          ],
                        M.get_associated_function (|
                          Ty.path "core::alloc::layout::Layout",
                          "array",
                          [],
                          [ T ]
                        |),
                        [ M.read (| len |) ]
                      |)
                    ]
                  |);
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0 ] =>
                          ltac:(M.monadic
                            (M.match_operator (|
                              Ty.apply
                                (Ty.path "*")
                                []
                                [
                                  Ty.function
                                    [ Ty.tuple [ Ty.path "core::alloc::layout::Layout" ] ]
                                    (Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [
                                        Ty.apply
                                          (Ty.path "core::ptr::non_null::NonNull")
                                          []
                                          [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ];
                                        Ty.path "core::alloc::AllocError"
                                      ])
                                ],
                              M.alloc (| α0 |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let layout := M.copy (| γ |) in
                                    M.call_closure (|
                                      Ty.apply
                                        (Ty.path "core::result::Result")
                                        []
                                        [
                                          Ty.apply
                                            (Ty.path "core::ptr::non_null::NonNull")
                                            []
                                            [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ];
                                          Ty.path "core::alloc::AllocError"
                                        ],
                                      M.get_trait_method (|
                                        "core::alloc::Allocator",
                                        Ty.path "alloc::alloc::Global",
                                        [],
                                        [],
                                        "allocate_zeroed",
                                        [],
                                        []
                                      |),
                                      [
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.alloc (| Value.StructTuple "alloc::alloc::Global" [] |)
                                        |);
                                        M.read (| layout |)
                                      ]
                                    |)))
                              ]
                            |)))
                        | _ => M.impossible "wrong number of arguments"
                        end));
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0 ] =>
                          ltac:(M.monadic
                            (M.match_operator (|
                              Ty.apply
                                (Ty.path "*")
                                []
                                [
                                  Ty.function
                                    [ Ty.tuple [ Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ] ] ]
                                    (Ty.apply
                                      (Ty.path "*mut")
                                      []
                                      [
                                        Ty.apply
                                          (Ty.path "alloc::sync::ArcInner")
                                          []
                                          [
                                            Ty.apply
                                              (Ty.path "slice")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                                  []
                                                  [ T ]
                                              ]
                                          ]
                                      ])
                                ],
                              M.alloc (| α0 |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let mem := M.copy (| γ |) in
                                    M.cast
                                      (Ty.apply
                                        (Ty.path "*mut")
                                        []
                                        [
                                          Ty.apply
                                            (Ty.path "alloc::sync::ArcInner")
                                            []
                                            [
                                              Ty.apply
                                                (Ty.path "slice")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                                    []
                                                    [ T ]
                                                ]
                                            ]
                                        ])
                                      (M.call_closure (|
                                        Ty.apply
                                          (Ty.path "*mut")
                                          []
                                          [ Ty.apply (Ty.path "slice") [] [ T ] ],
                                        M.get_function (|
                                          "core::ptr::slice_from_raw_parts_mut",
                                          [],
                                          [ T ]
                                        |),
                                        [
                                          M.cast
                                            (Ty.apply (Ty.path "*mut") [] [ T ])
                                            (M.read (| mem |));
                                          M.read (| len |)
                                        ]
                                      |))))
                              ]
                            |)))
                        | _ => M.impossible "wrong number of arguments"
                        end))
                ]
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_new_zeroed_slice :
      forall (T : Ty.t),
      M.IsAssociatedFunction.C (Self T) "new_zeroed_slice" (new_zeroed_slice T).
    Admitted.
    Global Typeclasses Opaque new_zeroed_slice.
    (*
        unsafe fn allocate_for_slice(len: usize) -> *mut ArcInner<[T]> {
            unsafe {
                Self::allocate_for_layout(
                    Layout::array::<T>(len).unwrap(),
                    |layout| Global.allocate(layout),
                    |mem| ptr::slice_from_raw_parts_mut(mem.cast::<T>(), len) as *mut ArcInner<[T]>,
                )
            }
        }
    *)
    Definition allocate_for_slice
        (T : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [], [ len ] =>
        ltac:(M.monadic
          (let len := M.alloc (| len |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "*mut")
              []
              [
                Ty.apply
                  (Ty.path "alloc::sync::ArcInner")
                  []
                  [ Ty.apply (Ty.path "slice") [] [ T ] ]
              ],
            M.get_associated_function (|
              Ty.apply
                (Ty.path "alloc::sync::Arc")
                []
                [ Ty.apply (Ty.path "slice") [] [ T ]; Ty.path "alloc::alloc::Global" ],
              "allocate_for_layout",
              [],
              [
                Ty.function
                  [ Ty.tuple [ Ty.path "core::alloc::layout::Layout" ] ]
                  (Ty.apply
                    (Ty.path "core::result::Result")
                    []
                    [
                      Ty.apply
                        (Ty.path "core::ptr::non_null::NonNull")
                        []
                        [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ];
                      Ty.path "core::alloc::AllocError"
                    ]);
                Ty.function
                  [ Ty.tuple [ Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ] ] ]
                  (Ty.apply
                    (Ty.path "*mut")
                    []
                    [
                      Ty.apply
                        (Ty.path "alloc::sync::ArcInner")
                        []
                        [ Ty.apply (Ty.path "slice") [] [ T ] ]
                    ])
              ]
            |),
            [
              M.call_closure (|
                Ty.path "core::alloc::layout::Layout",
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "core::result::Result")
                    []
                    [
                      Ty.path "core::alloc::layout::Layout";
                      Ty.path "core::alloc::layout::LayoutError"
                    ],
                  "unwrap",
                  [],
                  []
                |),
                [
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "core::result::Result")
                      []
                      [
                        Ty.path "core::alloc::layout::Layout";
                        Ty.path "core::alloc::layout::LayoutError"
                      ],
                    M.get_associated_function (|
                      Ty.path "core::alloc::layout::Layout",
                      "array",
                      [],
                      [ T ]
                    |),
                    [ M.read (| len |) ]
                  |)
                ]
              |);
              M.closure
                (fun γ =>
                  ltac:(M.monadic
                    match γ with
                    | [ α0 ] =>
                      ltac:(M.monadic
                        (M.match_operator (|
                          Ty.apply
                            (Ty.path "*")
                            []
                            [
                              Ty.function
                                [ Ty.tuple [ Ty.path "core::alloc::layout::Layout" ] ]
                                (Ty.apply
                                  (Ty.path "core::result::Result")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "core::ptr::non_null::NonNull")
                                      []
                                      [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ];
                                    Ty.path "core::alloc::AllocError"
                                  ])
                            ],
                          M.alloc (| α0 |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let layout := M.copy (| γ |) in
                                M.call_closure (|
                                  Ty.apply
                                    (Ty.path "core::result::Result")
                                    []
                                    [
                                      Ty.apply
                                        (Ty.path "core::ptr::non_null::NonNull")
                                        []
                                        [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ];
                                      Ty.path "core::alloc::AllocError"
                                    ],
                                  M.get_trait_method (|
                                    "core::alloc::Allocator",
                                    Ty.path "alloc::alloc::Global",
                                    [],
                                    [],
                                    "allocate",
                                    [],
                                    []
                                  |),
                                  [
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.alloc (| Value.StructTuple "alloc::alloc::Global" [] |)
                                    |);
                                    M.read (| layout |)
                                  ]
                                |)))
                          ]
                        |)))
                    | _ => M.impossible "wrong number of arguments"
                    end));
              M.closure
                (fun γ =>
                  ltac:(M.monadic
                    match γ with
                    | [ α0 ] =>
                      ltac:(M.monadic
                        (M.match_operator (|
                          Ty.apply
                            (Ty.path "*")
                            []
                            [
                              Ty.function
                                [ Ty.tuple [ Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ] ] ]
                                (Ty.apply
                                  (Ty.path "*mut")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "alloc::sync::ArcInner")
                                      []
                                      [ Ty.apply (Ty.path "slice") [] [ T ] ]
                                  ])
                            ],
                          M.alloc (| α0 |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let mem := M.copy (| γ |) in
                                M.cast
                                  (Ty.apply
                                    (Ty.path "*mut")
                                    []
                                    [
                                      Ty.apply
                                        (Ty.path "alloc::sync::ArcInner")
                                        []
                                        [ Ty.apply (Ty.path "slice") [] [ T ] ]
                                    ])
                                  (M.call_closure (|
                                    Ty.apply
                                      (Ty.path "*mut")
                                      []
                                      [ Ty.apply (Ty.path "slice") [] [ T ] ],
                                    M.get_function (|
                                      "core::ptr::slice_from_raw_parts_mut",
                                      [],
                                      [ T ]
                                    |),
                                    [
                                      M.call_closure (|
                                        Ty.apply (Ty.path "*mut") [] [ T ],
                                        M.get_associated_function (|
                                          Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ],
                                          "cast",
                                          [],
                                          [ T ]
                                        |),
                                        [ M.read (| mem |) ]
                                      |);
                                      M.read (| len |)
                                    ]
                                  |))))
                          ]
                        |)))
                    | _ => M.impossible "wrong number of arguments"
                    end))
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_allocate_for_slice :
      forall (T : Ty.t),
      M.IsAssociatedFunction.C (Self T) "allocate_for_slice" (allocate_for_slice T).
    Admitted.
    Global Typeclasses Opaque allocate_for_slice.
    
    (*
        unsafe fn copy_from_slice(v: &[T]) -> Arc<[T]> {
            unsafe {
                let ptr = Self::allocate_for_slice(v.len());
    
                ptr::copy_nonoverlapping(v.as_ptr(), (&raw mut ( *ptr).data) as *mut T, v.len());
    
                Self::from_ptr(ptr)
            }
        }
    *)
    Definition copy_from_slice
        (T : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [], [ v ] =>
        ltac:(M.monadic
          (let v := M.alloc (| v |) in
          M.read (|
            let~ ptr :
                Ty.apply
                  (Ty.path "*")
                  []
                  [
                    Ty.apply
                      (Ty.path "*mut")
                      []
                      [
                        Ty.apply
                          (Ty.path "alloc::sync::ArcInner")
                          []
                          [ Ty.apply (Ty.path "slice") [] [ T ] ]
                      ]
                  ] :=
              M.alloc (|
                M.call_closure (|
                  Ty.apply
                    (Ty.path "*mut")
                    []
                    [
                      Ty.apply
                        (Ty.path "alloc::sync::ArcInner")
                        []
                        [ Ty.apply (Ty.path "slice") [] [ T ] ]
                    ],
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "alloc::sync::Arc")
                      []
                      [ Ty.apply (Ty.path "slice") [] [ T ]; Ty.path "alloc::alloc::Global" ],
                    "allocate_for_slice",
                    [],
                    []
                  |),
                  [
                    M.call_closure (|
                      Ty.path "usize",
                      M.get_associated_function (|
                        Ty.apply (Ty.path "slice") [] [ T ],
                        "len",
                        [],
                        []
                      |),
                      [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| v |) |) |) ]
                    |)
                  ]
                |)
              |) in
            let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
              M.alloc (|
                M.call_closure (|
                  Ty.tuple [],
                  M.get_function (| "core::intrinsics::copy_nonoverlapping", [], [ T ] |),
                  [
                    M.call_closure (|
                      Ty.apply (Ty.path "*const") [] [ T ],
                      M.get_associated_function (|
                        Ty.apply (Ty.path "slice") [] [ T ],
                        "as_ptr",
                        [],
                        []
                      |),
                      [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| v |) |) |) ]
                    |);
                    M.cast
                      (Ty.apply (Ty.path "*mut") [] [ T ])
                      (M.borrow (|
                        Pointer.Kind.MutPointer,
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| ptr |) |),
                          "alloc::sync::ArcInner",
                          "data"
                        |)
                      |));
                    M.call_closure (|
                      Ty.path "usize",
                      M.get_associated_function (|
                        Ty.apply (Ty.path "slice") [] [ T ],
                        "len",
                        [],
                        []
                      |),
                      [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| v |) |) |) ]
                    |)
                  ]
                |)
              |) in
            M.alloc (|
              M.call_closure (|
                Ty.apply
                  (Ty.path "alloc::sync::Arc")
                  []
                  [ Ty.apply (Ty.path "slice") [] [ T ]; Ty.path "alloc::alloc::Global" ],
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "alloc::sync::Arc")
                    []
                    [ Ty.apply (Ty.path "slice") [] [ T ]; Ty.path "alloc::alloc::Global" ],
                  "from_ptr",
                  [],
                  []
                |),
                [ M.read (| ptr |) ]
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_copy_from_slice :
      forall (T : Ty.t),
      M.IsAssociatedFunction.C (Self T) "copy_from_slice" (copy_from_slice T).
    Admitted.
    Global Typeclasses Opaque copy_from_slice.
    
    (*
        unsafe fn from_iter_exact(iter: impl Iterator<Item = T>, len: usize) -> Arc<[T]> {
            // Panic guard while cloning T elements.
            // In the event of a panic, elements that have been written
            // into the new ArcInner will be dropped, then the memory freed.
            struct Guard<T> {
                mem: NonNull<u8>,
                elems: *mut T,
                layout: Layout,
                n_elems: usize,
            }
    
            impl<T> Drop for Guard<T> {
                fn drop(&mut self) {
                    unsafe {
                        let slice = from_raw_parts_mut(self.elems, self.n_elems);
                        ptr::drop_in_place(slice);
    
                        Global.deallocate(self.mem, self.layout);
                    }
                }
            }
    
            unsafe {
                let ptr = Self::allocate_for_slice(len);
    
                let mem = ptr as *mut _ as *mut u8;
                let layout = Layout::for_value_raw(ptr);
    
                // Pointer to first element
                let elems = (&raw mut ( *ptr).data) as *mut T;
    
                let mut guard = Guard { mem: NonNull::new_unchecked(mem), elems, layout, n_elems: 0 };
    
                for (i, item) in iter.enumerate() {
                    ptr::write(elems.add(i), item);
                    guard.n_elems += 1;
                }
    
                // All clear. Forget the guard so it doesn't free the new ArcInner.
                mem::forget(guard);
    
                Self::from_ptr(ptr)
            }
        }
    *)
    Definition from_iter_exact
        (T : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [ impl_Iterator_Item___T_ ], [ iter; len ] =>
        ltac:(M.monadic
          (let iter := M.alloc (| iter |) in
          let len := M.alloc (| len |) in
          M.read (|
            let~ ptr :
                Ty.apply
                  (Ty.path "*")
                  []
                  [
                    Ty.apply
                      (Ty.path "*mut")
                      []
                      [
                        Ty.apply
                          (Ty.path "alloc::sync::ArcInner")
                          []
                          [ Ty.apply (Ty.path "slice") [] [ T ] ]
                      ]
                  ] :=
              M.alloc (|
                M.call_closure (|
                  Ty.apply
                    (Ty.path "*mut")
                    []
                    [
                      Ty.apply
                        (Ty.path "alloc::sync::ArcInner")
                        []
                        [ Ty.apply (Ty.path "slice") [] [ T ] ]
                    ],
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "alloc::sync::Arc")
                      []
                      [ Ty.apply (Ty.path "slice") [] [ T ]; Ty.path "alloc::alloc::Global" ],
                    "allocate_for_slice",
                    [],
                    []
                  |),
                  [ M.read (| len |) ]
                |)
              |) in
            let~ mem :
                Ty.apply (Ty.path "*") [] [ Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ] ] :=
              M.alloc (|
                M.cast
                  (Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ])
                  (M.cast
                    (Ty.apply
                      (Ty.path "*mut")
                      []
                      [
                        Ty.apply
                          (Ty.path "alloc::sync::ArcInner")
                          []
                          [ Ty.apply (Ty.path "slice") [] [ T ] ]
                      ])
                    (M.read (| ptr |)))
              |) in
            let~ layout : Ty.apply (Ty.path "*") [] [ Ty.path "core::alloc::layout::Layout" ] :=
              M.alloc (|
                M.call_closure (|
                  Ty.path "core::alloc::layout::Layout",
                  M.get_associated_function (|
                    Ty.path "core::alloc::layout::Layout",
                    "for_value_raw",
                    [],
                    [
                      Ty.apply
                        (Ty.path "alloc::sync::ArcInner")
                        []
                        [ Ty.apply (Ty.path "slice") [] [ T ] ]
                    ]
                  |),
                  [ (* MutToConstPointer *) M.pointer_coercion (M.read (| ptr |)) ]
                |)
              |) in
            let~ elems : Ty.apply (Ty.path "*") [] [ Ty.apply (Ty.path "*mut") [] [ T ] ] :=
              M.alloc (|
                M.cast
                  (Ty.apply (Ty.path "*mut") [] [ T ])
                  (M.borrow (|
                    Pointer.Kind.MutPointer,
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| ptr |) |),
                      "alloc::sync::ArcInner",
                      "data"
                    |)
                  |))
              |) in
            let~ guard :
                Ty.apply
                  (Ty.path "*")
                  []
                  [ Ty.apply (Ty.path "alloc::sync::from_iter_exact::Guard") [] [ T ] ] :=
              M.alloc (|
                Value.StructRecord
                  "alloc::sync::from_iter_exact::Guard"
                  [
                    ("mem",
                      M.call_closure (|
                        Ty.apply (Ty.path "core::ptr::non_null::NonNull") [] [ Ty.path "u8" ],
                        M.get_associated_function (|
                          Ty.apply (Ty.path "core::ptr::non_null::NonNull") [] [ Ty.path "u8" ],
                          "new_unchecked",
                          [],
                          []
                        |),
                        [ M.read (| mem |) ]
                      |));
                    ("elems", M.read (| elems |));
                    ("layout", M.read (| layout |));
                    ("n_elems", Value.Integer IntegerKind.Usize 0)
                  ]
              |) in
            let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
              M.use
                (M.match_operator (|
                  Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                  M.alloc (|
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "core::iter::adapters::enumerate::Enumerate")
                        []
                        [ impl_Iterator_Item___T_ ],
                      M.get_trait_method (|
                        "core::iter::traits::collect::IntoIterator",
                        Ty.apply
                          (Ty.path "core::iter::adapters::enumerate::Enumerate")
                          []
                          [ impl_Iterator_Item___T_ ],
                        [],
                        [],
                        "into_iter",
                        [],
                        []
                      |),
                      [
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "core::iter::adapters::enumerate::Enumerate")
                            []
                            [ impl_Iterator_Item___T_ ],
                          M.get_trait_method (|
                            "core::iter::traits::iterator::Iterator",
                            impl_Iterator_Item___T_,
                            [],
                            [],
                            "enumerate",
                            [],
                            []
                          |),
                          [ M.read (| iter |) ]
                        |)
                      ]
                    |)
                  |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let iter := M.copy (| γ |) in
                        M.loop (|
                          Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                          ltac:(M.monadic
                            (let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                              M.match_operator (|
                                Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                                M.alloc (|
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "core::option::Option")
                                      []
                                      [ Ty.tuple [ Ty.path "usize"; T ] ],
                                    M.get_trait_method (|
                                      "core::iter::traits::iterator::Iterator",
                                      Ty.apply
                                        (Ty.path "core::iter::adapters::enumerate::Enumerate")
                                        []
                                        [ impl_Iterator_Item___T_ ],
                                      [],
                                      [],
                                      "next",
                                      [],
                                      []
                                    |),
                                    [
                                      M.borrow (|
                                        Pointer.Kind.MutRef,
                                        M.deref (| M.borrow (| Pointer.Kind.MutRef, iter |) |)
                                      |)
                                    ]
                                  |)
                                |),
                                [
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let _ :=
                                        M.is_struct_tuple (| γ, "core::option::Option::None" |) in
                                      M.alloc (|
                                        M.never_to_any (| M.read (| M.break (||) |) |)
                                      |)));
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let γ0_0 :=
                                        M.SubPointer.get_struct_tuple_field (|
                                          γ,
                                          "core::option::Option::Some",
                                          0
                                        |) in
                                      let γ1_0 := M.SubPointer.get_tuple_field (| γ0_0, 0 |) in
                                      let γ1_1 := M.SubPointer.get_tuple_field (| γ0_0, 1 |) in
                                      let i := M.copy (| γ1_0 |) in
                                      let item := M.copy (| γ1_1 |) in
                                      let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                                        M.alloc (|
                                          M.call_closure (|
                                            Ty.tuple [],
                                            M.get_function (| "core::ptr::write", [], [ T ] |),
                                            [
                                              M.call_closure (|
                                                Ty.apply (Ty.path "*mut") [] [ T ],
                                                M.get_associated_function (|
                                                  Ty.apply (Ty.path "*mut") [] [ T ],
                                                  "add",
                                                  [],
                                                  []
                                                |),
                                                [ M.read (| elems |); M.read (| i |) ]
                                              |);
                                              M.read (| item |)
                                            ]
                                          |)
                                        |) in
                                      let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                                        M.alloc (|
                                          let β :=
                                            M.SubPointer.get_struct_record_field (|
                                              guard,
                                              "alloc::sync::from_iter_exact::Guard",
                                              "n_elems"
                                            |) in
                                          M.write (|
                                            β,
                                            M.call_closure (|
                                              Ty.path "usize",
                                              BinOp.Wrap.add,
                                              [ M.read (| β |); Value.Integer IntegerKind.Usize 1 ]
                                            |)
                                          |)
                                        |) in
                                      M.alloc (| Value.Tuple [] |)))
                                ]
                              |) in
                            M.alloc (| Value.Tuple [] |)))
                        |)))
                  ]
                |)) in
            let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
              M.alloc (|
                M.call_closure (|
                  Ty.tuple [],
                  M.get_function (|
                    "core::mem::forget",
                    [],
                    [ Ty.apply (Ty.path "alloc::sync::from_iter_exact::Guard") [] [ T ] ]
                  |),
                  [ M.read (| guard |) ]
                |)
              |) in
            M.alloc (|
              M.call_closure (|
                Ty.apply
                  (Ty.path "alloc::sync::Arc")
                  []
                  [ Ty.apply (Ty.path "slice") [] [ T ]; Ty.path "alloc::alloc::Global" ],
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "alloc::sync::Arc")
                    []
                    [ Ty.apply (Ty.path "slice") [] [ T ]; Ty.path "alloc::alloc::Global" ],
                  "from_ptr",
                  [],
                  []
                |),
                [ M.read (| ptr |) ]
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_from_iter_exact :
      forall (T : Ty.t),
      M.IsAssociatedFunction.C (Self T) "from_iter_exact" (from_iter_exact T).
    Admitted.
    Global Typeclasses Opaque from_iter_exact.
  End Impl_alloc_sync_Arc_slice_T_alloc_alloc_Global.
  
  Module Impl_alloc_sync_Arc_slice_T_A.
    Definition Self (T A : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "alloc::sync::Arc") [] [ Ty.apply (Ty.path "slice") [] [ T ]; A ].
    
    (*
        pub fn new_uninit_slice_in(len: usize, alloc: A) -> Arc<[mem::MaybeUninit<T>], A> {
            unsafe { Arc::from_ptr_in(Arc::allocate_for_slice_in(len, &alloc), alloc) }
        }
    *)
    Definition new_uninit_slice_in
        (T A : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ len; alloc ] =>
        ltac:(M.monadic
          (let len := M.alloc (| len |) in
          let alloc := M.alloc (| alloc |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "alloc::sync::Arc")
              []
              [
                Ty.apply
                  (Ty.path "slice")
                  []
                  [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ] ];
                A
              ],
            M.get_associated_function (|
              Ty.apply
                (Ty.path "alloc::sync::Arc")
                []
                [
                  Ty.apply
                    (Ty.path "slice")
                    []
                    [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ] ];
                  A
                ],
              "from_ptr_in",
              [],
              []
            |),
            [
              M.call_closure (|
                Ty.apply
                  (Ty.path "*mut")
                  []
                  [
                    Ty.apply
                      (Ty.path "alloc::sync::ArcInner")
                      []
                      [
                        Ty.apply
                          (Ty.path "slice")
                          []
                          [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ] ]
                      ]
                  ],
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "alloc::sync::Arc")
                    []
                    [
                      Ty.apply
                        (Ty.path "slice")
                        []
                        [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ] ];
                      A
                    ],
                  "allocate_for_slice_in",
                  [],
                  []
                |),
                [
                  M.read (| len |);
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (| M.borrow (| Pointer.Kind.Ref, alloc |) |)
                  |)
                ]
              |);
              M.read (| alloc |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_new_uninit_slice_in :
      forall (T A : Ty.t),
      M.IsAssociatedFunction.C (Self T A) "new_uninit_slice_in" (new_uninit_slice_in T A).
    Admitted.
    Global Typeclasses Opaque new_uninit_slice_in.
    
    (*
        pub fn new_zeroed_slice_in(len: usize, alloc: A) -> Arc<[mem::MaybeUninit<T>], A> {
            unsafe {
                Arc::from_ptr_in(
                    Arc::allocate_for_layout(
                        Layout::array::<T>(len).unwrap(),
                        |layout| alloc.allocate_zeroed(layout),
                        |mem| {
                            ptr::slice_from_raw_parts_mut(mem.cast::<T>(), len)
                                as *mut ArcInner<[mem::MaybeUninit<T>]>
                        },
                    ),
                    alloc,
                )
            }
        }
    *)
    Definition new_zeroed_slice_in
        (T A : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ len; alloc ] =>
        ltac:(M.monadic
          (let len := M.alloc (| len |) in
          let alloc := M.alloc (| alloc |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "alloc::sync::Arc")
              []
              [
                Ty.apply
                  (Ty.path "slice")
                  []
                  [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ] ];
                A
              ],
            M.get_associated_function (|
              Ty.apply
                (Ty.path "alloc::sync::Arc")
                []
                [
                  Ty.apply
                    (Ty.path "slice")
                    []
                    [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ] ];
                  A
                ],
              "from_ptr_in",
              [],
              []
            |),
            [
              M.call_closure (|
                Ty.apply
                  (Ty.path "*mut")
                  []
                  [
                    Ty.apply
                      (Ty.path "alloc::sync::ArcInner")
                      []
                      [
                        Ty.apply
                          (Ty.path "slice")
                          []
                          [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ] ]
                      ]
                  ],
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "alloc::sync::Arc")
                    []
                    [
                      Ty.apply
                        (Ty.path "slice")
                        []
                        [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ] ];
                      Ty.path "alloc::alloc::Global"
                    ],
                  "allocate_for_layout",
                  [],
                  [
                    Ty.function
                      [ Ty.tuple [ Ty.path "core::alloc::layout::Layout" ] ]
                      (Ty.apply
                        (Ty.path "core::result::Result")
                        []
                        [
                          Ty.apply
                            (Ty.path "core::ptr::non_null::NonNull")
                            []
                            [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ];
                          Ty.path "core::alloc::AllocError"
                        ]);
                    Ty.function
                      [ Ty.tuple [ Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ] ] ]
                      (Ty.apply
                        (Ty.path "*mut")
                        []
                        [
                          Ty.apply
                            (Ty.path "alloc::sync::ArcInner")
                            []
                            [
                              Ty.apply
                                (Ty.path "slice")
                                []
                                [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ]
                                ]
                            ]
                        ])
                  ]
                |),
                [
                  M.call_closure (|
                    Ty.path "core::alloc::layout::Layout",
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "core::result::Result")
                        []
                        [
                          Ty.path "core::alloc::layout::Layout";
                          Ty.path "core::alloc::layout::LayoutError"
                        ],
                      "unwrap",
                      [],
                      []
                    |),
                    [
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [
                            Ty.path "core::alloc::layout::Layout";
                            Ty.path "core::alloc::layout::LayoutError"
                          ],
                        M.get_associated_function (|
                          Ty.path "core::alloc::layout::Layout",
                          "array",
                          [],
                          [ T ]
                        |),
                        [ M.read (| len |) ]
                      |)
                    ]
                  |);
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0 ] =>
                          ltac:(M.monadic
                            (M.match_operator (|
                              Ty.apply
                                (Ty.path "*")
                                []
                                [
                                  Ty.function
                                    [ Ty.tuple [ Ty.path "core::alloc::layout::Layout" ] ]
                                    (Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [
                                        Ty.apply
                                          (Ty.path "core::ptr::non_null::NonNull")
                                          []
                                          [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ];
                                        Ty.path "core::alloc::AllocError"
                                      ])
                                ],
                              M.alloc (| α0 |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let layout := M.copy (| γ |) in
                                    M.call_closure (|
                                      Ty.apply
                                        (Ty.path "core::result::Result")
                                        []
                                        [
                                          Ty.apply
                                            (Ty.path "core::ptr::non_null::NonNull")
                                            []
                                            [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ];
                                          Ty.path "core::alloc::AllocError"
                                        ],
                                      M.get_trait_method (|
                                        "core::alloc::Allocator",
                                        A,
                                        [],
                                        [],
                                        "allocate_zeroed",
                                        [],
                                        []
                                      |),
                                      [ M.borrow (| Pointer.Kind.Ref, alloc |); M.read (| layout |)
                                      ]
                                    |)))
                              ]
                            |)))
                        | _ => M.impossible "wrong number of arguments"
                        end));
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0 ] =>
                          ltac:(M.monadic
                            (M.match_operator (|
                              Ty.apply
                                (Ty.path "*")
                                []
                                [
                                  Ty.function
                                    [ Ty.tuple [ Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ] ] ]
                                    (Ty.apply
                                      (Ty.path "*mut")
                                      []
                                      [
                                        Ty.apply
                                          (Ty.path "alloc::sync::ArcInner")
                                          []
                                          [
                                            Ty.apply
                                              (Ty.path "slice")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                                  []
                                                  [ T ]
                                              ]
                                          ]
                                      ])
                                ],
                              M.alloc (| α0 |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let mem := M.copy (| γ |) in
                                    M.cast
                                      (Ty.apply
                                        (Ty.path "*mut")
                                        []
                                        [
                                          Ty.apply
                                            (Ty.path "alloc::sync::ArcInner")
                                            []
                                            [
                                              Ty.apply
                                                (Ty.path "slice")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                                    []
                                                    [ T ]
                                                ]
                                            ]
                                        ])
                                      (M.call_closure (|
                                        Ty.apply
                                          (Ty.path "*mut")
                                          []
                                          [ Ty.apply (Ty.path "slice") [] [ T ] ],
                                        M.get_function (|
                                          "core::ptr::slice_from_raw_parts_mut",
                                          [],
                                          [ T ]
                                        |),
                                        [
                                          M.call_closure (|
                                            Ty.apply (Ty.path "*mut") [] [ T ],
                                            M.get_associated_function (|
                                              Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ],
                                              "cast",
                                              [],
                                              [ T ]
                                            |),
                                            [ M.read (| mem |) ]
                                          |);
                                          M.read (| len |)
                                        ]
                                      |))))
                              ]
                            |)))
                        | _ => M.impossible "wrong number of arguments"
                        end))
                ]
              |);
              M.read (| alloc |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_new_zeroed_slice_in :
      forall (T A : Ty.t),
      M.IsAssociatedFunction.C (Self T A) "new_zeroed_slice_in" (new_zeroed_slice_in T A).
    Admitted.
    Global Typeclasses Opaque new_zeroed_slice_in.
    (*
        unsafe fn allocate_for_slice_in(len: usize, alloc: &A) -> *mut ArcInner<[T]> {
            unsafe {
                Arc::allocate_for_layout(
                    Layout::array::<T>(len).unwrap(),
                    |layout| alloc.allocate(layout),
                    |mem| ptr::slice_from_raw_parts_mut(mem.cast::<T>(), len) as *mut ArcInner<[T]>,
                )
            }
        }
    *)
    Definition allocate_for_slice_in
        (T A : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ len; alloc ] =>
        ltac:(M.monadic
          (let len := M.alloc (| len |) in
          let alloc := M.alloc (| alloc |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "*mut")
              []
              [
                Ty.apply
                  (Ty.path "alloc::sync::ArcInner")
                  []
                  [ Ty.apply (Ty.path "slice") [] [ T ] ]
              ],
            M.get_associated_function (|
              Ty.apply
                (Ty.path "alloc::sync::Arc")
                []
                [ Ty.apply (Ty.path "slice") [] [ T ]; Ty.path "alloc::alloc::Global" ],
              "allocate_for_layout",
              [],
              [
                Ty.function
                  [ Ty.tuple [ Ty.path "core::alloc::layout::Layout" ] ]
                  (Ty.apply
                    (Ty.path "core::result::Result")
                    []
                    [
                      Ty.apply
                        (Ty.path "core::ptr::non_null::NonNull")
                        []
                        [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ];
                      Ty.path "core::alloc::AllocError"
                    ]);
                Ty.function
                  [ Ty.tuple [ Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ] ] ]
                  (Ty.apply
                    (Ty.path "*mut")
                    []
                    [
                      Ty.apply
                        (Ty.path "alloc::sync::ArcInner")
                        []
                        [ Ty.apply (Ty.path "slice") [] [ T ] ]
                    ])
              ]
            |),
            [
              M.call_closure (|
                Ty.path "core::alloc::layout::Layout",
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "core::result::Result")
                    []
                    [
                      Ty.path "core::alloc::layout::Layout";
                      Ty.path "core::alloc::layout::LayoutError"
                    ],
                  "unwrap",
                  [],
                  []
                |),
                [
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "core::result::Result")
                      []
                      [
                        Ty.path "core::alloc::layout::Layout";
                        Ty.path "core::alloc::layout::LayoutError"
                      ],
                    M.get_associated_function (|
                      Ty.path "core::alloc::layout::Layout",
                      "array",
                      [],
                      [ T ]
                    |),
                    [ M.read (| len |) ]
                  |)
                ]
              |);
              M.closure
                (fun γ =>
                  ltac:(M.monadic
                    match γ with
                    | [ α0 ] =>
                      ltac:(M.monadic
                        (M.match_operator (|
                          Ty.apply
                            (Ty.path "*")
                            []
                            [
                              Ty.function
                                [ Ty.tuple [ Ty.path "core::alloc::layout::Layout" ] ]
                                (Ty.apply
                                  (Ty.path "core::result::Result")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "core::ptr::non_null::NonNull")
                                      []
                                      [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ];
                                    Ty.path "core::alloc::AllocError"
                                  ])
                            ],
                          M.alloc (| α0 |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let layout := M.copy (| γ |) in
                                M.call_closure (|
                                  Ty.apply
                                    (Ty.path "core::result::Result")
                                    []
                                    [
                                      Ty.apply
                                        (Ty.path "core::ptr::non_null::NonNull")
                                        []
                                        [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ];
                                      Ty.path "core::alloc::AllocError"
                                    ],
                                  M.get_trait_method (|
                                    "core::alloc::Allocator",
                                    A,
                                    [],
                                    [],
                                    "allocate",
                                    [],
                                    []
                                  |),
                                  [
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.deref (| M.read (| alloc |) |)
                                    |);
                                    M.read (| layout |)
                                  ]
                                |)))
                          ]
                        |)))
                    | _ => M.impossible "wrong number of arguments"
                    end));
              M.closure
                (fun γ =>
                  ltac:(M.monadic
                    match γ with
                    | [ α0 ] =>
                      ltac:(M.monadic
                        (M.match_operator (|
                          Ty.apply
                            (Ty.path "*")
                            []
                            [
                              Ty.function
                                [ Ty.tuple [ Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ] ] ]
                                (Ty.apply
                                  (Ty.path "*mut")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "alloc::sync::ArcInner")
                                      []
                                      [ Ty.apply (Ty.path "slice") [] [ T ] ]
                                  ])
                            ],
                          M.alloc (| α0 |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let mem := M.copy (| γ |) in
                                M.cast
                                  (Ty.apply
                                    (Ty.path "*mut")
                                    []
                                    [
                                      Ty.apply
                                        (Ty.path "alloc::sync::ArcInner")
                                        []
                                        [ Ty.apply (Ty.path "slice") [] [ T ] ]
                                    ])
                                  (M.call_closure (|
                                    Ty.apply
                                      (Ty.path "*mut")
                                      []
                                      [ Ty.apply (Ty.path "slice") [] [ T ] ],
                                    M.get_function (|
                                      "core::ptr::slice_from_raw_parts_mut",
                                      [],
                                      [ T ]
                                    |),
                                    [
                                      M.call_closure (|
                                        Ty.apply (Ty.path "*mut") [] [ T ],
                                        M.get_associated_function (|
                                          Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ],
                                          "cast",
                                          [],
                                          [ T ]
                                        |),
                                        [ M.read (| mem |) ]
                                      |);
                                      M.read (| len |)
                                    ]
                                  |))))
                          ]
                        |)))
                    | _ => M.impossible "wrong number of arguments"
                    end))
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_allocate_for_slice_in :
      forall (T A : Ty.t),
      M.IsAssociatedFunction.C (Self T A) "allocate_for_slice_in" (allocate_for_slice_in T A).
    Admitted.
    Global Typeclasses Opaque allocate_for_slice_in.
  End Impl_alloc_sync_Arc_slice_T_A.
  
  Module Impl_alloc_sync_Arc_core_mem_maybe_uninit_MaybeUninit_T_A.
    Definition Self (T A : Ty.t) : Ty.t :=
      Ty.apply
        (Ty.path "alloc::sync::Arc")
        []
        [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ]; A ].
    
    (*
        pub unsafe fn assume_init(self) -> Arc<T, A> {
            let (ptr, alloc) = Arc::into_inner_with_allocator(self);
            unsafe { Arc::from_inner_in(ptr.cast(), alloc) }
        }
    *)
    Definition assume_init (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              Ty.apply (Ty.path "*") [] [ Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; A ] ],
              M.alloc (|
                M.call_closure (|
                  Ty.tuple
                    [
                      Ty.apply
                        (Ty.path "core::ptr::non_null::NonNull")
                        []
                        [
                          Ty.apply
                            (Ty.path "alloc::sync::ArcInner")
                            []
                            [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ] ]
                        ];
                      A
                    ],
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "alloc::sync::Arc")
                      []
                      [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ]; A ],
                    "into_inner_with_allocator",
                    [],
                    []
                  |),
                  [ M.read (| self |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let ptr := M.copy (| γ0_0 |) in
                    let alloc := M.copy (| γ0_1 |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; A ],
                        M.get_associated_function (|
                          Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; A ],
                          "from_inner_in",
                          [],
                          []
                        |),
                        [
                          M.call_closure (|
                            Ty.apply
                              (Ty.path "core::ptr::non_null::NonNull")
                              []
                              [ Ty.apply (Ty.path "alloc::sync::ArcInner") [] [ T ] ],
                            M.get_associated_function (|
                              Ty.apply
                                (Ty.path "core::ptr::non_null::NonNull")
                                []
                                [
                                  Ty.apply
                                    (Ty.path "alloc::sync::ArcInner")
                                    []
                                    [
                                      Ty.apply
                                        (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                        []
                                        [ T ]
                                    ]
                                ],
                              "cast",
                              [],
                              [ Ty.apply (Ty.path "alloc::sync::ArcInner") [] [ T ] ]
                            |),
                            [ M.read (| ptr |) ]
                          |);
                          M.read (| alloc |)
                        ]
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_assume_init :
      forall (T A : Ty.t),
      M.IsAssociatedFunction.C (Self T A) "assume_init" (assume_init T A).
    Admitted.
    Global Typeclasses Opaque assume_init.
  End Impl_alloc_sync_Arc_core_mem_maybe_uninit_MaybeUninit_T_A.
  
  Module Impl_alloc_sync_Arc_slice_core_mem_maybe_uninit_MaybeUninit_T_A.
    Definition Self (T A : Ty.t) : Ty.t :=
      Ty.apply
        (Ty.path "alloc::sync::Arc")
        []
        [
          Ty.apply
            (Ty.path "slice")
            []
            [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ] ];
          A
        ].
    
    (*
        pub unsafe fn assume_init(self) -> Arc<[T], A> {
            let (ptr, alloc) = Arc::into_inner_with_allocator(self);
            unsafe { Arc::from_ptr_in(ptr.as_ptr() as _, alloc) }
        }
    *)
    Definition assume_init (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              Ty.apply
                (Ty.path "*")
                []
                [
                  Ty.apply
                    (Ty.path "alloc::sync::Arc")
                    []
                    [ Ty.apply (Ty.path "slice") [] [ T ]; A ]
                ],
              M.alloc (|
                M.call_closure (|
                  Ty.tuple
                    [
                      Ty.apply
                        (Ty.path "core::ptr::non_null::NonNull")
                        []
                        [
                          Ty.apply
                            (Ty.path "alloc::sync::ArcInner")
                            []
                            [
                              Ty.apply
                                (Ty.path "slice")
                                []
                                [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ]
                                ]
                            ]
                        ];
                      A
                    ],
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "alloc::sync::Arc")
                      []
                      [
                        Ty.apply
                          (Ty.path "slice")
                          []
                          [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ] ];
                        A
                      ],
                    "into_inner_with_allocator",
                    [],
                    []
                  |),
                  [ M.read (| self |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let ptr := M.copy (| γ0_0 |) in
                    let alloc := M.copy (| γ0_1 |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "alloc::sync::Arc")
                          []
                          [ Ty.apply (Ty.path "slice") [] [ T ]; A ],
                        M.get_associated_function (|
                          Ty.apply
                            (Ty.path "alloc::sync::Arc")
                            []
                            [ Ty.apply (Ty.path "slice") [] [ T ]; A ],
                          "from_ptr_in",
                          [],
                          []
                        |),
                        [
                          M.cast
                            (Ty.apply
                              (Ty.path "*mut")
                              []
                              [
                                Ty.apply
                                  (Ty.path "alloc::sync::ArcInner")
                                  []
                                  [ Ty.apply (Ty.path "slice") [] [ T ] ]
                              ])
                            (M.call_closure (|
                              Ty.apply
                                (Ty.path "*mut")
                                []
                                [
                                  Ty.apply
                                    (Ty.path "alloc::sync::ArcInner")
                                    []
                                    [
                                      Ty.apply
                                        (Ty.path "slice")
                                        []
                                        [
                                          Ty.apply
                                            (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                            []
                                            [ T ]
                                        ]
                                    ]
                                ],
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "core::ptr::non_null::NonNull")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "alloc::sync::ArcInner")
                                      []
                                      [
                                        Ty.apply
                                          (Ty.path "slice")
                                          []
                                          [
                                            Ty.apply
                                              (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                              []
                                              [ T ]
                                          ]
                                      ]
                                  ],
                                "as_ptr",
                                [],
                                []
                              |),
                              [ M.read (| ptr |) ]
                            |));
                          M.read (| alloc |)
                        ]
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_assume_init :
      forall (T A : Ty.t),
      M.IsAssociatedFunction.C (Self T A) "assume_init" (assume_init T A).
    Admitted.
    Global Typeclasses Opaque assume_init.
  End Impl_alloc_sync_Arc_slice_core_mem_maybe_uninit_MaybeUninit_T_A.
  
  
  
  
  
  
  
  (* Trait *)
  (* Empty module 'ArcFromSlice' *)
  
  Module Impl_alloc_sync_ArcFromSlice_where_core_clone_Clone_T_T_for_alloc_sync_Arc_slice_T_alloc_alloc_Global.
    Definition Self (T : Ty.t) : Ty.t :=
      Ty.apply
        (Ty.path "alloc::sync::Arc")
        []
        [ Ty.apply (Ty.path "slice") [] [ T ]; Ty.path "alloc::alloc::Global" ].
    
    (*
        default fn from_slice(v: &[T]) -> Self {
            unsafe { Self::from_iter_exact(v.iter().cloned(), v.len()) }
        }
    *)
    Definition from_slice (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [], [ v ] =>
        ltac:(M.monadic
          (let v := M.alloc (| v |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "alloc::sync::Arc")
              []
              [ Ty.apply (Ty.path "slice") [] [ T ]; Ty.path "alloc::alloc::Global" ],
            M.get_associated_function (|
              Ty.apply
                (Ty.path "alloc::sync::Arc")
                []
                [ Ty.apply (Ty.path "slice") [] [ T ]; Ty.path "alloc::alloc::Global" ],
              "from_iter_exact",
              [],
              [
                Ty.apply
                  (Ty.path "core::iter::adapters::cloned::Cloned")
                  []
                  [ Ty.apply (Ty.path "core::slice::iter::Iter") [] [ T ] ]
              ]
            |),
            [
              M.call_closure (|
                Ty.apply
                  (Ty.path "core::iter::adapters::cloned::Cloned")
                  []
                  [ Ty.apply (Ty.path "core::slice::iter::Iter") [] [ T ] ],
                M.get_trait_method (|
                  "core::iter::traits::iterator::Iterator",
                  Ty.apply (Ty.path "core::slice::iter::Iter") [] [ T ],
                  [],
                  [],
                  "cloned",
                  [],
                  [ T ]
                |),
                [
                  M.call_closure (|
                    Ty.apply (Ty.path "core::slice::iter::Iter") [] [ T ],
                    M.get_associated_function (|
                      Ty.apply (Ty.path "slice") [] [ T ],
                      "iter",
                      [],
                      []
                    |),
                    [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| v |) |) |) ]
                  |)
                ]
              |);
              M.call_closure (|
                Ty.path "usize",
                M.get_associated_function (| Ty.apply (Ty.path "slice") [] [ T ], "len", [], [] |),
                [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| v |) |) |) ]
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "alloc::sync::ArcFromSlice"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ T ]
        (Self T)
        (* Instance *) [ ("from_slice", InstanceField.Method (from_slice T)) ].
  End Impl_alloc_sync_ArcFromSlice_where_core_clone_Clone_T_T_for_alloc_sync_Arc_slice_T_alloc_alloc_Global.
  
  Module Impl_alloc_sync_ArcFromSlice_where_core_marker_Copy_T_T_for_alloc_sync_Arc_slice_T_alloc_alloc_Global.
    Definition Self (T : Ty.t) : Ty.t :=
      Ty.apply
        (Ty.path "alloc::sync::Arc")
        []
        [ Ty.apply (Ty.path "slice") [] [ T ]; Ty.path "alloc::alloc::Global" ].
    
    (*
        fn from_slice(v: &[T]) -> Self {
            unsafe { Arc::copy_from_slice(v) }
        }
    *)
    Definition from_slice (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [], [ v ] =>
        ltac:(M.monadic
          (let v := M.alloc (| v |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "alloc::sync::Arc")
              []
              [ Ty.apply (Ty.path "slice") [] [ T ]; Ty.path "alloc::alloc::Global" ],
            M.get_associated_function (|
              Ty.apply
                (Ty.path "alloc::sync::Arc")
                []
                [ Ty.apply (Ty.path "slice") [] [ T ]; Ty.path "alloc::alloc::Global" ],
              "copy_from_slice",
              [],
              []
            |),
            [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| v |) |) |) ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "alloc::sync::ArcFromSlice"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ T ]
        (Self T)
        (* Instance *) [ ("from_slice", InstanceField.Method (from_slice T)) ].
  End Impl_alloc_sync_ArcFromSlice_where_core_marker_Copy_T_T_for_alloc_sync_Arc_slice_T_alloc_alloc_Global.
  
  Module Impl_core_clone_Clone_where_core_marker_Sized_T_where_core_alloc_Allocator_A_where_core_clone_Clone_A_for_alloc_sync_Arc_T_A.
    Definition Self (T A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; A ].
    
    (*
        fn clone(&self) -> Arc<T, A> {
            // Using a relaxed ordering is alright here, as knowledge of the
            // original reference prevents other threads from erroneously deleting
            // the object.
            //
            // As explained in the [Boost documentation][1], Increasing the
            // reference counter can always be done with memory_order_relaxed: New
            // references to an object can only be formed from an existing
            // reference, and passing an existing reference from one thread to
            // another must already provide any required synchronization.
            //
            // [1]: (www.boost.org/doc/libs/1_55_0/doc/html/atomic/usage_examples.html)
            let old_size = self.inner().strong.fetch_add(1, Relaxed);
    
            // However we need to guard against massive refcounts in case someone is `mem::forget`ing
            // Arcs. If we don't do this the count can overflow and users will use-after free. This
            // branch will never be taken in any realistic program. We abort because such a program is
            // incredibly degenerate, and we don't care to support it.
            //
            // This check is not 100% water-proof: we error when the refcount grows beyond `isize::MAX`.
            // But we do that check *after* having done the increment, so there is a chance here that
            // the worst already happened and we actually do overflow the `usize` counter. However, that
            // requires the counter to grow from `isize::MAX` to `usize::MAX` between the increment
            // above and the `abort` below, which seems exceedingly unlikely.
            //
            // This is a global invariant, and also applies when using a compare-exchange loop to increment
            // counters in other methods.
            // Otherwise, the counter could be brought to an almost-overflow using a compare-exchange loop,
            // and then overflow using a few `fetch_add`s.
            if old_size > MAX_REFCOUNT {
                abort();
            }
    
            unsafe { Self::from_inner_in(self.ptr, self.alloc.clone()) }
        }
    *)
    Definition clone (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            let~ old_size : Ty.apply (Ty.path "*") [] [ Ty.path "usize" ] :=
              M.alloc (|
                M.call_closure (|
                  Ty.path "usize",
                  M.get_associated_function (|
                    Ty.path "core::sync::atomic::AtomicUsize",
                    "fetch_add",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (|
                          M.call_closure (|
                            Ty.apply
                              (Ty.path "&")
                              []
                              [ Ty.apply (Ty.path "alloc::sync::ArcInner") [] [ T ] ],
                            M.get_associated_function (|
                              Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; A ],
                              "inner",
                              [],
                              []
                            |),
                            [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                          |)
                        |),
                        "alloc::sync::ArcInner",
                        "strong"
                      |)
                    |);
                    Value.Integer IntegerKind.Usize 1;
                    Value.StructTuple "core::sync::atomic::Ordering::Relaxed" []
                  ]
                |)
              |) in
            let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
              M.match_operator (|
                Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            M.call_closure (|
                              Ty.path "bool",
                              BinOp.gt,
                              [
                                M.read (| old_size |);
                                M.read (|
                                  get_constant (| "alloc::sync::MAX_REFCOUNT", Ty.path "usize" |)
                                |)
                              ]
                            |)
                          |)) in
                      let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (|
                        M.never_to_any (|
                          M.call_closure (|
                            Ty.path "never",
                            M.get_function (| "core::intrinsics::abort", [], [] |),
                            []
                          |)
                        |)
                      |)));
                  fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                ]
              |) in
            M.alloc (|
              M.call_closure (|
                Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; A ],
                M.get_associated_function (|
                  Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; A ],
                  "from_inner_in",
                  [],
                  []
                |),
                [
                  M.read (|
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| self |) |),
                      "alloc::sync::Arc",
                      "ptr"
                    |)
                  |);
                  M.call_closure (|
                    A,
                    M.get_trait_method (| "core::clone::Clone", A, [], [], "clone", [], [] |),
                    [
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "alloc::sync::Arc",
                          "alloc"
                        |)
                      |)
                    ]
                  |)
                ]
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (T A : Ty.t),
      M.IsTraitInstance
        "core::clone::Clone"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self T A)
        (* Instance *) [ ("clone", InstanceField.Method (clone T A)) ].
  End Impl_core_clone_Clone_where_core_marker_Sized_T_where_core_alloc_Allocator_A_where_core_clone_Clone_A_for_alloc_sync_Arc_T_A.
  
  Module Impl_core_ops_deref_Deref_where_core_marker_Sized_T_where_core_alloc_Allocator_A_for_alloc_sync_Arc_T_A.
    Definition Self (T A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; A ].
    
    (*     type Target = T; *)
    Definition _Target (T A : Ty.t) : Ty.t := T.
    
    (*
        fn deref(&self) -> &T {
            &self.inner().data
        }
    *)
    Definition deref (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.borrow (|
            Pointer.Kind.Ref,
            M.deref (|
              M.borrow (|
                Pointer.Kind.Ref,
                M.SubPointer.get_struct_record_field (|
                  M.deref (|
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "&")
                        []
                        [ Ty.apply (Ty.path "alloc::sync::ArcInner") [] [ T ] ],
                      M.get_associated_function (|
                        Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; A ],
                        "inner",
                        [],
                        []
                      |),
                      [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                    |)
                  |),
                  "alloc::sync::ArcInner",
                  "data"
                |)
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (T A : Ty.t),
      M.IsTraitInstance
        "core::ops::deref::Deref"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self T A)
        (* Instance *)
        [ ("Target", InstanceField.Ty (_Target T A)); ("deref", InstanceField.Method (deref T A)) ].
  End Impl_core_ops_deref_Deref_where_core_marker_Sized_T_where_core_alloc_Allocator_A_for_alloc_sync_Arc_T_A.
  
  Module Impl_core_pin_PinCoerceUnsized_where_core_marker_Sized_T_where_core_alloc_Allocator_A_for_alloc_sync_Arc_T_A.
    Definition Self (T A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; A ].
    
    Axiom Implements :
      forall (T A : Ty.t),
      M.IsTraitInstance
        "core::pin::PinCoerceUnsized"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self T A)
        (* Instance *) [].
  End Impl_core_pin_PinCoerceUnsized_where_core_marker_Sized_T_where_core_alloc_Allocator_A_for_alloc_sync_Arc_T_A.
  
  Module Impl_core_pin_PinCoerceUnsized_where_core_marker_Sized_T_where_core_alloc_Allocator_A_for_alloc_sync_Weak_T_A.
    Definition Self (T A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::sync::Weak") [] [ T; A ].
    
    Axiom Implements :
      forall (T A : Ty.t),
      M.IsTraitInstance
        "core::pin::PinCoerceUnsized"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self T A)
        (* Instance *) [].
  End Impl_core_pin_PinCoerceUnsized_where_core_marker_Sized_T_where_core_alloc_Allocator_A_for_alloc_sync_Weak_T_A.
  
  Module Impl_core_ops_deref_DerefPure_where_core_marker_Sized_T_where_core_alloc_Allocator_A_for_alloc_sync_Arc_T_A.
    Definition Self (T A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; A ].
    
    Axiom Implements :
      forall (T A : Ty.t),
      M.IsTraitInstance
        "core::ops::deref::DerefPure"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self T A)
        (* Instance *) [].
  End Impl_core_ops_deref_DerefPure_where_core_marker_Sized_T_where_core_alloc_Allocator_A_for_alloc_sync_Arc_T_A.
  
  Module Impl_core_ops_deref_LegacyReceiver_where_core_marker_Sized_T_for_alloc_sync_Arc_T_alloc_alloc_Global.
    Definition Self (T : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; Ty.path "alloc::alloc::Global" ].
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "core::ops::deref::LegacyReceiver"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self T)
        (* Instance *) [].
  End Impl_core_ops_deref_LegacyReceiver_where_core_marker_Sized_T_for_alloc_sync_Arc_T_alloc_alloc_Global.
  
  
  
  
  Module Impl_core_ops_drop_Drop_where_core_marker_Sized_T_where_core_alloc_Allocator_A_for_alloc_sync_Arc_T_A.
    Definition Self (T A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; A ].
    
    (*
        fn drop(&mut self) {
            // Because `fetch_sub` is already atomic, we do not need to synchronize
            // with other threads unless we are going to delete the object. This
            // same logic applies to the below `fetch_sub` to the `weak` count.
            if self.inner().strong.fetch_sub(1, Release) != 1 {
                return;
            }
    
            // This fence is needed to prevent reordering of use of the data and
            // deletion of the data. Because it is marked `Release`, the decreasing
            // of the reference count synchronizes with this `Acquire` fence. This
            // means that use of the data happens before decreasing the reference
            // count, which happens before this fence, which happens before the
            // deletion of the data.
            //
            // As explained in the [Boost documentation][1],
            //
            // > It is important to enforce any possible access to the object in one
            // > thread (through an existing reference) to *happen before* deleting
            // > the object in a different thread. This is achieved by a "release"
            // > operation after dropping a reference (any access to the object
            // > through this reference must obviously happened before), and an
            // > "acquire" operation before deleting the object.
            //
            // In particular, while the contents of an Arc are usually immutable, it's
            // possible to have interior writes to something like a Mutex<T>. Since a
            // Mutex is not acquired when it is deleted, we can't rely on its
            // synchronization logic to make writes in thread A visible to a destructor
            // running in thread B.
            //
            // Also note that the Acquire fence here could probably be replaced with an
            // Acquire load, which could improve performance in highly-contended
            // situations. See [2].
            //
            // [1]: (www.boost.org/doc/libs/1_55_0/doc/html/atomic/usage_examples.html)
            // [2]: (https://github.com/rust-lang/rust/pull/41714)
            acquire!(self.inner().strong);
    
            // Make sure we aren't trying to "drop" the shared static for empty slices
            // used by Default::default.
            debug_assert!(
                !ptr::addr_eq(self.ptr.as_ptr(), &STATIC_INNER_SLICE.inner),
                "Arcs backed by a static should never reach a strong count of 0. \
                Likely decrement_strong_count or from_raw were called too many times.",
            );
    
            unsafe {
                self.drop_slow();
            }
        }
    *)
    Definition drop (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.catch_return (Ty.tuple []) (|
            ltac:(M.monadic
              (M.read (|
                let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                  M.match_operator (|
                    Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                M.call_closure (|
                                  Ty.path "bool",
                                  BinOp.ne,
                                  [
                                    M.call_closure (|
                                      Ty.path "usize",
                                      M.get_associated_function (|
                                        Ty.path "core::sync::atomic::AtomicUsize",
                                        "fetch_sub",
                                        [],
                                        []
                                      |),
                                      [
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.SubPointer.get_struct_record_field (|
                                            M.deref (|
                                              M.call_closure (|
                                                Ty.apply
                                                  (Ty.path "&")
                                                  []
                                                  [
                                                    Ty.apply
                                                      (Ty.path "alloc::sync::ArcInner")
                                                      []
                                                      [ T ]
                                                  ],
                                                M.get_associated_function (|
                                                  Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; A ],
                                                  "inner",
                                                  [],
                                                  []
                                                |),
                                                [
                                                  M.borrow (|
                                                    Pointer.Kind.Ref,
                                                    M.deref (| M.read (| self |) |)
                                                  |)
                                                ]
                                              |)
                                            |),
                                            "alloc::sync::ArcInner",
                                            "strong"
                                          |)
                                        |);
                                        Value.Integer IntegerKind.Usize 1;
                                        Value.StructTuple "core::sync::atomic::Ordering::Release" []
                                      ]
                                    |);
                                    Value.Integer IntegerKind.Usize 1
                                  ]
                                |)
                              |)) in
                          let _ :=
                            is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (|
                            M.never_to_any (| M.read (| M.return_ (| Value.Tuple [] |) |) |)
                          |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                  M.alloc (|
                    M.call_closure (|
                      Ty.tuple [],
                      M.get_function (| "core::sync::atomic::fence", [], [] |),
                      [ Value.StructTuple "core::sync::atomic::Ordering::Acquire" [] ]
                    |)
                  |) in
                let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                  M.match_operator (|
                    Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ := M.use (M.alloc (| Value.Bool true |)) in
                          let _ :=
                            is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                            M.match_operator (|
                              Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                              M.alloc (| Value.Tuple [] |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let γ :=
                                      M.use
                                        (M.alloc (|
                                          UnOp.not (|
                                            UnOp.not (|
                                              M.call_closure (|
                                                Ty.path "bool",
                                                M.get_function (|
                                                  "core::ptr::addr_eq",
                                                  [],
                                                  [
                                                    Ty.apply
                                                      (Ty.path "alloc::sync::ArcInner")
                                                      []
                                                      [ T ];
                                                    Ty.apply
                                                      (Ty.path "alloc::sync::ArcInner")
                                                      []
                                                      [
                                                        Ty.apply
                                                          (Ty.path "array")
                                                          [ Value.Integer IntegerKind.Usize 1 ]
                                                          [ Ty.path "u8" ]
                                                      ]
                                                  ]
                                                |),
                                                [
                                                  (* MutToConstPointer *)
                                                  M.pointer_coercion
                                                    (M.call_closure (|
                                                      Ty.apply
                                                        (Ty.path "*mut")
                                                        []
                                                        [
                                                          Ty.apply
                                                            (Ty.path "alloc::sync::ArcInner")
                                                            []
                                                            [ T ]
                                                        ],
                                                      M.get_associated_function (|
                                                        Ty.apply
                                                          (Ty.path "core::ptr::non_null::NonNull")
                                                          []
                                                          [
                                                            Ty.apply
                                                              (Ty.path "alloc::sync::ArcInner")
                                                              []
                                                              [ T ]
                                                          ],
                                                        "as_ptr",
                                                        [],
                                                        []
                                                      |),
                                                      [
                                                        M.read (|
                                                          M.SubPointer.get_struct_record_field (|
                                                            M.deref (| M.read (| self |) |),
                                                            "alloc::sync::Arc",
                                                            "ptr"
                                                          |)
                                                        |)
                                                      ]
                                                    |));
                                                  M.borrow (|
                                                    Pointer.Kind.ConstPointer,
                                                    M.deref (|
                                                      M.borrow (|
                                                        Pointer.Kind.Ref,
                                                        M.SubPointer.get_struct_record_field (|
                                                          M.deref (|
                                                            M.read (|
                                                              get_constant (|
                                                                "alloc::sync::STATIC_INNER_SLICE",
                                                                Ty.apply
                                                                  (Ty.path "&")
                                                                  []
                                                                  [
                                                                    Ty.path
                                                                      "alloc::sync::SliceArcInnerForStatic"
                                                                  ]
                                                              |)
                                                            |)
                                                          |),
                                                          "alloc::sync::SliceArcInnerForStatic",
                                                          "inner"
                                                        |)
                                                      |)
                                                    |)
                                                  |)
                                                ]
                                              |)
                                            |)
                                          |)
                                        |)) in
                                    let _ :=
                                      is_constant_or_break_match (|
                                        M.read (| γ |),
                                        Value.Bool true
                                      |) in
                                    M.alloc (|
                                      M.never_to_any (|
                                        M.call_closure (|
                                          Ty.path "never",
                                          M.get_function (| "core::panicking::panic_fmt", [], [] |),
                                          [
                                            M.call_closure (|
                                              Ty.path "core::fmt::Arguments",
                                              M.get_associated_function (|
                                                Ty.path "core::fmt::Arguments",
                                                "new_const",
                                                [ Value.Integer IntegerKind.Usize 1 ],
                                                []
                                              |),
                                              [
                                                M.borrow (|
                                                  Pointer.Kind.Ref,
                                                  M.deref (|
                                                    M.borrow (|
                                                      Pointer.Kind.Ref,
                                                      M.alloc (|
                                                        Value.Array
                                                          [
                                                            mk_str (|
                                                              "Arcs backed by a static should never reach a strong count of 0. Likely decrement_strong_count or from_raw were called too many times."
                                                            |)
                                                          ]
                                                      |)
                                                    |)
                                                  |)
                                                |)
                                              ]
                                            |)
                                          ]
                                        |)
                                      |)
                                    |)));
                                fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                              ]
                            |) in
                          M.alloc (| Value.Tuple [] |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                  M.alloc (|
                    M.call_closure (|
                      Ty.tuple [],
                      M.get_associated_function (|
                        Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; A ],
                        "drop_slow",
                        [],
                        []
                      |),
                      [ M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |) ]
                    |)
                  |) in
                M.alloc (| Value.Tuple [] |)
              |)))
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (T A : Ty.t),
      M.IsTraitInstance
        "core::ops::drop::Drop"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self T A)
        (* Instance *) [ ("drop", InstanceField.Method (drop T A)) ].
  End Impl_core_ops_drop_Drop_where_core_marker_Sized_T_where_core_alloc_Allocator_A_for_alloc_sync_Arc_T_A.
  
  Module Impl_alloc_sync_Arc_Dyn_core_any_Any_Trait_core_marker_Sync_AutoTrait_core_marker_Send_AutoTrait_A.
    Definition Self (A : Ty.t) : Ty.t :=
      Ty.apply
        (Ty.path "alloc::sync::Arc")
        []
        [
          Ty.dyn
            [
              ("core::any::Any::Trait", []);
              ("core::marker::Sync::AutoTrait", []);
              ("core::marker::Send::AutoTrait", [])
            ];
          A
        ].
    
    (*
        pub fn downcast<T>(self) -> Result<Arc<T, A>, Self>
        where
            T: Any + Send + Sync,
        {
            if ( *self).is::<T>() {
                unsafe {
                    let (ptr, alloc) = Arc::into_inner_with_allocator(self);
                    Ok(Arc::from_inner_in(ptr.cast(), alloc))
                }
            } else {
                Err(self)
            }
        }
    *)
    Definition downcast (A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self A in
      match ε, τ, α with
      | [], [ T ], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              Ty.apply
                (Ty.path "*")
                []
                [
                  Ty.apply
                    (Ty.path "core::result::Result")
                    []
                    [
                      Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; A ];
                      Ty.apply
                        (Ty.path "alloc::sync::Arc")
                        []
                        [
                          Ty.dyn
                            [
                              ("core::any::Any::Trait", []);
                              ("core::marker::Sync::AutoTrait", []);
                              ("core::marker::Send::AutoTrait", [])
                            ];
                          A
                        ]
                    ]
                ],
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          M.call_closure (|
                            Ty.path "bool",
                            M.get_associated_function (|
                              Ty.dyn
                                [
                                  ("core::any::Any::Trait", []);
                                  ("core::marker::Sync::AutoTrait", []);
                                  ("core::marker::Send::AutoTrait", [])
                                ],
                              "is",
                              [],
                              [ T ]
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "&")
                                      []
                                      [
                                        Ty.dyn
                                          [
                                            ("core::any::Any::Trait", []);
                                            ("core::marker::Sync::AutoTrait", []);
                                            ("core::marker::Send::AutoTrait", [])
                                          ]
                                      ],
                                    M.get_trait_method (|
                                      "core::ops::deref::Deref",
                                      Ty.apply
                                        (Ty.path "alloc::sync::Arc")
                                        []
                                        [
                                          Ty.dyn
                                            [
                                              ("core::any::Any::Trait", []);
                                              ("core::marker::Sync::AutoTrait", []);
                                              ("core::marker::Send::AutoTrait", [])
                                            ];
                                          A
                                        ],
                                      [],
                                      [],
                                      "deref",
                                      [],
                                      []
                                    |),
                                    [ M.borrow (| Pointer.Kind.Ref, self |) ]
                                  |)
                                |)
                              |)
                            ]
                          |)
                        |)) in
                    let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.match_operator (|
                      Ty.apply
                        (Ty.path "*")
                        []
                        [
                          Ty.apply
                            (Ty.path "core::result::Result")
                            []
                            [
                              Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; A ];
                              Ty.apply
                                (Ty.path "alloc::sync::Arc")
                                []
                                [
                                  Ty.dyn
                                    [
                                      ("core::any::Any::Trait", []);
                                      ("core::marker::Sync::AutoTrait", []);
                                      ("core::marker::Send::AutoTrait", [])
                                    ];
                                  A
                                ]
                            ]
                        ],
                      M.alloc (|
                        M.call_closure (|
                          Ty.tuple
                            [
                              Ty.apply
                                (Ty.path "core::ptr::non_null::NonNull")
                                []
                                [
                                  Ty.apply
                                    (Ty.path "alloc::sync::ArcInner")
                                    []
                                    [
                                      Ty.dyn
                                        [
                                          ("core::any::Any::Trait", []);
                                          ("core::marker::Sync::AutoTrait", []);
                                          ("core::marker::Send::AutoTrait", [])
                                        ]
                                    ]
                                ];
                              A
                            ],
                          M.get_associated_function (|
                            Ty.apply
                              (Ty.path "alloc::sync::Arc")
                              []
                              [
                                Ty.dyn
                                  [
                                    ("core::any::Any::Trait", []);
                                    ("core::marker::Sync::AutoTrait", []);
                                    ("core::marker::Send::AutoTrait", [])
                                  ];
                                A
                              ],
                            "into_inner_with_allocator",
                            [],
                            []
                          |),
                          [ M.read (| self |) ]
                        |)
                      |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                            let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                            let ptr := M.copy (| γ0_0 |) in
                            let alloc := M.copy (| γ0_1 |) in
                            M.alloc (|
                              Value.StructTuple
                                "core::result::Result::Ok"
                                [
                                  M.call_closure (|
                                    Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; A ],
                                    M.get_associated_function (|
                                      Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; A ],
                                      "from_inner_in",
                                      [],
                                      []
                                    |),
                                    [
                                      M.call_closure (|
                                        Ty.apply
                                          (Ty.path "core::ptr::non_null::NonNull")
                                          []
                                          [ Ty.apply (Ty.path "alloc::sync::ArcInner") [] [ T ] ],
                                        M.get_associated_function (|
                                          Ty.apply
                                            (Ty.path "core::ptr::non_null::NonNull")
                                            []
                                            [
                                              Ty.apply
                                                (Ty.path "alloc::sync::ArcInner")
                                                []
                                                [
                                                  Ty.dyn
                                                    [
                                                      ("core::any::Any::Trait", []);
                                                      ("core::marker::Sync::AutoTrait", []);
                                                      ("core::marker::Send::AutoTrait", [])
                                                    ]
                                                ]
                                            ],
                                          "cast",
                                          [],
                                          [ Ty.apply (Ty.path "alloc::sync::ArcInner") [] [ T ] ]
                                        |),
                                        [ M.read (| ptr |) ]
                                      |);
                                      M.read (| alloc |)
                                    ]
                                  |)
                                ]
                            |)))
                      ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Err"
                        [ (* Unsize *) M.pointer_coercion (M.read (| self |)) ]
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_downcast :
      forall (A : Ty.t),
      M.IsAssociatedFunction.C (Self A) "downcast" (downcast A).
    Admitted.
    Global Typeclasses Opaque downcast.
    
    (*
        pub unsafe fn downcast_unchecked<T>(self) -> Arc<T, A>
        where
            T: Any + Send + Sync,
        {
            unsafe {
                let (ptr, alloc) = Arc::into_inner_with_allocator(self);
                Arc::from_inner_in(ptr.cast(), alloc)
            }
        }
    *)
    Definition downcast_unchecked
        (A : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self A in
      match ε, τ, α with
      | [], [ T ], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              Ty.apply (Ty.path "*") [] [ Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; A ] ],
              M.alloc (|
                M.call_closure (|
                  Ty.tuple
                    [
                      Ty.apply
                        (Ty.path "core::ptr::non_null::NonNull")
                        []
                        [
                          Ty.apply
                            (Ty.path "alloc::sync::ArcInner")
                            []
                            [
                              Ty.dyn
                                [
                                  ("core::any::Any::Trait", []);
                                  ("core::marker::Sync::AutoTrait", []);
                                  ("core::marker::Send::AutoTrait", [])
                                ]
                            ]
                        ];
                      A
                    ],
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "alloc::sync::Arc")
                      []
                      [
                        Ty.dyn
                          [
                            ("core::any::Any::Trait", []);
                            ("core::marker::Sync::AutoTrait", []);
                            ("core::marker::Send::AutoTrait", [])
                          ];
                        A
                      ],
                    "into_inner_with_allocator",
                    [],
                    []
                  |),
                  [ M.read (| self |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let ptr := M.copy (| γ0_0 |) in
                    let alloc := M.copy (| γ0_1 |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; A ],
                        M.get_associated_function (|
                          Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; A ],
                          "from_inner_in",
                          [],
                          []
                        |),
                        [
                          M.call_closure (|
                            Ty.apply
                              (Ty.path "core::ptr::non_null::NonNull")
                              []
                              [ Ty.apply (Ty.path "alloc::sync::ArcInner") [] [ T ] ],
                            M.get_associated_function (|
                              Ty.apply
                                (Ty.path "core::ptr::non_null::NonNull")
                                []
                                [
                                  Ty.apply
                                    (Ty.path "alloc::sync::ArcInner")
                                    []
                                    [
                                      Ty.dyn
                                        [
                                          ("core::any::Any::Trait", []);
                                          ("core::marker::Sync::AutoTrait", []);
                                          ("core::marker::Send::AutoTrait", [])
                                        ]
                                    ]
                                ],
                              "cast",
                              [],
                              [ Ty.apply (Ty.path "alloc::sync::ArcInner") [] [ T ] ]
                            |),
                            [ M.read (| ptr |) ]
                          |);
                          M.read (| alloc |)
                        ]
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_downcast_unchecked :
      forall (A : Ty.t),
      M.IsAssociatedFunction.C (Self A) "downcast_unchecked" (downcast_unchecked A).
    Admitted.
    Global Typeclasses Opaque downcast_unchecked.
  End Impl_alloc_sync_Arc_Dyn_core_any_Any_Trait_core_marker_Sync_AutoTrait_core_marker_Send_AutoTrait_A.
  
  Module Impl_alloc_sync_Weak_T_alloc_alloc_Global.
    Definition Self (T : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "alloc::sync::Weak") [] [ T; Ty.path "alloc::alloc::Global" ].
    
    (*
        pub const fn new() -> Weak<T> {
            Weak {
                ptr: unsafe {
                    NonNull::new_unchecked(ptr::without_provenance_mut::<ArcInner<T>>(usize::MAX))
                },
                alloc: Global,
            }
        }
    *)
    Definition new (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [], [] =>
        ltac:(M.monadic
          (Value.StructRecord
            "alloc::sync::Weak"
            [
              ("ptr",
                M.call_closure (|
                  Ty.apply
                    (Ty.path "core::ptr::non_null::NonNull")
                    []
                    [ Ty.apply (Ty.path "alloc::sync::ArcInner") [] [ T ] ],
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "core::ptr::non_null::NonNull")
                      []
                      [ Ty.apply (Ty.path "alloc::sync::ArcInner") [] [ T ] ],
                    "new_unchecked",
                    [],
                    []
                  |),
                  [
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "*mut")
                        []
                        [ Ty.apply (Ty.path "alloc::sync::ArcInner") [] [ T ] ],
                      M.get_function (|
                        "core::ptr::without_provenance_mut",
                        [],
                        [ Ty.apply (Ty.path "alloc::sync::ArcInner") [] [ T ] ]
                      |),
                      [
                        M.read (|
                          get_associated_constant (| Ty.path "usize", "MAX", Ty.path "usize" |)
                        |)
                      ]
                    |)
                  ]
                |));
              ("alloc", Value.StructTuple "alloc::alloc::Global" [])
            ]))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_new :
      forall (T : Ty.t),
      M.IsAssociatedFunction.C (Self T) "new" (new T).
    Admitted.
    Global Typeclasses Opaque new.
    (*
        pub unsafe fn from_raw(ptr: *const T) -> Self {
            unsafe { Weak::from_raw_in(ptr, Global) }
        }
    *)
    Definition from_raw (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [], [ ptr ] =>
        ltac:(M.monadic
          (let ptr := M.alloc (| ptr |) in
          M.call_closure (|
            Ty.apply (Ty.path "alloc::sync::Weak") [] [ T; Ty.path "alloc::alloc::Global" ],
            M.get_associated_function (|
              Ty.apply (Ty.path "alloc::sync::Weak") [] [ T; Ty.path "alloc::alloc::Global" ],
              "from_raw_in",
              [],
              []
            |),
            [ M.read (| ptr |); Value.StructTuple "alloc::alloc::Global" [] ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_from_raw :
      forall (T : Ty.t),
      M.IsAssociatedFunction.C (Self T) "from_raw" (from_raw T).
    Admitted.
    Global Typeclasses Opaque from_raw.
  End Impl_alloc_sync_Weak_T_alloc_alloc_Global.
  
  Module Impl_alloc_sync_Weak_T_A.
    Definition Self (T A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::sync::Weak") [] [ T; A ].
    
    (*
        pub fn new_in(alloc: A) -> Weak<T, A> {
            Weak {
                ptr: unsafe {
                    NonNull::new_unchecked(ptr::without_provenance_mut::<ArcInner<T>>(usize::MAX))
                },
                alloc,
            }
        }
    *)
    Definition new_in (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ alloc ] =>
        ltac:(M.monadic
          (let alloc := M.alloc (| alloc |) in
          Value.StructRecord
            "alloc::sync::Weak"
            [
              ("ptr",
                M.call_closure (|
                  Ty.apply
                    (Ty.path "core::ptr::non_null::NonNull")
                    []
                    [ Ty.apply (Ty.path "alloc::sync::ArcInner") [] [ T ] ],
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "core::ptr::non_null::NonNull")
                      []
                      [ Ty.apply (Ty.path "alloc::sync::ArcInner") [] [ T ] ],
                    "new_unchecked",
                    [],
                    []
                  |),
                  [
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "*mut")
                        []
                        [ Ty.apply (Ty.path "alloc::sync::ArcInner") [] [ T ] ],
                      M.get_function (|
                        "core::ptr::without_provenance_mut",
                        [],
                        [ Ty.apply (Ty.path "alloc::sync::ArcInner") [] [ T ] ]
                      |),
                      [
                        M.read (|
                          get_associated_constant (| Ty.path "usize", "MAX", Ty.path "usize" |)
                        |)
                      ]
                    |)
                  ]
                |));
              ("alloc", M.read (| alloc |))
            ]))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_new_in :
      forall (T A : Ty.t),
      M.IsAssociatedFunction.C (Self T A) "new_in" (new_in T A).
    Admitted.
    Global Typeclasses Opaque new_in.
    (*
        pub fn allocator(&self) -> &A {
            &self.alloc
        }
    *)
    Definition allocator (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.borrow (|
            Pointer.Kind.Ref,
            M.deref (|
              M.borrow (|
                Pointer.Kind.Ref,
                M.SubPointer.get_struct_record_field (|
                  M.deref (| M.read (| self |) |),
                  "alloc::sync::Weak",
                  "alloc"
                |)
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_allocator :
      forall (T A : Ty.t),
      M.IsAssociatedFunction.C (Self T A) "allocator" (allocator T A).
    Admitted.
    Global Typeclasses Opaque allocator.
    
    (*
        pub fn as_ptr(&self) -> *const T {
            let ptr: *mut ArcInner<T> = NonNull::as_ptr(self.ptr);
    
            if is_dangling(ptr) {
                // If the pointer is dangling, we return the sentinel directly. This cannot be
                // a valid payload address, as the payload is at least as aligned as ArcInner (usize).
                ptr as *const T
            } else {
                // SAFETY: if is_dangling returns false, then the pointer is dereferenceable.
                // The payload may be dropped at this point, and we have to maintain provenance,
                // so use raw pointer manipulation.
                unsafe { &raw mut ( *ptr).data }
            }
        }
    *)
    Definition as_ptr (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            let~ ptr :
                Ty.apply
                  (Ty.path "*")
                  []
                  [
                    Ty.apply
                      (Ty.path "*mut")
                      []
                      [ Ty.apply (Ty.path "alloc::sync::ArcInner") [] [ T ] ]
                  ] :=
              M.alloc (|
                M.call_closure (|
                  Ty.apply
                    (Ty.path "*mut")
                    []
                    [ Ty.apply (Ty.path "alloc::sync::ArcInner") [] [ T ] ],
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "core::ptr::non_null::NonNull")
                      []
                      [ Ty.apply (Ty.path "alloc::sync::ArcInner") [] [ T ] ],
                    "as_ptr",
                    [],
                    []
                  |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "alloc::sync::Weak",
                        "ptr"
                      |)
                    |)
                  ]
                |)
              |) in
            M.match_operator (|
              Ty.apply (Ty.path "*") [] [ Ty.apply (Ty.path "*const") [] [ T ] ],
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          M.call_closure (|
                            Ty.path "bool",
                            M.get_function (|
                              "alloc::rc::is_dangling",
                              [],
                              [ Ty.apply (Ty.path "alloc::sync::ArcInner") [] [ T ] ]
                            |),
                            [ (* MutToConstPointer *) M.pointer_coercion (M.read (| ptr |)) ]
                          |)
                        |)) in
                    let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (|
                      M.cast (Ty.apply (Ty.path "*const") [] [ T ]) (M.read (| ptr |))
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      (* MutToConstPointer *)
                      M.pointer_coercion
                        (M.borrow (|
                          Pointer.Kind.MutPointer,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| ptr |) |),
                            "alloc::sync::ArcInner",
                            "data"
                          |)
                        |))
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_as_ptr :
      forall (T A : Ty.t),
      M.IsAssociatedFunction.C (Self T A) "as_ptr" (as_ptr T A).
    Admitted.
    Global Typeclasses Opaque as_ptr.
    
    (*
        pub fn into_raw(self) -> *const T {
            ManuallyDrop::new(self).as_ptr()
        }
    *)
    Definition into_raw (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            Ty.apply (Ty.path "*const") [] [ T ],
            M.get_associated_function (|
              Ty.apply (Ty.path "alloc::sync::Weak") [] [ T; A ],
              "as_ptr",
              [],
              []
            |),
            [
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "&")
                      []
                      [ Ty.apply (Ty.path "alloc::sync::Weak") [] [ T; A ] ],
                    M.get_trait_method (|
                      "core::ops::deref::Deref",
                      Ty.apply
                        (Ty.path "core::mem::manually_drop::ManuallyDrop")
                        []
                        [ Ty.apply (Ty.path "alloc::sync::Weak") [] [ T; A ] ],
                      [],
                      [],
                      "deref",
                      [],
                      []
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.alloc (|
                          M.call_closure (|
                            Ty.apply
                              (Ty.path "core::mem::manually_drop::ManuallyDrop")
                              []
                              [ Ty.apply (Ty.path "alloc::sync::Weak") [] [ T; A ] ],
                            M.get_associated_function (|
                              Ty.apply
                                (Ty.path "core::mem::manually_drop::ManuallyDrop")
                                []
                                [ Ty.apply (Ty.path "alloc::sync::Weak") [] [ T; A ] ],
                              "new",
                              [],
                              []
                            |),
                            [ M.read (| self |) ]
                          |)
                        |)
                      |)
                    ]
                  |)
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_into_raw :
      forall (T A : Ty.t),
      M.IsAssociatedFunction.C (Self T A) "into_raw" (into_raw T A).
    Admitted.
    Global Typeclasses Opaque into_raw.
    
    (*
        pub fn into_raw_with_allocator(self) -> ( *const T, A) {
            let this = mem::ManuallyDrop::new(self);
            let result = this.as_ptr();
            // Safety: `this` is ManuallyDrop so the allocator will not be double-dropped
            let alloc = unsafe { ptr::read(&this.alloc) };
            (result, alloc)
        }
    *)
    Definition into_raw_with_allocator
        (T A : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            let~ this :
                Ty.apply
                  (Ty.path "*")
                  []
                  [
                    Ty.apply
                      (Ty.path "core::mem::manually_drop::ManuallyDrop")
                      []
                      [ Ty.apply (Ty.path "alloc::sync::Weak") [] [ T; A ] ]
                  ] :=
              M.alloc (|
                M.call_closure (|
                  Ty.apply
                    (Ty.path "core::mem::manually_drop::ManuallyDrop")
                    []
                    [ Ty.apply (Ty.path "alloc::sync::Weak") [] [ T; A ] ],
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "core::mem::manually_drop::ManuallyDrop")
                      []
                      [ Ty.apply (Ty.path "alloc::sync::Weak") [] [ T; A ] ],
                    "new",
                    [],
                    []
                  |),
                  [ M.read (| self |) ]
                |)
              |) in
            let~ result : Ty.apply (Ty.path "*") [] [ Ty.apply (Ty.path "*const") [] [ T ] ] :=
              M.alloc (|
                M.call_closure (|
                  Ty.apply (Ty.path "*const") [] [ T ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "alloc::sync::Weak") [] [ T; A ],
                    "as_ptr",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "&")
                            []
                            [ Ty.apply (Ty.path "alloc::sync::Weak") [] [ T; A ] ],
                          M.get_trait_method (|
                            "core::ops::deref::Deref",
                            Ty.apply
                              (Ty.path "core::mem::manually_drop::ManuallyDrop")
                              []
                              [ Ty.apply (Ty.path "alloc::sync::Weak") [] [ T; A ] ],
                            [],
                            [],
                            "deref",
                            [],
                            []
                          |),
                          [ M.borrow (| Pointer.Kind.Ref, this |) ]
                        |)
                      |)
                    |)
                  ]
                |)
              |) in
            let~ alloc : Ty.apply (Ty.path "*") [] [ A ] :=
              M.alloc (|
                M.call_closure (|
                  A,
                  M.get_function (| "core::ptr::read", [], [ A ] |),
                  [
                    M.borrow (|
                      Pointer.Kind.ConstPointer,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (|
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "&")
                                  []
                                  [ Ty.apply (Ty.path "alloc::sync::Weak") [] [ T; A ] ],
                                M.get_trait_method (|
                                  "core::ops::deref::Deref",
                                  Ty.apply
                                    (Ty.path "core::mem::manually_drop::ManuallyDrop")
                                    []
                                    [ Ty.apply (Ty.path "alloc::sync::Weak") [] [ T; A ] ],
                                  [],
                                  [],
                                  "deref",
                                  [],
                                  []
                                |),
                                [ M.borrow (| Pointer.Kind.Ref, this |) ]
                              |)
                            |),
                            "alloc::sync::Weak",
                            "alloc"
                          |)
                        |)
                      |)
                    |)
                  ]
                |)
              |) in
            M.alloc (| Value.Tuple [ M.read (| result |); M.read (| alloc |) ] |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_into_raw_with_allocator :
      forall (T A : Ty.t),
      M.IsAssociatedFunction.C (Self T A) "into_raw_with_allocator" (into_raw_with_allocator T A).
    Admitted.
    Global Typeclasses Opaque into_raw_with_allocator.
    
    (*
        pub unsafe fn from_raw_in(ptr: *const T, alloc: A) -> Self {
            // See Weak::as_ptr for context on how the input pointer is derived.
    
            let ptr = if is_dangling(ptr) {
                // This is a dangling Weak.
                ptr as *mut ArcInner<T>
            } else {
                // Otherwise, we're guaranteed the pointer came from a nondangling Weak.
                // SAFETY: data_offset is safe to call, as ptr references a real (potentially dropped) T.
                let offset = unsafe { data_offset(ptr) };
                // Thus, we reverse the offset to get the whole RcInner.
                // SAFETY: the pointer originated from a Weak, so this offset is safe.
                unsafe { ptr.byte_sub(offset) as *mut ArcInner<T> }
            };
    
            // SAFETY: we now have recovered the original Weak pointer, so can create the Weak.
            Weak { ptr: unsafe { NonNull::new_unchecked(ptr) }, alloc }
        }
    *)
    Definition from_raw_in (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ ptr; alloc ] =>
        ltac:(M.monadic
          (let ptr := M.alloc (| ptr |) in
          let alloc := M.alloc (| alloc |) in
          M.read (|
            let~ ptr :
                Ty.apply
                  (Ty.path "*")
                  []
                  [
                    Ty.apply
                      (Ty.path "*mut")
                      []
                      [ Ty.apply (Ty.path "alloc::sync::ArcInner") [] [ T ] ]
                  ] :=
              M.copy (|
                M.match_operator (|
                  Ty.apply
                    (Ty.path "*")
                    []
                    [
                      Ty.apply
                        (Ty.path "*mut")
                        []
                        [ Ty.apply (Ty.path "alloc::sync::ArcInner") [] [ T ] ]
                    ],
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ :=
                          M.use
                            (M.alloc (|
                              M.call_closure (|
                                Ty.path "bool",
                                M.get_function (| "alloc::rc::is_dangling", [], [ T ] |),
                                [ M.read (| ptr |) ]
                              |)
                            |)) in
                        let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        M.alloc (|
                          M.cast
                            (Ty.apply
                              (Ty.path "*mut")
                              []
                              [ Ty.apply (Ty.path "alloc::sync::ArcInner") [] [ T ] ])
                            (M.read (| ptr |))
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let~ offset : Ty.apply (Ty.path "*") [] [ Ty.path "usize" ] :=
                          M.alloc (|
                            M.call_closure (|
                              Ty.path "usize",
                              M.get_function (| "alloc::sync::data_offset", [], [ T ] |),
                              [ M.read (| ptr |) ]
                            |)
                          |) in
                        M.alloc (|
                          M.cast
                            (Ty.apply
                              (Ty.path "*mut")
                              []
                              [ Ty.apply (Ty.path "alloc::sync::ArcInner") [] [ T ] ])
                            (M.call_closure (|
                              Ty.apply (Ty.path "*const") [] [ T ],
                              M.get_associated_function (|
                                Ty.apply (Ty.path "*const") [] [ T ],
                                "byte_sub",
                                [],
                                []
                              |),
                              [ M.read (| ptr |); M.read (| offset |) ]
                            |))
                        |)))
                  ]
                |)
              |) in
            M.alloc (|
              Value.StructRecord
                "alloc::sync::Weak"
                [
                  ("ptr",
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "core::ptr::non_null::NonNull")
                        []
                        [ Ty.apply (Ty.path "alloc::sync::ArcInner") [] [ T ] ],
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "core::ptr::non_null::NonNull")
                          []
                          [ Ty.apply (Ty.path "alloc::sync::ArcInner") [] [ T ] ],
                        "new_unchecked",
                        [],
                        []
                      |),
                      [ M.read (| ptr |) ]
                    |));
                  ("alloc", M.read (| alloc |))
                ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_from_raw_in :
      forall (T A : Ty.t),
      M.IsAssociatedFunction.C (Self T A) "from_raw_in" (from_raw_in T A).
    Admitted.
    Global Typeclasses Opaque from_raw_in.
    (*
        pub fn upgrade(&self) -> Option<Arc<T, A>>
        where
            A: Clone,
        {
            #[inline]
            fn checked_increment(n: usize) -> Option<usize> {
                // Any write of 0 we can observe leaves the field in permanently zero state.
                if n == 0 {
                    return None;
                }
                // See comments in `Arc::clone` for why we do this (for `mem::forget`).
                assert!(n <= MAX_REFCOUNT, "{}", INTERNAL_OVERFLOW_ERROR);
                Some(n + 1)
            }
    
            // We use a CAS loop to increment the strong count instead of a
            // fetch_add as this function should never take the reference count
            // from zero to one.
            //
            // Relaxed is fine for the failure case because we don't have any expectations about the new state.
            // Acquire is necessary for the success case to synchronise with `Arc::new_cyclic`, when the inner
            // value can be initialized after `Weak` references have already been created. In that case, we
            // expect to observe the fully initialized value.
            if self.inner()?.strong.fetch_update(Acquire, Relaxed, checked_increment).is_ok() {
                // SAFETY: pointer is not null, verified in checked_increment
                unsafe { Some(Arc::from_inner_in(self.ptr, self.alloc.clone())) }
            } else {
                None
            }
        }
    *)
    Definition upgrade (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.catch_return
            (Ty.apply
              (Ty.path "core::option::Option")
              []
              [ Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; A ] ]) (|
            ltac:(M.monadic
              (M.read (|
                M.match_operator (|
                  Ty.apply
                    (Ty.path "*")
                    []
                    [
                      Ty.apply
                        (Ty.path "core::option::Option")
                        []
                        [ Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; A ] ]
                    ],
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ :=
                          M.use
                            (M.alloc (|
                              M.call_closure (|
                                Ty.path "bool",
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "core::result::Result")
                                    []
                                    [ Ty.path "usize"; Ty.path "usize" ],
                                  "is_ok",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      M.call_closure (|
                                        Ty.apply
                                          (Ty.path "core::result::Result")
                                          []
                                          [ Ty.path "usize"; Ty.path "usize" ],
                                        M.get_associated_function (|
                                          Ty.path "core::sync::atomic::AtomicUsize",
                                          "fetch_update",
                                          [],
                                          [
                                            Ty.function
                                              [ Ty.path "usize" ]
                                              (Ty.apply
                                                (Ty.path "core::option::Option")
                                                []
                                                [ Ty.path "usize" ])
                                          ]
                                        |),
                                        [
                                          M.borrow (|
                                            Pointer.Kind.Ref,
                                            M.deref (|
                                              M.read (|
                                                M.SubPointer.get_struct_record_field (|
                                                  M.match_operator (|
                                                    Ty.apply
                                                      (Ty.path "*")
                                                      []
                                                      [ Ty.path "alloc::sync::WeakInner" ],
                                                    M.alloc (|
                                                      M.call_closure (|
                                                        Ty.apply
                                                          (Ty.path
                                                            "core::ops::control_flow::ControlFlow")
                                                          []
                                                          [
                                                            Ty.apply
                                                              (Ty.path "core::option::Option")
                                                              []
                                                              [ Ty.path "core::convert::Infallible"
                                                              ];
                                                            Ty.path "alloc::sync::WeakInner"
                                                          ],
                                                        M.get_trait_method (|
                                                          "core::ops::try_trait::Try",
                                                          Ty.apply
                                                            (Ty.path "core::option::Option")
                                                            []
                                                            [ Ty.path "alloc::sync::WeakInner" ],
                                                          [],
                                                          [],
                                                          "branch",
                                                          [],
                                                          []
                                                        |),
                                                        [
                                                          M.call_closure (|
                                                            Ty.apply
                                                              (Ty.path "core::option::Option")
                                                              []
                                                              [ Ty.path "alloc::sync::WeakInner" ],
                                                            M.get_associated_function (|
                                                              Ty.apply
                                                                (Ty.path "alloc::sync::Weak")
                                                                []
                                                                [ T; A ],
                                                              "inner",
                                                              [],
                                                              []
                                                            |),
                                                            [
                                                              M.borrow (|
                                                                Pointer.Kind.Ref,
                                                                M.deref (| M.read (| self |) |)
                                                              |)
                                                            ]
                                                          |)
                                                        ]
                                                      |)
                                                    |),
                                                    [
                                                      fun γ =>
                                                        ltac:(M.monadic
                                                          (let γ0_0 :=
                                                            M.SubPointer.get_struct_tuple_field (|
                                                              γ,
                                                              "core::ops::control_flow::ControlFlow::Break",
                                                              0
                                                            |) in
                                                          let residual := M.copy (| γ0_0 |) in
                                                          M.alloc (|
                                                            M.never_to_any (|
                                                              M.read (|
                                                                M.return_ (|
                                                                  M.call_closure (|
                                                                    Ty.apply
                                                                      (Ty.path
                                                                        "core::option::Option")
                                                                      []
                                                                      [
                                                                        Ty.apply
                                                                          (Ty.path
                                                                            "alloc::sync::Arc")
                                                                          []
                                                                          [ T; A ]
                                                                      ],
                                                                    M.get_trait_method (|
                                                                      "core::ops::try_trait::FromResidual",
                                                                      Ty.apply
                                                                        (Ty.path
                                                                          "core::option::Option")
                                                                        []
                                                                        [
                                                                          Ty.apply
                                                                            (Ty.path
                                                                              "alloc::sync::Arc")
                                                                            []
                                                                            [ T; A ]
                                                                        ],
                                                                      [],
                                                                      [
                                                                        Ty.apply
                                                                          (Ty.path
                                                                            "core::option::Option")
                                                                          []
                                                                          [
                                                                            Ty.path
                                                                              "core::convert::Infallible"
                                                                          ]
                                                                      ],
                                                                      "from_residual",
                                                                      [],
                                                                      []
                                                                    |),
                                                                    [ M.read (| residual |) ]
                                                                  |)
                                                                |)
                                                              |)
                                                            |)
                                                          |)));
                                                      fun γ =>
                                                        ltac:(M.monadic
                                                          (let γ0_0 :=
                                                            M.SubPointer.get_struct_tuple_field (|
                                                              γ,
                                                              "core::ops::control_flow::ControlFlow::Continue",
                                                              0
                                                            |) in
                                                          let val := M.copy (| γ0_0 |) in
                                                          val))
                                                    ]
                                                  |),
                                                  "alloc::sync::WeakInner",
                                                  "strong"
                                                |)
                                              |)
                                            |)
                                          |);
                                          Value.StructTuple
                                            "core::sync::atomic::Ordering::Acquire"
                                            [];
                                          Value.StructTuple
                                            "core::sync::atomic::Ordering::Relaxed"
                                            [];
                                          M.get_associated_function (|
                                            Self,
                                            "checked_increment.upgrade",
                                            [],
                                            []
                                          |)
                                        ]
                                      |)
                                    |)
                                  |)
                                ]
                              |)
                            |)) in
                        let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        M.alloc (|
                          Value.StructTuple
                            "core::option::Option::Some"
                            [
                              M.call_closure (|
                                Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; A ],
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; A ],
                                  "from_inner_in",
                                  [],
                                  []
                                |),
                                [
                                  M.read (|
                                    M.SubPointer.get_struct_record_field (|
                                      M.deref (| M.read (| self |) |),
                                      "alloc::sync::Weak",
                                      "ptr"
                                    |)
                                  |);
                                  M.call_closure (|
                                    A,
                                    M.get_trait_method (|
                                      "core::clone::Clone",
                                      A,
                                      [],
                                      [],
                                      "clone",
                                      [],
                                      []
                                    |),
                                    [
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.SubPointer.get_struct_record_field (|
                                          M.deref (| M.read (| self |) |),
                                          "alloc::sync::Weak",
                                          "alloc"
                                        |)
                                      |)
                                    ]
                                  |)
                                ]
                              |)
                            ]
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
                  ]
                |)
              |)))
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_upgrade :
      forall (T A : Ty.t),
      M.IsAssociatedFunction.C (Self T A) "upgrade" (upgrade T A).
    Admitted.
    Global Typeclasses Opaque upgrade.
    
    (*
        pub fn strong_count(&self) -> usize {
            if let Some(inner) = self.inner() { inner.strong.load(Relaxed) } else { 0 }
        }
    *)
    Definition strong_count
        (T A : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              Ty.apply (Ty.path "*") [] [ Ty.path "usize" ],
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.alloc (|
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "core::option::Option")
                            []
                            [ Ty.path "alloc::sync::WeakInner" ],
                          M.get_associated_function (|
                            Ty.apply (Ty.path "alloc::sync::Weak") [] [ T; A ],
                            "inner",
                            [],
                            []
                          |),
                          [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                        |)
                      |) in
                    let γ0_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "core::option::Option::Some",
                        0
                      |) in
                    let inner := M.copy (| γ0_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.path "usize",
                        M.get_associated_function (|
                          Ty.path "core::sync::atomic::AtomicUsize",
                          "load",
                          [],
                          []
                        |),
                        [
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (|
                              M.read (|
                                M.SubPointer.get_struct_record_field (|
                                  inner,
                                  "alloc::sync::WeakInner",
                                  "strong"
                                |)
                              |)
                            |)
                          |);
                          Value.StructTuple "core::sync::atomic::Ordering::Relaxed" []
                        ]
                      |)
                    |)));
                fun γ => ltac:(M.monadic (M.alloc (| Value.Integer IntegerKind.Usize 0 |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_strong_count :
      forall (T A : Ty.t),
      M.IsAssociatedFunction.C (Self T A) "strong_count" (strong_count T A).
    Admitted.
    Global Typeclasses Opaque strong_count.
    
    (*
        pub fn weak_count(&self) -> usize {
            if let Some(inner) = self.inner() {
                let weak = inner.weak.load(Acquire);
                let strong = inner.strong.load(Relaxed);
                if strong == 0 {
                    0
                } else {
                    // Since we observed that there was at least one strong pointer
                    // after reading the weak count, we know that the implicit weak
                    // reference (present whenever any strong references are alive)
                    // was still around when we observed the weak count, and can
                    // therefore safely subtract it.
                    weak - 1
                }
            } else {
                0
            }
        }
    *)
    Definition weak_count (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              Ty.apply (Ty.path "*") [] [ Ty.path "usize" ],
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.alloc (|
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "core::option::Option")
                            []
                            [ Ty.path "alloc::sync::WeakInner" ],
                          M.get_associated_function (|
                            Ty.apply (Ty.path "alloc::sync::Weak") [] [ T; A ],
                            "inner",
                            [],
                            []
                          |),
                          [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                        |)
                      |) in
                    let γ0_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "core::option::Option::Some",
                        0
                      |) in
                    let inner := M.copy (| γ0_0 |) in
                    let~ weak : Ty.apply (Ty.path "*") [] [ Ty.path "usize" ] :=
                      M.alloc (|
                        M.call_closure (|
                          Ty.path "usize",
                          M.get_associated_function (|
                            Ty.path "core::sync::atomic::AtomicUsize",
                            "load",
                            [],
                            []
                          |),
                          [
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.deref (|
                                M.read (|
                                  M.SubPointer.get_struct_record_field (|
                                    inner,
                                    "alloc::sync::WeakInner",
                                    "weak"
                                  |)
                                |)
                              |)
                            |);
                            Value.StructTuple "core::sync::atomic::Ordering::Acquire" []
                          ]
                        |)
                      |) in
                    let~ strong : Ty.apply (Ty.path "*") [] [ Ty.path "usize" ] :=
                      M.alloc (|
                        M.call_closure (|
                          Ty.path "usize",
                          M.get_associated_function (|
                            Ty.path "core::sync::atomic::AtomicUsize",
                            "load",
                            [],
                            []
                          |),
                          [
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.deref (|
                                M.read (|
                                  M.SubPointer.get_struct_record_field (|
                                    inner,
                                    "alloc::sync::WeakInner",
                                    "strong"
                                  |)
                                |)
                              |)
                            |);
                            Value.StructTuple "core::sync::atomic::Ordering::Relaxed" []
                          ]
                        |)
                      |) in
                    M.match_operator (|
                      Ty.apply (Ty.path "*") [] [ Ty.path "usize" ],
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  M.call_closure (|
                                    Ty.path "bool",
                                    BinOp.eq,
                                    [ M.read (| strong |); Value.Integer IntegerKind.Usize 0 ]
                                  |)
                                |)) in
                            let _ :=
                              is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (| Value.Integer IntegerKind.Usize 0 |)));
                        fun γ =>
                          ltac:(M.monadic
                            (M.alloc (|
                              M.call_closure (|
                                Ty.path "usize",
                                BinOp.Wrap.sub,
                                [ M.read (| weak |); Value.Integer IntegerKind.Usize 1 ]
                              |)
                            |)))
                      ]
                    |)));
                fun γ => ltac:(M.monadic (M.alloc (| Value.Integer IntegerKind.Usize 0 |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_weak_count :
      forall (T A : Ty.t),
      M.IsAssociatedFunction.C (Self T A) "weak_count" (weak_count T A).
    Admitted.
    Global Typeclasses Opaque weak_count.
    
    (*
        fn inner(&self) -> Option<WeakInner<'_>> {
            let ptr = self.ptr.as_ptr();
            if is_dangling(ptr) {
                None
            } else {
                // We are careful to *not* create a reference covering the "data" field, as
                // the field may be mutated concurrently (for example, if the last `Arc`
                // is dropped, the data field will be dropped in-place).
                Some(unsafe { WeakInner { strong: &( *ptr).strong, weak: &( *ptr).weak } })
            }
        }
    *)
    Definition inner (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            let~ ptr :
                Ty.apply
                  (Ty.path "*")
                  []
                  [
                    Ty.apply
                      (Ty.path "*mut")
                      []
                      [ Ty.apply (Ty.path "alloc::sync::ArcInner") [] [ T ] ]
                  ] :=
              M.alloc (|
                M.call_closure (|
                  Ty.apply
                    (Ty.path "*mut")
                    []
                    [ Ty.apply (Ty.path "alloc::sync::ArcInner") [] [ T ] ],
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "core::ptr::non_null::NonNull")
                      []
                      [ Ty.apply (Ty.path "alloc::sync::ArcInner") [] [ T ] ],
                    "as_ptr",
                    [],
                    []
                  |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "alloc::sync::Weak",
                        "ptr"
                      |)
                    |)
                  ]
                |)
              |) in
            M.match_operator (|
              Ty.apply
                (Ty.path "*")
                []
                [ Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "alloc::sync::WeakInner" ]
                ],
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          M.call_closure (|
                            Ty.path "bool",
                            M.get_function (|
                              "alloc::rc::is_dangling",
                              [],
                              [ Ty.apply (Ty.path "alloc::sync::ArcInner") [] [ T ] ]
                            |),
                            [ (* MutToConstPointer *) M.pointer_coercion (M.read (| ptr |)) ]
                          |)
                        |)) in
                    let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      Value.StructTuple
                        "core::option::Option::Some"
                        [
                          Value.StructRecord
                            "alloc::sync::WeakInner"
                            [
                              ("strong",
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.deref (|
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.SubPointer.get_struct_record_field (|
                                        M.deref (| M.read (| ptr |) |),
                                        "alloc::sync::ArcInner",
                                        "strong"
                                      |)
                                    |)
                                  |)
                                |));
                              ("weak",
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.deref (|
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.SubPointer.get_struct_record_field (|
                                        M.deref (| M.read (| ptr |) |),
                                        "alloc::sync::ArcInner",
                                        "weak"
                                      |)
                                    |)
                                  |)
                                |))
                            ]
                        ]
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_inner :
      forall (T A : Ty.t),
      M.IsAssociatedFunction.C (Self T A) "inner" (inner T A).
    Admitted.
    Global Typeclasses Opaque inner.
    
    (*
        pub fn ptr_eq(&self, other: &Self) -> bool {
            ptr::addr_eq(self.ptr.as_ptr(), other.ptr.as_ptr())
        }
    *)
    Definition ptr_eq (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            Ty.path "bool",
            M.get_function (|
              "core::ptr::addr_eq",
              [],
              [
                Ty.apply (Ty.path "alloc::sync::ArcInner") [] [ T ];
                Ty.apply (Ty.path "alloc::sync::ArcInner") [] [ T ]
              ]
            |),
            [
              (* MutToConstPointer *)
              M.pointer_coercion
                (M.call_closure (|
                  Ty.apply
                    (Ty.path "*mut")
                    []
                    [ Ty.apply (Ty.path "alloc::sync::ArcInner") [] [ T ] ],
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "core::ptr::non_null::NonNull")
                      []
                      [ Ty.apply (Ty.path "alloc::sync::ArcInner") [] [ T ] ],
                    "as_ptr",
                    [],
                    []
                  |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "alloc::sync::Weak",
                        "ptr"
                      |)
                    |)
                  ]
                |));
              (* MutToConstPointer *)
              M.pointer_coercion
                (M.call_closure (|
                  Ty.apply
                    (Ty.path "*mut")
                    []
                    [ Ty.apply (Ty.path "alloc::sync::ArcInner") [] [ T ] ],
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "core::ptr::non_null::NonNull")
                      []
                      [ Ty.apply (Ty.path "alloc::sync::ArcInner") [] [ T ] ],
                    "as_ptr",
                    [],
                    []
                  |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| other |) |),
                        "alloc::sync::Weak",
                        "ptr"
                      |)
                    |)
                  ]
                |))
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_ptr_eq :
      forall (T A : Ty.t),
      M.IsAssociatedFunction.C (Self T A) "ptr_eq" (ptr_eq T A).
    Admitted.
    Global Typeclasses Opaque ptr_eq.
  End Impl_alloc_sync_Weak_T_A.
  
  (* StructRecord
    {
      name := "WeakInner";
      const_params := [];
      ty_params := [];
      fields :=
        [
          ("weak", Ty.apply (Ty.path "&") [] [ Ty.path "core::sync::atomic::AtomicUsize" ]);
          ("strong", Ty.apply (Ty.path "&") [] [ Ty.path "core::sync::atomic::AtomicUsize" ])
        ];
    } *)
  
  
  
  
  Module Impl_core_clone_Clone_where_core_marker_Sized_T_where_core_alloc_Allocator_A_where_core_clone_Clone_A_for_alloc_sync_Weak_T_A.
    Definition Self (T A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::sync::Weak") [] [ T; A ].
    
    (*
        fn clone(&self) -> Weak<T, A> {
            if let Some(inner) = self.inner() {
                // See comments in Arc::clone() for why this is relaxed. This can use a
                // fetch_add (ignoring the lock) because the weak count is only locked
                // where are *no other* weak pointers in existence. (So we can't be
                // running this code in that case).
                let old_size = inner.weak.fetch_add(1, Relaxed);
    
                // See comments in Arc::clone() for why we do this (for mem::forget).
                if old_size > MAX_REFCOUNT {
                    abort();
                }
            }
    
            Weak { ptr: self.ptr, alloc: self.alloc.clone() }
        }
    *)
    Definition clone (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
              M.match_operator (|
                Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.alloc (|
                          M.call_closure (|
                            Ty.apply
                              (Ty.path "core::option::Option")
                              []
                              [ Ty.path "alloc::sync::WeakInner" ],
                            M.get_associated_function (|
                              Ty.apply (Ty.path "alloc::sync::Weak") [] [ T; A ],
                              "inner",
                              [],
                              []
                            |),
                            [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                          |)
                        |) in
                      let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::option::Option::Some",
                          0
                        |) in
                      let inner := M.copy (| γ0_0 |) in
                      let~ old_size : Ty.apply (Ty.path "*") [] [ Ty.path "usize" ] :=
                        M.alloc (|
                          M.call_closure (|
                            Ty.path "usize",
                            M.get_associated_function (|
                              Ty.path "core::sync::atomic::AtomicUsize",
                              "fetch_add",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.read (|
                                    M.SubPointer.get_struct_record_field (|
                                      inner,
                                      "alloc::sync::WeakInner",
                                      "weak"
                                    |)
                                  |)
                                |)
                              |);
                              Value.Integer IntegerKind.Usize 1;
                              Value.StructTuple "core::sync::atomic::Ordering::Relaxed" []
                            ]
                          |)
                        |) in
                      M.match_operator (|
                        Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                        M.alloc (| Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.use
                                  (M.alloc (|
                                    M.call_closure (|
                                      Ty.path "bool",
                                      BinOp.gt,
                                      [
                                        M.read (| old_size |);
                                        M.read (|
                                          get_constant (|
                                            "alloc::sync::MAX_REFCOUNT",
                                            Ty.path "usize"
                                          |)
                                        |)
                                      ]
                                    |)
                                  |)) in
                              let _ :=
                                is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                              M.alloc (|
                                M.never_to_any (|
                                  M.call_closure (|
                                    Ty.path "never",
                                    M.get_function (| "core::intrinsics::abort", [], [] |),
                                    []
                                  |)
                                |)
                              |)));
                          fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                        ]
                      |)));
                  fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                ]
              |) in
            M.alloc (|
              Value.StructRecord
                "alloc::sync::Weak"
                [
                  ("ptr",
                    M.read (|
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "alloc::sync::Weak",
                        "ptr"
                      |)
                    |));
                  ("alloc",
                    M.call_closure (|
                      A,
                      M.get_trait_method (| "core::clone::Clone", A, [], [], "clone", [], [] |),
                      [
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "alloc::sync::Weak",
                            "alloc"
                          |)
                        |)
                      ]
                    |))
                ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (T A : Ty.t),
      M.IsTraitInstance
        "core::clone::Clone"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self T A)
        (* Instance *) [ ("clone", InstanceField.Method (clone T A)) ].
  End Impl_core_clone_Clone_where_core_marker_Sized_T_where_core_alloc_Allocator_A_where_core_clone_Clone_A_for_alloc_sync_Weak_T_A.
  
  Module Impl_core_default_Default_for_alloc_sync_Weak_T_alloc_alloc_Global.
    Definition Self (T : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "alloc::sync::Weak") [] [ T; Ty.path "alloc::alloc::Global" ].
    
    (*
        fn default() -> Weak<T> {
            Weak::new()
        }
    *)
    Definition default (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [], [] =>
        ltac:(M.monadic
          (M.call_closure (|
            Ty.apply (Ty.path "alloc::sync::Weak") [] [ T; Ty.path "alloc::alloc::Global" ],
            M.get_associated_function (|
              Ty.apply (Ty.path "alloc::sync::Weak") [] [ T; Ty.path "alloc::alloc::Global" ],
              "new",
              [],
              []
            |),
            []
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "core::default::Default"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self T)
        (* Instance *) [ ("default", InstanceField.Method (default T)) ].
  End Impl_core_default_Default_for_alloc_sync_Weak_T_alloc_alloc_Global.
  
  Module Impl_core_ops_drop_Drop_where_core_marker_Sized_T_where_core_alloc_Allocator_A_for_alloc_sync_Weak_T_A.
    Definition Self (T A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::sync::Weak") [] [ T; A ].
    
    (*
        fn drop(&mut self) {
            // If we find out that we were the last weak pointer, then its time to
            // deallocate the data entirely. See the discussion in Arc::drop() about
            // the memory orderings
            //
            // It's not necessary to check for the locked state here, because the
            // weak count can only be locked if there was precisely one weak ref,
            // meaning that drop could only subsequently run ON that remaining weak
            // ref, which can only happen after the lock is released.
            let inner = if let Some(inner) = self.inner() { inner } else { return };
    
            if inner.weak.fetch_sub(1, Release) == 1 {
                acquire!(inner.weak);
    
                // Make sure we aren't trying to "deallocate" the shared static for empty slices
                // used by Default::default.
                debug_assert!(
                    !ptr::addr_eq(self.ptr.as_ptr(), &STATIC_INNER_SLICE.inner),
                    "Arc/Weaks backed by a static should never be deallocated. \
                    Likely decrement_strong_count or from_raw were called too many times.",
                );
    
                unsafe {
                    self.alloc.deallocate(self.ptr.cast(), Layout::for_value_raw(self.ptr.as_ptr()))
                }
            }
        }
    *)
    Definition drop (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.catch_return (Ty.tuple []) (|
            ltac:(M.monadic
              (M.read (|
                let~ inner : Ty.apply (Ty.path "*") [] [ Ty.path "alloc::sync::WeakInner" ] :=
                  M.copy (|
                    M.match_operator (|
                      Ty.apply (Ty.path "*") [] [ Ty.path "alloc::sync::WeakInner" ],
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.alloc (|
                                M.call_closure (|
                                  Ty.apply
                                    (Ty.path "core::option::Option")
                                    []
                                    [ Ty.path "alloc::sync::WeakInner" ],
                                  M.get_associated_function (|
                                    Ty.apply (Ty.path "alloc::sync::Weak") [] [ T; A ],
                                    "inner",
                                    [],
                                    []
                                  |),
                                  [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |)
                                  ]
                                |)
                              |) in
                            let γ0_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "core::option::Option::Some",
                                0
                              |) in
                            let inner := M.copy (| γ0_0 |) in
                            inner));
                        fun γ =>
                          ltac:(M.monadic
                            (M.alloc (|
                              M.never_to_any (| M.read (| M.return_ (| Value.Tuple [] |) |) |)
                            |)))
                      ]
                    |)
                  |) in
                M.match_operator (|
                  Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ :=
                          M.use
                            (M.alloc (|
                              M.call_closure (|
                                Ty.path "bool",
                                BinOp.eq,
                                [
                                  M.call_closure (|
                                    Ty.path "usize",
                                    M.get_associated_function (|
                                      Ty.path "core::sync::atomic::AtomicUsize",
                                      "fetch_sub",
                                      [],
                                      []
                                    |),
                                    [
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.deref (|
                                          M.read (|
                                            M.SubPointer.get_struct_record_field (|
                                              inner,
                                              "alloc::sync::WeakInner",
                                              "weak"
                                            |)
                                          |)
                                        |)
                                      |);
                                      Value.Integer IntegerKind.Usize 1;
                                      Value.StructTuple "core::sync::atomic::Ordering::Release" []
                                    ]
                                  |);
                                  Value.Integer IntegerKind.Usize 1
                                ]
                              |)
                            |)) in
                        let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                          M.alloc (|
                            M.call_closure (|
                              Ty.tuple [],
                              M.get_function (| "core::sync::atomic::fence", [], [] |),
                              [ Value.StructTuple "core::sync::atomic::Ordering::Acquire" [] ]
                            |)
                          |) in
                        let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                          M.match_operator (|
                            Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                            M.alloc (| Value.Tuple [] |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ := M.use (M.alloc (| Value.Bool true |)) in
                                  let _ :=
                                    is_constant_or_break_match (|
                                      M.read (| γ |),
                                      Value.Bool true
                                    |) in
                                  let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                                    M.match_operator (|
                                      Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                                      M.alloc (| Value.Tuple [] |),
                                      [
                                        fun γ =>
                                          ltac:(M.monadic
                                            (let γ :=
                                              M.use
                                                (M.alloc (|
                                                  UnOp.not (|
                                                    UnOp.not (|
                                                      M.call_closure (|
                                                        Ty.path "bool",
                                                        M.get_function (|
                                                          "core::ptr::addr_eq",
                                                          [],
                                                          [
                                                            Ty.apply
                                                              (Ty.path "alloc::sync::ArcInner")
                                                              []
                                                              [ T ];
                                                            Ty.apply
                                                              (Ty.path "alloc::sync::ArcInner")
                                                              []
                                                              [
                                                                Ty.apply
                                                                  (Ty.path "array")
                                                                  [
                                                                    Value.Integer
                                                                      IntegerKind.Usize
                                                                      1
                                                                  ]
                                                                  [ Ty.path "u8" ]
                                                              ]
                                                          ]
                                                        |),
                                                        [
                                                          (* MutToConstPointer *)
                                                          M.pointer_coercion
                                                            (M.call_closure (|
                                                              Ty.apply
                                                                (Ty.path "*mut")
                                                                []
                                                                [
                                                                  Ty.apply
                                                                    (Ty.path
                                                                      "alloc::sync::ArcInner")
                                                                    []
                                                                    [ T ]
                                                                ],
                                                              M.get_associated_function (|
                                                                Ty.apply
                                                                  (Ty.path
                                                                    "core::ptr::non_null::NonNull")
                                                                  []
                                                                  [
                                                                    Ty.apply
                                                                      (Ty.path
                                                                        "alloc::sync::ArcInner")
                                                                      []
                                                                      [ T ]
                                                                  ],
                                                                "as_ptr",
                                                                [],
                                                                []
                                                              |),
                                                              [
                                                                M.read (|
                                                                  M.SubPointer.get_struct_record_field (|
                                                                    M.deref (| M.read (| self |) |),
                                                                    "alloc::sync::Weak",
                                                                    "ptr"
                                                                  |)
                                                                |)
                                                              ]
                                                            |));
                                                          M.borrow (|
                                                            Pointer.Kind.ConstPointer,
                                                            M.deref (|
                                                              M.borrow (|
                                                                Pointer.Kind.Ref,
                                                                M.SubPointer.get_struct_record_field (|
                                                                  M.deref (|
                                                                    M.read (|
                                                                      get_constant (|
                                                                        "alloc::sync::STATIC_INNER_SLICE",
                                                                        Ty.apply
                                                                          (Ty.path "&")
                                                                          []
                                                                          [
                                                                            Ty.path
                                                                              "alloc::sync::SliceArcInnerForStatic"
                                                                          ]
                                                                      |)
                                                                    |)
                                                                  |),
                                                                  "alloc::sync::SliceArcInnerForStatic",
                                                                  "inner"
                                                                |)
                                                              |)
                                                            |)
                                                          |)
                                                        ]
                                                      |)
                                                    |)
                                                  |)
                                                |)) in
                                            let _ :=
                                              is_constant_or_break_match (|
                                                M.read (| γ |),
                                                Value.Bool true
                                              |) in
                                            M.alloc (|
                                              M.never_to_any (|
                                                M.call_closure (|
                                                  Ty.path "never",
                                                  M.get_function (|
                                                    "core::panicking::panic_fmt",
                                                    [],
                                                    []
                                                  |),
                                                  [
                                                    M.call_closure (|
                                                      Ty.path "core::fmt::Arguments",
                                                      M.get_associated_function (|
                                                        Ty.path "core::fmt::Arguments",
                                                        "new_const",
                                                        [ Value.Integer IntegerKind.Usize 1 ],
                                                        []
                                                      |),
                                                      [
                                                        M.borrow (|
                                                          Pointer.Kind.Ref,
                                                          M.deref (|
                                                            M.borrow (|
                                                              Pointer.Kind.Ref,
                                                              M.alloc (|
                                                                Value.Array
                                                                  [
                                                                    mk_str (|
                                                                      "Arc/Weaks backed by a static should never be deallocated. Likely decrement_strong_count or from_raw were called too many times."
                                                                    |)
                                                                  ]
                                                              |)
                                                            |)
                                                          |)
                                                        |)
                                                      ]
                                                    |)
                                                  ]
                                                |)
                                              |)
                                            |)));
                                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                                      ]
                                    |) in
                                  M.alloc (| Value.Tuple [] |)));
                              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                            ]
                          |) in
                        M.alloc (|
                          M.call_closure (|
                            Ty.tuple [],
                            M.get_trait_method (|
                              "core::alloc::Allocator",
                              A,
                              [],
                              [],
                              "deallocate",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.SubPointer.get_struct_record_field (|
                                  M.deref (| M.read (| self |) |),
                                  "alloc::sync::Weak",
                                  "alloc"
                                |)
                              |);
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "core::ptr::non_null::NonNull")
                                  []
                                  [ Ty.path "u8" ],
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "core::ptr::non_null::NonNull")
                                    []
                                    [ Ty.apply (Ty.path "alloc::sync::ArcInner") [] [ T ] ],
                                  "cast",
                                  [],
                                  [ Ty.path "u8" ]
                                |),
                                [
                                  M.read (|
                                    M.SubPointer.get_struct_record_field (|
                                      M.deref (| M.read (| self |) |),
                                      "alloc::sync::Weak",
                                      "ptr"
                                    |)
                                  |)
                                ]
                              |);
                              M.call_closure (|
                                Ty.path "core::alloc::layout::Layout",
                                M.get_associated_function (|
                                  Ty.path "core::alloc::layout::Layout",
                                  "for_value_raw",
                                  [],
                                  [ Ty.apply (Ty.path "alloc::sync::ArcInner") [] [ T ] ]
                                |),
                                [
                                  (* MutToConstPointer *)
                                  M.pointer_coercion
                                    (M.call_closure (|
                                      Ty.apply
                                        (Ty.path "*mut")
                                        []
                                        [ Ty.apply (Ty.path "alloc::sync::ArcInner") [] [ T ] ],
                                      M.get_associated_function (|
                                        Ty.apply
                                          (Ty.path "core::ptr::non_null::NonNull")
                                          []
                                          [ Ty.apply (Ty.path "alloc::sync::ArcInner") [] [ T ] ],
                                        "as_ptr",
                                        [],
                                        []
                                      |),
                                      [
                                        M.read (|
                                          M.SubPointer.get_struct_record_field (|
                                            M.deref (| M.read (| self |) |),
                                            "alloc::sync::Weak",
                                            "ptr"
                                          |)
                                        |)
                                      ]
                                    |))
                                ]
                              |)
                            ]
                          |)
                        |)));
                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                  ]
                |)
              |)))
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (T A : Ty.t),
      M.IsTraitInstance
        "core::ops::drop::Drop"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self T A)
        (* Instance *) [ ("drop", InstanceField.Method (drop T A)) ].
  End Impl_core_ops_drop_Drop_where_core_marker_Sized_T_where_core_alloc_Allocator_A_for_alloc_sync_Weak_T_A.
  
  (* Trait *)
  (* Empty module 'ArcEqIdent' *)
  
  Module Impl_alloc_sync_ArcEqIdent_where_core_marker_Sized_T_where_core_cmp_PartialEq_T_where_core_alloc_Allocator_A_T_A_for_alloc_sync_Arc_T_A.
    Definition Self (T A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; A ].
    
    (*
        default fn eq(&self, other: &Arc<T, A>) -> bool {
            **self == **other
        }
    *)
    Definition eq (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            Ty.path "bool",
            M.get_trait_method (| "core::cmp::PartialEq", T, [], [ T ], "eq", [], [] |),
            [
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.call_closure (|
                    Ty.apply (Ty.path "&") [] [ T ],
                    M.get_trait_method (|
                      "core::ops::deref::Deref",
                      Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; A ],
                      [],
                      [],
                      "deref",
                      [],
                      []
                    |),
                    [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                  |)
                |)
              |);
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.call_closure (|
                    Ty.apply (Ty.path "&") [] [ T ],
                    M.get_trait_method (|
                      "core::ops::deref::Deref",
                      Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; A ],
                      [],
                      [],
                      "deref",
                      [],
                      []
                    |),
                    [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| other |) |) |) ]
                  |)
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    (*
        default fn ne(&self, other: &Arc<T, A>) -> bool {
            **self != **other
        }
    *)
    Definition ne (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            Ty.path "bool",
            M.get_trait_method (| "core::cmp::PartialEq", T, [], [ T ], "ne", [], [] |),
            [
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.call_closure (|
                    Ty.apply (Ty.path "&") [] [ T ],
                    M.get_trait_method (|
                      "core::ops::deref::Deref",
                      Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; A ],
                      [],
                      [],
                      "deref",
                      [],
                      []
                    |),
                    [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                  |)
                |)
              |);
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.call_closure (|
                    Ty.apply (Ty.path "&") [] [ T ],
                    M.get_trait_method (|
                      "core::ops::deref::Deref",
                      Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; A ],
                      [],
                      [],
                      "deref",
                      [],
                      []
                    |),
                    [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| other |) |) |) ]
                  |)
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (T A : Ty.t),
      M.IsTraitInstance
        "alloc::sync::ArcEqIdent"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ T; A ]
        (Self T A)
        (* Instance *)
        [ ("eq", InstanceField.Method (eq T A)); ("ne", InstanceField.Method (ne T A)) ].
  End Impl_alloc_sync_ArcEqIdent_where_core_marker_Sized_T_where_core_cmp_PartialEq_T_where_core_alloc_Allocator_A_T_A_for_alloc_sync_Arc_T_A.
  
  Module Impl_alloc_sync_ArcEqIdent_where_core_marker_Sized_T_where_alloc_rc_MarkerEq_T_where_core_alloc_Allocator_A_T_A_for_alloc_sync_Arc_T_A.
    Definition Self (T A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; A ].
    
    (*
        fn eq(&self, other: &Arc<T, A>) -> bool {
            Arc::ptr_eq(self, other) || **self == **other
        }
    *)
    Definition eq (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          LogicalOp.or (|
            M.call_closure (|
              Ty.path "bool",
              M.get_associated_function (|
                Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; A ],
                "ptr_eq",
                [],
                []
              |),
              [
                M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |);
                M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| other |) |) |)
              ]
            |),
            ltac:(M.monadic
              (M.call_closure (|
                Ty.path "bool",
                M.get_trait_method (| "core::cmp::PartialEq", T, [], [ T ], "eq", [], [] |),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.call_closure (|
                        Ty.apply (Ty.path "&") [] [ T ],
                        M.get_trait_method (|
                          "core::ops::deref::Deref",
                          Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; A ],
                          [],
                          [],
                          "deref",
                          [],
                          []
                        |),
                        [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                      |)
                    |)
                  |);
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.call_closure (|
                        Ty.apply (Ty.path "&") [] [ T ],
                        M.get_trait_method (|
                          "core::ops::deref::Deref",
                          Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; A ],
                          [],
                          [],
                          "deref",
                          [],
                          []
                        |),
                        [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| other |) |) |) ]
                      |)
                    |)
                  |)
                ]
              |)))
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    (*
        fn ne(&self, other: &Arc<T, A>) -> bool {
            !Arc::ptr_eq(self, other) && **self != **other
        }
    *)
    Definition ne (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          LogicalOp.and (|
            UnOp.not (|
              M.call_closure (|
                Ty.path "bool",
                M.get_associated_function (|
                  Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; A ],
                  "ptr_eq",
                  [],
                  []
                |),
                [
                  M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |);
                  M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| other |) |) |)
                ]
              |)
            |),
            ltac:(M.monadic
              (M.call_closure (|
                Ty.path "bool",
                M.get_trait_method (| "core::cmp::PartialEq", T, [], [ T ], "ne", [], [] |),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.call_closure (|
                        Ty.apply (Ty.path "&") [] [ T ],
                        M.get_trait_method (|
                          "core::ops::deref::Deref",
                          Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; A ],
                          [],
                          [],
                          "deref",
                          [],
                          []
                        |),
                        [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                      |)
                    |)
                  |);
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.call_closure (|
                        Ty.apply (Ty.path "&") [] [ T ],
                        M.get_trait_method (|
                          "core::ops::deref::Deref",
                          Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; A ],
                          [],
                          [],
                          "deref",
                          [],
                          []
                        |),
                        [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| other |) |) |) ]
                      |)
                    |)
                  |)
                ]
              |)))
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (T A : Ty.t),
      M.IsTraitInstance
        "alloc::sync::ArcEqIdent"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ T; A ]
        (Self T A)
        (* Instance *)
        [ ("eq", InstanceField.Method (eq T A)); ("ne", InstanceField.Method (ne T A)) ].
  End Impl_alloc_sync_ArcEqIdent_where_core_marker_Sized_T_where_alloc_rc_MarkerEq_T_where_core_alloc_Allocator_A_T_A_for_alloc_sync_Arc_T_A.
  
  Module Impl_core_cmp_PartialEq_where_core_marker_Sized_T_where_core_cmp_PartialEq_T_where_core_alloc_Allocator_A_alloc_sync_Arc_T_A_for_alloc_sync_Arc_T_A.
    Definition Self (T A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; A ].
    
    (*
        fn eq(&self, other: &Arc<T, A>) -> bool {
            ArcEqIdent::eq(self, other)
        }
    *)
    Definition eq (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            Ty.path "bool",
            M.get_trait_method (|
              "alloc::sync::ArcEqIdent",
              Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; A ],
              [],
              [ T; A ],
              "eq",
              [],
              []
            |),
            [
              M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |);
              M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| other |) |) |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    (*
        fn ne(&self, other: &Arc<T, A>) -> bool {
            ArcEqIdent::ne(self, other)
        }
    *)
    Definition ne (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            Ty.path "bool",
            M.get_trait_method (|
              "alloc::sync::ArcEqIdent",
              Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; A ],
              [],
              [ T; A ],
              "ne",
              [],
              []
            |),
            [
              M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |);
              M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| other |) |) |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (T A : Ty.t),
      M.IsTraitInstance
        "core::cmp::PartialEq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; A ] ]
        (Self T A)
        (* Instance *)
        [ ("eq", InstanceField.Method (eq T A)); ("ne", InstanceField.Method (ne T A)) ].
  End Impl_core_cmp_PartialEq_where_core_marker_Sized_T_where_core_cmp_PartialEq_T_where_core_alloc_Allocator_A_alloc_sync_Arc_T_A_for_alloc_sync_Arc_T_A.
  
  Module Impl_core_cmp_PartialOrd_where_core_marker_Sized_T_where_core_cmp_PartialOrd_T_where_core_alloc_Allocator_A_alloc_sync_Arc_T_A_for_alloc_sync_Arc_T_A.
    Definition Self (T A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; A ].
    
    (*
        fn partial_cmp(&self, other: &Arc<T, A>) -> Option<Ordering> {
            ( **self).partial_cmp(&**other)
        }
    *)
    Definition partial_cmp (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "core::cmp::Ordering" ],
            M.get_trait_method (| "core::cmp::PartialOrd", T, [], [ T ], "partial_cmp", [], [] |),
            [
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.call_closure (|
                    Ty.apply (Ty.path "&") [] [ T ],
                    M.get_trait_method (|
                      "core::ops::deref::Deref",
                      Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; A ],
                      [],
                      [],
                      "deref",
                      [],
                      []
                    |),
                    [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                  |)
                |)
              |);
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.call_closure (|
                        Ty.apply (Ty.path "&") [] [ T ],
                        M.get_trait_method (|
                          "core::ops::deref::Deref",
                          Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; A ],
                          [],
                          [],
                          "deref",
                          [],
                          []
                        |),
                        [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| other |) |) |) ]
                      |)
                    |)
                  |)
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    (*
        fn lt(&self, other: &Arc<T, A>) -> bool {
            *( *self) < *( *other)
        }
    *)
    Definition lt (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            Ty.path "bool",
            M.get_trait_method (| "core::cmp::PartialOrd", T, [], [ T ], "lt", [], [] |),
            [
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.call_closure (|
                    Ty.apply (Ty.path "&") [] [ T ],
                    M.get_trait_method (|
                      "core::ops::deref::Deref",
                      Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; A ],
                      [],
                      [],
                      "deref",
                      [],
                      []
                    |),
                    [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                  |)
                |)
              |);
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.call_closure (|
                    Ty.apply (Ty.path "&") [] [ T ],
                    M.get_trait_method (|
                      "core::ops::deref::Deref",
                      Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; A ],
                      [],
                      [],
                      "deref",
                      [],
                      []
                    |),
                    [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| other |) |) |) ]
                  |)
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    (*
        fn le(&self, other: &Arc<T, A>) -> bool {
            *( *self) <= *( *other)
        }
    *)
    Definition le (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            Ty.path "bool",
            M.get_trait_method (| "core::cmp::PartialOrd", T, [], [ T ], "le", [], [] |),
            [
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.call_closure (|
                    Ty.apply (Ty.path "&") [] [ T ],
                    M.get_trait_method (|
                      "core::ops::deref::Deref",
                      Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; A ],
                      [],
                      [],
                      "deref",
                      [],
                      []
                    |),
                    [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                  |)
                |)
              |);
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.call_closure (|
                    Ty.apply (Ty.path "&") [] [ T ],
                    M.get_trait_method (|
                      "core::ops::deref::Deref",
                      Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; A ],
                      [],
                      [],
                      "deref",
                      [],
                      []
                    |),
                    [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| other |) |) |) ]
                  |)
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    (*
        fn gt(&self, other: &Arc<T, A>) -> bool {
            *( *self) > *( *other)
        }
    *)
    Definition gt (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            Ty.path "bool",
            M.get_trait_method (| "core::cmp::PartialOrd", T, [], [ T ], "gt", [], [] |),
            [
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.call_closure (|
                    Ty.apply (Ty.path "&") [] [ T ],
                    M.get_trait_method (|
                      "core::ops::deref::Deref",
                      Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; A ],
                      [],
                      [],
                      "deref",
                      [],
                      []
                    |),
                    [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                  |)
                |)
              |);
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.call_closure (|
                    Ty.apply (Ty.path "&") [] [ T ],
                    M.get_trait_method (|
                      "core::ops::deref::Deref",
                      Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; A ],
                      [],
                      [],
                      "deref",
                      [],
                      []
                    |),
                    [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| other |) |) |) ]
                  |)
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    (*
        fn ge(&self, other: &Arc<T, A>) -> bool {
            *( *self) >= *( *other)
        }
    *)
    Definition ge (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            Ty.path "bool",
            M.get_trait_method (| "core::cmp::PartialOrd", T, [], [ T ], "ge", [], [] |),
            [
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.call_closure (|
                    Ty.apply (Ty.path "&") [] [ T ],
                    M.get_trait_method (|
                      "core::ops::deref::Deref",
                      Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; A ],
                      [],
                      [],
                      "deref",
                      [],
                      []
                    |),
                    [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                  |)
                |)
              |);
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.call_closure (|
                    Ty.apply (Ty.path "&") [] [ T ],
                    M.get_trait_method (|
                      "core::ops::deref::Deref",
                      Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; A ],
                      [],
                      [],
                      "deref",
                      [],
                      []
                    |),
                    [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| other |) |) |) ]
                  |)
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (T A : Ty.t),
      M.IsTraitInstance
        "core::cmp::PartialOrd"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; A ] ]
        (Self T A)
        (* Instance *)
        [
          ("partial_cmp", InstanceField.Method (partial_cmp T A));
          ("lt", InstanceField.Method (lt T A));
          ("le", InstanceField.Method (le T A));
          ("gt", InstanceField.Method (gt T A));
          ("ge", InstanceField.Method (ge T A))
        ].
  End Impl_core_cmp_PartialOrd_where_core_marker_Sized_T_where_core_cmp_PartialOrd_T_where_core_alloc_Allocator_A_alloc_sync_Arc_T_A_for_alloc_sync_Arc_T_A.
  
  Module Impl_core_cmp_Ord_where_core_marker_Sized_T_where_core_cmp_Ord_T_where_core_alloc_Allocator_A_for_alloc_sync_Arc_T_A.
    Definition Self (T A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; A ].
    
    (*
        fn cmp(&self, other: &Arc<T, A>) -> Ordering {
            ( **self).cmp(&**other)
        }
    *)
    Definition cmp (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            Ty.path "core::cmp::Ordering",
            M.get_trait_method (| "core::cmp::Ord", T, [], [], "cmp", [], [] |),
            [
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.call_closure (|
                    Ty.apply (Ty.path "&") [] [ T ],
                    M.get_trait_method (|
                      "core::ops::deref::Deref",
                      Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; A ],
                      [],
                      [],
                      "deref",
                      [],
                      []
                    |),
                    [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                  |)
                |)
              |);
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.call_closure (|
                        Ty.apply (Ty.path "&") [] [ T ],
                        M.get_trait_method (|
                          "core::ops::deref::Deref",
                          Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; A ],
                          [],
                          [],
                          "deref",
                          [],
                          []
                        |),
                        [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| other |) |) |) ]
                      |)
                    |)
                  |)
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (T A : Ty.t),
      M.IsTraitInstance
        "core::cmp::Ord"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self T A)
        (* Instance *) [ ("cmp", InstanceField.Method (cmp T A)) ].
  End Impl_core_cmp_Ord_where_core_marker_Sized_T_where_core_cmp_Ord_T_where_core_alloc_Allocator_A_for_alloc_sync_Arc_T_A.
  
  Module Impl_core_cmp_Eq_where_core_marker_Sized_T_where_core_cmp_Eq_T_where_core_alloc_Allocator_A_for_alloc_sync_Arc_T_A.
    Definition Self (T A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; A ].
    
    Axiom Implements :
      forall (T A : Ty.t),
      M.IsTraitInstance
        "core::cmp::Eq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self T A)
        (* Instance *) [].
  End Impl_core_cmp_Eq_where_core_marker_Sized_T_where_core_cmp_Eq_T_where_core_alloc_Allocator_A_for_alloc_sync_Arc_T_A.
  
  Module Impl_core_fmt_Display_where_core_marker_Sized_T_where_core_fmt_Display_T_where_core_alloc_Allocator_A_for_alloc_sync_Arc_T_A.
    Definition Self (T A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; A ].
    
    (*
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            fmt::Display::fmt(&**self, f)
        }
    *)
    Definition fmt (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "core::result::Result")
              []
              [ Ty.tuple []; Ty.path "core::fmt::Error" ],
            M.get_trait_method (| "core::fmt::Display", T, [], [], "fmt", [], [] |),
            [
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.call_closure (|
                        Ty.apply (Ty.path "&") [] [ T ],
                        M.get_trait_method (|
                          "core::ops::deref::Deref",
                          Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; A ],
                          [],
                          [],
                          "deref",
                          [],
                          []
                        |),
                        [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                      |)
                    |)
                  |)
                |)
              |);
              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (T A : Ty.t),
      M.IsTraitInstance
        "core::fmt::Display"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self T A)
        (* Instance *) [ ("fmt", InstanceField.Method (fmt T A)) ].
  End Impl_core_fmt_Display_where_core_marker_Sized_T_where_core_fmt_Display_T_where_core_alloc_Allocator_A_for_alloc_sync_Arc_T_A.
  
  Module Impl_core_fmt_Debug_where_core_marker_Sized_T_where_core_fmt_Debug_T_where_core_alloc_Allocator_A_for_alloc_sync_Arc_T_A.
    Definition Self (T A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; A ].
    
    (*
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            fmt::Debug::fmt(&**self, f)
        }
    *)
    Definition fmt (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "core::result::Result")
              []
              [ Ty.tuple []; Ty.path "core::fmt::Error" ],
            M.get_trait_method (| "core::fmt::Debug", T, [], [], "fmt", [], [] |),
            [
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.call_closure (|
                        Ty.apply (Ty.path "&") [] [ T ],
                        M.get_trait_method (|
                          "core::ops::deref::Deref",
                          Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; A ],
                          [],
                          [],
                          "deref",
                          [],
                          []
                        |),
                        [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                      |)
                    |)
                  |)
                |)
              |);
              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (T A : Ty.t),
      M.IsTraitInstance
        "core::fmt::Debug"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self T A)
        (* Instance *) [ ("fmt", InstanceField.Method (fmt T A)) ].
  End Impl_core_fmt_Debug_where_core_marker_Sized_T_where_core_fmt_Debug_T_where_core_alloc_Allocator_A_for_alloc_sync_Arc_T_A.
  
  Module Impl_core_fmt_Pointer_where_core_marker_Sized_T_where_core_alloc_Allocator_A_for_alloc_sync_Arc_T_A.
    Definition Self (T A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; A ].
    
    (*
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            fmt::Pointer::fmt(&(&raw const **self), f)
        }
    *)
    Definition fmt (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "core::result::Result")
              []
              [ Ty.tuple []; Ty.path "core::fmt::Error" ],
            M.get_trait_method (|
              "core::fmt::Pointer",
              Ty.apply (Ty.path "*const") [] [ T ],
              [],
              [],
              "fmt",
              [],
              []
            |),
            [
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.alloc (|
                      M.borrow (|
                        Pointer.Kind.ConstPointer,
                        M.deref (|
                          M.call_closure (|
                            Ty.apply (Ty.path "&") [] [ T ],
                            M.get_trait_method (|
                              "core::ops::deref::Deref",
                              Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; A ],
                              [],
                              [],
                              "deref",
                              [],
                              []
                            |),
                            [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                          |)
                        |)
                      |)
                    |)
                  |)
                |)
              |);
              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (T A : Ty.t),
      M.IsTraitInstance
        "core::fmt::Pointer"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self T A)
        (* Instance *) [ ("fmt", InstanceField.Method (fmt T A)) ].
  End Impl_core_fmt_Pointer_where_core_marker_Sized_T_where_core_alloc_Allocator_A_for_alloc_sync_Arc_T_A.
  
  Module Impl_core_default_Default_where_core_default_Default_T_for_alloc_sync_Arc_T_alloc_alloc_Global.
    Definition Self (T : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; Ty.path "alloc::alloc::Global" ].
    
    (*
        fn default() -> Arc<T> {
            unsafe {
                Self::from_inner(
                    Box::leak(Box::write(Box::new_uninit(), ArcInner {
                        strong: atomic::AtomicUsize::new(1),
                        weak: atomic::AtomicUsize::new(1),
                        data: T::default(),
                    }))
                    .into(),
                )
            }
        }
    *)
    Definition default (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [], [] =>
        ltac:(M.monadic
          (M.call_closure (|
            Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; Ty.path "alloc::alloc::Global" ],
            M.get_associated_function (|
              Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; Ty.path "alloc::alloc::Global" ],
              "from_inner",
              [],
              []
            |),
            [
              M.call_closure (|
                Ty.apply
                  (Ty.path "core::ptr::non_null::NonNull")
                  []
                  [ Ty.apply (Ty.path "alloc::sync::ArcInner") [] [ T ] ],
                M.get_trait_method (|
                  "core::convert::Into",
                  Ty.apply
                    (Ty.path "&mut")
                    []
                    [ Ty.apply (Ty.path "alloc::sync::ArcInner") [] [ T ] ],
                  [],
                  [
                    Ty.apply
                      (Ty.path "core::ptr::non_null::NonNull")
                      []
                      [ Ty.apply (Ty.path "alloc::sync::ArcInner") [] [ T ] ]
                  ],
                  "into",
                  [],
                  []
                |),
                [
                  M.borrow (|
                    Pointer.Kind.MutRef,
                    M.deref (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "&mut")
                          []
                          [ Ty.apply (Ty.path "alloc::sync::ArcInner") [] [ T ] ],
                        M.get_associated_function (|
                          Ty.apply
                            (Ty.path "alloc::boxed::Box")
                            []
                            [
                              Ty.apply (Ty.path "alloc::sync::ArcInner") [] [ T ];
                              Ty.path "alloc::alloc::Global"
                            ],
                          "leak",
                          [],
                          []
                        |),
                        [
                          M.call_closure (|
                            Ty.apply
                              (Ty.path "alloc::boxed::Box")
                              []
                              [
                                Ty.apply (Ty.path "alloc::sync::ArcInner") [] [ T ];
                                Ty.path "alloc::alloc::Global"
                              ],
                            M.get_associated_function (|
                              Ty.apply
                                (Ty.path "alloc::boxed::Box")
                                []
                                [
                                  Ty.apply
                                    (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                    []
                                    [ Ty.apply (Ty.path "alloc::sync::ArcInner") [] [ T ] ];
                                  Ty.path "alloc::alloc::Global"
                                ],
                              "write",
                              [],
                              []
                            |),
                            [
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "alloc::boxed::Box")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                      []
                                      [ Ty.apply (Ty.path "alloc::sync::ArcInner") [] [ T ] ];
                                    Ty.path "alloc::alloc::Global"
                                  ],
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "alloc::boxed::Box")
                                    []
                                    [
                                      Ty.apply (Ty.path "alloc::sync::ArcInner") [] [ T ];
                                      Ty.path "alloc::alloc::Global"
                                    ],
                                  "new_uninit",
                                  [],
                                  []
                                |),
                                []
                              |);
                              Value.StructRecord
                                "alloc::sync::ArcInner"
                                [
                                  ("strong",
                                    M.call_closure (|
                                      Ty.path "core::sync::atomic::AtomicUsize",
                                      M.get_associated_function (|
                                        Ty.path "core::sync::atomic::AtomicUsize",
                                        "new",
                                        [],
                                        []
                                      |),
                                      [ Value.Integer IntegerKind.Usize 1 ]
                                    |));
                                  ("weak",
                                    M.call_closure (|
                                      Ty.path "core::sync::atomic::AtomicUsize",
                                      M.get_associated_function (|
                                        Ty.path "core::sync::atomic::AtomicUsize",
                                        "new",
                                        [],
                                        []
                                      |),
                                      [ Value.Integer IntegerKind.Usize 1 ]
                                    |));
                                  ("data",
                                    M.call_closure (|
                                      T,
                                      M.get_trait_method (|
                                        "core::default::Default",
                                        T,
                                        [],
                                        [],
                                        "default",
                                        [],
                                        []
                                      |),
                                      []
                                    |))
                                ]
                            ]
                          |)
                        ]
                      |)
                    |)
                  |)
                ]
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "core::default::Default"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self T)
        (* Instance *) [ ("default", InstanceField.Method (default T)) ].
  End Impl_core_default_Default_where_core_default_Default_T_for_alloc_sync_Arc_T_alloc_alloc_Global.
  
  (* StructRecord
    {
      name := "SliceArcInnerForStatic";
      const_params := [];
      ty_params := [];
      fields :=
        [
          ("inner",
            Ty.apply
              (Ty.path "alloc::sync::ArcInner")
              []
              [ Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 1 ] [ Ty.path "u8" ] ])
        ];
    } *)
  
  Definition value_MAX_STATIC_INNER_SLICE_ALIGNMENT
      (ε : list Value.t)
      (τ : list Ty.t)
      (α : list Value.t)
      : M :=
    ltac:(M.monadic (M.alloc (| Value.Integer IntegerKind.Usize 16 |))).
  
  Global Instance Instance_IsConstant_value_MAX_STATIC_INNER_SLICE_ALIGNMENT :
    M.IsFunction.C
      "alloc::sync::MAX_STATIC_INNER_SLICE_ALIGNMENT"
      value_MAX_STATIC_INNER_SLICE_ALIGNMENT.
  Admitted.
  Global Typeclasses Opaque value_MAX_STATIC_INNER_SLICE_ALIGNMENT.
  
  Definition value_STATIC_INNER_SLICE (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    ltac:(M.monadic
      (M.alloc (|
        M.alloc (|
          Value.StructRecord
            "alloc::sync::SliceArcInnerForStatic"
            [
              ("inner",
                Value.StructRecord
                  "alloc::sync::ArcInner"
                  [
                    ("strong",
                      M.call_closure (|
                        Ty.path "core::sync::atomic::AtomicUsize",
                        M.get_associated_function (|
                          Ty.path "core::sync::atomic::AtomicUsize",
                          "new",
                          [],
                          []
                        |),
                        [ Value.Integer IntegerKind.Usize 1 ]
                      |));
                    ("weak",
                      M.call_closure (|
                        Ty.path "core::sync::atomic::AtomicUsize",
                        M.get_associated_function (|
                          Ty.path "core::sync::atomic::AtomicUsize",
                          "new",
                          [],
                          []
                        |),
                        [ Value.Integer IntegerKind.Usize 1 ]
                      |));
                    ("data", Value.Array [ Value.Integer IntegerKind.U8 0 ])
                  ])
            ]
        |)
      |))).
  
  Global Instance Instance_IsConstant_value_STATIC_INNER_SLICE :
    M.IsFunction.C "alloc::sync::STATIC_INNER_SLICE" value_STATIC_INNER_SLICE.
  Admitted.
  Global Typeclasses Opaque value_STATIC_INNER_SLICE.
  
  Module Impl_core_default_Default_for_alloc_sync_Arc_str_alloc_alloc_Global.
    Definition Self : Ty.t :=
      Ty.apply (Ty.path "alloc::sync::Arc") [] [ Ty.path "str"; Ty.path "alloc::alloc::Global" ].
    
    (*
        fn default() -> Self {
            let arc: Arc<[u8]> = Default::default();
            debug_assert!(core::str::from_utf8(&*arc).is_ok());
            let (ptr, alloc) = Arc::into_inner_with_allocator(arc);
            unsafe { Arc::from_ptr_in(ptr.as_ptr() as *mut ArcInner<str>, alloc) }
        }
    *)
    Definition default (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [] =>
        ltac:(M.monadic
          (M.read (|
            let~ arc :
                Ty.apply
                  (Ty.path "*")
                  []
                  [
                    Ty.apply
                      (Ty.path "alloc::sync::Arc")
                      []
                      [
                        Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ];
                        Ty.path "alloc::alloc::Global"
                      ]
                  ] :=
              M.alloc (|
                M.call_closure (|
                  Ty.apply
                    (Ty.path "alloc::sync::Arc")
                    []
                    [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ]; Ty.path "alloc::alloc::Global"
                    ],
                  M.get_trait_method (|
                    "core::default::Default",
                    Ty.apply
                      (Ty.path "alloc::sync::Arc")
                      []
                      [
                        Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ];
                        Ty.path "alloc::alloc::Global"
                      ],
                    [],
                    [],
                    "default",
                    [],
                    []
                  |),
                  []
                |)
              |) in
            let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
              M.match_operator (|
                Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.use (M.alloc (| Value.Bool true |)) in
                      let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                        M.match_operator (|
                          Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                          M.alloc (| Value.Tuple [] |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ :=
                                  M.use
                                    (M.alloc (|
                                      UnOp.not (|
                                        M.call_closure (|
                                          Ty.path "bool",
                                          M.get_associated_function (|
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              []
                                              [
                                                Ty.apply (Ty.path "&") [] [ Ty.path "str" ];
                                                Ty.path "core::str::error::Utf8Error"
                                              ],
                                            "is_ok",
                                            [],
                                            []
                                          |),
                                          [
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.alloc (|
                                                M.call_closure (|
                                                  Ty.apply
                                                    (Ty.path "core::result::Result")
                                                    []
                                                    [
                                                      Ty.apply (Ty.path "&") [] [ Ty.path "str" ];
                                                      Ty.path "core::str::error::Utf8Error"
                                                    ],
                                                  M.get_function (|
                                                    "core::str::converts::from_utf8",
                                                    [],
                                                    []
                                                  |),
                                                  [
                                                    M.borrow (|
                                                      Pointer.Kind.Ref,
                                                      M.deref (|
                                                        M.borrow (|
                                                          Pointer.Kind.Ref,
                                                          M.deref (|
                                                            M.call_closure (|
                                                              Ty.apply
                                                                (Ty.path "&")
                                                                []
                                                                [
                                                                  Ty.apply
                                                                    (Ty.path "slice")
                                                                    []
                                                                    [ Ty.path "u8" ]
                                                                ],
                                                              M.get_trait_method (|
                                                                "core::ops::deref::Deref",
                                                                Ty.apply
                                                                  (Ty.path "alloc::sync::Arc")
                                                                  []
                                                                  [
                                                                    Ty.apply
                                                                      (Ty.path "slice")
                                                                      []
                                                                      [ Ty.path "u8" ];
                                                                    Ty.path "alloc::alloc::Global"
                                                                  ],
                                                                [],
                                                                [],
                                                                "deref",
                                                                [],
                                                                []
                                                              |),
                                                              [ M.borrow (| Pointer.Kind.Ref, arc |)
                                                              ]
                                                            |)
                                                          |)
                                                        |)
                                                      |)
                                                    |)
                                                  ]
                                                |)
                                              |)
                                            |)
                                          ]
                                        |)
                                      |)
                                    |)) in
                                let _ :=
                                  is_constant_or_break_match (|
                                    M.read (| γ |),
                                    Value.Bool true
                                  |) in
                                M.alloc (|
                                  M.never_to_any (|
                                    M.call_closure (|
                                      Ty.path "never",
                                      M.get_function (| "core::panicking::panic", [], [] |),
                                      [
                                        mk_str (|
                                          "assertion failed: core::str::from_utf8(&*arc).is_ok()"
                                        |)
                                      ]
                                    |)
                                  |)
                                |)));
                            fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                          ]
                        |) in
                      M.alloc (| Value.Tuple [] |)));
                  fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                ]
              |) in
            M.match_operator (|
              Ty.apply
                (Ty.path "*")
                []
                [
                  Ty.apply
                    (Ty.path "alloc::sync::Arc")
                    []
                    [ Ty.path "str"; Ty.path "alloc::alloc::Global" ]
                ],
              M.alloc (|
                M.call_closure (|
                  Ty.tuple
                    [
                      Ty.apply
                        (Ty.path "core::ptr::non_null::NonNull")
                        []
                        [
                          Ty.apply
                            (Ty.path "alloc::sync::ArcInner")
                            []
                            [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
                        ];
                      Ty.path "alloc::alloc::Global"
                    ],
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "alloc::sync::Arc")
                      []
                      [
                        Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ];
                        Ty.path "alloc::alloc::Global"
                      ],
                    "into_inner_with_allocator",
                    [],
                    []
                  |),
                  [ M.read (| arc |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let ptr := M.copy (| γ0_0 |) in
                    let alloc := M.copy (| γ0_1 |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "alloc::sync::Arc")
                          []
                          [ Ty.path "str"; Ty.path "alloc::alloc::Global" ],
                        M.get_associated_function (|
                          Ty.apply
                            (Ty.path "alloc::sync::Arc")
                            []
                            [ Ty.path "str"; Ty.path "alloc::alloc::Global" ],
                          "from_ptr_in",
                          [],
                          []
                        |),
                        [
                          M.cast
                            (Ty.apply
                              (Ty.path "*mut")
                              []
                              [ Ty.apply (Ty.path "alloc::sync::ArcInner") [] [ Ty.path "str" ] ])
                            (M.call_closure (|
                              Ty.apply
                                (Ty.path "*mut")
                                []
                                [
                                  Ty.apply
                                    (Ty.path "alloc::sync::ArcInner")
                                    []
                                    [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
                                ],
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "core::ptr::non_null::NonNull")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "alloc::sync::ArcInner")
                                      []
                                      [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
                                  ],
                                "as_ptr",
                                [],
                                []
                              |),
                              [ M.read (| ptr |) ]
                            |));
                          M.read (| alloc |)
                        ]
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::default::Default"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("default", InstanceField.Method default) ].
  End Impl_core_default_Default_for_alloc_sync_Arc_str_alloc_alloc_Global.
  
  Module Impl_core_default_Default_for_alloc_sync_Arc_core_ffi_c_str_CStr_alloc_alloc_Global.
    Definition Self : Ty.t :=
      Ty.apply
        (Ty.path "alloc::sync::Arc")
        []
        [ Ty.path "core::ffi::c_str::CStr"; Ty.path "alloc::alloc::Global" ].
    
    (*
        fn default() -> Self {
            use core::ffi::CStr;
            let inner: NonNull<ArcInner<[u8]>> = NonNull::from(&STATIC_INNER_SLICE.inner);
            let inner: NonNull<ArcInner<CStr>> =
                NonNull::new(inner.as_ptr() as *mut ArcInner<CStr>).unwrap();
            // `this` semantically is the Arc "owned" by the static, so make sure not to drop it.
            let this: mem::ManuallyDrop<Arc<CStr>> =
                unsafe { mem::ManuallyDrop::new(Arc::from_inner(inner)) };
            ( *this).clone()
        }
    *)
    Definition default (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [] =>
        ltac:(M.monadic
          (M.read (|
            let~ inner :
                Ty.apply
                  (Ty.path "*")
                  []
                  [
                    Ty.apply
                      (Ty.path "core::ptr::non_null::NonNull")
                      []
                      [
                        Ty.apply
                          (Ty.path "alloc::sync::ArcInner")
                          []
                          [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
                      ]
                  ] :=
              M.alloc (|
                (* Unsize *)
                M.pointer_coercion
                  (M.call_closure (|
                    Ty.apply
                      (Ty.path "core::ptr::non_null::NonNull")
                      []
                      [
                        Ty.apply
                          (Ty.path "alloc::sync::ArcInner")
                          []
                          [
                            Ty.apply
                              (Ty.path "array")
                              [ Value.Integer IntegerKind.Usize 1 ]
                              [ Ty.path "u8" ]
                          ]
                      ],
                    M.get_trait_method (|
                      "core::convert::From",
                      Ty.apply
                        (Ty.path "core::ptr::non_null::NonNull")
                        []
                        [
                          Ty.apply
                            (Ty.path "alloc::sync::ArcInner")
                            []
                            [
                              Ty.apply
                                (Ty.path "array")
                                [ Value.Integer IntegerKind.Usize 1 ]
                                [ Ty.path "u8" ]
                            ]
                        ],
                      [],
                      [
                        Ty.apply
                          (Ty.path "&")
                          []
                          [
                            Ty.apply
                              (Ty.path "alloc::sync::ArcInner")
                              []
                              [
                                Ty.apply
                                  (Ty.path "array")
                                  [ Value.Integer IntegerKind.Usize 1 ]
                                  [ Ty.path "u8" ]
                              ]
                          ]
                      ],
                      "from",
                      [],
                      []
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.SubPointer.get_struct_record_field (|
                          M.deref (|
                            M.read (|
                              get_constant (|
                                "alloc::sync::STATIC_INNER_SLICE",
                                Ty.apply
                                  (Ty.path "&")
                                  []
                                  [ Ty.path "alloc::sync::SliceArcInnerForStatic" ]
                              |)
                            |)
                          |),
                          "alloc::sync::SliceArcInnerForStatic",
                          "inner"
                        |)
                      |)
                    ]
                  |))
              |) in
            let~ inner :
                Ty.apply
                  (Ty.path "*")
                  []
                  [
                    Ty.apply
                      (Ty.path "core::ptr::non_null::NonNull")
                      []
                      [
                        Ty.apply
                          (Ty.path "alloc::sync::ArcInner")
                          []
                          [ Ty.path "core::ffi::c_str::CStr" ]
                      ]
                  ] :=
              M.alloc (|
                M.call_closure (|
                  Ty.apply
                    (Ty.path "core::ptr::non_null::NonNull")
                    []
                    [
                      Ty.apply
                        (Ty.path "alloc::sync::ArcInner")
                        []
                        [ Ty.path "core::ffi::c_str::CStr" ]
                    ],
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "core::option::Option")
                      []
                      [
                        Ty.apply
                          (Ty.path "core::ptr::non_null::NonNull")
                          []
                          [
                            Ty.apply
                              (Ty.path "alloc::sync::ArcInner")
                              []
                              [ Ty.path "core::ffi::c_str::CStr" ]
                          ]
                      ],
                    "unwrap",
                    [],
                    []
                  |),
                  [
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "core::option::Option")
                        []
                        [
                          Ty.apply
                            (Ty.path "core::ptr::non_null::NonNull")
                            []
                            [
                              Ty.apply
                                (Ty.path "alloc::sync::ArcInner")
                                []
                                [ Ty.path "core::ffi::c_str::CStr" ]
                            ]
                        ],
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "core::ptr::non_null::NonNull")
                          []
                          [
                            Ty.apply
                              (Ty.path "alloc::sync::ArcInner")
                              []
                              [ Ty.path "core::ffi::c_str::CStr" ]
                          ],
                        "new",
                        [],
                        []
                      |),
                      [
                        M.cast
                          (Ty.apply
                            (Ty.path "*mut")
                            []
                            [
                              Ty.apply
                                (Ty.path "alloc::sync::ArcInner")
                                []
                                [ Ty.path "core::ffi::c_str::CStr" ]
                            ])
                          (M.call_closure (|
                            Ty.apply
                              (Ty.path "*mut")
                              []
                              [
                                Ty.apply
                                  (Ty.path "alloc::sync::ArcInner")
                                  []
                                  [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
                              ],
                            M.get_associated_function (|
                              Ty.apply
                                (Ty.path "core::ptr::non_null::NonNull")
                                []
                                [
                                  Ty.apply
                                    (Ty.path "alloc::sync::ArcInner")
                                    []
                                    [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
                                ],
                              "as_ptr",
                              [],
                              []
                            |),
                            [ M.read (| inner |) ]
                          |))
                      ]
                    |)
                  ]
                |)
              |) in
            let~ this :
                Ty.apply
                  (Ty.path "*")
                  []
                  [
                    Ty.apply
                      (Ty.path "core::mem::manually_drop::ManuallyDrop")
                      []
                      [
                        Ty.apply
                          (Ty.path "alloc::sync::Arc")
                          []
                          [ Ty.path "core::ffi::c_str::CStr"; Ty.path "alloc::alloc::Global" ]
                      ]
                  ] :=
              M.alloc (|
                M.call_closure (|
                  Ty.apply
                    (Ty.path "core::mem::manually_drop::ManuallyDrop")
                    []
                    [
                      Ty.apply
                        (Ty.path "alloc::sync::Arc")
                        []
                        [ Ty.path "core::ffi::c_str::CStr"; Ty.path "alloc::alloc::Global" ]
                    ],
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "core::mem::manually_drop::ManuallyDrop")
                      []
                      [
                        Ty.apply
                          (Ty.path "alloc::sync::Arc")
                          []
                          [ Ty.path "core::ffi::c_str::CStr"; Ty.path "alloc::alloc::Global" ]
                      ],
                    "new",
                    [],
                    []
                  |),
                  [
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "alloc::sync::Arc")
                        []
                        [ Ty.path "core::ffi::c_str::CStr"; Ty.path "alloc::alloc::Global" ],
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "alloc::sync::Arc")
                          []
                          [ Ty.path "core::ffi::c_str::CStr"; Ty.path "alloc::alloc::Global" ],
                        "from_inner",
                        [],
                        []
                      |),
                      [ M.read (| inner |) ]
                    |)
                  ]
                |)
              |) in
            M.alloc (|
              M.call_closure (|
                Ty.apply
                  (Ty.path "alloc::sync::Arc")
                  []
                  [ Ty.path "core::ffi::c_str::CStr"; Ty.path "alloc::alloc::Global" ],
                M.get_trait_method (|
                  "core::clone::Clone",
                  Ty.apply
                    (Ty.path "alloc::sync::Arc")
                    []
                    [ Ty.path "core::ffi::c_str::CStr"; Ty.path "alloc::alloc::Global" ],
                  [],
                  [],
                  "clone",
                  [],
                  []
                |),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "&")
                          []
                          [
                            Ty.apply
                              (Ty.path "alloc::sync::Arc")
                              []
                              [ Ty.path "core::ffi::c_str::CStr"; Ty.path "alloc::alloc::Global" ]
                          ],
                        M.get_trait_method (|
                          "core::ops::deref::Deref",
                          Ty.apply
                            (Ty.path "core::mem::manually_drop::ManuallyDrop")
                            []
                            [
                              Ty.apply
                                (Ty.path "alloc::sync::Arc")
                                []
                                [ Ty.path "core::ffi::c_str::CStr"; Ty.path "alloc::alloc::Global" ]
                            ],
                          [],
                          [],
                          "deref",
                          [],
                          []
                        |),
                        [ M.borrow (| Pointer.Kind.Ref, this |) ]
                      |)
                    |)
                  |)
                ]
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::default::Default"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("default", InstanceField.Method default) ].
  End Impl_core_default_Default_for_alloc_sync_Arc_core_ffi_c_str_CStr_alloc_alloc_Global.
  
  Module Impl_core_default_Default_for_alloc_sync_Arc_slice_T_alloc_alloc_Global.
    Definition Self (T : Ty.t) : Ty.t :=
      Ty.apply
        (Ty.path "alloc::sync::Arc")
        []
        [ Ty.apply (Ty.path "slice") [] [ T ]; Ty.path "alloc::alloc::Global" ].
    
    (*
        fn default() -> Self {
            if mem::align_of::<T>() <= MAX_STATIC_INNER_SLICE_ALIGNMENT {
                // We take a reference to the whole struct instead of the ArcInner<[u8; 1]> inside it so
                // we don't shrink the range of bytes the ptr is allowed to access under Stacked Borrows.
                // (Miri complains on 32-bit targets with Arc<[Align16]> otherwise.)
                // (Note that NonNull::from(&STATIC_INNER_SLICE.inner) is fine under Tree Borrows.)
                let inner: NonNull<SliceArcInnerForStatic> = NonNull::from(&STATIC_INNER_SLICE);
                let inner: NonNull<ArcInner<[T; 0]>> = inner.cast();
                // `this` semantically is the Arc "owned" by the static, so make sure not to drop it.
                let this: mem::ManuallyDrop<Arc<[T; 0]>> =
                    unsafe { mem::ManuallyDrop::new(Arc::from_inner(inner)) };
                return ( *this).clone();
            }
    
            // If T's alignment is too large for the static, make a new unique allocation.
            let arr: [T; 0] = [];
            Arc::from(arr)
        }
    *)
    Definition default (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [], [] =>
        ltac:(M.monadic
          (M.catch_return
            (Ty.apply
              (Ty.path "alloc::sync::Arc")
              []
              [ Ty.apply (Ty.path "slice") [] [ T ]; Ty.path "alloc::alloc::Global" ]) (|
            ltac:(M.monadic
              (M.read (|
                let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                  M.match_operator (|
                    Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                M.call_closure (|
                                  Ty.path "bool",
                                  BinOp.le,
                                  [
                                    M.call_closure (|
                                      Ty.path "usize",
                                      M.get_function (| "core::mem::align_of", [], [ T ] |),
                                      []
                                    |);
                                    M.read (|
                                      get_constant (|
                                        "alloc::sync::MAX_STATIC_INNER_SLICE_ALIGNMENT",
                                        Ty.path "usize"
                                      |)
                                    |)
                                  ]
                                |)
                              |)) in
                          let _ :=
                            is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (|
                            M.never_to_any (|
                              M.read (|
                                let~ inner :
                                    Ty.apply
                                      (Ty.path "*")
                                      []
                                      [
                                        Ty.apply
                                          (Ty.path "core::ptr::non_null::NonNull")
                                          []
                                          [ Ty.path "alloc::sync::SliceArcInnerForStatic" ]
                                      ] :=
                                  M.alloc (|
                                    M.call_closure (|
                                      Ty.apply
                                        (Ty.path "core::ptr::non_null::NonNull")
                                        []
                                        [ Ty.path "alloc::sync::SliceArcInnerForStatic" ],
                                      M.get_trait_method (|
                                        "core::convert::From",
                                        Ty.apply
                                          (Ty.path "core::ptr::non_null::NonNull")
                                          []
                                          [ Ty.path "alloc::sync::SliceArcInnerForStatic" ],
                                        [],
                                        [
                                          Ty.apply
                                            (Ty.path "&")
                                            []
                                            [ Ty.path "alloc::sync::SliceArcInnerForStatic" ]
                                        ],
                                        "from",
                                        [],
                                        []
                                      |),
                                      [
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.deref (|
                                            M.read (|
                                              get_constant (|
                                                "alloc::sync::STATIC_INNER_SLICE",
                                                Ty.apply
                                                  (Ty.path "&")
                                                  []
                                                  [ Ty.path "alloc::sync::SliceArcInnerForStatic" ]
                                              |)
                                            |)
                                          |)
                                        |)
                                      ]
                                    |)
                                  |) in
                                let~ inner :
                                    Ty.apply
                                      (Ty.path "*")
                                      []
                                      [
                                        Ty.apply
                                          (Ty.path "core::ptr::non_null::NonNull")
                                          []
                                          [
                                            Ty.apply
                                              (Ty.path "alloc::sync::ArcInner")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "array")
                                                  [ Value.Integer IntegerKind.Usize 0 ]
                                                  [ T ]
                                              ]
                                          ]
                                      ] :=
                                  M.alloc (|
                                    M.call_closure (|
                                      Ty.apply
                                        (Ty.path "core::ptr::non_null::NonNull")
                                        []
                                        [
                                          Ty.apply
                                            (Ty.path "alloc::sync::ArcInner")
                                            []
                                            [
                                              Ty.apply
                                                (Ty.path "array")
                                                [ Value.Integer IntegerKind.Usize 0 ]
                                                [ T ]
                                            ]
                                        ],
                                      M.get_associated_function (|
                                        Ty.apply
                                          (Ty.path "core::ptr::non_null::NonNull")
                                          []
                                          [ Ty.path "alloc::sync::SliceArcInnerForStatic" ],
                                        "cast",
                                        [],
                                        [
                                          Ty.apply
                                            (Ty.path "alloc::sync::ArcInner")
                                            []
                                            [
                                              Ty.apply
                                                (Ty.path "array")
                                                [ Value.Integer IntegerKind.Usize 0 ]
                                                [ T ]
                                            ]
                                        ]
                                      |),
                                      [ M.read (| inner |) ]
                                    |)
                                  |) in
                                let~ this :
                                    Ty.apply
                                      (Ty.path "*")
                                      []
                                      [
                                        Ty.apply
                                          (Ty.path "core::mem::manually_drop::ManuallyDrop")
                                          []
                                          [
                                            Ty.apply
                                              (Ty.path "alloc::sync::Arc")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "array")
                                                  [ Value.Integer IntegerKind.Usize 0 ]
                                                  [ T ];
                                                Ty.path "alloc::alloc::Global"
                                              ]
                                          ]
                                      ] :=
                                  M.alloc (|
                                    M.call_closure (|
                                      Ty.apply
                                        (Ty.path "core::mem::manually_drop::ManuallyDrop")
                                        []
                                        [
                                          Ty.apply
                                            (Ty.path "alloc::sync::Arc")
                                            []
                                            [
                                              Ty.apply
                                                (Ty.path "array")
                                                [ Value.Integer IntegerKind.Usize 0 ]
                                                [ T ];
                                              Ty.path "alloc::alloc::Global"
                                            ]
                                        ],
                                      M.get_associated_function (|
                                        Ty.apply
                                          (Ty.path "core::mem::manually_drop::ManuallyDrop")
                                          []
                                          [
                                            Ty.apply
                                              (Ty.path "alloc::sync::Arc")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "array")
                                                  [ Value.Integer IntegerKind.Usize 0 ]
                                                  [ T ];
                                                Ty.path "alloc::alloc::Global"
                                              ]
                                          ],
                                        "new",
                                        [],
                                        []
                                      |),
                                      [
                                        M.call_closure (|
                                          Ty.apply
                                            (Ty.path "alloc::sync::Arc")
                                            []
                                            [
                                              Ty.apply
                                                (Ty.path "array")
                                                [ Value.Integer IntegerKind.Usize 0 ]
                                                [ T ];
                                              Ty.path "alloc::alloc::Global"
                                            ],
                                          M.get_associated_function (|
                                            Ty.apply
                                              (Ty.path "alloc::sync::Arc")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "array")
                                                  [ Value.Integer IntegerKind.Usize 0 ]
                                                  [ T ];
                                                Ty.path "alloc::alloc::Global"
                                              ],
                                            "from_inner",
                                            [],
                                            []
                                          |),
                                          [ M.read (| inner |) ]
                                        |)
                                      ]
                                    |)
                                  |) in
                                M.return_ (|
                                  (* Unsize *)
                                  M.pointer_coercion
                                    (M.call_closure (|
                                      Ty.apply
                                        (Ty.path "alloc::sync::Arc")
                                        []
                                        [
                                          Ty.apply
                                            (Ty.path "array")
                                            [ Value.Integer IntegerKind.Usize 0 ]
                                            [ T ];
                                          Ty.path "alloc::alloc::Global"
                                        ],
                                      M.get_trait_method (|
                                        "core::clone::Clone",
                                        Ty.apply
                                          (Ty.path "alloc::sync::Arc")
                                          []
                                          [
                                            Ty.apply
                                              (Ty.path "array")
                                              [ Value.Integer IntegerKind.Usize 0 ]
                                              [ T ];
                                            Ty.path "alloc::alloc::Global"
                                          ],
                                        [],
                                        [],
                                        "clone",
                                        [],
                                        []
                                      |),
                                      [
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.deref (|
                                            M.call_closure (|
                                              Ty.apply
                                                (Ty.path "&")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path "alloc::sync::Arc")
                                                    []
                                                    [
                                                      Ty.apply
                                                        (Ty.path "array")
                                                        [ Value.Integer IntegerKind.Usize 0 ]
                                                        [ T ];
                                                      Ty.path "alloc::alloc::Global"
                                                    ]
                                                ],
                                              M.get_trait_method (|
                                                "core::ops::deref::Deref",
                                                Ty.apply
                                                  (Ty.path "core::mem::manually_drop::ManuallyDrop")
                                                  []
                                                  [
                                                    Ty.apply
                                                      (Ty.path "alloc::sync::Arc")
                                                      []
                                                      [
                                                        Ty.apply
                                                          (Ty.path "array")
                                                          [ Value.Integer IntegerKind.Usize 0 ]
                                                          [ T ];
                                                        Ty.path "alloc::alloc::Global"
                                                      ]
                                                  ],
                                                [],
                                                [],
                                                "deref",
                                                [],
                                                []
                                              |),
                                              [ M.borrow (| Pointer.Kind.Ref, this |) ]
                                            |)
                                          |)
                                        |)
                                      ]
                                    |))
                                |)
                              |)
                            |)
                          |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                let~ arr :
                    Ty.apply
                      (Ty.path "*")
                      []
                      [ Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 0 ] [ T ] ] :=
                  M.alloc (| Value.Array [] |) in
                M.alloc (|
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "alloc::sync::Arc")
                      []
                      [ Ty.apply (Ty.path "slice") [] [ T ]; Ty.path "alloc::alloc::Global" ],
                    M.get_trait_method (|
                      "core::convert::From",
                      Ty.apply
                        (Ty.path "alloc::sync::Arc")
                        []
                        [ Ty.apply (Ty.path "slice") [] [ T ]; Ty.path "alloc::alloc::Global" ],
                      [],
                      [ Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 0 ] [ T ] ],
                      "from",
                      [],
                      []
                    |),
                    [ M.read (| arr |) ]
                  |)
                |)
              |)))
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "core::default::Default"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self T)
        (* Instance *) [ ("default", InstanceField.Method (default T)) ].
  End Impl_core_default_Default_for_alloc_sync_Arc_slice_T_alloc_alloc_Global.
  
  Module Impl_core_hash_Hash_where_core_marker_Sized_T_where_core_hash_Hash_T_where_core_alloc_Allocator_A_for_alloc_sync_Arc_T_A.
    Definition Self (T A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; A ].
    
    (*
        fn hash<H: Hasher>(&self, state: &mut H) {
            ( **self).hash(state)
        }
    *)
    Definition hash (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [ H ], [ self; state ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let state := M.alloc (| state |) in
          M.call_closure (|
            Ty.tuple [],
            M.get_trait_method (| "core::hash::Hash", T, [], [], "hash", [], [ H ] |),
            [
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.call_closure (|
                    Ty.apply (Ty.path "&") [] [ T ],
                    M.get_trait_method (|
                      "core::ops::deref::Deref",
                      Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; A ],
                      [],
                      [],
                      "deref",
                      [],
                      []
                    |),
                    [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                  |)
                |)
              |);
              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (T A : Ty.t),
      M.IsTraitInstance
        "core::hash::Hash"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self T A)
        (* Instance *) [ ("hash", InstanceField.Method (hash T A)) ].
  End Impl_core_hash_Hash_where_core_marker_Sized_T_where_core_hash_Hash_T_where_core_alloc_Allocator_A_for_alloc_sync_Arc_T_A.
  
  Module Impl_core_convert_From_T_for_alloc_sync_Arc_T_alloc_alloc_Global.
    Definition Self (T : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; Ty.path "alloc::alloc::Global" ].
    
    (*
        fn from(t: T) -> Self {
            Arc::new(t)
        }
    *)
    Definition from (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [], [ t ] =>
        ltac:(M.monadic
          (let t := M.alloc (| t |) in
          M.call_closure (|
            Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; Ty.path "alloc::alloc::Global" ],
            M.get_associated_function (|
              Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; Ty.path "alloc::alloc::Global" ],
              "new",
              [],
              []
            |),
            [ M.read (| t |) ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "core::convert::From"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ T ]
        (Self T)
        (* Instance *) [ ("from", InstanceField.Method (from T)) ].
  End Impl_core_convert_From_T_for_alloc_sync_Arc_T_alloc_alloc_Global.
  
  Module Impl_core_convert_From_array_N_T_for_alloc_sync_Arc_slice_T_alloc_alloc_Global.
    Definition Self (N : Value.t) (T : Ty.t) : Ty.t :=
      Ty.apply
        (Ty.path "alloc::sync::Arc")
        []
        [ Ty.apply (Ty.path "slice") [] [ T ]; Ty.path "alloc::alloc::Global" ].
    
    (*
        fn from(v: [T; N]) -> Arc<[T]> {
            Arc::<[T; N]>::from(v)
        }
    *)
    Definition from
        (N : Value.t)
        (T : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self N T in
      match ε, τ, α with
      | [], [], [ v ] =>
        ltac:(M.monadic
          (let v := M.alloc (| v |) in
          (* Unsize *)
          M.pointer_coercion
            (M.call_closure (|
              Ty.apply
                (Ty.path "alloc::sync::Arc")
                []
                [ Ty.apply (Ty.path "array") [ N ] [ T ]; Ty.path "alloc::alloc::Global" ],
              M.get_trait_method (|
                "core::convert::From",
                Ty.apply
                  (Ty.path "alloc::sync::Arc")
                  []
                  [ Ty.apply (Ty.path "array") [ N ] [ T ]; Ty.path "alloc::alloc::Global" ],
                [],
                [ Ty.apply (Ty.path "array") [ N ] [ T ] ],
                "from",
                [],
                []
              |),
              [ M.read (| v |) ]
            |))))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (N : Value.t) (T : Ty.t),
      M.IsTraitInstance
        "core::convert::From"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.apply (Ty.path "array") [ N ] [ T ] ]
        (Self N T)
        (* Instance *) [ ("from", InstanceField.Method (from N T)) ].
  End Impl_core_convert_From_array_N_T_for_alloc_sync_Arc_slice_T_alloc_alloc_Global.
  
  Module Impl_core_convert_From_where_core_clone_Clone_T_ref__slice_T_for_alloc_sync_Arc_slice_T_alloc_alloc_Global.
    Definition Self (T : Ty.t) : Ty.t :=
      Ty.apply
        (Ty.path "alloc::sync::Arc")
        []
        [ Ty.apply (Ty.path "slice") [] [ T ]; Ty.path "alloc::alloc::Global" ].
    
    (*
        fn from(v: &[T]) -> Arc<[T]> {
            <Self as ArcFromSlice<T>>::from_slice(v)
        }
    *)
    Definition from (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [], [ v ] =>
        ltac:(M.monadic
          (let v := M.alloc (| v |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "alloc::sync::Arc")
              []
              [ Ty.apply (Ty.path "slice") [] [ T ]; Ty.path "alloc::alloc::Global" ],
            M.get_trait_method (|
              "alloc::sync::ArcFromSlice",
              Ty.apply
                (Ty.path "alloc::sync::Arc")
                []
                [ Ty.apply (Ty.path "slice") [] [ T ]; Ty.path "alloc::alloc::Global" ],
              [],
              [ T ],
              "from_slice",
              [],
              []
            |),
            [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| v |) |) |) ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "core::convert::From"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *)
        [ Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ T ] ] ]
        (Self T)
        (* Instance *) [ ("from", InstanceField.Method (from T)) ].
  End Impl_core_convert_From_where_core_clone_Clone_T_ref__slice_T_for_alloc_sync_Arc_slice_T_alloc_alloc_Global.
  
  Module Impl_core_convert_From_where_core_clone_Clone_T_ref_mut_slice_T_for_alloc_sync_Arc_slice_T_alloc_alloc_Global.
    Definition Self (T : Ty.t) : Ty.t :=
      Ty.apply
        (Ty.path "alloc::sync::Arc")
        []
        [ Ty.apply (Ty.path "slice") [] [ T ]; Ty.path "alloc::alloc::Global" ].
    
    (*
        fn from(v: &mut [T]) -> Arc<[T]> {
            Arc::from(&*v)
        }
    *)
    Definition from (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [], [ v ] =>
        ltac:(M.monadic
          (let v := M.alloc (| v |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "alloc::sync::Arc")
              []
              [ Ty.apply (Ty.path "slice") [] [ T ]; Ty.path "alloc::alloc::Global" ],
            M.get_trait_method (|
              "core::convert::From",
              Ty.apply
                (Ty.path "alloc::sync::Arc")
                []
                [ Ty.apply (Ty.path "slice") [] [ T ]; Ty.path "alloc::alloc::Global" ],
              [],
              [ Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ T ] ] ],
              "from",
              [],
              []
            |),
            [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| v |) |) |) ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "core::convert::From"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *)
        [ Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "slice") [] [ T ] ] ]
        (Self T)
        (* Instance *) [ ("from", InstanceField.Method (from T)) ].
  End Impl_core_convert_From_where_core_clone_Clone_T_ref_mut_slice_T_for_alloc_sync_Arc_slice_T_alloc_alloc_Global.
  
  Module Impl_core_convert_From_ref__str_for_alloc_sync_Arc_str_alloc_alloc_Global.
    Definition Self : Ty.t :=
      Ty.apply (Ty.path "alloc::sync::Arc") [] [ Ty.path "str"; Ty.path "alloc::alloc::Global" ].
    
    (*
        fn from(v: &str) -> Arc<str> {
            let arc = Arc::<[u8]>::from(v.as_bytes());
            unsafe { Arc::from_raw(Arc::into_raw(arc) as *const str) }
        }
    *)
    Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ v ] =>
        ltac:(M.monadic
          (let v := M.alloc (| v |) in
          M.read (|
            let~ arc :
                Ty.apply
                  (Ty.path "*")
                  []
                  [
                    Ty.apply
                      (Ty.path "alloc::sync::Arc")
                      []
                      [
                        Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ];
                        Ty.path "alloc::alloc::Global"
                      ]
                  ] :=
              M.alloc (|
                M.call_closure (|
                  Ty.apply
                    (Ty.path "alloc::sync::Arc")
                    []
                    [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ]; Ty.path "alloc::alloc::Global"
                    ],
                  M.get_trait_method (|
                    "core::convert::From",
                    Ty.apply
                      (Ty.path "alloc::sync::Arc")
                      []
                      [
                        Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ];
                        Ty.path "alloc::alloc::Global"
                      ],
                    [],
                    [ Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
                    ],
                    "from",
                    [],
                    []
                  |),
                  [
                    M.call_closure (|
                      Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                      M.get_associated_function (| Ty.path "str", "as_bytes", [], [] |),
                      [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| v |) |) |) ]
                    |)
                  ]
                |)
              |) in
            M.alloc (|
              M.call_closure (|
                Ty.apply
                  (Ty.path "alloc::sync::Arc")
                  []
                  [ Ty.path "str"; Ty.path "alloc::alloc::Global" ],
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "alloc::sync::Arc")
                    []
                    [ Ty.path "str"; Ty.path "alloc::alloc::Global" ],
                  "from_raw",
                  [],
                  []
                |),
                [
                  M.cast
                    (Ty.apply (Ty.path "*const") [] [ Ty.path "str" ])
                    (M.call_closure (|
                      Ty.apply
                        (Ty.path "*const")
                        []
                        [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "alloc::sync::Arc")
                          []
                          [
                            Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ];
                            Ty.path "alloc::alloc::Global"
                          ],
                        "into_raw",
                        [],
                        []
                      |),
                      [ M.read (| arc |) ]
                    |))
                ]
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::convert::From"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.apply (Ty.path "&") [] [ Ty.path "str" ] ]
        Self
        (* Instance *) [ ("from", InstanceField.Method from) ].
  End Impl_core_convert_From_ref__str_for_alloc_sync_Arc_str_alloc_alloc_Global.
  
  Module Impl_core_convert_From_ref_mut_str_for_alloc_sync_Arc_str_alloc_alloc_Global.
    Definition Self : Ty.t :=
      Ty.apply (Ty.path "alloc::sync::Arc") [] [ Ty.path "str"; Ty.path "alloc::alloc::Global" ].
    
    (*
        fn from(v: &mut str) -> Arc<str> {
            Arc::from(&*v)
        }
    *)
    Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ v ] =>
        ltac:(M.monadic
          (let v := M.alloc (| v |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "alloc::sync::Arc")
              []
              [ Ty.path "str"; Ty.path "alloc::alloc::Global" ],
            M.get_trait_method (|
              "core::convert::From",
              Ty.apply
                (Ty.path "alloc::sync::Arc")
                []
                [ Ty.path "str"; Ty.path "alloc::alloc::Global" ],
              [],
              [ Ty.apply (Ty.path "&") [] [ Ty.path "str" ] ],
              "from",
              [],
              []
            |),
            [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| v |) |) |) ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::convert::From"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.apply (Ty.path "&mut") [] [ Ty.path "str" ] ]
        Self
        (* Instance *) [ ("from", InstanceField.Method from) ].
  End Impl_core_convert_From_ref_mut_str_for_alloc_sync_Arc_str_alloc_alloc_Global.
  
  Module Impl_core_convert_From_alloc_string_String_for_alloc_sync_Arc_str_alloc_alloc_Global.
    Definition Self : Ty.t :=
      Ty.apply (Ty.path "alloc::sync::Arc") [] [ Ty.path "str"; Ty.path "alloc::alloc::Global" ].
    
    (*
        fn from(v: String) -> Arc<str> {
            Arc::from(&v[..])
        }
    *)
    Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ v ] =>
        ltac:(M.monadic
          (let v := M.alloc (| v |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "alloc::sync::Arc")
              []
              [ Ty.path "str"; Ty.path "alloc::alloc::Global" ],
            M.get_trait_method (|
              "core::convert::From",
              Ty.apply
                (Ty.path "alloc::sync::Arc")
                []
                [ Ty.path "str"; Ty.path "alloc::alloc::Global" ],
              [],
              [ Ty.apply (Ty.path "&") [] [ Ty.path "str" ] ],
              "from",
              [],
              []
            |),
            [
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.call_closure (|
                    Ty.apply (Ty.path "&") [] [ Ty.path "str" ],
                    M.get_trait_method (|
                      "core::ops::index::Index",
                      Ty.path "alloc::string::String",
                      [],
                      [ Ty.path "core::ops::range::RangeFull" ],
                      "index",
                      [],
                      []
                    |),
                    [
                      M.borrow (| Pointer.Kind.Ref, v |);
                      Value.StructTuple "core::ops::range::RangeFull" []
                    ]
                  |)
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::convert::From"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.path "alloc::string::String" ]
        Self
        (* Instance *) [ ("from", InstanceField.Method from) ].
  End Impl_core_convert_From_alloc_string_String_for_alloc_sync_Arc_str_alloc_alloc_Global.
  
  Module Impl_core_convert_From_where_core_marker_Sized_T_where_core_alloc_Allocator_A_alloc_boxed_Box_T_A_for_alloc_sync_Arc_T_A.
    Definition Self (T A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; A ].
    
    (*
        fn from(v: Box<T, A>) -> Arc<T, A> {
            Arc::from_box_in(v)
        }
    *)
    Definition from (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ v ] =>
        ltac:(M.monadic
          (let v := M.alloc (| v |) in
          M.call_closure (|
            Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; A ],
            M.get_associated_function (|
              Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; A ],
              "from_box_in",
              [],
              []
            |),
            [ M.read (| v |) ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (T A : Ty.t),
      M.IsTraitInstance
        "core::convert::From"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.apply (Ty.path "alloc::boxed::Box") [] [ T; A ] ]
        (Self T A)
        (* Instance *) [ ("from", InstanceField.Method (from T A)) ].
  End Impl_core_convert_From_where_core_marker_Sized_T_where_core_alloc_Allocator_A_alloc_boxed_Box_T_A_for_alloc_sync_Arc_T_A.
  
  Module Impl_core_convert_From_where_core_alloc_Allocator_A_where_core_clone_Clone_A_alloc_vec_Vec_T_A_for_alloc_sync_Arc_slice_T_A.
    Definition Self (T A : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "alloc::sync::Arc") [] [ Ty.apply (Ty.path "slice") [] [ T ]; A ].
    
    (*
        fn from(v: Vec<T, A>) -> Arc<[T], A> {
            unsafe {
                let (vec_ptr, len, cap, alloc) = v.into_raw_parts_with_alloc();
    
                let rc_ptr = Self::allocate_for_slice_in(len, &alloc);
                ptr::copy_nonoverlapping(vec_ptr, (&raw mut ( *rc_ptr).data) as *mut T, len);
    
                // Create a `Vec<T, &A>` with length 0, to deallocate the buffer
                // without dropping its contents or the allocator
                let _ = Vec::from_raw_parts_in(vec_ptr, 0, cap, &alloc);
    
                Self::from_ptr_in(rc_ptr, alloc)
            }
        }
    *)
    Definition from (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ v ] =>
        ltac:(M.monadic
          (let v := M.alloc (| v |) in
          M.read (|
            M.match_operator (|
              Ty.apply
                (Ty.path "*")
                []
                [
                  Ty.apply
                    (Ty.path "alloc::sync::Arc")
                    []
                    [ Ty.apply (Ty.path "slice") [] [ T ]; A ]
                ],
              M.alloc (|
                M.call_closure (|
                  Ty.tuple
                    [ Ty.apply (Ty.path "*mut") [] [ T ]; Ty.path "usize"; Ty.path "usize"; A ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "alloc::vec::Vec") [] [ T; A ],
                    "into_raw_parts_with_alloc",
                    [],
                    []
                  |),
                  [ M.read (| v |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let γ0_2 := M.SubPointer.get_tuple_field (| γ, 2 |) in
                    let γ0_3 := M.SubPointer.get_tuple_field (| γ, 3 |) in
                    let vec_ptr := M.copy (| γ0_0 |) in
                    let len := M.copy (| γ0_1 |) in
                    let cap := M.copy (| γ0_2 |) in
                    let alloc := M.copy (| γ0_3 |) in
                    let~ rc_ptr :
                        Ty.apply
                          (Ty.path "*")
                          []
                          [
                            Ty.apply
                              (Ty.path "*mut")
                              []
                              [
                                Ty.apply
                                  (Ty.path "alloc::sync::ArcInner")
                                  []
                                  [ Ty.apply (Ty.path "slice") [] [ T ] ]
                              ]
                          ] :=
                      M.alloc (|
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "*mut")
                            []
                            [
                              Ty.apply
                                (Ty.path "alloc::sync::ArcInner")
                                []
                                [ Ty.apply (Ty.path "slice") [] [ T ] ]
                            ],
                          M.get_associated_function (|
                            Ty.apply
                              (Ty.path "alloc::sync::Arc")
                              []
                              [ Ty.apply (Ty.path "slice") [] [ T ]; A ],
                            "allocate_for_slice_in",
                            [],
                            []
                          |),
                          [
                            M.read (| len |);
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.deref (| M.borrow (| Pointer.Kind.Ref, alloc |) |)
                            |)
                          ]
                        |)
                      |) in
                    let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                      M.alloc (|
                        M.call_closure (|
                          Ty.tuple [],
                          M.get_function (| "core::intrinsics::copy_nonoverlapping", [], [ T ] |),
                          [
                            (* MutToConstPointer *) M.pointer_coercion (M.read (| vec_ptr |));
                            M.cast
                              (Ty.apply (Ty.path "*mut") [] [ T ])
                              (M.borrow (|
                                Pointer.Kind.MutPointer,
                                M.SubPointer.get_struct_record_field (|
                                  M.deref (| M.read (| rc_ptr |) |),
                                  "alloc::sync::ArcInner",
                                  "data"
                                |)
                              |));
                            M.read (| len |)
                          ]
                        |)
                      |) in
                    M.match_operator (|
                      Ty.apply
                        (Ty.path "*")
                        []
                        [
                          Ty.apply
                            (Ty.path "alloc::sync::Arc")
                            []
                            [ Ty.apply (Ty.path "slice") [] [ T ]; A ]
                        ],
                      M.alloc (|
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "alloc::vec::Vec")
                            []
                            [ T; Ty.apply (Ty.path "&") [] [ A ] ],
                          M.get_associated_function (|
                            Ty.apply
                              (Ty.path "alloc::vec::Vec")
                              []
                              [ T; Ty.apply (Ty.path "&") [] [ A ] ],
                            "from_raw_parts_in",
                            [],
                            []
                          |),
                          [
                            M.read (| vec_ptr |);
                            Value.Integer IntegerKind.Usize 0;
                            M.read (| cap |);
                            M.borrow (| Pointer.Kind.Ref, alloc |)
                          ]
                        |)
                      |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (M.alloc (|
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "alloc::sync::Arc")
                                  []
                                  [ Ty.apply (Ty.path "slice") [] [ T ]; A ],
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "alloc::sync::Arc")
                                    []
                                    [ Ty.apply (Ty.path "slice") [] [ T ]; A ],
                                  "from_ptr_in",
                                  [],
                                  []
                                |),
                                [ M.read (| rc_ptr |); M.read (| alloc |) ]
                              |)
                            |)))
                      ]
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (T A : Ty.t),
      M.IsTraitInstance
        "core::convert::From"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.apply (Ty.path "alloc::vec::Vec") [] [ T; A ] ]
        (Self T A)
        (* Instance *) [ ("from", InstanceField.Method (from T A)) ].
  End Impl_core_convert_From_where_core_alloc_Allocator_A_where_core_clone_Clone_A_alloc_vec_Vec_T_A_for_alloc_sync_Arc_slice_T_A.
  
  Module Impl_core_convert_From_where_alloc_borrow_ToOwned_B_where_core_marker_Sized_B_where_core_convert_From_alloc_sync_Arc_B_alloc_alloc_Global_ref__B_where_core_convert_From_alloc_sync_Arc_B_alloc_alloc_Global_associated_in_trait_alloc_borrow_ToOwned___B_Owned_alloc_borrow_Cow_B_for_alloc_sync_Arc_B_alloc_alloc_Global.
    Definition Self (B : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "alloc::sync::Arc") [] [ B; Ty.path "alloc::alloc::Global" ].
    
    (*
        fn from(cow: Cow<'a, B>) -> Arc<B> {
            match cow {
                Cow::Borrowed(s) => Arc::from(s),
                Cow::Owned(s) => Arc::from(s),
            }
        }
    *)
    Definition from (B : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self B in
      match ε, τ, α with
      | [], [], [ cow ] =>
        ltac:(M.monadic
          (let cow := M.alloc (| cow |) in
          M.read (|
            M.match_operator (|
              Ty.apply
                (Ty.path "*")
                []
                [ Ty.apply (Ty.path "alloc::sync::Arc") [] [ B; Ty.path "alloc::alloc::Global" ] ],
              cow,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "alloc::borrow::Cow::Borrowed",
                        0
                      |) in
                    let s := M.copy (| γ0_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "alloc::sync::Arc")
                          []
                          [ B; Ty.path "alloc::alloc::Global" ],
                        M.get_trait_method (|
                          "core::convert::From",
                          Ty.apply
                            (Ty.path "alloc::sync::Arc")
                            []
                            [ B; Ty.path "alloc::alloc::Global" ],
                          [],
                          [ Ty.apply (Ty.path "&") [] [ B ] ],
                          "from",
                          [],
                          []
                        |),
                        [ M.read (| s |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 :=
                      M.SubPointer.get_struct_tuple_field (| γ, "alloc::borrow::Cow::Owned", 0 |) in
                    let s := M.copy (| γ0_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "alloc::sync::Arc")
                          []
                          [ B; Ty.path "alloc::alloc::Global" ],
                        M.get_trait_method (|
                          "core::convert::From",
                          Ty.apply
                            (Ty.path "alloc::sync::Arc")
                            []
                            [ B; Ty.path "alloc::alloc::Global" ],
                          [],
                          [ Ty.associated_in_trait "alloc::borrow::ToOwned" [] [] B "Owned" ],
                          "from",
                          [],
                          []
                        |),
                        [ M.read (| s |) ]
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (B : Ty.t),
      M.IsTraitInstance
        "core::convert::From"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.apply (Ty.path "alloc::borrow::Cow") [] [ B ] ]
        (Self B)
        (* Instance *) [ ("from", InstanceField.Method (from B)) ].
  End Impl_core_convert_From_where_alloc_borrow_ToOwned_B_where_core_marker_Sized_B_where_core_convert_From_alloc_sync_Arc_B_alloc_alloc_Global_ref__B_where_core_convert_From_alloc_sync_Arc_B_alloc_alloc_Global_associated_in_trait_alloc_borrow_ToOwned___B_Owned_alloc_borrow_Cow_B_for_alloc_sync_Arc_B_alloc_alloc_Global.
  
  Module Impl_core_convert_From_alloc_sync_Arc_str_alloc_alloc_Global_for_alloc_sync_Arc_slice_u8_alloc_alloc_Global.
    Definition Self : Ty.t :=
      Ty.apply
        (Ty.path "alloc::sync::Arc")
        []
        [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ]; Ty.path "alloc::alloc::Global" ].
    
    (*
        fn from(rc: Arc<str>) -> Self {
            // SAFETY: `str` has the same layout as `[u8]`.
            unsafe { Arc::from_raw(Arc::into_raw(rc) as *const [u8]) }
        }
    *)
    Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ rc ] =>
        ltac:(M.monadic
          (let rc := M.alloc (| rc |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "alloc::sync::Arc")
              []
              [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ]; Ty.path "alloc::alloc::Global" ],
            M.get_associated_function (|
              Ty.apply
                (Ty.path "alloc::sync::Arc")
                []
                [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ]; Ty.path "alloc::alloc::Global" ],
              "from_raw",
              [],
              []
            |),
            [
              M.cast
                (Ty.apply (Ty.path "*const") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ])
                (M.call_closure (|
                  Ty.apply (Ty.path "*const") [] [ Ty.path "str" ],
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "alloc::sync::Arc")
                      []
                      [ Ty.path "str"; Ty.path "alloc::alloc::Global" ],
                    "into_raw",
                    [],
                    []
                  |),
                  [ M.read (| rc |) ]
                |))
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::convert::From"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *)
        [ Ty.apply (Ty.path "alloc::sync::Arc") [] [ Ty.path "str"; Ty.path "alloc::alloc::Global" ]
        ]
        Self
        (* Instance *) [ ("from", InstanceField.Method from) ].
  End Impl_core_convert_From_alloc_sync_Arc_str_alloc_alloc_Global_for_alloc_sync_Arc_slice_u8_alloc_alloc_Global.
  
  Module Impl_core_convert_TryFrom_where_core_alloc_Allocator_A_alloc_sync_Arc_slice_T_A_for_alloc_sync_Arc_array_N_T_A.
    Definition Self (N : Value.t) (T A : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "alloc::sync::Arc") [] [ Ty.apply (Ty.path "array") [ N ] [ T ]; A ].
    
    (*     type Error = Arc<[T], A>; *)
    Definition _Error (N : Value.t) (T A : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "alloc::sync::Arc") [] [ Ty.apply (Ty.path "slice") [] [ T ]; A ].
    
    (*
        fn try_from(boxed_slice: Arc<[T], A>) -> Result<Self, Self::Error> {
            if boxed_slice.len() == N {
                let (ptr, alloc) = Arc::into_inner_with_allocator(boxed_slice);
                Ok(unsafe { Arc::from_inner_in(ptr.cast(), alloc) })
            } else {
                Err(boxed_slice)
            }
        }
    *)
    Definition try_from
        (N : Value.t)
        (T A : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self N T A in
      match ε, τ, α with
      | [], [], [ boxed_slice ] =>
        ltac:(M.monadic
          (let boxed_slice := M.alloc (| boxed_slice |) in
          M.read (|
            M.match_operator (|
              Ty.apply
                (Ty.path "*")
                []
                [
                  Ty.apply
                    (Ty.path "core::result::Result")
                    []
                    [
                      Ty.apply
                        (Ty.path "alloc::sync::Arc")
                        []
                        [ Ty.apply (Ty.path "array") [ N ] [ T ]; A ];
                      Ty.apply
                        (Ty.path "alloc::sync::Arc")
                        []
                        [ Ty.apply (Ty.path "slice") [] [ T ]; A ]
                    ]
                ],
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          M.call_closure (|
                            Ty.path "bool",
                            BinOp.eq,
                            [
                              M.call_closure (|
                                Ty.path "usize",
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "slice") [] [ T ],
                                  "len",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (|
                                      M.call_closure (|
                                        Ty.apply
                                          (Ty.path "&")
                                          []
                                          [ Ty.apply (Ty.path "slice") [] [ T ] ],
                                        M.get_trait_method (|
                                          "core::ops::deref::Deref",
                                          Ty.apply
                                            (Ty.path "alloc::sync::Arc")
                                            []
                                            [ Ty.apply (Ty.path "slice") [] [ T ]; A ],
                                          [],
                                          [],
                                          "deref",
                                          [],
                                          []
                                        |),
                                        [ M.borrow (| Pointer.Kind.Ref, boxed_slice |) ]
                                      |)
                                    |)
                                  |)
                                ]
                              |);
                              N
                            ]
                          |)
                        |)) in
                    let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.match_operator (|
                      Ty.apply
                        (Ty.path "*")
                        []
                        [
                          Ty.apply
                            (Ty.path "core::result::Result")
                            []
                            [
                              Ty.apply
                                (Ty.path "alloc::sync::Arc")
                                []
                                [ Ty.apply (Ty.path "array") [ N ] [ T ]; A ];
                              Ty.apply
                                (Ty.path "alloc::sync::Arc")
                                []
                                [ Ty.apply (Ty.path "slice") [] [ T ]; A ]
                            ]
                        ],
                      M.alloc (|
                        M.call_closure (|
                          Ty.tuple
                            [
                              Ty.apply
                                (Ty.path "core::ptr::non_null::NonNull")
                                []
                                [
                                  Ty.apply
                                    (Ty.path "alloc::sync::ArcInner")
                                    []
                                    [ Ty.apply (Ty.path "slice") [] [ T ] ]
                                ];
                              A
                            ],
                          M.get_associated_function (|
                            Ty.apply
                              (Ty.path "alloc::sync::Arc")
                              []
                              [ Ty.apply (Ty.path "slice") [] [ T ]; A ],
                            "into_inner_with_allocator",
                            [],
                            []
                          |),
                          [ M.read (| boxed_slice |) ]
                        |)
                      |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                            let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                            let ptr := M.copy (| γ0_0 |) in
                            let alloc := M.copy (| γ0_1 |) in
                            M.alloc (|
                              Value.StructTuple
                                "core::result::Result::Ok"
                                [
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "alloc::sync::Arc")
                                      []
                                      [ Ty.apply (Ty.path "array") [ N ] [ T ]; A ],
                                    M.get_associated_function (|
                                      Ty.apply
                                        (Ty.path "alloc::sync::Arc")
                                        []
                                        [ Ty.apply (Ty.path "array") [ N ] [ T ]; A ],
                                      "from_inner_in",
                                      [],
                                      []
                                    |),
                                    [
                                      M.call_closure (|
                                        Ty.apply
                                          (Ty.path "core::ptr::non_null::NonNull")
                                          []
                                          [
                                            Ty.apply
                                              (Ty.path "alloc::sync::ArcInner")
                                              []
                                              [ Ty.apply (Ty.path "array") [ N ] [ T ] ]
                                          ],
                                        M.get_associated_function (|
                                          Ty.apply
                                            (Ty.path "core::ptr::non_null::NonNull")
                                            []
                                            [
                                              Ty.apply
                                                (Ty.path "alloc::sync::ArcInner")
                                                []
                                                [ Ty.apply (Ty.path "slice") [] [ T ] ]
                                            ],
                                          "cast",
                                          [],
                                          [
                                            Ty.apply
                                              (Ty.path "alloc::sync::ArcInner")
                                              []
                                              [ Ty.apply (Ty.path "array") [ N ] [ T ] ]
                                          ]
                                        |),
                                        [ M.read (| ptr |) ]
                                      |);
                                      M.read (| alloc |)
                                    ]
                                  |)
                                ]
                            |)))
                      ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      Value.StructTuple "core::result::Result::Err" [ M.read (| boxed_slice |) ]
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (N : Value.t) (T A : Ty.t),
      M.IsTraitInstance
        "core::convert::TryFrom"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *)
        [ Ty.apply (Ty.path "alloc::sync::Arc") [] [ Ty.apply (Ty.path "slice") [] [ T ]; A ] ]
        (Self N T A)
        (* Instance *)
        [
          ("Error", InstanceField.Ty (_Error N T A));
          ("try_from", InstanceField.Method (try_from N T A))
        ].
  End Impl_core_convert_TryFrom_where_core_alloc_Allocator_A_alloc_sync_Arc_slice_T_A_for_alloc_sync_Arc_array_N_T_A.
  
  Module Impl_core_iter_traits_collect_FromIterator_T_for_alloc_sync_Arc_slice_T_alloc_alloc_Global.
    Definition Self (T : Ty.t) : Ty.t :=
      Ty.apply
        (Ty.path "alloc::sync::Arc")
        []
        [ Ty.apply (Ty.path "slice") [] [ T ]; Ty.path "alloc::alloc::Global" ].
    
    (*
        fn from_iter<I: IntoIterator<Item = T>>(iter: I) -> Self {
            ToArcSlice::to_arc_slice(iter.into_iter())
        }
    *)
    Definition from_iter (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [ _ as I ], [ iter ] =>
        ltac:(M.monadic
          (let iter := M.alloc (| iter |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "alloc::sync::Arc")
              []
              [ Ty.apply (Ty.path "slice") [] [ T ]; Ty.path "alloc::alloc::Global" ],
            M.get_trait_method (|
              "alloc::sync::ToArcSlice",
              Ty.associated_in_trait "core::iter::traits::collect::IntoIterator" [] [] I "IntoIter",
              [],
              [ T ],
              "to_arc_slice",
              [],
              []
            |),
            [
              M.call_closure (|
                Ty.associated_in_trait
                  "core::iter::traits::collect::IntoIterator"
                  []
                  []
                  I
                  "IntoIter",
                M.get_trait_method (|
                  "core::iter::traits::collect::IntoIterator",
                  I,
                  [],
                  [],
                  "into_iter",
                  [],
                  []
                |),
                [ M.read (| iter |) ]
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "core::iter::traits::collect::FromIterator"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ T ]
        (Self T)
        (* Instance *) [ ("from_iter", InstanceField.Method (from_iter T)) ].
  End Impl_core_iter_traits_collect_FromIterator_T_for_alloc_sync_Arc_slice_T_alloc_alloc_Global.
  
  (* Trait *)
  (* Empty module 'ToArcSlice' *)
  
  Module Impl_alloc_sync_ToArcSlice_where_core_iter_traits_iterator_Iterator_I_T_for_I.
    Definition Self (T I : Ty.t) : Ty.t := I.
    
    (*
        default fn to_arc_slice(self) -> Arc<[T]> {
            self.collect::<Vec<T>>().into()
        }
    *)
    Definition to_arc_slice
        (T I : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self T I in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "alloc::sync::Arc")
              []
              [ Ty.apply (Ty.path "slice") [] [ T ]; Ty.path "alloc::alloc::Global" ],
            M.get_trait_method (|
              "core::convert::Into",
              Ty.apply (Ty.path "alloc::vec::Vec") [] [ T; Ty.path "alloc::alloc::Global" ],
              [],
              [
                Ty.apply
                  (Ty.path "alloc::sync::Arc")
                  []
                  [ Ty.apply (Ty.path "slice") [] [ T ]; Ty.path "alloc::alloc::Global" ]
              ],
              "into",
              [],
              []
            |),
            [
              M.call_closure (|
                Ty.apply (Ty.path "alloc::vec::Vec") [] [ T; Ty.path "alloc::alloc::Global" ],
                M.get_trait_method (|
                  "core::iter::traits::iterator::Iterator",
                  I,
                  [],
                  [],
                  "collect",
                  [],
                  [ Ty.apply (Ty.path "alloc::vec::Vec") [] [ T; Ty.path "alloc::alloc::Global" ] ]
                |),
                [ M.read (| self |) ]
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (T I : Ty.t),
      M.IsTraitInstance
        "alloc::sync::ToArcSlice"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ T ]
        (Self T I)
        (* Instance *) [ ("to_arc_slice", InstanceField.Method (to_arc_slice T I)) ].
  End Impl_alloc_sync_ToArcSlice_where_core_iter_traits_iterator_Iterator_I_T_for_I.
  
  Module Impl_alloc_sync_ToArcSlice_where_core_iter_traits_marker_TrustedLen_I_T_for_I.
    Definition Self (T I : Ty.t) : Ty.t := I.
    
    (*
        fn to_arc_slice(self) -> Arc<[T]> {
            // This is the case for a `TrustedLen` iterator.
            let (low, high) = self.size_hint();
            if let Some(high) = high {
                debug_assert_eq!(
                    low,
                    high,
                    "TrustedLen iterator's size hint is not exact: {:?}",
                    (low, high)
                );
    
                unsafe {
                    // SAFETY: We need to ensure that the iterator has an exact length and we have.
                    Arc::from_iter_exact(self, low)
                }
            } else {
                // TrustedLen contract guarantees that `upper_bound == None` implies an iterator
                // length exceeding `usize::MAX`.
                // The default implementation would collect into a vec which would panic.
                // Thus we panic here immediately without invoking `Vec` code.
                panic!("capacity overflow");
            }
        }
    *)
    Definition to_arc_slice
        (T I : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self T I in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              Ty.apply
                (Ty.path "*")
                []
                [
                  Ty.apply
                    (Ty.path "alloc::sync::Arc")
                    []
                    [ Ty.apply (Ty.path "slice") [] [ T ]; Ty.path "alloc::alloc::Global" ]
                ],
              M.alloc (|
                M.call_closure (|
                  Ty.tuple
                    [
                      Ty.path "usize";
                      Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "usize" ]
                    ],
                  M.get_trait_method (|
                    "core::iter::traits::iterator::Iterator",
                    I,
                    [],
                    [],
                    "size_hint",
                    [],
                    []
                  |),
                  [ M.borrow (| Pointer.Kind.Ref, self |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let low := M.copy (| γ0_0 |) in
                    let high := M.copy (| γ0_1 |) in
                    M.match_operator (|
                      Ty.apply
                        (Ty.path "*")
                        []
                        [
                          Ty.apply
                            (Ty.path "alloc::sync::Arc")
                            []
                            [ Ty.apply (Ty.path "slice") [] [ T ]; Ty.path "alloc::alloc::Global" ]
                        ],
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ := high in
                            let γ0_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "core::option::Option::Some",
                                0
                              |) in
                            let high := M.copy (| γ0_0 |) in
                            let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                              M.match_operator (|
                                Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                                M.alloc (| Value.Tuple [] |),
                                [
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let γ := M.use (M.alloc (| Value.Bool true |)) in
                                      let _ :=
                                        is_constant_or_break_match (|
                                          M.read (| γ |),
                                          Value.Bool true
                                        |) in
                                      let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                                        M.match_operator (|
                                          Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                                          M.alloc (|
                                            Value.Tuple
                                              [
                                                M.borrow (| Pointer.Kind.Ref, low |);
                                                M.borrow (| Pointer.Kind.Ref, high |)
                                              ]
                                          |),
                                          [
                                            fun γ =>
                                              ltac:(M.monadic
                                                (let γ0_0 :=
                                                  M.SubPointer.get_tuple_field (| γ, 0 |) in
                                                let γ0_1 :=
                                                  M.SubPointer.get_tuple_field (| γ, 1 |) in
                                                let left_val := M.copy (| γ0_0 |) in
                                                let right_val := M.copy (| γ0_1 |) in
                                                M.match_operator (|
                                                  Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                                                  M.alloc (| Value.Tuple [] |),
                                                  [
                                                    fun γ =>
                                                      ltac:(M.monadic
                                                        (let γ :=
                                                          M.use
                                                            (M.alloc (|
                                                              UnOp.not (|
                                                                M.call_closure (|
                                                                  Ty.path "bool",
                                                                  BinOp.eq,
                                                                  [
                                                                    M.read (|
                                                                      M.deref (|
                                                                        M.read (| left_val |)
                                                                      |)
                                                                    |);
                                                                    M.read (|
                                                                      M.deref (|
                                                                        M.read (| right_val |)
                                                                      |)
                                                                    |)
                                                                  ]
                                                                |)
                                                              |)
                                                            |)) in
                                                        let _ :=
                                                          is_constant_or_break_match (|
                                                            M.read (| γ |),
                                                            Value.Bool true
                                                          |) in
                                                        M.alloc (|
                                                          M.never_to_any (|
                                                            M.read (|
                                                              let~ kind :
                                                                  Ty.apply
                                                                    (Ty.path "*")
                                                                    []
                                                                    [
                                                                      Ty.path
                                                                        "core::panicking::AssertKind"
                                                                    ] :=
                                                                M.alloc (|
                                                                  Value.StructTuple
                                                                    "core::panicking::AssertKind::Eq"
                                                                    []
                                                                |) in
                                                              M.alloc (|
                                                                M.call_closure (|
                                                                  Ty.path "never",
                                                                  M.get_function (|
                                                                    "core::panicking::assert_failed",
                                                                    [],
                                                                    [
                                                                      Ty.path "usize";
                                                                      Ty.path "usize"
                                                                    ]
                                                                  |),
                                                                  [
                                                                    M.read (| kind |);
                                                                    M.borrow (|
                                                                      Pointer.Kind.Ref,
                                                                      M.deref (|
                                                                        M.borrow (|
                                                                          Pointer.Kind.Ref,
                                                                          M.deref (|
                                                                            M.read (| left_val |)
                                                                          |)
                                                                        |)
                                                                      |)
                                                                    |);
                                                                    M.borrow (|
                                                                      Pointer.Kind.Ref,
                                                                      M.deref (|
                                                                        M.borrow (|
                                                                          Pointer.Kind.Ref,
                                                                          M.deref (|
                                                                            M.read (| right_val |)
                                                                          |)
                                                                        |)
                                                                      |)
                                                                    |);
                                                                    Value.StructTuple
                                                                      "core::option::Option::Some"
                                                                      [
                                                                        M.call_closure (|
                                                                          Ty.path
                                                                            "core::fmt::Arguments",
                                                                          M.get_associated_function (|
                                                                            Ty.path
                                                                              "core::fmt::Arguments",
                                                                            "new_v1",
                                                                            [
                                                                              Value.Integer
                                                                                IntegerKind.Usize
                                                                                1;
                                                                              Value.Integer
                                                                                IntegerKind.Usize
                                                                                1
                                                                            ],
                                                                            []
                                                                          |),
                                                                          [
                                                                            M.borrow (|
                                                                              Pointer.Kind.Ref,
                                                                              M.deref (|
                                                                                M.borrow (|
                                                                                  Pointer.Kind.Ref,
                                                                                  M.alloc (|
                                                                                    Value.Array
                                                                                      [
                                                                                        mk_str (|
                                                                                          "TrustedLen iterator's size hint is not exact: "
                                                                                        |)
                                                                                      ]
                                                                                  |)
                                                                                |)
                                                                              |)
                                                                            |);
                                                                            M.borrow (|
                                                                              Pointer.Kind.Ref,
                                                                              M.deref (|
                                                                                M.borrow (|
                                                                                  Pointer.Kind.Ref,
                                                                                  M.alloc (|
                                                                                    Value.Array
                                                                                      [
                                                                                        M.call_closure (|
                                                                                          Ty.path
                                                                                            "core::fmt::rt::Argument",
                                                                                          M.get_associated_function (|
                                                                                            Ty.path
                                                                                              "core::fmt::rt::Argument",
                                                                                            "new_debug",
                                                                                            [],
                                                                                            [
                                                                                              Ty.tuple
                                                                                                [
                                                                                                  Ty.path
                                                                                                    "usize";
                                                                                                  Ty.path
                                                                                                    "usize"
                                                                                                ]
                                                                                            ]
                                                                                          |),
                                                                                          [
                                                                                            M.borrow (|
                                                                                              Pointer.Kind.Ref,
                                                                                              M.deref (|
                                                                                                M.borrow (|
                                                                                                  Pointer.Kind.Ref,
                                                                                                  M.alloc (|
                                                                                                    Value.Tuple
                                                                                                      [
                                                                                                        M.read (|
                                                                                                          low
                                                                                                        |);
                                                                                                        M.read (|
                                                                                                          high
                                                                                                        |)
                                                                                                      ]
                                                                                                  |)
                                                                                                |)
                                                                                              |)
                                                                                            |)
                                                                                          ]
                                                                                        |)
                                                                                      ]
                                                                                  |)
                                                                                |)
                                                                              |)
                                                                            |)
                                                                          ]
                                                                        |)
                                                                      ]
                                                                  ]
                                                                |)
                                                              |)
                                                            |)
                                                          |)
                                                        |)));
                                                    fun γ =>
                                                      ltac:(M.monadic
                                                        (M.alloc (| Value.Tuple [] |)))
                                                  ]
                                                |)))
                                          ]
                                        |) in
                                      M.alloc (| Value.Tuple [] |)));
                                  fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                                ]
                              |) in
                            M.alloc (|
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "alloc::sync::Arc")
                                  []
                                  [
                                    Ty.apply (Ty.path "slice") [] [ T ];
                                    Ty.path "alloc::alloc::Global"
                                  ],
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "alloc::sync::Arc")
                                    []
                                    [
                                      Ty.apply (Ty.path "slice") [] [ T ];
                                      Ty.path "alloc::alloc::Global"
                                    ],
                                  "from_iter_exact",
                                  [],
                                  [ I ]
                                |),
                                [ M.read (| self |); M.read (| low |) ]
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (M.alloc (|
                              M.never_to_any (|
                                M.call_closure (|
                                  Ty.path "never",
                                  M.get_function (| "core::panicking::panic_fmt", [], [] |),
                                  [
                                    M.call_closure (|
                                      Ty.path "core::fmt::Arguments",
                                      M.get_associated_function (|
                                        Ty.path "core::fmt::Arguments",
                                        "new_const",
                                        [ Value.Integer IntegerKind.Usize 1 ],
                                        []
                                      |),
                                      [
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.deref (|
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.alloc (|
                                                Value.Array [ mk_str (| "capacity overflow" |) ]
                                              |)
                                            |)
                                          |)
                                        |)
                                      ]
                                    |)
                                  ]
                                |)
                              |)
                            |)))
                      ]
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (T I : Ty.t),
      M.IsTraitInstance
        "alloc::sync::ToArcSlice"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ T ]
        (Self T I)
        (* Instance *) [ ("to_arc_slice", InstanceField.Method (to_arc_slice T I)) ].
  End Impl_alloc_sync_ToArcSlice_where_core_iter_traits_marker_TrustedLen_I_T_for_I.
  
  Module Impl_core_borrow_Borrow_where_core_marker_Sized_T_where_core_alloc_Allocator_A_T_for_alloc_sync_Arc_T_A.
    Definition Self (T A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; A ].
    
    (*
        fn borrow(&self) -> &T {
            &**self
        }
    *)
    Definition borrow (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.borrow (|
            Pointer.Kind.Ref,
            M.deref (|
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.call_closure (|
                    Ty.apply (Ty.path "&") [] [ T ],
                    M.get_trait_method (|
                      "core::ops::deref::Deref",
                      Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; A ],
                      [],
                      [],
                      "deref",
                      [],
                      []
                    |),
                    [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                  |)
                |)
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (T A : Ty.t),
      M.IsTraitInstance
        "core::borrow::Borrow"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ T ]
        (Self T A)
        (* Instance *) [ ("borrow", InstanceField.Method (borrow T A)) ].
  End Impl_core_borrow_Borrow_where_core_marker_Sized_T_where_core_alloc_Allocator_A_T_for_alloc_sync_Arc_T_A.
  
  Module Impl_core_convert_AsRef_where_core_marker_Sized_T_where_core_alloc_Allocator_A_T_for_alloc_sync_Arc_T_A.
    Definition Self (T A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; A ].
    
    (*
        fn as_ref(&self) -> &T {
            &**self
        }
    *)
    Definition as_ref (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.borrow (|
            Pointer.Kind.Ref,
            M.deref (|
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.call_closure (|
                    Ty.apply (Ty.path "&") [] [ T ],
                    M.get_trait_method (|
                      "core::ops::deref::Deref",
                      Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; A ],
                      [],
                      [],
                      "deref",
                      [],
                      []
                    |),
                    [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                  |)
                |)
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (T A : Ty.t),
      M.IsTraitInstance
        "core::convert::AsRef"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ T ]
        (Self T A)
        (* Instance *) [ ("as_ref", InstanceField.Method (as_ref T A)) ].
  End Impl_core_convert_AsRef_where_core_marker_Sized_T_where_core_alloc_Allocator_A_T_for_alloc_sync_Arc_T_A.
  
  Module Impl_core_marker_Unpin_where_core_marker_Sized_T_where_core_alloc_Allocator_A_for_alloc_sync_Arc_T_A.
    Definition Self (T A : Ty.t) : Ty.t := Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; A ].
    
    Axiom Implements :
      forall (T A : Ty.t),
      M.IsTraitInstance
        "core::marker::Unpin"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self T A)
        (* Instance *) [].
  End Impl_core_marker_Unpin_where_core_marker_Sized_T_where_core_alloc_Allocator_A_for_alloc_sync_Arc_T_A.
  
  (*
  unsafe fn data_offset<T: ?Sized>(ptr: *const T) -> usize {
      // Align the unsized value to the end of the ArcInner.
      // Because RcInner is repr(C), it will always be the last field in memory.
      // SAFETY: since the only unsized types possible are slices, trait objects,
      // and extern types, the input safety requirement is currently enough to
      // satisfy the requirements of align_of_val_raw; this is an implementation
      // detail of the language that must not be relied upon outside of std.
      unsafe { data_offset_align(align_of_val_raw(ptr)) }
  }
  *)
  Definition data_offset (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [ T ], [ ptr ] =>
      ltac:(M.monadic
        (let ptr := M.alloc (| ptr |) in
        M.call_closure (|
          Ty.path "usize",
          M.get_function (| "alloc::sync::data_offset_align", [], [] |),
          [
            M.call_closure (|
              Ty.path "usize",
              M.get_function (| "core::mem::align_of_val_raw", [], [ T ] |),
              [ M.read (| ptr |) ]
            |)
          ]
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_data_offset :
    M.IsFunction.C "alloc::sync::data_offset" data_offset.
  Admitted.
  Global Typeclasses Opaque data_offset.
  
  (*
  fn data_offset_align(align: usize) -> usize {
      let layout = Layout::new::<ArcInner<()>>();
      layout.size() + layout.padding_needed_for(align)
  }
  *)
  Definition data_offset_align (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ align ] =>
      ltac:(M.monadic
        (let align := M.alloc (| align |) in
        M.read (|
          let~ layout : Ty.apply (Ty.path "*") [] [ Ty.path "core::alloc::layout::Layout" ] :=
            M.alloc (|
              M.call_closure (|
                Ty.path "core::alloc::layout::Layout",
                M.get_associated_function (|
                  Ty.path "core::alloc::layout::Layout",
                  "new",
                  [],
                  [ Ty.apply (Ty.path "alloc::sync::ArcInner") [] [ Ty.tuple [] ] ]
                |),
                []
              |)
            |) in
          M.alloc (|
            M.call_closure (|
              Ty.path "usize",
              BinOp.Wrap.add,
              [
                M.call_closure (|
                  Ty.path "usize",
                  M.get_associated_function (|
                    Ty.path "core::alloc::layout::Layout",
                    "size",
                    [],
                    []
                  |),
                  [ M.borrow (| Pointer.Kind.Ref, layout |) ]
                |);
                M.call_closure (|
                  Ty.path "usize",
                  M.get_associated_function (|
                    Ty.path "core::alloc::layout::Layout",
                    "padding_needed_for",
                    [],
                    []
                  |),
                  [ M.borrow (| Pointer.Kind.Ref, layout |); M.read (| align |) ]
                |)
              ]
            |)
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_data_offset_align :
    M.IsFunction.C "alloc::sync::data_offset_align" data_offset_align.
  Admitted.
  Global Typeclasses Opaque data_offset_align.
  
  (* StructRecord
    {
      name := "UniqueArcUninit";
      const_params := [];
      ty_params := [ "T"; "A" ];
      fields :=
        [
          ("ptr",
            Ty.apply
              (Ty.path "core::ptr::non_null::NonNull")
              []
              [ Ty.apply (Ty.path "alloc::sync::ArcInner") [] [ T ] ]);
          ("layout_for_value", Ty.path "core::alloc::layout::Layout");
          ("alloc", Ty.apply (Ty.path "core::option::Option") [] [ A ])
        ];
    } *)
  
  Module Impl_alloc_sync_UniqueArcUninit_T_A.
    Definition Self (T A : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "alloc::sync::UniqueArcUninit") [] [ T; A ].
    
    (*
        fn new(for_value: &T, alloc: A) -> UniqueArcUninit<T, A> {
            let layout = Layout::for_value(for_value);
            let ptr = unsafe {
                Arc::allocate_for_layout(
                    layout,
                    |layout_for_arcinner| alloc.allocate(layout_for_arcinner),
                    |mem| mem.with_metadata_of(ptr::from_ref(for_value) as *const ArcInner<T>),
                )
            };
            Self { ptr: NonNull::new(ptr).unwrap(), layout_for_value: layout, alloc: Some(alloc) }
        }
    *)
    Definition new (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ for_value; alloc ] =>
        ltac:(M.monadic
          (let for_value := M.alloc (| for_value |) in
          let alloc := M.alloc (| alloc |) in
          M.read (|
            let~ layout : Ty.apply (Ty.path "*") [] [ Ty.path "core::alloc::layout::Layout" ] :=
              M.alloc (|
                M.call_closure (|
                  Ty.path "core::alloc::layout::Layout",
                  M.get_associated_function (|
                    Ty.path "core::alloc::layout::Layout",
                    "for_value",
                    [],
                    [ T ]
                  |),
                  [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| for_value |) |) |) ]
                |)
              |) in
            let~ ptr :
                Ty.apply
                  (Ty.path "*")
                  []
                  [
                    Ty.apply
                      (Ty.path "*mut")
                      []
                      [ Ty.apply (Ty.path "alloc::sync::ArcInner") [] [ T ] ]
                  ] :=
              M.alloc (|
                M.call_closure (|
                  Ty.apply
                    (Ty.path "*mut")
                    []
                    [ Ty.apply (Ty.path "alloc::sync::ArcInner") [] [ T ] ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; Ty.path "alloc::alloc::Global" ],
                    "allocate_for_layout",
                    [],
                    [
                      Ty.function
                        [ Ty.tuple [ Ty.path "core::alloc::layout::Layout" ] ]
                        (Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [
                            Ty.apply
                              (Ty.path "core::ptr::non_null::NonNull")
                              []
                              [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ];
                            Ty.path "core::alloc::AllocError"
                          ]);
                      Ty.function
                        [ Ty.tuple [ Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ] ] ]
                        (Ty.apply
                          (Ty.path "*mut")
                          []
                          [ Ty.apply (Ty.path "alloc::sync::ArcInner") [] [ T ] ])
                    ]
                  |),
                  [
                    M.read (| layout |);
                    M.closure
                      (fun γ =>
                        ltac:(M.monadic
                          match γ with
                          | [ α0 ] =>
                            ltac:(M.monadic
                              (M.match_operator (|
                                Ty.apply
                                  (Ty.path "*")
                                  []
                                  [
                                    Ty.function
                                      [ Ty.tuple [ Ty.path "core::alloc::layout::Layout" ] ]
                                      (Ty.apply
                                        (Ty.path "core::result::Result")
                                        []
                                        [
                                          Ty.apply
                                            (Ty.path "core::ptr::non_null::NonNull")
                                            []
                                            [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ];
                                          Ty.path "core::alloc::AllocError"
                                        ])
                                  ],
                                M.alloc (| α0 |),
                                [
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let layout_for_arcinner := M.copy (| γ |) in
                                      M.call_closure (|
                                        Ty.apply
                                          (Ty.path "core::result::Result")
                                          []
                                          [
                                            Ty.apply
                                              (Ty.path "core::ptr::non_null::NonNull")
                                              []
                                              [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ];
                                            Ty.path "core::alloc::AllocError"
                                          ],
                                        M.get_trait_method (|
                                          "core::alloc::Allocator",
                                          A,
                                          [],
                                          [],
                                          "allocate",
                                          [],
                                          []
                                        |),
                                        [
                                          M.borrow (| Pointer.Kind.Ref, alloc |);
                                          M.read (| layout_for_arcinner |)
                                        ]
                                      |)))
                                ]
                              |)))
                          | _ => M.impossible "wrong number of arguments"
                          end));
                    M.closure
                      (fun γ =>
                        ltac:(M.monadic
                          match γ with
                          | [ α0 ] =>
                            ltac:(M.monadic
                              (M.match_operator (|
                                Ty.apply
                                  (Ty.path "*")
                                  []
                                  [
                                    Ty.function
                                      [ Ty.tuple [ Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ] ] ]
                                      (Ty.apply
                                        (Ty.path "*mut")
                                        []
                                        [ Ty.apply (Ty.path "alloc::sync::ArcInner") [] [ T ] ])
                                  ],
                                M.alloc (| α0 |),
                                [
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let mem := M.copy (| γ |) in
                                      M.call_closure (|
                                        Ty.apply
                                          (Ty.path "*mut")
                                          []
                                          [ Ty.apply (Ty.path "alloc::sync::ArcInner") [] [ T ] ],
                                        M.get_associated_function (|
                                          Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ],
                                          "with_metadata_of",
                                          [],
                                          [ Ty.apply (Ty.path "alloc::sync::ArcInner") [] [ T ] ]
                                        |),
                                        [
                                          M.read (| mem |);
                                          M.cast
                                            (Ty.apply
                                              (Ty.path "*const")
                                              []
                                              [ Ty.apply (Ty.path "alloc::sync::ArcInner") [] [ T ]
                                              ])
                                            (M.call_closure (|
                                              Ty.apply (Ty.path "*const") [] [ T ],
                                              M.get_function (| "core::ptr::from_ref", [], [ T ] |),
                                              [
                                                M.borrow (|
                                                  Pointer.Kind.Ref,
                                                  M.deref (| M.read (| for_value |) |)
                                                |)
                                              ]
                                            |))
                                        ]
                                      |)))
                                ]
                              |)))
                          | _ => M.impossible "wrong number of arguments"
                          end))
                  ]
                |)
              |) in
            M.alloc (|
              Value.StructRecord
                "alloc::sync::UniqueArcUninit"
                [
                  ("ptr",
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "core::ptr::non_null::NonNull")
                        []
                        [ Ty.apply (Ty.path "alloc::sync::ArcInner") [] [ T ] ],
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "core::option::Option")
                          []
                          [
                            Ty.apply
                              (Ty.path "core::ptr::non_null::NonNull")
                              []
                              [ Ty.apply (Ty.path "alloc::sync::ArcInner") [] [ T ] ]
                          ],
                        "unwrap",
                        [],
                        []
                      |),
                      [
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "core::option::Option")
                            []
                            [
                              Ty.apply
                                (Ty.path "core::ptr::non_null::NonNull")
                                []
                                [ Ty.apply (Ty.path "alloc::sync::ArcInner") [] [ T ] ]
                            ],
                          M.get_associated_function (|
                            Ty.apply
                              (Ty.path "core::ptr::non_null::NonNull")
                              []
                              [ Ty.apply (Ty.path "alloc::sync::ArcInner") [] [ T ] ],
                            "new",
                            [],
                            []
                          |),
                          [ M.read (| ptr |) ]
                        |)
                      ]
                    |));
                  ("layout_for_value", M.read (| layout |));
                  ("alloc", Value.StructTuple "core::option::Option::Some" [ M.read (| alloc |) ])
                ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_new :
      forall (T A : Ty.t),
      M.IsAssociatedFunction.C (Self T A) "new" (new T A).
    Admitted.
    Global Typeclasses Opaque new.
    
    (*
        fn data_ptr(&mut self) -> *mut T {
            let offset = data_offset_align(self.layout_for_value.align());
            unsafe { self.ptr.as_ptr().byte_add(offset) as *mut T }
        }
    *)
    Definition data_ptr (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            let~ offset : Ty.apply (Ty.path "*") [] [ Ty.path "usize" ] :=
              M.alloc (|
                M.call_closure (|
                  Ty.path "usize",
                  M.get_function (| "alloc::sync::data_offset_align", [], [] |),
                  [
                    M.call_closure (|
                      Ty.path "usize",
                      M.get_associated_function (|
                        Ty.path "core::alloc::layout::Layout",
                        "align",
                        [],
                        []
                      |),
                      [
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "alloc::sync::UniqueArcUninit",
                            "layout_for_value"
                          |)
                        |)
                      ]
                    |)
                  ]
                |)
              |) in
            M.alloc (|
              M.cast
                (Ty.apply (Ty.path "*mut") [] [ T ])
                (M.call_closure (|
                  Ty.apply
                    (Ty.path "*mut")
                    []
                    [ Ty.apply (Ty.path "alloc::sync::ArcInner") [] [ T ] ],
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "*mut")
                      []
                      [ Ty.apply (Ty.path "alloc::sync::ArcInner") [] [ T ] ],
                    "byte_add",
                    [],
                    []
                  |),
                  [
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "*mut")
                        []
                        [ Ty.apply (Ty.path "alloc::sync::ArcInner") [] [ T ] ],
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "core::ptr::non_null::NonNull")
                          []
                          [ Ty.apply (Ty.path "alloc::sync::ArcInner") [] [ T ] ],
                        "as_ptr",
                        [],
                        []
                      |),
                      [
                        M.read (|
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "alloc::sync::UniqueArcUninit",
                            "ptr"
                          |)
                        |)
                      ]
                    |);
                    M.read (| offset |)
                  ]
                |))
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_data_ptr :
      forall (T A : Ty.t),
      M.IsAssociatedFunction.C (Self T A) "data_ptr" (data_ptr T A).
    Admitted.
    Global Typeclasses Opaque data_ptr.
    
    (*
        unsafe fn into_arc(self) -> Arc<T, A> {
            let mut this = ManuallyDrop::new(self);
            let ptr = this.ptr.as_ptr();
            let alloc = this.alloc.take().unwrap();
    
            // SAFETY: The pointer is valid as per `UniqueArcUninit::new`, and the caller is responsible
            // for having initialized the data.
            unsafe { Arc::from_ptr_in(ptr, alloc) }
        }
    *)
    Definition into_arc (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            let~ this :
                Ty.apply
                  (Ty.path "*")
                  []
                  [
                    Ty.apply
                      (Ty.path "core::mem::manually_drop::ManuallyDrop")
                      []
                      [ Ty.apply (Ty.path "alloc::sync::UniqueArcUninit") [] [ T; A ] ]
                  ] :=
              M.alloc (|
                M.call_closure (|
                  Ty.apply
                    (Ty.path "core::mem::manually_drop::ManuallyDrop")
                    []
                    [ Ty.apply (Ty.path "alloc::sync::UniqueArcUninit") [] [ T; A ] ],
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "core::mem::manually_drop::ManuallyDrop")
                      []
                      [ Ty.apply (Ty.path "alloc::sync::UniqueArcUninit") [] [ T; A ] ],
                    "new",
                    [],
                    []
                  |),
                  [ M.read (| self |) ]
                |)
              |) in
            let~ ptr :
                Ty.apply
                  (Ty.path "*")
                  []
                  [
                    Ty.apply
                      (Ty.path "*mut")
                      []
                      [ Ty.apply (Ty.path "alloc::sync::ArcInner") [] [ T ] ]
                  ] :=
              M.alloc (|
                M.call_closure (|
                  Ty.apply
                    (Ty.path "*mut")
                    []
                    [ Ty.apply (Ty.path "alloc::sync::ArcInner") [] [ T ] ],
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "core::ptr::non_null::NonNull")
                      []
                      [ Ty.apply (Ty.path "alloc::sync::ArcInner") [] [ T ] ],
                    "as_ptr",
                    [],
                    []
                  |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_record_field (|
                        M.deref (|
                          M.call_closure (|
                            Ty.apply
                              (Ty.path "&")
                              []
                              [ Ty.apply (Ty.path "alloc::sync::UniqueArcUninit") [] [ T; A ] ],
                            M.get_trait_method (|
                              "core::ops::deref::Deref",
                              Ty.apply
                                (Ty.path "core::mem::manually_drop::ManuallyDrop")
                                []
                                [ Ty.apply (Ty.path "alloc::sync::UniqueArcUninit") [] [ T; A ] ],
                              [],
                              [],
                              "deref",
                              [],
                              []
                            |),
                            [ M.borrow (| Pointer.Kind.Ref, this |) ]
                          |)
                        |),
                        "alloc::sync::UniqueArcUninit",
                        "ptr"
                      |)
                    |)
                  ]
                |)
              |) in
            let~ alloc : Ty.apply (Ty.path "*") [] [ A ] :=
              M.alloc (|
                M.call_closure (|
                  A,
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::option::Option") [] [ A ],
                    "unwrap",
                    [],
                    []
                  |),
                  [
                    M.call_closure (|
                      Ty.apply (Ty.path "core::option::Option") [] [ A ],
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::option::Option") [] [ A ],
                        "take",
                        [],
                        []
                      |),
                      [
                        M.borrow (|
                          Pointer.Kind.MutRef,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (|
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "&mut")
                                  []
                                  [ Ty.apply (Ty.path "alloc::sync::UniqueArcUninit") [] [ T; A ] ],
                                M.get_trait_method (|
                                  "core::ops::deref::DerefMut",
                                  Ty.apply
                                    (Ty.path "core::mem::manually_drop::ManuallyDrop")
                                    []
                                    [ Ty.apply (Ty.path "alloc::sync::UniqueArcUninit") [] [ T; A ]
                                    ],
                                  [],
                                  [],
                                  "deref_mut",
                                  [],
                                  []
                                |),
                                [ M.borrow (| Pointer.Kind.MutRef, this |) ]
                              |)
                            |),
                            "alloc::sync::UniqueArcUninit",
                            "alloc"
                          |)
                        |)
                      ]
                    |)
                  ]
                |)
              |) in
            M.alloc (|
              M.call_closure (|
                Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; A ],
                M.get_associated_function (|
                  Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; A ],
                  "from_ptr_in",
                  [],
                  []
                |),
                [ M.read (| ptr |); M.read (| alloc |) ]
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_into_arc :
      forall (T A : Ty.t),
      M.IsAssociatedFunction.C (Self T A) "into_arc" (into_arc T A).
    Admitted.
    Global Typeclasses Opaque into_arc.
  End Impl_alloc_sync_UniqueArcUninit_T_A.
  
  Module Impl_core_ops_drop_Drop_where_core_marker_Sized_T_where_core_alloc_Allocator_A_for_alloc_sync_UniqueArcUninit_T_A.
    Definition Self (T A : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "alloc::sync::UniqueArcUninit") [] [ T; A ].
    
    (*
        fn drop(&mut self) {
            // SAFETY:
            // * new() produced a pointer safe to deallocate.
            // * We own the pointer unless into_arc() was called, which forgets us.
            unsafe {
                self.alloc.take().unwrap().deallocate(
                    self.ptr.cast(),
                    arcinner_layout_for_value_layout(self.layout_for_value),
                );
            }
        }
    *)
    Definition drop (T A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T A in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
              M.alloc (|
                M.call_closure (|
                  Ty.tuple [],
                  M.get_trait_method (|
                    "core::alloc::Allocator",
                    A,
                    [],
                    [],
                    "deallocate",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.alloc (|
                        M.call_closure (|
                          A,
                          M.get_associated_function (|
                            Ty.apply (Ty.path "core::option::Option") [] [ A ],
                            "unwrap",
                            [],
                            []
                          |),
                          [
                            M.call_closure (|
                              Ty.apply (Ty.path "core::option::Option") [] [ A ],
                              M.get_associated_function (|
                                Ty.apply (Ty.path "core::option::Option") [] [ A ],
                                "take",
                                [],
                                []
                              |),
                              [
                                M.borrow (|
                                  Pointer.Kind.MutRef,
                                  M.SubPointer.get_struct_record_field (|
                                    M.deref (| M.read (| self |) |),
                                    "alloc::sync::UniqueArcUninit",
                                    "alloc"
                                  |)
                                |)
                              ]
                            |)
                          ]
                        |)
                      |)
                    |);
                    M.call_closure (|
                      Ty.apply (Ty.path "core::ptr::non_null::NonNull") [] [ Ty.path "u8" ],
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "core::ptr::non_null::NonNull")
                          []
                          [ Ty.apply (Ty.path "alloc::sync::ArcInner") [] [ T ] ],
                        "cast",
                        [],
                        [ Ty.path "u8" ]
                      |),
                      [
                        M.read (|
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "alloc::sync::UniqueArcUninit",
                            "ptr"
                          |)
                        |)
                      ]
                    |);
                    M.call_closure (|
                      Ty.path "core::alloc::layout::Layout",
                      M.get_function (| "alloc::sync::arcinner_layout_for_value_layout", [], [] |),
                      [
                        M.read (|
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "alloc::sync::UniqueArcUninit",
                            "layout_for_value"
                          |)
                        |)
                      ]
                    |)
                  ]
                |)
              |) in
            M.alloc (| Value.Tuple [] |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (T A : Ty.t),
      M.IsTraitInstance
        "core::ops::drop::Drop"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self T A)
        (* Instance *) [ ("drop", InstanceField.Method (drop T A)) ].
  End Impl_core_ops_drop_Drop_where_core_marker_Sized_T_where_core_alloc_Allocator_A_for_alloc_sync_UniqueArcUninit_T_A.
  
  Module Impl_core_error_Error_where_core_error_Error_T_where_core_marker_Sized_T_for_alloc_sync_Arc_T_alloc_alloc_Global.
    Definition Self (T : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "alloc::sync::Arc") [] [ T; Ty.path "alloc::alloc::Global" ].
    
    (*
        fn description(&self) -> &str {
            core::error::Error::description(&**self)
        }
    *)
    Definition description (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.borrow (|
            Pointer.Kind.Ref,
            M.deref (|
              M.call_closure (|
                Ty.apply (Ty.path "&") [] [ Ty.path "str" ],
                M.get_trait_method (| "core::error::Error", T, [], [], "description", [], [] |),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.deref (|
                          M.call_closure (|
                            Ty.apply (Ty.path "&") [] [ T ],
                            M.get_trait_method (|
                              "core::ops::deref::Deref",
                              Ty.apply
                                (Ty.path "alloc::sync::Arc")
                                []
                                [ T; Ty.path "alloc::alloc::Global" ],
                              [],
                              [],
                              "deref",
                              [],
                              []
                            |),
                            [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                          |)
                        |)
                      |)
                    |)
                  |)
                ]
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    (*
        fn cause(&self) -> Option<&dyn core::error::Error> {
            core::error::Error::cause(&**self)
        }
    *)
    Definition cause (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "core::option::Option")
              []
              [ Ty.apply (Ty.path "&") [] [ Ty.dyn [ ("core::error::Error::Trait", []) ] ] ],
            M.get_trait_method (| "core::error::Error", T, [], [], "cause", [], [] |),
            [
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.call_closure (|
                        Ty.apply (Ty.path "&") [] [ T ],
                        M.get_trait_method (|
                          "core::ops::deref::Deref",
                          Ty.apply
                            (Ty.path "alloc::sync::Arc")
                            []
                            [ T; Ty.path "alloc::alloc::Global" ],
                          [],
                          [],
                          "deref",
                          [],
                          []
                        |),
                        [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                      |)
                    |)
                  |)
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    (*
        fn source(&self) -> Option<&(dyn core::error::Error + 'static)> {
            core::error::Error::source(&**self)
        }
    *)
    Definition source (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "core::option::Option")
              []
              [ Ty.apply (Ty.path "&") [] [ Ty.dyn [ ("core::error::Error::Trait", []) ] ] ],
            M.get_trait_method (| "core::error::Error", T, [], [], "source", [], [] |),
            [
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.call_closure (|
                        Ty.apply (Ty.path "&") [] [ T ],
                        M.get_trait_method (|
                          "core::ops::deref::Deref",
                          Ty.apply
                            (Ty.path "alloc::sync::Arc")
                            []
                            [ T; Ty.path "alloc::alloc::Global" ],
                          [],
                          [],
                          "deref",
                          [],
                          []
                        |),
                        [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                      |)
                    |)
                  |)
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    (*
        fn provide<'a>(&'a self, req: &mut core::error::Request<'a>) {
            core::error::Error::provide(&**self, req);
        }
    *)
    Definition provide (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [], [ self; req ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let req := M.alloc (| req |) in
          M.read (|
            let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
              M.alloc (|
                M.call_closure (|
                  Ty.tuple [],
                  M.get_trait_method (| "core::error::Error", T, [], [], "provide", [], [] |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.deref (|
                            M.call_closure (|
                              Ty.apply (Ty.path "&") [] [ T ],
                              M.get_trait_method (|
                                "core::ops::deref::Deref",
                                Ty.apply
                                  (Ty.path "alloc::sync::Arc")
                                  []
                                  [ T; Ty.path "alloc::alloc::Global" ],
                                [],
                                [],
                                "deref",
                                [],
                                []
                              |),
                              [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                            |)
                          |)
                        |)
                      |)
                    |);
                    M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| req |) |) |)
                  ]
                |)
              |) in
            M.alloc (| Value.Tuple [] |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "core::error::Error"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self T)
        (* Instance *)
        [
          ("description", InstanceField.Method (description T));
          ("cause", InstanceField.Method (cause T));
          ("source", InstanceField.Method (source T));
          ("provide", InstanceField.Method (provide T))
        ].
  End Impl_core_error_Error_where_core_error_Error_T_where_core_marker_Sized_T_for_alloc_sync_Arc_T_alloc_alloc_Global.
End sync.
