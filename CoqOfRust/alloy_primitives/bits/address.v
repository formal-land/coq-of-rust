(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module bits.
  Module address.
    (*
    Enum AddressError
    {
      const_params := [];
      ty_params := [];
      variants :=
        [
          {
            name := "Hex";
            item := StructTuple [ Ty.path "const_hex::error::FromHexError" ];
          };
          {
            name := "InvalidChecksum";
            item := StructTuple [];
          }
        ];
    }
    *)
    
    Axiom IsDiscriminant_AddressError_Hex :
      M.IsDiscriminant "alloy_primitives::bits::address::AddressError::Hex" 0.
    Axiom IsDiscriminant_AddressError_InvalidChecksum :
      M.IsDiscriminant "alloy_primitives::bits::address::AddressError::InvalidChecksum" 1.
    
    Module Impl_core_clone_Clone_for_alloy_primitives_bits_address_AddressError.
      Definition Self : Ty.t := Ty.path "alloy_primitives::bits::address::AddressError".
      
      (* Clone *)
      Definition clone (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply
                  (Ty.path "&")
                  []
                  [ Ty.path "alloy_primitives::bits::address::AddressError" ],
                self
              |) in
            M.read (|
              M.match_operator (|
                Ty.path "alloy_primitives::bits::address::AddressError",
                Value.DeclaredButUndefined,
                [ fun γ => ltac:(M.monadic (M.deref (| M.read (| self |) |))) ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::clone::Clone"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [ ("clone", InstanceField.Method clone) ].
    End Impl_core_clone_Clone_for_alloy_primitives_bits_address_AddressError.
    
    Module Impl_core_marker_Copy_for_alloy_primitives_bits_address_AddressError.
      Definition Self : Ty.t := Ty.path "alloy_primitives::bits::address::AddressError".
      
      Axiom Implements :
        M.IsTraitInstance
          "core::marker::Copy"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [].
    End Impl_core_marker_Copy_for_alloy_primitives_bits_address_AddressError.
    
    Module Impl_core_fmt_Debug_for_alloy_primitives_bits_address_AddressError.
      Definition Self : Ty.t := Ty.path "alloy_primitives::bits::address::AddressError".
      
      (* Debug *)
      Definition fmt (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; f ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply
                  (Ty.path "&")
                  []
                  [ Ty.path "alloy_primitives::bits::address::AddressError" ],
                self
              |) in
            let f :=
              M.alloc (| Ty.apply (Ty.path "&mut") [] [ Ty.path "core::fmt::Formatter" ], f |) in
            M.read (|
              M.match_operator (|
                Ty.apply
                  (Ty.path "core::result::Result")
                  []
                  [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                self,
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.read (| γ |) in
                      let γ1_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "alloy_primitives::bits::address::AddressError::Hex",
                          0
                        |) in
                      let __self_0 :=
                        M.alloc (|
                          Ty.apply (Ty.path "&") [] [ Ty.path "const_hex::error::FromHexError" ],
                          γ1_0
                        |) in
                      M.alloc (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "core::result::Result")
                            []
                            [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                          M.get_associated_function (|
                            Ty.path "core::fmt::Formatter",
                            "debug_tuple_field1_finish",
                            [],
                            []
                          |),
                          [
                            M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                            M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "Hex" |) |) |);
                            (* Unsize *)
                            M.pointer_coercion
                              (M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (| M.borrow (| Pointer.Kind.Ref, __self_0 |) |)
                              |))
                          ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.read (| γ |) in
                      let _ :=
                        M.is_struct_tuple (|
                          γ,
                          "alloy_primitives::bits::address::AddressError::InvalidChecksum"
                        |) in
                      M.alloc (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "core::result::Result")
                            []
                            [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                          M.get_associated_function (|
                            Ty.path "core::fmt::Formatter",
                            "write_str",
                            [],
                            []
                          |),
                          [
                            M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.deref (| mk_str (| "InvalidChecksum" |) |)
                            |)
                          ]
                        |)
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::Debug"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
    End Impl_core_fmt_Debug_for_alloy_primitives_bits_address_AddressError.
    
    Module Impl_core_convert_From_const_hex_error_FromHexError_for_alloy_primitives_bits_address_AddressError.
      Definition Self : Ty.t := Ty.path "alloy_primitives::bits::address::AddressError".
      
      (*
          fn from(value: hex::FromHexError) -> Self {
              Self::Hex(value)
          }
      *)
      Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| Ty.path "const_hex::error::FromHexError", value |) in
            Value.StructTuple
              "alloy_primitives::bits::address::AddressError::Hex"
              []
              []
              [ M.read (| value |) ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "const_hex::error::FromHexError" ]
          Self
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_const_hex_error_FromHexError_for_alloy_primitives_bits_address_AddressError.
    
    Module Impl_core_error_Error_for_alloy_primitives_bits_address_AddressError.
      Definition Self : Ty.t := Ty.path "alloy_primitives::bits::address::AddressError".
      
      (*
          fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
              match self {
                  Self::Hex(err) => Some(err),
                  Self::InvalidChecksum => None,
              }
          }
      *)
      Definition source (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply
                  (Ty.path "&")
                  []
                  [ Ty.path "alloy_primitives::bits::address::AddressError" ],
                self
              |) in
            M.read (|
              M.match_operator (|
                Ty.apply
                  (Ty.path "core::option::Option")
                  []
                  [ Ty.apply (Ty.path "&") [] [ Ty.dyn [ ("core::error::Error::Trait", []) ] ] ],
                self,
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.read (| γ |) in
                      let γ1_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "alloy_primitives::bits::address::AddressError::Hex",
                          0
                        |) in
                      let err :=
                        M.alloc (|
                          Ty.apply (Ty.path "&") [] [ Ty.path "const_hex::error::FromHexError" ],
                          γ1_0
                        |) in
                      M.alloc (|
                        Ty.apply
                          (Ty.path "core::option::Option")
                          []
                          [
                            Ty.apply
                              (Ty.path "&")
                              []
                              [ Ty.dyn [ ("core::error::Error::Trait", []) ] ]
                          ],
                        Value.StructTuple
                          "core::option::Option::Some"
                          []
                          [
                            Ty.apply
                              (Ty.path "&")
                              []
                              [ Ty.dyn [ ("core::error::Error::Trait", []) ] ]
                          ]
                          [
                            (* Unsize *)
                            M.pointer_coercion
                              (M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| err |) |) |))
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.read (| γ |) in
                      let _ :=
                        M.is_struct_tuple (|
                          γ,
                          "alloy_primitives::bits::address::AddressError::InvalidChecksum"
                        |) in
                      M.alloc (|
                        Ty.apply
                          (Ty.path "core::option::Option")
                          []
                          [
                            Ty.apply
                              (Ty.path "&")
                              []
                              [ Ty.dyn [ ("core::error::Error::Trait", []) ] ]
                          ],
                        Value.StructTuple
                          "core::option::Option::None"
                          []
                          [
                            Ty.apply
                              (Ty.path "&")
                              []
                              [ Ty.dyn [ ("core::error::Error::Trait", []) ] ]
                          ]
                          []
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::error::Error"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [ ("source", InstanceField.Method source) ].
    End Impl_core_error_Error_for_alloy_primitives_bits_address_AddressError.
    
    Module Impl_core_fmt_Display_for_alloy_primitives_bits_address_AddressError.
      Definition Self : Ty.t := Ty.path "alloy_primitives::bits::address::AddressError".
      
      (*
          fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
              match self {
                  Self::Hex(err) => err.fmt(f),
                  Self::InvalidChecksum => f.write_str("Bad address checksum"),
              }
          }
      *)
      Definition fmt (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; f ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply
                  (Ty.path "&")
                  []
                  [ Ty.path "alloy_primitives::bits::address::AddressError" ],
                self
              |) in
            let f :=
              M.alloc (| Ty.apply (Ty.path "&mut") [] [ Ty.path "core::fmt::Formatter" ], f |) in
            M.read (|
              M.match_operator (|
                Ty.apply
                  (Ty.path "core::result::Result")
                  []
                  [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                self,
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.read (| γ |) in
                      let γ1_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "alloy_primitives::bits::address::AddressError::Hex",
                          0
                        |) in
                      let err :=
                        M.alloc (|
                          Ty.apply (Ty.path "&") [] [ Ty.path "const_hex::error::FromHexError" ],
                          γ1_0
                        |) in
                      M.alloc (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "core::result::Result")
                            []
                            [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                          M.get_trait_method (|
                            "core::fmt::Display",
                            Ty.path "const_hex::error::FromHexError",
                            [],
                            [],
                            "fmt",
                            [],
                            []
                          |),
                          [
                            M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| err |) |) |);
                            M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |)
                          ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.read (| γ |) in
                      let _ :=
                        M.is_struct_tuple (|
                          γ,
                          "alloy_primitives::bits::address::AddressError::InvalidChecksum"
                        |) in
                      M.alloc (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "core::result::Result")
                            []
                            [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                          M.get_associated_function (|
                            Ty.path "core::fmt::Formatter",
                            "write_str",
                            [],
                            []
                          |),
                          [
                            M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.deref (| mk_str (| "Bad address checksum" |) |)
                            |)
                          ]
                        |)
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::Display"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
    End Impl_core_fmt_Display_for_alloy_primitives_bits_address_AddressError.
    
    Module Impl_core_convert_From_ruint_Uint_Usize_160_Usize_3_for_alloy_primitives_bits_address_Address.
      Definition Self : Ty.t := Ty.path "alloy_primitives::bits::address::Address".
      
      (*
          fn from(value: U160) -> Self {
              Self(FixedBytes(value.to_be_bytes()))
          }
      *)
      Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value :=
              M.alloc (|
                Ty.apply
                  (Ty.path "ruint::Uint")
                  [ Value.Integer IntegerKind.Usize 160; Value.Integer IntegerKind.Usize 3 ]
                  [],
                value
              |) in
            Value.StructTuple
              "alloy_primitives::bits::address::Address"
              []
              []
              [
                Value.StructTuple
                  "alloy_primitives::bits::fixed::FixedBytes"
                  [ Value.Integer IntegerKind.Usize 20 ]
                  []
                  [
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "array")
                        [ Value.Integer IntegerKind.Usize 20 ]
                        [ Ty.path "u8" ],
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "ruint::Uint")
                          [ Value.Integer IntegerKind.Usize 160; Value.Integer IntegerKind.Usize 3 ]
                          [],
                        "to_be_bytes",
                        [ Value.Integer IntegerKind.Usize 20 ],
                        []
                      |),
                      [ M.borrow (| Pointer.Kind.Ref, value |) ]
                    |)
                  ]
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [
            Ty.apply
              (Ty.path "ruint::Uint")
              [ Value.Integer IntegerKind.Usize 160; Value.Integer IntegerKind.Usize 3 ]
              []
          ]
          Self
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_ruint_Uint_Usize_160_Usize_3_for_alloy_primitives_bits_address_Address.
    
    Module Impl_core_convert_From_alloy_primitives_bits_address_Address_for_ruint_Uint_Usize_160_Usize_3.
      Definition Self : Ty.t :=
        Ty.apply
          (Ty.path "ruint::Uint")
          [ Value.Integer IntegerKind.Usize 160; Value.Integer IntegerKind.Usize 3 ]
          [].
      
      (*
          fn from(value: Address) -> Self {
              Self::from_be_bytes(value.0 .0)
          }
      *)
      Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| Ty.path "alloy_primitives::bits::address::Address", value |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "ruint::Uint")
                [ Value.Integer IntegerKind.Usize 160; Value.Integer IntegerKind.Usize 3 ]
                [],
              M.get_associated_function (|
                Ty.apply
                  (Ty.path "ruint::Uint")
                  [ Value.Integer IntegerKind.Usize 160; Value.Integer IntegerKind.Usize 3 ]
                  [],
                "from_be_bytes",
                [ Value.Integer IntegerKind.Usize 20 ],
                []
              |),
              [
                M.read (|
                  M.SubPointer.get_struct_tuple_field (|
                    M.SubPointer.get_struct_tuple_field (|
                      value,
                      "alloy_primitives::bits::address::Address",
                      0
                    |),
                    "alloy_primitives::bits::fixed::FixedBytes",
                    0
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "alloy_primitives::bits::address::Address" ]
          Self
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_alloy_primitives_bits_address_Address_for_ruint_Uint_Usize_160_Usize_3.
    
    Module Impl_core_fmt_Display_for_alloy_primitives_bits_address_Address.
      Definition Self : Ty.t := Ty.path "alloy_primitives::bits::address::Address".
      
      (*
          fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
              let checksum = self.to_checksum_buffer(None);
              let checksum = checksum.as_str();
              if f.alternate() {
                  // If the alternate flag is set, use middle-out compression
                  // "0x" + first 4 bytes + "…" + last 4 bytes
                  f.write_str(&checksum[..6])?;
                  f.write_str("…")?;
                  f.write_str(&checksum[38..])
              } else {
                  f.write_str(checksum)
              }
          }
      *)
      Definition fmt (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; f ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply (Ty.path "&") [] [ Ty.path "alloy_primitives::bits::address::Address" ],
                self
              |) in
            let f :=
              M.alloc (| Ty.apply (Ty.path "&mut") [] [ Ty.path "core::fmt::Formatter" ], f |) in
            M.read (|
              M.catch_return
                (Ty.apply
                  (Ty.path "core::result::Result")
                  []
                  [ Ty.tuple []; Ty.path "core::fmt::Error" ]) (|
                ltac:(M.monadic
                  (M.alloc (|
                    Ty.apply
                      (Ty.path "core::result::Result")
                      []
                      [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                    M.read (|
                      let~ checksum :
                          Ty.path "alloy_primitives::bits::address::AddressChecksumBuffer" :=
                        M.call_closure (|
                          Ty.path "alloy_primitives::bits::address::AddressChecksumBuffer",
                          M.get_associated_function (|
                            Ty.path "alloy_primitives::bits::address::Address",
                            "to_checksum_buffer",
                            [],
                            []
                          |),
                          [
                            M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |);
                            Value.StructTuple "core::option::Option::None" [] [ Ty.path "u64" ] []
                          ]
                        |) in
                      let~ checksum : Ty.apply (Ty.path "&") [] [ Ty.path "str" ] :=
                        M.call_closure (|
                          Ty.apply (Ty.path "&") [] [ Ty.path "str" ],
                          M.get_associated_function (|
                            Ty.path "alloy_primitives::bits::address::AddressChecksumBuffer",
                            "as_str",
                            [],
                            []
                          |),
                          [ M.borrow (| Pointer.Kind.Ref, checksum |) ]
                        |) in
                      M.match_operator (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.alloc (| Ty.tuple [], Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.use
                                  (M.alloc (|
                                    Ty.path "bool",
                                    M.call_closure (|
                                      Ty.path "bool",
                                      M.get_associated_function (|
                                        Ty.path "core::fmt::Formatter",
                                        "alternate",
                                        [],
                                        []
                                      |),
                                      [
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.deref (| M.read (| f |) |)
                                        |)
                                      ]
                                    |)
                                  |)) in
                              let _ :=
                                is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                              let~ _ : Ty.tuple [] :=
                                M.read (|
                                  M.match_operator (|
                                    Ty.tuple [],
                                    M.alloc (|
                                      Ty.apply
                                        (Ty.path "core::ops::control_flow::ControlFlow")
                                        []
                                        [
                                          Ty.apply
                                            (Ty.path "core::result::Result")
                                            []
                                            [
                                              Ty.path "core::convert::Infallible";
                                              Ty.path "core::fmt::Error"
                                            ];
                                          Ty.tuple []
                                        ],
                                      M.call_closure (|
                                        Ty.apply
                                          (Ty.path "core::ops::control_flow::ControlFlow")
                                          []
                                          [
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              []
                                              [
                                                Ty.path "core::convert::Infallible";
                                                Ty.path "core::fmt::Error"
                                              ];
                                            Ty.tuple []
                                          ],
                                        M.get_trait_method (|
                                          "core::ops::try_trait::Try",
                                          Ty.apply
                                            (Ty.path "core::result::Result")
                                            []
                                            [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                                          [],
                                          [],
                                          "branch",
                                          [],
                                          []
                                        |),
                                        [
                                          M.call_closure (|
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              []
                                              [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                                            M.get_associated_function (|
                                              Ty.path "core::fmt::Formatter",
                                              "write_str",
                                              [],
                                              []
                                            |),
                                            [
                                              M.borrow (|
                                                Pointer.Kind.MutRef,
                                                M.deref (| M.read (| f |) |)
                                              |);
                                              M.borrow (|
                                                Pointer.Kind.Ref,
                                                M.deref (|
                                                  M.borrow (|
                                                    Pointer.Kind.Ref,
                                                    M.deref (|
                                                      M.call_closure (|
                                                        Ty.apply (Ty.path "&") [] [ Ty.path "str" ],
                                                        M.get_trait_method (|
                                                          "core::ops::index::Index",
                                                          Ty.path "str",
                                                          [],
                                                          [
                                                            Ty.apply
                                                              (Ty.path "core::ops::range::RangeTo")
                                                              []
                                                              [ Ty.path "usize" ]
                                                          ],
                                                          "index",
                                                          [],
                                                          []
                                                        |),
                                                        [
                                                          M.borrow (|
                                                            Pointer.Kind.Ref,
                                                            M.deref (| M.read (| checksum |) |)
                                                          |);
                                                          Value.mkStructRecord
                                                            "core::ops::range::RangeTo"
                                                            []
                                                            [ Ty.path "usize" ]
                                                            [
                                                              ("end_",
                                                                Value.Integer IntegerKind.Usize 6)
                                                            ]
                                                        ]
                                                      |)
                                                    |)
                                                  |)
                                                |)
                                              |)
                                            ]
                                          |)
                                        ]
                                      |)
                                    |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let γ0_0 :=
                                            M.SubPointer.get_struct_tuple_field (|
                                              γ,
                                              "core::ops::control_flow::ControlFlow::Break",
                                              0
                                            |) in
                                          let residual :=
                                            M.copy (|
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                []
                                                [
                                                  Ty.path "core::convert::Infallible";
                                                  Ty.path "core::fmt::Error"
                                                ],
                                              γ0_0
                                            |) in
                                          M.alloc (|
                                            Ty.tuple [],
                                            M.never_to_any (|
                                              M.read (|
                                                M.return_ (|
                                                  M.call_closure (|
                                                    Ty.apply
                                                      (Ty.path "core::result::Result")
                                                      []
                                                      [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                                                    M.get_trait_method (|
                                                      "core::ops::try_trait::FromResidual",
                                                      Ty.apply
                                                        (Ty.path "core::result::Result")
                                                        []
                                                        [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                                                      [],
                                                      [
                                                        Ty.apply
                                                          (Ty.path "core::result::Result")
                                                          []
                                                          [
                                                            Ty.path "core::convert::Infallible";
                                                            Ty.path "core::fmt::Error"
                                                          ]
                                                      ],
                                                      "from_residual",
                                                      [],
                                                      []
                                                    |),
                                                    [ M.read (| residual |) ]
                                                  |)
                                                |)
                                              |)
                                            |)
                                          |)));
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let γ0_0 :=
                                            M.SubPointer.get_struct_tuple_field (|
                                              γ,
                                              "core::ops::control_flow::ControlFlow::Continue",
                                              0
                                            |) in
                                          let val := M.copy (| Ty.tuple [], γ0_0 |) in
                                          val))
                                    ]
                                  |)
                                |) in
                              let~ _ : Ty.tuple [] :=
                                M.read (|
                                  M.match_operator (|
                                    Ty.tuple [],
                                    M.alloc (|
                                      Ty.apply
                                        (Ty.path "core::ops::control_flow::ControlFlow")
                                        []
                                        [
                                          Ty.apply
                                            (Ty.path "core::result::Result")
                                            []
                                            [
                                              Ty.path "core::convert::Infallible";
                                              Ty.path "core::fmt::Error"
                                            ];
                                          Ty.tuple []
                                        ],
                                      M.call_closure (|
                                        Ty.apply
                                          (Ty.path "core::ops::control_flow::ControlFlow")
                                          []
                                          [
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              []
                                              [
                                                Ty.path "core::convert::Infallible";
                                                Ty.path "core::fmt::Error"
                                              ];
                                            Ty.tuple []
                                          ],
                                        M.get_trait_method (|
                                          "core::ops::try_trait::Try",
                                          Ty.apply
                                            (Ty.path "core::result::Result")
                                            []
                                            [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                                          [],
                                          [],
                                          "branch",
                                          [],
                                          []
                                        |),
                                        [
                                          M.call_closure (|
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              []
                                              [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                                            M.get_associated_function (|
                                              Ty.path "core::fmt::Formatter",
                                              "write_str",
                                              [],
                                              []
                                            |),
                                            [
                                              M.borrow (|
                                                Pointer.Kind.MutRef,
                                                M.deref (| M.read (| f |) |)
                                              |);
                                              M.borrow (|
                                                Pointer.Kind.Ref,
                                                M.deref (|
                                                  mk_str (|
                                                    PrimString.cat
                                                      (PrimString.make 1 (8230%int63))
                                                      ""
                                                  |)
                                                |)
                                              |)
                                            ]
                                          |)
                                        ]
                                      |)
                                    |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let γ0_0 :=
                                            M.SubPointer.get_struct_tuple_field (|
                                              γ,
                                              "core::ops::control_flow::ControlFlow::Break",
                                              0
                                            |) in
                                          let residual :=
                                            M.copy (|
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                []
                                                [
                                                  Ty.path "core::convert::Infallible";
                                                  Ty.path "core::fmt::Error"
                                                ],
                                              γ0_0
                                            |) in
                                          M.alloc (|
                                            Ty.tuple [],
                                            M.never_to_any (|
                                              M.read (|
                                                M.return_ (|
                                                  M.call_closure (|
                                                    Ty.apply
                                                      (Ty.path "core::result::Result")
                                                      []
                                                      [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                                                    M.get_trait_method (|
                                                      "core::ops::try_trait::FromResidual",
                                                      Ty.apply
                                                        (Ty.path "core::result::Result")
                                                        []
                                                        [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                                                      [],
                                                      [
                                                        Ty.apply
                                                          (Ty.path "core::result::Result")
                                                          []
                                                          [
                                                            Ty.path "core::convert::Infallible";
                                                            Ty.path "core::fmt::Error"
                                                          ]
                                                      ],
                                                      "from_residual",
                                                      [],
                                                      []
                                                    |),
                                                    [ M.read (| residual |) ]
                                                  |)
                                                |)
                                              |)
                                            |)
                                          |)));
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let γ0_0 :=
                                            M.SubPointer.get_struct_tuple_field (|
                                              γ,
                                              "core::ops::control_flow::ControlFlow::Continue",
                                              0
                                            |) in
                                          let val := M.copy (| Ty.tuple [], γ0_0 |) in
                                          val))
                                    ]
                                  |)
                                |) in
                              M.alloc (|
                                Ty.apply
                                  (Ty.path "core::result::Result")
                                  []
                                  [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                                M.call_closure (|
                                  Ty.apply
                                    (Ty.path "core::result::Result")
                                    []
                                    [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                                  M.get_associated_function (|
                                    Ty.path "core::fmt::Formatter",
                                    "write_str",
                                    [],
                                    []
                                  |),
                                  [
                                    M.borrow (|
                                      Pointer.Kind.MutRef,
                                      M.deref (| M.read (| f |) |)
                                    |);
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.deref (|
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.deref (|
                                            M.call_closure (|
                                              Ty.apply (Ty.path "&") [] [ Ty.path "str" ],
                                              M.get_trait_method (|
                                                "core::ops::index::Index",
                                                Ty.path "str",
                                                [],
                                                [
                                                  Ty.apply
                                                    (Ty.path "core::ops::range::RangeFrom")
                                                    []
                                                    [ Ty.path "usize" ]
                                                ],
                                                "index",
                                                [],
                                                []
                                              |),
                                              [
                                                M.borrow (|
                                                  Pointer.Kind.Ref,
                                                  M.deref (| M.read (| checksum |) |)
                                                |);
                                                Value.mkStructRecord
                                                  "core::ops::range::RangeFrom"
                                                  []
                                                  [ Ty.path "usize" ]
                                                  [ ("start", Value.Integer IntegerKind.Usize 38) ]
                                              ]
                                            |)
                                          |)
                                        |)
                                      |)
                                    |)
                                  ]
                                |)
                              |)));
                          fun γ =>
                            ltac:(M.monadic
                              (M.alloc (|
                                Ty.apply
                                  (Ty.path "core::result::Result")
                                  []
                                  [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                                M.call_closure (|
                                  Ty.apply
                                    (Ty.path "core::result::Result")
                                    []
                                    [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                                  M.get_associated_function (|
                                    Ty.path "core::fmt::Formatter",
                                    "write_str",
                                    [],
                                    []
                                  |),
                                  [
                                    M.borrow (|
                                      Pointer.Kind.MutRef,
                                      M.deref (| M.read (| f |) |)
                                    |);
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.deref (| M.read (| checksum |) |)
                                    |)
                                  ]
                                |)
                              |)))
                        ]
                      |)
                    |)
                  |)))
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::Display"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
    End Impl_core_fmt_Display_for_alloy_primitives_bits_address_Address.
    
    Module Impl_alloy_primitives_bits_address_Address.
      Definition Self : Ty.t := Ty.path "alloy_primitives::bits::address::Address".
      
      (*
          pub fn from_word(word: FixedBytes<32>) -> Self {
              Self(FixedBytes(word[12..].try_into().unwrap()))
          }
      *)
      Definition from_word (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ word ] =>
          ltac:(M.monadic
            (let word :=
              M.alloc (|
                Ty.apply
                  (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                  [ Value.Integer IntegerKind.Usize 32 ]
                  [],
                word
              |) in
            Value.StructTuple
              "alloy_primitives::bits::address::Address"
              []
              []
              [
                Value.StructTuple
                  "alloy_primitives::bits::fixed::FixedBytes"
                  [ Value.Integer IntegerKind.Usize 20 ]
                  []
                  [
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "array")
                        [ Value.Integer IntegerKind.Usize 20 ]
                        [ Ty.path "u8" ],
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [
                            Ty.apply
                              (Ty.path "array")
                              [ Value.Integer IntegerKind.Usize 20 ]
                              [ Ty.path "u8" ];
                            Ty.path "core::array::TryFromSliceError"
                          ],
                        "unwrap",
                        [],
                        []
                      |),
                      [
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "core::result::Result")
                            []
                            [
                              Ty.apply
                                (Ty.path "array")
                                [ Value.Integer IntegerKind.Usize 20 ]
                                [ Ty.path "u8" ];
                              Ty.path "core::array::TryFromSliceError"
                            ],
                          M.get_trait_method (|
                            "core::convert::TryInto",
                            Ty.apply
                              (Ty.path "&")
                              []
                              [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                            [],
                            [
                              Ty.apply
                                (Ty.path "array")
                                [ Value.Integer IntegerKind.Usize 20 ]
                                [ Ty.path "u8" ]
                            ],
                            "try_into",
                            [],
                            []
                          |),
                          [
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.deref (|
                                M.call_closure (|
                                  Ty.apply
                                    (Ty.path "&")
                                    []
                                    [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                                  M.get_trait_method (|
                                    "core::ops::index::Index",
                                    Ty.apply
                                      (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                                      [ Value.Integer IntegerKind.Usize 32 ]
                                      [],
                                    [],
                                    [
                                      Ty.apply
                                        (Ty.path "core::ops::range::RangeFrom")
                                        []
                                        [ Ty.path "usize" ]
                                    ],
                                    "index",
                                    [],
                                    []
                                  |),
                                  [
                                    M.borrow (| Pointer.Kind.Ref, word |);
                                    Value.mkStructRecord
                                      "core::ops::range::RangeFrom"
                                      []
                                      [ Ty.path "usize" ]
                                      [ ("start", Value.Integer IntegerKind.Usize 12) ]
                                  ]
                                |)
                              |)
                            |)
                          ]
                        |)
                      ]
                    |)
                  ]
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_from_word :
        M.IsAssociatedFunction.C Self "from_word" from_word.
      Admitted.
      Global Typeclasses Opaque from_word.
      
      (*
          pub fn into_word(&self) -> FixedBytes<32> {
              let mut word = [0; 32];
              word[12..].copy_from_slice(self.as_slice());
              FixedBytes(word)
          }
      *)
      Definition into_word (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply (Ty.path "&") [] [ Ty.path "alloy_primitives::bits::address::Address" ],
                self
              |) in
            M.read (|
              let~ word :
                  Ty.apply
                    (Ty.path "array")
                    [ Value.Integer IntegerKind.Usize 32 ]
                    [ Ty.path "u8" ] :=
                lib.repeat (|
                  Value.Integer IntegerKind.U8 0,
                  Value.Integer IntegerKind.Usize 32
                |) in
              let~ _ : Ty.tuple [] :=
                M.call_closure (|
                  Ty.tuple [],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                    "copy_from_slice",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.MutRef,
                      M.deref (|
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "&mut")
                            []
                            [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                          M.get_trait_method (|
                            "core::ops::index::IndexMut",
                            Ty.apply
                              (Ty.path "array")
                              [ Value.Integer IntegerKind.Usize 32 ]
                              [ Ty.path "u8" ],
                            [],
                            [
                              Ty.apply
                                (Ty.path "core::ops::range::RangeFrom")
                                []
                                [ Ty.path "usize" ]
                            ],
                            "index_mut",
                            [],
                            []
                          |),
                          [
                            M.borrow (| Pointer.Kind.MutRef, word |);
                            Value.mkStructRecord
                              "core::ops::range::RangeFrom"
                              []
                              [ Ty.path "usize" ]
                              [ ("start", Value.Integer IntegerKind.Usize 12) ]
                          ]
                        |)
                      |)
                    |);
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "&")
                            []
                            [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                          M.get_associated_function (|
                            Ty.apply
                              (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                              [ Value.Integer IntegerKind.Usize 20 ]
                              [],
                            "as_slice",
                            [],
                            []
                          |),
                          [
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.deref (|
                                M.call_closure (|
                                  Ty.apply
                                    (Ty.path "&")
                                    []
                                    [
                                      Ty.apply
                                        (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                                        [ Value.Integer IntegerKind.Usize 20 ]
                                        []
                                    ],
                                  M.get_trait_method (|
                                    "core::ops::deref::Deref",
                                    Ty.path "alloy_primitives::bits::address::Address",
                                    [],
                                    [],
                                    "deref",
                                    [],
                                    []
                                  |),
                                  [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |)
                                  ]
                                |)
                              |)
                            |)
                          ]
                        |)
                      |)
                    |)
                  ]
                |) in
              M.alloc (|
                Ty.apply
                  (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                  [ Value.Integer IntegerKind.Usize 32 ]
                  [],
                Value.StructTuple
                  "alloy_primitives::bits::fixed::FixedBytes"
                  [ Value.Integer IntegerKind.Usize 32 ]
                  []
                  [ M.read (| word |) ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_into_word :
        M.IsAssociatedFunction.C Self "into_word" into_word.
      Admitted.
      Global Typeclasses Opaque into_word.
      
      (*
          pub fn parse_checksummed<S: AsRef<str>>(
              s: S,
              chain_id: Option<u64>,
          ) -> Result<Self, AddressError> {
              fn parse_checksummed(s: &str, chain_id: Option<u64>) -> Result<Address, AddressError> {
                  // checksummed addresses always start with the "0x" prefix
                  if !s.starts_with("0x") {
                      return Err(AddressError::Hex(hex::FromHexError::InvalidStringLength));
                  }
      
                  let address: Address = s.parse()?;
                  if s == address.to_checksum_buffer(chain_id).as_str() {
                      Ok(address)
                  } else {
                      Err(AddressError::InvalidChecksum)
                  }
              }
      
              parse_checksummed(s.as_ref(), chain_id)
          }
      *)
      Definition parse_checksummed (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [ _ as S ], [ s; chain_id ] =>
          ltac:(M.monadic
            (let s := M.alloc (| S, s |) in
            let chain_id :=
              M.alloc (|
                Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "u64" ],
                chain_id
              |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "core::result::Result")
                []
                [
                  Ty.path "alloy_primitives::bits::address::Address";
                  Ty.path "alloy_primitives::bits::address::AddressError"
                ],
              M.get_associated_function (| Self, "parse_checksummed.parse_checksummed", [], [] |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.call_closure (|
                      Ty.apply (Ty.path "&") [] [ Ty.path "str" ],
                      M.get_trait_method (|
                        "core::convert::AsRef",
                        S,
                        [],
                        [ Ty.path "str" ],
                        "as_ref",
                        [],
                        []
                      |),
                      [ M.borrow (| Pointer.Kind.Ref, s |) ]
                    |)
                  |)
                |);
                M.read (| chain_id |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_parse_checksummed :
        M.IsAssociatedFunction.C Self "parse_checksummed" parse_checksummed.
      Admitted.
      Global Typeclasses Opaque parse_checksummed.
      
      (*
          pub fn to_checksum(&self, chain_id: Option<u64>) -> String {
              self.to_checksum_buffer(chain_id).as_str().into()
          }
      *)
      Definition to_checksum (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; chain_id ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply (Ty.path "&") [] [ Ty.path "alloy_primitives::bits::address::Address" ],
                self
              |) in
            let chain_id :=
              M.alloc (|
                Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "u64" ],
                chain_id
              |) in
            M.call_closure (|
              Ty.path "alloc::string::String",
              M.get_trait_method (|
                "core::convert::Into",
                Ty.apply (Ty.path "&") [] [ Ty.path "str" ],
                [],
                [ Ty.path "alloc::string::String" ],
                "into",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.call_closure (|
                      Ty.apply (Ty.path "&") [] [ Ty.path "str" ],
                      M.get_associated_function (|
                        Ty.path "alloy_primitives::bits::address::AddressChecksumBuffer",
                        "as_str",
                        [],
                        []
                      |),
                      [
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.alloc (|
                            Ty.path "alloy_primitives::bits::address::AddressChecksumBuffer",
                            M.call_closure (|
                              Ty.path "alloy_primitives::bits::address::AddressChecksumBuffer",
                              M.get_associated_function (|
                                Ty.path "alloy_primitives::bits::address::Address",
                                "to_checksum_buffer",
                                [],
                                []
                              |),
                              [
                                M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |);
                                M.read (| chain_id |)
                              ]
                            |)
                          |)
                        |)
                      ]
                    |)
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_to_checksum :
        M.IsAssociatedFunction.C Self "to_checksum" to_checksum.
      Admitted.
      Global Typeclasses Opaque to_checksum.
      
      (*
          pub fn to_checksum_raw<'a>(&self, buf: &'a mut [u8], chain_id: Option<u64>) -> &'a mut str {
              let buf: &mut [u8; 42] = buf.try_into().expect("buffer must be exactly 42 bytes long");
              self.to_checksum_inner(buf, chain_id);
              // SAFETY: All bytes in the buffer are valid UTF-8.
              unsafe { str::from_utf8_unchecked_mut(buf) }
          }
      *)
      Definition to_checksum_raw (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; buf; chain_id ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply (Ty.path "&") [] [ Ty.path "alloy_primitives::bits::address::Address" ],
                self
              |) in
            let buf :=
              M.alloc (|
                Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                buf
              |) in
            let chain_id :=
              M.alloc (|
                Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "u64" ],
                chain_id
              |) in
            M.borrow (|
              Pointer.Kind.MutRef,
              M.deref (|
                M.read (|
                  let~ buf :
                      Ty.apply
                        (Ty.path "&mut")
                        []
                        [
                          Ty.apply
                            (Ty.path "array")
                            [ Value.Integer IntegerKind.Usize 42 ]
                            [ Ty.path "u8" ]
                        ] :=
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "&mut")
                        []
                        [
                          Ty.apply
                            (Ty.path "array")
                            [ Value.Integer IntegerKind.Usize 42 ]
                            [ Ty.path "u8" ]
                        ],
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [
                            Ty.apply
                              (Ty.path "&mut")
                              []
                              [
                                Ty.apply
                                  (Ty.path "array")
                                  [ Value.Integer IntegerKind.Usize 42 ]
                                  [ Ty.path "u8" ]
                              ];
                            Ty.path "core::array::TryFromSliceError"
                          ],
                        "expect",
                        [],
                        []
                      |),
                      [
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "core::result::Result")
                            []
                            [
                              Ty.apply
                                (Ty.path "&mut")
                                []
                                [
                                  Ty.apply
                                    (Ty.path "array")
                                    [ Value.Integer IntegerKind.Usize 42 ]
                                    [ Ty.path "u8" ]
                                ];
                              Ty.path "core::array::TryFromSliceError"
                            ],
                          M.get_trait_method (|
                            "core::convert::TryInto",
                            Ty.apply
                              (Ty.path "&mut")
                              []
                              [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                            [],
                            [
                              Ty.apply
                                (Ty.path "&mut")
                                []
                                [
                                  Ty.apply
                                    (Ty.path "array")
                                    [ Value.Integer IntegerKind.Usize 42 ]
                                    [ Ty.path "u8" ]
                                ]
                            ],
                            "try_into",
                            [],
                            []
                          |),
                          [ M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| buf |) |) |) ]
                        |);
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.deref (| mk_str (| "buffer must be exactly 42 bytes long" |) |)
                        |)
                      ]
                    |) in
                  let~ _ : Ty.tuple [] :=
                    M.call_closure (|
                      Ty.tuple [],
                      M.get_associated_function (|
                        Ty.path "alloy_primitives::bits::address::Address",
                        "to_checksum_inner",
                        [],
                        []
                      |),
                      [
                        M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |);
                        M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| buf |) |) |);
                        M.read (| chain_id |)
                      ]
                    |) in
                  M.alloc (|
                    Ty.apply (Ty.path "&mut") [] [ Ty.path "str" ],
                    M.borrow (|
                      Pointer.Kind.MutRef,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.MutRef,
                          M.deref (|
                            M.call_closure (|
                              Ty.apply (Ty.path "&mut") [] [ Ty.path "str" ],
                              M.get_function (|
                                "core::str::converts::from_utf8_unchecked_mut",
                                [],
                                []
                              |),
                              [
                                (* Unsize *)
                                M.pointer_coercion
                                  (M.borrow (|
                                    Pointer.Kind.MutRef,
                                    M.deref (| M.read (| buf |) |)
                                  |))
                              ]
                            |)
                          |)
                        |)
                      |)
                    |)
                  |)
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_to_checksum_raw :
        M.IsAssociatedFunction.C Self "to_checksum_raw" to_checksum_raw.
      Admitted.
      Global Typeclasses Opaque to_checksum_raw.
      
      (*
          pub fn to_checksum_buffer(&self, chain_id: Option<u64>) -> AddressChecksumBuffer {
              // SAFETY: The buffer is initialized by `format`.
              let mut buf = unsafe { AddressChecksumBuffer::new() };
              buf.format(self, chain_id);
              buf
          }
      *)
      Definition to_checksum_buffer (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; chain_id ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply (Ty.path "&") [] [ Ty.path "alloy_primitives::bits::address::Address" ],
                self
              |) in
            let chain_id :=
              M.alloc (|
                Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "u64" ],
                chain_id
              |) in
            M.read (|
              let~ buf : Ty.path "alloy_primitives::bits::address::AddressChecksumBuffer" :=
                M.call_closure (|
                  Ty.path "alloy_primitives::bits::address::AddressChecksumBuffer",
                  M.get_associated_function (|
                    Ty.path "alloy_primitives::bits::address::AddressChecksumBuffer",
                    "new",
                    [],
                    []
                  |),
                  []
                |) in
              let~ _ : Ty.apply (Ty.path "&mut") [] [ Ty.path "str" ] :=
                M.call_closure (|
                  Ty.apply (Ty.path "&mut") [] [ Ty.path "str" ],
                  M.get_associated_function (|
                    Ty.path "alloy_primitives::bits::address::AddressChecksumBuffer",
                    "format",
                    [],
                    []
                  |),
                  [
                    M.borrow (| Pointer.Kind.MutRef, buf |);
                    M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |);
                    M.read (| chain_id |)
                  ]
                |) in
              buf
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_to_checksum_buffer :
        M.IsAssociatedFunction.C Self "to_checksum_buffer" to_checksum_buffer.
      Admitted.
      Global Typeclasses Opaque to_checksum_buffer.
      
      (*
          fn to_checksum_inner(&self, buf: &mut [u8; 42], chain_id: Option<u64>) {
              buf[0] = b'0';
              buf[1] = b'x';
              hex::encode_to_slice(self, &mut buf[2..]).unwrap();
      
              let mut hasher = crate::Keccak256::new();
              match chain_id {
                  Some(chain_id) => {
                      hasher.update(itoa::Buffer::new().format(chain_id).as_bytes());
                      // Clippy suggests an unnecessary copy.
                      #[allow(clippy::needless_borrows_for_generic_args)]
                      hasher.update(&*buf);
                  }
                  None => hasher.update(&buf[2..]),
              }
              let hash = hasher.finalize();
      
              for (i, out) in buf[2..].iter_mut().enumerate() {
                  // This is made branchless for easier vectorization.
                  // Get the i-th nibble of the hash.
                  let hash_nibble = hash[i / 2] >> (4 * (1 - i % 2)) & 0xf;
                  // Make the character ASCII uppercase if it's a hex letter and the hash nibble is >= 8.
                  // We can use a simpler comparison for checking if the character is a hex letter because
                  // we know `out` is a hex-encoded character (`b'0'..=b'9' | b'a'..=b'f'`).
                  *out ^= 0b0010_0000 * (( *out >= b'a') & (hash_nibble >= 8)) as u8;
              }
          }
      *)
      Definition to_checksum_inner (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; buf; chain_id ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply (Ty.path "&") [] [ Ty.path "alloy_primitives::bits::address::Address" ],
                self
              |) in
            let buf :=
              M.alloc (|
                Ty.apply
                  (Ty.path "&mut")
                  []
                  [
                    Ty.apply
                      (Ty.path "array")
                      [ Value.Integer IntegerKind.Usize 42 ]
                      [ Ty.path "u8" ]
                  ],
                buf
              |) in
            let chain_id :=
              M.alloc (|
                Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "u64" ],
                chain_id
              |) in
            M.read (|
              let~ _ : Ty.tuple [] :=
                M.write (|
                  M.SubPointer.get_array_field (|
                    M.deref (| M.read (| buf |) |),
                    Value.Integer IntegerKind.Usize 0
                  |),
                  M.read (| UnsupportedLiteral |)
                |) in
              let~ _ : Ty.tuple [] :=
                M.write (|
                  M.SubPointer.get_array_field (|
                    M.deref (| M.read (| buf |) |),
                    Value.Integer IntegerKind.Usize 1
                  |),
                  M.read (| UnsupportedLiteral |)
                |) in
              let~ _ : Ty.tuple [] :=
                M.call_closure (|
                  Ty.tuple [],
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "core::result::Result")
                      []
                      [ Ty.tuple []; Ty.path "const_hex::error::FromHexError" ],
                    "unwrap",
                    [],
                    []
                  |),
                  [
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "core::result::Result")
                        []
                        [ Ty.tuple []; Ty.path "const_hex::error::FromHexError" ],
                      M.get_function (|
                        "const_hex::encode_to_slice",
                        [],
                        [
                          Ty.apply
                            (Ty.path "&")
                            []
                            [ Ty.path "alloy_primitives::bits::address::Address" ]
                        ]
                      |),
                      [
                        M.read (| self |);
                        M.borrow (|
                          Pointer.Kind.MutRef,
                          M.deref (|
                            M.borrow (|
                              Pointer.Kind.MutRef,
                              M.deref (|
                                M.call_closure (|
                                  Ty.apply
                                    (Ty.path "&mut")
                                    []
                                    [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                                  M.get_trait_method (|
                                    "core::ops::index::IndexMut",
                                    Ty.apply
                                      (Ty.path "array")
                                      [ Value.Integer IntegerKind.Usize 42 ]
                                      [ Ty.path "u8" ],
                                    [],
                                    [
                                      Ty.apply
                                        (Ty.path "core::ops::range::RangeFrom")
                                        []
                                        [ Ty.path "usize" ]
                                    ],
                                    "index_mut",
                                    [],
                                    []
                                  |),
                                  [
                                    M.borrow (|
                                      Pointer.Kind.MutRef,
                                      M.deref (| M.read (| buf |) |)
                                    |);
                                    Value.mkStructRecord
                                      "core::ops::range::RangeFrom"
                                      []
                                      [ Ty.path "usize" ]
                                      [ ("start", Value.Integer IntegerKind.Usize 2) ]
                                  ]
                                |)
                              |)
                            |)
                          |)
                        |)
                      ]
                    |)
                  ]
                |) in
              let~ hasher : Ty.path "alloy_primitives::utils::Keccak256" :=
                M.call_closure (|
                  Ty.path "alloy_primitives::utils::Keccak256",
                  M.get_associated_function (|
                    Ty.path "alloy_primitives::utils::Keccak256",
                    "new",
                    [],
                    []
                  |),
                  []
                |) in
              let~ _ : Ty.tuple [] :=
                M.read (|
                  M.match_operator (|
                    Ty.tuple [],
                    chain_id,
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ0_0 :=
                            M.SubPointer.get_struct_tuple_field (|
                              γ,
                              "core::option::Option::Some",
                              0
                            |) in
                          let chain_id := M.copy (| Ty.path "u64", γ0_0 |) in
                          let~ _ : Ty.tuple [] :=
                            M.call_closure (|
                              Ty.tuple [],
                              M.get_associated_function (|
                                Ty.path "alloy_primitives::utils::Keccak256",
                                "update",
                                [],
                                [
                                  Ty.apply
                                    (Ty.path "&")
                                    []
                                    [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
                                ]
                              |),
                              [
                                M.borrow (| Pointer.Kind.MutRef, hasher |);
                                M.call_closure (|
                                  Ty.apply
                                    (Ty.path "&")
                                    []
                                    [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                                  M.get_associated_function (| Ty.path "str", "as_bytes", [], [] |),
                                  [
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.deref (|
                                        M.call_closure (|
                                          Ty.apply (Ty.path "&") [] [ Ty.path "str" ],
                                          M.get_associated_function (|
                                            Ty.path "itoa::Buffer",
                                            "format",
                                            [],
                                            [ Ty.path "u64" ]
                                          |),
                                          [
                                            M.borrow (|
                                              Pointer.Kind.MutRef,
                                              M.alloc (|
                                                Ty.path "itoa::Buffer",
                                                M.call_closure (|
                                                  Ty.path "itoa::Buffer",
                                                  M.get_associated_function (|
                                                    Ty.path "itoa::Buffer",
                                                    "new",
                                                    [],
                                                    []
                                                  |),
                                                  []
                                                |)
                                              |)
                                            |);
                                            M.read (| chain_id |)
                                          ]
                                        |)
                                      |)
                                    |)
                                  ]
                                |)
                              ]
                            |) in
                          let~ _ : Ty.tuple [] :=
                            M.call_closure (|
                              Ty.tuple [],
                              M.get_associated_function (|
                                Ty.path "alloy_primitives::utils::Keccak256",
                                "update",
                                [],
                                [
                                  Ty.apply
                                    (Ty.path "&")
                                    []
                                    [
                                      Ty.apply
                                        (Ty.path "array")
                                        [ Value.Integer IntegerKind.Usize 42 ]
                                        [ Ty.path "u8" ]
                                    ]
                                ]
                              |),
                              [
                                M.borrow (| Pointer.Kind.MutRef, hasher |);
                                M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| buf |) |) |)
                              ]
                            |) in
                          M.alloc (| Ty.tuple [], Value.Tuple [] |)));
                      fun γ =>
                        ltac:(M.monadic
                          (let _ := M.is_struct_tuple (| γ, "core::option::Option::None" |) in
                          M.alloc (|
                            Ty.tuple [],
                            M.call_closure (|
                              Ty.tuple [],
                              M.get_associated_function (|
                                Ty.path "alloy_primitives::utils::Keccak256",
                                "update",
                                [],
                                [
                                  Ty.apply
                                    (Ty.path "&")
                                    []
                                    [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
                                ]
                              |),
                              [
                                M.borrow (| Pointer.Kind.MutRef, hasher |);
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.deref (|
                                    M.call_closure (|
                                      Ty.apply
                                        (Ty.path "&")
                                        []
                                        [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                                      M.get_trait_method (|
                                        "core::ops::index::Index",
                                        Ty.apply
                                          (Ty.path "array")
                                          [ Value.Integer IntegerKind.Usize 42 ]
                                          [ Ty.path "u8" ],
                                        [],
                                        [
                                          Ty.apply
                                            (Ty.path "core::ops::range::RangeFrom")
                                            []
                                            [ Ty.path "usize" ]
                                        ],
                                        "index",
                                        [],
                                        []
                                      |),
                                      [
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.deref (| M.read (| buf |) |)
                                        |);
                                        Value.mkStructRecord
                                          "core::ops::range::RangeFrom"
                                          []
                                          [ Ty.path "usize" ]
                                          [ ("start", Value.Integer IntegerKind.Usize 2) ]
                                      ]
                                    |)
                                  |)
                                |)
                              ]
                            |)
                          |)))
                    ]
                  |)
                |) in
              let~ hash :
                  Ty.apply
                    (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                    [ Value.Integer IntegerKind.Usize 32 ]
                    [] :=
                M.call_closure (|
                  Ty.apply
                    (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                    [ Value.Integer IntegerKind.Usize 32 ]
                    [],
                  M.get_associated_function (|
                    Ty.path "alloy_primitives::utils::Keccak256",
                    "finalize",
                    [],
                    []
                  |),
                  [ M.read (| hasher |) ]
                |) in
              M.use
                (M.match_operator (|
                  Ty.tuple [],
                  M.alloc (|
                    Ty.apply
                      (Ty.path "core::iter::adapters::enumerate::Enumerate")
                      []
                      [ Ty.apply (Ty.path "core::slice::iter::IterMut") [] [ Ty.path "u8" ] ],
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "core::iter::adapters::enumerate::Enumerate")
                        []
                        [ Ty.apply (Ty.path "core::slice::iter::IterMut") [] [ Ty.path "u8" ] ],
                      M.get_trait_method (|
                        "core::iter::traits::collect::IntoIterator",
                        Ty.apply
                          (Ty.path "core::iter::adapters::enumerate::Enumerate")
                          []
                          [ Ty.apply (Ty.path "core::slice::iter::IterMut") [] [ Ty.path "u8" ] ],
                        [],
                        [],
                        "into_iter",
                        [],
                        []
                      |),
                      [
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "core::iter::adapters::enumerate::Enumerate")
                            []
                            [ Ty.apply (Ty.path "core::slice::iter::IterMut") [] [ Ty.path "u8" ] ],
                          M.get_trait_method (|
                            "core::iter::traits::iterator::Iterator",
                            Ty.apply (Ty.path "core::slice::iter::IterMut") [] [ Ty.path "u8" ],
                            [],
                            [],
                            "enumerate",
                            [],
                            []
                          |),
                          [
                            M.call_closure (|
                              Ty.apply (Ty.path "core::slice::iter::IterMut") [] [ Ty.path "u8" ],
                              M.get_associated_function (|
                                Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                                "iter_mut",
                                [],
                                []
                              |),
                              [
                                M.borrow (|
                                  Pointer.Kind.MutRef,
                                  M.deref (|
                                    M.call_closure (|
                                      Ty.apply
                                        (Ty.path "&mut")
                                        []
                                        [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                                      M.get_trait_method (|
                                        "core::ops::index::IndexMut",
                                        Ty.apply
                                          (Ty.path "array")
                                          [ Value.Integer IntegerKind.Usize 42 ]
                                          [ Ty.path "u8" ],
                                        [],
                                        [
                                          Ty.apply
                                            (Ty.path "core::ops::range::RangeFrom")
                                            []
                                            [ Ty.path "usize" ]
                                        ],
                                        "index_mut",
                                        [],
                                        []
                                      |),
                                      [
                                        M.borrow (|
                                          Pointer.Kind.MutRef,
                                          M.deref (| M.read (| buf |) |)
                                        |);
                                        Value.mkStructRecord
                                          "core::ops::range::RangeFrom"
                                          []
                                          [ Ty.path "usize" ]
                                          [ ("start", Value.Integer IntegerKind.Usize 2) ]
                                      ]
                                    |)
                                  |)
                                |)
                              ]
                            |)
                          ]
                        |)
                      ]
                    |)
                  |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let iter :=
                          M.copy (|
                            Ty.apply
                              (Ty.path "core::iter::adapters::enumerate::Enumerate")
                              []
                              [ Ty.apply (Ty.path "core::slice::iter::IterMut") [] [ Ty.path "u8" ]
                              ],
                            γ
                          |) in
                        M.loop (|
                          Ty.tuple [],
                          ltac:(M.monadic
                            (let~ _ : Ty.tuple [] :=
                              M.read (|
                                M.match_operator (|
                                  Ty.tuple [],
                                  M.alloc (|
                                    Ty.apply
                                      (Ty.path "core::option::Option")
                                      []
                                      [
                                        Ty.tuple
                                          [
                                            Ty.path "usize";
                                            Ty.apply (Ty.path "&mut") [] [ Ty.path "u8" ]
                                          ]
                                      ],
                                    M.call_closure (|
                                      Ty.apply
                                        (Ty.path "core::option::Option")
                                        []
                                        [
                                          Ty.tuple
                                            [
                                              Ty.path "usize";
                                              Ty.apply (Ty.path "&mut") [] [ Ty.path "u8" ]
                                            ]
                                        ],
                                      M.get_trait_method (|
                                        "core::iter::traits::iterator::Iterator",
                                        Ty.apply
                                          (Ty.path "core::iter::adapters::enumerate::Enumerate")
                                          []
                                          [
                                            Ty.apply
                                              (Ty.path "core::slice::iter::IterMut")
                                              []
                                              [ Ty.path "u8" ]
                                          ],
                                        [],
                                        [],
                                        "next",
                                        [],
                                        []
                                      |),
                                      [
                                        M.borrow (|
                                          Pointer.Kind.MutRef,
                                          M.deref (| M.borrow (| Pointer.Kind.MutRef, iter |) |)
                                        |)
                                      ]
                                    |)
                                  |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let _ :=
                                          M.is_struct_tuple (| γ, "core::option::Option::None" |) in
                                        M.alloc (|
                                          Ty.tuple [],
                                          M.never_to_any (| M.read (| M.break (||) |) |)
                                        |)));
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ0_0 :=
                                          M.SubPointer.get_struct_tuple_field (|
                                            γ,
                                            "core::option::Option::Some",
                                            0
                                          |) in
                                        let γ1_0 := M.SubPointer.get_tuple_field (| γ0_0, 0 |) in
                                        let γ1_1 := M.SubPointer.get_tuple_field (| γ0_0, 1 |) in
                                        let i := M.copy (| Ty.path "usize", γ1_0 |) in
                                        let out :=
                                          M.copy (|
                                            Ty.apply (Ty.path "&mut") [] [ Ty.path "u8" ],
                                            γ1_1
                                          |) in
                                        let~ hash_nibble : Ty.path "u8" :=
                                          M.call_closure (|
                                            Ty.path "u8",
                                            BinOp.Wrap.bit_and,
                                            [
                                              M.call_closure (|
                                                Ty.path "u8",
                                                BinOp.Wrap.shr,
                                                [
                                                  M.read (|
                                                    M.deref (|
                                                      M.call_closure (|
                                                        Ty.apply (Ty.path "&") [] [ Ty.path "u8" ],
                                                        M.get_trait_method (|
                                                          "core::ops::index::Index",
                                                          Ty.apply
                                                            (Ty.path
                                                              "alloy_primitives::bits::fixed::FixedBytes")
                                                            [ Value.Integer IntegerKind.Usize 32 ]
                                                            [],
                                                          [],
                                                          [ Ty.path "usize" ],
                                                          "index",
                                                          [],
                                                          []
                                                        |),
                                                        [
                                                          M.borrow (| Pointer.Kind.Ref, hash |);
                                                          M.call_closure (|
                                                            Ty.path "usize",
                                                            BinOp.Wrap.div,
                                                            [
                                                              M.read (| i |);
                                                              Value.Integer IntegerKind.Usize 2
                                                            ]
                                                          |)
                                                        ]
                                                      |)
                                                    |)
                                                  |);
                                                  M.call_closure (|
                                                    Ty.path "usize",
                                                    BinOp.Wrap.mul,
                                                    [
                                                      Value.Integer IntegerKind.Usize 4;
                                                      M.call_closure (|
                                                        Ty.path "usize",
                                                        BinOp.Wrap.sub,
                                                        [
                                                          Value.Integer IntegerKind.Usize 1;
                                                          M.call_closure (|
                                                            Ty.path "usize",
                                                            BinOp.Wrap.rem,
                                                            [
                                                              M.read (| i |);
                                                              Value.Integer IntegerKind.Usize 2
                                                            ]
                                                          |)
                                                        ]
                                                      |)
                                                    ]
                                                  |)
                                                ]
                                              |);
                                              Value.Integer IntegerKind.U8 15
                                            ]
                                          |) in
                                        let~ _ : Ty.tuple [] :=
                                          let β := M.deref (| M.read (| out |) |) in
                                          M.write (|
                                            β,
                                            M.call_closure (|
                                              Ty.path "u8",
                                              BinOp.Wrap.bit_xor,
                                              [
                                                M.read (| β |);
                                                M.call_closure (|
                                                  Ty.path "u8",
                                                  BinOp.Wrap.mul,
                                                  [
                                                    Value.Integer IntegerKind.U8 32;
                                                    M.cast
                                                      (Ty.path "u8")
                                                      (M.call_closure (|
                                                        Ty.path "bool",
                                                        BinOp.Wrap.bit_and,
                                                        [
                                                          M.call_closure (|
                                                            Ty.path "bool",
                                                            BinOp.ge,
                                                            [
                                                              M.read (|
                                                                M.deref (| M.read (| out |) |)
                                                              |);
                                                              M.read (| UnsupportedLiteral |)
                                                            ]
                                                          |);
                                                          M.call_closure (|
                                                            Ty.path "bool",
                                                            BinOp.ge,
                                                            [
                                                              M.read (| hash_nibble |);
                                                              Value.Integer IntegerKind.U8 8
                                                            ]
                                                          |)
                                                        ]
                                                      |))
                                                  ]
                                                |)
                                              ]
                                            |)
                                          |) in
                                        M.alloc (| Ty.tuple [], Value.Tuple [] |)))
                                  ]
                                |)
                              |) in
                            M.alloc (| Ty.tuple [], Value.Tuple [] |)))
                        |)))
                  ]
                |))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_to_checksum_inner :
        M.IsAssociatedFunction.C Self "to_checksum_inner" to_checksum_inner.
      Admitted.
      Global Typeclasses Opaque to_checksum_inner.
      
      (*
          pub fn create2_from_code<S, C>(&self, salt: S, init_code: C) -> Self
          where
              // not `AsRef` because `[u8; N]` does not implement `AsRef<[u8; N]>`
              S: Borrow<[u8; 32]>,
              C: AsRef<[u8]>,
          {
              self._create2(salt.borrow(), &keccak256(init_code.as_ref()).0)
          }
      *)
      Definition create2_from_code (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [ _ as S; C ], [ self; salt; init_code ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply (Ty.path "&") [] [ Ty.path "alloy_primitives::bits::address::Address" ],
                self
              |) in
            let salt := M.alloc (| S, salt |) in
            let init_code := M.alloc (| C, init_code |) in
            M.call_closure (|
              Ty.path "alloy_primitives::bits::address::Address",
              M.get_associated_function (|
                Ty.path "alloy_primitives::bits::address::Address",
                "_create2",
                [],
                []
              |),
              [
                M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |);
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "&")
                        []
                        [
                          Ty.apply
                            (Ty.path "array")
                            [ Value.Integer IntegerKind.Usize 32 ]
                            [ Ty.path "u8" ]
                        ],
                      M.get_trait_method (|
                        "core::borrow::Borrow",
                        S,
                        [],
                        [
                          Ty.apply
                            (Ty.path "array")
                            [ Value.Integer IntegerKind.Usize 32 ]
                            [ Ty.path "u8" ]
                        ],
                        "borrow",
                        [],
                        []
                      |),
                      [ M.borrow (| Pointer.Kind.Ref, salt |) ]
                    |)
                  |)
                |);
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_tuple_field (|
                        M.alloc (|
                          Ty.apply
                            (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                            [ Value.Integer IntegerKind.Usize 32 ]
                            [],
                          M.call_closure (|
                            Ty.apply
                              (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                              [ Value.Integer IntegerKind.Usize 32 ]
                              [],
                            M.get_function (|
                              "alloy_primitives::utils::keccak256",
                              [],
                              [
                                Ty.apply
                                  (Ty.path "&")
                                  []
                                  [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
                              ]
                            |),
                            [
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "&")
                                  []
                                  [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                                M.get_trait_method (|
                                  "core::convert::AsRef",
                                  C,
                                  [],
                                  [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                                  "as_ref",
                                  [],
                                  []
                                |),
                                [ M.borrow (| Pointer.Kind.Ref, init_code |) ]
                              |)
                            ]
                          |)
                        |),
                        "alloy_primitives::bits::fixed::FixedBytes",
                        0
                      |)
                    |)
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_create2_from_code :
        M.IsAssociatedFunction.C Self "create2_from_code" create2_from_code.
      Admitted.
      Global Typeclasses Opaque create2_from_code.
      
      (*
          pub fn create2<S, H>(&self, salt: S, init_code_hash: H) -> Self
          where
              // not `AsRef` because `[u8; N]` does not implement `AsRef<[u8; N]>`
              S: Borrow<[u8; 32]>,
              H: Borrow<[u8; 32]>,
          {
              self._create2(salt.borrow(), init_code_hash.borrow())
          }
      *)
      Definition create2 (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [ _ as S; H ], [ self; salt; init_code_hash ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply (Ty.path "&") [] [ Ty.path "alloy_primitives::bits::address::Address" ],
                self
              |) in
            let salt := M.alloc (| S, salt |) in
            let init_code_hash := M.alloc (| H, init_code_hash |) in
            M.call_closure (|
              Ty.path "alloy_primitives::bits::address::Address",
              M.get_associated_function (|
                Ty.path "alloy_primitives::bits::address::Address",
                "_create2",
                [],
                []
              |),
              [
                M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |);
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "&")
                        []
                        [
                          Ty.apply
                            (Ty.path "array")
                            [ Value.Integer IntegerKind.Usize 32 ]
                            [ Ty.path "u8" ]
                        ],
                      M.get_trait_method (|
                        "core::borrow::Borrow",
                        S,
                        [],
                        [
                          Ty.apply
                            (Ty.path "array")
                            [ Value.Integer IntegerKind.Usize 32 ]
                            [ Ty.path "u8" ]
                        ],
                        "borrow",
                        [],
                        []
                      |),
                      [ M.borrow (| Pointer.Kind.Ref, salt |) ]
                    |)
                  |)
                |);
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "&")
                        []
                        [
                          Ty.apply
                            (Ty.path "array")
                            [ Value.Integer IntegerKind.Usize 32 ]
                            [ Ty.path "u8" ]
                        ],
                      M.get_trait_method (|
                        "core::borrow::Borrow",
                        H,
                        [],
                        [
                          Ty.apply
                            (Ty.path "array")
                            [ Value.Integer IntegerKind.Usize 32 ]
                            [ Ty.path "u8" ]
                        ],
                        "borrow",
                        [],
                        []
                      |),
                      [ M.borrow (| Pointer.Kind.Ref, init_code_hash |) ]
                    |)
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_create2 : M.IsAssociatedFunction.C Self "create2" create2.
      Admitted.
      Global Typeclasses Opaque create2.
      
      (*
          fn _create2(&self, salt: &[u8; 32], init_code_hash: &[u8; 32]) -> Self {
              // note: creating a temporary buffer and copying everything over performs
              // much better than calling `Keccak::update` multiple times
              let mut bytes = [0; 85];
              bytes[0] = 0xff;
              bytes[1..21].copy_from_slice(self.as_slice());
              bytes[21..53].copy_from_slice(salt);
              bytes[53..85].copy_from_slice(init_code_hash);
              let hash = keccak256(bytes);
              Self::from_word(hash)
          }
      *)
      Definition _create2 (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; salt; init_code_hash ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply (Ty.path "&") [] [ Ty.path "alloy_primitives::bits::address::Address" ],
                self
              |) in
            let salt :=
              M.alloc (|
                Ty.apply
                  (Ty.path "&")
                  []
                  [
                    Ty.apply
                      (Ty.path "array")
                      [ Value.Integer IntegerKind.Usize 32 ]
                      [ Ty.path "u8" ]
                  ],
                salt
              |) in
            let init_code_hash :=
              M.alloc (|
                Ty.apply
                  (Ty.path "&")
                  []
                  [
                    Ty.apply
                      (Ty.path "array")
                      [ Value.Integer IntegerKind.Usize 32 ]
                      [ Ty.path "u8" ]
                  ],
                init_code_hash
              |) in
            M.read (|
              let~ bytes :
                  Ty.apply
                    (Ty.path "array")
                    [ Value.Integer IntegerKind.Usize 85 ]
                    [ Ty.path "u8" ] :=
                lib.repeat (|
                  Value.Integer IntegerKind.U8 0,
                  Value.Integer IntegerKind.Usize 85
                |) in
              let~ _ : Ty.tuple [] :=
                M.write (|
                  M.SubPointer.get_array_field (| bytes, Value.Integer IntegerKind.Usize 0 |),
                  Value.Integer IntegerKind.U8 255
                |) in
              let~ _ : Ty.tuple [] :=
                M.call_closure (|
                  Ty.tuple [],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                    "copy_from_slice",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.MutRef,
                      M.deref (|
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "&mut")
                            []
                            [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                          M.get_trait_method (|
                            "core::ops::index::IndexMut",
                            Ty.apply
                              (Ty.path "array")
                              [ Value.Integer IntegerKind.Usize 85 ]
                              [ Ty.path "u8" ],
                            [],
                            [ Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "usize" ] ],
                            "index_mut",
                            [],
                            []
                          |),
                          [
                            M.borrow (| Pointer.Kind.MutRef, bytes |);
                            Value.mkStructRecord
                              "core::ops::range::Range"
                              []
                              [ Ty.path "usize" ]
                              [
                                ("start", Value.Integer IntegerKind.Usize 1);
                                ("end_", Value.Integer IntegerKind.Usize 21)
                              ]
                          ]
                        |)
                      |)
                    |);
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "&")
                            []
                            [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                          M.get_associated_function (|
                            Ty.apply
                              (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                              [ Value.Integer IntegerKind.Usize 20 ]
                              [],
                            "as_slice",
                            [],
                            []
                          |),
                          [
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.deref (|
                                M.call_closure (|
                                  Ty.apply
                                    (Ty.path "&")
                                    []
                                    [
                                      Ty.apply
                                        (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                                        [ Value.Integer IntegerKind.Usize 20 ]
                                        []
                                    ],
                                  M.get_trait_method (|
                                    "core::ops::deref::Deref",
                                    Ty.path "alloy_primitives::bits::address::Address",
                                    [],
                                    [],
                                    "deref",
                                    [],
                                    []
                                  |),
                                  [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |)
                                  ]
                                |)
                              |)
                            |)
                          ]
                        |)
                      |)
                    |)
                  ]
                |) in
              let~ _ : Ty.tuple [] :=
                M.call_closure (|
                  Ty.tuple [],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                    "copy_from_slice",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.MutRef,
                      M.deref (|
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "&mut")
                            []
                            [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                          M.get_trait_method (|
                            "core::ops::index::IndexMut",
                            Ty.apply
                              (Ty.path "array")
                              [ Value.Integer IntegerKind.Usize 85 ]
                              [ Ty.path "u8" ],
                            [],
                            [ Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "usize" ] ],
                            "index_mut",
                            [],
                            []
                          |),
                          [
                            M.borrow (| Pointer.Kind.MutRef, bytes |);
                            Value.mkStructRecord
                              "core::ops::range::Range"
                              []
                              [ Ty.path "usize" ]
                              [
                                ("start", Value.Integer IntegerKind.Usize 21);
                                ("end_", Value.Integer IntegerKind.Usize 53)
                              ]
                          ]
                        |)
                      |)
                    |);
                    (* Unsize *)
                    M.pointer_coercion
                      (M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| salt |) |) |))
                  ]
                |) in
              let~ _ : Ty.tuple [] :=
                M.call_closure (|
                  Ty.tuple [],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                    "copy_from_slice",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.MutRef,
                      M.deref (|
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "&mut")
                            []
                            [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                          M.get_trait_method (|
                            "core::ops::index::IndexMut",
                            Ty.apply
                              (Ty.path "array")
                              [ Value.Integer IntegerKind.Usize 85 ]
                              [ Ty.path "u8" ],
                            [],
                            [ Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "usize" ] ],
                            "index_mut",
                            [],
                            []
                          |),
                          [
                            M.borrow (| Pointer.Kind.MutRef, bytes |);
                            Value.mkStructRecord
                              "core::ops::range::Range"
                              []
                              [ Ty.path "usize" ]
                              [
                                ("start", Value.Integer IntegerKind.Usize 53);
                                ("end_", Value.Integer IntegerKind.Usize 85)
                              ]
                          ]
                        |)
                      |)
                    |);
                    (* Unsize *)
                    M.pointer_coercion
                      (M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| init_code_hash |) |) |))
                  ]
                |) in
              let~ hash :
                  Ty.apply
                    (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                    [ Value.Integer IntegerKind.Usize 32 ]
                    [] :=
                M.call_closure (|
                  Ty.apply
                    (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                    [ Value.Integer IntegerKind.Usize 32 ]
                    [],
                  M.get_function (|
                    "alloy_primitives::utils::keccak256",
                    [],
                    [
                      Ty.apply
                        (Ty.path "array")
                        [ Value.Integer IntegerKind.Usize 85 ]
                        [ Ty.path "u8" ]
                    ]
                  |),
                  [ M.read (| bytes |) ]
                |) in
              M.alloc (|
                Ty.path "alloy_primitives::bits::address::Address",
                M.call_closure (|
                  Ty.path "alloy_primitives::bits::address::Address",
                  M.get_associated_function (|
                    Ty.path "alloy_primitives::bits::address::Address",
                    "from_word",
                    [],
                    []
                  |),
                  [ M.read (| hash |) ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction__create2 :
        M.IsAssociatedFunction.C Self "_create2" _create2.
      Admitted.
      Global Typeclasses Opaque _create2.
      
      (*
          pub fn from_raw_public_key(pubkey: &[u8]) -> Self {
              assert_eq!(pubkey.len(), 64, "raw public key must be 64 bytes");
              let digest = keccak256(pubkey);
              Self::from_slice(&digest[12..])
          }
      *)
      Definition from_raw_public_key (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ pubkey ] =>
          ltac:(M.monadic
            (let pubkey :=
              M.alloc (|
                Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                pubkey
              |) in
            M.read (|
              let~ _ : Ty.tuple [] :=
                M.read (|
                  M.match_operator (|
                    Ty.tuple [],
                    M.alloc (|
                      Ty.tuple
                        [
                          Ty.apply (Ty.path "&") [] [ Ty.path "usize" ];
                          Ty.apply (Ty.path "&") [] [ Ty.path "usize" ]
                        ],
                      Value.Tuple
                        [
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.alloc (|
                              Ty.path "usize",
                              M.call_closure (|
                                Ty.path "usize",
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                                  "len",
                                  [],
                                  []
                                |),
                                [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| pubkey |) |) |)
                                ]
                              |)
                            |)
                          |);
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.alloc (| Ty.path "usize", Value.Integer IntegerKind.Usize 64 |)
                          |)
                        ]
                    |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                          let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                          let left_val :=
                            M.copy (| Ty.apply (Ty.path "&") [] [ Ty.path "usize" ], γ0_0 |) in
                          let right_val :=
                            M.copy (| Ty.apply (Ty.path "&") [] [ Ty.path "usize" ], γ0_1 |) in
                          M.match_operator (|
                            Ty.tuple [],
                            M.alloc (| Ty.tuple [], Value.Tuple [] |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ :=
                                    M.use
                                      (M.alloc (|
                                        Ty.path "bool",
                                        UnOp.not (|
                                          M.call_closure (|
                                            Ty.path "bool",
                                            BinOp.eq,
                                            [
                                              M.read (| M.deref (| M.read (| left_val |) |) |);
                                              M.read (| M.deref (| M.read (| right_val |) |) |)
                                            ]
                                          |)
                                        |)
                                      |)) in
                                  let _ :=
                                    is_constant_or_break_match (|
                                      M.read (| γ |),
                                      Value.Bool true
                                    |) in
                                  M.alloc (|
                                    Ty.tuple [],
                                    M.never_to_any (|
                                      M.read (|
                                        let~ kind : Ty.path "core::panicking::AssertKind" :=
                                          Value.StructTuple
                                            "core::panicking::AssertKind::Eq"
                                            []
                                            []
                                            [] in
                                        M.alloc (|
                                          Ty.path "never",
                                          M.call_closure (|
                                            Ty.path "never",
                                            M.get_function (|
                                              "core::panicking::assert_failed",
                                              [],
                                              [ Ty.path "usize"; Ty.path "usize" ]
                                            |),
                                            [
                                              M.read (| kind |);
                                              M.borrow (|
                                                Pointer.Kind.Ref,
                                                M.deref (|
                                                  M.borrow (|
                                                    Pointer.Kind.Ref,
                                                    M.deref (| M.read (| left_val |) |)
                                                  |)
                                                |)
                                              |);
                                              M.borrow (|
                                                Pointer.Kind.Ref,
                                                M.deref (|
                                                  M.borrow (|
                                                    Pointer.Kind.Ref,
                                                    M.deref (| M.read (| right_val |) |)
                                                  |)
                                                |)
                                              |);
                                              Value.StructTuple
                                                "core::option::Option::Some"
                                                []
                                                [ Ty.path "core::fmt::Arguments" ]
                                                [
                                                  M.call_closure (|
                                                    Ty.path "core::fmt::Arguments",
                                                    M.get_associated_function (|
                                                      Ty.path "core::fmt::Arguments",
                                                      "new_const",
                                                      [ Value.Integer IntegerKind.Usize 1 ],
                                                      []
                                                    |),
                                                    [
                                                      M.borrow (|
                                                        Pointer.Kind.Ref,
                                                        M.deref (|
                                                          M.borrow (|
                                                            Pointer.Kind.Ref,
                                                            M.alloc (|
                                                              Ty.apply
                                                                (Ty.path "array")
                                                                [ Value.Integer IntegerKind.Usize 1
                                                                ]
                                                                [
                                                                  Ty.apply
                                                                    (Ty.path "&")
                                                                    []
                                                                    [ Ty.path "str" ]
                                                                ],
                                                              Value.Array
                                                                [
                                                                  mk_str (|
                                                                    "raw public key must be 64 bytes"
                                                                  |)
                                                                ]
                                                            |)
                                                          |)
                                                        |)
                                                      |)
                                                    ]
                                                  |)
                                                ]
                                            ]
                                          |)
                                        |)
                                      |)
                                    |)
                                  |)));
                              fun γ => ltac:(M.monadic (M.alloc (| Ty.tuple [], Value.Tuple [] |)))
                            ]
                          |)))
                    ]
                  |)
                |) in
              let~ digest :
                  Ty.apply
                    (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                    [ Value.Integer IntegerKind.Usize 32 ]
                    [] :=
                M.call_closure (|
                  Ty.apply
                    (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                    [ Value.Integer IntegerKind.Usize 32 ]
                    [],
                  M.get_function (|
                    "alloy_primitives::utils::keccak256",
                    [],
                    [ Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ] ]
                  |),
                  [ M.read (| pubkey |) ]
                |) in
              M.alloc (|
                Ty.path "alloy_primitives::bits::address::Address",
                M.call_closure (|
                  Ty.path "alloy_primitives::bits::address::Address",
                  M.get_associated_function (|
                    Ty.path "alloy_primitives::bits::address::Address",
                    "from_slice",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.deref (|
                            M.call_closure (|
                              Ty.apply
                                (Ty.path "&")
                                []
                                [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                              M.get_trait_method (|
                                "core::ops::index::Index",
                                Ty.apply
                                  (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                                  [ Value.Integer IntegerKind.Usize 32 ]
                                  [],
                                [],
                                [
                                  Ty.apply
                                    (Ty.path "core::ops::range::RangeFrom")
                                    []
                                    [ Ty.path "usize" ]
                                ],
                                "index",
                                [],
                                []
                              |),
                              [
                                M.borrow (| Pointer.Kind.Ref, digest |);
                                Value.mkStructRecord
                                  "core::ops::range::RangeFrom"
                                  []
                                  [ Ty.path "usize" ]
                                  [ ("start", Value.Integer IntegerKind.Usize 12) ]
                              ]
                            |)
                          |)
                        |)
                      |)
                    |)
                  ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_from_raw_public_key :
        M.IsAssociatedFunction.C Self "from_raw_public_key" from_raw_public_key.
      Admitted.
      Global Typeclasses Opaque from_raw_public_key.
    End Impl_alloy_primitives_bits_address_Address.
    
    (* StructTuple
      {
        name := "AddressChecksumBuffer";
        const_params := [];
        ty_params := [];
        fields :=
          [
            Ty.apply
              (Ty.path "core::mem::maybe_uninit::MaybeUninit")
              []
              [ Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 42 ] [ Ty.path "u8" ] ]
          ];
      } *)
    
    Module Impl_core_clone_Clone_for_alloy_primitives_bits_address_AddressChecksumBuffer.
      Definition Self : Ty.t := Ty.path "alloy_primitives::bits::address::AddressChecksumBuffer".
      
      (* Clone *)
      Definition clone (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply
                  (Ty.path "&")
                  []
                  [ Ty.path "alloy_primitives::bits::address::AddressChecksumBuffer" ],
                self
              |) in
            Value.StructTuple
              "alloy_primitives::bits::address::AddressChecksumBuffer"
              []
              []
              [
                M.call_closure (|
                  Ty.apply
                    (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                    []
                    [
                      Ty.apply
                        (Ty.path "array")
                        [ Value.Integer IntegerKind.Usize 42 ]
                        [ Ty.path "u8" ]
                    ],
                  M.get_trait_method (|
                    "core::clone::Clone",
                    Ty.apply
                      (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                      []
                      [
                        Ty.apply
                          (Ty.path "array")
                          [ Value.Integer IntegerKind.Usize 42 ]
                          [ Ty.path "u8" ]
                      ],
                    [],
                    [],
                    "clone",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_tuple_field (|
                            M.deref (| M.read (| self |) |),
                            "alloy_primitives::bits::address::AddressChecksumBuffer",
                            0
                          |)
                        |)
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::clone::Clone"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [ ("clone", InstanceField.Method clone) ].
    End Impl_core_clone_Clone_for_alloy_primitives_bits_address_AddressChecksumBuffer.
    
    Module Impl_core_fmt_Debug_for_alloy_primitives_bits_address_AddressChecksumBuffer.
      Definition Self : Ty.t := Ty.path "alloy_primitives::bits::address::AddressChecksumBuffer".
      
      (*
          fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
              self.as_str().fmt(f)
          }
      *)
      Definition fmt (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; f ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply
                  (Ty.path "&")
                  []
                  [ Ty.path "alloy_primitives::bits::address::AddressChecksumBuffer" ],
                self
              |) in
            let f :=
              M.alloc (| Ty.apply (Ty.path "&mut") [] [ Ty.path "core::fmt::Formatter" ], f |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "core::result::Result")
                []
                [ Ty.tuple []; Ty.path "core::fmt::Error" ],
              M.get_trait_method (| "core::fmt::Debug", Ty.path "str", [], [], "fmt", [], [] |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.call_closure (|
                      Ty.apply (Ty.path "&") [] [ Ty.path "str" ],
                      M.get_associated_function (|
                        Ty.path "alloy_primitives::bits::address::AddressChecksumBuffer",
                        "as_str",
                        [],
                        []
                      |),
                      [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                    |)
                  |)
                |);
                M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::Debug"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
    End Impl_core_fmt_Debug_for_alloy_primitives_bits_address_AddressChecksumBuffer.
    
    Module Impl_core_fmt_Display_for_alloy_primitives_bits_address_AddressChecksumBuffer.
      Definition Self : Ty.t := Ty.path "alloy_primitives::bits::address::AddressChecksumBuffer".
      
      (*
          fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
              self.as_str().fmt(f)
          }
      *)
      Definition fmt (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; f ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply
                  (Ty.path "&")
                  []
                  [ Ty.path "alloy_primitives::bits::address::AddressChecksumBuffer" ],
                self
              |) in
            let f :=
              M.alloc (| Ty.apply (Ty.path "&mut") [] [ Ty.path "core::fmt::Formatter" ], f |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "core::result::Result")
                []
                [ Ty.tuple []; Ty.path "core::fmt::Error" ],
              M.get_trait_method (| "core::fmt::Display", Ty.path "str", [], [], "fmt", [], [] |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.call_closure (|
                      Ty.apply (Ty.path "&") [] [ Ty.path "str" ],
                      M.get_associated_function (|
                        Ty.path "alloy_primitives::bits::address::AddressChecksumBuffer",
                        "as_str",
                        [],
                        []
                      |),
                      [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                    |)
                  |)
                |);
                M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::Display"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
    End Impl_core_fmt_Display_for_alloy_primitives_bits_address_AddressChecksumBuffer.
    
    Module Impl_alloy_primitives_bits_address_AddressChecksumBuffer.
      Definition Self : Ty.t := Ty.path "alloy_primitives::bits::address::AddressChecksumBuffer".
      
      (*
          pub const unsafe fn new() -> Self {
              Self(MaybeUninit::uninit())
          }
      *)
      Definition new (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [] =>
          ltac:(M.monadic
            (Value.StructTuple
              "alloy_primitives::bits::address::AddressChecksumBuffer"
              []
              []
              [
                M.call_closure (|
                  Ty.apply
                    (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                    []
                    [
                      Ty.apply
                        (Ty.path "array")
                        [ Value.Integer IntegerKind.Usize 42 ]
                        [ Ty.path "u8" ]
                    ],
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                      []
                      [
                        Ty.apply
                          (Ty.path "array")
                          [ Value.Integer IntegerKind.Usize 42 ]
                          [ Ty.path "u8" ]
                      ],
                    "uninit",
                    [],
                    []
                  |),
                  []
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_new : M.IsAssociatedFunction.C Self "new" new.
      Admitted.
      Global Typeclasses Opaque new.
      
      (*
          pub fn format(&mut self, address: &Address, chain_id: Option<u64>) -> &mut str {
              address.to_checksum_inner(unsafe { self.0.assume_init_mut() }, chain_id);
              self.as_mut_str()
          }
      *)
      Definition format (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; address; chain_id ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply
                  (Ty.path "&mut")
                  []
                  [ Ty.path "alloy_primitives::bits::address::AddressChecksumBuffer" ],
                self
              |) in
            let address :=
              M.alloc (|
                Ty.apply (Ty.path "&") [] [ Ty.path "alloy_primitives::bits::address::Address" ],
                address
              |) in
            let chain_id :=
              M.alloc (|
                Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "u64" ],
                chain_id
              |) in
            M.borrow (|
              Pointer.Kind.MutRef,
              M.deref (|
                M.read (|
                  let~ _ : Ty.tuple [] :=
                    M.call_closure (|
                      Ty.tuple [],
                      M.get_associated_function (|
                        Ty.path "alloy_primitives::bits::address::Address",
                        "to_checksum_inner",
                        [],
                        []
                      |),
                      [
                        M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| address |) |) |);
                        M.borrow (|
                          Pointer.Kind.MutRef,
                          M.deref (|
                            M.borrow (|
                              Pointer.Kind.MutRef,
                              M.deref (|
                                M.call_closure (|
                                  Ty.apply
                                    (Ty.path "&mut")
                                    []
                                    [
                                      Ty.apply
                                        (Ty.path "array")
                                        [ Value.Integer IntegerKind.Usize 42 ]
                                        [ Ty.path "u8" ]
                                    ],
                                  M.get_associated_function (|
                                    Ty.apply
                                      (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                      []
                                      [
                                        Ty.apply
                                          (Ty.path "array")
                                          [ Value.Integer IntegerKind.Usize 42 ]
                                          [ Ty.path "u8" ]
                                      ],
                                    "assume_init_mut",
                                    [],
                                    []
                                  |),
                                  [
                                    M.borrow (|
                                      Pointer.Kind.MutRef,
                                      M.SubPointer.get_struct_tuple_field (|
                                        M.deref (| M.read (| self |) |),
                                        "alloy_primitives::bits::address::AddressChecksumBuffer",
                                        0
                                      |)
                                    |)
                                  ]
                                |)
                              |)
                            |)
                          |)
                        |);
                        M.read (| chain_id |)
                      ]
                    |) in
                  M.alloc (|
                    Ty.apply (Ty.path "&mut") [] [ Ty.path "str" ],
                    M.borrow (|
                      Pointer.Kind.MutRef,
                      M.deref (|
                        M.call_closure (|
                          Ty.apply (Ty.path "&mut") [] [ Ty.path "str" ],
                          M.get_associated_function (|
                            Ty.path "alloy_primitives::bits::address::AddressChecksumBuffer",
                            "as_mut_str",
                            [],
                            []
                          |),
                          [ M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |) ]
                        |)
                      |)
                    |)
                  |)
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_format : M.IsAssociatedFunction.C Self "format" format.
      Admitted.
      Global Typeclasses Opaque format.
      
      (*
          pub const fn as_str(&self) -> &str {
              unsafe { str::from_utf8_unchecked(self.0.assume_init_ref()) }
          }
      *)
      Definition as_str (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply
                  (Ty.path "&")
                  []
                  [ Ty.path "alloy_primitives::bits::address::AddressChecksumBuffer" ],
                self
              |) in
            M.borrow (|
              Pointer.Kind.Ref,
              M.deref (|
                M.call_closure (|
                  Ty.apply (Ty.path "&") [] [ Ty.path "str" ],
                  M.get_function (| "core::str::converts::from_utf8_unchecked", [], [] |),
                  [
                    (* Unsize *)
                    M.pointer_coercion
                      (M.borrow (|
                        Pointer.Kind.Ref,
                        M.deref (|
                          M.call_closure (|
                            Ty.apply
                              (Ty.path "&")
                              []
                              [
                                Ty.apply
                                  (Ty.path "array")
                                  [ Value.Integer IntegerKind.Usize 42 ]
                                  [ Ty.path "u8" ]
                              ],
                            M.get_associated_function (|
                              Ty.apply
                                (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                []
                                [
                                  Ty.apply
                                    (Ty.path "array")
                                    [ Value.Integer IntegerKind.Usize 42 ]
                                    [ Ty.path "u8" ]
                                ],
                              "assume_init_ref",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.SubPointer.get_struct_tuple_field (|
                                  M.deref (| M.read (| self |) |),
                                  "alloy_primitives::bits::address::AddressChecksumBuffer",
                                  0
                                |)
                              |)
                            ]
                          |)
                        |)
                      |))
                  ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_as_str : M.IsAssociatedFunction.C Self "as_str" as_str.
      Admitted.
      Global Typeclasses Opaque as_str.
      
      (*
          pub fn as_mut_str(&mut self) -> &mut str {
              unsafe { str::from_utf8_unchecked_mut(self.0.assume_init_mut()) }
          }
      *)
      Definition as_mut_str (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply
                  (Ty.path "&mut")
                  []
                  [ Ty.path "alloy_primitives::bits::address::AddressChecksumBuffer" ],
                self
              |) in
            M.borrow (|
              Pointer.Kind.MutRef,
              M.deref (|
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.MutRef,
                      M.deref (|
                        M.call_closure (|
                          Ty.apply (Ty.path "&mut") [] [ Ty.path "str" ],
                          M.get_function (|
                            "core::str::converts::from_utf8_unchecked_mut",
                            [],
                            []
                          |),
                          [
                            (* Unsize *)
                            M.pointer_coercion
                              (M.borrow (|
                                Pointer.Kind.MutRef,
                                M.deref (|
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "&mut")
                                      []
                                      [
                                        Ty.apply
                                          (Ty.path "array")
                                          [ Value.Integer IntegerKind.Usize 42 ]
                                          [ Ty.path "u8" ]
                                      ],
                                    M.get_associated_function (|
                                      Ty.apply
                                        (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                        []
                                        [
                                          Ty.apply
                                            (Ty.path "array")
                                            [ Value.Integer IntegerKind.Usize 42 ]
                                            [ Ty.path "u8" ]
                                        ],
                                      "assume_init_mut",
                                      [],
                                      []
                                    |),
                                    [
                                      M.borrow (|
                                        Pointer.Kind.MutRef,
                                        M.SubPointer.get_struct_tuple_field (|
                                          M.deref (| M.read (| self |) |),
                                          "alloy_primitives::bits::address::AddressChecksumBuffer",
                                          0
                                        |)
                                      |)
                                    ]
                                  |)
                                |)
                              |))
                          ]
                        |)
                      |)
                    |)
                  |)
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_as_mut_str :
        M.IsAssociatedFunction.C Self "as_mut_str" as_mut_str.
      Admitted.
      Global Typeclasses Opaque as_mut_str.
      
      (*
          pub fn to_string(&self) -> String {
              self.as_str().to_string()
          }
      *)
      Definition to_string (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply
                  (Ty.path "&")
                  []
                  [ Ty.path "alloy_primitives::bits::address::AddressChecksumBuffer" ],
                self
              |) in
            M.call_closure (|
              Ty.path "alloc::string::String",
              M.get_trait_method (|
                "alloc::string::ToString",
                Ty.path "str",
                [],
                [],
                "to_string",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.call_closure (|
                      Ty.apply (Ty.path "&") [] [ Ty.path "str" ],
                      M.get_associated_function (|
                        Ty.path "alloy_primitives::bits::address::AddressChecksumBuffer",
                        "as_str",
                        [],
                        []
                      |),
                      [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                    |)
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_to_string :
        M.IsAssociatedFunction.C Self "to_string" to_string.
      Admitted.
      Global Typeclasses Opaque to_string.
      
      (*
          pub const fn into_inner(self) -> [u8; 42] {
              unsafe { self.0.assume_init() }
          }
      *)
      Definition into_inner (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.path "alloy_primitives::bits::address::AddressChecksumBuffer",
                self
              |) in
            M.call_closure (|
              Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 42 ] [ Ty.path "u8" ],
              M.get_associated_function (|
                Ty.apply
                  (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                  []
                  [
                    Ty.apply
                      (Ty.path "array")
                      [ Value.Integer IntegerKind.Usize 42 ]
                      [ Ty.path "u8" ]
                  ],
                "assume_init",
                [],
                []
              |),
              [
                M.read (|
                  M.SubPointer.get_struct_tuple_field (|
                    self,
                    "alloy_primitives::bits::address::AddressChecksumBuffer",
                    0
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_into_inner :
        M.IsAssociatedFunction.C Self "into_inner" into_inner.
      Admitted.
      Global Typeclasses Opaque into_inner.
    End Impl_alloy_primitives_bits_address_AddressChecksumBuffer.
  End address.
End bits.
