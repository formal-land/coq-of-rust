(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module bits.
  Module bloom.
    Definition value_BLOOM_BITS_PER_ITEM
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      ltac:(M.monadic (M.alloc (| Value.Integer IntegerKind.Usize 3 |))).
    
    Global Instance Instance_IsConstant_value_BLOOM_BITS_PER_ITEM :
      M.IsFunction.C "alloy_primitives::bits::bloom::BLOOM_BITS_PER_ITEM" value_BLOOM_BITS_PER_ITEM.
    Admitted.
    Global Typeclasses Opaque value_BLOOM_BITS_PER_ITEM.
    
    Definition value_BLOOM_SIZE_BYTES (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      ltac:(M.monadic (M.alloc (| Value.Integer IntegerKind.Usize 256 |))).
    
    Global Instance Instance_IsConstant_value_BLOOM_SIZE_BYTES :
      M.IsFunction.C "alloy_primitives::bits::bloom::BLOOM_SIZE_BYTES" value_BLOOM_SIZE_BYTES.
    Admitted.
    Global Typeclasses Opaque value_BLOOM_SIZE_BYTES.
    
    Definition value_BLOOM_SIZE_BITS (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      ltac:(M.monadic
        (M.alloc (|
          M.call_closure (|
            Ty.path "usize",
            BinOp.Wrap.mul,
            [
              M.read (|
                get_constant (|
                  "alloy_primitives::bits::bloom::BLOOM_SIZE_BYTES",
                  Ty.path "usize"
                |)
              |);
              Value.Integer IntegerKind.Usize 8
            ]
          |)
        |))).
    
    Global Instance Instance_IsConstant_value_BLOOM_SIZE_BITS :
      M.IsFunction.C "alloy_primitives::bits::bloom::BLOOM_SIZE_BITS" value_BLOOM_SIZE_BITS.
    Admitted.
    Global Typeclasses Opaque value_BLOOM_SIZE_BITS.
    
    Definition value_MASK (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      ltac:(M.monadic
        (M.alloc (|
          M.call_closure (|
            Ty.path "usize",
            BinOp.Wrap.sub,
            [
              M.read (|
                get_constant (| "alloy_primitives::bits::bloom::BLOOM_SIZE_BITS", Ty.path "usize" |)
              |);
              Value.Integer IntegerKind.Usize 1
            ]
          |)
        |))).
    
    Global Instance Instance_IsConstant_value_MASK :
      M.IsFunction.C "alloy_primitives::bits::bloom::MASK" value_MASK.
    Admitted.
    Global Typeclasses Opaque value_MASK.
    
    Definition value_ITEM_BYTES (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      ltac:(M.monadic
        (M.alloc (|
          M.call_closure (|
            Ty.path "usize",
            BinOp.Wrap.div,
            [
              M.call_closure (|
                Ty.path "usize",
                BinOp.Wrap.add,
                [
                  M.cast
                    (Ty.path "usize")
                    (M.call_closure (|
                      Ty.path "u32",
                      M.get_associated_function (| Ty.path "usize", "ilog2", [], [] |),
                      [
                        M.read (|
                          get_constant (|
                            "alloy_primitives::bits::bloom::BLOOM_SIZE_BITS",
                            Ty.path "usize"
                          |)
                        |)
                      ]
                    |));
                  Value.Integer IntegerKind.Usize 7
                ]
              |);
              Value.Integer IntegerKind.Usize 8
            ]
          |)
        |))).
    
    Global Instance Instance_IsConstant_value_ITEM_BYTES :
      M.IsFunction.C "alloy_primitives::bits::bloom::ITEM_BYTES" value_ITEM_BYTES.
    Admitted.
    Global Typeclasses Opaque value_ITEM_BYTES.
    
    (*
    Enum BloomInput
    {
      const_params := [];
      ty_params := [];
      variants :=
        [
          {
            name := "Raw";
            item :=
              StructTuple
                [ Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ] ];
          };
          {
            name := "Hash";
            item :=
              StructTuple
                [
                  Ty.apply
                    (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                    [ Value.Integer IntegerKind.Usize 32 ]
                    []
                ];
          }
        ];
    }
    *)
    
    Axiom IsDiscriminant_BloomInput_Raw :
      M.IsDiscriminant "alloy_primitives::bits::bloom::BloomInput::Raw" 0.
    Axiom IsDiscriminant_BloomInput_Hash :
      M.IsDiscriminant "alloy_primitives::bits::bloom::BloomInput::Hash" 1.
    
    Module Impl_core_clone_Clone_for_alloy_primitives_bits_bloom_BloomInput.
      Definition Self : Ty.t := Ty.path "alloy_primitives::bits::bloom::BloomInput".
      
      (* Clone *)
      Definition clone (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                Some
                  (Ty.apply
                    (Ty.path "*")
                    []
                    [ Ty.path "alloy_primitives::bits::bloom::BloomInput" ]),
                Value.DeclaredButUndefined,
                [
                  fun γ =>
                    ltac:(M.monadic
                      (M.match_operator (|
                        Some
                          (Ty.apply
                            (Ty.path "*")
                            []
                            [ Ty.path "alloy_primitives::bits::bloom::BloomInput" ]),
                        Value.DeclaredButUndefined,
                        [ fun γ => ltac:(M.monadic (M.deref (| M.read (| self |) |))) ]
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::clone::Clone"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [ ("clone", InstanceField.Method clone) ].
    End Impl_core_clone_Clone_for_alloy_primitives_bits_bloom_BloomInput.
    
    Module Impl_core_marker_Copy_for_alloy_primitives_bits_bloom_BloomInput.
      Definition Self : Ty.t := Ty.path "alloy_primitives::bits::bloom::BloomInput".
      
      Axiom Implements :
        M.IsTraitInstance
          "core::marker::Copy"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [].
    End Impl_core_marker_Copy_for_alloy_primitives_bits_bloom_BloomInput.
    
    Module Impl_core_fmt_Debug_for_alloy_primitives_bits_bloom_BloomInput.
      Definition Self : Ty.t := Ty.path "alloy_primitives::bits::bloom::BloomInput".
      
      (* Debug *)
      Definition fmt (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.read (|
              M.match_operator (|
                Some
                  (Ty.apply
                    (Ty.path "*")
                    []
                    [
                      Ty.apply
                        (Ty.path "core::result::Result")
                        []
                        [ Ty.tuple []; Ty.path "core::fmt::Error" ]
                    ]),
                self,
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.read (| γ |) in
                      let γ1_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "alloy_primitives::bits::bloom::BloomInput::Raw",
                          0
                        |) in
                      let __self_0 := M.alloc (| γ1_0 |) in
                      M.alloc (|
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "core::result::Result")
                            []
                            [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                          M.get_associated_function (|
                            Ty.path "core::fmt::Formatter",
                            "debug_tuple_field1_finish",
                            [],
                            []
                          |),
                          [
                            M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                            M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "Raw" |) |) |);
                            (* Unsize *)
                            M.pointer_coercion
                              (M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (| M.borrow (| Pointer.Kind.Ref, __self_0 |) |)
                              |))
                          ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.read (| γ |) in
                      let γ1_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "alloy_primitives::bits::bloom::BloomInput::Hash",
                          0
                        |) in
                      let __self_0 := M.alloc (| γ1_0 |) in
                      M.alloc (|
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "core::result::Result")
                            []
                            [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                          M.get_associated_function (|
                            Ty.path "core::fmt::Formatter",
                            "debug_tuple_field1_finish",
                            [],
                            []
                          |),
                          [
                            M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                            M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "Hash" |) |) |);
                            (* Unsize *)
                            M.pointer_coercion
                              (M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (| M.borrow (| Pointer.Kind.Ref, __self_0 |) |)
                              |))
                          ]
                        |)
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::Debug"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
    End Impl_core_fmt_Debug_for_alloy_primitives_bits_bloom_BloomInput.
    
    Module Impl_alloy_primitives_bits_bloom_BloomInput.
      Definition Self : Ty.t := Ty.path "alloy_primitives::bits::bloom::BloomInput".
      
      (*
          pub fn into_hash(self) -> B256 {
              match self {
                  BloomInput::Raw(raw) => keccak256(raw),
                  BloomInput::Hash(hash) => hash,
              }
          }
      *)
      Definition into_hash (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                Some
                  (Ty.apply
                    (Ty.path "*")
                    []
                    [
                      Ty.apply
                        (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                        [ Value.Integer IntegerKind.Usize 32 ]
                        []
                    ]),
                self,
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "alloy_primitives::bits::bloom::BloomInput::Raw",
                          0
                        |) in
                      let raw := M.copy (| γ0_0 |) in
                      M.alloc (|
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                            [ Value.Integer IntegerKind.Usize 32 ]
                            [],
                          M.get_function (|
                            "alloy_primitives::utils::keccak256",
                            [],
                            [
                              Ty.apply
                                (Ty.path "&")
                                []
                                [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
                            ]
                          |),
                          [ M.read (| raw |) ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "alloy_primitives::bits::bloom::BloomInput::Hash",
                          0
                        |) in
                      let hash := M.copy (| γ0_0 |) in
                      hash))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_into_hash :
        M.IsAssociatedFunction.C Self "into_hash" into_hash.
      Admitted.
      Global Typeclasses Opaque into_hash.
    End Impl_alloy_primitives_bits_bloom_BloomInput.
    
    Module Impl_core_convert_From_alloy_primitives_bits_bloom_BloomInput_for_alloy_primitives_bits_bloom_Bloom.
      Definition Self : Ty.t := Ty.path "alloy_primitives::bits::bloom::Bloom".
      
      (*
          fn from(input: BloomInput<'_>) -> Self {
              let mut bloom = Self::ZERO;
              bloom.accrue(input);
              bloom
          }
      *)
      Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ input ] =>
          ltac:(M.monadic
            (let input := M.alloc (| input |) in
            M.read (|
              let~ bloom :
                  Ty.apply (Ty.path "*") [] [ Ty.path "alloy_primitives::bits::bloom::Bloom" ] :=
                M.copy (|
                  get_associated_constant (|
                    Ty.path "alloy_primitives::bits::bloom::Bloom",
                    "ZERO",
                    Ty.path "alloy_primitives::bits::bloom::Bloom"
                  |)
                |) in
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.call_closure (|
                    Ty.tuple [],
                    M.get_associated_function (|
                      Ty.path "alloy_primitives::bits::bloom::Bloom",
                      "accrue",
                      [],
                      []
                    |),
                    [ M.borrow (| Pointer.Kind.MutRef, bloom |); M.read (| input |) ]
                  |)
                |) in
              bloom
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "alloy_primitives::bits::bloom::BloomInput" ]
          Self
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_alloy_primitives_bits_bloom_BloomInput_for_alloy_primitives_bits_bloom_Bloom.
    
    Module Impl_core_iter_traits_collect_FromIterator_ref__Tuple_alloy_primitives_bits_address_Address_alloy_primitives_log_LogData__for_alloy_primitives_bits_bloom_Bloom.
      Definition Self : Ty.t := Ty.path "alloy_primitives::bits::bloom::Bloom".
      
      (*
          fn from_iter<T: IntoIterator<Item = &'a (Address, LogData)>>(iter: T) -> Self {
              let mut bloom = Self::ZERO;
              bloom.extend(iter);
              bloom
          }
      *)
      Definition from_iter (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [ T ], [ iter ] =>
          ltac:(M.monadic
            (let iter := M.alloc (| iter |) in
            M.read (|
              let~ bloom :
                  Ty.apply (Ty.path "*") [] [ Ty.path "alloy_primitives::bits::bloom::Bloom" ] :=
                M.copy (|
                  get_associated_constant (|
                    Ty.path "alloy_primitives::bits::bloom::Bloom",
                    "ZERO",
                    Ty.path "alloy_primitives::bits::bloom::Bloom"
                  |)
                |) in
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.call_closure (|
                    Ty.tuple [],
                    M.get_trait_method (|
                      "core::iter::traits::collect::Extend",
                      Ty.path "alloy_primitives::bits::bloom::Bloom",
                      [],
                      [
                        Ty.apply
                          (Ty.path "&")
                          []
                          [
                            Ty.tuple
                              [
                                Ty.path "alloy_primitives::bits::address::Address";
                                Ty.path "alloy_primitives::log::LogData"
                              ]
                          ]
                      ],
                      "extend",
                      [],
                      [ T ]
                    |),
                    [ M.borrow (| Pointer.Kind.MutRef, bloom |); M.read (| iter |) ]
                  |)
                |) in
              bloom
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::iter::traits::collect::FromIterator"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [
            Ty.apply
              (Ty.path "&")
              []
              [
                Ty.tuple
                  [
                    Ty.path "alloy_primitives::bits::address::Address";
                    Ty.path "alloy_primitives::log::LogData"
                  ]
              ]
          ]
          Self
          (* Instance *) [ ("from_iter", InstanceField.Method from_iter) ].
    End Impl_core_iter_traits_collect_FromIterator_ref__Tuple_alloy_primitives_bits_address_Address_alloy_primitives_log_LogData__for_alloy_primitives_bits_bloom_Bloom.
    
    Module Impl_core_iter_traits_collect_Extend_ref__Tuple_alloy_primitives_bits_address_Address_alloy_primitives_log_LogData__for_alloy_primitives_bits_bloom_Bloom.
      Definition Self : Ty.t := Ty.path "alloy_primitives::bits::bloom::Bloom".
      
      (*
          fn extend<T: IntoIterator<Item = &'a (Address, LogData)>>(&mut self, iter: T) {
              for (address, log_data) in iter {
                  self.accrue_raw_log( *address, log_data.topics())
              }
          }
      *)
      Definition extend (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [ T ], [ self; iter ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let iter := M.alloc (| iter |) in
            M.read (|
              M.use
                (M.match_operator (|
                  Some (Ty.apply (Ty.path "*") [] [ Ty.tuple [] ]),
                  M.alloc (|
                    M.call_closure (|
                      Ty.associated_in_trait
                        "core::iter::traits::collect::IntoIterator"
                        []
                        []
                        T
                        "IntoIter",
                      M.get_trait_method (|
                        "core::iter::traits::collect::IntoIterator",
                        T,
                        [],
                        [],
                        "into_iter",
                        [],
                        []
                      |),
                      [ M.read (| iter |) ]
                    |)
                  |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let iter := M.copy (| γ |) in
                        M.loop (|
                          Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                          ltac:(M.monadic
                            (let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                              M.match_operator (|
                                Some (Ty.apply (Ty.path "*") [] [ Ty.tuple [] ]),
                                M.alloc (|
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "core::option::Option")
                                      []
                                      [
                                        Ty.apply
                                          (Ty.path "&")
                                          []
                                          [
                                            Ty.tuple
                                              [
                                                Ty.path "alloy_primitives::bits::address::Address";
                                                Ty.path "alloy_primitives::log::LogData"
                                              ]
                                          ]
                                      ],
                                    M.get_trait_method (|
                                      "core::iter::traits::iterator::Iterator",
                                      Ty.associated_in_trait
                                        "core::iter::traits::collect::IntoIterator"
                                        []
                                        []
                                        T
                                        "IntoIter",
                                      [],
                                      [],
                                      "next",
                                      [],
                                      []
                                    |),
                                    [
                                      M.borrow (|
                                        Pointer.Kind.MutRef,
                                        M.deref (| M.borrow (| Pointer.Kind.MutRef, iter |) |)
                                      |)
                                    ]
                                  |)
                                |),
                                [
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let _ :=
                                        M.is_struct_tuple (| γ, "core::option::Option::None" |) in
                                      M.alloc (|
                                        M.never_to_any (| M.read (| M.break (||) |) |)
                                      |)));
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let γ0_0 :=
                                        M.SubPointer.get_struct_tuple_field (|
                                          γ,
                                          "core::option::Option::Some",
                                          0
                                        |) in
                                      let γ0_0 := M.read (| γ0_0 |) in
                                      let γ2_0 := M.SubPointer.get_tuple_field (| γ0_0, 0 |) in
                                      let γ2_1 := M.SubPointer.get_tuple_field (| γ0_0, 1 |) in
                                      let address := M.alloc (| γ2_0 |) in
                                      let log_data := M.alloc (| γ2_1 |) in
                                      M.alloc (|
                                        M.call_closure (|
                                          Ty.tuple [],
                                          M.get_associated_function (|
                                            Ty.path "alloy_primitives::bits::bloom::Bloom",
                                            "accrue_raw_log",
                                            [],
                                            []
                                          |),
                                          [
                                            M.borrow (|
                                              Pointer.Kind.MutRef,
                                              M.deref (| M.read (| self |) |)
                                            |);
                                            M.read (| M.deref (| M.read (| address |) |) |);
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.deref (|
                                                M.call_closure (|
                                                  Ty.apply
                                                    (Ty.path "&")
                                                    []
                                                    [
                                                      Ty.apply
                                                        (Ty.path "slice")
                                                        []
                                                        [
                                                          Ty.apply
                                                            (Ty.path
                                                              "alloy_primitives::bits::fixed::FixedBytes")
                                                            [ Value.Integer IntegerKind.Usize 32 ]
                                                            []
                                                        ]
                                                    ],
                                                  M.get_associated_function (|
                                                    Ty.path "alloy_primitives::log::LogData",
                                                    "topics",
                                                    [],
                                                    []
                                                  |),
                                                  [
                                                    M.borrow (|
                                                      Pointer.Kind.Ref,
                                                      M.deref (| M.read (| log_data |) |)
                                                    |)
                                                  ]
                                                |)
                                              |)
                                            |)
                                          ]
                                        |)
                                      |)))
                                ]
                              |) in
                            M.alloc (| Value.Tuple [] |)))
                        |)))
                  ]
                |))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::iter::traits::collect::Extend"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [
            Ty.apply
              (Ty.path "&")
              []
              [
                Ty.tuple
                  [
                    Ty.path "alloy_primitives::bits::address::Address";
                    Ty.path "alloy_primitives::log::LogData"
                  ]
              ]
          ]
          Self
          (* Instance *) [ ("extend", InstanceField.Method extend) ].
    End Impl_core_iter_traits_collect_Extend_ref__Tuple_alloy_primitives_bits_address_Address_alloy_primitives_log_LogData__for_alloy_primitives_bits_bloom_Bloom.
    
    Module Impl_core_iter_traits_collect_FromIterator_ref__alloy_primitives_log_Log_alloy_primitives_log_LogData_for_alloy_primitives_bits_bloom_Bloom.
      Definition Self : Ty.t := Ty.path "alloy_primitives::bits::bloom::Bloom".
      
      (*
          fn from_iter<T: IntoIterator<Item = &'a Log>>(logs: T) -> Self {
              let mut bloom = Self::ZERO;
              bloom.extend(logs);
              bloom
          }
      *)
      Definition from_iter (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [ T ], [ logs ] =>
          ltac:(M.monadic
            (let logs := M.alloc (| logs |) in
            M.read (|
              let~ bloom :
                  Ty.apply (Ty.path "*") [] [ Ty.path "alloy_primitives::bits::bloom::Bloom" ] :=
                M.copy (|
                  get_associated_constant (|
                    Ty.path "alloy_primitives::bits::bloom::Bloom",
                    "ZERO",
                    Ty.path "alloy_primitives::bits::bloom::Bloom"
                  |)
                |) in
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.call_closure (|
                    Ty.tuple [],
                    M.get_trait_method (|
                      "core::iter::traits::collect::Extend",
                      Ty.path "alloy_primitives::bits::bloom::Bloom",
                      [],
                      [
                        Ty.apply
                          (Ty.path "&")
                          []
                          [
                            Ty.apply
                              (Ty.path "alloy_primitives::log::Log")
                              []
                              [ Ty.path "alloy_primitives::log::LogData" ]
                          ]
                      ],
                      "extend",
                      [],
                      [ T ]
                    |),
                    [ M.borrow (| Pointer.Kind.MutRef, bloom |); M.read (| logs |) ]
                  |)
                |) in
              bloom
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::iter::traits::collect::FromIterator"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [
            Ty.apply
              (Ty.path "&")
              []
              [
                Ty.apply
                  (Ty.path "alloy_primitives::log::Log")
                  []
                  [ Ty.path "alloy_primitives::log::LogData" ]
              ]
          ]
          Self
          (* Instance *) [ ("from_iter", InstanceField.Method from_iter) ].
    End Impl_core_iter_traits_collect_FromIterator_ref__alloy_primitives_log_Log_alloy_primitives_log_LogData_for_alloy_primitives_bits_bloom_Bloom.
    
    Module Impl_core_iter_traits_collect_Extend_ref__alloy_primitives_log_Log_alloy_primitives_log_LogData_for_alloy_primitives_bits_bloom_Bloom.
      Definition Self : Ty.t := Ty.path "alloy_primitives::bits::bloom::Bloom".
      
      (*
          fn extend<T: IntoIterator<Item = &'a Log>>(&mut self, logs: T) {
              for log in logs {
                  self.accrue_log(log)
              }
          }
      *)
      Definition extend (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [ T ], [ self; logs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let logs := M.alloc (| logs |) in
            M.read (|
              M.use
                (M.match_operator (|
                  Some (Ty.apply (Ty.path "*") [] [ Ty.tuple [] ]),
                  M.alloc (|
                    M.call_closure (|
                      Ty.associated_in_trait
                        "core::iter::traits::collect::IntoIterator"
                        []
                        []
                        T
                        "IntoIter",
                      M.get_trait_method (|
                        "core::iter::traits::collect::IntoIterator",
                        T,
                        [],
                        [],
                        "into_iter",
                        [],
                        []
                      |),
                      [ M.read (| logs |) ]
                    |)
                  |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let iter := M.copy (| γ |) in
                        M.loop (|
                          Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                          ltac:(M.monadic
                            (let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                              M.match_operator (|
                                Some (Ty.apply (Ty.path "*") [] [ Ty.tuple [] ]),
                                M.alloc (|
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "core::option::Option")
                                      []
                                      [
                                        Ty.apply
                                          (Ty.path "&")
                                          []
                                          [
                                            Ty.apply
                                              (Ty.path "alloy_primitives::log::Log")
                                              []
                                              [ Ty.path "alloy_primitives::log::LogData" ]
                                          ]
                                      ],
                                    M.get_trait_method (|
                                      "core::iter::traits::iterator::Iterator",
                                      Ty.associated_in_trait
                                        "core::iter::traits::collect::IntoIterator"
                                        []
                                        []
                                        T
                                        "IntoIter",
                                      [],
                                      [],
                                      "next",
                                      [],
                                      []
                                    |),
                                    [
                                      M.borrow (|
                                        Pointer.Kind.MutRef,
                                        M.deref (| M.borrow (| Pointer.Kind.MutRef, iter |) |)
                                      |)
                                    ]
                                  |)
                                |),
                                [
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let _ :=
                                        M.is_struct_tuple (| γ, "core::option::Option::None" |) in
                                      M.alloc (|
                                        M.never_to_any (| M.read (| M.break (||) |) |)
                                      |)));
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let γ0_0 :=
                                        M.SubPointer.get_struct_tuple_field (|
                                          γ,
                                          "core::option::Option::Some",
                                          0
                                        |) in
                                      let log := M.copy (| γ0_0 |) in
                                      M.alloc (|
                                        M.call_closure (|
                                          Ty.tuple [],
                                          M.get_associated_function (|
                                            Ty.path "alloy_primitives::bits::bloom::Bloom",
                                            "accrue_log",
                                            [],
                                            []
                                          |),
                                          [
                                            M.borrow (|
                                              Pointer.Kind.MutRef,
                                              M.deref (| M.read (| self |) |)
                                            |);
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.deref (| M.read (| log |) |)
                                            |)
                                          ]
                                        |)
                                      |)))
                                ]
                              |) in
                            M.alloc (| Value.Tuple [] |)))
                        |)))
                  ]
                |))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::iter::traits::collect::Extend"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [
            Ty.apply
              (Ty.path "&")
              []
              [
                Ty.apply
                  (Ty.path "alloy_primitives::log::Log")
                  []
                  [ Ty.path "alloy_primitives::log::LogData" ]
              ]
          ]
          Self
          (* Instance *) [ ("extend", InstanceField.Method extend) ].
    End Impl_core_iter_traits_collect_Extend_ref__alloy_primitives_log_Log_alloy_primitives_log_LogData_for_alloy_primitives_bits_bloom_Bloom.
    
    Module Impl_core_iter_traits_collect_FromIterator_ref__alloy_primitives_bits_bloom_BloomInput_for_alloy_primitives_bits_bloom_Bloom.
      Definition Self : Ty.t := Ty.path "alloy_primitives::bits::bloom::Bloom".
      
      (*
          fn from_iter<T: IntoIterator<Item = &'a BloomInput<'b>>>(inputs: T) -> Self {
              let mut bloom = Self::ZERO;
              bloom.extend(inputs);
              bloom
          }
      *)
      Definition from_iter (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [ T ], [ inputs ] =>
          ltac:(M.monadic
            (let inputs := M.alloc (| inputs |) in
            M.read (|
              let~ bloom :
                  Ty.apply (Ty.path "*") [] [ Ty.path "alloy_primitives::bits::bloom::Bloom" ] :=
                M.copy (|
                  get_associated_constant (|
                    Ty.path "alloy_primitives::bits::bloom::Bloom",
                    "ZERO",
                    Ty.path "alloy_primitives::bits::bloom::Bloom"
                  |)
                |) in
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.call_closure (|
                    Ty.tuple [],
                    M.get_trait_method (|
                      "core::iter::traits::collect::Extend",
                      Ty.path "alloy_primitives::bits::bloom::Bloom",
                      [],
                      [
                        Ty.apply
                          (Ty.path "&")
                          []
                          [ Ty.path "alloy_primitives::bits::bloom::BloomInput" ]
                      ],
                      "extend",
                      [],
                      [ T ]
                    |),
                    [ M.borrow (| Pointer.Kind.MutRef, bloom |); M.read (| inputs |) ]
                  |)
                |) in
              bloom
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::iter::traits::collect::FromIterator"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "&") [] [ Ty.path "alloy_primitives::bits::bloom::BloomInput" ] ]
          Self
          (* Instance *) [ ("from_iter", InstanceField.Method from_iter) ].
    End Impl_core_iter_traits_collect_FromIterator_ref__alloy_primitives_bits_bloom_BloomInput_for_alloy_primitives_bits_bloom_Bloom.
    
    Module Impl_core_iter_traits_collect_Extend_ref__alloy_primitives_bits_bloom_BloomInput_for_alloy_primitives_bits_bloom_Bloom.
      Definition Self : Ty.t := Ty.path "alloy_primitives::bits::bloom::Bloom".
      
      (*
          fn extend<T: IntoIterator<Item = &'a BloomInput<'b>>>(&mut self, inputs: T) {
              for input in inputs {
                  self.accrue( *input);
              }
          }
      *)
      Definition extend (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [ T ], [ self; inputs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let inputs := M.alloc (| inputs |) in
            M.read (|
              M.use
                (M.match_operator (|
                  Some (Ty.apply (Ty.path "*") [] [ Ty.tuple [] ]),
                  M.alloc (|
                    M.call_closure (|
                      Ty.associated_in_trait
                        "core::iter::traits::collect::IntoIterator"
                        []
                        []
                        T
                        "IntoIter",
                      M.get_trait_method (|
                        "core::iter::traits::collect::IntoIterator",
                        T,
                        [],
                        [],
                        "into_iter",
                        [],
                        []
                      |),
                      [ M.read (| inputs |) ]
                    |)
                  |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let iter := M.copy (| γ |) in
                        M.loop (|
                          Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                          ltac:(M.monadic
                            (let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                              M.match_operator (|
                                Some (Ty.apply (Ty.path "*") [] [ Ty.tuple [] ]),
                                M.alloc (|
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "core::option::Option")
                                      []
                                      [
                                        Ty.apply
                                          (Ty.path "&")
                                          []
                                          [ Ty.path "alloy_primitives::bits::bloom::BloomInput" ]
                                      ],
                                    M.get_trait_method (|
                                      "core::iter::traits::iterator::Iterator",
                                      Ty.associated_in_trait
                                        "core::iter::traits::collect::IntoIterator"
                                        []
                                        []
                                        T
                                        "IntoIter",
                                      [],
                                      [],
                                      "next",
                                      [],
                                      []
                                    |),
                                    [
                                      M.borrow (|
                                        Pointer.Kind.MutRef,
                                        M.deref (| M.borrow (| Pointer.Kind.MutRef, iter |) |)
                                      |)
                                    ]
                                  |)
                                |),
                                [
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let _ :=
                                        M.is_struct_tuple (| γ, "core::option::Option::None" |) in
                                      M.alloc (|
                                        M.never_to_any (| M.read (| M.break (||) |) |)
                                      |)));
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let γ0_0 :=
                                        M.SubPointer.get_struct_tuple_field (|
                                          γ,
                                          "core::option::Option::Some",
                                          0
                                        |) in
                                      let input := M.copy (| γ0_0 |) in
                                      let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                                        M.alloc (|
                                          M.call_closure (|
                                            Ty.tuple [],
                                            M.get_associated_function (|
                                              Ty.path "alloy_primitives::bits::bloom::Bloom",
                                              "accrue",
                                              [],
                                              []
                                            |),
                                            [
                                              M.borrow (|
                                                Pointer.Kind.MutRef,
                                                M.deref (| M.read (| self |) |)
                                              |);
                                              M.read (| M.deref (| M.read (| input |) |) |)
                                            ]
                                          |)
                                        |) in
                                      M.alloc (| Value.Tuple [] |)))
                                ]
                              |) in
                            M.alloc (| Value.Tuple [] |)))
                        |)))
                  ]
                |))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::iter::traits::collect::Extend"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "&") [] [ Ty.path "alloy_primitives::bits::bloom::BloomInput" ] ]
          Self
          (* Instance *) [ ("extend", InstanceField.Method extend) ].
    End Impl_core_iter_traits_collect_Extend_ref__alloy_primitives_bits_bloom_BloomInput_for_alloy_primitives_bits_bloom_Bloom.
    
    Module Impl_alloy_primitives_bits_bloom_Bloom.
      Definition Self : Ty.t := Ty.path "alloy_primitives::bits::bloom::Bloom".
      
      (*
          pub const fn data(&self) -> &[u8; BLOOM_SIZE_BYTES] {
              &self.0 .0
          }
      *)
      Definition data (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.borrow (|
              Pointer.Kind.Ref,
              M.deref (|
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.SubPointer.get_struct_tuple_field (|
                    M.SubPointer.get_struct_tuple_field (|
                      M.deref (| M.read (| self |) |),
                      "alloy_primitives::bits::bloom::Bloom",
                      0
                    |),
                    "alloy_primitives::bits::fixed::FixedBytes",
                    0
                  |)
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_data : M.IsAssociatedFunction.C Self "data" data.
      Admitted.
      Global Typeclasses Opaque data.
      
      (*
          pub fn data_mut(&mut self) -> &mut [u8; BLOOM_SIZE_BYTES] {
              &mut self.0 .0
          }
      *)
      Definition data_mut (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.borrow (|
              Pointer.Kind.MutRef,
              M.deref (|
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.MutRef,
                      M.SubPointer.get_struct_tuple_field (|
                        M.SubPointer.get_struct_tuple_field (|
                          M.deref (| M.read (| self |) |),
                          "alloy_primitives::bits::bloom::Bloom",
                          0
                        |),
                        "alloy_primitives::bits::fixed::FixedBytes",
                        0
                      |)
                    |)
                  |)
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_data_mut :
        M.IsAssociatedFunction.C Self "data_mut" data_mut.
      Admitted.
      Global Typeclasses Opaque data_mut.
      
      (*
          pub fn contains_input(&self, input: BloomInput<'_>) -> bool {
              self.contains(&input.into())
          }
      *)
      Definition contains_input (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; input ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let input := M.alloc (| input |) in
            M.call_closure (|
              Ty.path "bool",
              M.get_associated_function (|
                Ty.path "alloy_primitives::bits::bloom::Bloom",
                "contains",
                [],
                []
              |),
              [
                M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |);
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.alloc (|
                        M.call_closure (|
                          Ty.path "alloy_primitives::bits::bloom::Bloom",
                          M.get_trait_method (|
                            "core::convert::Into",
                            Ty.path "alloy_primitives::bits::bloom::BloomInput",
                            [],
                            [ Ty.path "alloy_primitives::bits::bloom::Bloom" ],
                            "into",
                            [],
                            []
                          |),
                          [ M.read (| input |) ]
                        |)
                      |)
                    |)
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_contains_input :
        M.IsAssociatedFunction.C Self "contains_input" contains_input.
      Admitted.
      Global Typeclasses Opaque contains_input.
      
      (*
          pub const fn const_contains(self, other: Self) -> bool {
              self.0.const_covers(other.0)
          }
      *)
      Definition const_contains (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              Ty.path "bool",
              M.get_associated_function (|
                Ty.apply
                  (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                  [ Value.Integer IntegerKind.Usize 256 ]
                  [],
                "const_covers",
                [],
                []
              |),
              [
                M.read (|
                  M.SubPointer.get_struct_tuple_field (|
                    self,
                    "alloy_primitives::bits::bloom::Bloom",
                    0
                  |)
                |);
                M.read (|
                  M.SubPointer.get_struct_tuple_field (|
                    other,
                    "alloy_primitives::bits::bloom::Bloom",
                    0
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_const_contains :
        M.IsAssociatedFunction.C Self "const_contains" const_contains.
      Admitted.
      Global Typeclasses Opaque const_contains.
      
      (*
          pub fn contains(&self, other: &Self) -> bool {
              self.0.covers(&other.0)
          }
      *)
      Definition contains (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              Ty.path "bool",
              M.get_associated_function (|
                Ty.apply
                  (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                  [ Value.Integer IntegerKind.Usize 256 ]
                  [],
                "covers",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.SubPointer.get_struct_tuple_field (|
                    M.deref (| M.read (| self |) |),
                    "alloy_primitives::bits::bloom::Bloom",
                    0
                  |)
                |);
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_tuple_field (|
                        M.deref (| M.read (| other |) |),
                        "alloy_primitives::bits::bloom::Bloom",
                        0
                      |)
                    |)
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_contains :
        M.IsAssociatedFunction.C Self "contains" contains.
      Admitted.
      Global Typeclasses Opaque contains.
      
      (*
          pub fn accrue(&mut self, input: BloomInput<'_>) {
              let hash = input.into_hash();
      
              let mut ptr = 0;
      
              for _ in 0..3 {
                  let mut index = 0_usize;
                  for _ in 0..ITEM_BYTES {
                      index = (index << 8) | hash[ptr] as usize;
                      ptr += 1;
                  }
                  index &= MASK;
                  self.0[BLOOM_SIZE_BYTES - 1 - index / 8] |= 1 << (index % 8);
              }
          }
      *)
      Definition accrue (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; input ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let input := M.alloc (| input |) in
            M.read (|
              let~ hash :
                  Ty.apply
                    (Ty.path "*")
                    []
                    [
                      Ty.apply
                        (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                        [ Value.Integer IntegerKind.Usize 32 ]
                        []
                    ] :=
                M.alloc (|
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                      [ Value.Integer IntegerKind.Usize 32 ]
                      [],
                    M.get_associated_function (|
                      Ty.path "alloy_primitives::bits::bloom::BloomInput",
                      "into_hash",
                      [],
                      []
                    |),
                    [ M.read (| input |) ]
                  |)
                |) in
              let~ ptr : Ty.apply (Ty.path "*") [] [ Ty.path "usize" ] :=
                M.alloc (| Value.Integer IntegerKind.Usize 0 |) in
              M.use
                (M.match_operator (|
                  Some (Ty.apply (Ty.path "*") [] [ Ty.tuple [] ]),
                  M.alloc (|
                    M.call_closure (|
                      Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "i32" ],
                      M.get_trait_method (|
                        "core::iter::traits::collect::IntoIterator",
                        Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "i32" ],
                        [],
                        [],
                        "into_iter",
                        [],
                        []
                      |),
                      [
                        Value.StructRecord
                          "core::ops::range::Range"
                          [
                            ("start", Value.Integer IntegerKind.I32 0);
                            ("end_", Value.Integer IntegerKind.I32 3)
                          ]
                      ]
                    |)
                  |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let iter := M.copy (| γ |) in
                        M.loop (|
                          Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                          ltac:(M.monadic
                            (let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                              M.match_operator (|
                                Some (Ty.apply (Ty.path "*") [] [ Ty.tuple [] ]),
                                M.alloc (|
                                  M.call_closure (|
                                    Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "i32" ],
                                    M.get_trait_method (|
                                      "core::iter::traits::iterator::Iterator",
                                      Ty.apply
                                        (Ty.path "core::ops::range::Range")
                                        []
                                        [ Ty.path "i32" ],
                                      [],
                                      [],
                                      "next",
                                      [],
                                      []
                                    |),
                                    [
                                      M.borrow (|
                                        Pointer.Kind.MutRef,
                                        M.deref (| M.borrow (| Pointer.Kind.MutRef, iter |) |)
                                      |)
                                    ]
                                  |)
                                |),
                                [
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let _ :=
                                        M.is_struct_tuple (| γ, "core::option::Option::None" |) in
                                      M.alloc (|
                                        M.never_to_any (| M.read (| M.break (||) |) |)
                                      |)));
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let γ0_0 :=
                                        M.SubPointer.get_struct_tuple_field (|
                                          γ,
                                          "core::option::Option::Some",
                                          0
                                        |) in
                                      let~ index : Ty.apply (Ty.path "*") [] [ Ty.path "usize" ] :=
                                        M.alloc (| Value.Integer IntegerKind.Usize 0 |) in
                                      let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                                        M.use
                                          (M.match_operator (|
                                            Some (Ty.apply (Ty.path "*") [] [ Ty.tuple [] ]),
                                            M.alloc (|
                                              M.call_closure (|
                                                Ty.apply
                                                  (Ty.path "core::ops::range::Range")
                                                  []
                                                  [ Ty.path "usize" ],
                                                M.get_trait_method (|
                                                  "core::iter::traits::collect::IntoIterator",
                                                  Ty.apply
                                                    (Ty.path "core::ops::range::Range")
                                                    []
                                                    [ Ty.path "usize" ],
                                                  [],
                                                  [],
                                                  "into_iter",
                                                  [],
                                                  []
                                                |),
                                                [
                                                  Value.StructRecord
                                                    "core::ops::range::Range"
                                                    [
                                                      ("start", Value.Integer IntegerKind.Usize 0);
                                                      ("end_",
                                                        M.read (|
                                                          get_constant (|
                                                            "alloy_primitives::bits::bloom::ITEM_BYTES",
                                                            Ty.path "usize"
                                                          |)
                                                        |))
                                                    ]
                                                ]
                                              |)
                                            |),
                                            [
                                              fun γ =>
                                                ltac:(M.monadic
                                                  (let iter := M.copy (| γ |) in
                                                  M.loop (|
                                                    Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                                                    ltac:(M.monadic
                                                      (let~ _ :
                                                          Ty.apply
                                                            (Ty.path "*")
                                                            []
                                                            [ Ty.tuple [] ] :=
                                                        M.match_operator (|
                                                          Some
                                                            (Ty.apply
                                                              (Ty.path "*")
                                                              []
                                                              [ Ty.tuple [] ]),
                                                          M.alloc (|
                                                            M.call_closure (|
                                                              Ty.apply
                                                                (Ty.path "core::option::Option")
                                                                []
                                                                [ Ty.path "usize" ],
                                                              M.get_trait_method (|
                                                                "core::iter::traits::iterator::Iterator",
                                                                Ty.apply
                                                                  (Ty.path
                                                                    "core::ops::range::Range")
                                                                  []
                                                                  [ Ty.path "usize" ],
                                                                [],
                                                                [],
                                                                "next",
                                                                [],
                                                                []
                                                              |),
                                                              [
                                                                M.borrow (|
                                                                  Pointer.Kind.MutRef,
                                                                  M.deref (|
                                                                    M.borrow (|
                                                                      Pointer.Kind.MutRef,
                                                                      iter
                                                                    |)
                                                                  |)
                                                                |)
                                                              ]
                                                            |)
                                                          |),
                                                          [
                                                            fun γ =>
                                                              ltac:(M.monadic
                                                                (let _ :=
                                                                  M.is_struct_tuple (|
                                                                    γ,
                                                                    "core::option::Option::None"
                                                                  |) in
                                                                M.alloc (|
                                                                  M.never_to_any (|
                                                                    M.read (| M.break (||) |)
                                                                  |)
                                                                |)));
                                                            fun γ =>
                                                              ltac:(M.monadic
                                                                (let γ0_0 :=
                                                                  M.SubPointer.get_struct_tuple_field (|
                                                                    γ,
                                                                    "core::option::Option::Some",
                                                                    0
                                                                  |) in
                                                                let~ _ :
                                                                    Ty.apply
                                                                      (Ty.path "*")
                                                                      []
                                                                      [ Ty.tuple [] ] :=
                                                                  M.alloc (|
                                                                    M.write (|
                                                                      index,
                                                                      M.call_closure (|
                                                                        Ty.path "usize",
                                                                        BinOp.Wrap.bit_or,
                                                                        [
                                                                          M.call_closure (|
                                                                            Ty.path "usize",
                                                                            BinOp.Wrap.shl,
                                                                            [
                                                                              M.read (| index |);
                                                                              Value.Integer
                                                                                IntegerKind.I32
                                                                                8
                                                                            ]
                                                                          |);
                                                                          M.cast
                                                                            (Ty.path "usize")
                                                                            (M.read (|
                                                                              M.deref (|
                                                                                M.call_closure (|
                                                                                  Ty.apply
                                                                                    (Ty.path "&")
                                                                                    []
                                                                                    [ Ty.path "u8"
                                                                                    ],
                                                                                  M.get_trait_method (|
                                                                                    "core::ops::index::Index",
                                                                                    Ty.apply
                                                                                      (Ty.path
                                                                                        "alloy_primitives::bits::fixed::FixedBytes")
                                                                                      [
                                                                                        Value.Integer
                                                                                          IntegerKind.Usize
                                                                                          32
                                                                                      ]
                                                                                      [],
                                                                                    [],
                                                                                    [
                                                                                      Ty.path
                                                                                        "usize"
                                                                                    ],
                                                                                    "index",
                                                                                    [],
                                                                                    []
                                                                                  |),
                                                                                  [
                                                                                    M.borrow (|
                                                                                      Pointer.Kind.Ref,
                                                                                      hash
                                                                                    |);
                                                                                    M.read (| ptr |)
                                                                                  ]
                                                                                |)
                                                                              |)
                                                                            |))
                                                                        ]
                                                                      |)
                                                                    |)
                                                                  |) in
                                                                let~ _ :
                                                                    Ty.apply
                                                                      (Ty.path "*")
                                                                      []
                                                                      [ Ty.tuple [] ] :=
                                                                  M.alloc (|
                                                                    let β := ptr in
                                                                    M.write (|
                                                                      β,
                                                                      M.call_closure (|
                                                                        Ty.path "usize",
                                                                        BinOp.Wrap.add,
                                                                        [
                                                                          M.read (| β |);
                                                                          Value.Integer
                                                                            IntegerKind.Usize
                                                                            1
                                                                        ]
                                                                      |)
                                                                    |)
                                                                  |) in
                                                                M.alloc (| Value.Tuple [] |)))
                                                          ]
                                                        |) in
                                                      M.alloc (| Value.Tuple [] |)))
                                                  |)))
                                            ]
                                          |)) in
                                      let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                                        M.alloc (|
                                          let β := index in
                                          M.write (|
                                            β,
                                            M.call_closure (|
                                              Ty.path "usize",
                                              BinOp.Wrap.bit_and,
                                              [
                                                M.read (| β |);
                                                M.read (|
                                                  get_constant (|
                                                    "alloy_primitives::bits::bloom::MASK",
                                                    Ty.path "usize"
                                                  |)
                                                |)
                                              ]
                                            |)
                                          |)
                                        |) in
                                      let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                                        M.alloc (|
                                          let β :=
                                            M.deref (|
                                              M.call_closure (|
                                                Ty.apply (Ty.path "&mut") [] [ Ty.path "u8" ],
                                                M.get_trait_method (|
                                                  "core::ops::index::IndexMut",
                                                  Ty.apply
                                                    (Ty.path
                                                      "alloy_primitives::bits::fixed::FixedBytes")
                                                    [ Value.Integer IntegerKind.Usize 256 ]
                                                    [],
                                                  [],
                                                  [ Ty.path "usize" ],
                                                  "index_mut",
                                                  [],
                                                  []
                                                |),
                                                [
                                                  M.borrow (|
                                                    Pointer.Kind.MutRef,
                                                    M.SubPointer.get_struct_tuple_field (|
                                                      M.deref (| M.read (| self |) |),
                                                      "alloy_primitives::bits::bloom::Bloom",
                                                      0
                                                    |)
                                                  |);
                                                  M.call_closure (|
                                                    Ty.path "usize",
                                                    BinOp.Wrap.sub,
                                                    [
                                                      M.call_closure (|
                                                        Ty.path "usize",
                                                        BinOp.Wrap.sub,
                                                        [
                                                          M.read (|
                                                            get_constant (|
                                                              "alloy_primitives::bits::bloom::BLOOM_SIZE_BYTES",
                                                              Ty.path "usize"
                                                            |)
                                                          |);
                                                          Value.Integer IntegerKind.Usize 1
                                                        ]
                                                      |);
                                                      M.call_closure (|
                                                        Ty.path "usize",
                                                        BinOp.Wrap.div,
                                                        [
                                                          M.read (| index |);
                                                          Value.Integer IntegerKind.Usize 8
                                                        ]
                                                      |)
                                                    ]
                                                  |)
                                                ]
                                              |)
                                            |) in
                                          M.write (|
                                            β,
                                            M.call_closure (|
                                              Ty.path "u8",
                                              BinOp.Wrap.bit_or,
                                              [
                                                M.read (| β |);
                                                M.call_closure (|
                                                  Ty.path "u8",
                                                  BinOp.Wrap.shl,
                                                  [
                                                    Value.Integer IntegerKind.U8 1;
                                                    M.call_closure (|
                                                      Ty.path "usize",
                                                      BinOp.Wrap.rem,
                                                      [
                                                        M.read (| index |);
                                                        Value.Integer IntegerKind.Usize 8
                                                      ]
                                                    |)
                                                  ]
                                                |)
                                              ]
                                            |)
                                          |)
                                        |) in
                                      M.alloc (| Value.Tuple [] |)))
                                ]
                              |) in
                            M.alloc (| Value.Tuple [] |)))
                        |)))
                  ]
                |))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_accrue : M.IsAssociatedFunction.C Self "accrue" accrue.
      Admitted.
      Global Typeclasses Opaque accrue.
      
      (*
          pub fn accrue_bloom(&mut self, bloom: &Self) {
              *self |= *bloom;
          }
      *)
      Definition accrue_bloom (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; bloom ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let bloom := M.alloc (| bloom |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.call_closure (|
                    Ty.tuple [],
                    M.get_trait_method (|
                      "core::ops::bit::BitOrAssign",
                      Ty.path "alloy_primitives::bits::bloom::Bloom",
                      [],
                      [ Ty.path "alloy_primitives::bits::bloom::Bloom" ],
                      "bitor_assign",
                      [],
                      []
                    |),
                    [
                      M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |);
                      M.read (| M.deref (| M.read (| bloom |) |) |)
                    ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_accrue_bloom :
        M.IsAssociatedFunction.C Self "accrue_bloom" accrue_bloom.
      Admitted.
      Global Typeclasses Opaque accrue_bloom.
      
      (*
          pub fn m3_2048(&mut self, bytes: &[u8]) {
              self.m3_2048_hashed(&keccak256(bytes));
          }
      *)
      Definition m3_2048 (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; bytes ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let bytes := M.alloc (| bytes |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.call_closure (|
                    Ty.tuple [],
                    M.get_associated_function (|
                      Ty.path "alloy_primitives::bits::bloom::Bloom",
                      "m3_2048_hashed",
                      [],
                      []
                    |),
                    [
                      M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |);
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.deref (|
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.alloc (|
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                                  [ Value.Integer IntegerKind.Usize 32 ]
                                  [],
                                M.get_function (|
                                  "alloy_primitives::utils::keccak256",
                                  [],
                                  [
                                    Ty.apply
                                      (Ty.path "&")
                                      []
                                      [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
                                  ]
                                |),
                                [ M.read (| bytes |) ]
                              |)
                            |)
                          |)
                        |)
                      |)
                    ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_m3_2048 : M.IsAssociatedFunction.C Self "m3_2048" m3_2048.
      Admitted.
      Global Typeclasses Opaque m3_2048.
      
      (*
          pub fn m3_2048_hashed(&mut self, hash: &B256) {
              for i in [0, 2, 4] {
                  let bit = (hash[i + 1] as usize + ((hash[i] as usize) << 8)) & 0x7FF;
                  self[BLOOM_SIZE_BYTES - 1 - bit / 8] |= 1 << (bit % 8);
              }
          }
      *)
      Definition m3_2048_hashed (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; hash ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let hash := M.alloc (| hash |) in
            M.read (|
              M.use
                (M.match_operator (|
                  Some (Ty.apply (Ty.path "*") [] [ Ty.tuple [] ]),
                  M.alloc (|
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "core::array::iter::IntoIter")
                        [ Value.Integer IntegerKind.Usize 3 ]
                        [ Ty.path "usize" ],
                      M.get_trait_method (|
                        "core::iter::traits::collect::IntoIterator",
                        Ty.apply
                          (Ty.path "array")
                          [ Value.Integer IntegerKind.Usize 3 ]
                          [ Ty.path "usize" ],
                        [],
                        [],
                        "into_iter",
                        [],
                        []
                      |),
                      [
                        Value.Array
                          [
                            Value.Integer IntegerKind.Usize 0;
                            Value.Integer IntegerKind.Usize 2;
                            Value.Integer IntegerKind.Usize 4
                          ]
                      ]
                    |)
                  |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let iter := M.copy (| γ |) in
                        M.loop (|
                          Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                          ltac:(M.monadic
                            (let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                              M.match_operator (|
                                Some (Ty.apply (Ty.path "*") [] [ Ty.tuple [] ]),
                                M.alloc (|
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "core::option::Option")
                                      []
                                      [ Ty.path "usize" ],
                                    M.get_trait_method (|
                                      "core::iter::traits::iterator::Iterator",
                                      Ty.apply
                                        (Ty.path "core::array::iter::IntoIter")
                                        [ Value.Integer IntegerKind.Usize 3 ]
                                        [ Ty.path "usize" ],
                                      [],
                                      [],
                                      "next",
                                      [],
                                      []
                                    |),
                                    [
                                      M.borrow (|
                                        Pointer.Kind.MutRef,
                                        M.deref (| M.borrow (| Pointer.Kind.MutRef, iter |) |)
                                      |)
                                    ]
                                  |)
                                |),
                                [
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let _ :=
                                        M.is_struct_tuple (| γ, "core::option::Option::None" |) in
                                      M.alloc (|
                                        M.never_to_any (| M.read (| M.break (||) |) |)
                                      |)));
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let γ0_0 :=
                                        M.SubPointer.get_struct_tuple_field (|
                                          γ,
                                          "core::option::Option::Some",
                                          0
                                        |) in
                                      let i := M.copy (| γ0_0 |) in
                                      let~ bit : Ty.apply (Ty.path "*") [] [ Ty.path "usize" ] :=
                                        M.alloc (|
                                          M.call_closure (|
                                            Ty.path "usize",
                                            BinOp.Wrap.bit_and,
                                            [
                                              M.call_closure (|
                                                Ty.path "usize",
                                                BinOp.Wrap.add,
                                                [
                                                  M.cast
                                                    (Ty.path "usize")
                                                    (M.read (|
                                                      M.deref (|
                                                        M.call_closure (|
                                                          Ty.apply
                                                            (Ty.path "&")
                                                            []
                                                            [ Ty.path "u8" ],
                                                          M.get_trait_method (|
                                                            "core::ops::index::Index",
                                                            Ty.apply
                                                              (Ty.path
                                                                "alloy_primitives::bits::fixed::FixedBytes")
                                                              [ Value.Integer IntegerKind.Usize 32 ]
                                                              [],
                                                            [],
                                                            [ Ty.path "usize" ],
                                                            "index",
                                                            [],
                                                            []
                                                          |),
                                                          [
                                                            M.borrow (|
                                                              Pointer.Kind.Ref,
                                                              M.deref (| M.read (| hash |) |)
                                                            |);
                                                            M.call_closure (|
                                                              Ty.path "usize",
                                                              BinOp.Wrap.add,
                                                              [
                                                                M.read (| i |);
                                                                Value.Integer IntegerKind.Usize 1
                                                              ]
                                                            |)
                                                          ]
                                                        |)
                                                      |)
                                                    |));
                                                  M.call_closure (|
                                                    Ty.path "usize",
                                                    BinOp.Wrap.shl,
                                                    [
                                                      M.cast
                                                        (Ty.path "usize")
                                                        (M.read (|
                                                          M.deref (|
                                                            M.call_closure (|
                                                              Ty.apply
                                                                (Ty.path "&")
                                                                []
                                                                [ Ty.path "u8" ],
                                                              M.get_trait_method (|
                                                                "core::ops::index::Index",
                                                                Ty.apply
                                                                  (Ty.path
                                                                    "alloy_primitives::bits::fixed::FixedBytes")
                                                                  [
                                                                    Value.Integer
                                                                      IntegerKind.Usize
                                                                      32
                                                                  ]
                                                                  [],
                                                                [],
                                                                [ Ty.path "usize" ],
                                                                "index",
                                                                [],
                                                                []
                                                              |),
                                                              [
                                                                M.borrow (|
                                                                  Pointer.Kind.Ref,
                                                                  M.deref (| M.read (| hash |) |)
                                                                |);
                                                                M.read (| i |)
                                                              ]
                                                            |)
                                                          |)
                                                        |));
                                                      Value.Integer IntegerKind.I32 8
                                                    ]
                                                  |)
                                                ]
                                              |);
                                              Value.Integer IntegerKind.Usize 2047
                                            ]
                                          |)
                                        |) in
                                      let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                                        M.alloc (|
                                          let β :=
                                            M.deref (|
                                              M.call_closure (|
                                                Ty.apply (Ty.path "&mut") [] [ Ty.path "u8" ],
                                                M.get_trait_method (|
                                                  "core::ops::index::IndexMut",
                                                  Ty.path "alloy_primitives::bits::bloom::Bloom",
                                                  [],
                                                  [ Ty.path "usize" ],
                                                  "index_mut",
                                                  [],
                                                  []
                                                |),
                                                [
                                                  M.borrow (|
                                                    Pointer.Kind.MutRef,
                                                    M.deref (| M.read (| self |) |)
                                                  |);
                                                  M.call_closure (|
                                                    Ty.path "usize",
                                                    BinOp.Wrap.sub,
                                                    [
                                                      M.call_closure (|
                                                        Ty.path "usize",
                                                        BinOp.Wrap.sub,
                                                        [
                                                          M.read (|
                                                            get_constant (|
                                                              "alloy_primitives::bits::bloom::BLOOM_SIZE_BYTES",
                                                              Ty.path "usize"
                                                            |)
                                                          |);
                                                          Value.Integer IntegerKind.Usize 1
                                                        ]
                                                      |);
                                                      M.call_closure (|
                                                        Ty.path "usize",
                                                        BinOp.Wrap.div,
                                                        [
                                                          M.read (| bit |);
                                                          Value.Integer IntegerKind.Usize 8
                                                        ]
                                                      |)
                                                    ]
                                                  |)
                                                ]
                                              |)
                                            |) in
                                          M.write (|
                                            β,
                                            M.call_closure (|
                                              Ty.path "u8",
                                              BinOp.Wrap.bit_or,
                                              [
                                                M.read (| β |);
                                                M.call_closure (|
                                                  Ty.path "u8",
                                                  BinOp.Wrap.shl,
                                                  [
                                                    Value.Integer IntegerKind.U8 1;
                                                    M.call_closure (|
                                                      Ty.path "usize",
                                                      BinOp.Wrap.rem,
                                                      [
                                                        M.read (| bit |);
                                                        Value.Integer IntegerKind.Usize 8
                                                      ]
                                                    |)
                                                  ]
                                                |)
                                              ]
                                            |)
                                          |)
                                        |) in
                                      M.alloc (| Value.Tuple [] |)))
                                ]
                              |) in
                            M.alloc (| Value.Tuple [] |)))
                        |)))
                  ]
                |))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_m3_2048_hashed :
        M.IsAssociatedFunction.C Self "m3_2048_hashed" m3_2048_hashed.
      Admitted.
      Global Typeclasses Opaque m3_2048_hashed.
      
      (*
          pub fn accrue_raw_log(&mut self, address: Address, topics: &[B256]) {
              self.m3_2048(address.as_slice());
              for topic in topics.iter() {
                  self.m3_2048(topic.as_slice());
              }
          }
      *)
      Definition accrue_raw_log (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; address; topics ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let address := M.alloc (| address |) in
            let topics := M.alloc (| topics |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.call_closure (|
                    Ty.tuple [],
                    M.get_associated_function (|
                      Ty.path "alloy_primitives::bits::bloom::Bloom",
                      "m3_2048",
                      [],
                      []
                    |),
                    [
                      M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |);
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.deref (|
                          M.call_closure (|
                            Ty.apply
                              (Ty.path "&")
                              []
                              [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                            M.get_associated_function (|
                              Ty.apply
                                (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                                [ Value.Integer IntegerKind.Usize 20 ]
                                [],
                              "as_slice",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "&")
                                      []
                                      [
                                        Ty.apply
                                          (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                                          [ Value.Integer IntegerKind.Usize 20 ]
                                          []
                                      ],
                                    M.get_trait_method (|
                                      "core::ops::deref::Deref",
                                      Ty.path "alloy_primitives::bits::address::Address",
                                      [],
                                      [],
                                      "deref",
                                      [],
                                      []
                                    |),
                                    [ M.borrow (| Pointer.Kind.Ref, address |) ]
                                  |)
                                |)
                              |)
                            ]
                          |)
                        |)
                      |)
                    ]
                  |)
                |) in
              M.use
                (M.match_operator (|
                  Some (Ty.apply (Ty.path "*") [] [ Ty.tuple [] ]),
                  M.alloc (|
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "core::slice::iter::Iter")
                        []
                        [
                          Ty.apply
                            (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                            [ Value.Integer IntegerKind.Usize 32 ]
                            []
                        ],
                      M.get_trait_method (|
                        "core::iter::traits::collect::IntoIterator",
                        Ty.apply
                          (Ty.path "core::slice::iter::Iter")
                          []
                          [
                            Ty.apply
                              (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                              [ Value.Integer IntegerKind.Usize 32 ]
                              []
                          ],
                        [],
                        [],
                        "into_iter",
                        [],
                        []
                      |),
                      [
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "core::slice::iter::Iter")
                            []
                            [
                              Ty.apply
                                (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                                [ Value.Integer IntegerKind.Usize 32 ]
                                []
                            ],
                          M.get_associated_function (|
                            Ty.apply
                              (Ty.path "slice")
                              []
                              [
                                Ty.apply
                                  (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                                  [ Value.Integer IntegerKind.Usize 32 ]
                                  []
                              ],
                            "iter",
                            [],
                            []
                          |),
                          [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| topics |) |) |) ]
                        |)
                      ]
                    |)
                  |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let iter := M.copy (| γ |) in
                        M.loop (|
                          Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                          ltac:(M.monadic
                            (let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                              M.match_operator (|
                                Some (Ty.apply (Ty.path "*") [] [ Ty.tuple [] ]),
                                M.alloc (|
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "core::option::Option")
                                      []
                                      [
                                        Ty.apply
                                          (Ty.path "&")
                                          []
                                          [
                                            Ty.apply
                                              (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                                              [ Value.Integer IntegerKind.Usize 32 ]
                                              []
                                          ]
                                      ],
                                    M.get_trait_method (|
                                      "core::iter::traits::iterator::Iterator",
                                      Ty.apply
                                        (Ty.path "core::slice::iter::Iter")
                                        []
                                        [
                                          Ty.apply
                                            (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                                            [ Value.Integer IntegerKind.Usize 32 ]
                                            []
                                        ],
                                      [],
                                      [],
                                      "next",
                                      [],
                                      []
                                    |),
                                    [
                                      M.borrow (|
                                        Pointer.Kind.MutRef,
                                        M.deref (| M.borrow (| Pointer.Kind.MutRef, iter |) |)
                                      |)
                                    ]
                                  |)
                                |),
                                [
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let _ :=
                                        M.is_struct_tuple (| γ, "core::option::Option::None" |) in
                                      M.alloc (|
                                        M.never_to_any (| M.read (| M.break (||) |) |)
                                      |)));
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let γ0_0 :=
                                        M.SubPointer.get_struct_tuple_field (|
                                          γ,
                                          "core::option::Option::Some",
                                          0
                                        |) in
                                      let topic := M.copy (| γ0_0 |) in
                                      let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                                        M.alloc (|
                                          M.call_closure (|
                                            Ty.tuple [],
                                            M.get_associated_function (|
                                              Ty.path "alloy_primitives::bits::bloom::Bloom",
                                              "m3_2048",
                                              [],
                                              []
                                            |),
                                            [
                                              M.borrow (|
                                                Pointer.Kind.MutRef,
                                                M.deref (| M.read (| self |) |)
                                              |);
                                              M.borrow (|
                                                Pointer.Kind.Ref,
                                                M.deref (|
                                                  M.call_closure (|
                                                    Ty.apply
                                                      (Ty.path "&")
                                                      []
                                                      [
                                                        Ty.apply
                                                          (Ty.path "slice")
                                                          []
                                                          [ Ty.path "u8" ]
                                                      ],
                                                    M.get_associated_function (|
                                                      Ty.apply
                                                        (Ty.path
                                                          "alloy_primitives::bits::fixed::FixedBytes")
                                                        [ Value.Integer IntegerKind.Usize 32 ]
                                                        [],
                                                      "as_slice",
                                                      [],
                                                      []
                                                    |),
                                                    [
                                                      M.borrow (|
                                                        Pointer.Kind.Ref,
                                                        M.deref (| M.read (| topic |) |)
                                                      |)
                                                    ]
                                                  |)
                                                |)
                                              |)
                                            ]
                                          |)
                                        |) in
                                      M.alloc (| Value.Tuple [] |)))
                                ]
                              |) in
                            M.alloc (| Value.Tuple [] |)))
                        |)))
                  ]
                |))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_accrue_raw_log :
        M.IsAssociatedFunction.C Self "accrue_raw_log" accrue_raw_log.
      Admitted.
      Global Typeclasses Opaque accrue_raw_log.
      
      (*
          pub fn accrue_log(&mut self, log: &Log) {
              self.accrue_raw_log(log.address, log.topics())
          }
      *)
      Definition accrue_log (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; log ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let log := M.alloc (| log |) in
            M.call_closure (|
              Ty.tuple [],
              M.get_associated_function (|
                Ty.path "alloy_primitives::bits::bloom::Bloom",
                "accrue_raw_log",
                [],
                []
              |),
              [
                M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |);
                M.read (|
                  M.SubPointer.get_struct_record_field (|
                    M.deref (| M.read (| log |) |),
                    "alloy_primitives::log::Log",
                    "address"
                  |)
                |);
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "&")
                        []
                        [
                          Ty.apply
                            (Ty.path "slice")
                            []
                            [
                              Ty.apply
                                (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                                [ Value.Integer IntegerKind.Usize 32 ]
                                []
                            ]
                        ],
                      M.get_associated_function (|
                        Ty.path "alloy_primitives::log::LogData",
                        "topics",
                        [],
                        []
                      |),
                      [
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.deref (|
                            M.call_closure (|
                              Ty.apply
                                (Ty.path "&")
                                []
                                [ Ty.path "alloy_primitives::log::LogData" ],
                              M.get_trait_method (|
                                "core::ops::deref::Deref",
                                Ty.apply
                                  (Ty.path "alloy_primitives::log::Log")
                                  []
                                  [ Ty.path "alloy_primitives::log::LogData" ],
                                [],
                                [],
                                "deref",
                                [],
                                []
                              |),
                              [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| log |) |) |) ]
                            |)
                          |)
                        |)
                      ]
                    |)
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_accrue_log :
        M.IsAssociatedFunction.C Self "accrue_log" accrue_log.
      Admitted.
      Global Typeclasses Opaque accrue_log.
      
      (*
          pub fn contains_raw_log(&self, address: Address, topics: &[B256]) -> bool {
              let mut bloom = Self::default();
              bloom.accrue_raw_log(address, topics);
              self.contains(&bloom)
          }
      *)
      Definition contains_raw_log (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; address; topics ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let address := M.alloc (| address |) in
            let topics := M.alloc (| topics |) in
            M.read (|
              let~ bloom :
                  Ty.apply (Ty.path "*") [] [ Ty.path "alloy_primitives::bits::bloom::Bloom" ] :=
                M.alloc (|
                  M.call_closure (|
                    Ty.path "alloy_primitives::bits::bloom::Bloom",
                    M.get_trait_method (|
                      "core::default::Default",
                      Ty.path "alloy_primitives::bits::bloom::Bloom",
                      [],
                      [],
                      "default",
                      [],
                      []
                    |),
                    []
                  |)
                |) in
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.call_closure (|
                    Ty.tuple [],
                    M.get_associated_function (|
                      Ty.path "alloy_primitives::bits::bloom::Bloom",
                      "accrue_raw_log",
                      [],
                      []
                    |),
                    [
                      M.borrow (| Pointer.Kind.MutRef, bloom |);
                      M.read (| address |);
                      M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| topics |) |) |)
                    ]
                  |)
                |) in
              M.alloc (|
                M.call_closure (|
                  Ty.path "bool",
                  M.get_associated_function (|
                    Ty.path "alloy_primitives::bits::bloom::Bloom",
                    "contains",
                    [],
                    []
                  |),
                  [
                    M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |);
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (| M.borrow (| Pointer.Kind.Ref, bloom |) |)
                    |)
                  ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_contains_raw_log :
        M.IsAssociatedFunction.C Self "contains_raw_log" contains_raw_log.
      Admitted.
      Global Typeclasses Opaque contains_raw_log.
      
      (*
          pub fn contains_log(&self, log: &Log) -> bool {
              self.contains_raw_log(log.address, log.topics())
          }
      *)
      Definition contains_log (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; log ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let log := M.alloc (| log |) in
            M.call_closure (|
              Ty.path "bool",
              M.get_associated_function (|
                Ty.path "alloy_primitives::bits::bloom::Bloom",
                "contains_raw_log",
                [],
                []
              |),
              [
                M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |);
                M.read (|
                  M.SubPointer.get_struct_record_field (|
                    M.deref (| M.read (| log |) |),
                    "alloy_primitives::log::Log",
                    "address"
                  |)
                |);
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "&")
                        []
                        [
                          Ty.apply
                            (Ty.path "slice")
                            []
                            [
                              Ty.apply
                                (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                                [ Value.Integer IntegerKind.Usize 32 ]
                                []
                            ]
                        ],
                      M.get_associated_function (|
                        Ty.path "alloy_primitives::log::LogData",
                        "topics",
                        [],
                        []
                      |),
                      [
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.deref (|
                            M.call_closure (|
                              Ty.apply
                                (Ty.path "&")
                                []
                                [ Ty.path "alloy_primitives::log::LogData" ],
                              M.get_trait_method (|
                                "core::ops::deref::Deref",
                                Ty.apply
                                  (Ty.path "alloy_primitives::log::Log")
                                  []
                                  [ Ty.path "alloy_primitives::log::LogData" ],
                                [],
                                [],
                                "deref",
                                [],
                                []
                              |),
                              [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| log |) |) |) ]
                            |)
                          |)
                        |)
                      ]
                    |)
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_contains_log :
        M.IsAssociatedFunction.C Self "contains_log" contains_log.
      Admitted.
      Global Typeclasses Opaque contains_log.
    End Impl_alloy_primitives_bits_bloom_Bloom.
  End bloom.
End bits.
