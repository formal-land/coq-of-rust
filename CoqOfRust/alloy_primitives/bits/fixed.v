(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module bits.
  Module fixed.
    (* StructTuple
      {
        name := "FixedBytes";
        const_params := [ "N" ];
        ty_params := [];
        fields := [ Ty.apply (Ty.path "array") [ N ] [ Ty.path "u8" ] ];
      } *)
    
    Module Impl_core_clone_Clone_for_alloy_primitives_bits_fixed_FixedBytes_N.
      Definition Self (N : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::bits::fixed::FixedBytes") [ N ] [].
      
      (*     Clone *)
      Definition clone (N : Value.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self N in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                Ty.apply
                  (Ty.path "*")
                  []
                  [ Ty.apply (Ty.path "alloy_primitives::bits::fixed::FixedBytes") [ N ] [] ],
                Value.DeclaredButUndefined,
                [ fun γ => ltac:(M.monadic (M.deref (| M.read (| self |) |))) ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (N : Value.t),
        M.IsTraitInstance
          "core::clone::Clone"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self N)
          (* Instance *) [ ("clone", InstanceField.Method (clone N)) ].
    End Impl_core_clone_Clone_for_alloy_primitives_bits_fixed_FixedBytes_N.
    
    Module Impl_core_marker_Copy_for_alloy_primitives_bits_fixed_FixedBytes_N.
      Definition Self (N : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::bits::fixed::FixedBytes") [ N ] [].
      
      Axiom Implements :
        forall (N : Value.t),
        M.IsTraitInstance
          "core::marker::Copy"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self N)
          (* Instance *) [].
    End Impl_core_marker_Copy_for_alloy_primitives_bits_fixed_FixedBytes_N.
    
    Module Impl_core_marker_StructuralPartialEq_for_alloy_primitives_bits_fixed_FixedBytes_N.
      Definition Self (N : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::bits::fixed::FixedBytes") [ N ] [].
      
      Axiom Implements :
        forall (N : Value.t),
        M.IsTraitInstance
          "core::marker::StructuralPartialEq"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self N)
          (* Instance *) [].
    End Impl_core_marker_StructuralPartialEq_for_alloy_primitives_bits_fixed_FixedBytes_N.
    
    Module Impl_core_cmp_PartialEq_alloy_primitives_bits_fixed_FixedBytes_N_for_alloy_primitives_bits_fixed_FixedBytes_N.
      Definition Self (N : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::bits::fixed::FixedBytes") [ N ] [].
      
      (*     PartialEq *)
      Definition eq (N : Value.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self N in
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              Ty.path "bool",
              M.get_trait_method (|
                "core::cmp::PartialEq",
                Ty.apply (Ty.path "array") [ N ] [ Ty.path "u8" ],
                [],
                [ Ty.apply (Ty.path "array") [ N ] [ Ty.path "u8" ] ],
                "eq",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.SubPointer.get_struct_tuple_field (|
                    M.deref (| M.read (| self |) |),
                    "alloy_primitives::bits::fixed::FixedBytes",
                    0
                  |)
                |);
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.SubPointer.get_struct_tuple_field (|
                    M.deref (| M.read (| other |) |),
                    "alloy_primitives::bits::fixed::FixedBytes",
                    0
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (N : Value.t),
        M.IsTraitInstance
          "core::cmp::PartialEq"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "alloy_primitives::bits::fixed::FixedBytes") [ N ] [] ]
          (Self N)
          (* Instance *) [ ("eq", InstanceField.Method (eq N)) ].
    End Impl_core_cmp_PartialEq_alloy_primitives_bits_fixed_FixedBytes_N_for_alloy_primitives_bits_fixed_FixedBytes_N.
    
    Module Impl_core_cmp_Eq_for_alloy_primitives_bits_fixed_FixedBytes_N.
      Definition Self (N : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::bits::fixed::FixedBytes") [ N ] [].
      
      (*     Eq *)
      Definition assert_receiver_is_total_eq
          (N : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self N in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                Value.DeclaredButUndefined,
                [ fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |))) ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (N : Value.t),
        M.IsTraitInstance
          "core::cmp::Eq"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self N)
          (* Instance *)
          [ ("assert_receiver_is_total_eq", InstanceField.Method (assert_receiver_is_total_eq N)) ].
    End Impl_core_cmp_Eq_for_alloy_primitives_bits_fixed_FixedBytes_N.
    
    Module Impl_core_cmp_PartialOrd_alloy_primitives_bits_fixed_FixedBytes_N_for_alloy_primitives_bits_fixed_FixedBytes_N.
      Definition Self (N : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::bits::fixed::FixedBytes") [ N ] [].
      
      (*     PartialOrd *)
      Definition partial_cmp
          (N : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self N in
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "core::cmp::Ordering" ],
              M.get_trait_method (|
                "core::cmp::PartialOrd",
                Ty.apply (Ty.path "array") [ N ] [ Ty.path "u8" ],
                [],
                [ Ty.apply (Ty.path "array") [ N ] [ Ty.path "u8" ] ],
                "partial_cmp",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_tuple_field (|
                        M.deref (| M.read (| self |) |),
                        "alloy_primitives::bits::fixed::FixedBytes",
                        0
                      |)
                    |)
                  |)
                |);
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_tuple_field (|
                        M.deref (| M.read (| other |) |),
                        "alloy_primitives::bits::fixed::FixedBytes",
                        0
                      |)
                    |)
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (N : Value.t),
        M.IsTraitInstance
          "core::cmp::PartialOrd"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "alloy_primitives::bits::fixed::FixedBytes") [ N ] [] ]
          (Self N)
          (* Instance *) [ ("partial_cmp", InstanceField.Method (partial_cmp N)) ].
    End Impl_core_cmp_PartialOrd_alloy_primitives_bits_fixed_FixedBytes_N_for_alloy_primitives_bits_fixed_FixedBytes_N.
    
    Module Impl_core_cmp_Ord_for_alloy_primitives_bits_fixed_FixedBytes_N.
      Definition Self (N : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::bits::fixed::FixedBytes") [ N ] [].
      
      (*     Ord *)
      Definition cmp (N : Value.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self N in
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              Ty.path "core::cmp::Ordering",
              M.get_trait_method (|
                "core::cmp::Ord",
                Ty.apply (Ty.path "array") [ N ] [ Ty.path "u8" ],
                [],
                [],
                "cmp",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_tuple_field (|
                        M.deref (| M.read (| self |) |),
                        "alloy_primitives::bits::fixed::FixedBytes",
                        0
                      |)
                    |)
                  |)
                |);
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_tuple_field (|
                        M.deref (| M.read (| other |) |),
                        "alloy_primitives::bits::fixed::FixedBytes",
                        0
                      |)
                    |)
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (N : Value.t),
        M.IsTraitInstance
          "core::cmp::Ord"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self N)
          (* Instance *) [ ("cmp", InstanceField.Method (cmp N)) ].
    End Impl_core_cmp_Ord_for_alloy_primitives_bits_fixed_FixedBytes_N.
    
    Module Impl_core_hash_Hash_for_alloy_primitives_bits_fixed_FixedBytes_N.
      Definition Self (N : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::bits::fixed::FixedBytes") [ N ] [].
      
      (*     Hash *)
      Definition hash (N : Value.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self N in
        match ε, τ, α with
        | [], [ __H ], [ self; state ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let state := M.alloc (| state |) in
            M.call_closure (|
              Ty.tuple [],
              M.get_trait_method (|
                "core::hash::Hash",
                Ty.apply (Ty.path "array") [ N ] [ Ty.path "u8" ],
                [],
                [],
                "hash",
                [],
                [ __H ]
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_tuple_field (|
                        M.deref (| M.read (| self |) |),
                        "alloy_primitives::bits::fixed::FixedBytes",
                        0
                      |)
                    |)
                  |)
                |);
                M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (N : Value.t),
        M.IsTraitInstance
          "core::hash::Hash"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self N)
          (* Instance *) [ ("hash", InstanceField.Method (hash N)) ].
    End Impl_core_hash_Hash_for_alloy_primitives_bits_fixed_FixedBytes_N.
    
    Module Impl_core_ops_deref_Deref_for_alloy_primitives_bits_fixed_FixedBytes_N.
      Definition Self (N : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::bits::fixed::FixedBytes") [ N ] [].
      
      (*     Deref *)
      Definition _Target (N : Value.t) : Ty.t := Ty.apply (Ty.path "array") [ N ] [ Ty.path "u8" ].
      
      (*     Deref *)
      Definition deref (N : Value.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self N in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.borrow (|
              Pointer.Kind.Ref,
              M.deref (|
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.SubPointer.get_struct_tuple_field (|
                    M.deref (| M.read (| self |) |),
                    "alloy_primitives::bits::fixed::FixedBytes",
                    0
                  |)
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (N : Value.t),
        M.IsTraitInstance
          "core::ops::deref::Deref"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self N)
          (* Instance *)
          [ ("Target", InstanceField.Ty (_Target N)); ("deref", InstanceField.Method (deref N)) ].
    End Impl_core_ops_deref_Deref_for_alloy_primitives_bits_fixed_FixedBytes_N.
    
    Module Impl_core_ops_deref_DerefMut_for_alloy_primitives_bits_fixed_FixedBytes_N.
      Definition Self (N : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::bits::fixed::FixedBytes") [ N ] [].
      
      (*     DerefMut *)
      Definition deref_mut
          (N : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self N in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.borrow (|
              Pointer.Kind.MutRef,
              M.deref (|
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.MutRef,
                      M.SubPointer.get_struct_tuple_field (|
                        M.deref (| M.read (| self |) |),
                        "alloy_primitives::bits::fixed::FixedBytes",
                        0
                      |)
                    |)
                  |)
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (N : Value.t),
        M.IsTraitInstance
          "core::ops::deref::DerefMut"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self N)
          (* Instance *) [ ("deref_mut", InstanceField.Method (deref_mut N)) ].
    End Impl_core_ops_deref_DerefMut_for_alloy_primitives_bits_fixed_FixedBytes_N.
    
    Module Impl_core_convert_From_array_N_u8_for_alloy_primitives_bits_fixed_FixedBytes_N.
      Definition Self (N : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::bits::fixed::FixedBytes") [ N ] [].
      
      (*     From *)
      Definition from (N : Value.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self N in
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            Value.StructTuple "alloy_primitives::bits::fixed::FixedBytes" [ M.read (| value |) ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (N : Value.t),
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.apply (Ty.path "array") [ N ] [ Ty.path "u8" ] ]
          (Self N)
          (* Instance *) [ ("from", InstanceField.Method (from N)) ].
    End Impl_core_convert_From_array_N_u8_for_alloy_primitives_bits_fixed_FixedBytes_N.
    
    Module Impl_core_ops_index_Index_where_core_ops_index_Index_array_N_u8___IdxT___IdxT_for_alloy_primitives_bits_fixed_FixedBytes_N.
      Definition Self (N : Value.t) (__IdxT : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::bits::fixed::FixedBytes") [ N ] [].
      
      (*     Index *)
      Definition _Output (N : Value.t) (__IdxT : Ty.t) : Ty.t :=
        Ty.associated_in_trait
          "core::ops::index::Index"
          []
          [ __IdxT ]
          (Ty.apply (Ty.path "array") [ N ] [ Ty.path "u8" ])
          "Output".
      
      (*     Index *)
      Definition index
          (N : Value.t)
          (__IdxT : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self N __IdxT in
        match ε, τ, α with
        | [], [], [ self; idx ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let idx := M.alloc (| idx |) in
            M.borrow (|
              Pointer.Kind.Ref,
              M.deref (|
                M.call_closure (|
                  Ty.apply
                    (Ty.path "&")
                    []
                    [
                      Ty.associated_in_trait
                        "core::ops::index::Index"
                        []
                        [ __IdxT ]
                        (Ty.apply (Ty.path "array") [ N ] [ Ty.path "u8" ])
                        "Output"
                    ],
                  M.get_trait_method (|
                    "core::ops::index::Index",
                    Ty.apply (Ty.path "array") [ N ] [ Ty.path "u8" ],
                    [],
                    [ __IdxT ],
                    "index",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_tuple_field (|
                            M.deref (| M.read (| self |) |),
                            "alloy_primitives::bits::fixed::FixedBytes",
                            0
                          |)
                        |)
                      |)
                    |);
                    M.read (| idx |)
                  ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (N : Value.t) (__IdxT : Ty.t),
        M.IsTraitInstance
          "core::ops::index::Index"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ __IdxT ]
          (Self N __IdxT)
          (* Instance *)
          [
            ("Output", InstanceField.Ty (_Output N __IdxT));
            ("index", InstanceField.Method (index N __IdxT))
          ].
    End Impl_core_ops_index_Index_where_core_ops_index_Index_array_N_u8___IdxT___IdxT_for_alloy_primitives_bits_fixed_FixedBytes_N.
    
    Module Impl_core_ops_index_IndexMut_where_core_ops_index_IndexMut_array_N_u8___IdxT___IdxT_for_alloy_primitives_bits_fixed_FixedBytes_N.
      Definition Self (N : Value.t) (__IdxT : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::bits::fixed::FixedBytes") [ N ] [].
      
      (*     IndexMut *)
      Definition index_mut
          (N : Value.t)
          (__IdxT : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self N __IdxT in
        match ε, τ, α with
        | [], [], [ self; idx ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let idx := M.alloc (| idx |) in
            M.borrow (|
              Pointer.Kind.MutRef,
              M.deref (|
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.deref (|
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "&mut")
                        []
                        [
                          Ty.associated_in_trait
                            "core::ops::index::Index"
                            []
                            [ __IdxT ]
                            (Ty.apply (Ty.path "array") [ N ] [ Ty.path "u8" ])
                            "Output"
                        ],
                      M.get_trait_method (|
                        "core::ops::index::IndexMut",
                        Ty.apply (Ty.path "array") [ N ] [ Ty.path "u8" ],
                        [],
                        [ __IdxT ],
                        "index_mut",
                        [],
                        []
                      |),
                      [
                        M.borrow (|
                          Pointer.Kind.MutRef,
                          M.deref (|
                            M.borrow (|
                              Pointer.Kind.MutRef,
                              M.SubPointer.get_struct_tuple_field (|
                                M.deref (| M.read (| self |) |),
                                "alloy_primitives::bits::fixed::FixedBytes",
                                0
                              |)
                            |)
                          |)
                        |);
                        M.read (| idx |)
                      ]
                    |)
                  |)
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (N : Value.t) (__IdxT : Ty.t),
        M.IsTraitInstance
          "core::ops::index::IndexMut"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ __IdxT ]
          (Self N __IdxT)
          (* Instance *) [ ("index_mut", InstanceField.Method (index_mut N __IdxT)) ].
    End Impl_core_ops_index_IndexMut_where_core_ops_index_IndexMut_array_N_u8___IdxT___IdxT_for_alloy_primitives_bits_fixed_FixedBytes_N.
    
    Module Impl_core_iter_traits_collect_IntoIterator_where_core_iter_traits_collect_IntoIterator_array_N_u8_for_alloy_primitives_bits_fixed_FixedBytes_N.
      Definition Self (N : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::bits::fixed::FixedBytes") [ N ] [].
      
      (*     IntoIterator *)
      Definition _Item (N : Value.t) : Ty.t :=
        Ty.associated_in_trait
          "core::iter::traits::collect::IntoIterator"
          []
          []
          (Ty.apply (Ty.path "array") [ N ] [ Ty.path "u8" ])
          "Item".
      
      (*     IntoIterator *)
      Definition _IntoIter (N : Value.t) : Ty.t :=
        Ty.associated_in_trait
          "core::iter::traits::collect::IntoIterator"
          []
          []
          (Ty.apply (Ty.path "array") [ N ] [ Ty.path "u8" ])
          "IntoIter".
      
      (*     IntoIterator *)
      Definition into_iter
          (N : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self N in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.associated_in_trait
                "core::iter::traits::collect::IntoIterator"
                []
                []
                (Ty.apply (Ty.path "array") [ N ] [ Ty.path "u8" ])
                "IntoIter",
              M.get_trait_method (|
                "core::iter::traits::collect::IntoIterator",
                Ty.apply (Ty.path "array") [ N ] [ Ty.path "u8" ],
                [],
                [],
                "into_iter",
                [],
                []
              |),
              [
                M.read (|
                  M.SubPointer.get_struct_tuple_field (|
                    self,
                    "alloy_primitives::bits::fixed::FixedBytes",
                    0
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (N : Value.t),
        M.IsTraitInstance
          "core::iter::traits::collect::IntoIterator"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self N)
          (* Instance *)
          [
            ("Item", InstanceField.Ty (_Item N));
            ("IntoIter", InstanceField.Ty (_IntoIter N));
            ("into_iter", InstanceField.Method (into_iter N))
          ].
    End Impl_core_iter_traits_collect_IntoIterator_where_core_iter_traits_collect_IntoIterator_array_N_u8_for_alloy_primitives_bits_fixed_FixedBytes_N.
    
    Module Impl_core_iter_traits_collect_IntoIterator_where_core_iter_traits_collect_IntoIterator_ref__array_N_u8_for_ref__alloy_primitives_bits_fixed_FixedBytes_N.
      Definition Self (N : Value.t) : Ty.t :=
        Ty.apply
          (Ty.path "&")
          []
          [ Ty.apply (Ty.path "alloy_primitives::bits::fixed::FixedBytes") [ N ] [] ].
      
      (*     IntoIterator *)
      Definition _Item (N : Value.t) : Ty.t :=
        Ty.associated_in_trait
          "core::iter::traits::collect::IntoIterator"
          []
          []
          (Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "array") [ N ] [ Ty.path "u8" ] ])
          "Item".
      
      (*     IntoIterator *)
      Definition _IntoIter (N : Value.t) : Ty.t :=
        Ty.associated_in_trait
          "core::iter::traits::collect::IntoIterator"
          []
          []
          (Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "array") [ N ] [ Ty.path "u8" ] ])
          "IntoIter".
      
      (*     IntoIterator *)
      Definition into_iter
          (N : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self N in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.associated_in_trait
                "core::iter::traits::collect::IntoIterator"
                []
                []
                (Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "array") [ N ] [ Ty.path "u8" ] ])
                "IntoIter",
              M.get_trait_method (|
                "core::iter::traits::collect::IntoIterator",
                Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "array") [ N ] [ Ty.path "u8" ] ],
                [],
                [],
                "into_iter",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_tuple_field (|
                        M.deref (| M.read (| self |) |),
                        "alloy_primitives::bits::fixed::FixedBytes",
                        0
                      |)
                    |)
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (N : Value.t),
        M.IsTraitInstance
          "core::iter::traits::collect::IntoIterator"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self N)
          (* Instance *)
          [
            ("Item", InstanceField.Ty (_Item N));
            ("IntoIter", InstanceField.Ty (_IntoIter N));
            ("into_iter", InstanceField.Method (into_iter N))
          ].
    End Impl_core_iter_traits_collect_IntoIterator_where_core_iter_traits_collect_IntoIterator_ref__array_N_u8_for_ref__alloy_primitives_bits_fixed_FixedBytes_N.
    
    Module Impl_core_iter_traits_collect_IntoIterator_where_core_iter_traits_collect_IntoIterator_ref_mut_array_N_u8_for_ref_mut_alloy_primitives_bits_fixed_FixedBytes_N.
      Definition Self (N : Value.t) : Ty.t :=
        Ty.apply
          (Ty.path "&mut")
          []
          [ Ty.apply (Ty.path "alloy_primitives::bits::fixed::FixedBytes") [ N ] [] ].
      
      (*     IntoIterator *)
      Definition _Item (N : Value.t) : Ty.t :=
        Ty.associated_in_trait
          "core::iter::traits::collect::IntoIterator"
          []
          []
          (Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "array") [ N ] [ Ty.path "u8" ] ])
          "Item".
      
      (*     IntoIterator *)
      Definition _IntoIter (N : Value.t) : Ty.t :=
        Ty.associated_in_trait
          "core::iter::traits::collect::IntoIterator"
          []
          []
          (Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "array") [ N ] [ Ty.path "u8" ] ])
          "IntoIter".
      
      (*     IntoIterator *)
      Definition into_iter
          (N : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self N in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.associated_in_trait
                "core::iter::traits::collect::IntoIterator"
                []
                []
                (Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "array") [ N ] [ Ty.path "u8" ] ])
                "IntoIter",
              M.get_trait_method (|
                "core::iter::traits::collect::IntoIterator",
                Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "array") [ N ] [ Ty.path "u8" ] ],
                [],
                [],
                "into_iter",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.MutRef,
                      M.SubPointer.get_struct_tuple_field (|
                        M.deref (| M.read (| self |) |),
                        "alloy_primitives::bits::fixed::FixedBytes",
                        0
                      |)
                    |)
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (N : Value.t),
        M.IsTraitInstance
          "core::iter::traits::collect::IntoIterator"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self N)
          (* Instance *)
          [
            ("Item", InstanceField.Ty (_Item N));
            ("IntoIter", InstanceField.Ty (_IntoIter N));
            ("into_iter", InstanceField.Method (into_iter N))
          ].
    End Impl_core_iter_traits_collect_IntoIterator_where_core_iter_traits_collect_IntoIterator_ref_mut_array_N_u8_for_ref_mut_alloy_primitives_bits_fixed_FixedBytes_N.
    
    Module Impl_core_default_Default_for_alloy_primitives_bits_fixed_FixedBytes_N.
      Definition Self (N : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::bits::fixed::FixedBytes") [ N ] [].
      
      (*
          fn default() -> Self {
              Self::ZERO
          }
      *)
      Definition default (N : Value.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self N in
        match ε, τ, α with
        | [], [], [] =>
          ltac:(M.monadic
            (M.read (|
              get_associated_constant (|
                Ty.apply (Ty.path "alloy_primitives::bits::fixed::FixedBytes") [ N ] [],
                "ZERO",
                Ty.apply (Ty.path "alloy_primitives::bits::fixed::FixedBytes") [ N ] []
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (N : Value.t),
        M.IsTraitInstance
          "core::default::Default"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self N)
          (* Instance *) [ ("default", InstanceField.Method (default N)) ].
    End Impl_core_default_Default_for_alloy_primitives_bits_fixed_FixedBytes_N.
    
    Module Impl_core_default_Default_for_ref__alloy_primitives_bits_fixed_FixedBytes_N.
      Definition Self (N : Value.t) : Ty.t :=
        Ty.apply
          (Ty.path "&")
          []
          [ Ty.apply (Ty.path "alloy_primitives::bits::fixed::FixedBytes") [ N ] [] ].
      
      (*
          fn default() -> Self {
              &FixedBytes::ZERO
          }
      *)
      Definition default (N : Value.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self N in
        match ε, τ, α with
        | [], [], [] =>
          ltac:(M.monadic
            (M.borrow (|
              Pointer.Kind.Ref,
              M.deref (|
                M.borrow (|
                  Pointer.Kind.Ref,
                  get_associated_constant (|
                    Ty.apply (Ty.path "alloy_primitives::bits::fixed::FixedBytes") [ N ] [],
                    "ZERO",
                    Ty.apply (Ty.path "alloy_primitives::bits::fixed::FixedBytes") [ N ] []
                  |)
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (N : Value.t),
        M.IsTraitInstance
          "core::default::Default"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self N)
          (* Instance *) [ ("default", InstanceField.Method (default N)) ].
    End Impl_core_default_Default_for_ref__alloy_primitives_bits_fixed_FixedBytes_N.
    
    Module Impl_core_convert_From_ref__array_N_u8_for_alloy_primitives_bits_fixed_FixedBytes_N.
      Definition Self (N : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::bits::fixed::FixedBytes") [ N ] [].
      
      (*
          fn from(bytes: &[u8; N]) -> Self {
              Self( *bytes)
          }
      *)
      Definition from (N : Value.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self N in
        match ε, τ, α with
        | [], [], [ bytes ] =>
          ltac:(M.monadic
            (let bytes := M.alloc (| bytes |) in
            Value.StructTuple
              "alloy_primitives::bits::fixed::FixedBytes"
              [ M.read (| M.deref (| M.read (| bytes |) |) |) ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (N : Value.t),
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "array") [ N ] [ Ty.path "u8" ] ] ]
          (Self N)
          (* Instance *) [ ("from", InstanceField.Method (from N)) ].
    End Impl_core_convert_From_ref__array_N_u8_for_alloy_primitives_bits_fixed_FixedBytes_N.
    
    Module Impl_core_convert_From_ref_mut_array_N_u8_for_alloy_primitives_bits_fixed_FixedBytes_N.
      Definition Self (N : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::bits::fixed::FixedBytes") [ N ] [].
      
      (*
          fn from(bytes: &mut [u8; N]) -> Self {
              Self( *bytes)
          }
      *)
      Definition from (N : Value.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self N in
        match ε, τ, α with
        | [], [], [ bytes ] =>
          ltac:(M.monadic
            (let bytes := M.alloc (| bytes |) in
            Value.StructTuple
              "alloy_primitives::bits::fixed::FixedBytes"
              [ M.read (| M.deref (| M.read (| bytes |) |) |) ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (N : Value.t),
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "array") [ N ] [ Ty.path "u8" ] ] ]
          (Self N)
          (* Instance *) [ ("from", InstanceField.Method (from N)) ].
    End Impl_core_convert_From_ref_mut_array_N_u8_for_alloy_primitives_bits_fixed_FixedBytes_N.
    
    Module Impl_core_convert_TryFrom_ref__slice_u8_for_alloy_primitives_bits_fixed_FixedBytes_N.
      Definition Self (N : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::bits::fixed::FixedBytes") [ N ] [].
      
      (*     type Error = core::array::TryFromSliceError; *)
      Definition _Error (N : Value.t) : Ty.t := Ty.path "core::array::TryFromSliceError".
      
      (*
          fn try_from(slice: &[u8]) -> Result<Self, Self::Error> {
              <&Self>::try_from(slice).copied()
          }
      *)
      Definition try_from (N : Value.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self N in
        match ε, τ, α with
        | [], [], [ slice ] =>
          ltac:(M.monadic
            (let slice := M.alloc (| slice |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "core::result::Result")
                []
                [
                  Ty.apply (Ty.path "alloy_primitives::bits::fixed::FixedBytes") [ N ] [];
                  Ty.path "core::array::TryFromSliceError"
                ],
              M.get_associated_function (|
                Ty.apply
                  (Ty.path "core::result::Result")
                  []
                  [
                    Ty.apply
                      (Ty.path "&")
                      []
                      [ Ty.apply (Ty.path "alloy_primitives::bits::fixed::FixedBytes") [ N ] [] ];
                    Ty.path "core::array::TryFromSliceError"
                  ],
                "copied",
                [],
                []
              |),
              [
                M.call_closure (|
                  Ty.apply
                    (Ty.path "core::result::Result")
                    []
                    [
                      Ty.apply
                        (Ty.path "&")
                        []
                        [ Ty.apply (Ty.path "alloy_primitives::bits::fixed::FixedBytes") [ N ] [] ];
                      Ty.path "core::array::TryFromSliceError"
                    ],
                  M.get_trait_method (|
                    "core::convert::TryFrom",
                    Ty.apply
                      (Ty.path "&")
                      []
                      [ Ty.apply (Ty.path "alloy_primitives::bits::fixed::FixedBytes") [ N ] [] ],
                    [],
                    [ Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
                    ],
                    "try_from",
                    [],
                    []
                  |),
                  [ M.read (| slice |) ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (N : Value.t),
        M.IsTraitInstance
          "core::convert::TryFrom"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ] ]
          (Self N)
          (* Instance *)
          [ ("Error", InstanceField.Ty (_Error N)); ("try_from", InstanceField.Method (try_from N))
          ].
    End Impl_core_convert_TryFrom_ref__slice_u8_for_alloy_primitives_bits_fixed_FixedBytes_N.
    
    Module Impl_core_convert_TryFrom_ref_mut_slice_u8_for_alloy_primitives_bits_fixed_FixedBytes_N.
      Definition Self (N : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::bits::fixed::FixedBytes") [ N ] [].
      
      (*     type Error = core::array::TryFromSliceError; *)
      Definition _Error (N : Value.t) : Ty.t := Ty.path "core::array::TryFromSliceError".
      
      (*
          fn try_from(slice: &mut [u8]) -> Result<Self, Self::Error> {
              Self::try_from(&*slice)
          }
      *)
      Definition try_from (N : Value.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self N in
        match ε, τ, α with
        | [], [], [ slice ] =>
          ltac:(M.monadic
            (let slice := M.alloc (| slice |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "core::result::Result")
                []
                [
                  Ty.apply (Ty.path "alloy_primitives::bits::fixed::FixedBytes") [ N ] [];
                  Ty.path "core::array::TryFromSliceError"
                ],
              M.get_trait_method (|
                "core::convert::TryFrom",
                Ty.apply (Ty.path "alloy_primitives::bits::fixed::FixedBytes") [ N ] [],
                [],
                [ Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ] ],
                "try_from",
                [],
                []
              |),
              [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| slice |) |) |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (N : Value.t),
        M.IsTraitInstance
          "core::convert::TryFrom"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ] ]
          (Self N)
          (* Instance *)
          [ ("Error", InstanceField.Ty (_Error N)); ("try_from", InstanceField.Method (try_from N))
          ].
    End Impl_core_convert_TryFrom_ref_mut_slice_u8_for_alloy_primitives_bits_fixed_FixedBytes_N.
    
    Module Impl_core_convert_TryFrom_ref__slice_u8_for_ref__alloy_primitives_bits_fixed_FixedBytes_N.
      Definition Self (N : Value.t) : Ty.t :=
        Ty.apply
          (Ty.path "&")
          []
          [ Ty.apply (Ty.path "alloy_primitives::bits::fixed::FixedBytes") [ N ] [] ].
      
      (*     type Error = core::array::TryFromSliceError; *)
      Definition _Error (N : Value.t) : Ty.t := Ty.path "core::array::TryFromSliceError".
      
      (*
          fn try_from(slice: &'a [u8]) -> Result<&'a FixedBytes<N>, Self::Error> {
              // SAFETY: `FixedBytes<N>` is `repr(transparent)` for `[u8; N]`
              <&[u8; N]>::try_from(slice).map(|array_ref| unsafe { core::mem::transmute(array_ref) })
          }
      *)
      Definition try_from (N : Value.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self N in
        match ε, τ, α with
        | [], [], [ slice ] =>
          ltac:(M.monadic
            (let slice := M.alloc (| slice |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "core::result::Result")
                []
                [
                  Ty.apply
                    (Ty.path "&")
                    []
                    [ Ty.apply (Ty.path "alloy_primitives::bits::fixed::FixedBytes") [ N ] [] ];
                  Ty.path "core::array::TryFromSliceError"
                ],
              M.get_associated_function (|
                Ty.apply
                  (Ty.path "core::result::Result")
                  []
                  [
                    Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "array") [ N ] [ Ty.path "u8" ] ];
                    Ty.path "core::array::TryFromSliceError"
                  ],
                "map",
                [],
                [
                  Ty.apply
                    (Ty.path "&")
                    []
                    [ Ty.apply (Ty.path "alloy_primitives::bits::fixed::FixedBytes") [ N ] [] ];
                  Ty.function
                    [
                      Ty.tuple
                        [
                          Ty.apply
                            (Ty.path "&")
                            []
                            [ Ty.apply (Ty.path "array") [ N ] [ Ty.path "u8" ] ]
                        ]
                    ]
                    (Ty.apply
                      (Ty.path "&")
                      []
                      [ Ty.apply (Ty.path "alloy_primitives::bits::fixed::FixedBytes") [ N ] [] ])
                ]
              |),
              [
                M.call_closure (|
                  Ty.apply
                    (Ty.path "core::result::Result")
                    []
                    [
                      Ty.apply
                        (Ty.path "&")
                        []
                        [ Ty.apply (Ty.path "array") [ N ] [ Ty.path "u8" ] ];
                      Ty.path "core::array::TryFromSliceError"
                    ],
                  M.get_trait_method (|
                    "core::convert::TryFrom",
                    Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "array") [ N ] [ Ty.path "u8" ] ],
                    [],
                    [ Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
                    ],
                    "try_from",
                    [],
                    []
                  |),
                  [ M.read (| slice |) ]
                |);
                M.closure
                  (fun γ =>
                    ltac:(M.monadic
                      match γ with
                      | [ α0 ] =>
                        ltac:(M.monadic
                          (M.match_operator (|
                            Ty.apply
                              (Ty.path "*")
                              []
                              [
                                Ty.function
                                  [
                                    Ty.tuple
                                      [
                                        Ty.apply
                                          (Ty.path "&")
                                          []
                                          [ Ty.apply (Ty.path "array") [ N ] [ Ty.path "u8" ] ]
                                      ]
                                  ]
                                  (Ty.apply
                                    (Ty.path "&")
                                    []
                                    [
                                      Ty.apply
                                        (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                                        [ N ]
                                        []
                                    ])
                              ],
                            M.alloc (| α0 |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let array_ref := M.copy (| γ |) in
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "&")
                                      []
                                      [
                                        Ty.apply
                                          (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                                          [ N ]
                                          []
                                      ],
                                    M.get_function (|
                                      "core::intrinsics::transmute",
                                      [],
                                      [
                                        Ty.apply
                                          (Ty.path "&")
                                          []
                                          [ Ty.apply (Ty.path "array") [ N ] [ Ty.path "u8" ] ];
                                        Ty.apply
                                          (Ty.path "&")
                                          []
                                          [
                                            Ty.apply
                                              (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                                              [ N ]
                                              []
                                          ]
                                      ]
                                    |),
                                    [ M.read (| array_ref |) ]
                                  |)))
                            ]
                          |)))
                      | _ => M.impossible "wrong number of arguments"
                      end))
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (N : Value.t),
        M.IsTraitInstance
          "core::convert::TryFrom"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ] ]
          (Self N)
          (* Instance *)
          [ ("Error", InstanceField.Ty (_Error N)); ("try_from", InstanceField.Method (try_from N))
          ].
    End Impl_core_convert_TryFrom_ref__slice_u8_for_ref__alloy_primitives_bits_fixed_FixedBytes_N.
    
    Module Impl_core_convert_TryFrom_ref_mut_slice_u8_for_ref_mut_alloy_primitives_bits_fixed_FixedBytes_N.
      Definition Self (N : Value.t) : Ty.t :=
        Ty.apply
          (Ty.path "&mut")
          []
          [ Ty.apply (Ty.path "alloy_primitives::bits::fixed::FixedBytes") [ N ] [] ].
      
      (*     type Error = core::array::TryFromSliceError; *)
      Definition _Error (N : Value.t) : Ty.t := Ty.path "core::array::TryFromSliceError".
      
      (*
          fn try_from(slice: &'a mut [u8]) -> Result<&'a mut FixedBytes<N>, Self::Error> {
              // SAFETY: `FixedBytes<N>` is `repr(transparent)` for `[u8; N]`
              <&mut [u8; N]>::try_from(slice).map(|array_ref| unsafe { core::mem::transmute(array_ref) })
          }
      *)
      Definition try_from (N : Value.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self N in
        match ε, τ, α with
        | [], [], [ slice ] =>
          ltac:(M.monadic
            (let slice := M.alloc (| slice |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "core::result::Result")
                []
                [
                  Ty.apply
                    (Ty.path "&mut")
                    []
                    [ Ty.apply (Ty.path "alloy_primitives::bits::fixed::FixedBytes") [ N ] [] ];
                  Ty.path "core::array::TryFromSliceError"
                ],
              M.get_associated_function (|
                Ty.apply
                  (Ty.path "core::result::Result")
                  []
                  [
                    Ty.apply
                      (Ty.path "&mut")
                      []
                      [ Ty.apply (Ty.path "array") [ N ] [ Ty.path "u8" ] ];
                    Ty.path "core::array::TryFromSliceError"
                  ],
                "map",
                [],
                [
                  Ty.apply
                    (Ty.path "&mut")
                    []
                    [ Ty.apply (Ty.path "alloy_primitives::bits::fixed::FixedBytes") [ N ] [] ];
                  Ty.function
                    [
                      Ty.tuple
                        [
                          Ty.apply
                            (Ty.path "&mut")
                            []
                            [ Ty.apply (Ty.path "array") [ N ] [ Ty.path "u8" ] ]
                        ]
                    ]
                    (Ty.apply
                      (Ty.path "&mut")
                      []
                      [ Ty.apply (Ty.path "alloy_primitives::bits::fixed::FixedBytes") [ N ] [] ])
                ]
              |),
              [
                M.call_closure (|
                  Ty.apply
                    (Ty.path "core::result::Result")
                    []
                    [
                      Ty.apply
                        (Ty.path "&mut")
                        []
                        [ Ty.apply (Ty.path "array") [ N ] [ Ty.path "u8" ] ];
                      Ty.path "core::array::TryFromSliceError"
                    ],
                  M.get_trait_method (|
                    "core::convert::TryFrom",
                    Ty.apply
                      (Ty.path "&mut")
                      []
                      [ Ty.apply (Ty.path "array") [ N ] [ Ty.path "u8" ] ],
                    [],
                    [
                      Ty.apply
                        (Ty.path "&mut")
                        []
                        [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
                    ],
                    "try_from",
                    [],
                    []
                  |),
                  [ M.read (| slice |) ]
                |);
                M.closure
                  (fun γ =>
                    ltac:(M.monadic
                      match γ with
                      | [ α0 ] =>
                        ltac:(M.monadic
                          (M.match_operator (|
                            Ty.apply
                              (Ty.path "*")
                              []
                              [
                                Ty.function
                                  [
                                    Ty.tuple
                                      [
                                        Ty.apply
                                          (Ty.path "&mut")
                                          []
                                          [ Ty.apply (Ty.path "array") [ N ] [ Ty.path "u8" ] ]
                                      ]
                                  ]
                                  (Ty.apply
                                    (Ty.path "&mut")
                                    []
                                    [
                                      Ty.apply
                                        (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                                        [ N ]
                                        []
                                    ])
                              ],
                            M.alloc (| α0 |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let array_ref := M.copy (| γ |) in
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "&mut")
                                      []
                                      [
                                        Ty.apply
                                          (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                                          [ N ]
                                          []
                                      ],
                                    M.get_function (|
                                      "core::intrinsics::transmute",
                                      [],
                                      [
                                        Ty.apply
                                          (Ty.path "&mut")
                                          []
                                          [ Ty.apply (Ty.path "array") [ N ] [ Ty.path "u8" ] ];
                                        Ty.apply
                                          (Ty.path "&mut")
                                          []
                                          [
                                            Ty.apply
                                              (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                                              [ N ]
                                              []
                                          ]
                                      ]
                                    |),
                                    [ M.read (| array_ref |) ]
                                  |)))
                            ]
                          |)))
                      | _ => M.impossible "wrong number of arguments"
                      end))
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (N : Value.t),
        M.IsTraitInstance
          "core::convert::TryFrom"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ] ]
          (Self N)
          (* Instance *)
          [ ("Error", InstanceField.Ty (_Error N)); ("try_from", InstanceField.Method (try_from N))
          ].
    End Impl_core_convert_TryFrom_ref_mut_slice_u8_for_ref_mut_alloy_primitives_bits_fixed_FixedBytes_N.
    
    Module Impl_core_convert_From_u8_for_alloy_primitives_bits_fixed_FixedBytes_Usize_1.
      Definition Self : Ty.t :=
        Ty.apply
          (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
          [ Value.Integer IntegerKind.Usize 1 ]
          [].
      
      (*
                  fn from(value: $int) -> Self {
                      Self(value.to_be_bytes())
                  }
      *)
      Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            Value.StructTuple
              "alloy_primitives::bits::fixed::FixedBytes"
              [
                M.call_closure (|
                  Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 1 ] [ Ty.path "u8" ],
                  M.get_associated_function (| Ty.path "u8", "to_be_bytes", [], [] |),
                  [ M.read (| value |) ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u8" ]
          Self
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_u8_for_alloy_primitives_bits_fixed_FixedBytes_Usize_1.
    
    Module Impl_core_convert_From_alloy_primitives_bits_fixed_FixedBytes_Usize_1_for_u8.
      Definition Self : Ty.t := Ty.path "u8".
      
      (*
                  fn from(value: $fb) -> Self {
                      Self::from_be_bytes(value.0)
                  }
      *)
      Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            M.call_closure (|
              Ty.path "u8",
              M.get_associated_function (| Ty.path "u8", "from_be_bytes", [], [] |),
              [
                M.read (|
                  M.SubPointer.get_struct_tuple_field (|
                    value,
                    "alloy_primitives::bits::fixed::FixedBytes",
                    0
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [
            Ty.apply
              (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
              [ Value.Integer IntegerKind.Usize 1 ]
              []
          ]
          Self
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_alloy_primitives_bits_fixed_FixedBytes_Usize_1_for_u8.
    
    Module Impl_core_convert_From_ruint_Uint_Usize_8_Usize_1_for_alloy_primitives_bits_fixed_FixedBytes_Usize_1.
      Definition Self : Ty.t :=
        Ty.apply
          (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
          [ Value.Integer IntegerKind.Usize 1 ]
          [].
      
      (*
                  fn from(value: $int) -> Self {
                      Self(value.to_be_bytes())
                  }
      *)
      Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            Value.StructTuple
              "alloy_primitives::bits::fixed::FixedBytes"
              [
                M.call_closure (|
                  Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 1 ] [ Ty.path "u8" ],
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "ruint::Uint")
                      [ Value.Integer IntegerKind.Usize 8; Value.Integer IntegerKind.Usize 1 ]
                      [],
                    "to_be_bytes",
                    [ Value.Integer IntegerKind.Usize 1 ],
                    []
                  |),
                  [ M.borrow (| Pointer.Kind.Ref, value |) ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [
            Ty.apply
              (Ty.path "ruint::Uint")
              [ Value.Integer IntegerKind.Usize 8; Value.Integer IntegerKind.Usize 1 ]
              []
          ]
          Self
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_ruint_Uint_Usize_8_Usize_1_for_alloy_primitives_bits_fixed_FixedBytes_Usize_1.
    
    Module Impl_core_convert_From_alloy_primitives_bits_fixed_FixedBytes_Usize_1_for_ruint_Uint_Usize_8_Usize_1.
      Definition Self : Ty.t :=
        Ty.apply
          (Ty.path "ruint::Uint")
          [ Value.Integer IntegerKind.Usize 8; Value.Integer IntegerKind.Usize 1 ]
          [].
      
      (*
                  fn from(value: $fb) -> Self {
                      Self::from_be_bytes(value.0)
                  }
      *)
      Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "ruint::Uint")
                [ Value.Integer IntegerKind.Usize 8; Value.Integer IntegerKind.Usize 1 ]
                [],
              M.get_associated_function (|
                Ty.apply
                  (Ty.path "ruint::Uint")
                  [ Value.Integer IntegerKind.Usize 8; Value.Integer IntegerKind.Usize 1 ]
                  [],
                "from_be_bytes",
                [ Value.Integer IntegerKind.Usize 1 ],
                []
              |),
              [
                M.read (|
                  M.SubPointer.get_struct_tuple_field (|
                    value,
                    "alloy_primitives::bits::fixed::FixedBytes",
                    0
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [
            Ty.apply
              (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
              [ Value.Integer IntegerKind.Usize 1 ]
              []
          ]
          Self
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_alloy_primitives_bits_fixed_FixedBytes_Usize_1_for_ruint_Uint_Usize_8_Usize_1.
    
    Module Impl_core_convert_From_i8_for_alloy_primitives_bits_fixed_FixedBytes_Usize_1.
      Definition Self : Ty.t :=
        Ty.apply
          (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
          [ Value.Integer IntegerKind.Usize 1 ]
          [].
      
      (*
                  fn from(value: $int) -> Self {
                      Self(value.to_be_bytes())
                  }
      *)
      Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            Value.StructTuple
              "alloy_primitives::bits::fixed::FixedBytes"
              [
                M.call_closure (|
                  Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 1 ] [ Ty.path "u8" ],
                  M.get_associated_function (| Ty.path "i8", "to_be_bytes", [], [] |),
                  [ M.read (| value |) ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i8" ]
          Self
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_i8_for_alloy_primitives_bits_fixed_FixedBytes_Usize_1.
    
    Module Impl_core_convert_From_alloy_primitives_bits_fixed_FixedBytes_Usize_1_for_i8.
      Definition Self : Ty.t := Ty.path "i8".
      
      (*
                  fn from(value: $fb) -> Self {
                      Self::from_be_bytes(value.0)
                  }
      *)
      Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            M.call_closure (|
              Ty.path "i8",
              M.get_associated_function (| Ty.path "i8", "from_be_bytes", [], [] |),
              [
                M.read (|
                  M.SubPointer.get_struct_tuple_field (|
                    value,
                    "alloy_primitives::bits::fixed::FixedBytes",
                    0
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [
            Ty.apply
              (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
              [ Value.Integer IntegerKind.Usize 1 ]
              []
          ]
          Self
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_alloy_primitives_bits_fixed_FixedBytes_Usize_1_for_i8.
    
    Module Impl_core_convert_From_alloy_primitives_signed_int_Signed_Usize_8_Usize_1_for_alloy_primitives_bits_fixed_FixedBytes_Usize_1.
      Definition Self : Ty.t :=
        Ty.apply
          (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
          [ Value.Integer IntegerKind.Usize 1 ]
          [].
      
      (*
                  fn from(value: $int) -> Self {
                      Self(value.to_be_bytes())
                  }
      *)
      Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            Value.StructTuple
              "alloy_primitives::bits::fixed::FixedBytes"
              [
                M.call_closure (|
                  Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 1 ] [ Ty.path "u8" ],
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "alloy_primitives::signed::int::Signed")
                      [ Value.Integer IntegerKind.Usize 8; Value.Integer IntegerKind.Usize 1 ]
                      [],
                    "to_be_bytes",
                    [ Value.Integer IntegerKind.Usize 1 ],
                    []
                  |),
                  [ M.borrow (| Pointer.Kind.Ref, value |) ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [
            Ty.apply
              (Ty.path "alloy_primitives::signed::int::Signed")
              [ Value.Integer IntegerKind.Usize 8; Value.Integer IntegerKind.Usize 1 ]
              []
          ]
          Self
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_alloy_primitives_signed_int_Signed_Usize_8_Usize_1_for_alloy_primitives_bits_fixed_FixedBytes_Usize_1.
    
    Module Impl_core_convert_From_alloy_primitives_bits_fixed_FixedBytes_Usize_1_for_alloy_primitives_signed_int_Signed_Usize_8_Usize_1.
      Definition Self : Ty.t :=
        Ty.apply
          (Ty.path "alloy_primitives::signed::int::Signed")
          [ Value.Integer IntegerKind.Usize 8; Value.Integer IntegerKind.Usize 1 ]
          [].
      
      (*
                  fn from(value: $fb) -> Self {
                      Self::from_be_bytes(value.0)
                  }
      *)
      Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "alloy_primitives::signed::int::Signed")
                [ Value.Integer IntegerKind.Usize 8; Value.Integer IntegerKind.Usize 1 ]
                [],
              M.get_associated_function (|
                Ty.apply
                  (Ty.path "alloy_primitives::signed::int::Signed")
                  [ Value.Integer IntegerKind.Usize 8; Value.Integer IntegerKind.Usize 1 ]
                  [],
                "from_be_bytes",
                [ Value.Integer IntegerKind.Usize 1 ],
                []
              |),
              [
                M.read (|
                  M.SubPointer.get_struct_tuple_field (|
                    value,
                    "alloy_primitives::bits::fixed::FixedBytes",
                    0
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [
            Ty.apply
              (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
              [ Value.Integer IntegerKind.Usize 1 ]
              []
          ]
          Self
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_alloy_primitives_bits_fixed_FixedBytes_Usize_1_for_alloy_primitives_signed_int_Signed_Usize_8_Usize_1.
    
    Module Impl_core_convert_From_u16_for_alloy_primitives_bits_fixed_FixedBytes_Usize_2.
      Definition Self : Ty.t :=
        Ty.apply
          (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
          [ Value.Integer IntegerKind.Usize 2 ]
          [].
      
      (*
                  fn from(value: $int) -> Self {
                      Self(value.to_be_bytes())
                  }
      *)
      Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            Value.StructTuple
              "alloy_primitives::bits::fixed::FixedBytes"
              [
                M.call_closure (|
                  Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 2 ] [ Ty.path "u8" ],
                  M.get_associated_function (| Ty.path "u16", "to_be_bytes", [], [] |),
                  [ M.read (| value |) ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u16" ]
          Self
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_u16_for_alloy_primitives_bits_fixed_FixedBytes_Usize_2.
    
    Module Impl_core_convert_From_alloy_primitives_bits_fixed_FixedBytes_Usize_2_for_u16.
      Definition Self : Ty.t := Ty.path "u16".
      
      (*
                  fn from(value: $fb) -> Self {
                      Self::from_be_bytes(value.0)
                  }
      *)
      Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            M.call_closure (|
              Ty.path "u16",
              M.get_associated_function (| Ty.path "u16", "from_be_bytes", [], [] |),
              [
                M.read (|
                  M.SubPointer.get_struct_tuple_field (|
                    value,
                    "alloy_primitives::bits::fixed::FixedBytes",
                    0
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [
            Ty.apply
              (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
              [ Value.Integer IntegerKind.Usize 2 ]
              []
          ]
          Self
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_alloy_primitives_bits_fixed_FixedBytes_Usize_2_for_u16.
    
    Module Impl_core_convert_From_ruint_Uint_Usize_16_Usize_1_for_alloy_primitives_bits_fixed_FixedBytes_Usize_2.
      Definition Self : Ty.t :=
        Ty.apply
          (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
          [ Value.Integer IntegerKind.Usize 2 ]
          [].
      
      (*
                  fn from(value: $int) -> Self {
                      Self(value.to_be_bytes())
                  }
      *)
      Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            Value.StructTuple
              "alloy_primitives::bits::fixed::FixedBytes"
              [
                M.call_closure (|
                  Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 2 ] [ Ty.path "u8" ],
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "ruint::Uint")
                      [ Value.Integer IntegerKind.Usize 16; Value.Integer IntegerKind.Usize 1 ]
                      [],
                    "to_be_bytes",
                    [ Value.Integer IntegerKind.Usize 2 ],
                    []
                  |),
                  [ M.borrow (| Pointer.Kind.Ref, value |) ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [
            Ty.apply
              (Ty.path "ruint::Uint")
              [ Value.Integer IntegerKind.Usize 16; Value.Integer IntegerKind.Usize 1 ]
              []
          ]
          Self
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_ruint_Uint_Usize_16_Usize_1_for_alloy_primitives_bits_fixed_FixedBytes_Usize_2.
    
    Module Impl_core_convert_From_alloy_primitives_bits_fixed_FixedBytes_Usize_2_for_ruint_Uint_Usize_16_Usize_1.
      Definition Self : Ty.t :=
        Ty.apply
          (Ty.path "ruint::Uint")
          [ Value.Integer IntegerKind.Usize 16; Value.Integer IntegerKind.Usize 1 ]
          [].
      
      (*
                  fn from(value: $fb) -> Self {
                      Self::from_be_bytes(value.0)
                  }
      *)
      Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "ruint::Uint")
                [ Value.Integer IntegerKind.Usize 16; Value.Integer IntegerKind.Usize 1 ]
                [],
              M.get_associated_function (|
                Ty.apply
                  (Ty.path "ruint::Uint")
                  [ Value.Integer IntegerKind.Usize 16; Value.Integer IntegerKind.Usize 1 ]
                  [],
                "from_be_bytes",
                [ Value.Integer IntegerKind.Usize 2 ],
                []
              |),
              [
                M.read (|
                  M.SubPointer.get_struct_tuple_field (|
                    value,
                    "alloy_primitives::bits::fixed::FixedBytes",
                    0
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [
            Ty.apply
              (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
              [ Value.Integer IntegerKind.Usize 2 ]
              []
          ]
          Self
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_alloy_primitives_bits_fixed_FixedBytes_Usize_2_for_ruint_Uint_Usize_16_Usize_1.
    
    Module Impl_core_convert_From_i16_for_alloy_primitives_bits_fixed_FixedBytes_Usize_2.
      Definition Self : Ty.t :=
        Ty.apply
          (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
          [ Value.Integer IntegerKind.Usize 2 ]
          [].
      
      (*
                  fn from(value: $int) -> Self {
                      Self(value.to_be_bytes())
                  }
      *)
      Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            Value.StructTuple
              "alloy_primitives::bits::fixed::FixedBytes"
              [
                M.call_closure (|
                  Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 2 ] [ Ty.path "u8" ],
                  M.get_associated_function (| Ty.path "i16", "to_be_bytes", [], [] |),
                  [ M.read (| value |) ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i16" ]
          Self
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_i16_for_alloy_primitives_bits_fixed_FixedBytes_Usize_2.
    
    Module Impl_core_convert_From_alloy_primitives_bits_fixed_FixedBytes_Usize_2_for_i16.
      Definition Self : Ty.t := Ty.path "i16".
      
      (*
                  fn from(value: $fb) -> Self {
                      Self::from_be_bytes(value.0)
                  }
      *)
      Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            M.call_closure (|
              Ty.path "i16",
              M.get_associated_function (| Ty.path "i16", "from_be_bytes", [], [] |),
              [
                M.read (|
                  M.SubPointer.get_struct_tuple_field (|
                    value,
                    "alloy_primitives::bits::fixed::FixedBytes",
                    0
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [
            Ty.apply
              (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
              [ Value.Integer IntegerKind.Usize 2 ]
              []
          ]
          Self
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_alloy_primitives_bits_fixed_FixedBytes_Usize_2_for_i16.
    
    Module Impl_core_convert_From_alloy_primitives_signed_int_Signed_Usize_16_Usize_1_for_alloy_primitives_bits_fixed_FixedBytes_Usize_2.
      Definition Self : Ty.t :=
        Ty.apply
          (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
          [ Value.Integer IntegerKind.Usize 2 ]
          [].
      
      (*
                  fn from(value: $int) -> Self {
                      Self(value.to_be_bytes())
                  }
      *)
      Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            Value.StructTuple
              "alloy_primitives::bits::fixed::FixedBytes"
              [
                M.call_closure (|
                  Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 2 ] [ Ty.path "u8" ],
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "alloy_primitives::signed::int::Signed")
                      [ Value.Integer IntegerKind.Usize 16; Value.Integer IntegerKind.Usize 1 ]
                      [],
                    "to_be_bytes",
                    [ Value.Integer IntegerKind.Usize 2 ],
                    []
                  |),
                  [ M.borrow (| Pointer.Kind.Ref, value |) ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [
            Ty.apply
              (Ty.path "alloy_primitives::signed::int::Signed")
              [ Value.Integer IntegerKind.Usize 16; Value.Integer IntegerKind.Usize 1 ]
              []
          ]
          Self
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_alloy_primitives_signed_int_Signed_Usize_16_Usize_1_for_alloy_primitives_bits_fixed_FixedBytes_Usize_2.
    
    Module Impl_core_convert_From_alloy_primitives_bits_fixed_FixedBytes_Usize_2_for_alloy_primitives_signed_int_Signed_Usize_16_Usize_1.
      Definition Self : Ty.t :=
        Ty.apply
          (Ty.path "alloy_primitives::signed::int::Signed")
          [ Value.Integer IntegerKind.Usize 16; Value.Integer IntegerKind.Usize 1 ]
          [].
      
      (*
                  fn from(value: $fb) -> Self {
                      Self::from_be_bytes(value.0)
                  }
      *)
      Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "alloy_primitives::signed::int::Signed")
                [ Value.Integer IntegerKind.Usize 16; Value.Integer IntegerKind.Usize 1 ]
                [],
              M.get_associated_function (|
                Ty.apply
                  (Ty.path "alloy_primitives::signed::int::Signed")
                  [ Value.Integer IntegerKind.Usize 16; Value.Integer IntegerKind.Usize 1 ]
                  [],
                "from_be_bytes",
                [ Value.Integer IntegerKind.Usize 2 ],
                []
              |),
              [
                M.read (|
                  M.SubPointer.get_struct_tuple_field (|
                    value,
                    "alloy_primitives::bits::fixed::FixedBytes",
                    0
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [
            Ty.apply
              (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
              [ Value.Integer IntegerKind.Usize 2 ]
              []
          ]
          Self
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_alloy_primitives_bits_fixed_FixedBytes_Usize_2_for_alloy_primitives_signed_int_Signed_Usize_16_Usize_1.
    
    Module Impl_core_convert_From_u32_for_alloy_primitives_bits_fixed_FixedBytes_Usize_4.
      Definition Self : Ty.t :=
        Ty.apply
          (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
          [ Value.Integer IntegerKind.Usize 4 ]
          [].
      
      (*
                  fn from(value: $int) -> Self {
                      Self(value.to_be_bytes())
                  }
      *)
      Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            Value.StructTuple
              "alloy_primitives::bits::fixed::FixedBytes"
              [
                M.call_closure (|
                  Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 4 ] [ Ty.path "u8" ],
                  M.get_associated_function (| Ty.path "u32", "to_be_bytes", [], [] |),
                  [ M.read (| value |) ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u32" ]
          Self
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_u32_for_alloy_primitives_bits_fixed_FixedBytes_Usize_4.
    
    Module Impl_core_convert_From_alloy_primitives_bits_fixed_FixedBytes_Usize_4_for_u32.
      Definition Self : Ty.t := Ty.path "u32".
      
      (*
                  fn from(value: $fb) -> Self {
                      Self::from_be_bytes(value.0)
                  }
      *)
      Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            M.call_closure (|
              Ty.path "u32",
              M.get_associated_function (| Ty.path "u32", "from_be_bytes", [], [] |),
              [
                M.read (|
                  M.SubPointer.get_struct_tuple_field (|
                    value,
                    "alloy_primitives::bits::fixed::FixedBytes",
                    0
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [
            Ty.apply
              (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
              [ Value.Integer IntegerKind.Usize 4 ]
              []
          ]
          Self
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_alloy_primitives_bits_fixed_FixedBytes_Usize_4_for_u32.
    
    Module Impl_core_convert_From_ruint_Uint_Usize_32_Usize_1_for_alloy_primitives_bits_fixed_FixedBytes_Usize_4.
      Definition Self : Ty.t :=
        Ty.apply
          (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
          [ Value.Integer IntegerKind.Usize 4 ]
          [].
      
      (*
                  fn from(value: $int) -> Self {
                      Self(value.to_be_bytes())
                  }
      *)
      Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            Value.StructTuple
              "alloy_primitives::bits::fixed::FixedBytes"
              [
                M.call_closure (|
                  Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 4 ] [ Ty.path "u8" ],
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "ruint::Uint")
                      [ Value.Integer IntegerKind.Usize 32; Value.Integer IntegerKind.Usize 1 ]
                      [],
                    "to_be_bytes",
                    [ Value.Integer IntegerKind.Usize 4 ],
                    []
                  |),
                  [ M.borrow (| Pointer.Kind.Ref, value |) ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [
            Ty.apply
              (Ty.path "ruint::Uint")
              [ Value.Integer IntegerKind.Usize 32; Value.Integer IntegerKind.Usize 1 ]
              []
          ]
          Self
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_ruint_Uint_Usize_32_Usize_1_for_alloy_primitives_bits_fixed_FixedBytes_Usize_4.
    
    Module Impl_core_convert_From_alloy_primitives_bits_fixed_FixedBytes_Usize_4_for_ruint_Uint_Usize_32_Usize_1.
      Definition Self : Ty.t :=
        Ty.apply
          (Ty.path "ruint::Uint")
          [ Value.Integer IntegerKind.Usize 32; Value.Integer IntegerKind.Usize 1 ]
          [].
      
      (*
                  fn from(value: $fb) -> Self {
                      Self::from_be_bytes(value.0)
                  }
      *)
      Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "ruint::Uint")
                [ Value.Integer IntegerKind.Usize 32; Value.Integer IntegerKind.Usize 1 ]
                [],
              M.get_associated_function (|
                Ty.apply
                  (Ty.path "ruint::Uint")
                  [ Value.Integer IntegerKind.Usize 32; Value.Integer IntegerKind.Usize 1 ]
                  [],
                "from_be_bytes",
                [ Value.Integer IntegerKind.Usize 4 ],
                []
              |),
              [
                M.read (|
                  M.SubPointer.get_struct_tuple_field (|
                    value,
                    "alloy_primitives::bits::fixed::FixedBytes",
                    0
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [
            Ty.apply
              (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
              [ Value.Integer IntegerKind.Usize 4 ]
              []
          ]
          Self
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_alloy_primitives_bits_fixed_FixedBytes_Usize_4_for_ruint_Uint_Usize_32_Usize_1.
    
    Module Impl_core_convert_From_i32_for_alloy_primitives_bits_fixed_FixedBytes_Usize_4.
      Definition Self : Ty.t :=
        Ty.apply
          (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
          [ Value.Integer IntegerKind.Usize 4 ]
          [].
      
      (*
                  fn from(value: $int) -> Self {
                      Self(value.to_be_bytes())
                  }
      *)
      Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            Value.StructTuple
              "alloy_primitives::bits::fixed::FixedBytes"
              [
                M.call_closure (|
                  Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 4 ] [ Ty.path "u8" ],
                  M.get_associated_function (| Ty.path "i32", "to_be_bytes", [], [] |),
                  [ M.read (| value |) ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i32" ]
          Self
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_i32_for_alloy_primitives_bits_fixed_FixedBytes_Usize_4.
    
    Module Impl_core_convert_From_alloy_primitives_bits_fixed_FixedBytes_Usize_4_for_i32.
      Definition Self : Ty.t := Ty.path "i32".
      
      (*
                  fn from(value: $fb) -> Self {
                      Self::from_be_bytes(value.0)
                  }
      *)
      Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            M.call_closure (|
              Ty.path "i32",
              M.get_associated_function (| Ty.path "i32", "from_be_bytes", [], [] |),
              [
                M.read (|
                  M.SubPointer.get_struct_tuple_field (|
                    value,
                    "alloy_primitives::bits::fixed::FixedBytes",
                    0
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [
            Ty.apply
              (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
              [ Value.Integer IntegerKind.Usize 4 ]
              []
          ]
          Self
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_alloy_primitives_bits_fixed_FixedBytes_Usize_4_for_i32.
    
    Module Impl_core_convert_From_alloy_primitives_signed_int_Signed_Usize_32_Usize_1_for_alloy_primitives_bits_fixed_FixedBytes_Usize_4.
      Definition Self : Ty.t :=
        Ty.apply
          (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
          [ Value.Integer IntegerKind.Usize 4 ]
          [].
      
      (*
                  fn from(value: $int) -> Self {
                      Self(value.to_be_bytes())
                  }
      *)
      Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            Value.StructTuple
              "alloy_primitives::bits::fixed::FixedBytes"
              [
                M.call_closure (|
                  Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 4 ] [ Ty.path "u8" ],
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "alloy_primitives::signed::int::Signed")
                      [ Value.Integer IntegerKind.Usize 32; Value.Integer IntegerKind.Usize 1 ]
                      [],
                    "to_be_bytes",
                    [ Value.Integer IntegerKind.Usize 4 ],
                    []
                  |),
                  [ M.borrow (| Pointer.Kind.Ref, value |) ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [
            Ty.apply
              (Ty.path "alloy_primitives::signed::int::Signed")
              [ Value.Integer IntegerKind.Usize 32; Value.Integer IntegerKind.Usize 1 ]
              []
          ]
          Self
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_alloy_primitives_signed_int_Signed_Usize_32_Usize_1_for_alloy_primitives_bits_fixed_FixedBytes_Usize_4.
    
    Module Impl_core_convert_From_alloy_primitives_bits_fixed_FixedBytes_Usize_4_for_alloy_primitives_signed_int_Signed_Usize_32_Usize_1.
      Definition Self : Ty.t :=
        Ty.apply
          (Ty.path "alloy_primitives::signed::int::Signed")
          [ Value.Integer IntegerKind.Usize 32; Value.Integer IntegerKind.Usize 1 ]
          [].
      
      (*
                  fn from(value: $fb) -> Self {
                      Self::from_be_bytes(value.0)
                  }
      *)
      Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "alloy_primitives::signed::int::Signed")
                [ Value.Integer IntegerKind.Usize 32; Value.Integer IntegerKind.Usize 1 ]
                [],
              M.get_associated_function (|
                Ty.apply
                  (Ty.path "alloy_primitives::signed::int::Signed")
                  [ Value.Integer IntegerKind.Usize 32; Value.Integer IntegerKind.Usize 1 ]
                  [],
                "from_be_bytes",
                [ Value.Integer IntegerKind.Usize 4 ],
                []
              |),
              [
                M.read (|
                  M.SubPointer.get_struct_tuple_field (|
                    value,
                    "alloy_primitives::bits::fixed::FixedBytes",
                    0
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [
            Ty.apply
              (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
              [ Value.Integer IntegerKind.Usize 4 ]
              []
          ]
          Self
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_alloy_primitives_bits_fixed_FixedBytes_Usize_4_for_alloy_primitives_signed_int_Signed_Usize_32_Usize_1.
    
    Module Impl_core_convert_From_u64_for_alloy_primitives_bits_fixed_FixedBytes_Usize_8.
      Definition Self : Ty.t :=
        Ty.apply
          (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
          [ Value.Integer IntegerKind.Usize 8 ]
          [].
      
      (*
                  fn from(value: $int) -> Self {
                      Self(value.to_be_bytes())
                  }
      *)
      Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            Value.StructTuple
              "alloy_primitives::bits::fixed::FixedBytes"
              [
                M.call_closure (|
                  Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 8 ] [ Ty.path "u8" ],
                  M.get_associated_function (| Ty.path "u64", "to_be_bytes", [], [] |),
                  [ M.read (| value |) ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u64" ]
          Self
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_u64_for_alloy_primitives_bits_fixed_FixedBytes_Usize_8.
    
    Module Impl_core_convert_From_alloy_primitives_bits_fixed_FixedBytes_Usize_8_for_u64.
      Definition Self : Ty.t := Ty.path "u64".
      
      (*
                  fn from(value: $fb) -> Self {
                      Self::from_be_bytes(value.0)
                  }
      *)
      Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            M.call_closure (|
              Ty.path "u64",
              M.get_associated_function (| Ty.path "u64", "from_be_bytes", [], [] |),
              [
                M.read (|
                  M.SubPointer.get_struct_tuple_field (|
                    value,
                    "alloy_primitives::bits::fixed::FixedBytes",
                    0
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [
            Ty.apply
              (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
              [ Value.Integer IntegerKind.Usize 8 ]
              []
          ]
          Self
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_alloy_primitives_bits_fixed_FixedBytes_Usize_8_for_u64.
    
    Module Impl_core_convert_From_ruint_Uint_Usize_64_Usize_1_for_alloy_primitives_bits_fixed_FixedBytes_Usize_8.
      Definition Self : Ty.t :=
        Ty.apply
          (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
          [ Value.Integer IntegerKind.Usize 8 ]
          [].
      
      (*
                  fn from(value: $int) -> Self {
                      Self(value.to_be_bytes())
                  }
      *)
      Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            Value.StructTuple
              "alloy_primitives::bits::fixed::FixedBytes"
              [
                M.call_closure (|
                  Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 8 ] [ Ty.path "u8" ],
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "ruint::Uint")
                      [ Value.Integer IntegerKind.Usize 64; Value.Integer IntegerKind.Usize 1 ]
                      [],
                    "to_be_bytes",
                    [ Value.Integer IntegerKind.Usize 8 ],
                    []
                  |),
                  [ M.borrow (| Pointer.Kind.Ref, value |) ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [
            Ty.apply
              (Ty.path "ruint::Uint")
              [ Value.Integer IntegerKind.Usize 64; Value.Integer IntegerKind.Usize 1 ]
              []
          ]
          Self
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_ruint_Uint_Usize_64_Usize_1_for_alloy_primitives_bits_fixed_FixedBytes_Usize_8.
    
    Module Impl_core_convert_From_alloy_primitives_bits_fixed_FixedBytes_Usize_8_for_ruint_Uint_Usize_64_Usize_1.
      Definition Self : Ty.t :=
        Ty.apply
          (Ty.path "ruint::Uint")
          [ Value.Integer IntegerKind.Usize 64; Value.Integer IntegerKind.Usize 1 ]
          [].
      
      (*
                  fn from(value: $fb) -> Self {
                      Self::from_be_bytes(value.0)
                  }
      *)
      Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "ruint::Uint")
                [ Value.Integer IntegerKind.Usize 64; Value.Integer IntegerKind.Usize 1 ]
                [],
              M.get_associated_function (|
                Ty.apply
                  (Ty.path "ruint::Uint")
                  [ Value.Integer IntegerKind.Usize 64; Value.Integer IntegerKind.Usize 1 ]
                  [],
                "from_be_bytes",
                [ Value.Integer IntegerKind.Usize 8 ],
                []
              |),
              [
                M.read (|
                  M.SubPointer.get_struct_tuple_field (|
                    value,
                    "alloy_primitives::bits::fixed::FixedBytes",
                    0
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [
            Ty.apply
              (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
              [ Value.Integer IntegerKind.Usize 8 ]
              []
          ]
          Self
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_alloy_primitives_bits_fixed_FixedBytes_Usize_8_for_ruint_Uint_Usize_64_Usize_1.
    
    Module Impl_core_convert_From_i64_for_alloy_primitives_bits_fixed_FixedBytes_Usize_8.
      Definition Self : Ty.t :=
        Ty.apply
          (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
          [ Value.Integer IntegerKind.Usize 8 ]
          [].
      
      (*
                  fn from(value: $int) -> Self {
                      Self(value.to_be_bytes())
                  }
      *)
      Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            Value.StructTuple
              "alloy_primitives::bits::fixed::FixedBytes"
              [
                M.call_closure (|
                  Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 8 ] [ Ty.path "u8" ],
                  M.get_associated_function (| Ty.path "i64", "to_be_bytes", [], [] |),
                  [ M.read (| value |) ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i64" ]
          Self
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_i64_for_alloy_primitives_bits_fixed_FixedBytes_Usize_8.
    
    Module Impl_core_convert_From_alloy_primitives_bits_fixed_FixedBytes_Usize_8_for_i64.
      Definition Self : Ty.t := Ty.path "i64".
      
      (*
                  fn from(value: $fb) -> Self {
                      Self::from_be_bytes(value.0)
                  }
      *)
      Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            M.call_closure (|
              Ty.path "i64",
              M.get_associated_function (| Ty.path "i64", "from_be_bytes", [], [] |),
              [
                M.read (|
                  M.SubPointer.get_struct_tuple_field (|
                    value,
                    "alloy_primitives::bits::fixed::FixedBytes",
                    0
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [
            Ty.apply
              (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
              [ Value.Integer IntegerKind.Usize 8 ]
              []
          ]
          Self
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_alloy_primitives_bits_fixed_FixedBytes_Usize_8_for_i64.
    
    Module Impl_core_convert_From_alloy_primitives_signed_int_Signed_Usize_64_Usize_1_for_alloy_primitives_bits_fixed_FixedBytes_Usize_8.
      Definition Self : Ty.t :=
        Ty.apply
          (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
          [ Value.Integer IntegerKind.Usize 8 ]
          [].
      
      (*
                  fn from(value: $int) -> Self {
                      Self(value.to_be_bytes())
                  }
      *)
      Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            Value.StructTuple
              "alloy_primitives::bits::fixed::FixedBytes"
              [
                M.call_closure (|
                  Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 8 ] [ Ty.path "u8" ],
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "alloy_primitives::signed::int::Signed")
                      [ Value.Integer IntegerKind.Usize 64; Value.Integer IntegerKind.Usize 1 ]
                      [],
                    "to_be_bytes",
                    [ Value.Integer IntegerKind.Usize 8 ],
                    []
                  |),
                  [ M.borrow (| Pointer.Kind.Ref, value |) ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [
            Ty.apply
              (Ty.path "alloy_primitives::signed::int::Signed")
              [ Value.Integer IntegerKind.Usize 64; Value.Integer IntegerKind.Usize 1 ]
              []
          ]
          Self
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_alloy_primitives_signed_int_Signed_Usize_64_Usize_1_for_alloy_primitives_bits_fixed_FixedBytes_Usize_8.
    
    Module Impl_core_convert_From_alloy_primitives_bits_fixed_FixedBytes_Usize_8_for_alloy_primitives_signed_int_Signed_Usize_64_Usize_1.
      Definition Self : Ty.t :=
        Ty.apply
          (Ty.path "alloy_primitives::signed::int::Signed")
          [ Value.Integer IntegerKind.Usize 64; Value.Integer IntegerKind.Usize 1 ]
          [].
      
      (*
                  fn from(value: $fb) -> Self {
                      Self::from_be_bytes(value.0)
                  }
      *)
      Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "alloy_primitives::signed::int::Signed")
                [ Value.Integer IntegerKind.Usize 64; Value.Integer IntegerKind.Usize 1 ]
                [],
              M.get_associated_function (|
                Ty.apply
                  (Ty.path "alloy_primitives::signed::int::Signed")
                  [ Value.Integer IntegerKind.Usize 64; Value.Integer IntegerKind.Usize 1 ]
                  [],
                "from_be_bytes",
                [ Value.Integer IntegerKind.Usize 8 ],
                []
              |),
              [
                M.read (|
                  M.SubPointer.get_struct_tuple_field (|
                    value,
                    "alloy_primitives::bits::fixed::FixedBytes",
                    0
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [
            Ty.apply
              (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
              [ Value.Integer IntegerKind.Usize 8 ]
              []
          ]
          Self
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_alloy_primitives_bits_fixed_FixedBytes_Usize_8_for_alloy_primitives_signed_int_Signed_Usize_64_Usize_1.
    
    Module Impl_core_convert_From_u128_for_alloy_primitives_bits_fixed_FixedBytes_Usize_16.
      Definition Self : Ty.t :=
        Ty.apply
          (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
          [ Value.Integer IntegerKind.Usize 16 ]
          [].
      
      (*
                  fn from(value: $int) -> Self {
                      Self(value.to_be_bytes())
                  }
      *)
      Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            Value.StructTuple
              "alloy_primitives::bits::fixed::FixedBytes"
              [
                M.call_closure (|
                  Ty.apply
                    (Ty.path "array")
                    [ Value.Integer IntegerKind.Usize 16 ]
                    [ Ty.path "u8" ],
                  M.get_associated_function (| Ty.path "u128", "to_be_bytes", [], [] |),
                  [ M.read (| value |) ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u128" ]
          Self
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_u128_for_alloy_primitives_bits_fixed_FixedBytes_Usize_16.
    
    Module Impl_core_convert_From_alloy_primitives_bits_fixed_FixedBytes_Usize_16_for_u128.
      Definition Self : Ty.t := Ty.path "u128".
      
      (*
                  fn from(value: $fb) -> Self {
                      Self::from_be_bytes(value.0)
                  }
      *)
      Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            M.call_closure (|
              Ty.path "u128",
              M.get_associated_function (| Ty.path "u128", "from_be_bytes", [], [] |),
              [
                M.read (|
                  M.SubPointer.get_struct_tuple_field (|
                    value,
                    "alloy_primitives::bits::fixed::FixedBytes",
                    0
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [
            Ty.apply
              (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
              [ Value.Integer IntegerKind.Usize 16 ]
              []
          ]
          Self
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_alloy_primitives_bits_fixed_FixedBytes_Usize_16_for_u128.
    
    Module Impl_core_convert_From_ruint_Uint_Usize_128_Usize_2_for_alloy_primitives_bits_fixed_FixedBytes_Usize_16.
      Definition Self : Ty.t :=
        Ty.apply
          (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
          [ Value.Integer IntegerKind.Usize 16 ]
          [].
      
      (*
                  fn from(value: $int) -> Self {
                      Self(value.to_be_bytes())
                  }
      *)
      Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            Value.StructTuple
              "alloy_primitives::bits::fixed::FixedBytes"
              [
                M.call_closure (|
                  Ty.apply
                    (Ty.path "array")
                    [ Value.Integer IntegerKind.Usize 16 ]
                    [ Ty.path "u8" ],
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "ruint::Uint")
                      [ Value.Integer IntegerKind.Usize 128; Value.Integer IntegerKind.Usize 2 ]
                      [],
                    "to_be_bytes",
                    [ Value.Integer IntegerKind.Usize 16 ],
                    []
                  |),
                  [ M.borrow (| Pointer.Kind.Ref, value |) ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [
            Ty.apply
              (Ty.path "ruint::Uint")
              [ Value.Integer IntegerKind.Usize 128; Value.Integer IntegerKind.Usize 2 ]
              []
          ]
          Self
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_ruint_Uint_Usize_128_Usize_2_for_alloy_primitives_bits_fixed_FixedBytes_Usize_16.
    
    Module Impl_core_convert_From_alloy_primitives_bits_fixed_FixedBytes_Usize_16_for_ruint_Uint_Usize_128_Usize_2.
      Definition Self : Ty.t :=
        Ty.apply
          (Ty.path "ruint::Uint")
          [ Value.Integer IntegerKind.Usize 128; Value.Integer IntegerKind.Usize 2 ]
          [].
      
      (*
                  fn from(value: $fb) -> Self {
                      Self::from_be_bytes(value.0)
                  }
      *)
      Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "ruint::Uint")
                [ Value.Integer IntegerKind.Usize 128; Value.Integer IntegerKind.Usize 2 ]
                [],
              M.get_associated_function (|
                Ty.apply
                  (Ty.path "ruint::Uint")
                  [ Value.Integer IntegerKind.Usize 128; Value.Integer IntegerKind.Usize 2 ]
                  [],
                "from_be_bytes",
                [ Value.Integer IntegerKind.Usize 16 ],
                []
              |),
              [
                M.read (|
                  M.SubPointer.get_struct_tuple_field (|
                    value,
                    "alloy_primitives::bits::fixed::FixedBytes",
                    0
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [
            Ty.apply
              (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
              [ Value.Integer IntegerKind.Usize 16 ]
              []
          ]
          Self
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_alloy_primitives_bits_fixed_FixedBytes_Usize_16_for_ruint_Uint_Usize_128_Usize_2.
    
    Module Impl_core_convert_From_i128_for_alloy_primitives_bits_fixed_FixedBytes_Usize_16.
      Definition Self : Ty.t :=
        Ty.apply
          (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
          [ Value.Integer IntegerKind.Usize 16 ]
          [].
      
      (*
                  fn from(value: $int) -> Self {
                      Self(value.to_be_bytes())
                  }
      *)
      Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            Value.StructTuple
              "alloy_primitives::bits::fixed::FixedBytes"
              [
                M.call_closure (|
                  Ty.apply
                    (Ty.path "array")
                    [ Value.Integer IntegerKind.Usize 16 ]
                    [ Ty.path "u8" ],
                  M.get_associated_function (| Ty.path "i128", "to_be_bytes", [], [] |),
                  [ M.read (| value |) ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i128" ]
          Self
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_i128_for_alloy_primitives_bits_fixed_FixedBytes_Usize_16.
    
    Module Impl_core_convert_From_alloy_primitives_bits_fixed_FixedBytes_Usize_16_for_i128.
      Definition Self : Ty.t := Ty.path "i128".
      
      (*
                  fn from(value: $fb) -> Self {
                      Self::from_be_bytes(value.0)
                  }
      *)
      Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            M.call_closure (|
              Ty.path "i128",
              M.get_associated_function (| Ty.path "i128", "from_be_bytes", [], [] |),
              [
                M.read (|
                  M.SubPointer.get_struct_tuple_field (|
                    value,
                    "alloy_primitives::bits::fixed::FixedBytes",
                    0
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [
            Ty.apply
              (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
              [ Value.Integer IntegerKind.Usize 16 ]
              []
          ]
          Self
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_alloy_primitives_bits_fixed_FixedBytes_Usize_16_for_i128.
    
    Module Impl_core_convert_From_alloy_primitives_signed_int_Signed_Usize_128_Usize_2_for_alloy_primitives_bits_fixed_FixedBytes_Usize_16.
      Definition Self : Ty.t :=
        Ty.apply
          (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
          [ Value.Integer IntegerKind.Usize 16 ]
          [].
      
      (*
                  fn from(value: $int) -> Self {
                      Self(value.to_be_bytes())
                  }
      *)
      Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            Value.StructTuple
              "alloy_primitives::bits::fixed::FixedBytes"
              [
                M.call_closure (|
                  Ty.apply
                    (Ty.path "array")
                    [ Value.Integer IntegerKind.Usize 16 ]
                    [ Ty.path "u8" ],
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "alloy_primitives::signed::int::Signed")
                      [ Value.Integer IntegerKind.Usize 128; Value.Integer IntegerKind.Usize 2 ]
                      [],
                    "to_be_bytes",
                    [ Value.Integer IntegerKind.Usize 16 ],
                    []
                  |),
                  [ M.borrow (| Pointer.Kind.Ref, value |) ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [
            Ty.apply
              (Ty.path "alloy_primitives::signed::int::Signed")
              [ Value.Integer IntegerKind.Usize 128; Value.Integer IntegerKind.Usize 2 ]
              []
          ]
          Self
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_alloy_primitives_signed_int_Signed_Usize_128_Usize_2_for_alloy_primitives_bits_fixed_FixedBytes_Usize_16.
    
    Module Impl_core_convert_From_alloy_primitives_bits_fixed_FixedBytes_Usize_16_for_alloy_primitives_signed_int_Signed_Usize_128_Usize_2.
      Definition Self : Ty.t :=
        Ty.apply
          (Ty.path "alloy_primitives::signed::int::Signed")
          [ Value.Integer IntegerKind.Usize 128; Value.Integer IntegerKind.Usize 2 ]
          [].
      
      (*
                  fn from(value: $fb) -> Self {
                      Self::from_be_bytes(value.0)
                  }
      *)
      Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "alloy_primitives::signed::int::Signed")
                [ Value.Integer IntegerKind.Usize 128; Value.Integer IntegerKind.Usize 2 ]
                [],
              M.get_associated_function (|
                Ty.apply
                  (Ty.path "alloy_primitives::signed::int::Signed")
                  [ Value.Integer IntegerKind.Usize 128; Value.Integer IntegerKind.Usize 2 ]
                  [],
                "from_be_bytes",
                [ Value.Integer IntegerKind.Usize 16 ],
                []
              |),
              [
                M.read (|
                  M.SubPointer.get_struct_tuple_field (|
                    value,
                    "alloy_primitives::bits::fixed::FixedBytes",
                    0
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [
            Ty.apply
              (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
              [ Value.Integer IntegerKind.Usize 16 ]
              []
          ]
          Self
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_alloy_primitives_bits_fixed_FixedBytes_Usize_16_for_alloy_primitives_signed_int_Signed_Usize_128_Usize_2.
    
    Module Impl_core_convert_From_ruint_Uint_Usize_160_Usize_3_for_alloy_primitives_bits_fixed_FixedBytes_Usize_20.
      Definition Self : Ty.t :=
        Ty.apply
          (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
          [ Value.Integer IntegerKind.Usize 20 ]
          [].
      
      (*
                  fn from(value: $int) -> Self {
                      Self(value.to_be_bytes())
                  }
      *)
      Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            Value.StructTuple
              "alloy_primitives::bits::fixed::FixedBytes"
              [
                M.call_closure (|
                  Ty.apply
                    (Ty.path "array")
                    [ Value.Integer IntegerKind.Usize 20 ]
                    [ Ty.path "u8" ],
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "ruint::Uint")
                      [ Value.Integer IntegerKind.Usize 160; Value.Integer IntegerKind.Usize 3 ]
                      [],
                    "to_be_bytes",
                    [ Value.Integer IntegerKind.Usize 20 ],
                    []
                  |),
                  [ M.borrow (| Pointer.Kind.Ref, value |) ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [
            Ty.apply
              (Ty.path "ruint::Uint")
              [ Value.Integer IntegerKind.Usize 160; Value.Integer IntegerKind.Usize 3 ]
              []
          ]
          Self
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_ruint_Uint_Usize_160_Usize_3_for_alloy_primitives_bits_fixed_FixedBytes_Usize_20.
    
    Module Impl_core_convert_From_alloy_primitives_bits_fixed_FixedBytes_Usize_20_for_ruint_Uint_Usize_160_Usize_3.
      Definition Self : Ty.t :=
        Ty.apply
          (Ty.path "ruint::Uint")
          [ Value.Integer IntegerKind.Usize 160; Value.Integer IntegerKind.Usize 3 ]
          [].
      
      (*
                  fn from(value: $fb) -> Self {
                      Self::from_be_bytes(value.0)
                  }
      *)
      Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "ruint::Uint")
                [ Value.Integer IntegerKind.Usize 160; Value.Integer IntegerKind.Usize 3 ]
                [],
              M.get_associated_function (|
                Ty.apply
                  (Ty.path "ruint::Uint")
                  [ Value.Integer IntegerKind.Usize 160; Value.Integer IntegerKind.Usize 3 ]
                  [],
                "from_be_bytes",
                [ Value.Integer IntegerKind.Usize 20 ],
                []
              |),
              [
                M.read (|
                  M.SubPointer.get_struct_tuple_field (|
                    value,
                    "alloy_primitives::bits::fixed::FixedBytes",
                    0
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [
            Ty.apply
              (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
              [ Value.Integer IntegerKind.Usize 20 ]
              []
          ]
          Self
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_alloy_primitives_bits_fixed_FixedBytes_Usize_20_for_ruint_Uint_Usize_160_Usize_3.
    
    Module Impl_core_convert_From_alloy_primitives_signed_int_Signed_Usize_160_Usize_3_for_alloy_primitives_bits_fixed_FixedBytes_Usize_20.
      Definition Self : Ty.t :=
        Ty.apply
          (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
          [ Value.Integer IntegerKind.Usize 20 ]
          [].
      
      (*
                  fn from(value: $int) -> Self {
                      Self(value.to_be_bytes())
                  }
      *)
      Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            Value.StructTuple
              "alloy_primitives::bits::fixed::FixedBytes"
              [
                M.call_closure (|
                  Ty.apply
                    (Ty.path "array")
                    [ Value.Integer IntegerKind.Usize 20 ]
                    [ Ty.path "u8" ],
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "alloy_primitives::signed::int::Signed")
                      [ Value.Integer IntegerKind.Usize 160; Value.Integer IntegerKind.Usize 3 ]
                      [],
                    "to_be_bytes",
                    [ Value.Integer IntegerKind.Usize 20 ],
                    []
                  |),
                  [ M.borrow (| Pointer.Kind.Ref, value |) ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [
            Ty.apply
              (Ty.path "alloy_primitives::signed::int::Signed")
              [ Value.Integer IntegerKind.Usize 160; Value.Integer IntegerKind.Usize 3 ]
              []
          ]
          Self
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_alloy_primitives_signed_int_Signed_Usize_160_Usize_3_for_alloy_primitives_bits_fixed_FixedBytes_Usize_20.
    
    Module Impl_core_convert_From_alloy_primitives_bits_fixed_FixedBytes_Usize_20_for_alloy_primitives_signed_int_Signed_Usize_160_Usize_3.
      Definition Self : Ty.t :=
        Ty.apply
          (Ty.path "alloy_primitives::signed::int::Signed")
          [ Value.Integer IntegerKind.Usize 160; Value.Integer IntegerKind.Usize 3 ]
          [].
      
      (*
                  fn from(value: $fb) -> Self {
                      Self::from_be_bytes(value.0)
                  }
      *)
      Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "alloy_primitives::signed::int::Signed")
                [ Value.Integer IntegerKind.Usize 160; Value.Integer IntegerKind.Usize 3 ]
                [],
              M.get_associated_function (|
                Ty.apply
                  (Ty.path "alloy_primitives::signed::int::Signed")
                  [ Value.Integer IntegerKind.Usize 160; Value.Integer IntegerKind.Usize 3 ]
                  [],
                "from_be_bytes",
                [ Value.Integer IntegerKind.Usize 20 ],
                []
              |),
              [
                M.read (|
                  M.SubPointer.get_struct_tuple_field (|
                    value,
                    "alloy_primitives::bits::fixed::FixedBytes",
                    0
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [
            Ty.apply
              (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
              [ Value.Integer IntegerKind.Usize 20 ]
              []
          ]
          Self
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_alloy_primitives_bits_fixed_FixedBytes_Usize_20_for_alloy_primitives_signed_int_Signed_Usize_160_Usize_3.
    
    Module Impl_core_convert_From_ruint_Uint_Usize_256_Usize_4_for_alloy_primitives_bits_fixed_FixedBytes_Usize_32.
      Definition Self : Ty.t :=
        Ty.apply
          (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
          [ Value.Integer IntegerKind.Usize 32 ]
          [].
      
      (*
                  fn from(value: $int) -> Self {
                      Self(value.to_be_bytes())
                  }
      *)
      Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            Value.StructTuple
              "alloy_primitives::bits::fixed::FixedBytes"
              [
                M.call_closure (|
                  Ty.apply
                    (Ty.path "array")
                    [ Value.Integer IntegerKind.Usize 32 ]
                    [ Ty.path "u8" ],
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "ruint::Uint")
                      [ Value.Integer IntegerKind.Usize 256; Value.Integer IntegerKind.Usize 4 ]
                      [],
                    "to_be_bytes",
                    [ Value.Integer IntegerKind.Usize 32 ],
                    []
                  |),
                  [ M.borrow (| Pointer.Kind.Ref, value |) ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [
            Ty.apply
              (Ty.path "ruint::Uint")
              [ Value.Integer IntegerKind.Usize 256; Value.Integer IntegerKind.Usize 4 ]
              []
          ]
          Self
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_ruint_Uint_Usize_256_Usize_4_for_alloy_primitives_bits_fixed_FixedBytes_Usize_32.
    
    Module Impl_core_convert_From_alloy_primitives_bits_fixed_FixedBytes_Usize_32_for_ruint_Uint_Usize_256_Usize_4.
      Definition Self : Ty.t :=
        Ty.apply
          (Ty.path "ruint::Uint")
          [ Value.Integer IntegerKind.Usize 256; Value.Integer IntegerKind.Usize 4 ]
          [].
      
      (*
                  fn from(value: $fb) -> Self {
                      Self::from_be_bytes(value.0)
                  }
      *)
      Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "ruint::Uint")
                [ Value.Integer IntegerKind.Usize 256; Value.Integer IntegerKind.Usize 4 ]
                [],
              M.get_associated_function (|
                Ty.apply
                  (Ty.path "ruint::Uint")
                  [ Value.Integer IntegerKind.Usize 256; Value.Integer IntegerKind.Usize 4 ]
                  [],
                "from_be_bytes",
                [ Value.Integer IntegerKind.Usize 32 ],
                []
              |),
              [
                M.read (|
                  M.SubPointer.get_struct_tuple_field (|
                    value,
                    "alloy_primitives::bits::fixed::FixedBytes",
                    0
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [
            Ty.apply
              (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
              [ Value.Integer IntegerKind.Usize 32 ]
              []
          ]
          Self
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_alloy_primitives_bits_fixed_FixedBytes_Usize_32_for_ruint_Uint_Usize_256_Usize_4.
    
    Module Impl_core_convert_From_alloy_primitives_signed_int_Signed_Usize_256_Usize_4_for_alloy_primitives_bits_fixed_FixedBytes_Usize_32.
      Definition Self : Ty.t :=
        Ty.apply
          (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
          [ Value.Integer IntegerKind.Usize 32 ]
          [].
      
      (*
                  fn from(value: $int) -> Self {
                      Self(value.to_be_bytes())
                  }
      *)
      Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            Value.StructTuple
              "alloy_primitives::bits::fixed::FixedBytes"
              [
                M.call_closure (|
                  Ty.apply
                    (Ty.path "array")
                    [ Value.Integer IntegerKind.Usize 32 ]
                    [ Ty.path "u8" ],
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "alloy_primitives::signed::int::Signed")
                      [ Value.Integer IntegerKind.Usize 256; Value.Integer IntegerKind.Usize 4 ]
                      [],
                    "to_be_bytes",
                    [ Value.Integer IntegerKind.Usize 32 ],
                    []
                  |),
                  [ M.borrow (| Pointer.Kind.Ref, value |) ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [
            Ty.apply
              (Ty.path "alloy_primitives::signed::int::Signed")
              [ Value.Integer IntegerKind.Usize 256; Value.Integer IntegerKind.Usize 4 ]
              []
          ]
          Self
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_alloy_primitives_signed_int_Signed_Usize_256_Usize_4_for_alloy_primitives_bits_fixed_FixedBytes_Usize_32.
    
    Module Impl_core_convert_From_alloy_primitives_bits_fixed_FixedBytes_Usize_32_for_alloy_primitives_signed_int_Signed_Usize_256_Usize_4.
      Definition Self : Ty.t :=
        Ty.apply
          (Ty.path "alloy_primitives::signed::int::Signed")
          [ Value.Integer IntegerKind.Usize 256; Value.Integer IntegerKind.Usize 4 ]
          [].
      
      (*
                  fn from(value: $fb) -> Self {
                      Self::from_be_bytes(value.0)
                  }
      *)
      Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "alloy_primitives::signed::int::Signed")
                [ Value.Integer IntegerKind.Usize 256; Value.Integer IntegerKind.Usize 4 ]
                [],
              M.get_associated_function (|
                Ty.apply
                  (Ty.path "alloy_primitives::signed::int::Signed")
                  [ Value.Integer IntegerKind.Usize 256; Value.Integer IntegerKind.Usize 4 ]
                  [],
                "from_be_bytes",
                [ Value.Integer IntegerKind.Usize 32 ],
                []
              |),
              [
                M.read (|
                  M.SubPointer.get_struct_tuple_field (|
                    value,
                    "alloy_primitives::bits::fixed::FixedBytes",
                    0
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [
            Ty.apply
              (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
              [ Value.Integer IntegerKind.Usize 32 ]
              []
          ]
          Self
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_alloy_primitives_bits_fixed_FixedBytes_Usize_32_for_alloy_primitives_signed_int_Signed_Usize_256_Usize_4.
    
    Module Impl_core_convert_From_ruint_Uint_Usize_512_Usize_8_for_alloy_primitives_bits_fixed_FixedBytes_Usize_64.
      Definition Self : Ty.t :=
        Ty.apply
          (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
          [ Value.Integer IntegerKind.Usize 64 ]
          [].
      
      (*
                  fn from(value: $int) -> Self {
                      Self(value.to_be_bytes())
                  }
      *)
      Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            Value.StructTuple
              "alloy_primitives::bits::fixed::FixedBytes"
              [
                M.call_closure (|
                  Ty.apply
                    (Ty.path "array")
                    [ Value.Integer IntegerKind.Usize 64 ]
                    [ Ty.path "u8" ],
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "ruint::Uint")
                      [ Value.Integer IntegerKind.Usize 512; Value.Integer IntegerKind.Usize 8 ]
                      [],
                    "to_be_bytes",
                    [ Value.Integer IntegerKind.Usize 64 ],
                    []
                  |),
                  [ M.borrow (| Pointer.Kind.Ref, value |) ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [
            Ty.apply
              (Ty.path "ruint::Uint")
              [ Value.Integer IntegerKind.Usize 512; Value.Integer IntegerKind.Usize 8 ]
              []
          ]
          Self
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_ruint_Uint_Usize_512_Usize_8_for_alloy_primitives_bits_fixed_FixedBytes_Usize_64.
    
    Module Impl_core_convert_From_alloy_primitives_bits_fixed_FixedBytes_Usize_64_for_ruint_Uint_Usize_512_Usize_8.
      Definition Self : Ty.t :=
        Ty.apply
          (Ty.path "ruint::Uint")
          [ Value.Integer IntegerKind.Usize 512; Value.Integer IntegerKind.Usize 8 ]
          [].
      
      (*
                  fn from(value: $fb) -> Self {
                      Self::from_be_bytes(value.0)
                  }
      *)
      Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "ruint::Uint")
                [ Value.Integer IntegerKind.Usize 512; Value.Integer IntegerKind.Usize 8 ]
                [],
              M.get_associated_function (|
                Ty.apply
                  (Ty.path "ruint::Uint")
                  [ Value.Integer IntegerKind.Usize 512; Value.Integer IntegerKind.Usize 8 ]
                  [],
                "from_be_bytes",
                [ Value.Integer IntegerKind.Usize 64 ],
                []
              |),
              [
                M.read (|
                  M.SubPointer.get_struct_tuple_field (|
                    value,
                    "alloy_primitives::bits::fixed::FixedBytes",
                    0
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [
            Ty.apply
              (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
              [ Value.Integer IntegerKind.Usize 64 ]
              []
          ]
          Self
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_alloy_primitives_bits_fixed_FixedBytes_Usize_64_for_ruint_Uint_Usize_512_Usize_8.
    
    Module Impl_core_convert_From_alloy_primitives_signed_int_Signed_Usize_512_Usize_8_for_alloy_primitives_bits_fixed_FixedBytes_Usize_64.
      Definition Self : Ty.t :=
        Ty.apply
          (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
          [ Value.Integer IntegerKind.Usize 64 ]
          [].
      
      (*
                  fn from(value: $int) -> Self {
                      Self(value.to_be_bytes())
                  }
      *)
      Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            Value.StructTuple
              "alloy_primitives::bits::fixed::FixedBytes"
              [
                M.call_closure (|
                  Ty.apply
                    (Ty.path "array")
                    [ Value.Integer IntegerKind.Usize 64 ]
                    [ Ty.path "u8" ],
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "alloy_primitives::signed::int::Signed")
                      [ Value.Integer IntegerKind.Usize 512; Value.Integer IntegerKind.Usize 8 ]
                      [],
                    "to_be_bytes",
                    [ Value.Integer IntegerKind.Usize 64 ],
                    []
                  |),
                  [ M.borrow (| Pointer.Kind.Ref, value |) ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [
            Ty.apply
              (Ty.path "alloy_primitives::signed::int::Signed")
              [ Value.Integer IntegerKind.Usize 512; Value.Integer IntegerKind.Usize 8 ]
              []
          ]
          Self
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_alloy_primitives_signed_int_Signed_Usize_512_Usize_8_for_alloy_primitives_bits_fixed_FixedBytes_Usize_64.
    
    Module Impl_core_convert_From_alloy_primitives_bits_fixed_FixedBytes_Usize_64_for_alloy_primitives_signed_int_Signed_Usize_512_Usize_8.
      Definition Self : Ty.t :=
        Ty.apply
          (Ty.path "alloy_primitives::signed::int::Signed")
          [ Value.Integer IntegerKind.Usize 512; Value.Integer IntegerKind.Usize 8 ]
          [].
      
      (*
                  fn from(value: $fb) -> Self {
                      Self::from_be_bytes(value.0)
                  }
      *)
      Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "alloy_primitives::signed::int::Signed")
                [ Value.Integer IntegerKind.Usize 512; Value.Integer IntegerKind.Usize 8 ]
                [],
              M.get_associated_function (|
                Ty.apply
                  (Ty.path "alloy_primitives::signed::int::Signed")
                  [ Value.Integer IntegerKind.Usize 512; Value.Integer IntegerKind.Usize 8 ]
                  [],
                "from_be_bytes",
                [ Value.Integer IntegerKind.Usize 64 ],
                []
              |),
              [
                M.read (|
                  M.SubPointer.get_struct_tuple_field (|
                    value,
                    "alloy_primitives::bits::fixed::FixedBytes",
                    0
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [
            Ty.apply
              (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
              [ Value.Integer IntegerKind.Usize 64 ]
              []
          ]
          Self
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_alloy_primitives_bits_fixed_FixedBytes_Usize_64_for_alloy_primitives_signed_int_Signed_Usize_512_Usize_8.
    
    Module Impl_core_convert_From_alloy_primitives_bits_fixed_FixedBytes_N_for_array_N_u8.
      Definition Self (N : Value.t) : Ty.t := Ty.apply (Ty.path "array") [ N ] [ Ty.path "u8" ].
      
      (*
          fn from(s: FixedBytes<N>) -> Self {
              s.0
          }
      *)
      Definition from (N : Value.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self N in
        match ε, τ, α with
        | [], [], [ s ] =>
          ltac:(M.monadic
            (let s := M.alloc (| s |) in
            M.read (|
              M.SubPointer.get_struct_tuple_field (|
                s,
                "alloy_primitives::bits::fixed::FixedBytes",
                0
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (N : Value.t),
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "alloy_primitives::bits::fixed::FixedBytes") [ N ] [] ]
          (Self N)
          (* Instance *) [ ("from", InstanceField.Method (from N)) ].
    End Impl_core_convert_From_alloy_primitives_bits_fixed_FixedBytes_N_for_array_N_u8.
    
    Module Impl_core_convert_AsRef_array_N_u8_for_alloy_primitives_bits_fixed_FixedBytes_N.
      Definition Self (N : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::bits::fixed::FixedBytes") [ N ] [].
      
      (*
          fn as_ref(&self) -> &[u8; N] {
              &self.0
          }
      *)
      Definition as_ref (N : Value.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self N in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.borrow (|
              Pointer.Kind.Ref,
              M.deref (|
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.SubPointer.get_struct_tuple_field (|
                    M.deref (| M.read (| self |) |),
                    "alloy_primitives::bits::fixed::FixedBytes",
                    0
                  |)
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (N : Value.t),
        M.IsTraitInstance
          "core::convert::AsRef"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.apply (Ty.path "array") [ N ] [ Ty.path "u8" ] ]
          (Self N)
          (* Instance *) [ ("as_ref", InstanceField.Method (as_ref N)) ].
    End Impl_core_convert_AsRef_array_N_u8_for_alloy_primitives_bits_fixed_FixedBytes_N.
    
    Module Impl_core_convert_AsMut_array_N_u8_for_alloy_primitives_bits_fixed_FixedBytes_N.
      Definition Self (N : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::bits::fixed::FixedBytes") [ N ] [].
      
      (*
          fn as_mut(&mut self) -> &mut [u8; N] {
              &mut self.0
          }
      *)
      Definition as_mut (N : Value.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self N in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.borrow (|
              Pointer.Kind.MutRef,
              M.deref (|
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.MutRef,
                      M.SubPointer.get_struct_tuple_field (|
                        M.deref (| M.read (| self |) |),
                        "alloy_primitives::bits::fixed::FixedBytes",
                        0
                      |)
                    |)
                  |)
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (N : Value.t),
        M.IsTraitInstance
          "core::convert::AsMut"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.apply (Ty.path "array") [ N ] [ Ty.path "u8" ] ]
          (Self N)
          (* Instance *) [ ("as_mut", InstanceField.Method (as_mut N)) ].
    End Impl_core_convert_AsMut_array_N_u8_for_alloy_primitives_bits_fixed_FixedBytes_N.
    
    Module Impl_core_convert_AsRef_slice_u8_for_alloy_primitives_bits_fixed_FixedBytes_N.
      Definition Self (N : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::bits::fixed::FixedBytes") [ N ] [].
      
      (*
          fn as_ref(&self) -> &[u8] {
              &self.0
          }
      *)
      Definition as_ref (N : Value.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self N in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            (* Unsize *)
            M.pointer_coercion
              (M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.SubPointer.get_struct_tuple_field (|
                      M.deref (| M.read (| self |) |),
                      "alloy_primitives::bits::fixed::FixedBytes",
                      0
                    |)
                  |)
                |)
              |))))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (N : Value.t),
        M.IsTraitInstance
          "core::convert::AsRef"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
          (Self N)
          (* Instance *) [ ("as_ref", InstanceField.Method (as_ref N)) ].
    End Impl_core_convert_AsRef_slice_u8_for_alloy_primitives_bits_fixed_FixedBytes_N.
    
    Module Impl_core_convert_AsMut_slice_u8_for_alloy_primitives_bits_fixed_FixedBytes_N.
      Definition Self (N : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::bits::fixed::FixedBytes") [ N ] [].
      
      (*
          fn as_mut(&mut self) -> &mut [u8] {
              &mut self.0
          }
      *)
      Definition as_mut (N : Value.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self N in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.borrow (|
              Pointer.Kind.MutRef,
              M.deref (|
                (* Unsize *)
                M.pointer_coercion
                  (M.borrow (|
                    Pointer.Kind.MutRef,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.MutRef,
                        M.SubPointer.get_struct_tuple_field (|
                          M.deref (| M.read (| self |) |),
                          "alloy_primitives::bits::fixed::FixedBytes",
                          0
                        |)
                      |)
                    |)
                  |))
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (N : Value.t),
        M.IsTraitInstance
          "core::convert::AsMut"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
          (Self N)
          (* Instance *) [ ("as_mut", InstanceField.Method (as_mut N)) ].
    End Impl_core_convert_AsMut_slice_u8_for_alloy_primitives_bits_fixed_FixedBytes_N.
    
    Module Impl_core_fmt_Debug_for_alloy_primitives_bits_fixed_FixedBytes_N.
      Definition Self (N : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::bits::fixed::FixedBytes") [ N ] [].
      
      (*
          fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
              self.fmt_hex::<false>(f, true)
          }
      *)
      Definition fmt (N : Value.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self N in
        match ε, τ, α with
        | [], [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "core::result::Result")
                []
                [ Ty.tuple []; Ty.path "core::fmt::Error" ],
              M.get_associated_function (|
                Ty.apply (Ty.path "alloy_primitives::bits::fixed::FixedBytes") [ N ] [],
                "fmt_hex",
                [ Value.Bool false ],
                []
              |),
              [
                M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |);
                M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                Value.Bool true
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (N : Value.t),
        M.IsTraitInstance
          "core::fmt::Debug"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self N)
          (* Instance *) [ ("fmt", InstanceField.Method (fmt N)) ].
    End Impl_core_fmt_Debug_for_alloy_primitives_bits_fixed_FixedBytes_N.
    
    Module Impl_core_fmt_Display_for_alloy_primitives_bits_fixed_FixedBytes_N.
      Definition Self (N : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::bits::fixed::FixedBytes") [ N ] [].
      
      (*
          fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
              // If the alternate flag is NOT set, we write the full hex.
              if N <= 4 || !f.alternate() {
                  return self.fmt_hex::<false>(f, true);
              }
      
              // If the alternate flag is set, we use middle-out compression.
              const SEP_LEN: usize = '…'.len_utf8();
              let mut buf = [0; 2 + 4 + SEP_LEN + 4];
              buf[0] = b'0';
              buf[1] = b'x';
              hex::encode_to_slice(&self.0[0..2], &mut buf[2..6]).unwrap();
              '…'.encode_utf8(&mut buf[6..]);
              hex::encode_to_slice(&self.0[N - 2..N], &mut buf[6 + SEP_LEN..]).unwrap();
      
              // SAFETY: always valid UTF-8
              f.write_str(unsafe { str::from_utf8_unchecked(&buf) })
          }
      *)
      Definition fmt (N : Value.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self N in
        match ε, τ, α with
        | [], [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.catch_return
              (Ty.apply
                (Ty.path "core::result::Result")
                []
                [ Ty.tuple []; Ty.path "core::fmt::Error" ]) (|
              ltac:(M.monadic
                (M.read (|
                  let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                    M.match_operator (|
                      Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  LogicalOp.or (|
                                    M.call_closure (|
                                      Ty.path "bool",
                                      BinOp.le,
                                      [ N; Value.Integer IntegerKind.Usize 4 ]
                                    |),
                                    ltac:(M.monadic
                                      (UnOp.not (|
                                        M.call_closure (|
                                          Ty.path "bool",
                                          M.get_associated_function (|
                                            Ty.path "core::fmt::Formatter",
                                            "alternate",
                                            [],
                                            []
                                          |),
                                          [
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.deref (| M.read (| f |) |)
                                            |)
                                          ]
                                        |)
                                      |)))
                                  |)
                                |)) in
                            let _ :=
                              is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (|
                              M.never_to_any (|
                                M.read (|
                                  M.return_ (|
                                    M.call_closure (|
                                      Ty.apply
                                        (Ty.path "core::result::Result")
                                        []
                                        [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                                      M.get_associated_function (|
                                        Ty.apply
                                          (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                                          [ N ]
                                          [],
                                        "fmt_hex",
                                        [ Value.Bool false ],
                                        []
                                      |),
                                      [
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.deref (| M.read (| self |) |)
                                        |);
                                        M.borrow (|
                                          Pointer.Kind.MutRef,
                                          M.deref (| M.read (| f |) |)
                                        |);
                                        Value.Bool true
                                      ]
                                    |)
                                  |)
                                |)
                              |)
                            |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                      ]
                    |) in
                  let~ buf :
                      Ty.apply
                        (Ty.path "*")
                        []
                        [
                          Ty.apply
                            (Ty.path "array")
                            [ Value.Integer IntegerKind.Usize 13 ]
                            [ Ty.path "u8" ]
                        ] :=
                    M.alloc (|
                      repeat (|
                        Value.Integer IntegerKind.U8 0,
                        Value.Integer IntegerKind.Usize 13
                      |)
                    |) in
                  let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                    M.alloc (|
                      M.write (|
                        M.SubPointer.get_array_field (| buf, Value.Integer IntegerKind.Usize 0 |),
                        M.read (| UnsupportedLiteral |)
                      |)
                    |) in
                  let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                    M.alloc (|
                      M.write (|
                        M.SubPointer.get_array_field (| buf, Value.Integer IntegerKind.Usize 1 |),
                        M.read (| UnsupportedLiteral |)
                      |)
                    |) in
                  let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                    M.alloc (|
                      M.call_closure (|
                        Ty.tuple [],
                        M.get_associated_function (|
                          Ty.apply
                            (Ty.path "core::result::Result")
                            []
                            [ Ty.tuple []; Ty.path "const_hex::error::FromHexError" ],
                          "unwrap",
                          [],
                          []
                        |),
                        [
                          M.call_closure (|
                            Ty.apply
                              (Ty.path "core::result::Result")
                              []
                              [ Ty.tuple []; Ty.path "const_hex::error::FromHexError" ],
                            M.get_function (|
                              "const_hex::encode_to_slice",
                              [],
                              [
                                Ty.apply
                                  (Ty.path "&")
                                  []
                                  [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
                              ]
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "&")
                                      []
                                      [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                                    M.get_trait_method (|
                                      "core::ops::index::Index",
                                      Ty.apply (Ty.path "array") [ N ] [ Ty.path "u8" ],
                                      [],
                                      [
                                        Ty.apply
                                          (Ty.path "core::ops::range::Range")
                                          []
                                          [ Ty.path "usize" ]
                                      ],
                                      "index",
                                      [],
                                      []
                                    |),
                                    [
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.SubPointer.get_struct_tuple_field (|
                                          M.deref (| M.read (| self |) |),
                                          "alloy_primitives::bits::fixed::FixedBytes",
                                          0
                                        |)
                                      |);
                                      Value.StructRecord
                                        "core::ops::range::Range"
                                        [
                                          ("start", Value.Integer IntegerKind.Usize 0);
                                          ("end_", Value.Integer IntegerKind.Usize 2)
                                        ]
                                    ]
                                  |)
                                |)
                              |);
                              M.borrow (|
                                Pointer.Kind.MutRef,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.MutRef,
                                    M.deref (|
                                      M.call_closure (|
                                        Ty.apply
                                          (Ty.path "&mut")
                                          []
                                          [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                                        M.get_trait_method (|
                                          "core::ops::index::IndexMut",
                                          Ty.apply
                                            (Ty.path "array")
                                            [ Value.Integer IntegerKind.Usize 13 ]
                                            [ Ty.path "u8" ],
                                          [],
                                          [
                                            Ty.apply
                                              (Ty.path "core::ops::range::Range")
                                              []
                                              [ Ty.path "usize" ]
                                          ],
                                          "index_mut",
                                          [],
                                          []
                                        |),
                                        [
                                          M.borrow (| Pointer.Kind.MutRef, buf |);
                                          Value.StructRecord
                                            "core::ops::range::Range"
                                            [
                                              ("start", Value.Integer IntegerKind.Usize 2);
                                              ("end_", Value.Integer IntegerKind.Usize 6)
                                            ]
                                        ]
                                      |)
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |) in
                  let~ _ :
                      Ty.apply
                        (Ty.path "*")
                        []
                        [ Ty.apply (Ty.path "&mut") [] [ Ty.path "str" ] ] :=
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply (Ty.path "&mut") [] [ Ty.path "str" ],
                        M.get_associated_function (| Ty.path "char", "encode_utf8", [], [] |),
                        [
                          Value.UnicodeChar 8230;
                          M.borrow (|
                            Pointer.Kind.MutRef,
                            M.deref (|
                              M.borrow (|
                                Pointer.Kind.MutRef,
                                M.deref (|
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "&mut")
                                      []
                                      [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                                    M.get_trait_method (|
                                      "core::ops::index::IndexMut",
                                      Ty.apply
                                        (Ty.path "array")
                                        [ Value.Integer IntegerKind.Usize 13 ]
                                        [ Ty.path "u8" ],
                                      [],
                                      [
                                        Ty.apply
                                          (Ty.path "core::ops::range::RangeFrom")
                                          []
                                          [ Ty.path "usize" ]
                                      ],
                                      "index_mut",
                                      [],
                                      []
                                    |),
                                    [
                                      M.borrow (| Pointer.Kind.MutRef, buf |);
                                      Value.StructRecord
                                        "core::ops::range::RangeFrom"
                                        [ ("start", Value.Integer IntegerKind.Usize 6) ]
                                    ]
                                  |)
                                |)
                              |)
                            |)
                          |)
                        ]
                      |)
                    |) in
                  let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                    M.alloc (|
                      M.call_closure (|
                        Ty.tuple [],
                        M.get_associated_function (|
                          Ty.apply
                            (Ty.path "core::result::Result")
                            []
                            [ Ty.tuple []; Ty.path "const_hex::error::FromHexError" ],
                          "unwrap",
                          [],
                          []
                        |),
                        [
                          M.call_closure (|
                            Ty.apply
                              (Ty.path "core::result::Result")
                              []
                              [ Ty.tuple []; Ty.path "const_hex::error::FromHexError" ],
                            M.get_function (|
                              "const_hex::encode_to_slice",
                              [],
                              [
                                Ty.apply
                                  (Ty.path "&")
                                  []
                                  [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
                              ]
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "&")
                                      []
                                      [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                                    M.get_trait_method (|
                                      "core::ops::index::Index",
                                      Ty.apply (Ty.path "array") [ N ] [ Ty.path "u8" ],
                                      [],
                                      [
                                        Ty.apply
                                          (Ty.path "core::ops::range::Range")
                                          []
                                          [ Ty.path "usize" ]
                                      ],
                                      "index",
                                      [],
                                      []
                                    |),
                                    [
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.SubPointer.get_struct_tuple_field (|
                                          M.deref (| M.read (| self |) |),
                                          "alloy_primitives::bits::fixed::FixedBytes",
                                          0
                                        |)
                                      |);
                                      Value.StructRecord
                                        "core::ops::range::Range"
                                        [
                                          ("start",
                                            M.call_closure (|
                                              Ty.path "usize",
                                              BinOp.Wrap.sub,
                                              [ N; Value.Integer IntegerKind.Usize 2 ]
                                            |));
                                          ("end_", N)
                                        ]
                                    ]
                                  |)
                                |)
                              |);
                              M.borrow (|
                                Pointer.Kind.MutRef,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.MutRef,
                                    M.deref (|
                                      M.call_closure (|
                                        Ty.apply
                                          (Ty.path "&mut")
                                          []
                                          [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                                        M.get_trait_method (|
                                          "core::ops::index::IndexMut",
                                          Ty.apply
                                            (Ty.path "array")
                                            [ Value.Integer IntegerKind.Usize 13 ]
                                            [ Ty.path "u8" ],
                                          [],
                                          [
                                            Ty.apply
                                              (Ty.path "core::ops::range::RangeFrom")
                                              []
                                              [ Ty.path "usize" ]
                                          ],
                                          "index_mut",
                                          [],
                                          []
                                        |),
                                        [
                                          M.borrow (| Pointer.Kind.MutRef, buf |);
                                          Value.StructRecord
                                            "core::ops::range::RangeFrom"
                                            [
                                              ("start",
                                                M.call_closure (|
                                                  Ty.path "usize",
                                                  BinOp.Wrap.add,
                                                  [
                                                    Value.Integer IntegerKind.Usize 6;
                                                    M.read (|
                                                      get_constant (|
                                                        "alloy_primitives::bits::fixed::fmt::SEP_LEN",
                                                        Ty.path "usize"
                                                      |)
                                                    |)
                                                  ]
                                                |))
                                            ]
                                        ]
                                      |)
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |) in
                  M.alloc (|
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "core::result::Result")
                        []
                        [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                      M.get_associated_function (|
                        Ty.path "core::fmt::Formatter",
                        "write_str",
                        [],
                        []
                      |),
                      [
                        M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.deref (|
                            M.call_closure (|
                              Ty.apply (Ty.path "&") [] [ Ty.path "str" ],
                              M.get_function (|
                                "core::str::converts::from_utf8_unchecked",
                                [],
                                []
                              |),
                              [
                                (* Unsize *)
                                M.pointer_coercion
                                  (M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (| M.borrow (| Pointer.Kind.Ref, buf |) |)
                                  |))
                              ]
                            |)
                          |)
                        |)
                      ]
                    |)
                  |)
                |)))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (N : Value.t),
        M.IsTraitInstance
          "core::fmt::Display"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self N)
          (* Instance *) [ ("fmt", InstanceField.Method (fmt N)) ].
    End Impl_core_fmt_Display_for_alloy_primitives_bits_fixed_FixedBytes_N.
    
    Module Impl_core_fmt_LowerHex_for_alloy_primitives_bits_fixed_FixedBytes_N.
      Definition Self (N : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::bits::fixed::FixedBytes") [ N ] [].
      
      (*
          fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
              self.fmt_hex::<false>(f, f.alternate())
          }
      *)
      Definition fmt (N : Value.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self N in
        match ε, τ, α with
        | [], [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "core::result::Result")
                []
                [ Ty.tuple []; Ty.path "core::fmt::Error" ],
              M.get_associated_function (|
                Ty.apply (Ty.path "alloy_primitives::bits::fixed::FixedBytes") [ N ] [],
                "fmt_hex",
                [ Value.Bool false ],
                []
              |),
              [
                M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |);
                M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                M.call_closure (|
                  Ty.path "bool",
                  M.get_associated_function (|
                    Ty.path "core::fmt::Formatter",
                    "alternate",
                    [],
                    []
                  |),
                  [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| f |) |) |) ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (N : Value.t),
        M.IsTraitInstance
          "core::fmt::LowerHex"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self N)
          (* Instance *) [ ("fmt", InstanceField.Method (fmt N)) ].
    End Impl_core_fmt_LowerHex_for_alloy_primitives_bits_fixed_FixedBytes_N.
    
    Module Impl_core_fmt_UpperHex_for_alloy_primitives_bits_fixed_FixedBytes_N.
      Definition Self (N : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::bits::fixed::FixedBytes") [ N ] [].
      
      (*
          fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
              self.fmt_hex::<true>(f, f.alternate())
          }
      *)
      Definition fmt (N : Value.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self N in
        match ε, τ, α with
        | [], [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "core::result::Result")
                []
                [ Ty.tuple []; Ty.path "core::fmt::Error" ],
              M.get_associated_function (|
                Ty.apply (Ty.path "alloy_primitives::bits::fixed::FixedBytes") [ N ] [],
                "fmt_hex",
                [ Value.Bool true ],
                []
              |),
              [
                M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |);
                M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                M.call_closure (|
                  Ty.path "bool",
                  M.get_associated_function (|
                    Ty.path "core::fmt::Formatter",
                    "alternate",
                    [],
                    []
                  |),
                  [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| f |) |) |) ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (N : Value.t),
        M.IsTraitInstance
          "core::fmt::UpperHex"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self N)
          (* Instance *) [ ("fmt", InstanceField.Method (fmt N)) ].
    End Impl_core_fmt_UpperHex_for_alloy_primitives_bits_fixed_FixedBytes_N.
    
    Module Impl_core_ops_bit_BitAnd_alloy_primitives_bits_fixed_FixedBytes_N_for_alloy_primitives_bits_fixed_FixedBytes_N.
      Definition Self (N : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::bits::fixed::FixedBytes") [ N ] [].
      
      (*     type Output = Self; *)
      Definition _Output (N : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::bits::fixed::FixedBytes") [ N ] [].
      
      (*
          fn bitand(mut self, rhs: Self) -> Self::Output {
              self &= rhs;
              self
          }
      *)
      Definition bitand (N : Value.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self N in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.call_closure (|
                    Ty.tuple [],
                    M.get_trait_method (|
                      "core::ops::bit::BitAndAssign",
                      Ty.apply (Ty.path "alloy_primitives::bits::fixed::FixedBytes") [ N ] [],
                      [],
                      [ Ty.apply (Ty.path "alloy_primitives::bits::fixed::FixedBytes") [ N ] [] ],
                      "bitand_assign",
                      [],
                      []
                    |),
                    [ M.borrow (| Pointer.Kind.MutRef, self |); M.read (| rhs |) ]
                  |)
                |) in
              self
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (N : Value.t),
        M.IsTraitInstance
          "core::ops::bit::BitAnd"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "alloy_primitives::bits::fixed::FixedBytes") [ N ] [] ]
          (Self N)
          (* Instance *)
          [ ("Output", InstanceField.Ty (_Output N)); ("bitand", InstanceField.Method (bitand N)) ].
    End Impl_core_ops_bit_BitAnd_alloy_primitives_bits_fixed_FixedBytes_N_for_alloy_primitives_bits_fixed_FixedBytes_N.
    
    Module Impl_core_ops_bit_BitAndAssign_alloy_primitives_bits_fixed_FixedBytes_N_for_alloy_primitives_bits_fixed_FixedBytes_N.
      Definition Self (N : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::bits::fixed::FixedBytes") [ N ] [].
      
      (*
          fn bitand_assign(&mut self, rhs: Self) {
              // Note: `slice::Iter` has better codegen than `array::IntoIter`
              iter::zip(self, &rhs).for_each(|(a, b)| *a &= *b);
          }
      *)
      Definition bitand_assign
          (N : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self N in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.call_closure (|
                    Ty.tuple [],
                    M.get_trait_method (|
                      "core::iter::traits::iterator::Iterator",
                      Ty.apply
                        (Ty.path "core::iter::adapters::zip::Zip")
                        []
                        [
                          Ty.apply (Ty.path "core::slice::iter::IterMut") [] [ Ty.path "u8" ];
                          Ty.apply (Ty.path "core::slice::iter::Iter") [] [ Ty.path "u8" ]
                        ],
                      [],
                      [],
                      "for_each",
                      [],
                      [
                        Ty.function
                          [
                            Ty.tuple
                              [
                                Ty.tuple
                                  [
                                    Ty.apply (Ty.path "&mut") [] [ Ty.path "u8" ];
                                    Ty.apply (Ty.path "&") [] [ Ty.path "u8" ]
                                  ]
                              ]
                          ]
                          (Ty.tuple [])
                      ]
                    |),
                    [
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::iter::adapters::zip::Zip")
                          []
                          [
                            Ty.apply (Ty.path "core::slice::iter::IterMut") [] [ Ty.path "u8" ];
                            Ty.apply (Ty.path "core::slice::iter::Iter") [] [ Ty.path "u8" ]
                          ],
                        M.get_function (|
                          "core::iter::adapters::zip::zip",
                          [],
                          [
                            Ty.apply
                              (Ty.path "&mut")
                              []
                              [
                                Ty.apply
                                  (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                                  [ N ]
                                  []
                              ];
                            Ty.apply
                              (Ty.path "&")
                              []
                              [
                                Ty.apply
                                  (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                                  [ N ]
                                  []
                              ]
                          ]
                        |),
                        [ M.read (| self |); M.borrow (| Pointer.Kind.Ref, rhs |) ]
                      |);
                      M.closure
                        (fun γ =>
                          ltac:(M.monadic
                            match γ with
                            | [ α0 ] =>
                              ltac:(M.monadic
                                (M.match_operator (|
                                  Ty.apply
                                    (Ty.path "*")
                                    []
                                    [
                                      Ty.function
                                        [
                                          Ty.tuple
                                            [
                                              Ty.tuple
                                                [
                                                  Ty.apply (Ty.path "&mut") [] [ Ty.path "u8" ];
                                                  Ty.apply (Ty.path "&") [] [ Ty.path "u8" ]
                                                ]
                                            ]
                                        ]
                                        (Ty.tuple [])
                                    ],
                                  M.alloc (| α0 |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                                        let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                        let a := M.copy (| γ0_0 |) in
                                        let b := M.copy (| γ0_1 |) in
                                        let β := M.deref (| M.read (| a |) |) in
                                        M.write (|
                                          β,
                                          M.call_closure (|
                                            Ty.path "u8",
                                            BinOp.Wrap.bit_and,
                                            [
                                              M.read (| β |);
                                              M.read (| M.deref (| M.read (| b |) |) |)
                                            ]
                                          |)
                                        |)))
                                  ]
                                |)))
                            | _ => M.impossible "wrong number of arguments"
                            end))
                    ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (N : Value.t),
        M.IsTraitInstance
          "core::ops::bit::BitAndAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "alloy_primitives::bits::fixed::FixedBytes") [ N ] [] ]
          (Self N)
          (* Instance *) [ ("bitand_assign", InstanceField.Method (bitand_assign N)) ].
    End Impl_core_ops_bit_BitAndAssign_alloy_primitives_bits_fixed_FixedBytes_N_for_alloy_primitives_bits_fixed_FixedBytes_N.
    
    Module Impl_core_ops_bit_BitOr_alloy_primitives_bits_fixed_FixedBytes_N_for_alloy_primitives_bits_fixed_FixedBytes_N.
      Definition Self (N : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::bits::fixed::FixedBytes") [ N ] [].
      
      (*     type Output = Self; *)
      Definition _Output (N : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::bits::fixed::FixedBytes") [ N ] [].
      
      (*
          fn bitor(mut self, rhs: Self) -> Self::Output {
              self |= rhs;
              self
          }
      *)
      Definition bitor (N : Value.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self N in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.call_closure (|
                    Ty.tuple [],
                    M.get_trait_method (|
                      "core::ops::bit::BitOrAssign",
                      Ty.apply (Ty.path "alloy_primitives::bits::fixed::FixedBytes") [ N ] [],
                      [],
                      [ Ty.apply (Ty.path "alloy_primitives::bits::fixed::FixedBytes") [ N ] [] ],
                      "bitor_assign",
                      [],
                      []
                    |),
                    [ M.borrow (| Pointer.Kind.MutRef, self |); M.read (| rhs |) ]
                  |)
                |) in
              self
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (N : Value.t),
        M.IsTraitInstance
          "core::ops::bit::BitOr"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "alloy_primitives::bits::fixed::FixedBytes") [ N ] [] ]
          (Self N)
          (* Instance *)
          [ ("Output", InstanceField.Ty (_Output N)); ("bitor", InstanceField.Method (bitor N)) ].
    End Impl_core_ops_bit_BitOr_alloy_primitives_bits_fixed_FixedBytes_N_for_alloy_primitives_bits_fixed_FixedBytes_N.
    
    Module Impl_core_ops_bit_BitOrAssign_alloy_primitives_bits_fixed_FixedBytes_N_for_alloy_primitives_bits_fixed_FixedBytes_N.
      Definition Self (N : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::bits::fixed::FixedBytes") [ N ] [].
      
      (*
          fn bitor_assign(&mut self, rhs: Self) {
              // Note: `slice::Iter` has better codegen than `array::IntoIter`
              iter::zip(self, &rhs).for_each(|(a, b)| *a |= *b);
          }
      *)
      Definition bitor_assign
          (N : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self N in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.call_closure (|
                    Ty.tuple [],
                    M.get_trait_method (|
                      "core::iter::traits::iterator::Iterator",
                      Ty.apply
                        (Ty.path "core::iter::adapters::zip::Zip")
                        []
                        [
                          Ty.apply (Ty.path "core::slice::iter::IterMut") [] [ Ty.path "u8" ];
                          Ty.apply (Ty.path "core::slice::iter::Iter") [] [ Ty.path "u8" ]
                        ],
                      [],
                      [],
                      "for_each",
                      [],
                      [
                        Ty.function
                          [
                            Ty.tuple
                              [
                                Ty.tuple
                                  [
                                    Ty.apply (Ty.path "&mut") [] [ Ty.path "u8" ];
                                    Ty.apply (Ty.path "&") [] [ Ty.path "u8" ]
                                  ]
                              ]
                          ]
                          (Ty.tuple [])
                      ]
                    |),
                    [
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::iter::adapters::zip::Zip")
                          []
                          [
                            Ty.apply (Ty.path "core::slice::iter::IterMut") [] [ Ty.path "u8" ];
                            Ty.apply (Ty.path "core::slice::iter::Iter") [] [ Ty.path "u8" ]
                          ],
                        M.get_function (|
                          "core::iter::adapters::zip::zip",
                          [],
                          [
                            Ty.apply
                              (Ty.path "&mut")
                              []
                              [
                                Ty.apply
                                  (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                                  [ N ]
                                  []
                              ];
                            Ty.apply
                              (Ty.path "&")
                              []
                              [
                                Ty.apply
                                  (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                                  [ N ]
                                  []
                              ]
                          ]
                        |),
                        [ M.read (| self |); M.borrow (| Pointer.Kind.Ref, rhs |) ]
                      |);
                      M.closure
                        (fun γ =>
                          ltac:(M.monadic
                            match γ with
                            | [ α0 ] =>
                              ltac:(M.monadic
                                (M.match_operator (|
                                  Ty.apply
                                    (Ty.path "*")
                                    []
                                    [
                                      Ty.function
                                        [
                                          Ty.tuple
                                            [
                                              Ty.tuple
                                                [
                                                  Ty.apply (Ty.path "&mut") [] [ Ty.path "u8" ];
                                                  Ty.apply (Ty.path "&") [] [ Ty.path "u8" ]
                                                ]
                                            ]
                                        ]
                                        (Ty.tuple [])
                                    ],
                                  M.alloc (| α0 |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                                        let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                        let a := M.copy (| γ0_0 |) in
                                        let b := M.copy (| γ0_1 |) in
                                        let β := M.deref (| M.read (| a |) |) in
                                        M.write (|
                                          β,
                                          M.call_closure (|
                                            Ty.path "u8",
                                            BinOp.Wrap.bit_or,
                                            [
                                              M.read (| β |);
                                              M.read (| M.deref (| M.read (| b |) |) |)
                                            ]
                                          |)
                                        |)))
                                  ]
                                |)))
                            | _ => M.impossible "wrong number of arguments"
                            end))
                    ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (N : Value.t),
        M.IsTraitInstance
          "core::ops::bit::BitOrAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "alloy_primitives::bits::fixed::FixedBytes") [ N ] [] ]
          (Self N)
          (* Instance *) [ ("bitor_assign", InstanceField.Method (bitor_assign N)) ].
    End Impl_core_ops_bit_BitOrAssign_alloy_primitives_bits_fixed_FixedBytes_N_for_alloy_primitives_bits_fixed_FixedBytes_N.
    
    Module Impl_core_ops_bit_BitXor_alloy_primitives_bits_fixed_FixedBytes_N_for_alloy_primitives_bits_fixed_FixedBytes_N.
      Definition Self (N : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::bits::fixed::FixedBytes") [ N ] [].
      
      (*     type Output = Self; *)
      Definition _Output (N : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::bits::fixed::FixedBytes") [ N ] [].
      
      (*
          fn bitxor(mut self, rhs: Self) -> Self::Output {
              self ^= rhs;
              self
          }
      *)
      Definition bitxor (N : Value.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self N in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.call_closure (|
                    Ty.tuple [],
                    M.get_trait_method (|
                      "core::ops::bit::BitXorAssign",
                      Ty.apply (Ty.path "alloy_primitives::bits::fixed::FixedBytes") [ N ] [],
                      [],
                      [ Ty.apply (Ty.path "alloy_primitives::bits::fixed::FixedBytes") [ N ] [] ],
                      "bitxor_assign",
                      [],
                      []
                    |),
                    [ M.borrow (| Pointer.Kind.MutRef, self |); M.read (| rhs |) ]
                  |)
                |) in
              self
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (N : Value.t),
        M.IsTraitInstance
          "core::ops::bit::BitXor"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "alloy_primitives::bits::fixed::FixedBytes") [ N ] [] ]
          (Self N)
          (* Instance *)
          [ ("Output", InstanceField.Ty (_Output N)); ("bitxor", InstanceField.Method (bitxor N)) ].
    End Impl_core_ops_bit_BitXor_alloy_primitives_bits_fixed_FixedBytes_N_for_alloy_primitives_bits_fixed_FixedBytes_N.
    
    Module Impl_core_ops_bit_BitXorAssign_alloy_primitives_bits_fixed_FixedBytes_N_for_alloy_primitives_bits_fixed_FixedBytes_N.
      Definition Self (N : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::bits::fixed::FixedBytes") [ N ] [].
      
      (*
          fn bitxor_assign(&mut self, rhs: Self) {
              // Note: `slice::Iter` has better codegen than `array::IntoIter`
              iter::zip(self, &rhs).for_each(|(a, b)| *a ^= *b);
          }
      *)
      Definition bitxor_assign
          (N : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self N in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.call_closure (|
                    Ty.tuple [],
                    M.get_trait_method (|
                      "core::iter::traits::iterator::Iterator",
                      Ty.apply
                        (Ty.path "core::iter::adapters::zip::Zip")
                        []
                        [
                          Ty.apply (Ty.path "core::slice::iter::IterMut") [] [ Ty.path "u8" ];
                          Ty.apply (Ty.path "core::slice::iter::Iter") [] [ Ty.path "u8" ]
                        ],
                      [],
                      [],
                      "for_each",
                      [],
                      [
                        Ty.function
                          [
                            Ty.tuple
                              [
                                Ty.tuple
                                  [
                                    Ty.apply (Ty.path "&mut") [] [ Ty.path "u8" ];
                                    Ty.apply (Ty.path "&") [] [ Ty.path "u8" ]
                                  ]
                              ]
                          ]
                          (Ty.tuple [])
                      ]
                    |),
                    [
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::iter::adapters::zip::Zip")
                          []
                          [
                            Ty.apply (Ty.path "core::slice::iter::IterMut") [] [ Ty.path "u8" ];
                            Ty.apply (Ty.path "core::slice::iter::Iter") [] [ Ty.path "u8" ]
                          ],
                        M.get_function (|
                          "core::iter::adapters::zip::zip",
                          [],
                          [
                            Ty.apply
                              (Ty.path "&mut")
                              []
                              [
                                Ty.apply
                                  (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                                  [ N ]
                                  []
                              ];
                            Ty.apply
                              (Ty.path "&")
                              []
                              [
                                Ty.apply
                                  (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                                  [ N ]
                                  []
                              ]
                          ]
                        |),
                        [ M.read (| self |); M.borrow (| Pointer.Kind.Ref, rhs |) ]
                      |);
                      M.closure
                        (fun γ =>
                          ltac:(M.monadic
                            match γ with
                            | [ α0 ] =>
                              ltac:(M.monadic
                                (M.match_operator (|
                                  Ty.apply
                                    (Ty.path "*")
                                    []
                                    [
                                      Ty.function
                                        [
                                          Ty.tuple
                                            [
                                              Ty.tuple
                                                [
                                                  Ty.apply (Ty.path "&mut") [] [ Ty.path "u8" ];
                                                  Ty.apply (Ty.path "&") [] [ Ty.path "u8" ]
                                                ]
                                            ]
                                        ]
                                        (Ty.tuple [])
                                    ],
                                  M.alloc (| α0 |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                                        let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                        let a := M.copy (| γ0_0 |) in
                                        let b := M.copy (| γ0_1 |) in
                                        let β := M.deref (| M.read (| a |) |) in
                                        M.write (|
                                          β,
                                          M.call_closure (|
                                            Ty.path "u8",
                                            BinOp.Wrap.bit_xor,
                                            [
                                              M.read (| β |);
                                              M.read (| M.deref (| M.read (| b |) |) |)
                                            ]
                                          |)
                                        |)))
                                  ]
                                |)))
                            | _ => M.impossible "wrong number of arguments"
                            end))
                    ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (N : Value.t),
        M.IsTraitInstance
          "core::ops::bit::BitXorAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "alloy_primitives::bits::fixed::FixedBytes") [ N ] [] ]
          (Self N)
          (* Instance *) [ ("bitxor_assign", InstanceField.Method (bitxor_assign N)) ].
    End Impl_core_ops_bit_BitXorAssign_alloy_primitives_bits_fixed_FixedBytes_N_for_alloy_primitives_bits_fixed_FixedBytes_N.
    
    Module Impl_core_ops_bit_Not_for_alloy_primitives_bits_fixed_FixedBytes_N.
      Definition Self (N : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::bits::fixed::FixedBytes") [ N ] [].
      
      (*     type Output = Self; *)
      Definition _Output (N : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::bits::fixed::FixedBytes") [ N ] [].
      
      (*
          fn not(mut self) -> Self::Output {
              self.iter_mut().for_each(|byte| *byte = !*byte);
              self
          }
      *)
      Definition not (N : Value.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self N in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.call_closure (|
                    Ty.tuple [],
                    M.get_trait_method (|
                      "core::iter::traits::iterator::Iterator",
                      Ty.apply (Ty.path "core::slice::iter::IterMut") [] [ Ty.path "u8" ],
                      [],
                      [],
                      "for_each",
                      [],
                      [
                        Ty.function
                          [ Ty.tuple [ Ty.apply (Ty.path "&mut") [] [ Ty.path "u8" ] ] ]
                          (Ty.tuple [])
                      ]
                    |),
                    [
                      M.call_closure (|
                        Ty.apply (Ty.path "core::slice::iter::IterMut") [] [ Ty.path "u8" ],
                        M.get_associated_function (|
                          Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                          "iter_mut",
                          [],
                          []
                        |),
                        [
                          (* Unsize *)
                          M.pointer_coercion
                            (M.borrow (|
                              Pointer.Kind.MutRef,
                              M.deref (|
                                M.call_closure (|
                                  Ty.apply
                                    (Ty.path "&mut")
                                    []
                                    [ Ty.apply (Ty.path "array") [ N ] [ Ty.path "u8" ] ],
                                  M.get_trait_method (|
                                    "core::ops::deref::DerefMut",
                                    Ty.apply
                                      (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                                      [ N ]
                                      [],
                                    [],
                                    [],
                                    "deref_mut",
                                    [],
                                    []
                                  |),
                                  [ M.borrow (| Pointer.Kind.MutRef, self |) ]
                                |)
                              |)
                            |))
                        ]
                      |);
                      M.closure
                        (fun γ =>
                          ltac:(M.monadic
                            match γ with
                            | [ α0 ] =>
                              ltac:(M.monadic
                                (M.match_operator (|
                                  Ty.apply
                                    (Ty.path "*")
                                    []
                                    [
                                      Ty.function
                                        [ Ty.tuple [ Ty.apply (Ty.path "&mut") [] [ Ty.path "u8" ] ]
                                        ]
                                        (Ty.tuple [])
                                    ],
                                  M.alloc (| α0 |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let byte := M.copy (| γ |) in
                                        M.write (|
                                          M.deref (| M.read (| byte |) |),
                                          UnOp.not (|
                                            M.read (| M.deref (| M.read (| byte |) |) |)
                                          |)
                                        |)))
                                  ]
                                |)))
                            | _ => M.impossible "wrong number of arguments"
                            end))
                    ]
                  |)
                |) in
              self
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (N : Value.t),
        M.IsTraitInstance
          "core::ops::bit::Not"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self N)
          (* Instance *)
          [ ("Output", InstanceField.Ty (_Output N)); ("not", InstanceField.Method (not N)) ].
    End Impl_core_ops_bit_Not_for_alloy_primitives_bits_fixed_FixedBytes_N.
    
    Module Impl_core_str_traits_FromStr_for_alloy_primitives_bits_fixed_FixedBytes_N.
      Definition Self (N : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::bits::fixed::FixedBytes") [ N ] [].
      
      (*     type Err = hex::FromHexError; *)
      Definition _Err (N : Value.t) : Ty.t := Ty.path "const_hex::error::FromHexError".
      
      (*
          fn from_str(s: &str) -> Result<Self, Self::Err> {
              Self::from_hex(s)
          }
      *)
      Definition from_str (N : Value.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self N in
        match ε, τ, α with
        | [], [], [ s ] =>
          ltac:(M.monadic
            (let s := M.alloc (| s |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "core::result::Result")
                []
                [
                  Ty.apply (Ty.path "alloy_primitives::bits::fixed::FixedBytes") [ N ] [];
                  Ty.path "const_hex::error::FromHexError"
                ],
              M.get_trait_method (|
                "const_hex::traits::FromHex",
                Ty.apply (Ty.path "alloy_primitives::bits::fixed::FixedBytes") [ N ] [],
                [],
                [],
                "from_hex",
                [],
                [ Ty.apply (Ty.path "&") [] [ Ty.path "str" ] ]
              |),
              [ M.read (| s |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (N : Value.t),
        M.IsTraitInstance
          "core::str::traits::FromStr"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self N)
          (* Instance *)
          [ ("Err", InstanceField.Ty (_Err N)); ("from_str", InstanceField.Method (from_str N)) ].
    End Impl_core_str_traits_FromStr_for_alloy_primitives_bits_fixed_FixedBytes_N.
    
    Module Impl_alloy_primitives_bits_fixed_FixedBytes_N.
      Definition Self (N : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::bits::fixed::FixedBytes") [ N ] [].
      
      (*     pub const ZERO: Self = Self([0u8; N]); *)
      (* Ty.apply (Ty.path "alloy_primitives::bits::fixed::FixedBytes") [ N ] [] *)
      Definition value_ZERO
          (N : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self N in
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple
              "alloy_primitives::bits::fixed::FixedBytes"
              [ repeat (| Value.Integer IntegerKind.U8 0, N |) ]
          |))).
      
      Global Instance AssociatedConstant_value_ZERO :
        forall (N : Value.t),
        M.IsAssociatedFunction.C (Self N) "ZERO" (value_ZERO N).
      Admitted.
      Global Typeclasses Opaque value_ZERO.
      
      (*
          pub const fn new(bytes: [u8; N]) -> Self {
              Self(bytes)
          }
      *)
      Definition new (N : Value.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self N in
        match ε, τ, α with
        | [], [], [ bytes ] =>
          ltac:(M.monadic
            (let bytes := M.alloc (| bytes |) in
            Value.StructTuple "alloy_primitives::bits::fixed::FixedBytes" [ M.read (| bytes |) ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_new :
        forall (N : Value.t),
        M.IsAssociatedFunction.C (Self N) "new" (new N).
      Admitted.
      Global Typeclasses Opaque new.
      
      (*
          pub const fn with_last_byte(x: u8) -> Self {
              let mut bytes = [0u8; N];
              if N > 0 {
                  bytes[N - 1] = x;
              }
              Self(bytes)
          }
      *)
      Definition with_last_byte
          (N : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self N in
        match ε, τ, α with
        | [], [], [ x ] =>
          ltac:(M.monadic
            (let x := M.alloc (| x |) in
            M.read (|
              let~ bytes :
                  Ty.apply (Ty.path "*") [] [ Ty.apply (Ty.path "array") [ N ] [ Ty.path "u8" ] ] :=
                M.alloc (| repeat (| Value.Integer IntegerKind.U8 0, N |) |) in
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.match_operator (|
                  Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ :=
                          M.use
                            (M.alloc (|
                              M.call_closure (|
                                Ty.path "bool",
                                BinOp.gt,
                                [ N; Value.Integer IntegerKind.Usize 0 ]
                              |)
                            |)) in
                        let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                          M.alloc (|
                            M.write (|
                              M.SubPointer.get_array_field (|
                                bytes,
                                M.call_closure (|
                                  Ty.path "usize",
                                  BinOp.Wrap.sub,
                                  [ N; Value.Integer IntegerKind.Usize 1 ]
                                |)
                              |),
                              M.read (| x |)
                            |)
                          |) in
                        M.alloc (| Value.Tuple [] |)));
                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                  ]
                |) in
              M.alloc (|
                Value.StructTuple "alloy_primitives::bits::fixed::FixedBytes" [ M.read (| bytes |) ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_with_last_byte :
        forall (N : Value.t),
        M.IsAssociatedFunction.C (Self N) "with_last_byte" (with_last_byte N).
      Admitted.
      Global Typeclasses Opaque with_last_byte.
      
      (*
          pub const fn repeat_byte(byte: u8) -> Self {
              Self([byte; N])
          }
      *)
      Definition repeat_byte
          (N : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self N in
        match ε, τ, α with
        | [], [], [ byte ] =>
          ltac:(M.monadic
            (let byte := M.alloc (| byte |) in
            Value.StructTuple
              "alloy_primitives::bits::fixed::FixedBytes"
              [ repeat (| M.read (| byte |), N |) ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_repeat_byte :
        forall (N : Value.t),
        M.IsAssociatedFunction.C (Self N) "repeat_byte" (repeat_byte N).
      Admitted.
      Global Typeclasses Opaque repeat_byte.
      
      (*
          pub const fn len_bytes() -> usize {
              N
          }
      *)
      Definition len_bytes
          (N : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self N in
        match ε, τ, α with
        | [], [], [] => ltac:(M.monadic N)
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_len_bytes :
        forall (N : Value.t),
        M.IsAssociatedFunction.C (Self N) "len_bytes" (len_bytes N).
      Admitted.
      Global Typeclasses Opaque len_bytes.
      
      (*
          pub const fn concat_const<const M: usize, const Z: usize>(
              self,
              other: FixedBytes<M>,
          ) -> FixedBytes<Z> {
              assert!(N + M == Z, "Output size `Z` must equal the sum of the input sizes `N` and `M`");
      
              let mut result = [0u8; Z];
              let mut i = 0;
              while i < Z {
                  result[i] = if i >= N { other.0[i - N] } else { self.0[i] };
                  i += 1;
              }
              FixedBytes(result)
          }
      *)
      Definition concat_const
          (N : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self N in
        match ε, τ, α with
        | [ M_; Z ], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.match_operator (|
                  Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ :=
                          M.use
                            (M.alloc (|
                              UnOp.not (|
                                M.call_closure (|
                                  Ty.path "bool",
                                  BinOp.eq,
                                  [
                                    M.call_closure (| Ty.path "usize", BinOp.Wrap.add, [ N; M_ ] |);
                                    Z
                                  ]
                                |)
                              |)
                            |)) in
                        let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        M.alloc (|
                          M.never_to_any (|
                            M.call_closure (|
                              Ty.path "never",
                              M.get_function (| "core::panicking::panic_fmt", [], [] |),
                              [
                                M.call_closure (|
                                  Ty.path "core::fmt::Arguments",
                                  M.get_associated_function (|
                                    Ty.path "core::fmt::Arguments",
                                    "new_const",
                                    [ Value.Integer IntegerKind.Usize 1 ],
                                    []
                                  |),
                                  [
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.deref (|
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.alloc (|
                                            Value.Array
                                              [
                                                mk_str (|
                                                  "Output size `Z` must equal the sum of the input sizes `N` and `M`"
                                                |)
                                              ]
                                          |)
                                        |)
                                      |)
                                    |)
                                  ]
                                |)
                              ]
                            |)
                          |)
                        |)));
                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                  ]
                |) in
              let~ result :
                  Ty.apply (Ty.path "*") [] [ Ty.apply (Ty.path "array") [ Z ] [ Ty.path "u8" ] ] :=
                M.alloc (| repeat (| Value.Integer IntegerKind.U8 0, Z |) |) in
              let~ i : Ty.apply (Ty.path "*") [] [ Ty.path "usize" ] :=
                M.alloc (| Value.Integer IntegerKind.Usize 0 |) in
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.loop (|
                  Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                  ltac:(M.monadic
                    (M.match_operator (|
                      Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  M.call_closure (|
                                    Ty.path "bool",
                                    BinOp.lt,
                                    [ M.read (| i |); Z ]
                                  |)
                                |)) in
                            let _ :=
                              is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                              M.alloc (|
                                M.write (|
                                  M.SubPointer.get_array_field (| result, M.read (| i |) |),
                                  M.read (|
                                    M.match_operator (|
                                      Ty.apply (Ty.path "*") [] [ Ty.path "u8" ],
                                      M.alloc (| Value.Tuple [] |),
                                      [
                                        fun γ =>
                                          ltac:(M.monadic
                                            (let γ :=
                                              M.use
                                                (M.alloc (|
                                                  M.call_closure (|
                                                    Ty.path "bool",
                                                    BinOp.ge,
                                                    [ M.read (| i |); N ]
                                                  |)
                                                |)) in
                                            let _ :=
                                              is_constant_or_break_match (|
                                                M.read (| γ |),
                                                Value.Bool true
                                              |) in
                                            M.SubPointer.get_array_field (|
                                              M.SubPointer.get_struct_tuple_field (|
                                                other,
                                                "alloy_primitives::bits::fixed::FixedBytes",
                                                0
                                              |),
                                              M.call_closure (|
                                                Ty.path "usize",
                                                BinOp.Wrap.sub,
                                                [ M.read (| i |); N ]
                                              |)
                                            |)));
                                        fun γ =>
                                          ltac:(M.monadic
                                            (M.SubPointer.get_array_field (|
                                              M.SubPointer.get_struct_tuple_field (|
                                                self,
                                                "alloy_primitives::bits::fixed::FixedBytes",
                                                0
                                              |),
                                              M.read (| i |)
                                            |)))
                                      ]
                                    |)
                                  |)
                                |)
                              |) in
                            let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                              M.alloc (|
                                let β := i in
                                M.write (|
                                  β,
                                  M.call_closure (|
                                    Ty.path "usize",
                                    BinOp.Wrap.add,
                                    [ M.read (| β |); Value.Integer IntegerKind.Usize 1 ]
                                  |)
                                |)
                              |) in
                            M.alloc (| Value.Tuple [] |)));
                        fun γ =>
                          ltac:(M.monadic
                            (M.alloc (|
                              M.never_to_any (|
                                M.read (|
                                  let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                                    M.alloc (| M.never_to_any (| M.read (| M.break (||) |) |) |) in
                                  M.alloc (| Value.Tuple [] |)
                                |)
                              |)
                            |)))
                      ]
                    |)))
                |) in
              M.alloc (|
                Value.StructTuple
                  "alloy_primitives::bits::fixed::FixedBytes"
                  [ M.read (| result |) ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_concat_const :
        forall (N : Value.t),
        M.IsAssociatedFunction.C (Self N) "concat_const" (concat_const N).
      Admitted.
      Global Typeclasses Opaque concat_const.
      
      (*
          pub fn from_slice(src: &[u8]) -> Self {
              match Self::try_from(src) {
                  Ok(x) => x,
                  Err(_) => panic!("cannot convert a slice of length {} to FixedBytes<{N}>", src.len()),
              }
          }
      *)
      Definition from_slice
          (N : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self N in
        match ε, τ, α with
        | [], [], [ src ] =>
          ltac:(M.monadic
            (let src := M.alloc (| src |) in
            M.read (|
              M.match_operator (|
                Ty.apply
                  (Ty.path "*")
                  []
                  [ Ty.apply (Ty.path "alloy_primitives::bits::fixed::FixedBytes") [ N ] [] ],
                M.alloc (|
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "core::result::Result")
                      []
                      [
                        Ty.apply (Ty.path "alloy_primitives::bits::fixed::FixedBytes") [ N ] [];
                        Ty.path "core::array::TryFromSliceError"
                      ],
                    M.get_trait_method (|
                      "core::convert::TryFrom",
                      Ty.apply (Ty.path "alloy_primitives::bits::fixed::FixedBytes") [ N ] [],
                      [],
                      [ Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
                      ],
                      "try_from",
                      [],
                      []
                    |),
                    [ M.read (| src |) ]
                  |)
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::result::Result::Ok",
                          0
                        |) in
                      let x := M.copy (| γ0_0 |) in
                      x));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::result::Result::Err",
                          0
                        |) in
                      M.alloc (|
                        M.never_to_any (|
                          M.call_closure (|
                            Ty.path "never",
                            M.get_function (| "core::panicking::panic_fmt", [], [] |),
                            [
                              M.call_closure (|
                                Ty.path "core::fmt::Arguments",
                                M.get_associated_function (|
                                  Ty.path "core::fmt::Arguments",
                                  "new_v1",
                                  [
                                    Value.Integer IntegerKind.Usize 3;
                                    Value.Integer IntegerKind.Usize 2
                                  ],
                                  []
                                |),
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (|
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.alloc (|
                                          Value.Array
                                            [
                                              mk_str (| "cannot convert a slice of length " |);
                                              mk_str (| " to FixedBytes<" |);
                                              mk_str (| ">" |)
                                            ]
                                        |)
                                      |)
                                    |)
                                  |);
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (|
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.alloc (|
                                          Value.Array
                                            [
                                              M.call_closure (|
                                                Ty.path "core::fmt::rt::Argument",
                                                M.get_associated_function (|
                                                  Ty.path "core::fmt::rt::Argument",
                                                  "new_display",
                                                  [],
                                                  [ Ty.path "usize" ]
                                                |),
                                                [
                                                  M.borrow (|
                                                    Pointer.Kind.Ref,
                                                    M.deref (|
                                                      M.borrow (|
                                                        Pointer.Kind.Ref,
                                                        M.alloc (|
                                                          M.call_closure (|
                                                            Ty.path "usize",
                                                            M.get_associated_function (|
                                                              Ty.apply
                                                                (Ty.path "slice")
                                                                []
                                                                [ Ty.path "u8" ],
                                                              "len",
                                                              [],
                                                              []
                                                            |),
                                                            [
                                                              M.borrow (|
                                                                Pointer.Kind.Ref,
                                                                M.deref (| M.read (| src |) |)
                                                              |)
                                                            ]
                                                          |)
                                                        |)
                                                      |)
                                                    |)
                                                  |)
                                                ]
                                              |);
                                              M.call_closure (|
                                                Ty.path "core::fmt::rt::Argument",
                                                M.get_associated_function (|
                                                  Ty.path "core::fmt::rt::Argument",
                                                  "new_display",
                                                  [],
                                                  [ Ty.path "usize" ]
                                                |),
                                                [
                                                  M.borrow (|
                                                    Pointer.Kind.Ref,
                                                    M.deref (|
                                                      M.borrow (|
                                                        Pointer.Kind.Ref,
                                                        M.alloc (| N |)
                                                      |)
                                                    |)
                                                  |)
                                                ]
                                              |)
                                            ]
                                        |)
                                      |)
                                    |)
                                  |)
                                ]
                              |)
                            ]
                          |)
                        |)
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_from_slice :
        forall (N : Value.t),
        M.IsAssociatedFunction.C (Self N) "from_slice" (from_slice N).
      Admitted.
      Global Typeclasses Opaque from_slice.
      
      (*
          pub fn left_padding_from(value: &[u8]) -> Self {
              let len = value.len();
              assert!(len <= N, "slice is too large. Expected <={N} bytes, got {len}");
              let mut bytes = Self::ZERO;
              bytes[N - len..].copy_from_slice(value);
              bytes
          }
      *)
      Definition left_padding_from
          (N : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self N in
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            M.read (|
              let~ len : Ty.apply (Ty.path "*") [] [ Ty.path "usize" ] :=
                M.alloc (|
                  M.call_closure (|
                    Ty.path "usize",
                    M.get_associated_function (|
                      Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                      "len",
                      [],
                      []
                    |),
                    [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| value |) |) |) ]
                  |)
                |) in
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.match_operator (|
                  Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ :=
                          M.use
                            (M.alloc (|
                              UnOp.not (|
                                M.call_closure (|
                                  Ty.path "bool",
                                  BinOp.le,
                                  [ M.read (| len |); N ]
                                |)
                              |)
                            |)) in
                        let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        M.alloc (|
                          M.never_to_any (|
                            M.call_closure (|
                              Ty.path "never",
                              M.get_function (| "core::panicking::panic_fmt", [], [] |),
                              [
                                M.call_closure (|
                                  Ty.path "core::fmt::Arguments",
                                  M.get_associated_function (|
                                    Ty.path "core::fmt::Arguments",
                                    "new_v1",
                                    [
                                      Value.Integer IntegerKind.Usize 2;
                                      Value.Integer IntegerKind.Usize 2
                                    ],
                                    []
                                  |),
                                  [
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.deref (|
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.alloc (|
                                            Value.Array
                                              [
                                                mk_str (| "slice is too large. Expected <=" |);
                                                mk_str (| " bytes, got " |)
                                              ]
                                          |)
                                        |)
                                      |)
                                    |);
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.deref (|
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.alloc (|
                                            Value.Array
                                              [
                                                M.call_closure (|
                                                  Ty.path "core::fmt::rt::Argument",
                                                  M.get_associated_function (|
                                                    Ty.path "core::fmt::rt::Argument",
                                                    "new_display",
                                                    [],
                                                    [ Ty.path "usize" ]
                                                  |),
                                                  [
                                                    M.borrow (|
                                                      Pointer.Kind.Ref,
                                                      M.deref (|
                                                        M.borrow (|
                                                          Pointer.Kind.Ref,
                                                          M.alloc (| N |)
                                                        |)
                                                      |)
                                                    |)
                                                  ]
                                                |);
                                                M.call_closure (|
                                                  Ty.path "core::fmt::rt::Argument",
                                                  M.get_associated_function (|
                                                    Ty.path "core::fmt::rt::Argument",
                                                    "new_display",
                                                    [],
                                                    [ Ty.path "usize" ]
                                                  |),
                                                  [
                                                    M.borrow (|
                                                      Pointer.Kind.Ref,
                                                      M.deref (|
                                                        M.borrow (| Pointer.Kind.Ref, len |)
                                                      |)
                                                    |)
                                                  ]
                                                |)
                                              ]
                                          |)
                                        |)
                                      |)
                                    |)
                                  ]
                                |)
                              ]
                            |)
                          |)
                        |)));
                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                  ]
                |) in
              let~ bytes :
                  Ty.apply
                    (Ty.path "*")
                    []
                    [ Ty.apply (Ty.path "alloy_primitives::bits::fixed::FixedBytes") [ N ] [] ] :=
                M.copy (|
                  get_associated_constant (|
                    Ty.apply (Ty.path "alloy_primitives::bits::fixed::FixedBytes") [ N ] [],
                    "ZERO",
                    Ty.apply (Ty.path "alloy_primitives::bits::fixed::FixedBytes") [ N ] []
                  |)
                |) in
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.call_closure (|
                    Ty.tuple [],
                    M.get_associated_function (|
                      Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                      "copy_from_slice",
                      [],
                      []
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.MutRef,
                        M.deref (|
                          M.call_closure (|
                            Ty.apply
                              (Ty.path "&mut")
                              []
                              [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                            M.get_trait_method (|
                              "core::ops::index::IndexMut",
                              Ty.apply
                                (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                                [ N ]
                                [],
                              [],
                              [
                                Ty.apply
                                  (Ty.path "core::ops::range::RangeFrom")
                                  []
                                  [ Ty.path "usize" ]
                              ],
                              "index_mut",
                              [],
                              []
                            |),
                            [
                              M.borrow (| Pointer.Kind.MutRef, bytes |);
                              Value.StructRecord
                                "core::ops::range::RangeFrom"
                                [
                                  ("start",
                                    M.call_closure (|
                                      Ty.path "usize",
                                      BinOp.Wrap.sub,
                                      [ N; M.read (| len |) ]
                                    |))
                                ]
                            ]
                          |)
                        |)
                      |);
                      M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| value |) |) |)
                    ]
                  |)
                |) in
              bytes
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_left_padding_from :
        forall (N : Value.t),
        M.IsAssociatedFunction.C (Self N) "left_padding_from" (left_padding_from N).
      Admitted.
      Global Typeclasses Opaque left_padding_from.
      
      (*
          pub fn right_padding_from(value: &[u8]) -> Self {
              let len = value.len();
              assert!(len <= N, "slice is too large. Expected <={N} bytes, got {len}");
              let mut bytes = Self::ZERO;
              bytes[..len].copy_from_slice(value);
              bytes
          }
      *)
      Definition right_padding_from
          (N : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self N in
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            M.read (|
              let~ len : Ty.apply (Ty.path "*") [] [ Ty.path "usize" ] :=
                M.alloc (|
                  M.call_closure (|
                    Ty.path "usize",
                    M.get_associated_function (|
                      Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                      "len",
                      [],
                      []
                    |),
                    [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| value |) |) |) ]
                  |)
                |) in
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.match_operator (|
                  Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ :=
                          M.use
                            (M.alloc (|
                              UnOp.not (|
                                M.call_closure (|
                                  Ty.path "bool",
                                  BinOp.le,
                                  [ M.read (| len |); N ]
                                |)
                              |)
                            |)) in
                        let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        M.alloc (|
                          M.never_to_any (|
                            M.call_closure (|
                              Ty.path "never",
                              M.get_function (| "core::panicking::panic_fmt", [], [] |),
                              [
                                M.call_closure (|
                                  Ty.path "core::fmt::Arguments",
                                  M.get_associated_function (|
                                    Ty.path "core::fmt::Arguments",
                                    "new_v1",
                                    [
                                      Value.Integer IntegerKind.Usize 2;
                                      Value.Integer IntegerKind.Usize 2
                                    ],
                                    []
                                  |),
                                  [
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.deref (|
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.alloc (|
                                            Value.Array
                                              [
                                                mk_str (| "slice is too large. Expected <=" |);
                                                mk_str (| " bytes, got " |)
                                              ]
                                          |)
                                        |)
                                      |)
                                    |);
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.deref (|
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.alloc (|
                                            Value.Array
                                              [
                                                M.call_closure (|
                                                  Ty.path "core::fmt::rt::Argument",
                                                  M.get_associated_function (|
                                                    Ty.path "core::fmt::rt::Argument",
                                                    "new_display",
                                                    [],
                                                    [ Ty.path "usize" ]
                                                  |),
                                                  [
                                                    M.borrow (|
                                                      Pointer.Kind.Ref,
                                                      M.deref (|
                                                        M.borrow (|
                                                          Pointer.Kind.Ref,
                                                          M.alloc (| N |)
                                                        |)
                                                      |)
                                                    |)
                                                  ]
                                                |);
                                                M.call_closure (|
                                                  Ty.path "core::fmt::rt::Argument",
                                                  M.get_associated_function (|
                                                    Ty.path "core::fmt::rt::Argument",
                                                    "new_display",
                                                    [],
                                                    [ Ty.path "usize" ]
                                                  |),
                                                  [
                                                    M.borrow (|
                                                      Pointer.Kind.Ref,
                                                      M.deref (|
                                                        M.borrow (| Pointer.Kind.Ref, len |)
                                                      |)
                                                    |)
                                                  ]
                                                |)
                                              ]
                                          |)
                                        |)
                                      |)
                                    |)
                                  ]
                                |)
                              ]
                            |)
                          |)
                        |)));
                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                  ]
                |) in
              let~ bytes :
                  Ty.apply
                    (Ty.path "*")
                    []
                    [ Ty.apply (Ty.path "alloy_primitives::bits::fixed::FixedBytes") [ N ] [] ] :=
                M.copy (|
                  get_associated_constant (|
                    Ty.apply (Ty.path "alloy_primitives::bits::fixed::FixedBytes") [ N ] [],
                    "ZERO",
                    Ty.apply (Ty.path "alloy_primitives::bits::fixed::FixedBytes") [ N ] []
                  |)
                |) in
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.call_closure (|
                    Ty.tuple [],
                    M.get_associated_function (|
                      Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                      "copy_from_slice",
                      [],
                      []
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.MutRef,
                        M.deref (|
                          M.call_closure (|
                            Ty.apply
                              (Ty.path "&mut")
                              []
                              [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                            M.get_trait_method (|
                              "core::ops::index::IndexMut",
                              Ty.apply
                                (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                                [ N ]
                                [],
                              [],
                              [
                                Ty.apply
                                  (Ty.path "core::ops::range::RangeTo")
                                  []
                                  [ Ty.path "usize" ]
                              ],
                              "index_mut",
                              [],
                              []
                            |),
                            [
                              M.borrow (| Pointer.Kind.MutRef, bytes |);
                              Value.StructRecord
                                "core::ops::range::RangeTo"
                                [ ("end_", M.read (| len |)) ]
                            ]
                          |)
                        |)
                      |);
                      M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| value |) |) |)
                    ]
                  |)
                |) in
              bytes
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_right_padding_from :
        forall (N : Value.t),
        M.IsAssociatedFunction.C (Self N) "right_padding_from" (right_padding_from N).
      Admitted.
      Global Typeclasses Opaque right_padding_from.
      
      (*
          pub const fn as_slice(&self) -> &[u8] {
              &self.0
          }
      *)
      Definition as_slice (N : Value.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self N in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            (* Unsize *)
            M.pointer_coercion
              (M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.SubPointer.get_struct_tuple_field (|
                      M.deref (| M.read (| self |) |),
                      "alloy_primitives::bits::fixed::FixedBytes",
                      0
                    |)
                  |)
                |)
              |))))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_as_slice :
        forall (N : Value.t),
        M.IsAssociatedFunction.C (Self N) "as_slice" (as_slice N).
      Admitted.
      Global Typeclasses Opaque as_slice.
      
      (*
          pub fn as_mut_slice(&mut self) -> &mut [u8] {
              &mut self.0
          }
      *)
      Definition as_mut_slice
          (N : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self N in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.borrow (|
              Pointer.Kind.MutRef,
              M.deref (|
                (* Unsize *)
                M.pointer_coercion
                  (M.borrow (|
                    Pointer.Kind.MutRef,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.MutRef,
                        M.SubPointer.get_struct_tuple_field (|
                          M.deref (| M.read (| self |) |),
                          "alloy_primitives::bits::fixed::FixedBytes",
                          0
                        |)
                      |)
                    |)
                  |))
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_as_mut_slice :
        forall (N : Value.t),
        M.IsAssociatedFunction.C (Self N) "as_mut_slice" (as_mut_slice N).
      Admitted.
      Global Typeclasses Opaque as_mut_slice.
      
      (*
          pub fn covers(&self, other: &Self) -> bool {
              ( *self & *other) == *other
          }
      *)
      Definition covers (N : Value.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self N in
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              Ty.path "bool",
              M.get_trait_method (|
                "core::cmp::PartialEq",
                Ty.apply (Ty.path "alloy_primitives::bits::fixed::FixedBytes") [ N ] [],
                [],
                [ Ty.apply (Ty.path "alloy_primitives::bits::fixed::FixedBytes") [ N ] [] ],
                "eq",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.alloc (|
                    M.call_closure (|
                      Ty.apply (Ty.path "alloy_primitives::bits::fixed::FixedBytes") [ N ] [],
                      M.get_trait_method (|
                        "core::ops::bit::BitAnd",
                        Ty.apply (Ty.path "alloy_primitives::bits::fixed::FixedBytes") [ N ] [],
                        [],
                        [ Ty.apply (Ty.path "alloy_primitives::bits::fixed::FixedBytes") [ N ] [] ],
                        "bitand",
                        [],
                        []
                      |),
                      [
                        M.read (| M.deref (| M.read (| self |) |) |);
                        M.read (| M.deref (| M.read (| other |) |) |)
                      ]
                    |)
                  |)
                |);
                M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| other |) |) |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_covers :
        forall (N : Value.t),
        M.IsAssociatedFunction.C (Self N) "covers" (covers N).
      Admitted.
      Global Typeclasses Opaque covers.
      
      (*
          pub const fn const_covers(self, other: Self) -> bool {
              // (self & other) == other
              other.const_eq(&self.bit_and(other))
          }
      *)
      Definition const_covers
          (N : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self N in
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              Ty.path "bool",
              M.get_associated_function (|
                Ty.apply (Ty.path "alloy_primitives::bits::fixed::FixedBytes") [ N ] [],
                "const_eq",
                [],
                []
              |),
              [
                M.borrow (| Pointer.Kind.Ref, other |);
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.alloc (|
                        M.call_closure (|
                          Ty.apply (Ty.path "alloy_primitives::bits::fixed::FixedBytes") [ N ] [],
                          M.get_associated_function (|
                            Ty.apply (Ty.path "alloy_primitives::bits::fixed::FixedBytes") [ N ] [],
                            "bit_and",
                            [],
                            []
                          |),
                          [ M.read (| self |); M.read (| other |) ]
                        |)
                      |)
                    |)
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_const_covers :
        forall (N : Value.t),
        M.IsAssociatedFunction.C (Self N) "const_covers" (const_covers N).
      Admitted.
      Global Typeclasses Opaque const_covers.
      
      (*
          pub const fn const_eq(&self, other: &Self) -> bool {
              let mut i = 0;
              while i < N {
                  if self.0[i] != other.0[i] {
                      return false;
                  }
                  i += 1;
              }
              true
          }
      *)
      Definition const_eq (N : Value.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self N in
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.catch_return (Ty.path "bool") (|
              ltac:(M.monadic
                (M.read (|
                  let~ i : Ty.apply (Ty.path "*") [] [ Ty.path "usize" ] :=
                    M.alloc (| Value.Integer IntegerKind.Usize 0 |) in
                  let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                    M.loop (|
                      Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                      ltac:(M.monadic
                        (M.match_operator (|
                          Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                          M.alloc (| Value.Tuple [] |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ :=
                                  M.use
                                    (M.alloc (|
                                      M.call_closure (|
                                        Ty.path "bool",
                                        BinOp.lt,
                                        [ M.read (| i |); N ]
                                      |)
                                    |)) in
                                let _ :=
                                  is_constant_or_break_match (|
                                    M.read (| γ |),
                                    Value.Bool true
                                  |) in
                                let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                                  M.match_operator (|
                                    Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                                    M.alloc (| Value.Tuple [] |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let γ :=
                                            M.use
                                              (M.alloc (|
                                                M.call_closure (|
                                                  Ty.path "bool",
                                                  BinOp.ne,
                                                  [
                                                    M.read (|
                                                      M.SubPointer.get_array_field (|
                                                        M.SubPointer.get_struct_tuple_field (|
                                                          M.deref (| M.read (| self |) |),
                                                          "alloy_primitives::bits::fixed::FixedBytes",
                                                          0
                                                        |),
                                                        M.read (| i |)
                                                      |)
                                                    |);
                                                    M.read (|
                                                      M.SubPointer.get_array_field (|
                                                        M.SubPointer.get_struct_tuple_field (|
                                                          M.deref (| M.read (| other |) |),
                                                          "alloy_primitives::bits::fixed::FixedBytes",
                                                          0
                                                        |),
                                                        M.read (| i |)
                                                      |)
                                                    |)
                                                  ]
                                                |)
                                              |)) in
                                          let _ :=
                                            is_constant_or_break_match (|
                                              M.read (| γ |),
                                              Value.Bool true
                                            |) in
                                          M.alloc (|
                                            M.never_to_any (|
                                              M.read (| M.return_ (| Value.Bool false |) |)
                                            |)
                                          |)));
                                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                                    ]
                                  |) in
                                let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                                  M.alloc (|
                                    let β := i in
                                    M.write (|
                                      β,
                                      M.call_closure (|
                                        Ty.path "usize",
                                        BinOp.Wrap.add,
                                        [ M.read (| β |); Value.Integer IntegerKind.Usize 1 ]
                                      |)
                                    |)
                                  |) in
                                M.alloc (| Value.Tuple [] |)));
                            fun γ =>
                              ltac:(M.monadic
                                (M.alloc (|
                                  M.never_to_any (|
                                    M.read (|
                                      let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                                        M.alloc (|
                                          M.never_to_any (| M.read (| M.break (||) |) |)
                                        |) in
                                      M.alloc (| Value.Tuple [] |)
                                    |)
                                  |)
                                |)))
                          ]
                        |)))
                    |) in
                  M.alloc (| Value.Bool true |)
                |)))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_const_eq :
        forall (N : Value.t),
        M.IsAssociatedFunction.C (Self N) "const_eq" (const_eq N).
      Admitted.
      Global Typeclasses Opaque const_eq.
      
      (*
          pub fn is_zero(&self) -> bool {
              *self == Self::ZERO
          }
      *)
      Definition is_zero (N : Value.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self N in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "bool",
              M.get_trait_method (|
                "core::cmp::PartialEq",
                Ty.apply (Ty.path "alloy_primitives::bits::fixed::FixedBytes") [ N ] [],
                [],
                [ Ty.apply (Ty.path "alloy_primitives::bits::fixed::FixedBytes") [ N ] [] ],
                "eq",
                [],
                []
              |),
              [
                M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |);
                M.borrow (|
                  Pointer.Kind.Ref,
                  get_associated_constant (|
                    Ty.apply (Ty.path "alloy_primitives::bits::fixed::FixedBytes") [ N ] [],
                    "ZERO",
                    Ty.apply (Ty.path "alloy_primitives::bits::fixed::FixedBytes") [ N ] []
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_is_zero :
        forall (N : Value.t),
        M.IsAssociatedFunction.C (Self N) "is_zero" (is_zero N).
      Admitted.
      Global Typeclasses Opaque is_zero.
      
      (*
          pub const fn const_is_zero(&self) -> bool {
              self.const_eq(&Self::ZERO)
          }
      *)
      Definition const_is_zero
          (N : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self N in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "bool",
              M.get_associated_function (|
                Ty.apply (Ty.path "alloy_primitives::bits::fixed::FixedBytes") [ N ] [],
                "const_eq",
                [],
                []
              |),
              [
                M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |);
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      get_associated_constant (|
                        Ty.apply (Ty.path "alloy_primitives::bits::fixed::FixedBytes") [ N ] [],
                        "ZERO",
                        Ty.apply (Ty.path "alloy_primitives::bits::fixed::FixedBytes") [ N ] []
                      |)
                    |)
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_const_is_zero :
        forall (N : Value.t),
        M.IsAssociatedFunction.C (Self N) "const_is_zero" (const_is_zero N).
      Admitted.
      Global Typeclasses Opaque const_is_zero.
      
      (*
          pub const fn bit_and(self, rhs: Self) -> Self {
              let mut ret = Self::ZERO;
              let mut i = 0;
              while i < N {
                  ret.0[i] = self.0[i] & rhs.0[i];
                  i += 1;
              }
              ret
          }
      *)
      Definition bit_and (N : Value.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self N in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            M.read (|
              let~ ret :
                  Ty.apply
                    (Ty.path "*")
                    []
                    [ Ty.apply (Ty.path "alloy_primitives::bits::fixed::FixedBytes") [ N ] [] ] :=
                M.copy (|
                  get_associated_constant (|
                    Ty.apply (Ty.path "alloy_primitives::bits::fixed::FixedBytes") [ N ] [],
                    "ZERO",
                    Ty.apply (Ty.path "alloy_primitives::bits::fixed::FixedBytes") [ N ] []
                  |)
                |) in
              let~ i : Ty.apply (Ty.path "*") [] [ Ty.path "usize" ] :=
                M.alloc (| Value.Integer IntegerKind.Usize 0 |) in
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.loop (|
                  Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                  ltac:(M.monadic
                    (M.match_operator (|
                      Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  M.call_closure (|
                                    Ty.path "bool",
                                    BinOp.lt,
                                    [ M.read (| i |); N ]
                                  |)
                                |)) in
                            let _ :=
                              is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                              M.alloc (|
                                M.write (|
                                  M.SubPointer.get_array_field (|
                                    M.SubPointer.get_struct_tuple_field (|
                                      ret,
                                      "alloy_primitives::bits::fixed::FixedBytes",
                                      0
                                    |),
                                    M.read (| i |)
                                  |),
                                  M.call_closure (|
                                    Ty.path "u8",
                                    BinOp.Wrap.bit_and,
                                    [
                                      M.read (|
                                        M.SubPointer.get_array_field (|
                                          M.SubPointer.get_struct_tuple_field (|
                                            self,
                                            "alloy_primitives::bits::fixed::FixedBytes",
                                            0
                                          |),
                                          M.read (| i |)
                                        |)
                                      |);
                                      M.read (|
                                        M.SubPointer.get_array_field (|
                                          M.SubPointer.get_struct_tuple_field (|
                                            rhs,
                                            "alloy_primitives::bits::fixed::FixedBytes",
                                            0
                                          |),
                                          M.read (| i |)
                                        |)
                                      |)
                                    ]
                                  |)
                                |)
                              |) in
                            let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                              M.alloc (|
                                let β := i in
                                M.write (|
                                  β,
                                  M.call_closure (|
                                    Ty.path "usize",
                                    BinOp.Wrap.add,
                                    [ M.read (| β |); Value.Integer IntegerKind.Usize 1 ]
                                  |)
                                |)
                              |) in
                            M.alloc (| Value.Tuple [] |)));
                        fun γ =>
                          ltac:(M.monadic
                            (M.alloc (|
                              M.never_to_any (|
                                M.read (|
                                  let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                                    M.alloc (| M.never_to_any (| M.read (| M.break (||) |) |) |) in
                                  M.alloc (| Value.Tuple [] |)
                                |)
                              |)
                            |)))
                      ]
                    |)))
                |) in
              ret
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_bit_and :
        forall (N : Value.t),
        M.IsAssociatedFunction.C (Self N) "bit_and" (bit_and N).
      Admitted.
      Global Typeclasses Opaque bit_and.
      
      (*
          pub const fn bit_or(self, rhs: Self) -> Self {
              let mut ret = Self::ZERO;
              let mut i = 0;
              while i < N {
                  ret.0[i] = self.0[i] | rhs.0[i];
                  i += 1;
              }
              ret
          }
      *)
      Definition bit_or (N : Value.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self N in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            M.read (|
              let~ ret :
                  Ty.apply
                    (Ty.path "*")
                    []
                    [ Ty.apply (Ty.path "alloy_primitives::bits::fixed::FixedBytes") [ N ] [] ] :=
                M.copy (|
                  get_associated_constant (|
                    Ty.apply (Ty.path "alloy_primitives::bits::fixed::FixedBytes") [ N ] [],
                    "ZERO",
                    Ty.apply (Ty.path "alloy_primitives::bits::fixed::FixedBytes") [ N ] []
                  |)
                |) in
              let~ i : Ty.apply (Ty.path "*") [] [ Ty.path "usize" ] :=
                M.alloc (| Value.Integer IntegerKind.Usize 0 |) in
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.loop (|
                  Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                  ltac:(M.monadic
                    (M.match_operator (|
                      Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  M.call_closure (|
                                    Ty.path "bool",
                                    BinOp.lt,
                                    [ M.read (| i |); N ]
                                  |)
                                |)) in
                            let _ :=
                              is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                              M.alloc (|
                                M.write (|
                                  M.SubPointer.get_array_field (|
                                    M.SubPointer.get_struct_tuple_field (|
                                      ret,
                                      "alloy_primitives::bits::fixed::FixedBytes",
                                      0
                                    |),
                                    M.read (| i |)
                                  |),
                                  M.call_closure (|
                                    Ty.path "u8",
                                    BinOp.Wrap.bit_or,
                                    [
                                      M.read (|
                                        M.SubPointer.get_array_field (|
                                          M.SubPointer.get_struct_tuple_field (|
                                            self,
                                            "alloy_primitives::bits::fixed::FixedBytes",
                                            0
                                          |),
                                          M.read (| i |)
                                        |)
                                      |);
                                      M.read (|
                                        M.SubPointer.get_array_field (|
                                          M.SubPointer.get_struct_tuple_field (|
                                            rhs,
                                            "alloy_primitives::bits::fixed::FixedBytes",
                                            0
                                          |),
                                          M.read (| i |)
                                        |)
                                      |)
                                    ]
                                  |)
                                |)
                              |) in
                            let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                              M.alloc (|
                                let β := i in
                                M.write (|
                                  β,
                                  M.call_closure (|
                                    Ty.path "usize",
                                    BinOp.Wrap.add,
                                    [ M.read (| β |); Value.Integer IntegerKind.Usize 1 ]
                                  |)
                                |)
                              |) in
                            M.alloc (| Value.Tuple [] |)));
                        fun γ =>
                          ltac:(M.monadic
                            (M.alloc (|
                              M.never_to_any (|
                                M.read (|
                                  let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                                    M.alloc (| M.never_to_any (| M.read (| M.break (||) |) |) |) in
                                  M.alloc (| Value.Tuple [] |)
                                |)
                              |)
                            |)))
                      ]
                    |)))
                |) in
              ret
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_bit_or :
        forall (N : Value.t),
        M.IsAssociatedFunction.C (Self N) "bit_or" (bit_or N).
      Admitted.
      Global Typeclasses Opaque bit_or.
      
      (*
          pub const fn bit_xor(self, rhs: Self) -> Self {
              let mut ret = Self::ZERO;
              let mut i = 0;
              while i < N {
                  ret.0[i] = self.0[i] ^ rhs.0[i];
                  i += 1;
              }
              ret
          }
      *)
      Definition bit_xor (N : Value.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self N in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            M.read (|
              let~ ret :
                  Ty.apply
                    (Ty.path "*")
                    []
                    [ Ty.apply (Ty.path "alloy_primitives::bits::fixed::FixedBytes") [ N ] [] ] :=
                M.copy (|
                  get_associated_constant (|
                    Ty.apply (Ty.path "alloy_primitives::bits::fixed::FixedBytes") [ N ] [],
                    "ZERO",
                    Ty.apply (Ty.path "alloy_primitives::bits::fixed::FixedBytes") [ N ] []
                  |)
                |) in
              let~ i : Ty.apply (Ty.path "*") [] [ Ty.path "usize" ] :=
                M.alloc (| Value.Integer IntegerKind.Usize 0 |) in
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.loop (|
                  Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                  ltac:(M.monadic
                    (M.match_operator (|
                      Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  M.call_closure (|
                                    Ty.path "bool",
                                    BinOp.lt,
                                    [ M.read (| i |); N ]
                                  |)
                                |)) in
                            let _ :=
                              is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                              M.alloc (|
                                M.write (|
                                  M.SubPointer.get_array_field (|
                                    M.SubPointer.get_struct_tuple_field (|
                                      ret,
                                      "alloy_primitives::bits::fixed::FixedBytes",
                                      0
                                    |),
                                    M.read (| i |)
                                  |),
                                  M.call_closure (|
                                    Ty.path "u8",
                                    BinOp.Wrap.bit_xor,
                                    [
                                      M.read (|
                                        M.SubPointer.get_array_field (|
                                          M.SubPointer.get_struct_tuple_field (|
                                            self,
                                            "alloy_primitives::bits::fixed::FixedBytes",
                                            0
                                          |),
                                          M.read (| i |)
                                        |)
                                      |);
                                      M.read (|
                                        M.SubPointer.get_array_field (|
                                          M.SubPointer.get_struct_tuple_field (|
                                            rhs,
                                            "alloy_primitives::bits::fixed::FixedBytes",
                                            0
                                          |),
                                          M.read (| i |)
                                        |)
                                      |)
                                    ]
                                  |)
                                |)
                              |) in
                            let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                              M.alloc (|
                                let β := i in
                                M.write (|
                                  β,
                                  M.call_closure (|
                                    Ty.path "usize",
                                    BinOp.Wrap.add,
                                    [ M.read (| β |); Value.Integer IntegerKind.Usize 1 ]
                                  |)
                                |)
                              |) in
                            M.alloc (| Value.Tuple [] |)));
                        fun γ =>
                          ltac:(M.monadic
                            (M.alloc (|
                              M.never_to_any (|
                                M.read (|
                                  let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                                    M.alloc (| M.never_to_any (| M.read (| M.break (||) |) |) |) in
                                  M.alloc (| Value.Tuple [] |)
                                |)
                              |)
                            |)))
                      ]
                    |)))
                |) in
              ret
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_bit_xor :
        forall (N : Value.t),
        M.IsAssociatedFunction.C (Self N) "bit_xor" (bit_xor N).
      Admitted.
      Global Typeclasses Opaque bit_xor.
      
      (*
          fn fmt_hex<const UPPER: bool>(&self, f: &mut fmt::Formatter<'_>, prefix: bool) -> fmt::Result {
              let mut buf = hex::Buffer::<N, true>::new();
              let s = if UPPER { buf.format_upper(self) } else { buf.format(self) };
              // SAFETY: The buffer is guaranteed to be at least 2 bytes in length.
              f.write_str(unsafe { s.get_unchecked((!prefix as usize) * 2..) })
          }
      *)
      Definition fmt_hex (N : Value.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self N in
        match ε, τ, α with
        | [ UPPER ], [], [ self; f; prefix ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            let prefix := M.alloc (| prefix |) in
            M.read (|
              let~ buf :
                  Ty.apply
                    (Ty.path "*")
                    []
                    [ Ty.apply (Ty.path "const_hex::buffer::Buffer") [ N; Value.Bool true ] [] ] :=
                M.alloc (|
                  M.call_closure (|
                    Ty.apply (Ty.path "const_hex::buffer::Buffer") [ N; Value.Bool true ] [],
                    M.get_associated_function (|
                      Ty.apply (Ty.path "const_hex::buffer::Buffer") [ N; Value.Bool true ] [],
                      "new",
                      [],
                      []
                    |),
                    []
                  |)
                |) in
              let~ s :
                  Ty.apply (Ty.path "*") [] [ Ty.apply (Ty.path "&mut") [] [ Ty.path "str" ] ] :=
                M.copy (|
                  M.match_operator (|
                    Ty.apply (Ty.path "*") [] [ Ty.apply (Ty.path "&mut") [] [ Ty.path "str" ] ],
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ := M.use (M.alloc (| UPPER |)) in
                          let _ :=
                            is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (|
                            M.call_closure (|
                              Ty.apply (Ty.path "&mut") [] [ Ty.path "str" ],
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "const_hex::buffer::Buffer")
                                  [ N; Value.Bool true ]
                                  [],
                                "format_upper",
                                [],
                                []
                              |),
                              [
                                M.borrow (| Pointer.Kind.MutRef, buf |);
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.deref (|
                                    M.call_closure (|
                                      Ty.apply
                                        (Ty.path "&")
                                        []
                                        [ Ty.apply (Ty.path "array") [ N ] [ Ty.path "u8" ] ],
                                      M.get_trait_method (|
                                        "core::ops::deref::Deref",
                                        Ty.apply
                                          (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                                          [ N ]
                                          [],
                                        [],
                                        [],
                                        "deref",
                                        [],
                                        []
                                      |),
                                      [
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.deref (| M.read (| self |) |)
                                        |)
                                      ]
                                    |)
                                  |)
                                |)
                              ]
                            |)
                          |)));
                      fun γ =>
                        ltac:(M.monadic
                          (M.alloc (|
                            M.borrow (|
                              Pointer.Kind.MutRef,
                              M.deref (|
                                M.call_closure (|
                                  Ty.apply (Ty.path "&mut") [] [ Ty.path "str" ],
                                  M.get_associated_function (|
                                    Ty.apply
                                      (Ty.path "const_hex::buffer::Buffer")
                                      [ N; Value.Bool true ]
                                      [],
                                    "format",
                                    [],
                                    []
                                  |),
                                  [
                                    M.borrow (| Pointer.Kind.MutRef, buf |);
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.deref (|
                                        M.call_closure (|
                                          Ty.apply
                                            (Ty.path "&")
                                            []
                                            [ Ty.apply (Ty.path "array") [ N ] [ Ty.path "u8" ] ],
                                          M.get_trait_method (|
                                            "core::ops::deref::Deref",
                                            Ty.apply
                                              (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                                              [ N ]
                                              [],
                                            [],
                                            [],
                                            "deref",
                                            [],
                                            []
                                          |),
                                          [
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.deref (| M.read (| self |) |)
                                            |)
                                          ]
                                        |)
                                      |)
                                    |)
                                  ]
                                |)
                              |)
                            |)
                          |)))
                    ]
                  |)
                |) in
              M.alloc (|
                M.call_closure (|
                  Ty.apply
                    (Ty.path "core::result::Result")
                    []
                    [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                  M.get_associated_function (|
                    Ty.path "core::fmt::Formatter",
                    "write_str",
                    [],
                    []
                  |),
                  [
                    M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.call_closure (|
                          Ty.apply (Ty.path "&") [] [ Ty.path "str" ],
                          M.get_associated_function (|
                            Ty.path "str",
                            "get_unchecked",
                            [],
                            [
                              Ty.apply
                                (Ty.path "core::ops::range::RangeFrom")
                                []
                                [ Ty.path "usize" ]
                            ]
                          |),
                          [
                            M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| s |) |) |);
                            Value.StructRecord
                              "core::ops::range::RangeFrom"
                              [
                                ("start",
                                  M.call_closure (|
                                    Ty.path "usize",
                                    BinOp.Wrap.mul,
                                    [
                                      M.cast (Ty.path "usize") (UnOp.not (| M.read (| prefix |) |));
                                      Value.Integer IntegerKind.Usize 2
                                    ]
                                  |))
                              ]
                          ]
                        |)
                      |)
                    |)
                  ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_fmt_hex :
        forall (N : Value.t),
        M.IsAssociatedFunction.C (Self N) "fmt_hex" (fmt_hex N).
      Admitted.
      Global Typeclasses Opaque fmt_hex.
    End Impl_alloy_primitives_bits_fixed_FixedBytes_N.
  End fixed.
End bits.
