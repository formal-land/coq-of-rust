(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module bits.
  Module address.
    (* StructTuple
      {
        name := "Address";
        const_params := [];
        ty_params := [];
        fields :=
          [
            Ty.apply
              (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
              [ Value.Integer IntegerKind.Usize 20 ]
              []
          ];
      } *)
    
    Module Impl_core_clone_Clone_for_alloy_primitives_bits_address_Address.
      Definition Self : Ty.t := Ty.path "alloy_primitives::bits::address::Address".
      
      (*             Clone *)
      Definition clone (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                None,
                Value.DeclaredButUndefined,
                [ fun γ => ltac:(M.monadic (M.deref (| M.read (| self |) |))) ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::clone::Clone"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [ ("clone", InstanceField.Method clone) ].
    End Impl_core_clone_Clone_for_alloy_primitives_bits_address_Address.
    
    Module Impl_core_marker_Copy_for_alloy_primitives_bits_address_Address.
      Definition Self : Ty.t := Ty.path "alloy_primitives::bits::address::Address".
      
      Axiom Implements :
        M.IsTraitInstance
          "core::marker::Copy"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [].
    End Impl_core_marker_Copy_for_alloy_primitives_bits_address_Address.
    
    Module Impl_core_default_Default_for_alloy_primitives_bits_address_Address.
      Definition Self : Ty.t := Ty.path "alloy_primitives::bits::address::Address".
      
      (*             Default *)
      Definition default (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [] =>
          ltac:(M.monadic
            (Value.StructTuple
              "alloy_primitives::bits::address::Address"
              [
                M.call_closure (|
                  Ty.apply
                    (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                    [ Value.Integer IntegerKind.Usize 20 ]
                    [],
                  M.get_trait_method (|
                    "core::default::Default",
                    Ty.apply
                      (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                      [ Value.Integer IntegerKind.Usize 20 ]
                      [],
                    [],
                    [],
                    "default",
                    [],
                    []
                  |),
                  []
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::default::Default"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [ ("default", InstanceField.Method default) ].
    End Impl_core_default_Default_for_alloy_primitives_bits_address_Address.
    
    Module Impl_core_marker_StructuralPartialEq_for_alloy_primitives_bits_address_Address.
      Definition Self : Ty.t := Ty.path "alloy_primitives::bits::address::Address".
      
      Axiom Implements :
        M.IsTraitInstance
          "core::marker::StructuralPartialEq"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [].
    End Impl_core_marker_StructuralPartialEq_for_alloy_primitives_bits_address_Address.
    
    Module Impl_core_cmp_PartialEq_alloy_primitives_bits_address_Address_for_alloy_primitives_bits_address_Address.
      Definition Self : Ty.t := Ty.path "alloy_primitives::bits::address::Address".
      
      (*             PartialEq *)
      Definition eq (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              Ty.path "bool",
              M.get_trait_method (|
                "core::cmp::PartialEq",
                Ty.apply
                  (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                  [ Value.Integer IntegerKind.Usize 20 ]
                  [],
                [],
                [
                  Ty.apply
                    (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                    [ Value.Integer IntegerKind.Usize 20 ]
                    []
                ],
                "eq",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.SubPointer.get_struct_tuple_field (|
                    M.deref (| M.read (| self |) |),
                    "alloy_primitives::bits::address::Address",
                    0
                  |)
                |);
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.SubPointer.get_struct_tuple_field (|
                    M.deref (| M.read (| other |) |),
                    "alloy_primitives::bits::address::Address",
                    0
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::cmp::PartialEq"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "alloy_primitives::bits::address::Address" ]
          Self
          (* Instance *) [ ("eq", InstanceField.Method eq) ].
    End Impl_core_cmp_PartialEq_alloy_primitives_bits_address_Address_for_alloy_primitives_bits_address_Address.
    
    Module Impl_core_cmp_Eq_for_alloy_primitives_bits_address_Address.
      Definition Self : Ty.t := Ty.path "alloy_primitives::bits::address::Address".
      
      (*             Eq *)
      Definition assert_receiver_is_total_eq
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                None,
                Value.DeclaredButUndefined,
                [ fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |))) ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::cmp::Eq"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *)
          [ ("assert_receiver_is_total_eq", InstanceField.Method assert_receiver_is_total_eq) ].
    End Impl_core_cmp_Eq_for_alloy_primitives_bits_address_Address.
    
    Module Impl_core_cmp_PartialOrd_alloy_primitives_bits_address_Address_for_alloy_primitives_bits_address_Address.
      Definition Self : Ty.t := Ty.path "alloy_primitives::bits::address::Address".
      
      (*             PartialOrd *)
      Definition partial_cmp (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "core::cmp::Ordering" ],
              M.get_trait_method (|
                "core::cmp::PartialOrd",
                Ty.apply
                  (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                  [ Value.Integer IntegerKind.Usize 20 ]
                  [],
                [],
                [
                  Ty.apply
                    (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                    [ Value.Integer IntegerKind.Usize 20 ]
                    []
                ],
                "partial_cmp",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_tuple_field (|
                        M.deref (| M.read (| self |) |),
                        "alloy_primitives::bits::address::Address",
                        0
                      |)
                    |)
                  |)
                |);
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_tuple_field (|
                        M.deref (| M.read (| other |) |),
                        "alloy_primitives::bits::address::Address",
                        0
                      |)
                    |)
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::cmp::PartialOrd"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "alloy_primitives::bits::address::Address" ]
          Self
          (* Instance *) [ ("partial_cmp", InstanceField.Method partial_cmp) ].
    End Impl_core_cmp_PartialOrd_alloy_primitives_bits_address_Address_for_alloy_primitives_bits_address_Address.
    
    Module Impl_core_cmp_Ord_for_alloy_primitives_bits_address_Address.
      Definition Self : Ty.t := Ty.path "alloy_primitives::bits::address::Address".
      
      (*             Ord *)
      Definition cmp (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              Ty.path "core::cmp::Ordering",
              M.get_trait_method (|
                "core::cmp::Ord",
                Ty.apply
                  (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                  [ Value.Integer IntegerKind.Usize 20 ]
                  [],
                [],
                [],
                "cmp",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_tuple_field (|
                        M.deref (| M.read (| self |) |),
                        "alloy_primitives::bits::address::Address",
                        0
                      |)
                    |)
                  |)
                |);
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_tuple_field (|
                        M.deref (| M.read (| other |) |),
                        "alloy_primitives::bits::address::Address",
                        0
                      |)
                    |)
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::cmp::Ord"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [ ("cmp", InstanceField.Method cmp) ].
    End Impl_core_cmp_Ord_for_alloy_primitives_bits_address_Address.
    
    Module Impl_core_hash_Hash_for_alloy_primitives_bits_address_Address.
      Definition Self : Ty.t := Ty.path "alloy_primitives::bits::address::Address".
      
      (*             Hash *)
      Definition hash (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [ __H ], [ self; state ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let state := M.alloc (| state |) in
            M.call_closure (|
              Ty.tuple [],
              M.get_trait_method (|
                "core::hash::Hash",
                Ty.apply
                  (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                  [ Value.Integer IntegerKind.Usize 20 ]
                  [],
                [],
                [],
                "hash",
                [],
                [ __H ]
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_tuple_field (|
                        M.deref (| M.read (| self |) |),
                        "alloy_primitives::bits::address::Address",
                        0
                      |)
                    |)
                  |)
                |);
                M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::hash::Hash"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [ ("hash", InstanceField.Method hash) ].
    End Impl_core_hash_Hash_for_alloy_primitives_bits_address_Address.
    
    Module Impl_core_convert_AsMut_alloy_primitives_bits_fixed_FixedBytes_Usize_20_for_alloy_primitives_bits_address_Address.
      Definition Self : Ty.t := Ty.path "alloy_primitives::bits::address::Address".
      
      (*             $crate::private::derive_more::AsMut *)
      Definition as_mut (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.borrow (|
              Pointer.Kind.MutRef,
              M.deref (|
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.MutRef,
                      M.SubPointer.get_struct_tuple_field (|
                        M.deref (| M.read (| self |) |),
                        "alloy_primitives::bits::address::Address",
                        0
                      |)
                    |)
                  |)
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::AsMut"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [
            Ty.apply
              (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
              [ Value.Integer IntegerKind.Usize 20 ]
              []
          ]
          Self
          (* Instance *) [ ("as_mut", InstanceField.Method as_mut) ].
    End Impl_core_convert_AsMut_alloy_primitives_bits_fixed_FixedBytes_Usize_20_for_alloy_primitives_bits_address_Address.
    
    Module Impl_core_convert_AsRef_alloy_primitives_bits_fixed_FixedBytes_Usize_20_for_alloy_primitives_bits_address_Address.
      Definition Self : Ty.t := Ty.path "alloy_primitives::bits::address::Address".
      
      (*             $crate::private::derive_more::AsRef *)
      Definition as_ref (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.borrow (|
              Pointer.Kind.Ref,
              M.deref (|
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.SubPointer.get_struct_tuple_field (|
                    M.deref (| M.read (| self |) |),
                    "alloy_primitives::bits::address::Address",
                    0
                  |)
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::AsRef"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [
            Ty.apply
              (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
              [ Value.Integer IntegerKind.Usize 20 ]
              []
          ]
          Self
          (* Instance *) [ ("as_ref", InstanceField.Method as_ref) ].
    End Impl_core_convert_AsRef_alloy_primitives_bits_fixed_FixedBytes_Usize_20_for_alloy_primitives_bits_address_Address.
    
    Module Impl_core_ops_bit_BitAnd_alloy_primitives_bits_address_Address_for_alloy_primitives_bits_address_Address.
      Definition Self : Ty.t := Ty.path "alloy_primitives::bits::address::Address".
      
      (*             $crate::private::derive_more::BitAnd *)
      Definition _Output : Ty.t := Ty.path "alloy_primitives::bits::address::Address".
      
      (*             $crate::private::derive_more::BitAnd *)
      Definition bitand (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            Value.StructTuple
              "alloy_primitives::bits::address::Address"
              [
                M.call_closure (|
                  Ty.apply
                    (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                    [ Value.Integer IntegerKind.Usize 20 ]
                    [],
                  M.get_trait_method (|
                    "core::ops::bit::BitAnd",
                    Ty.apply
                      (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                      [ Value.Integer IntegerKind.Usize 20 ]
                      [],
                    [],
                    [
                      Ty.apply
                        (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                        [ Value.Integer IntegerKind.Usize 20 ]
                        []
                    ],
                    "bitand",
                    [],
                    []
                  |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "alloy_primitives::bits::address::Address",
                        0
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        rhs,
                        "alloy_primitives::bits::address::Address",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitAnd"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "alloy_primitives::bits::address::Address" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("bitand", InstanceField.Method bitand) ].
    End Impl_core_ops_bit_BitAnd_alloy_primitives_bits_address_Address_for_alloy_primitives_bits_address_Address.
    
    Module Impl_core_ops_bit_BitAndAssign_alloy_primitives_bits_address_Address_for_alloy_primitives_bits_address_Address.
      Definition Self : Ty.t := Ty.path "alloy_primitives::bits::address::Address".
      
      (*             $crate::private::derive_more::BitAndAssign *)
      Definition bitand_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            M.read (|
              let~ _ : Ty.tuple [] :=
                M.alloc (|
                  M.call_closure (|
                    Ty.tuple [],
                    M.get_trait_method (|
                      "core::ops::bit::BitAndAssign",
                      Ty.apply
                        (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                        [ Value.Integer IntegerKind.Usize 20 ]
                        [],
                      [],
                      [
                        Ty.apply
                          (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                          [ Value.Integer IntegerKind.Usize 20 ]
                          []
                      ],
                      "bitand_assign",
                      [],
                      []
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.MutRef,
                        M.SubPointer.get_struct_tuple_field (|
                          M.deref (| M.read (| self |) |),
                          "alloy_primitives::bits::address::Address",
                          0
                        |)
                      |);
                      M.read (|
                        M.SubPointer.get_struct_tuple_field (|
                          rhs,
                          "alloy_primitives::bits::address::Address",
                          0
                        |)
                      |)
                    ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitAndAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "alloy_primitives::bits::address::Address" ]
          Self
          (* Instance *) [ ("bitand_assign", InstanceField.Method bitand_assign) ].
    End Impl_core_ops_bit_BitAndAssign_alloy_primitives_bits_address_Address_for_alloy_primitives_bits_address_Address.
    
    Module Impl_core_ops_bit_BitOr_alloy_primitives_bits_address_Address_for_alloy_primitives_bits_address_Address.
      Definition Self : Ty.t := Ty.path "alloy_primitives::bits::address::Address".
      
      (*             $crate::private::derive_more::BitOr *)
      Definition _Output : Ty.t := Ty.path "alloy_primitives::bits::address::Address".
      
      (*             $crate::private::derive_more::BitOr *)
      Definition bitor (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            Value.StructTuple
              "alloy_primitives::bits::address::Address"
              [
                M.call_closure (|
                  Ty.apply
                    (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                    [ Value.Integer IntegerKind.Usize 20 ]
                    [],
                  M.get_trait_method (|
                    "core::ops::bit::BitOr",
                    Ty.apply
                      (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                      [ Value.Integer IntegerKind.Usize 20 ]
                      [],
                    [],
                    [
                      Ty.apply
                        (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                        [ Value.Integer IntegerKind.Usize 20 ]
                        []
                    ],
                    "bitor",
                    [],
                    []
                  |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "alloy_primitives::bits::address::Address",
                        0
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        rhs,
                        "alloy_primitives::bits::address::Address",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitOr"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "alloy_primitives::bits::address::Address" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("bitor", InstanceField.Method bitor) ].
    End Impl_core_ops_bit_BitOr_alloy_primitives_bits_address_Address_for_alloy_primitives_bits_address_Address.
    
    Module Impl_core_ops_bit_BitOrAssign_alloy_primitives_bits_address_Address_for_alloy_primitives_bits_address_Address.
      Definition Self : Ty.t := Ty.path "alloy_primitives::bits::address::Address".
      
      (*             $crate::private::derive_more::BitOrAssign *)
      Definition bitor_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            M.read (|
              let~ _ : Ty.tuple [] :=
                M.alloc (|
                  M.call_closure (|
                    Ty.tuple [],
                    M.get_trait_method (|
                      "core::ops::bit::BitOrAssign",
                      Ty.apply
                        (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                        [ Value.Integer IntegerKind.Usize 20 ]
                        [],
                      [],
                      [
                        Ty.apply
                          (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                          [ Value.Integer IntegerKind.Usize 20 ]
                          []
                      ],
                      "bitor_assign",
                      [],
                      []
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.MutRef,
                        M.SubPointer.get_struct_tuple_field (|
                          M.deref (| M.read (| self |) |),
                          "alloy_primitives::bits::address::Address",
                          0
                        |)
                      |);
                      M.read (|
                        M.SubPointer.get_struct_tuple_field (|
                          rhs,
                          "alloy_primitives::bits::address::Address",
                          0
                        |)
                      |)
                    ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitOrAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "alloy_primitives::bits::address::Address" ]
          Self
          (* Instance *) [ ("bitor_assign", InstanceField.Method bitor_assign) ].
    End Impl_core_ops_bit_BitOrAssign_alloy_primitives_bits_address_Address_for_alloy_primitives_bits_address_Address.
    
    Module Impl_core_ops_bit_BitXor_alloy_primitives_bits_address_Address_for_alloy_primitives_bits_address_Address.
      Definition Self : Ty.t := Ty.path "alloy_primitives::bits::address::Address".
      
      (*             $crate::private::derive_more::BitXor *)
      Definition _Output : Ty.t := Ty.path "alloy_primitives::bits::address::Address".
      
      (*             $crate::private::derive_more::BitXor *)
      Definition bitxor (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            Value.StructTuple
              "alloy_primitives::bits::address::Address"
              [
                M.call_closure (|
                  Ty.apply
                    (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                    [ Value.Integer IntegerKind.Usize 20 ]
                    [],
                  M.get_trait_method (|
                    "core::ops::bit::BitXor",
                    Ty.apply
                      (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                      [ Value.Integer IntegerKind.Usize 20 ]
                      [],
                    [],
                    [
                      Ty.apply
                        (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                        [ Value.Integer IntegerKind.Usize 20 ]
                        []
                    ],
                    "bitxor",
                    [],
                    []
                  |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "alloy_primitives::bits::address::Address",
                        0
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        rhs,
                        "alloy_primitives::bits::address::Address",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitXor"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "alloy_primitives::bits::address::Address" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("bitxor", InstanceField.Method bitxor) ].
    End Impl_core_ops_bit_BitXor_alloy_primitives_bits_address_Address_for_alloy_primitives_bits_address_Address.
    
    Module Impl_core_ops_bit_BitXorAssign_alloy_primitives_bits_address_Address_for_alloy_primitives_bits_address_Address.
      Definition Self : Ty.t := Ty.path "alloy_primitives::bits::address::Address".
      
      (*             $crate::private::derive_more::BitXorAssign *)
      Definition bitxor_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            M.read (|
              let~ _ : Ty.tuple [] :=
                M.alloc (|
                  M.call_closure (|
                    Ty.tuple [],
                    M.get_trait_method (|
                      "core::ops::bit::BitXorAssign",
                      Ty.apply
                        (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                        [ Value.Integer IntegerKind.Usize 20 ]
                        [],
                      [],
                      [
                        Ty.apply
                          (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                          [ Value.Integer IntegerKind.Usize 20 ]
                          []
                      ],
                      "bitxor_assign",
                      [],
                      []
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.MutRef,
                        M.SubPointer.get_struct_tuple_field (|
                          M.deref (| M.read (| self |) |),
                          "alloy_primitives::bits::address::Address",
                          0
                        |)
                      |);
                      M.read (|
                        M.SubPointer.get_struct_tuple_field (|
                          rhs,
                          "alloy_primitives::bits::address::Address",
                          0
                        |)
                      |)
                    ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitXorAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "alloy_primitives::bits::address::Address" ]
          Self
          (* Instance *) [ ("bitxor_assign", InstanceField.Method bitxor_assign) ].
    End Impl_core_ops_bit_BitXorAssign_alloy_primitives_bits_address_Address_for_alloy_primitives_bits_address_Address.
    
    Module Impl_core_ops_bit_Not_for_alloy_primitives_bits_address_Address.
      Definition Self : Ty.t := Ty.path "alloy_primitives::bits::address::Address".
      
      (*             $crate::private::derive_more::Not *)
      Definition _Output : Ty.t := Ty.path "alloy_primitives::bits::address::Address".
      
      (*             $crate::private::derive_more::Not *)
      Definition not (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructTuple
              "alloy_primitives::bits::address::Address"
              [
                M.call_closure (|
                  Ty.apply
                    (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                    [ Value.Integer IntegerKind.Usize 20 ]
                    [],
                  M.get_trait_method (|
                    "core::ops::bit::Not",
                    Ty.apply
                      (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                      [ Value.Integer IntegerKind.Usize 20 ]
                      [],
                    [],
                    [],
                    "not",
                    [],
                    []
                  |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "alloy_primitives::bits::address::Address",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Not"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("not", InstanceField.Method not) ].
    End Impl_core_ops_bit_Not_for_alloy_primitives_bits_address_Address.
    
    Module Impl_core_ops_deref_Deref_for_alloy_primitives_bits_address_Address.
      Definition Self : Ty.t := Ty.path "alloy_primitives::bits::address::Address".
      
      (*             $crate::private::derive_more::Deref *)
      Definition _Target : Ty.t :=
        Ty.apply
          (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
          [ Value.Integer IntegerKind.Usize 20 ]
          [].
      
      (*             $crate::private::derive_more::Deref *)
      Definition deref (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.borrow (|
              Pointer.Kind.Ref,
              M.deref (|
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.SubPointer.get_struct_tuple_field (|
                    M.deref (| M.read (| self |) |),
                    "alloy_primitives::bits::address::Address",
                    0
                  |)
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::deref::Deref"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *)
          [ ("Target", InstanceField.Ty _Target); ("deref", InstanceField.Method deref) ].
    End Impl_core_ops_deref_Deref_for_alloy_primitives_bits_address_Address.
    
    Module Impl_core_ops_deref_DerefMut_for_alloy_primitives_bits_address_Address.
      Definition Self : Ty.t := Ty.path "alloy_primitives::bits::address::Address".
      
      (*             $crate::private::derive_more::DerefMut *)
      Definition deref_mut (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.borrow (|
              Pointer.Kind.MutRef,
              M.deref (|
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.MutRef,
                      M.SubPointer.get_struct_tuple_field (|
                        M.deref (| M.read (| self |) |),
                        "alloy_primitives::bits::address::Address",
                        0
                      |)
                    |)
                  |)
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::deref::DerefMut"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [ ("deref_mut", InstanceField.Method deref_mut) ].
    End Impl_core_ops_deref_DerefMut_for_alloy_primitives_bits_address_Address.
    
    Module Impl_core_convert_From_alloy_primitives_bits_fixed_FixedBytes_Usize_20_for_alloy_primitives_bits_address_Address.
      Definition Self : Ty.t := Ty.path "alloy_primitives::bits::address::Address".
      
      (*             $crate::private::derive_more::From *)
      Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            Value.StructTuple "alloy_primitives::bits::address::Address" [ M.read (| value |) ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [
            Ty.apply
              (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
              [ Value.Integer IntegerKind.Usize 20 ]
              []
          ]
          Self
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_alloy_primitives_bits_fixed_FixedBytes_Usize_20_for_alloy_primitives_bits_address_Address.
    
    Module Impl_core_str_traits_FromStr_for_alloy_primitives_bits_address_Address.
      Definition Self : Ty.t := Ty.path "alloy_primitives::bits::address::Address".
      
      (*             $crate::private::derive_more::FromStr *)
      Definition _Err : Ty.t :=
        Ty.associated_in_trait
          "core::str::traits::FromStr"
          []
          []
          (Ty.apply
            (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
            [ Value.Integer IntegerKind.Usize 20 ]
            [])
          "Err".
      
      (*             $crate::private::derive_more::FromStr *)
      Definition from_str (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ src ] =>
          ltac:(M.monadic
            (let src := M.alloc (| src |) in
            M.catch_return (|
              ltac:(M.monadic
                (Value.StructTuple
                  "core::result::Result::Ok"
                  [
                    Value.StructTuple
                      "alloy_primitives::bits::address::Address"
                      [
                        M.read (|
                          M.match_operator (|
                            Some
                              (Ty.apply
                                (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                                [ Value.Integer IntegerKind.Usize 20 ]
                                []),
                            M.alloc (|
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "core::ops::control_flow::ControlFlow")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [
                                        Ty.path "core::convert::Infallible";
                                        Ty.path "const_hex::error::FromHexError"
                                      ];
                                    Ty.apply
                                      (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                                      [ Value.Integer IntegerKind.Usize 20 ]
                                      []
                                  ],
                                M.get_trait_method (|
                                  "core::ops::try_trait::Try",
                                  Ty.apply
                                    (Ty.path "core::result::Result")
                                    []
                                    [
                                      Ty.apply
                                        (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                                        [ Value.Integer IntegerKind.Usize 20 ]
                                        [];
                                      Ty.path "const_hex::error::FromHexError"
                                    ],
                                  [],
                                  [],
                                  "branch",
                                  [],
                                  []
                                |),
                                [
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [
                                        Ty.apply
                                          (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                                          [ Value.Integer IntegerKind.Usize 20 ]
                                          [];
                                        Ty.path "const_hex::error::FromHexError"
                                      ],
                                    M.get_trait_method (|
                                      "core::str::traits::FromStr",
                                      Ty.apply
                                        (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                                        [ Value.Integer IntegerKind.Usize 20 ]
                                        [],
                                      [],
                                      [],
                                      "from_str",
                                      [],
                                      []
                                    |),
                                    [
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.deref (| M.read (| src |) |)
                                      |)
                                    ]
                                  |)
                                ]
                              |)
                            |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Break",
                                      0
                                    |) in
                                  let residual := M.copy (| γ0_0 |) in
                                  M.alloc (|
                                    M.never_to_any (|
                                      M.read (|
                                        M.return_ (|
                                          M.call_closure (|
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              []
                                              [
                                                Ty.path "alloy_primitives::bits::address::Address";
                                                Ty.path "const_hex::error::FromHexError"
                                              ],
                                            M.get_trait_method (|
                                              "core::ops::try_trait::FromResidual",
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                []
                                                [
                                                  Ty.path
                                                    "alloy_primitives::bits::address::Address";
                                                  Ty.path "const_hex::error::FromHexError"
                                                ],
                                              [],
                                              [
                                                Ty.apply
                                                  (Ty.path "core::result::Result")
                                                  []
                                                  [
                                                    Ty.path "core::convert::Infallible";
                                                    Ty.path "const_hex::error::FromHexError"
                                                  ]
                                              ],
                                              "from_residual",
                                              [],
                                              []
                                            |),
                                            [ M.read (| residual |) ]
                                          |)
                                        |)
                                      |)
                                    |)
                                  |)));
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Continue",
                                      0
                                    |) in
                                  let val := M.copy (| γ0_0 |) in
                                  val))
                            ]
                          |)
                        |)
                      ]
                  ]))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::str::traits::FromStr"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *)
          [ ("Err", InstanceField.Ty _Err); ("from_str", InstanceField.Method from_str) ].
    End Impl_core_str_traits_FromStr_for_alloy_primitives_bits_address_Address.
    
    Module Impl_core_ops_index_Index_where_core_ops_index_Index_alloy_primitives_bits_fixed_FixedBytes_Usize_20___IdxT___IdxT_for_alloy_primitives_bits_address_Address.
      Definition Self (__IdxT : Ty.t) : Ty.t := Ty.path "alloy_primitives::bits::address::Address".
      
      (*             $crate::private::derive_more::Index *)
      Definition _Output (__IdxT : Ty.t) : Ty.t :=
        Ty.associated_in_trait
          "core::ops::index::Index"
          []
          [ __IdxT ]
          (Ty.apply
            (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
            [ Value.Integer IntegerKind.Usize 20 ]
            [])
          "Output".
      
      (*             $crate::private::derive_more::Index *)
      Definition index (__IdxT : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self __IdxT in
        match ε, τ, α with
        | [], [], [ self; idx ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let idx := M.alloc (| idx |) in
            M.borrow (|
              Pointer.Kind.Ref,
              M.deref (|
                M.call_closure (|
                  Ty.apply
                    (Ty.path "&")
                    []
                    [
                      Ty.associated_in_trait
                        "core::ops::index::Index"
                        []
                        [ __IdxT ]
                        (Ty.apply
                          (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                          [ Value.Integer IntegerKind.Usize 20 ]
                          [])
                        "Output"
                    ],
                  M.get_trait_method (|
                    "core::ops::index::Index",
                    Ty.apply
                      (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                      [ Value.Integer IntegerKind.Usize 20 ]
                      [],
                    [],
                    [ __IdxT ],
                    "index",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_tuple_field (|
                            M.deref (| M.read (| self |) |),
                            "alloy_primitives::bits::address::Address",
                            0
                          |)
                        |)
                      |)
                    |);
                    M.read (| idx |)
                  ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (__IdxT : Ty.t),
        M.IsTraitInstance
          "core::ops::index::Index"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ __IdxT ]
          (Self __IdxT)
          (* Instance *)
          [
            ("Output", InstanceField.Ty (_Output __IdxT));
            ("index", InstanceField.Method (index __IdxT))
          ].
    End Impl_core_ops_index_Index_where_core_ops_index_Index_alloy_primitives_bits_fixed_FixedBytes_Usize_20___IdxT___IdxT_for_alloy_primitives_bits_address_Address.
    
    Module Impl_core_ops_index_IndexMut_where_core_ops_index_IndexMut_alloy_primitives_bits_fixed_FixedBytes_Usize_20___IdxT___IdxT_for_alloy_primitives_bits_address_Address.
      Definition Self (__IdxT : Ty.t) : Ty.t := Ty.path "alloy_primitives::bits::address::Address".
      
      (*             $crate::private::derive_more::IndexMut *)
      Definition index_mut
          (__IdxT : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self __IdxT in
        match ε, τ, α with
        | [], [], [ self; idx ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let idx := M.alloc (| idx |) in
            M.borrow (|
              Pointer.Kind.MutRef,
              M.deref (|
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.deref (|
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "&mut")
                        []
                        [
                          Ty.associated_in_trait
                            "core::ops::index::Index"
                            []
                            [ __IdxT ]
                            (Ty.apply
                              (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                              [ Value.Integer IntegerKind.Usize 20 ]
                              [])
                            "Output"
                        ],
                      M.get_trait_method (|
                        "core::ops::index::IndexMut",
                        Ty.apply
                          (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                          [ Value.Integer IntegerKind.Usize 20 ]
                          [],
                        [],
                        [ __IdxT ],
                        "index_mut",
                        [],
                        []
                      |),
                      [
                        M.borrow (|
                          Pointer.Kind.MutRef,
                          M.deref (|
                            M.borrow (|
                              Pointer.Kind.MutRef,
                              M.SubPointer.get_struct_tuple_field (|
                                M.deref (| M.read (| self |) |),
                                "alloy_primitives::bits::address::Address",
                                0
                              |)
                            |)
                          |)
                        |);
                        M.read (| idx |)
                      ]
                    |)
                  |)
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (__IdxT : Ty.t),
        M.IsTraitInstance
          "core::ops::index::IndexMut"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ __IdxT ]
          (Self __IdxT)
          (* Instance *) [ ("index_mut", InstanceField.Method (index_mut __IdxT)) ].
    End Impl_core_ops_index_IndexMut_where_core_ops_index_IndexMut_alloy_primitives_bits_fixed_FixedBytes_Usize_20___IdxT___IdxT_for_alloy_primitives_bits_address_Address.
    
    Module Impl_core_convert_From_alloy_primitives_bits_address_Address_for_alloy_primitives_bits_fixed_FixedBytes_Usize_20.
      Definition Self : Ty.t :=
        Ty.apply
          (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
          [ Value.Integer IntegerKind.Usize 20 ]
          [].
      
      (*             $crate::private::derive_more::Into *)
      Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                [ Value.Integer IntegerKind.Usize 20 ]
                [],
              M.get_trait_method (|
                "core::convert::From",
                Ty.apply
                  (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                  [ Value.Integer IntegerKind.Usize 20 ]
                  [],
                [],
                [
                  Ty.apply
                    (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                    [ Value.Integer IntegerKind.Usize 20 ]
                    []
                ],
                "from",
                [],
                []
              |),
              [
                M.read (|
                  M.SubPointer.get_struct_tuple_field (|
                    value,
                    "alloy_primitives::bits::address::Address",
                    0
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "alloy_primitives::bits::address::Address" ]
          Self
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_alloy_primitives_bits_address_Address_for_alloy_primitives_bits_fixed_FixedBytes_Usize_20.
    
    Module Impl_core_iter_traits_collect_IntoIterator_where_core_iter_traits_collect_IntoIterator_alloy_primitives_bits_fixed_FixedBytes_Usize_20_for_alloy_primitives_bits_address_Address.
      Definition Self : Ty.t := Ty.path "alloy_primitives::bits::address::Address".
      
      (*             $crate::private::derive_more::IntoIterator *)
      Definition _Item : Ty.t :=
        Ty.associated_in_trait
          "core::iter::traits::collect::IntoIterator"
          []
          []
          (Ty.apply
            (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
            [ Value.Integer IntegerKind.Usize 20 ]
            [])
          "Item".
      
      (*             $crate::private::derive_more::IntoIterator *)
      Definition _IntoIter : Ty.t :=
        Ty.associated_in_trait
          "core::iter::traits::collect::IntoIterator"
          []
          []
          (Ty.apply
            (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
            [ Value.Integer IntegerKind.Usize 20 ]
            [])
          "IntoIter".
      
      (*             $crate::private::derive_more::IntoIterator *)
      Definition into_iter (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "core::array::iter::IntoIter")
                [ Value.Integer IntegerKind.Usize 20 ]
                [ Ty.path "u8" ],
              M.get_trait_method (|
                "core::iter::traits::collect::IntoIterator",
                Ty.apply
                  (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                  [ Value.Integer IntegerKind.Usize 20 ]
                  [],
                [],
                [],
                "into_iter",
                [],
                []
              |),
              [
                M.read (|
                  M.SubPointer.get_struct_tuple_field (|
                    self,
                    "alloy_primitives::bits::address::Address",
                    0
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::iter::traits::collect::IntoIterator"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *)
          [
            ("Item", InstanceField.Ty _Item);
            ("IntoIter", InstanceField.Ty _IntoIter);
            ("into_iter", InstanceField.Method into_iter)
          ].
    End Impl_core_iter_traits_collect_IntoIterator_where_core_iter_traits_collect_IntoIterator_alloy_primitives_bits_fixed_FixedBytes_Usize_20_for_alloy_primitives_bits_address_Address.
    
    Module Impl_core_iter_traits_collect_IntoIterator_where_core_iter_traits_collect_IntoIterator_ref__alloy_primitives_bits_fixed_FixedBytes_Usize_20_for_ref__alloy_primitives_bits_address_Address.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "&") [] [ Ty.path "alloy_primitives::bits::address::Address" ].
      
      (*             $crate::private::derive_more::IntoIterator *)
      Definition _Item : Ty.t :=
        Ty.associated_in_trait
          "core::iter::traits::collect::IntoIterator"
          []
          []
          (Ty.apply
            (Ty.path "&")
            []
            [
              Ty.apply
                (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                [ Value.Integer IntegerKind.Usize 20 ]
                []
            ])
          "Item".
      
      (*             $crate::private::derive_more::IntoIterator *)
      Definition _IntoIter : Ty.t :=
        Ty.associated_in_trait
          "core::iter::traits::collect::IntoIterator"
          []
          []
          (Ty.apply
            (Ty.path "&")
            []
            [
              Ty.apply
                (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                [ Value.Integer IntegerKind.Usize 20 ]
                []
            ])
          "IntoIter".
      
      (*             $crate::private::derive_more::IntoIterator *)
      Definition into_iter (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.associated_in_trait
                "core::iter::traits::collect::IntoIterator"
                []
                []
                (Ty.apply
                  (Ty.path "&")
                  []
                  [
                    Ty.apply
                      (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                      [ Value.Integer IntegerKind.Usize 20 ]
                      []
                  ])
                "IntoIter",
              M.get_trait_method (|
                "core::iter::traits::collect::IntoIterator",
                Ty.apply
                  (Ty.path "&")
                  []
                  [
                    Ty.apply
                      (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                      [ Value.Integer IntegerKind.Usize 20 ]
                      []
                  ],
                [],
                [],
                "into_iter",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_tuple_field (|
                        M.deref (| M.read (| self |) |),
                        "alloy_primitives::bits::address::Address",
                        0
                      |)
                    |)
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::iter::traits::collect::IntoIterator"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *)
          [
            ("Item", InstanceField.Ty _Item);
            ("IntoIter", InstanceField.Ty _IntoIter);
            ("into_iter", InstanceField.Method into_iter)
          ].
    End Impl_core_iter_traits_collect_IntoIterator_where_core_iter_traits_collect_IntoIterator_ref__alloy_primitives_bits_fixed_FixedBytes_Usize_20_for_ref__alloy_primitives_bits_address_Address.
    
    Module Impl_core_iter_traits_collect_IntoIterator_where_core_iter_traits_collect_IntoIterator_ref_mut_alloy_primitives_bits_fixed_FixedBytes_Usize_20_for_ref_mut_alloy_primitives_bits_address_Address.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "&mut") [] [ Ty.path "alloy_primitives::bits::address::Address" ].
      
      (*             $crate::private::derive_more::IntoIterator *)
      Definition _Item : Ty.t :=
        Ty.associated_in_trait
          "core::iter::traits::collect::IntoIterator"
          []
          []
          (Ty.apply
            (Ty.path "&mut")
            []
            [
              Ty.apply
                (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                [ Value.Integer IntegerKind.Usize 20 ]
                []
            ])
          "Item".
      
      (*             $crate::private::derive_more::IntoIterator *)
      Definition _IntoIter : Ty.t :=
        Ty.associated_in_trait
          "core::iter::traits::collect::IntoIterator"
          []
          []
          (Ty.apply
            (Ty.path "&mut")
            []
            [
              Ty.apply
                (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                [ Value.Integer IntegerKind.Usize 20 ]
                []
            ])
          "IntoIter".
      
      (*             $crate::private::derive_more::IntoIterator *)
      Definition into_iter (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.associated_in_trait
                "core::iter::traits::collect::IntoIterator"
                []
                []
                (Ty.apply
                  (Ty.path "&mut")
                  []
                  [
                    Ty.apply
                      (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                      [ Value.Integer IntegerKind.Usize 20 ]
                      []
                  ])
                "IntoIter",
              M.get_trait_method (|
                "core::iter::traits::collect::IntoIterator",
                Ty.apply
                  (Ty.path "&mut")
                  []
                  [
                    Ty.apply
                      (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                      [ Value.Integer IntegerKind.Usize 20 ]
                      []
                  ],
                [],
                [],
                "into_iter",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.MutRef,
                      M.SubPointer.get_struct_tuple_field (|
                        M.deref (| M.read (| self |) |),
                        "alloy_primitives::bits::address::Address",
                        0
                      |)
                    |)
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::iter::traits::collect::IntoIterator"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *)
          [
            ("Item", InstanceField.Ty _Item);
            ("IntoIter", InstanceField.Ty _IntoIter);
            ("into_iter", InstanceField.Method into_iter)
          ].
    End Impl_core_iter_traits_collect_IntoIterator_where_core_iter_traits_collect_IntoIterator_ref_mut_alloy_primitives_bits_fixed_FixedBytes_Usize_20_for_ref_mut_alloy_primitives_bits_address_Address.
    
    Module Impl_core_fmt_LowerHex_for_alloy_primitives_bits_address_Address.
      Definition Self : Ty.t := Ty.path "alloy_primitives::bits::address::Address".
      
      (*             $crate::private::derive_more::LowerHex *)
      Definition fmt (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; __derive_more_f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let __derive_more_f := M.alloc (| __derive_more_f |) in
            M.read (|
              let~ _0 :
                  Ty.apply
                    (Ty.path "&")
                    []
                    [
                      Ty.apply
                        (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                        [ Value.Integer IntegerKind.Usize 20 ]
                        []
                    ] :=
                M.alloc (|
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.SubPointer.get_struct_tuple_field (|
                      M.deref (| M.read (| self |) |),
                      "alloy_primitives::bits::address::Address",
                      0
                    |)
                  |)
                |) in
              M.alloc (|
                M.call_closure (|
                  Ty.apply
                    (Ty.path "core::result::Result")
                    []
                    [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                  M.get_trait_method (|
                    "core::fmt::LowerHex",
                    Ty.apply
                      (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                      [ Value.Integer IntegerKind.Usize 20 ]
                      [],
                    [],
                    [],
                    "fmt",
                    [],
                    []
                  |),
                  [
                    M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| _0 |) |) |);
                    M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| __derive_more_f |) |) |)
                  ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::LowerHex"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
    End Impl_core_fmt_LowerHex_for_alloy_primitives_bits_address_Address.
    
    Module Impl_core_fmt_UpperHex_for_alloy_primitives_bits_address_Address.
      Definition Self : Ty.t := Ty.path "alloy_primitives::bits::address::Address".
      
      (*             $crate::private::derive_more::UpperHex *)
      Definition fmt (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; __derive_more_f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let __derive_more_f := M.alloc (| __derive_more_f |) in
            M.read (|
              let~ _0 :
                  Ty.apply
                    (Ty.path "&")
                    []
                    [
                      Ty.apply
                        (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                        [ Value.Integer IntegerKind.Usize 20 ]
                        []
                    ] :=
                M.alloc (|
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.SubPointer.get_struct_tuple_field (|
                      M.deref (| M.read (| self |) |),
                      "alloy_primitives::bits::address::Address",
                      0
                    |)
                  |)
                |) in
              M.alloc (|
                M.call_closure (|
                  Ty.apply
                    (Ty.path "core::result::Result")
                    []
                    [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                  M.get_trait_method (|
                    "core::fmt::UpperHex",
                    Ty.apply
                      (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                      [ Value.Integer IntegerKind.Usize 20 ]
                      [],
                    [],
                    [],
                    "fmt",
                    [],
                    []
                  |),
                  [
                    M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| _0 |) |) |);
                    M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| __derive_more_f |) |) |)
                  ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::UpperHex"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
    End Impl_core_fmt_UpperHex_for_alloy_primitives_bits_address_Address.
    
    Module Impl_core_convert_From_array_Usize_20_u8_for_alloy_primitives_bits_address_Address.
      Definition Self : Ty.t := Ty.path "alloy_primitives::bits::address::Address".
      
      (*
                  fn from(value: [u8; $n]) -> Self {
                      Self($crate::FixedBytes(value))
                  }
      *)
      Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            Value.StructTuple
              "alloy_primitives::bits::address::Address"
              [ Value.StructTuple "alloy_primitives::bits::fixed::FixedBytes" [ M.read (| value |) ]
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 20 ] [ Ty.path "u8" ] ]
          Self
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_array_Usize_20_u8_for_alloy_primitives_bits_address_Address.
    
    Module Impl_core_convert_From_alloy_primitives_bits_address_Address_for_array_Usize_20_u8.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 20 ] [ Ty.path "u8" ].
      
      (*
                  fn from(value: $name) -> Self {
                      value.0 .0
                  }
      *)
      Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            M.read (|
              M.SubPointer.get_struct_tuple_field (|
                M.SubPointer.get_struct_tuple_field (|
                  value,
                  "alloy_primitives::bits::address::Address",
                  0
                |),
                "alloy_primitives::bits::fixed::FixedBytes",
                0
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "alloy_primitives::bits::address::Address" ]
          Self
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_alloy_primitives_bits_address_Address_for_array_Usize_20_u8.
    
    Module Impl_core_convert_From_ref__array_Usize_20_u8_for_alloy_primitives_bits_address_Address.
      Definition Self : Ty.t := Ty.path "alloy_primitives::bits::address::Address".
      
      (*
                  fn from(value: &'a [u8; $n]) -> Self {
                      Self($crate::FixedBytes( *value))
                  }
      *)
      Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            Value.StructTuple
              "alloy_primitives::bits::address::Address"
              [
                Value.StructTuple
                  "alloy_primitives::bits::fixed::FixedBytes"
                  [ M.read (| M.deref (| M.read (| value |) |) |) ]
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [
            Ty.apply
              (Ty.path "&")
              []
              [ Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 20 ] [ Ty.path "u8" ] ]
          ]
          Self
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_ref__array_Usize_20_u8_for_alloy_primitives_bits_address_Address.
    
    Module Impl_core_convert_From_ref_mut_array_Usize_20_u8_for_alloy_primitives_bits_address_Address.
      Definition Self : Ty.t := Ty.path "alloy_primitives::bits::address::Address".
      
      (*
                  fn from(value: &'a mut [u8; $n]) -> Self {
                      Self($crate::FixedBytes( *value))
                  }
      *)
      Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            Value.StructTuple
              "alloy_primitives::bits::address::Address"
              [
                Value.StructTuple
                  "alloy_primitives::bits::fixed::FixedBytes"
                  [ M.read (| M.deref (| M.read (| value |) |) |) ]
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [
            Ty.apply
              (Ty.path "&mut")
              []
              [ Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 20 ] [ Ty.path "u8" ] ]
          ]
          Self
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_ref_mut_array_Usize_20_u8_for_alloy_primitives_bits_address_Address.
    
    Module Impl_core_convert_TryFrom_ref__slice_u8_for_alloy_primitives_bits_address_Address.
      Definition Self : Ty.t := Ty.path "alloy_primitives::bits::address::Address".
      
      (*             type Error = $crate::private::core::array::TryFromSliceError; *)
      Definition _Error : Ty.t := Ty.path "core::array::TryFromSliceError".
      
      (*
                  fn try_from(slice: &[u8]) -> Result<Self, Self::Error> {
                      <&Self as $crate::private::TryFrom<&[u8]>>::try_from(slice).copied()
                  }
      *)
      Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ slice ] =>
          ltac:(M.monadic
            (let slice := M.alloc (| slice |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "core::result::Result")
                []
                [
                  Ty.path "alloy_primitives::bits::address::Address";
                  Ty.path "core::array::TryFromSliceError"
                ],
              M.get_associated_function (|
                Ty.apply
                  (Ty.path "core::result::Result")
                  []
                  [
                    Ty.apply
                      (Ty.path "&")
                      []
                      [ Ty.path "alloy_primitives::bits::address::Address" ];
                    Ty.path "core::array::TryFromSliceError"
                  ],
                "copied",
                [],
                []
              |),
              [
                M.call_closure (|
                  Ty.apply
                    (Ty.path "core::result::Result")
                    []
                    [
                      Ty.apply
                        (Ty.path "&")
                        []
                        [ Ty.path "alloy_primitives::bits::address::Address" ];
                      Ty.path "core::array::TryFromSliceError"
                    ],
                  M.get_trait_method (|
                    "core::convert::TryFrom",
                    Ty.apply
                      (Ty.path "&")
                      []
                      [ Ty.path "alloy_primitives::bits::address::Address" ],
                    [],
                    [ Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
                    ],
                    "try_from",
                    [],
                    []
                  |),
                  [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| slice |) |) |) ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::TryFrom"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ] ]
          Self
          (* Instance *)
          [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
    End Impl_core_convert_TryFrom_ref__slice_u8_for_alloy_primitives_bits_address_Address.
    
    Module Impl_core_convert_TryFrom_ref_mut_slice_u8_for_alloy_primitives_bits_address_Address.
      Definition Self : Ty.t := Ty.path "alloy_primitives::bits::address::Address".
      
      (*             type Error = $crate::private::core::array::TryFromSliceError; *)
      Definition _Error : Ty.t := Ty.path "core::array::TryFromSliceError".
      
      (*
                  fn try_from(slice: &mut [u8]) -> Result<Self, Self::Error> {
                      <Self as $crate::private::TryFrom<&[u8]>>::try_from(&*slice)
                  }
      *)
      Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ slice ] =>
          ltac:(M.monadic
            (let slice := M.alloc (| slice |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "core::result::Result")
                []
                [
                  Ty.path "alloy_primitives::bits::address::Address";
                  Ty.path "core::array::TryFromSliceError"
                ],
              M.get_trait_method (|
                "core::convert::TryFrom",
                Ty.path "alloy_primitives::bits::address::Address",
                [],
                [ Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ] ],
                "try_from",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (| M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| slice |) |) |) |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::TryFrom"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ] ]
          Self
          (* Instance *)
          [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
    End Impl_core_convert_TryFrom_ref_mut_slice_u8_for_alloy_primitives_bits_address_Address.
    
    Module Impl_core_convert_TryFrom_ref__slice_u8_for_ref__alloy_primitives_bits_address_Address.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "&") [] [ Ty.path "alloy_primitives::bits::address::Address" ].
      
      (*             type Error = $crate::private::core::array::TryFromSliceError; *)
      Definition _Error : Ty.t := Ty.path "core::array::TryFromSliceError".
      
      (*
                  fn try_from(slice: &'a [u8]) -> Result<&'a $name, Self::Error> {
                      // SAFETY: `$name` is `repr(transparent)` for `FixedBytes<$n>`
                      // and consequently `[u8; $n]`
                      <&[u8; $n] as $crate::private::TryFrom<&[u8]>>::try_from(slice)
                          .map(|array_ref| unsafe { $crate::private::core::mem::transmute(array_ref) })
                  }
      *)
      Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ slice ] =>
          ltac:(M.monadic
            (let slice := M.alloc (| slice |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "core::result::Result")
                []
                [
                  Ty.apply (Ty.path "&") [] [ Ty.path "alloy_primitives::bits::address::Address" ];
                  Ty.path "core::array::TryFromSliceError"
                ],
              M.get_associated_function (|
                Ty.apply
                  (Ty.path "core::result::Result")
                  []
                  [
                    Ty.apply
                      (Ty.path "&")
                      []
                      [
                        Ty.apply
                          (Ty.path "array")
                          [ Value.Integer IntegerKind.Usize 20 ]
                          [ Ty.path "u8" ]
                      ];
                    Ty.path "core::array::TryFromSliceError"
                  ],
                "map",
                [],
                [
                  Ty.apply (Ty.path "&") [] [ Ty.path "alloy_primitives::bits::address::Address" ];
                  Ty.function
                    [
                      Ty.tuple
                        [
                          Ty.apply
                            (Ty.path "&")
                            []
                            [
                              Ty.apply
                                (Ty.path "array")
                                [ Value.Integer IntegerKind.Usize 20 ]
                                [ Ty.path "u8" ]
                            ]
                        ]
                    ]
                    (Ty.apply
                      (Ty.path "&")
                      []
                      [ Ty.path "alloy_primitives::bits::address::Address" ])
                ]
              |),
              [
                M.call_closure (|
                  Ty.apply
                    (Ty.path "core::result::Result")
                    []
                    [
                      Ty.apply
                        (Ty.path "&")
                        []
                        [
                          Ty.apply
                            (Ty.path "array")
                            [ Value.Integer IntegerKind.Usize 20 ]
                            [ Ty.path "u8" ]
                        ];
                      Ty.path "core::array::TryFromSliceError"
                    ],
                  M.get_trait_method (|
                    "core::convert::TryFrom",
                    Ty.apply
                      (Ty.path "&")
                      []
                      [
                        Ty.apply
                          (Ty.path "array")
                          [ Value.Integer IntegerKind.Usize 20 ]
                          [ Ty.path "u8" ]
                      ],
                    [],
                    [ Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
                    ],
                    "try_from",
                    [],
                    []
                  |),
                  [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| slice |) |) |) ]
                |);
                M.closure
                  (fun γ =>
                    ltac:(M.monadic
                      match γ with
                      | [ α0 ] =>
                        ltac:(M.monadic
                          (M.match_operator (|
                            Some
                              (Ty.function
                                [
                                  Ty.tuple
                                    [
                                      Ty.apply
                                        (Ty.path "&")
                                        []
                                        [
                                          Ty.apply
                                            (Ty.path "array")
                                            [ Value.Integer IntegerKind.Usize 20 ]
                                            [ Ty.path "u8" ]
                                        ]
                                    ]
                                ]
                                (Ty.apply
                                  (Ty.path "&")
                                  []
                                  [ Ty.path "alloy_primitives::bits::address::Address" ])),
                            M.alloc (| α0 |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let array_ref := M.copy (| γ |) in
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "&")
                                      []
                                      [ Ty.path "alloy_primitives::bits::address::Address" ],
                                    M.get_function (|
                                      "core::intrinsics::transmute",
                                      [],
                                      [
                                        Ty.apply
                                          (Ty.path "&")
                                          []
                                          [
                                            Ty.apply
                                              (Ty.path "array")
                                              [ Value.Integer IntegerKind.Usize 20 ]
                                              [ Ty.path "u8" ]
                                          ];
                                        Ty.apply
                                          (Ty.path "&")
                                          []
                                          [ Ty.path "alloy_primitives::bits::address::Address" ]
                                      ]
                                    |),
                                    [ M.read (| array_ref |) ]
                                  |)))
                            ]
                          |)))
                      | _ => M.impossible "wrong number of arguments"
                      end))
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::TryFrom"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ] ]
          Self
          (* Instance *)
          [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
    End Impl_core_convert_TryFrom_ref__slice_u8_for_ref__alloy_primitives_bits_address_Address.
    
    Module Impl_core_convert_TryFrom_ref_mut_slice_u8_for_ref_mut_alloy_primitives_bits_address_Address.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "&mut") [] [ Ty.path "alloy_primitives::bits::address::Address" ].
      
      (*             type Error = $crate::private::core::array::TryFromSliceError; *)
      Definition _Error : Ty.t := Ty.path "core::array::TryFromSliceError".
      
      (*
                  fn try_from(slice: &'a mut [u8]) -> Result<&'a mut $name, Self::Error> {
                      // SAFETY: `$name` is `repr(transparent)` for `FixedBytes<$n>`
                      // and consequently `[u8; $n]`
                      <&mut [u8; $n] as $crate::private::TryFrom<&mut [u8]>>::try_from(slice)
                          .map(|array_ref| unsafe { $crate::private::core::mem::transmute(array_ref) })
                  }
      *)
      Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ slice ] =>
          ltac:(M.monadic
            (let slice := M.alloc (| slice |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "core::result::Result")
                []
                [
                  Ty.apply
                    (Ty.path "&mut")
                    []
                    [ Ty.path "alloy_primitives::bits::address::Address" ];
                  Ty.path "core::array::TryFromSliceError"
                ],
              M.get_associated_function (|
                Ty.apply
                  (Ty.path "core::result::Result")
                  []
                  [
                    Ty.apply
                      (Ty.path "&mut")
                      []
                      [
                        Ty.apply
                          (Ty.path "array")
                          [ Value.Integer IntegerKind.Usize 20 ]
                          [ Ty.path "u8" ]
                      ];
                    Ty.path "core::array::TryFromSliceError"
                  ],
                "map",
                [],
                [
                  Ty.apply
                    (Ty.path "&mut")
                    []
                    [ Ty.path "alloy_primitives::bits::address::Address" ];
                  Ty.function
                    [
                      Ty.tuple
                        [
                          Ty.apply
                            (Ty.path "&mut")
                            []
                            [
                              Ty.apply
                                (Ty.path "array")
                                [ Value.Integer IntegerKind.Usize 20 ]
                                [ Ty.path "u8" ]
                            ]
                        ]
                    ]
                    (Ty.apply
                      (Ty.path "&mut")
                      []
                      [ Ty.path "alloy_primitives::bits::address::Address" ])
                ]
              |),
              [
                M.call_closure (|
                  Ty.apply
                    (Ty.path "core::result::Result")
                    []
                    [
                      Ty.apply
                        (Ty.path "&mut")
                        []
                        [
                          Ty.apply
                            (Ty.path "array")
                            [ Value.Integer IntegerKind.Usize 20 ]
                            [ Ty.path "u8" ]
                        ];
                      Ty.path "core::array::TryFromSliceError"
                    ],
                  M.get_trait_method (|
                    "core::convert::TryFrom",
                    Ty.apply
                      (Ty.path "&mut")
                      []
                      [
                        Ty.apply
                          (Ty.path "array")
                          [ Value.Integer IntegerKind.Usize 20 ]
                          [ Ty.path "u8" ]
                      ],
                    [],
                    [
                      Ty.apply
                        (Ty.path "&mut")
                        []
                        [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
                    ],
                    "try_from",
                    [],
                    []
                  |),
                  [ M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| slice |) |) |) ]
                |);
                M.closure
                  (fun γ =>
                    ltac:(M.monadic
                      match γ with
                      | [ α0 ] =>
                        ltac:(M.monadic
                          (M.match_operator (|
                            Some
                              (Ty.function
                                [
                                  Ty.tuple
                                    [
                                      Ty.apply
                                        (Ty.path "&mut")
                                        []
                                        [
                                          Ty.apply
                                            (Ty.path "array")
                                            [ Value.Integer IntegerKind.Usize 20 ]
                                            [ Ty.path "u8" ]
                                        ]
                                    ]
                                ]
                                (Ty.apply
                                  (Ty.path "&mut")
                                  []
                                  [ Ty.path "alloy_primitives::bits::address::Address" ])),
                            M.alloc (| α0 |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let array_ref := M.copy (| γ |) in
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "&mut")
                                      []
                                      [ Ty.path "alloy_primitives::bits::address::Address" ],
                                    M.get_function (|
                                      "core::intrinsics::transmute",
                                      [],
                                      [
                                        Ty.apply
                                          (Ty.path "&mut")
                                          []
                                          [
                                            Ty.apply
                                              (Ty.path "array")
                                              [ Value.Integer IntegerKind.Usize 20 ]
                                              [ Ty.path "u8" ]
                                          ];
                                        Ty.apply
                                          (Ty.path "&mut")
                                          []
                                          [ Ty.path "alloy_primitives::bits::address::Address" ]
                                      ]
                                    |),
                                    [ M.read (| array_ref |) ]
                                  |)))
                            ]
                          |)))
                      | _ => M.impossible "wrong number of arguments"
                      end))
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::TryFrom"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ] ]
          Self
          (* Instance *)
          [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
    End Impl_core_convert_TryFrom_ref_mut_slice_u8_for_ref_mut_alloy_primitives_bits_address_Address.
    
    Module Impl_core_convert_AsRef_array_Usize_20_u8_for_alloy_primitives_bits_address_Address.
      Definition Self : Ty.t := Ty.path "alloy_primitives::bits::address::Address".
      
      (*
                  fn as_ref(&self) -> &[u8; $n] {
                      &self.0 .0
                  }
      *)
      Definition as_ref (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.borrow (|
              Pointer.Kind.Ref,
              M.deref (|
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.SubPointer.get_struct_tuple_field (|
                    M.SubPointer.get_struct_tuple_field (|
                      M.deref (| M.read (| self |) |),
                      "alloy_primitives::bits::address::Address",
                      0
                    |),
                    "alloy_primitives::bits::fixed::FixedBytes",
                    0
                  |)
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::AsRef"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 20 ] [ Ty.path "u8" ] ]
          Self
          (* Instance *) [ ("as_ref", InstanceField.Method as_ref) ].
    End Impl_core_convert_AsRef_array_Usize_20_u8_for_alloy_primitives_bits_address_Address.
    
    Module Impl_core_convert_AsMut_array_Usize_20_u8_for_alloy_primitives_bits_address_Address.
      Definition Self : Ty.t := Ty.path "alloy_primitives::bits::address::Address".
      
      (*
                  fn as_mut(&mut self) -> &mut [u8; $n] {
                      &mut self.0 .0
                  }
      *)
      Definition as_mut (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.borrow (|
              Pointer.Kind.MutRef,
              M.deref (|
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.MutRef,
                      M.SubPointer.get_struct_tuple_field (|
                        M.SubPointer.get_struct_tuple_field (|
                          M.deref (| M.read (| self |) |),
                          "alloy_primitives::bits::address::Address",
                          0
                        |),
                        "alloy_primitives::bits::fixed::FixedBytes",
                        0
                      |)
                    |)
                  |)
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::AsMut"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 20 ] [ Ty.path "u8" ] ]
          Self
          (* Instance *) [ ("as_mut", InstanceField.Method as_mut) ].
    End Impl_core_convert_AsMut_array_Usize_20_u8_for_alloy_primitives_bits_address_Address.
    
    Module Impl_core_convert_AsRef_slice_u8_for_alloy_primitives_bits_address_Address.
      Definition Self : Ty.t := Ty.path "alloy_primitives::bits::address::Address".
      
      (*
                  fn as_ref(&self) -> &[u8] {
                      &self.0 .0
                  }
      *)
      Definition as_ref (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            (* Unsize *)
            M.pointer_coercion
              (M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.SubPointer.get_struct_tuple_field (|
                      M.SubPointer.get_struct_tuple_field (|
                        M.deref (| M.read (| self |) |),
                        "alloy_primitives::bits::address::Address",
                        0
                      |),
                      "alloy_primitives::bits::fixed::FixedBytes",
                      0
                    |)
                  |)
                |)
              |))))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::AsRef"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
          Self
          (* Instance *) [ ("as_ref", InstanceField.Method as_ref) ].
    End Impl_core_convert_AsRef_slice_u8_for_alloy_primitives_bits_address_Address.
    
    Module Impl_core_convert_AsMut_slice_u8_for_alloy_primitives_bits_address_Address.
      Definition Self : Ty.t := Ty.path "alloy_primitives::bits::address::Address".
      
      (*
                  fn as_mut(&mut self) -> &mut [u8] {
                      &mut self.0 .0
                  }
      *)
      Definition as_mut (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.borrow (|
              Pointer.Kind.MutRef,
              M.deref (|
                (* Unsize *)
                M.pointer_coercion
                  (M.borrow (|
                    Pointer.Kind.MutRef,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.MutRef,
                        M.SubPointer.get_struct_tuple_field (|
                          M.SubPointer.get_struct_tuple_field (|
                            M.deref (| M.read (| self |) |),
                            "alloy_primitives::bits::address::Address",
                            0
                          |),
                          "alloy_primitives::bits::fixed::FixedBytes",
                          0
                        |)
                      |)
                    |)
                  |))
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::AsMut"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
          Self
          (* Instance *) [ ("as_mut", InstanceField.Method as_mut) ].
    End Impl_core_convert_AsMut_slice_u8_for_alloy_primitives_bits_address_Address.
    
    Module Impl_core_fmt_Debug_for_alloy_primitives_bits_address_Address.
      Definition Self : Ty.t := Ty.path "alloy_primitives::bits::address::Address".
      
      (*
                  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                      $crate::private::core::fmt::Debug::fmt(&self.0, f)
                  }
      *)
      Definition fmt (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "core::result::Result")
                []
                [ Ty.tuple []; Ty.path "core::fmt::Error" ],
              M.get_trait_method (|
                "core::fmt::Debug",
                Ty.apply
                  (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                  [ Value.Integer IntegerKind.Usize 20 ]
                  [],
                [],
                [],
                "fmt",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_tuple_field (|
                        M.deref (| M.read (| self |) |),
                        "alloy_primitives::bits::address::Address",
                        0
                      |)
                    |)
                  |)
                |);
                M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::Debug"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
    End Impl_core_fmt_Debug_for_alloy_primitives_bits_address_Address.
    
    Module Impl_core_borrow_Borrow_slice_u8_for_alloy_primitives_bits_address_Address.
      Definition Self : Ty.t := Ty.path "alloy_primitives::bits::address::Address".
      
      (*
                  fn borrow(&self) -> &$t {
                      $crate::private::Borrow::borrow(&self.0)
                  }
      *)
      Definition borrow (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.borrow (|
              Pointer.Kind.Ref,
              M.deref (|
                M.call_closure (|
                  Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                  M.get_trait_method (|
                    "core::borrow::Borrow",
                    Ty.apply
                      (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                      [ Value.Integer IntegerKind.Usize 20 ]
                      [],
                    [],
                    [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                    "borrow",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_tuple_field (|
                            M.deref (| M.read (| self |) |),
                            "alloy_primitives::bits::address::Address",
                            0
                          |)
                        |)
                      |)
                    |)
                  ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::borrow::Borrow"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
          Self
          (* Instance *) [ ("borrow", InstanceField.Method borrow) ].
    End Impl_core_borrow_Borrow_slice_u8_for_alloy_primitives_bits_address_Address.
    
    Module Impl_core_borrow_Borrow_slice_u8_for_ref__alloy_primitives_bits_address_Address.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "&") [] [ Ty.path "alloy_primitives::bits::address::Address" ].
      
      (*
                  fn borrow(&self) -> &$t {
                      $crate::private::Borrow::borrow(&self.0)
                  }
      *)
      Definition borrow (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.borrow (|
              Pointer.Kind.Ref,
              M.deref (|
                M.call_closure (|
                  Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                  M.get_trait_method (|
                    "core::borrow::Borrow",
                    Ty.apply
                      (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                      [ Value.Integer IntegerKind.Usize 20 ]
                      [],
                    [],
                    [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                    "borrow",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_tuple_field (|
                            M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |),
                            "alloy_primitives::bits::address::Address",
                            0
                          |)
                        |)
                      |)
                    |)
                  ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::borrow::Borrow"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
          Self
          (* Instance *) [ ("borrow", InstanceField.Method borrow) ].
    End Impl_core_borrow_Borrow_slice_u8_for_ref__alloy_primitives_bits_address_Address.
    
    Module Impl_core_borrow_Borrow_slice_u8_for_ref_mut_alloy_primitives_bits_address_Address.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "&mut") [] [ Ty.path "alloy_primitives::bits::address::Address" ].
      
      (*
                  fn borrow(&self) -> &$t {
                      $crate::private::Borrow::borrow(&self.0)
                  }
      *)
      Definition borrow (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.borrow (|
              Pointer.Kind.Ref,
              M.deref (|
                M.call_closure (|
                  Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                  M.get_trait_method (|
                    "core::borrow::Borrow",
                    Ty.apply
                      (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                      [ Value.Integer IntegerKind.Usize 20 ]
                      [],
                    [],
                    [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                    "borrow",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_tuple_field (|
                            M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |),
                            "alloy_primitives::bits::address::Address",
                            0
                          |)
                        |)
                      |)
                    |)
                  ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::borrow::Borrow"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
          Self
          (* Instance *) [ ("borrow", InstanceField.Method borrow) ].
    End Impl_core_borrow_Borrow_slice_u8_for_ref_mut_alloy_primitives_bits_address_Address.
    
    Module Impl_core_borrow_Borrow_array_Usize_20_u8_for_alloy_primitives_bits_address_Address.
      Definition Self : Ty.t := Ty.path "alloy_primitives::bits::address::Address".
      
      (*
                  fn borrow(&self) -> &$t {
                      $crate::private::Borrow::borrow(&self.0)
                  }
      *)
      Definition borrow (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.borrow (|
              Pointer.Kind.Ref,
              M.deref (|
                M.call_closure (|
                  Ty.apply
                    (Ty.path "&")
                    []
                    [
                      Ty.apply
                        (Ty.path "array")
                        [ Value.Integer IntegerKind.Usize 20 ]
                        [ Ty.path "u8" ]
                    ],
                  M.get_trait_method (|
                    "core::borrow::Borrow",
                    Ty.apply
                      (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                      [ Value.Integer IntegerKind.Usize 20 ]
                      [],
                    [],
                    [
                      Ty.apply
                        (Ty.path "array")
                        [ Value.Integer IntegerKind.Usize 20 ]
                        [ Ty.path "u8" ]
                    ],
                    "borrow",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_tuple_field (|
                            M.deref (| M.read (| self |) |),
                            "alloy_primitives::bits::address::Address",
                            0
                          |)
                        |)
                      |)
                    |)
                  ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::borrow::Borrow"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 20 ] [ Ty.path "u8" ] ]
          Self
          (* Instance *) [ ("borrow", InstanceField.Method borrow) ].
    End Impl_core_borrow_Borrow_array_Usize_20_u8_for_alloy_primitives_bits_address_Address.
    
    Module Impl_core_borrow_Borrow_array_Usize_20_u8_for_ref__alloy_primitives_bits_address_Address.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "&") [] [ Ty.path "alloy_primitives::bits::address::Address" ].
      
      (*
                  fn borrow(&self) -> &$t {
                      $crate::private::Borrow::borrow(&self.0)
                  }
      *)
      Definition borrow (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.borrow (|
              Pointer.Kind.Ref,
              M.deref (|
                M.call_closure (|
                  Ty.apply
                    (Ty.path "&")
                    []
                    [
                      Ty.apply
                        (Ty.path "array")
                        [ Value.Integer IntegerKind.Usize 20 ]
                        [ Ty.path "u8" ]
                    ],
                  M.get_trait_method (|
                    "core::borrow::Borrow",
                    Ty.apply
                      (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                      [ Value.Integer IntegerKind.Usize 20 ]
                      [],
                    [],
                    [
                      Ty.apply
                        (Ty.path "array")
                        [ Value.Integer IntegerKind.Usize 20 ]
                        [ Ty.path "u8" ]
                    ],
                    "borrow",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_tuple_field (|
                            M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |),
                            "alloy_primitives::bits::address::Address",
                            0
                          |)
                        |)
                      |)
                    |)
                  ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::borrow::Borrow"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 20 ] [ Ty.path "u8" ] ]
          Self
          (* Instance *) [ ("borrow", InstanceField.Method borrow) ].
    End Impl_core_borrow_Borrow_array_Usize_20_u8_for_ref__alloy_primitives_bits_address_Address.
    
    Module Impl_core_borrow_Borrow_array_Usize_20_u8_for_ref_mut_alloy_primitives_bits_address_Address.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "&mut") [] [ Ty.path "alloy_primitives::bits::address::Address" ].
      
      (*
                  fn borrow(&self) -> &$t {
                      $crate::private::Borrow::borrow(&self.0)
                  }
      *)
      Definition borrow (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.borrow (|
              Pointer.Kind.Ref,
              M.deref (|
                M.call_closure (|
                  Ty.apply
                    (Ty.path "&")
                    []
                    [
                      Ty.apply
                        (Ty.path "array")
                        [ Value.Integer IntegerKind.Usize 20 ]
                        [ Ty.path "u8" ]
                    ],
                  M.get_trait_method (|
                    "core::borrow::Borrow",
                    Ty.apply
                      (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                      [ Value.Integer IntegerKind.Usize 20 ]
                      [],
                    [],
                    [
                      Ty.apply
                        (Ty.path "array")
                        [ Value.Integer IntegerKind.Usize 20 ]
                        [ Ty.path "u8" ]
                    ],
                    "borrow",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_tuple_field (|
                            M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |),
                            "alloy_primitives::bits::address::Address",
                            0
                          |)
                        |)
                      |)
                    |)
                  ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::borrow::Borrow"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 20 ] [ Ty.path "u8" ] ]
          Self
          (* Instance *) [ ("borrow", InstanceField.Method borrow) ].
    End Impl_core_borrow_Borrow_array_Usize_20_u8_for_ref_mut_alloy_primitives_bits_address_Address.
    
    Module Impl_core_borrow_BorrowMut_slice_u8_for_alloy_primitives_bits_address_Address.
      Definition Self : Ty.t := Ty.path "alloy_primitives::bits::address::Address".
      
      (*
                  fn borrow_mut(&mut self) -> &mut $t {
                      $crate::private::BorrowMut::borrow_mut(&mut self.0)
                  }
      *)
      Definition borrow_mut (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.borrow (|
              Pointer.Kind.MutRef,
              M.deref (|
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.deref (|
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "&mut")
                        []
                        [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                      M.get_trait_method (|
                        "core::borrow::BorrowMut",
                        Ty.apply
                          (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                          [ Value.Integer IntegerKind.Usize 20 ]
                          [],
                        [],
                        [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                        "borrow_mut",
                        [],
                        []
                      |),
                      [
                        M.borrow (|
                          Pointer.Kind.MutRef,
                          M.deref (|
                            M.borrow (|
                              Pointer.Kind.MutRef,
                              M.SubPointer.get_struct_tuple_field (|
                                M.deref (| M.read (| self |) |),
                                "alloy_primitives::bits::address::Address",
                                0
                              |)
                            |)
                          |)
                        |)
                      ]
                    |)
                  |)
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::borrow::BorrowMut"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
          Self
          (* Instance *) [ ("borrow_mut", InstanceField.Method borrow_mut) ].
    End Impl_core_borrow_BorrowMut_slice_u8_for_alloy_primitives_bits_address_Address.
    
    Module Impl_core_borrow_BorrowMut_slice_u8_for_ref_mut_alloy_primitives_bits_address_Address.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "&mut") [] [ Ty.path "alloy_primitives::bits::address::Address" ].
      
      (*
                  fn borrow_mut(&mut self) -> &mut $t {
                      $crate::private::BorrowMut::borrow_mut(&mut self.0)
                  }
      *)
      Definition borrow_mut (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.borrow (|
              Pointer.Kind.MutRef,
              M.deref (|
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.deref (|
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "&mut")
                        []
                        [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                      M.get_trait_method (|
                        "core::borrow::BorrowMut",
                        Ty.apply
                          (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                          [ Value.Integer IntegerKind.Usize 20 ]
                          [],
                        [],
                        [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                        "borrow_mut",
                        [],
                        []
                      |),
                      [
                        M.borrow (|
                          Pointer.Kind.MutRef,
                          M.deref (|
                            M.borrow (|
                              Pointer.Kind.MutRef,
                              M.SubPointer.get_struct_tuple_field (|
                                M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |),
                                "alloy_primitives::bits::address::Address",
                                0
                              |)
                            |)
                          |)
                        |)
                      ]
                    |)
                  |)
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::borrow::BorrowMut"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
          Self
          (* Instance *) [ ("borrow_mut", InstanceField.Method borrow_mut) ].
    End Impl_core_borrow_BorrowMut_slice_u8_for_ref_mut_alloy_primitives_bits_address_Address.
    
    Module Impl_core_borrow_BorrowMut_array_Usize_20_u8_for_alloy_primitives_bits_address_Address.
      Definition Self : Ty.t := Ty.path "alloy_primitives::bits::address::Address".
      
      (*
                  fn borrow_mut(&mut self) -> &mut $t {
                      $crate::private::BorrowMut::borrow_mut(&mut self.0)
                  }
      *)
      Definition borrow_mut (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.borrow (|
              Pointer.Kind.MutRef,
              M.deref (|
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.deref (|
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "&mut")
                        []
                        [
                          Ty.apply
                            (Ty.path "array")
                            [ Value.Integer IntegerKind.Usize 20 ]
                            [ Ty.path "u8" ]
                        ],
                      M.get_trait_method (|
                        "core::borrow::BorrowMut",
                        Ty.apply
                          (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                          [ Value.Integer IntegerKind.Usize 20 ]
                          [],
                        [],
                        [
                          Ty.apply
                            (Ty.path "array")
                            [ Value.Integer IntegerKind.Usize 20 ]
                            [ Ty.path "u8" ]
                        ],
                        "borrow_mut",
                        [],
                        []
                      |),
                      [
                        M.borrow (|
                          Pointer.Kind.MutRef,
                          M.deref (|
                            M.borrow (|
                              Pointer.Kind.MutRef,
                              M.SubPointer.get_struct_tuple_field (|
                                M.deref (| M.read (| self |) |),
                                "alloy_primitives::bits::address::Address",
                                0
                              |)
                            |)
                          |)
                        |)
                      ]
                    |)
                  |)
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::borrow::BorrowMut"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 20 ] [ Ty.path "u8" ] ]
          Self
          (* Instance *) [ ("borrow_mut", InstanceField.Method borrow_mut) ].
    End Impl_core_borrow_BorrowMut_array_Usize_20_u8_for_alloy_primitives_bits_address_Address.
    
    Module Impl_core_borrow_BorrowMut_array_Usize_20_u8_for_ref_mut_alloy_primitives_bits_address_Address.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "&mut") [] [ Ty.path "alloy_primitives::bits::address::Address" ].
      
      (*
                  fn borrow_mut(&mut self) -> &mut $t {
                      $crate::private::BorrowMut::borrow_mut(&mut self.0)
                  }
      *)
      Definition borrow_mut (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.borrow (|
              Pointer.Kind.MutRef,
              M.deref (|
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.deref (|
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "&mut")
                        []
                        [
                          Ty.apply
                            (Ty.path "array")
                            [ Value.Integer IntegerKind.Usize 20 ]
                            [ Ty.path "u8" ]
                        ],
                      M.get_trait_method (|
                        "core::borrow::BorrowMut",
                        Ty.apply
                          (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                          [ Value.Integer IntegerKind.Usize 20 ]
                          [],
                        [],
                        [
                          Ty.apply
                            (Ty.path "array")
                            [ Value.Integer IntegerKind.Usize 20 ]
                            [ Ty.path "u8" ]
                        ],
                        "borrow_mut",
                        [],
                        []
                      |),
                      [
                        M.borrow (|
                          Pointer.Kind.MutRef,
                          M.deref (|
                            M.borrow (|
                              Pointer.Kind.MutRef,
                              M.SubPointer.get_struct_tuple_field (|
                                M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |),
                                "alloy_primitives::bits::address::Address",
                                0
                              |)
                            |)
                          |)
                        |)
                      ]
                    |)
                  |)
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::borrow::BorrowMut"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 20 ] [ Ty.path "u8" ] ]
          Self
          (* Instance *) [ ("borrow_mut", InstanceField.Method borrow_mut) ].
    End Impl_core_borrow_BorrowMut_array_Usize_20_u8_for_ref_mut_alloy_primitives_bits_address_Address.
    
    Module Impl_core_convert_From_ref__array_Usize_20_u8_for_ref__alloy_primitives_bits_address_Address.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "&") [] [ Ty.path "alloy_primitives::bits::address::Address" ].
      
      (*
                  fn from(value: $a) -> $b {
                      // SAFETY: guaranteed by caller
                      unsafe { $crate::private::core::mem::transmute::<$a, $b>(value) }
                  }
      *)
      Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            M.call_closure (|
              Ty.apply (Ty.path "&") [] [ Ty.path "alloy_primitives::bits::address::Address" ],
              M.get_function (|
                "core::intrinsics::transmute",
                [],
                [
                  Ty.apply
                    (Ty.path "&")
                    []
                    [
                      Ty.apply
                        (Ty.path "array")
                        [ Value.Integer IntegerKind.Usize 20 ]
                        [ Ty.path "u8" ]
                    ];
                  Ty.apply (Ty.path "&") [] [ Ty.path "alloy_primitives::bits::address::Address" ]
                ]
              |),
              [ M.read (| value |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [
            Ty.apply
              (Ty.path "&")
              []
              [ Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 20 ] [ Ty.path "u8" ] ]
          ]
          Self
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_ref__array_Usize_20_u8_for_ref__alloy_primitives_bits_address_Address.
    
    Module Impl_core_convert_From_ref_mut_array_Usize_20_u8_for_ref__alloy_primitives_bits_address_Address.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "&") [] [ Ty.path "alloy_primitives::bits::address::Address" ].
      
      (*
                  fn from(value: $a) -> $b {
                      // SAFETY: guaranteed by caller
                      unsafe { $crate::private::core::mem::transmute::<$a, $b>(value) }
                  }
      *)
      Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            M.call_closure (|
              Ty.apply (Ty.path "&") [] [ Ty.path "alloy_primitives::bits::address::Address" ],
              M.get_function (|
                "core::intrinsics::transmute",
                [],
                [
                  Ty.apply
                    (Ty.path "&mut")
                    []
                    [
                      Ty.apply
                        (Ty.path "array")
                        [ Value.Integer IntegerKind.Usize 20 ]
                        [ Ty.path "u8" ]
                    ];
                  Ty.apply (Ty.path "&") [] [ Ty.path "alloy_primitives::bits::address::Address" ]
                ]
              |),
              [ M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| value |) |) |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [
            Ty.apply
              (Ty.path "&mut")
              []
              [ Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 20 ] [ Ty.path "u8" ] ]
          ]
          Self
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_ref_mut_array_Usize_20_u8_for_ref__alloy_primitives_bits_address_Address.
    
    Module Impl_core_convert_From_ref_mut_array_Usize_20_u8_for_ref_mut_alloy_primitives_bits_address_Address.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "&mut") [] [ Ty.path "alloy_primitives::bits::address::Address" ].
      
      (*
                  fn from(value: $a) -> $b {
                      // SAFETY: guaranteed by caller
                      unsafe { $crate::private::core::mem::transmute::<$a, $b>(value) }
                  }
      *)
      Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            M.borrow (|
              Pointer.Kind.MutRef,
              M.deref (|
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.MutRef,
                      M.deref (|
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "&mut")
                            []
                            [ Ty.path "alloy_primitives::bits::address::Address" ],
                          M.get_function (|
                            "core::intrinsics::transmute",
                            [],
                            [
                              Ty.apply
                                (Ty.path "&mut")
                                []
                                [
                                  Ty.apply
                                    (Ty.path "array")
                                    [ Value.Integer IntegerKind.Usize 20 ]
                                    [ Ty.path "u8" ]
                                ];
                              Ty.apply
                                (Ty.path "&mut")
                                []
                                [ Ty.path "alloy_primitives::bits::address::Address" ]
                            ]
                          |),
                          [ M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| value |) |) |) ]
                        |)
                      |)
                    |)
                  |)
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [
            Ty.apply
              (Ty.path "&mut")
              []
              [ Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 20 ] [ Ty.path "u8" ] ]
          ]
          Self
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_ref_mut_array_Usize_20_u8_for_ref_mut_alloy_primitives_bits_address_Address.
    
    Module Impl_core_convert_From_ref__alloy_primitives_bits_address_Address_for_ref__array_Usize_20_u8.
      Definition Self : Ty.t :=
        Ty.apply
          (Ty.path "&")
          []
          [ Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 20 ] [ Ty.path "u8" ] ].
      
      (*
                  fn from(value: $a) -> $b {
                      // SAFETY: guaranteed by caller
                      unsafe { $crate::private::core::mem::transmute::<$a, $b>(value) }
                  }
      *)
      Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "&")
                []
                [ Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 20 ] [ Ty.path "u8" ]
                ],
              M.get_function (|
                "core::intrinsics::transmute",
                [],
                [
                  Ty.apply (Ty.path "&") [] [ Ty.path "alloy_primitives::bits::address::Address" ];
                  Ty.apply
                    (Ty.path "&")
                    []
                    [
                      Ty.apply
                        (Ty.path "array")
                        [ Value.Integer IntegerKind.Usize 20 ]
                        [ Ty.path "u8" ]
                    ]
                ]
              |),
              [ M.read (| value |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "&") [] [ Ty.path "alloy_primitives::bits::address::Address" ] ]
          Self
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_ref__alloy_primitives_bits_address_Address_for_ref__array_Usize_20_u8.
    
    Module Impl_core_convert_From_ref_mut_alloy_primitives_bits_address_Address_for_ref__array_Usize_20_u8.
      Definition Self : Ty.t :=
        Ty.apply
          (Ty.path "&")
          []
          [ Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 20 ] [ Ty.path "u8" ] ].
      
      (*
                  fn from(value: $a) -> $b {
                      // SAFETY: guaranteed by caller
                      unsafe { $crate::private::core::mem::transmute::<$a, $b>(value) }
                  }
      *)
      Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "&")
                []
                [ Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 20 ] [ Ty.path "u8" ]
                ],
              M.get_function (|
                "core::intrinsics::transmute",
                [],
                [
                  Ty.apply
                    (Ty.path "&mut")
                    []
                    [ Ty.path "alloy_primitives::bits::address::Address" ];
                  Ty.apply
                    (Ty.path "&")
                    []
                    [
                      Ty.apply
                        (Ty.path "array")
                        [ Value.Integer IntegerKind.Usize 20 ]
                        [ Ty.path "u8" ]
                    ]
                ]
              |),
              [ M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| value |) |) |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "&mut") [] [ Ty.path "alloy_primitives::bits::address::Address" ] ]
          Self
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_ref_mut_alloy_primitives_bits_address_Address_for_ref__array_Usize_20_u8.
    
    Module Impl_core_convert_From_ref_mut_alloy_primitives_bits_address_Address_for_ref_mut_array_Usize_20_u8.
      Definition Self : Ty.t :=
        Ty.apply
          (Ty.path "&mut")
          []
          [ Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 20 ] [ Ty.path "u8" ] ].
      
      (*
                  fn from(value: $a) -> $b {
                      // SAFETY: guaranteed by caller
                      unsafe { $crate::private::core::mem::transmute::<$a, $b>(value) }
                  }
      *)
      Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            M.borrow (|
              Pointer.Kind.MutRef,
              M.deref (|
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.MutRef,
                      M.deref (|
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "&mut")
                            []
                            [
                              Ty.apply
                                (Ty.path "array")
                                [ Value.Integer IntegerKind.Usize 20 ]
                                [ Ty.path "u8" ]
                            ],
                          M.get_function (|
                            "core::intrinsics::transmute",
                            [],
                            [
                              Ty.apply
                                (Ty.path "&mut")
                                []
                                [ Ty.path "alloy_primitives::bits::address::Address" ];
                              Ty.apply
                                (Ty.path "&mut")
                                []
                                [
                                  Ty.apply
                                    (Ty.path "array")
                                    [ Value.Integer IntegerKind.Usize 20 ]
                                    [ Ty.path "u8" ]
                                ]
                            ]
                          |),
                          [ M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| value |) |) |) ]
                        |)
                      |)
                    |)
                  |)
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "&mut") [] [ Ty.path "alloy_primitives::bits::address::Address" ] ]
          Self
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_ref_mut_alloy_primitives_bits_address_Address_for_ref_mut_array_Usize_20_u8.
    
    Module Impl_core_cmp_PartialEq_slice_u8_for_alloy_primitives_bits_address_Address.
      Definition Self : Ty.t := Ty.path "alloy_primitives::bits::address::Address".
      
      (*
                  fn $fn(&self, other: &$a) -> $ret {
                      $crate::private::$tr::$fn(&self.0 $([$e])?, other)
                  }
      *)
      Definition eq (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              Ty.path "bool",
              M.get_trait_method (|
                "core::cmp::PartialEq",
                Ty.apply
                  (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                  [ Value.Integer IntegerKind.Usize 20 ]
                  [],
                [],
                [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                "eq",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_tuple_field (|
                        M.deref (| M.read (| self |) |),
                        "alloy_primitives::bits::address::Address",
                        0
                      |)
                    |)
                  |)
                |);
                M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| other |) |) |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::cmp::PartialEq"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
          Self
          (* Instance *) [ ("eq", InstanceField.Method eq) ].
    End Impl_core_cmp_PartialEq_slice_u8_for_alloy_primitives_bits_address_Address.
    
    Module Impl_core_cmp_PartialEq_alloy_primitives_bits_address_Address_for_slice_u8.
      Definition Self : Ty.t := Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ].
      
      (*
                  fn $fn(&self, other: &$b) -> $ret {
                      $crate::private::$tr::$fn(self, &other.0 $([$e])?)
                  }
      *)
      Definition eq (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              Ty.path "bool",
              M.get_trait_method (|
                "core::cmp::PartialEq",
                Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                [],
                [
                  Ty.apply
                    (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                    [ Value.Integer IntegerKind.Usize 20 ]
                    []
                ],
                "eq",
                [],
                []
              |),
              [
                M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |);
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_tuple_field (|
                        M.deref (| M.read (| other |) |),
                        "alloy_primitives::bits::address::Address",
                        0
                      |)
                    |)
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::cmp::PartialEq"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "alloy_primitives::bits::address::Address" ]
          Self
          (* Instance *) [ ("eq", InstanceField.Method eq) ].
    End Impl_core_cmp_PartialEq_alloy_primitives_bits_address_Address_for_slice_u8.
    
    Module Impl_core_cmp_PartialEq_ref__slice_u8_for_alloy_primitives_bits_address_Address.
      Definition Self : Ty.t := Ty.path "alloy_primitives::bits::address::Address".
      
      (*
                  fn $fn(&self, other: &&$a) -> $ret {
                      $crate::private::$tr::$fn(&self.0 $([$e])?, *other)
                  }
      *)
      Definition eq (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              Ty.path "bool",
              M.get_trait_method (|
                "core::cmp::PartialEq",
                Ty.apply
                  (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                  [ Value.Integer IntegerKind.Usize 20 ]
                  [],
                [],
                [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                "eq",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_tuple_field (|
                        M.deref (| M.read (| self |) |),
                        "alloy_primitives::bits::address::Address",
                        0
                      |)
                    |)
                  |)
                |);
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (| M.read (| M.deref (| M.read (| other |) |) |) |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::cmp::PartialEq"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ] ]
          Self
          (* Instance *) [ ("eq", InstanceField.Method eq) ].
    End Impl_core_cmp_PartialEq_ref__slice_u8_for_alloy_primitives_bits_address_Address.
    
    Module Impl_core_cmp_PartialEq_alloy_primitives_bits_address_Address_for_ref__slice_u8.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ].
      
      (*
                  fn $fn(&self, other: &$b) -> $ret {
                      $crate::private::$tr::$fn( *self, &other.0 $([$e])?)
                  }
      *)
      Definition eq (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              Ty.path "bool",
              M.get_trait_method (|
                "core::cmp::PartialEq",
                Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                [],
                [
                  Ty.apply
                    (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                    [ Value.Integer IntegerKind.Usize 20 ]
                    []
                ],
                "eq",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
                |);
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_tuple_field (|
                        M.deref (| M.read (| other |) |),
                        "alloy_primitives::bits::address::Address",
                        0
                      |)
                    |)
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::cmp::PartialEq"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "alloy_primitives::bits::address::Address" ]
          Self
          (* Instance *) [ ("eq", InstanceField.Method eq) ].
    End Impl_core_cmp_PartialEq_alloy_primitives_bits_address_Address_for_ref__slice_u8.
    
    Module Impl_core_cmp_PartialEq_slice_u8_for_ref__alloy_primitives_bits_address_Address.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "&") [] [ Ty.path "alloy_primitives::bits::address::Address" ].
      
      (*
                  fn $fn(&self, other: &$a) -> $ret {
                      $crate::private::$tr::$fn(&self.0 $([$e])?, other)
                  }
      *)
      Definition eq (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              Ty.path "bool",
              M.get_trait_method (|
                "core::cmp::PartialEq",
                Ty.apply
                  (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                  [ Value.Integer IntegerKind.Usize 20 ]
                  [],
                [],
                [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                "eq",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_tuple_field (|
                        M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |),
                        "alloy_primitives::bits::address::Address",
                        0
                      |)
                    |)
                  |)
                |);
                M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| other |) |) |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::cmp::PartialEq"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
          Self
          (* Instance *) [ ("eq", InstanceField.Method eq) ].
    End Impl_core_cmp_PartialEq_slice_u8_for_ref__alloy_primitives_bits_address_Address.
    
    Module Impl_core_cmp_PartialEq_ref__alloy_primitives_bits_address_Address_for_slice_u8.
      Definition Self : Ty.t := Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ].
      
      (*
                  fn $fn(&self, other: &&$b) -> $ret {
                      $crate::private::$tr::$fn(self, &other.0 $([$e])?)
                  }
      *)
      Definition eq (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              Ty.path "bool",
              M.get_trait_method (|
                "core::cmp::PartialEq",
                Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                [],
                [
                  Ty.apply
                    (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                    [ Value.Integer IntegerKind.Usize 20 ]
                    []
                ],
                "eq",
                [],
                []
              |),
              [
                M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |);
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_tuple_field (|
                        M.deref (| M.read (| M.deref (| M.read (| other |) |) |) |),
                        "alloy_primitives::bits::address::Address",
                        0
                      |)
                    |)
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::cmp::PartialEq"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "&") [] [ Ty.path "alloy_primitives::bits::address::Address" ] ]
          Self
          (* Instance *) [ ("eq", InstanceField.Method eq) ].
    End Impl_core_cmp_PartialEq_ref__alloy_primitives_bits_address_Address_for_slice_u8.
    
    Module Impl_core_cmp_PartialEq_array_Usize_20_u8_for_alloy_primitives_bits_address_Address.
      Definition Self : Ty.t := Ty.path "alloy_primitives::bits::address::Address".
      
      (*
                  fn $fn(&self, other: &$a) -> $ret {
                      $crate::private::$tr::$fn(&self.0 $([$e])?, other)
                  }
      *)
      Definition eq (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              Ty.path "bool",
              M.get_trait_method (|
                "core::cmp::PartialEq",
                Ty.apply
                  (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                  [ Value.Integer IntegerKind.Usize 20 ]
                  [],
                [],
                [ Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 20 ] [ Ty.path "u8" ]
                ],
                "eq",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_tuple_field (|
                        M.deref (| M.read (| self |) |),
                        "alloy_primitives::bits::address::Address",
                        0
                      |)
                    |)
                  |)
                |);
                M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| other |) |) |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::cmp::PartialEq"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 20 ] [ Ty.path "u8" ] ]
          Self
          (* Instance *) [ ("eq", InstanceField.Method eq) ].
    End Impl_core_cmp_PartialEq_array_Usize_20_u8_for_alloy_primitives_bits_address_Address.
    
    Module Impl_core_cmp_PartialEq_alloy_primitives_bits_address_Address_for_array_Usize_20_u8.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 20 ] [ Ty.path "u8" ].
      
      (*
                  fn $fn(&self, other: &$b) -> $ret {
                      $crate::private::$tr::$fn(self, &other.0 $([$e])?)
                  }
      *)
      Definition eq (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              Ty.path "bool",
              M.get_trait_method (|
                "core::cmp::PartialEq",
                Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 20 ] [ Ty.path "u8" ],
                [],
                [
                  Ty.apply
                    (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                    [ Value.Integer IntegerKind.Usize 20 ]
                    []
                ],
                "eq",
                [],
                []
              |),
              [
                M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |);
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_tuple_field (|
                        M.deref (| M.read (| other |) |),
                        "alloy_primitives::bits::address::Address",
                        0
                      |)
                    |)
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::cmp::PartialEq"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "alloy_primitives::bits::address::Address" ]
          Self
          (* Instance *) [ ("eq", InstanceField.Method eq) ].
    End Impl_core_cmp_PartialEq_alloy_primitives_bits_address_Address_for_array_Usize_20_u8.
    
    Module Impl_core_cmp_PartialEq_ref__array_Usize_20_u8_for_alloy_primitives_bits_address_Address.
      Definition Self : Ty.t := Ty.path "alloy_primitives::bits::address::Address".
      
      (*
                  fn $fn(&self, other: &&$a) -> $ret {
                      $crate::private::$tr::$fn(&self.0 $([$e])?, *other)
                  }
      *)
      Definition eq (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              Ty.path "bool",
              M.get_trait_method (|
                "core::cmp::PartialEq",
                Ty.apply
                  (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                  [ Value.Integer IntegerKind.Usize 20 ]
                  [],
                [],
                [ Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 20 ] [ Ty.path "u8" ]
                ],
                "eq",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_tuple_field (|
                        M.deref (| M.read (| self |) |),
                        "alloy_primitives::bits::address::Address",
                        0
                      |)
                    |)
                  |)
                |);
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (| M.read (| M.deref (| M.read (| other |) |) |) |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::cmp::PartialEq"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [
            Ty.apply
              (Ty.path "&")
              []
              [ Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 20 ] [ Ty.path "u8" ] ]
          ]
          Self
          (* Instance *) [ ("eq", InstanceField.Method eq) ].
    End Impl_core_cmp_PartialEq_ref__array_Usize_20_u8_for_alloy_primitives_bits_address_Address.
    
    Module Impl_core_cmp_PartialEq_alloy_primitives_bits_address_Address_for_ref__array_Usize_20_u8.
      Definition Self : Ty.t :=
        Ty.apply
          (Ty.path "&")
          []
          [ Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 20 ] [ Ty.path "u8" ] ].
      
      (*
                  fn $fn(&self, other: &$b) -> $ret {
                      $crate::private::$tr::$fn( *self, &other.0 $([$e])?)
                  }
      *)
      Definition eq (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              Ty.path "bool",
              M.get_trait_method (|
                "core::cmp::PartialEq",
                Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 20 ] [ Ty.path "u8" ],
                [],
                [
                  Ty.apply
                    (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                    [ Value.Integer IntegerKind.Usize 20 ]
                    []
                ],
                "eq",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
                |);
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_tuple_field (|
                        M.deref (| M.read (| other |) |),
                        "alloy_primitives::bits::address::Address",
                        0
                      |)
                    |)
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::cmp::PartialEq"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "alloy_primitives::bits::address::Address" ]
          Self
          (* Instance *) [ ("eq", InstanceField.Method eq) ].
    End Impl_core_cmp_PartialEq_alloy_primitives_bits_address_Address_for_ref__array_Usize_20_u8.
    
    Module Impl_core_cmp_PartialEq_array_Usize_20_u8_for_ref__alloy_primitives_bits_address_Address.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "&") [] [ Ty.path "alloy_primitives::bits::address::Address" ].
      
      (*
                  fn $fn(&self, other: &$a) -> $ret {
                      $crate::private::$tr::$fn(&self.0 $([$e])?, other)
                  }
      *)
      Definition eq (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              Ty.path "bool",
              M.get_trait_method (|
                "core::cmp::PartialEq",
                Ty.apply
                  (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                  [ Value.Integer IntegerKind.Usize 20 ]
                  [],
                [],
                [ Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 20 ] [ Ty.path "u8" ]
                ],
                "eq",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_tuple_field (|
                        M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |),
                        "alloy_primitives::bits::address::Address",
                        0
                      |)
                    |)
                  |)
                |);
                M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| other |) |) |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::cmp::PartialEq"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 20 ] [ Ty.path "u8" ] ]
          Self
          (* Instance *) [ ("eq", InstanceField.Method eq) ].
    End Impl_core_cmp_PartialEq_array_Usize_20_u8_for_ref__alloy_primitives_bits_address_Address.
    
    Module Impl_core_cmp_PartialEq_ref__alloy_primitives_bits_address_Address_for_array_Usize_20_u8.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 20 ] [ Ty.path "u8" ].
      
      (*
                  fn $fn(&self, other: &&$b) -> $ret {
                      $crate::private::$tr::$fn(self, &other.0 $([$e])?)
                  }
      *)
      Definition eq (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              Ty.path "bool",
              M.get_trait_method (|
                "core::cmp::PartialEq",
                Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 20 ] [ Ty.path "u8" ],
                [],
                [
                  Ty.apply
                    (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                    [ Value.Integer IntegerKind.Usize 20 ]
                    []
                ],
                "eq",
                [],
                []
              |),
              [
                M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |);
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_tuple_field (|
                        M.deref (| M.read (| M.deref (| M.read (| other |) |) |) |),
                        "alloy_primitives::bits::address::Address",
                        0
                      |)
                    |)
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::cmp::PartialEq"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "&") [] [ Ty.path "alloy_primitives::bits::address::Address" ] ]
          Self
          (* Instance *) [ ("eq", InstanceField.Method eq) ].
    End Impl_core_cmp_PartialEq_ref__alloy_primitives_bits_address_Address_for_array_Usize_20_u8.
    
    Module Impl_core_cmp_PartialOrd_slice_u8_for_alloy_primitives_bits_address_Address.
      Definition Self : Ty.t := Ty.path "alloy_primitives::bits::address::Address".
      
      (*
                  fn $fn(&self, other: &$a) -> $ret {
                      $crate::private::$tr::$fn(&self.0 $([$e])?, other)
                  }
      *)
      Definition partial_cmp (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "core::cmp::Ordering" ],
              M.get_trait_method (|
                "core::cmp::PartialOrd",
                Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                [],
                [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                "partial_cmp",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "&")
                            []
                            [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                          M.get_trait_method (|
                            "core::ops::index::Index",
                            Ty.apply
                              (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                              [ Value.Integer IntegerKind.Usize 20 ]
                              [],
                            [],
                            [ Ty.path "core::ops::range::RangeFull" ],
                            "index",
                            [],
                            []
                          |),
                          [
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.SubPointer.get_struct_tuple_field (|
                                M.deref (| M.read (| self |) |),
                                "alloy_primitives::bits::address::Address",
                                0
                              |)
                            |);
                            Value.StructTuple "core::ops::range::RangeFull" []
                          ]
                        |)
                      |)
                    |)
                  |)
                |);
                M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| other |) |) |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::cmp::PartialOrd"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
          Self
          (* Instance *) [ ("partial_cmp", InstanceField.Method partial_cmp) ].
    End Impl_core_cmp_PartialOrd_slice_u8_for_alloy_primitives_bits_address_Address.
    
    Module Impl_core_cmp_PartialOrd_alloy_primitives_bits_address_Address_for_slice_u8.
      Definition Self : Ty.t := Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ].
      
      (*
                  fn $fn(&self, other: &$b) -> $ret {
                      $crate::private::$tr::$fn(self, &other.0 $([$e])?)
                  }
      *)
      Definition partial_cmp (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "core::cmp::Ordering" ],
              M.get_trait_method (|
                "core::cmp::PartialOrd",
                Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                [],
                [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                "partial_cmp",
                [],
                []
              |),
              [
                M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |);
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "&")
                            []
                            [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                          M.get_trait_method (|
                            "core::ops::index::Index",
                            Ty.apply
                              (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                              [ Value.Integer IntegerKind.Usize 20 ]
                              [],
                            [],
                            [ Ty.path "core::ops::range::RangeFull" ],
                            "index",
                            [],
                            []
                          |),
                          [
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.SubPointer.get_struct_tuple_field (|
                                M.deref (| M.read (| other |) |),
                                "alloy_primitives::bits::address::Address",
                                0
                              |)
                            |);
                            Value.StructTuple "core::ops::range::RangeFull" []
                          ]
                        |)
                      |)
                    |)
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::cmp::PartialOrd"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "alloy_primitives::bits::address::Address" ]
          Self
          (* Instance *) [ ("partial_cmp", InstanceField.Method partial_cmp) ].
    End Impl_core_cmp_PartialOrd_alloy_primitives_bits_address_Address_for_slice_u8.
    
    Module Impl_core_cmp_PartialOrd_ref__slice_u8_for_alloy_primitives_bits_address_Address.
      Definition Self : Ty.t := Ty.path "alloy_primitives::bits::address::Address".
      
      (*
                  fn $fn(&self, other: &&$a) -> $ret {
                      $crate::private::$tr::$fn(&self.0 $([$e])?, *other)
                  }
      *)
      Definition partial_cmp (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "core::cmp::Ordering" ],
              M.get_trait_method (|
                "core::cmp::PartialOrd",
                Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                [],
                [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                "partial_cmp",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "&")
                            []
                            [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                          M.get_trait_method (|
                            "core::ops::index::Index",
                            Ty.apply
                              (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                              [ Value.Integer IntegerKind.Usize 20 ]
                              [],
                            [],
                            [ Ty.path "core::ops::range::RangeFull" ],
                            "index",
                            [],
                            []
                          |),
                          [
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.SubPointer.get_struct_tuple_field (|
                                M.deref (| M.read (| self |) |),
                                "alloy_primitives::bits::address::Address",
                                0
                              |)
                            |);
                            Value.StructTuple "core::ops::range::RangeFull" []
                          ]
                        |)
                      |)
                    |)
                  |)
                |);
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (| M.read (| M.deref (| M.read (| other |) |) |) |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::cmp::PartialOrd"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ] ]
          Self
          (* Instance *) [ ("partial_cmp", InstanceField.Method partial_cmp) ].
    End Impl_core_cmp_PartialOrd_ref__slice_u8_for_alloy_primitives_bits_address_Address.
    
    Module Impl_core_cmp_PartialOrd_alloy_primitives_bits_address_Address_for_ref__slice_u8.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ].
      
      (*
                  fn $fn(&self, other: &$b) -> $ret {
                      $crate::private::$tr::$fn( *self, &other.0 $([$e])?)
                  }
      *)
      Definition partial_cmp (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "core::cmp::Ordering" ],
              M.get_trait_method (|
                "core::cmp::PartialOrd",
                Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                [],
                [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                "partial_cmp",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
                |);
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "&")
                            []
                            [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                          M.get_trait_method (|
                            "core::ops::index::Index",
                            Ty.apply
                              (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                              [ Value.Integer IntegerKind.Usize 20 ]
                              [],
                            [],
                            [ Ty.path "core::ops::range::RangeFull" ],
                            "index",
                            [],
                            []
                          |),
                          [
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.SubPointer.get_struct_tuple_field (|
                                M.deref (| M.read (| other |) |),
                                "alloy_primitives::bits::address::Address",
                                0
                              |)
                            |);
                            Value.StructTuple "core::ops::range::RangeFull" []
                          ]
                        |)
                      |)
                    |)
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::cmp::PartialOrd"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "alloy_primitives::bits::address::Address" ]
          Self
          (* Instance *) [ ("partial_cmp", InstanceField.Method partial_cmp) ].
    End Impl_core_cmp_PartialOrd_alloy_primitives_bits_address_Address_for_ref__slice_u8.
    
    Module Impl_core_cmp_PartialOrd_slice_u8_for_ref__alloy_primitives_bits_address_Address.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "&") [] [ Ty.path "alloy_primitives::bits::address::Address" ].
      
      (*
                  fn $fn(&self, other: &$a) -> $ret {
                      $crate::private::$tr::$fn(&self.0 $([$e])?, other)
                  }
      *)
      Definition partial_cmp (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "core::cmp::Ordering" ],
              M.get_trait_method (|
                "core::cmp::PartialOrd",
                Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                [],
                [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                "partial_cmp",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "&")
                            []
                            [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                          M.get_trait_method (|
                            "core::ops::index::Index",
                            Ty.apply
                              (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                              [ Value.Integer IntegerKind.Usize 20 ]
                              [],
                            [],
                            [ Ty.path "core::ops::range::RangeFull" ],
                            "index",
                            [],
                            []
                          |),
                          [
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.SubPointer.get_struct_tuple_field (|
                                M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |),
                                "alloy_primitives::bits::address::Address",
                                0
                              |)
                            |);
                            Value.StructTuple "core::ops::range::RangeFull" []
                          ]
                        |)
                      |)
                    |)
                  |)
                |);
                M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| other |) |) |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::cmp::PartialOrd"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
          Self
          (* Instance *) [ ("partial_cmp", InstanceField.Method partial_cmp) ].
    End Impl_core_cmp_PartialOrd_slice_u8_for_ref__alloy_primitives_bits_address_Address.
    
    Module Impl_core_cmp_PartialOrd_ref__alloy_primitives_bits_address_Address_for_slice_u8.
      Definition Self : Ty.t := Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ].
      
      (*
                  fn $fn(&self, other: &&$b) -> $ret {
                      $crate::private::$tr::$fn(self, &other.0 $([$e])?)
                  }
      *)
      Definition partial_cmp (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "core::cmp::Ordering" ],
              M.get_trait_method (|
                "core::cmp::PartialOrd",
                Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                [],
                [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                "partial_cmp",
                [],
                []
              |),
              [
                M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |);
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "&")
                            []
                            [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                          M.get_trait_method (|
                            "core::ops::index::Index",
                            Ty.apply
                              (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                              [ Value.Integer IntegerKind.Usize 20 ]
                              [],
                            [],
                            [ Ty.path "core::ops::range::RangeFull" ],
                            "index",
                            [],
                            []
                          |),
                          [
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.SubPointer.get_struct_tuple_field (|
                                M.deref (| M.read (| M.deref (| M.read (| other |) |) |) |),
                                "alloy_primitives::bits::address::Address",
                                0
                              |)
                            |);
                            Value.StructTuple "core::ops::range::RangeFull" []
                          ]
                        |)
                      |)
                    |)
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::cmp::PartialOrd"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "&") [] [ Ty.path "alloy_primitives::bits::address::Address" ] ]
          Self
          (* Instance *) [ ("partial_cmp", InstanceField.Method partial_cmp) ].
    End Impl_core_cmp_PartialOrd_ref__alloy_primitives_bits_address_Address_for_slice_u8.
    
    Module Impl_const_hex_traits_FromHex_for_alloy_primitives_bits_address_Address.
      Definition Self : Ty.t := Ty.path "alloy_primitives::bits::address::Address".
      
      (*             type Error = $crate::hex::FromHexError; *)
      Definition _Error : Ty.t := Ty.path "const_hex::error::FromHexError".
      
      (*
                  fn from_hex<T: $crate::private::AsRef<[u8]>>(hex: T) -> Result<Self, Self::Error> {
                      $crate::hex::decode_to_array(hex).map(Self::new)
                  }
      *)
      Definition from_hex (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [ T ], [ hex ] =>
          ltac:(M.monadic
            (let hex := M.alloc (| hex |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "core::result::Result")
                []
                [
                  Ty.path "alloy_primitives::bits::address::Address";
                  Ty.path "const_hex::error::FromHexError"
                ],
              M.get_associated_function (|
                Ty.apply
                  (Ty.path "core::result::Result")
                  []
                  [
                    Ty.apply
                      (Ty.path "array")
                      [ Value.Integer IntegerKind.Usize 20 ]
                      [ Ty.path "u8" ];
                    Ty.path "const_hex::error::FromHexError"
                  ],
                "map",
                [],
                [
                  Ty.path "alloy_primitives::bits::address::Address";
                  Ty.function
                    [
                      Ty.apply
                        (Ty.path "array")
                        [ Value.Integer IntegerKind.Usize 20 ]
                        [ Ty.path "u8" ]
                    ]
                    (Ty.path "alloy_primitives::bits::address::Address")
                ]
              |),
              [
                M.call_closure (|
                  Ty.apply
                    (Ty.path "core::result::Result")
                    []
                    [
                      Ty.apply
                        (Ty.path "array")
                        [ Value.Integer IntegerKind.Usize 20 ]
                        [ Ty.path "u8" ];
                      Ty.path "const_hex::error::FromHexError"
                    ],
                  M.get_function (|
                    "const_hex::decode_to_array",
                    [ Value.Integer IntegerKind.Usize 20 ],
                    [ T ]
                  |),
                  [ M.read (| hex |) ]
                |);
                M.get_associated_function (|
                  Ty.path "alloy_primitives::bits::address::Address",
                  "new",
                  [],
                  []
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "const_hex::traits::FromHex"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *)
          [ ("Error", InstanceField.Ty _Error); ("from_hex", InstanceField.Method from_hex) ].
    End Impl_const_hex_traits_FromHex_for_alloy_primitives_bits_address_Address.
    
    Module Impl_alloy_primitives_bits_address_Address.
      Definition Self : Ty.t := Ty.path "alloy_primitives::bits::address::Address".
      
      (*             pub const ZERO: Self = Self($crate::FixedBytes::ZERO); *)
      (* Ty.path "alloy_primitives::bits::address::Address" *)
      Definition value_ZERO (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple
              "alloy_primitives::bits::address::Address"
              [
                M.read (|
                  get_associated_constant (|
                    Ty.apply
                      (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                      [ Value.Integer IntegerKind.Usize 20 ]
                      [],
                    "ZERO",
                    Ty.apply
                      (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                      [ Value.Integer IntegerKind.Usize 20 ]
                      []
                  |)
                |)
              ]
          |))).
      
      Global Instance AssociatedConstant_value_ZERO :
        M.IsAssociatedFunction.C Self "ZERO" value_ZERO.
      Admitted.
      Global Typeclasses Opaque value_ZERO.
      
      (*
                  pub const fn new(bytes: [u8; $n]) -> Self {
                      Self($crate::FixedBytes(bytes))
                  }
      *)
      Definition new (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ bytes ] =>
          ltac:(M.monadic
            (let bytes := M.alloc (| bytes |) in
            Value.StructTuple
              "alloy_primitives::bits::address::Address"
              [ Value.StructTuple "alloy_primitives::bits::fixed::FixedBytes" [ M.read (| bytes |) ]
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_new : M.IsAssociatedFunction.C Self "new" new.
      Admitted.
      Global Typeclasses Opaque new.
      
      (*
                  pub const fn with_last_byte(x: u8) -> Self {
                      Self($crate::FixedBytes::with_last_byte(x))
                  }
      *)
      Definition with_last_byte (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ x ] =>
          ltac:(M.monadic
            (let x := M.alloc (| x |) in
            Value.StructTuple
              "alloy_primitives::bits::address::Address"
              [
                M.call_closure (|
                  Ty.apply
                    (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                    [ Value.Integer IntegerKind.Usize 20 ]
                    [],
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                      [ Value.Integer IntegerKind.Usize 20 ]
                      [],
                    "with_last_byte",
                    [],
                    []
                  |),
                  [ M.read (| x |) ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_with_last_byte :
        M.IsAssociatedFunction.C Self "with_last_byte" with_last_byte.
      Admitted.
      Global Typeclasses Opaque with_last_byte.
      
      (*
                  pub const fn repeat_byte(byte: u8) -> Self {
                      Self($crate::FixedBytes::repeat_byte(byte))
                  }
      *)
      Definition repeat_byte (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ byte ] =>
          ltac:(M.monadic
            (let byte := M.alloc (| byte |) in
            Value.StructTuple
              "alloy_primitives::bits::address::Address"
              [
                M.call_closure (|
                  Ty.apply
                    (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                    [ Value.Integer IntegerKind.Usize 20 ]
                    [],
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                      [ Value.Integer IntegerKind.Usize 20 ]
                      [],
                    "repeat_byte",
                    [],
                    []
                  |),
                  [ M.read (| byte |) ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_repeat_byte :
        M.IsAssociatedFunction.C Self "repeat_byte" repeat_byte.
      Admitted.
      Global Typeclasses Opaque repeat_byte.
      
      (*
                  pub const fn len_bytes() -> usize {
                      $n
                  }
      *)
      Definition len_bytes (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [] => ltac:(M.monadic (Value.Integer IntegerKind.Usize 20))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_len_bytes :
        M.IsAssociatedFunction.C Self "len_bytes" len_bytes.
      Admitted.
      Global Typeclasses Opaque len_bytes.
      
      (*
                  pub fn from_slice(src: &[u8]) -> Self {
                      match Self::try_from(src) {
                          Ok(x) => x,
                          Err(_) => panic!("cannot convert a slice of length {} to {}", src.len(), stringify!($name)),
                      }
                  }
      *)
      Definition from_slice (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ src ] =>
          ltac:(M.monadic
            (let src := M.alloc (| src |) in
            M.read (|
              M.match_operator (|
                Some (Ty.path "alloy_primitives::bits::address::Address"),
                M.alloc (|
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "core::result::Result")
                      []
                      [
                        Ty.path "alloy_primitives::bits::address::Address";
                        Ty.path "core::array::TryFromSliceError"
                      ],
                    M.get_trait_method (|
                      "core::convert::TryFrom",
                      Ty.path "alloy_primitives::bits::address::Address",
                      [],
                      [ Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
                      ],
                      "try_from",
                      [],
                      []
                    |),
                    [ M.read (| src |) ]
                  |)
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::result::Result::Ok",
                          0
                        |) in
                      let x := M.copy (| γ0_0 |) in
                      x));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::result::Result::Err",
                          0
                        |) in
                      M.alloc (|
                        M.never_to_any (|
                          M.call_closure (|
                            Ty.path "never",
                            M.get_function (| "core::panicking::panic_fmt", [], [] |),
                            [
                              M.call_closure (|
                                Ty.path "core::fmt::Arguments",
                                M.get_associated_function (|
                                  Ty.path "core::fmt::Arguments",
                                  "new_v1",
                                  [
                                    Value.Integer IntegerKind.Usize 2;
                                    Value.Integer IntegerKind.Usize 1
                                  ],
                                  []
                                |),
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (|
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.alloc (|
                                          Value.Array
                                            [
                                              mk_str (| "cannot convert a slice of length " |);
                                              mk_str (| " to Address" |)
                                            ]
                                        |)
                                      |)
                                    |)
                                  |);
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (|
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.alloc (|
                                          Value.Array
                                            [
                                              M.call_closure (|
                                                Ty.path "core::fmt::rt::Argument",
                                                M.get_associated_function (|
                                                  Ty.path "core::fmt::rt::Argument",
                                                  "new_display",
                                                  [],
                                                  [ Ty.path "usize" ]
                                                |),
                                                [
                                                  M.borrow (|
                                                    Pointer.Kind.Ref,
                                                    M.deref (|
                                                      M.borrow (|
                                                        Pointer.Kind.Ref,
                                                        M.alloc (|
                                                          M.call_closure (|
                                                            Ty.path "usize",
                                                            M.get_associated_function (|
                                                              Ty.apply
                                                                (Ty.path "slice")
                                                                []
                                                                [ Ty.path "u8" ],
                                                              "len",
                                                              [],
                                                              []
                                                            |),
                                                            [
                                                              M.borrow (|
                                                                Pointer.Kind.Ref,
                                                                M.deref (| M.read (| src |) |)
                                                              |)
                                                            ]
                                                          |)
                                                        |)
                                                      |)
                                                    |)
                                                  |)
                                                ]
                                              |)
                                            ]
                                        |)
                                      |)
                                    |)
                                  |)
                                ]
                              |)
                            ]
                          |)
                        |)
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_from_slice :
        M.IsAssociatedFunction.C Self "from_slice" from_slice.
      Admitted.
      Global Typeclasses Opaque from_slice.
      
      (*
                  pub fn left_padding_from(value: &[u8]) -> Self {
                      Self($crate::FixedBytes::left_padding_from(value))
                  }
      *)
      Definition left_padding_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            Value.StructTuple
              "alloy_primitives::bits::address::Address"
              [
                M.call_closure (|
                  Ty.apply
                    (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                    [ Value.Integer IntegerKind.Usize 20 ]
                    [],
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                      [ Value.Integer IntegerKind.Usize 20 ]
                      [],
                    "left_padding_from",
                    [],
                    []
                  |),
                  [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| value |) |) |) ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_left_padding_from :
        M.IsAssociatedFunction.C Self "left_padding_from" left_padding_from.
      Admitted.
      Global Typeclasses Opaque left_padding_from.
      
      (*
                  pub fn right_padding_from(value: &[u8]) -> Self {
                      Self($crate::FixedBytes::right_padding_from(value))
                  }
      *)
      Definition right_padding_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            Value.StructTuple
              "alloy_primitives::bits::address::Address"
              [
                M.call_closure (|
                  Ty.apply
                    (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                    [ Value.Integer IntegerKind.Usize 20 ]
                    [],
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                      [ Value.Integer IntegerKind.Usize 20 ]
                      [],
                    "right_padding_from",
                    [],
                    []
                  |),
                  [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| value |) |) |) ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_right_padding_from :
        M.IsAssociatedFunction.C Self "right_padding_from" right_padding_from.
      Admitted.
      Global Typeclasses Opaque right_padding_from.
      
      (*
                  pub const fn into_array(self) -> [u8; $n] {
                      self.0 .0
                  }
      *)
      Definition into_array (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.SubPointer.get_struct_tuple_field (|
                M.SubPointer.get_struct_tuple_field (|
                  self,
                  "alloy_primitives::bits::address::Address",
                  0
                |),
                "alloy_primitives::bits::fixed::FixedBytes",
                0
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_into_array :
        M.IsAssociatedFunction.C Self "into_array" into_array.
      Admitted.
      Global Typeclasses Opaque into_array.
      
      (*
                  pub fn covers(&self, b: &Self) -> bool {
                      &( *b & *self) == b
                  }
      *)
      Definition covers (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; b ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let b := M.alloc (| b |) in
            M.call_closure (|
              Ty.path "bool",
              M.get_trait_method (|
                "core::cmp::PartialEq",
                Ty.apply (Ty.path "&") [] [ Ty.path "alloy_primitives::bits::address::Address" ],
                [],
                [ Ty.apply (Ty.path "&") [] [ Ty.path "alloy_primitives::bits::address::Address" ]
                ],
                "eq",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.alloc (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.alloc (|
                        M.call_closure (|
                          Ty.path "alloy_primitives::bits::address::Address",
                          M.get_trait_method (|
                            "core::ops::bit::BitAnd",
                            Ty.path "alloy_primitives::bits::address::Address",
                            [],
                            [ Ty.path "alloy_primitives::bits::address::Address" ],
                            "bitand",
                            [],
                            []
                          |),
                          [
                            M.read (| M.deref (| M.read (| b |) |) |);
                            M.read (| M.deref (| M.read (| self |) |) |)
                          ]
                        |)
                      |)
                    |)
                  |)
                |);
                M.borrow (| Pointer.Kind.Ref, b |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_covers : M.IsAssociatedFunction.C Self "covers" covers.
      Admitted.
      Global Typeclasses Opaque covers.
      
      (*
                  pub const fn const_eq(&self, other: &Self) -> bool {
                      self.0.const_eq(&other.0)
                  }
      *)
      Definition const_eq (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              Ty.path "bool",
              M.get_associated_function (|
                Ty.apply
                  (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                  [ Value.Integer IntegerKind.Usize 20 ]
                  [],
                "const_eq",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.SubPointer.get_struct_tuple_field (|
                    M.deref (| M.read (| self |) |),
                    "alloy_primitives::bits::address::Address",
                    0
                  |)
                |);
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_tuple_field (|
                        M.deref (| M.read (| other |) |),
                        "alloy_primitives::bits::address::Address",
                        0
                      |)
                    |)
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_const_eq :
        M.IsAssociatedFunction.C Self "const_eq" const_eq.
      Admitted.
      Global Typeclasses Opaque const_eq.
      
      (*
                  pub const fn bit_and(self, rhs: Self) -> Self {
                      Self(self.0.bit_and(rhs.0))
                  }
      *)
      Definition bit_and (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            Value.StructTuple
              "alloy_primitives::bits::address::Address"
              [
                M.call_closure (|
                  Ty.apply
                    (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                    [ Value.Integer IntegerKind.Usize 20 ]
                    [],
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                      [ Value.Integer IntegerKind.Usize 20 ]
                      [],
                    "bit_and",
                    [],
                    []
                  |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "alloy_primitives::bits::address::Address",
                        0
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        rhs,
                        "alloy_primitives::bits::address::Address",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_bit_and : M.IsAssociatedFunction.C Self "bit_and" bit_and.
      Admitted.
      Global Typeclasses Opaque bit_and.
      
      (*
                  pub const fn bit_or(self, rhs: Self) -> Self {
                      Self(self.0.bit_or(rhs.0))
                  }
      *)
      Definition bit_or (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            Value.StructTuple
              "alloy_primitives::bits::address::Address"
              [
                M.call_closure (|
                  Ty.apply
                    (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                    [ Value.Integer IntegerKind.Usize 20 ]
                    [],
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                      [ Value.Integer IntegerKind.Usize 20 ]
                      [],
                    "bit_or",
                    [],
                    []
                  |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "alloy_primitives::bits::address::Address",
                        0
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        rhs,
                        "alloy_primitives::bits::address::Address",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_bit_or : M.IsAssociatedFunction.C Self "bit_or" bit_or.
      Admitted.
      Global Typeclasses Opaque bit_or.
      
      (*
                  pub const fn bit_xor(self, rhs: Self) -> Self {
                      Self(self.0.bit_xor(rhs.0))
                  }
      *)
      Definition bit_xor (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            Value.StructTuple
              "alloy_primitives::bits::address::Address"
              [
                M.call_closure (|
                  Ty.apply
                    (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                    [ Value.Integer IntegerKind.Usize 20 ]
                    [],
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                      [ Value.Integer IntegerKind.Usize 20 ]
                      [],
                    "bit_xor",
                    [],
                    []
                  |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "alloy_primitives::bits::address::Address",
                        0
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        rhs,
                        "alloy_primitives::bits::address::Address",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_bit_xor : M.IsAssociatedFunction.C Self "bit_xor" bit_xor.
      Admitted.
      Global Typeclasses Opaque bit_xor.
    End Impl_alloy_primitives_bits_address_Address.
  End address.
  
  Module bloom.
    (* StructTuple
      {
        name := "Bloom";
        const_params := [];
        ty_params := [];
        fields :=
          [
            Ty.apply
              (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
              [ Value.Integer IntegerKind.Usize 256 ]
              []
          ];
      } *)
    
    Module Impl_core_clone_Clone_for_alloy_primitives_bits_bloom_Bloom.
      Definition Self : Ty.t := Ty.path "alloy_primitives::bits::bloom::Bloom".
      
      (*             Clone *)
      Definition clone (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                None,
                Value.DeclaredButUndefined,
                [ fun γ => ltac:(M.monadic (M.deref (| M.read (| self |) |))) ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::clone::Clone"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [ ("clone", InstanceField.Method clone) ].
    End Impl_core_clone_Clone_for_alloy_primitives_bits_bloom_Bloom.
    
    Module Impl_core_marker_Copy_for_alloy_primitives_bits_bloom_Bloom.
      Definition Self : Ty.t := Ty.path "alloy_primitives::bits::bloom::Bloom".
      
      Axiom Implements :
        M.IsTraitInstance
          "core::marker::Copy"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [].
    End Impl_core_marker_Copy_for_alloy_primitives_bits_bloom_Bloom.
    
    Module Impl_core_default_Default_for_alloy_primitives_bits_bloom_Bloom.
      Definition Self : Ty.t := Ty.path "alloy_primitives::bits::bloom::Bloom".
      
      (*             Default *)
      Definition default (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [] =>
          ltac:(M.monadic
            (Value.StructTuple
              "alloy_primitives::bits::bloom::Bloom"
              [
                M.call_closure (|
                  Ty.apply
                    (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                    [ Value.Integer IntegerKind.Usize 256 ]
                    [],
                  M.get_trait_method (|
                    "core::default::Default",
                    Ty.apply
                      (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                      [ Value.Integer IntegerKind.Usize 256 ]
                      [],
                    [],
                    [],
                    "default",
                    [],
                    []
                  |),
                  []
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::default::Default"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [ ("default", InstanceField.Method default) ].
    End Impl_core_default_Default_for_alloy_primitives_bits_bloom_Bloom.
    
    Module Impl_core_marker_StructuralPartialEq_for_alloy_primitives_bits_bloom_Bloom.
      Definition Self : Ty.t := Ty.path "alloy_primitives::bits::bloom::Bloom".
      
      Axiom Implements :
        M.IsTraitInstance
          "core::marker::StructuralPartialEq"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [].
    End Impl_core_marker_StructuralPartialEq_for_alloy_primitives_bits_bloom_Bloom.
    
    Module Impl_core_cmp_PartialEq_alloy_primitives_bits_bloom_Bloom_for_alloy_primitives_bits_bloom_Bloom.
      Definition Self : Ty.t := Ty.path "alloy_primitives::bits::bloom::Bloom".
      
      (*             PartialEq *)
      Definition eq (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              Ty.path "bool",
              M.get_trait_method (|
                "core::cmp::PartialEq",
                Ty.apply
                  (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                  [ Value.Integer IntegerKind.Usize 256 ]
                  [],
                [],
                [
                  Ty.apply
                    (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                    [ Value.Integer IntegerKind.Usize 256 ]
                    []
                ],
                "eq",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.SubPointer.get_struct_tuple_field (|
                    M.deref (| M.read (| self |) |),
                    "alloy_primitives::bits::bloom::Bloom",
                    0
                  |)
                |);
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.SubPointer.get_struct_tuple_field (|
                    M.deref (| M.read (| other |) |),
                    "alloy_primitives::bits::bloom::Bloom",
                    0
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::cmp::PartialEq"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "alloy_primitives::bits::bloom::Bloom" ]
          Self
          (* Instance *) [ ("eq", InstanceField.Method eq) ].
    End Impl_core_cmp_PartialEq_alloy_primitives_bits_bloom_Bloom_for_alloy_primitives_bits_bloom_Bloom.
    
    Module Impl_core_cmp_Eq_for_alloy_primitives_bits_bloom_Bloom.
      Definition Self : Ty.t := Ty.path "alloy_primitives::bits::bloom::Bloom".
      
      (*             Eq *)
      Definition assert_receiver_is_total_eq
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                None,
                Value.DeclaredButUndefined,
                [ fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |))) ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::cmp::Eq"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *)
          [ ("assert_receiver_is_total_eq", InstanceField.Method assert_receiver_is_total_eq) ].
    End Impl_core_cmp_Eq_for_alloy_primitives_bits_bloom_Bloom.
    
    Module Impl_core_cmp_PartialOrd_alloy_primitives_bits_bloom_Bloom_for_alloy_primitives_bits_bloom_Bloom.
      Definition Self : Ty.t := Ty.path "alloy_primitives::bits::bloom::Bloom".
      
      (*             PartialOrd *)
      Definition partial_cmp (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "core::cmp::Ordering" ],
              M.get_trait_method (|
                "core::cmp::PartialOrd",
                Ty.apply
                  (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                  [ Value.Integer IntegerKind.Usize 256 ]
                  [],
                [],
                [
                  Ty.apply
                    (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                    [ Value.Integer IntegerKind.Usize 256 ]
                    []
                ],
                "partial_cmp",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_tuple_field (|
                        M.deref (| M.read (| self |) |),
                        "alloy_primitives::bits::bloom::Bloom",
                        0
                      |)
                    |)
                  |)
                |);
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_tuple_field (|
                        M.deref (| M.read (| other |) |),
                        "alloy_primitives::bits::bloom::Bloom",
                        0
                      |)
                    |)
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::cmp::PartialOrd"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "alloy_primitives::bits::bloom::Bloom" ]
          Self
          (* Instance *) [ ("partial_cmp", InstanceField.Method partial_cmp) ].
    End Impl_core_cmp_PartialOrd_alloy_primitives_bits_bloom_Bloom_for_alloy_primitives_bits_bloom_Bloom.
    
    Module Impl_core_cmp_Ord_for_alloy_primitives_bits_bloom_Bloom.
      Definition Self : Ty.t := Ty.path "alloy_primitives::bits::bloom::Bloom".
      
      (*             Ord *)
      Definition cmp (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              Ty.path "core::cmp::Ordering",
              M.get_trait_method (|
                "core::cmp::Ord",
                Ty.apply
                  (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                  [ Value.Integer IntegerKind.Usize 256 ]
                  [],
                [],
                [],
                "cmp",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_tuple_field (|
                        M.deref (| M.read (| self |) |),
                        "alloy_primitives::bits::bloom::Bloom",
                        0
                      |)
                    |)
                  |)
                |);
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_tuple_field (|
                        M.deref (| M.read (| other |) |),
                        "alloy_primitives::bits::bloom::Bloom",
                        0
                      |)
                    |)
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::cmp::Ord"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [ ("cmp", InstanceField.Method cmp) ].
    End Impl_core_cmp_Ord_for_alloy_primitives_bits_bloom_Bloom.
    
    Module Impl_core_hash_Hash_for_alloy_primitives_bits_bloom_Bloom.
      Definition Self : Ty.t := Ty.path "alloy_primitives::bits::bloom::Bloom".
      
      (*             Hash *)
      Definition hash (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [ __H ], [ self; state ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let state := M.alloc (| state |) in
            M.call_closure (|
              Ty.tuple [],
              M.get_trait_method (|
                "core::hash::Hash",
                Ty.apply
                  (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                  [ Value.Integer IntegerKind.Usize 256 ]
                  [],
                [],
                [],
                "hash",
                [],
                [ __H ]
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_tuple_field (|
                        M.deref (| M.read (| self |) |),
                        "alloy_primitives::bits::bloom::Bloom",
                        0
                      |)
                    |)
                  |)
                |);
                M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::hash::Hash"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [ ("hash", InstanceField.Method hash) ].
    End Impl_core_hash_Hash_for_alloy_primitives_bits_bloom_Bloom.
    
    Module Impl_core_convert_AsMut_alloy_primitives_bits_fixed_FixedBytes_Usize_256_for_alloy_primitives_bits_bloom_Bloom.
      Definition Self : Ty.t := Ty.path "alloy_primitives::bits::bloom::Bloom".
      
      (*             $crate::private::derive_more::AsMut *)
      Definition as_mut (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.borrow (|
              Pointer.Kind.MutRef,
              M.deref (|
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.MutRef,
                      M.SubPointer.get_struct_tuple_field (|
                        M.deref (| M.read (| self |) |),
                        "alloy_primitives::bits::bloom::Bloom",
                        0
                      |)
                    |)
                  |)
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::AsMut"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [
            Ty.apply
              (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
              [ Value.Integer IntegerKind.Usize 256 ]
              []
          ]
          Self
          (* Instance *) [ ("as_mut", InstanceField.Method as_mut) ].
    End Impl_core_convert_AsMut_alloy_primitives_bits_fixed_FixedBytes_Usize_256_for_alloy_primitives_bits_bloom_Bloom.
    
    Module Impl_core_convert_AsRef_alloy_primitives_bits_fixed_FixedBytes_Usize_256_for_alloy_primitives_bits_bloom_Bloom.
      Definition Self : Ty.t := Ty.path "alloy_primitives::bits::bloom::Bloom".
      
      (*             $crate::private::derive_more::AsRef *)
      Definition as_ref (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.borrow (|
              Pointer.Kind.Ref,
              M.deref (|
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.SubPointer.get_struct_tuple_field (|
                    M.deref (| M.read (| self |) |),
                    "alloy_primitives::bits::bloom::Bloom",
                    0
                  |)
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::AsRef"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [
            Ty.apply
              (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
              [ Value.Integer IntegerKind.Usize 256 ]
              []
          ]
          Self
          (* Instance *) [ ("as_ref", InstanceField.Method as_ref) ].
    End Impl_core_convert_AsRef_alloy_primitives_bits_fixed_FixedBytes_Usize_256_for_alloy_primitives_bits_bloom_Bloom.
    
    Module Impl_core_ops_bit_BitAnd_alloy_primitives_bits_bloom_Bloom_for_alloy_primitives_bits_bloom_Bloom.
      Definition Self : Ty.t := Ty.path "alloy_primitives::bits::bloom::Bloom".
      
      (*             $crate::private::derive_more::BitAnd *)
      Definition _Output : Ty.t := Ty.path "alloy_primitives::bits::bloom::Bloom".
      
      (*             $crate::private::derive_more::BitAnd *)
      Definition bitand (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            Value.StructTuple
              "alloy_primitives::bits::bloom::Bloom"
              [
                M.call_closure (|
                  Ty.apply
                    (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                    [ Value.Integer IntegerKind.Usize 256 ]
                    [],
                  M.get_trait_method (|
                    "core::ops::bit::BitAnd",
                    Ty.apply
                      (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                      [ Value.Integer IntegerKind.Usize 256 ]
                      [],
                    [],
                    [
                      Ty.apply
                        (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                        [ Value.Integer IntegerKind.Usize 256 ]
                        []
                    ],
                    "bitand",
                    [],
                    []
                  |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "alloy_primitives::bits::bloom::Bloom",
                        0
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        rhs,
                        "alloy_primitives::bits::bloom::Bloom",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitAnd"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "alloy_primitives::bits::bloom::Bloom" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("bitand", InstanceField.Method bitand) ].
    End Impl_core_ops_bit_BitAnd_alloy_primitives_bits_bloom_Bloom_for_alloy_primitives_bits_bloom_Bloom.
    
    Module Impl_core_ops_bit_BitAndAssign_alloy_primitives_bits_bloom_Bloom_for_alloy_primitives_bits_bloom_Bloom.
      Definition Self : Ty.t := Ty.path "alloy_primitives::bits::bloom::Bloom".
      
      (*             $crate::private::derive_more::BitAndAssign *)
      Definition bitand_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            M.read (|
              let~ _ : Ty.tuple [] :=
                M.alloc (|
                  M.call_closure (|
                    Ty.tuple [],
                    M.get_trait_method (|
                      "core::ops::bit::BitAndAssign",
                      Ty.apply
                        (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                        [ Value.Integer IntegerKind.Usize 256 ]
                        [],
                      [],
                      [
                        Ty.apply
                          (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                          [ Value.Integer IntegerKind.Usize 256 ]
                          []
                      ],
                      "bitand_assign",
                      [],
                      []
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.MutRef,
                        M.SubPointer.get_struct_tuple_field (|
                          M.deref (| M.read (| self |) |),
                          "alloy_primitives::bits::bloom::Bloom",
                          0
                        |)
                      |);
                      M.read (|
                        M.SubPointer.get_struct_tuple_field (|
                          rhs,
                          "alloy_primitives::bits::bloom::Bloom",
                          0
                        |)
                      |)
                    ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitAndAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "alloy_primitives::bits::bloom::Bloom" ]
          Self
          (* Instance *) [ ("bitand_assign", InstanceField.Method bitand_assign) ].
    End Impl_core_ops_bit_BitAndAssign_alloy_primitives_bits_bloom_Bloom_for_alloy_primitives_bits_bloom_Bloom.
    
    Module Impl_core_ops_bit_BitOr_alloy_primitives_bits_bloom_Bloom_for_alloy_primitives_bits_bloom_Bloom.
      Definition Self : Ty.t := Ty.path "alloy_primitives::bits::bloom::Bloom".
      
      (*             $crate::private::derive_more::BitOr *)
      Definition _Output : Ty.t := Ty.path "alloy_primitives::bits::bloom::Bloom".
      
      (*             $crate::private::derive_more::BitOr *)
      Definition bitor (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            Value.StructTuple
              "alloy_primitives::bits::bloom::Bloom"
              [
                M.call_closure (|
                  Ty.apply
                    (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                    [ Value.Integer IntegerKind.Usize 256 ]
                    [],
                  M.get_trait_method (|
                    "core::ops::bit::BitOr",
                    Ty.apply
                      (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                      [ Value.Integer IntegerKind.Usize 256 ]
                      [],
                    [],
                    [
                      Ty.apply
                        (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                        [ Value.Integer IntegerKind.Usize 256 ]
                        []
                    ],
                    "bitor",
                    [],
                    []
                  |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "alloy_primitives::bits::bloom::Bloom",
                        0
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        rhs,
                        "alloy_primitives::bits::bloom::Bloom",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitOr"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "alloy_primitives::bits::bloom::Bloom" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("bitor", InstanceField.Method bitor) ].
    End Impl_core_ops_bit_BitOr_alloy_primitives_bits_bloom_Bloom_for_alloy_primitives_bits_bloom_Bloom.
    
    Module Impl_core_ops_bit_BitOrAssign_alloy_primitives_bits_bloom_Bloom_for_alloy_primitives_bits_bloom_Bloom.
      Definition Self : Ty.t := Ty.path "alloy_primitives::bits::bloom::Bloom".
      
      (*             $crate::private::derive_more::BitOrAssign *)
      Definition bitor_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            M.read (|
              let~ _ : Ty.tuple [] :=
                M.alloc (|
                  M.call_closure (|
                    Ty.tuple [],
                    M.get_trait_method (|
                      "core::ops::bit::BitOrAssign",
                      Ty.apply
                        (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                        [ Value.Integer IntegerKind.Usize 256 ]
                        [],
                      [],
                      [
                        Ty.apply
                          (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                          [ Value.Integer IntegerKind.Usize 256 ]
                          []
                      ],
                      "bitor_assign",
                      [],
                      []
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.MutRef,
                        M.SubPointer.get_struct_tuple_field (|
                          M.deref (| M.read (| self |) |),
                          "alloy_primitives::bits::bloom::Bloom",
                          0
                        |)
                      |);
                      M.read (|
                        M.SubPointer.get_struct_tuple_field (|
                          rhs,
                          "alloy_primitives::bits::bloom::Bloom",
                          0
                        |)
                      |)
                    ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitOrAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "alloy_primitives::bits::bloom::Bloom" ]
          Self
          (* Instance *) [ ("bitor_assign", InstanceField.Method bitor_assign) ].
    End Impl_core_ops_bit_BitOrAssign_alloy_primitives_bits_bloom_Bloom_for_alloy_primitives_bits_bloom_Bloom.
    
    Module Impl_core_ops_bit_BitXor_alloy_primitives_bits_bloom_Bloom_for_alloy_primitives_bits_bloom_Bloom.
      Definition Self : Ty.t := Ty.path "alloy_primitives::bits::bloom::Bloom".
      
      (*             $crate::private::derive_more::BitXor *)
      Definition _Output : Ty.t := Ty.path "alloy_primitives::bits::bloom::Bloom".
      
      (*             $crate::private::derive_more::BitXor *)
      Definition bitxor (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            Value.StructTuple
              "alloy_primitives::bits::bloom::Bloom"
              [
                M.call_closure (|
                  Ty.apply
                    (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                    [ Value.Integer IntegerKind.Usize 256 ]
                    [],
                  M.get_trait_method (|
                    "core::ops::bit::BitXor",
                    Ty.apply
                      (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                      [ Value.Integer IntegerKind.Usize 256 ]
                      [],
                    [],
                    [
                      Ty.apply
                        (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                        [ Value.Integer IntegerKind.Usize 256 ]
                        []
                    ],
                    "bitxor",
                    [],
                    []
                  |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "alloy_primitives::bits::bloom::Bloom",
                        0
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        rhs,
                        "alloy_primitives::bits::bloom::Bloom",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitXor"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "alloy_primitives::bits::bloom::Bloom" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("bitxor", InstanceField.Method bitxor) ].
    End Impl_core_ops_bit_BitXor_alloy_primitives_bits_bloom_Bloom_for_alloy_primitives_bits_bloom_Bloom.
    
    Module Impl_core_ops_bit_BitXorAssign_alloy_primitives_bits_bloom_Bloom_for_alloy_primitives_bits_bloom_Bloom.
      Definition Self : Ty.t := Ty.path "alloy_primitives::bits::bloom::Bloom".
      
      (*             $crate::private::derive_more::BitXorAssign *)
      Definition bitxor_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            M.read (|
              let~ _ : Ty.tuple [] :=
                M.alloc (|
                  M.call_closure (|
                    Ty.tuple [],
                    M.get_trait_method (|
                      "core::ops::bit::BitXorAssign",
                      Ty.apply
                        (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                        [ Value.Integer IntegerKind.Usize 256 ]
                        [],
                      [],
                      [
                        Ty.apply
                          (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                          [ Value.Integer IntegerKind.Usize 256 ]
                          []
                      ],
                      "bitxor_assign",
                      [],
                      []
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.MutRef,
                        M.SubPointer.get_struct_tuple_field (|
                          M.deref (| M.read (| self |) |),
                          "alloy_primitives::bits::bloom::Bloom",
                          0
                        |)
                      |);
                      M.read (|
                        M.SubPointer.get_struct_tuple_field (|
                          rhs,
                          "alloy_primitives::bits::bloom::Bloom",
                          0
                        |)
                      |)
                    ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitXorAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "alloy_primitives::bits::bloom::Bloom" ]
          Self
          (* Instance *) [ ("bitxor_assign", InstanceField.Method bitxor_assign) ].
    End Impl_core_ops_bit_BitXorAssign_alloy_primitives_bits_bloom_Bloom_for_alloy_primitives_bits_bloom_Bloom.
    
    Module Impl_core_ops_bit_Not_for_alloy_primitives_bits_bloom_Bloom.
      Definition Self : Ty.t := Ty.path "alloy_primitives::bits::bloom::Bloom".
      
      (*             $crate::private::derive_more::Not *)
      Definition _Output : Ty.t := Ty.path "alloy_primitives::bits::bloom::Bloom".
      
      (*             $crate::private::derive_more::Not *)
      Definition not (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructTuple
              "alloy_primitives::bits::bloom::Bloom"
              [
                M.call_closure (|
                  Ty.apply
                    (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                    [ Value.Integer IntegerKind.Usize 256 ]
                    [],
                  M.get_trait_method (|
                    "core::ops::bit::Not",
                    Ty.apply
                      (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                      [ Value.Integer IntegerKind.Usize 256 ]
                      [],
                    [],
                    [],
                    "not",
                    [],
                    []
                  |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "alloy_primitives::bits::bloom::Bloom",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Not"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("not", InstanceField.Method not) ].
    End Impl_core_ops_bit_Not_for_alloy_primitives_bits_bloom_Bloom.
    
    Module Impl_core_ops_deref_Deref_for_alloy_primitives_bits_bloom_Bloom.
      Definition Self : Ty.t := Ty.path "alloy_primitives::bits::bloom::Bloom".
      
      (*             $crate::private::derive_more::Deref *)
      Definition _Target : Ty.t :=
        Ty.apply
          (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
          [ Value.Integer IntegerKind.Usize 256 ]
          [].
      
      (*             $crate::private::derive_more::Deref *)
      Definition deref (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.borrow (|
              Pointer.Kind.Ref,
              M.deref (|
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.SubPointer.get_struct_tuple_field (|
                    M.deref (| M.read (| self |) |),
                    "alloy_primitives::bits::bloom::Bloom",
                    0
                  |)
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::deref::Deref"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *)
          [ ("Target", InstanceField.Ty _Target); ("deref", InstanceField.Method deref) ].
    End Impl_core_ops_deref_Deref_for_alloy_primitives_bits_bloom_Bloom.
    
    Module Impl_core_ops_deref_DerefMut_for_alloy_primitives_bits_bloom_Bloom.
      Definition Self : Ty.t := Ty.path "alloy_primitives::bits::bloom::Bloom".
      
      (*             $crate::private::derive_more::DerefMut *)
      Definition deref_mut (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.borrow (|
              Pointer.Kind.MutRef,
              M.deref (|
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.MutRef,
                      M.SubPointer.get_struct_tuple_field (|
                        M.deref (| M.read (| self |) |),
                        "alloy_primitives::bits::bloom::Bloom",
                        0
                      |)
                    |)
                  |)
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::deref::DerefMut"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [ ("deref_mut", InstanceField.Method deref_mut) ].
    End Impl_core_ops_deref_DerefMut_for_alloy_primitives_bits_bloom_Bloom.
    
    Module Impl_core_convert_From_alloy_primitives_bits_fixed_FixedBytes_Usize_256_for_alloy_primitives_bits_bloom_Bloom.
      Definition Self : Ty.t := Ty.path "alloy_primitives::bits::bloom::Bloom".
      
      (*             $crate::private::derive_more::From *)
      Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            Value.StructTuple "alloy_primitives::bits::bloom::Bloom" [ M.read (| value |) ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [
            Ty.apply
              (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
              [ Value.Integer IntegerKind.Usize 256 ]
              []
          ]
          Self
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_alloy_primitives_bits_fixed_FixedBytes_Usize_256_for_alloy_primitives_bits_bloom_Bloom.
    
    Module Impl_core_str_traits_FromStr_for_alloy_primitives_bits_bloom_Bloom.
      Definition Self : Ty.t := Ty.path "alloy_primitives::bits::bloom::Bloom".
      
      (*             $crate::private::derive_more::FromStr *)
      Definition _Err : Ty.t :=
        Ty.associated_in_trait
          "core::str::traits::FromStr"
          []
          []
          (Ty.apply
            (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
            [ Value.Integer IntegerKind.Usize 256 ]
            [])
          "Err".
      
      (*             $crate::private::derive_more::FromStr *)
      Definition from_str (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ src ] =>
          ltac:(M.monadic
            (let src := M.alloc (| src |) in
            M.catch_return (|
              ltac:(M.monadic
                (Value.StructTuple
                  "core::result::Result::Ok"
                  [
                    Value.StructTuple
                      "alloy_primitives::bits::bloom::Bloom"
                      [
                        M.read (|
                          M.match_operator (|
                            Some
                              (Ty.apply
                                (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                                [ Value.Integer IntegerKind.Usize 256 ]
                                []),
                            M.alloc (|
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "core::ops::control_flow::ControlFlow")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [
                                        Ty.path "core::convert::Infallible";
                                        Ty.path "const_hex::error::FromHexError"
                                      ];
                                    Ty.apply
                                      (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                                      [ Value.Integer IntegerKind.Usize 256 ]
                                      []
                                  ],
                                M.get_trait_method (|
                                  "core::ops::try_trait::Try",
                                  Ty.apply
                                    (Ty.path "core::result::Result")
                                    []
                                    [
                                      Ty.apply
                                        (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                                        [ Value.Integer IntegerKind.Usize 256 ]
                                        [];
                                      Ty.path "const_hex::error::FromHexError"
                                    ],
                                  [],
                                  [],
                                  "branch",
                                  [],
                                  []
                                |),
                                [
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [
                                        Ty.apply
                                          (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                                          [ Value.Integer IntegerKind.Usize 256 ]
                                          [];
                                        Ty.path "const_hex::error::FromHexError"
                                      ],
                                    M.get_trait_method (|
                                      "core::str::traits::FromStr",
                                      Ty.apply
                                        (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                                        [ Value.Integer IntegerKind.Usize 256 ]
                                        [],
                                      [],
                                      [],
                                      "from_str",
                                      [],
                                      []
                                    |),
                                    [
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.deref (| M.read (| src |) |)
                                      |)
                                    ]
                                  |)
                                ]
                              |)
                            |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Break",
                                      0
                                    |) in
                                  let residual := M.copy (| γ0_0 |) in
                                  M.alloc (|
                                    M.never_to_any (|
                                      M.read (|
                                        M.return_ (|
                                          M.call_closure (|
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              []
                                              [
                                                Ty.path "alloy_primitives::bits::bloom::Bloom";
                                                Ty.path "const_hex::error::FromHexError"
                                              ],
                                            M.get_trait_method (|
                                              "core::ops::try_trait::FromResidual",
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                []
                                                [
                                                  Ty.path "alloy_primitives::bits::bloom::Bloom";
                                                  Ty.path "const_hex::error::FromHexError"
                                                ],
                                              [],
                                              [
                                                Ty.apply
                                                  (Ty.path "core::result::Result")
                                                  []
                                                  [
                                                    Ty.path "core::convert::Infallible";
                                                    Ty.path "const_hex::error::FromHexError"
                                                  ]
                                              ],
                                              "from_residual",
                                              [],
                                              []
                                            |),
                                            [ M.read (| residual |) ]
                                          |)
                                        |)
                                      |)
                                    |)
                                  |)));
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Continue",
                                      0
                                    |) in
                                  let val := M.copy (| γ0_0 |) in
                                  val))
                            ]
                          |)
                        |)
                      ]
                  ]))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::str::traits::FromStr"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *)
          [ ("Err", InstanceField.Ty _Err); ("from_str", InstanceField.Method from_str) ].
    End Impl_core_str_traits_FromStr_for_alloy_primitives_bits_bloom_Bloom.
    
    Module Impl_core_ops_index_Index_where_core_ops_index_Index_alloy_primitives_bits_fixed_FixedBytes_Usize_256___IdxT___IdxT_for_alloy_primitives_bits_bloom_Bloom.
      Definition Self (__IdxT : Ty.t) : Ty.t := Ty.path "alloy_primitives::bits::bloom::Bloom".
      
      (*             $crate::private::derive_more::Index *)
      Definition _Output (__IdxT : Ty.t) : Ty.t :=
        Ty.associated_in_trait
          "core::ops::index::Index"
          []
          [ __IdxT ]
          (Ty.apply
            (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
            [ Value.Integer IntegerKind.Usize 256 ]
            [])
          "Output".
      
      (*             $crate::private::derive_more::Index *)
      Definition index (__IdxT : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self __IdxT in
        match ε, τ, α with
        | [], [], [ self; idx ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let idx := M.alloc (| idx |) in
            M.borrow (|
              Pointer.Kind.Ref,
              M.deref (|
                M.call_closure (|
                  Ty.apply
                    (Ty.path "&")
                    []
                    [
                      Ty.associated_in_trait
                        "core::ops::index::Index"
                        []
                        [ __IdxT ]
                        (Ty.apply
                          (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                          [ Value.Integer IntegerKind.Usize 256 ]
                          [])
                        "Output"
                    ],
                  M.get_trait_method (|
                    "core::ops::index::Index",
                    Ty.apply
                      (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                      [ Value.Integer IntegerKind.Usize 256 ]
                      [],
                    [],
                    [ __IdxT ],
                    "index",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_tuple_field (|
                            M.deref (| M.read (| self |) |),
                            "alloy_primitives::bits::bloom::Bloom",
                            0
                          |)
                        |)
                      |)
                    |);
                    M.read (| idx |)
                  ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (__IdxT : Ty.t),
        M.IsTraitInstance
          "core::ops::index::Index"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ __IdxT ]
          (Self __IdxT)
          (* Instance *)
          [
            ("Output", InstanceField.Ty (_Output __IdxT));
            ("index", InstanceField.Method (index __IdxT))
          ].
    End Impl_core_ops_index_Index_where_core_ops_index_Index_alloy_primitives_bits_fixed_FixedBytes_Usize_256___IdxT___IdxT_for_alloy_primitives_bits_bloom_Bloom.
    
    Module Impl_core_ops_index_IndexMut_where_core_ops_index_IndexMut_alloy_primitives_bits_fixed_FixedBytes_Usize_256___IdxT___IdxT_for_alloy_primitives_bits_bloom_Bloom.
      Definition Self (__IdxT : Ty.t) : Ty.t := Ty.path "alloy_primitives::bits::bloom::Bloom".
      
      (*             $crate::private::derive_more::IndexMut *)
      Definition index_mut
          (__IdxT : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self __IdxT in
        match ε, τ, α with
        | [], [], [ self; idx ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let idx := M.alloc (| idx |) in
            M.borrow (|
              Pointer.Kind.MutRef,
              M.deref (|
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.deref (|
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "&mut")
                        []
                        [
                          Ty.associated_in_trait
                            "core::ops::index::Index"
                            []
                            [ __IdxT ]
                            (Ty.apply
                              (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                              [ Value.Integer IntegerKind.Usize 256 ]
                              [])
                            "Output"
                        ],
                      M.get_trait_method (|
                        "core::ops::index::IndexMut",
                        Ty.apply
                          (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                          [ Value.Integer IntegerKind.Usize 256 ]
                          [],
                        [],
                        [ __IdxT ],
                        "index_mut",
                        [],
                        []
                      |),
                      [
                        M.borrow (|
                          Pointer.Kind.MutRef,
                          M.deref (|
                            M.borrow (|
                              Pointer.Kind.MutRef,
                              M.SubPointer.get_struct_tuple_field (|
                                M.deref (| M.read (| self |) |),
                                "alloy_primitives::bits::bloom::Bloom",
                                0
                              |)
                            |)
                          |)
                        |);
                        M.read (| idx |)
                      ]
                    |)
                  |)
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (__IdxT : Ty.t),
        M.IsTraitInstance
          "core::ops::index::IndexMut"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ __IdxT ]
          (Self __IdxT)
          (* Instance *) [ ("index_mut", InstanceField.Method (index_mut __IdxT)) ].
    End Impl_core_ops_index_IndexMut_where_core_ops_index_IndexMut_alloy_primitives_bits_fixed_FixedBytes_Usize_256___IdxT___IdxT_for_alloy_primitives_bits_bloom_Bloom.
    
    Module Impl_core_convert_From_alloy_primitives_bits_bloom_Bloom_for_alloy_primitives_bits_fixed_FixedBytes_Usize_256.
      Definition Self : Ty.t :=
        Ty.apply
          (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
          [ Value.Integer IntegerKind.Usize 256 ]
          [].
      
      (*             $crate::private::derive_more::Into *)
      Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                [ Value.Integer IntegerKind.Usize 256 ]
                [],
              M.get_trait_method (|
                "core::convert::From",
                Ty.apply
                  (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                  [ Value.Integer IntegerKind.Usize 256 ]
                  [],
                [],
                [
                  Ty.apply
                    (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                    [ Value.Integer IntegerKind.Usize 256 ]
                    []
                ],
                "from",
                [],
                []
              |),
              [
                M.read (|
                  M.SubPointer.get_struct_tuple_field (|
                    value,
                    "alloy_primitives::bits::bloom::Bloom",
                    0
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "alloy_primitives::bits::bloom::Bloom" ]
          Self
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_alloy_primitives_bits_bloom_Bloom_for_alloy_primitives_bits_fixed_FixedBytes_Usize_256.
    
    Module Impl_core_iter_traits_collect_IntoIterator_where_core_iter_traits_collect_IntoIterator_alloy_primitives_bits_fixed_FixedBytes_Usize_256_for_alloy_primitives_bits_bloom_Bloom.
      Definition Self : Ty.t := Ty.path "alloy_primitives::bits::bloom::Bloom".
      
      (*             $crate::private::derive_more::IntoIterator *)
      Definition _Item : Ty.t :=
        Ty.associated_in_trait
          "core::iter::traits::collect::IntoIterator"
          []
          []
          (Ty.apply
            (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
            [ Value.Integer IntegerKind.Usize 256 ]
            [])
          "Item".
      
      (*             $crate::private::derive_more::IntoIterator *)
      Definition _IntoIter : Ty.t :=
        Ty.associated_in_trait
          "core::iter::traits::collect::IntoIterator"
          []
          []
          (Ty.apply
            (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
            [ Value.Integer IntegerKind.Usize 256 ]
            [])
          "IntoIter".
      
      (*             $crate::private::derive_more::IntoIterator *)
      Definition into_iter (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "core::array::iter::IntoIter")
                [ Value.Integer IntegerKind.Usize 256 ]
                [ Ty.path "u8" ],
              M.get_trait_method (|
                "core::iter::traits::collect::IntoIterator",
                Ty.apply
                  (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                  [ Value.Integer IntegerKind.Usize 256 ]
                  [],
                [],
                [],
                "into_iter",
                [],
                []
              |),
              [
                M.read (|
                  M.SubPointer.get_struct_tuple_field (|
                    self,
                    "alloy_primitives::bits::bloom::Bloom",
                    0
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::iter::traits::collect::IntoIterator"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *)
          [
            ("Item", InstanceField.Ty _Item);
            ("IntoIter", InstanceField.Ty _IntoIter);
            ("into_iter", InstanceField.Method into_iter)
          ].
    End Impl_core_iter_traits_collect_IntoIterator_where_core_iter_traits_collect_IntoIterator_alloy_primitives_bits_fixed_FixedBytes_Usize_256_for_alloy_primitives_bits_bloom_Bloom.
    
    Module Impl_core_iter_traits_collect_IntoIterator_where_core_iter_traits_collect_IntoIterator_ref__alloy_primitives_bits_fixed_FixedBytes_Usize_256_for_ref__alloy_primitives_bits_bloom_Bloom.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "&") [] [ Ty.path "alloy_primitives::bits::bloom::Bloom" ].
      
      (*             $crate::private::derive_more::IntoIterator *)
      Definition _Item : Ty.t :=
        Ty.associated_in_trait
          "core::iter::traits::collect::IntoIterator"
          []
          []
          (Ty.apply
            (Ty.path "&")
            []
            [
              Ty.apply
                (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                [ Value.Integer IntegerKind.Usize 256 ]
                []
            ])
          "Item".
      
      (*             $crate::private::derive_more::IntoIterator *)
      Definition _IntoIter : Ty.t :=
        Ty.associated_in_trait
          "core::iter::traits::collect::IntoIterator"
          []
          []
          (Ty.apply
            (Ty.path "&")
            []
            [
              Ty.apply
                (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                [ Value.Integer IntegerKind.Usize 256 ]
                []
            ])
          "IntoIter".
      
      (*             $crate::private::derive_more::IntoIterator *)
      Definition into_iter (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.associated_in_trait
                "core::iter::traits::collect::IntoIterator"
                []
                []
                (Ty.apply
                  (Ty.path "&")
                  []
                  [
                    Ty.apply
                      (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                      [ Value.Integer IntegerKind.Usize 256 ]
                      []
                  ])
                "IntoIter",
              M.get_trait_method (|
                "core::iter::traits::collect::IntoIterator",
                Ty.apply
                  (Ty.path "&")
                  []
                  [
                    Ty.apply
                      (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                      [ Value.Integer IntegerKind.Usize 256 ]
                      []
                  ],
                [],
                [],
                "into_iter",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_tuple_field (|
                        M.deref (| M.read (| self |) |),
                        "alloy_primitives::bits::bloom::Bloom",
                        0
                      |)
                    |)
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::iter::traits::collect::IntoIterator"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *)
          [
            ("Item", InstanceField.Ty _Item);
            ("IntoIter", InstanceField.Ty _IntoIter);
            ("into_iter", InstanceField.Method into_iter)
          ].
    End Impl_core_iter_traits_collect_IntoIterator_where_core_iter_traits_collect_IntoIterator_ref__alloy_primitives_bits_fixed_FixedBytes_Usize_256_for_ref__alloy_primitives_bits_bloom_Bloom.
    
    Module Impl_core_iter_traits_collect_IntoIterator_where_core_iter_traits_collect_IntoIterator_ref_mut_alloy_primitives_bits_fixed_FixedBytes_Usize_256_for_ref_mut_alloy_primitives_bits_bloom_Bloom.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "&mut") [] [ Ty.path "alloy_primitives::bits::bloom::Bloom" ].
      
      (*             $crate::private::derive_more::IntoIterator *)
      Definition _Item : Ty.t :=
        Ty.associated_in_trait
          "core::iter::traits::collect::IntoIterator"
          []
          []
          (Ty.apply
            (Ty.path "&mut")
            []
            [
              Ty.apply
                (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                [ Value.Integer IntegerKind.Usize 256 ]
                []
            ])
          "Item".
      
      (*             $crate::private::derive_more::IntoIterator *)
      Definition _IntoIter : Ty.t :=
        Ty.associated_in_trait
          "core::iter::traits::collect::IntoIterator"
          []
          []
          (Ty.apply
            (Ty.path "&mut")
            []
            [
              Ty.apply
                (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                [ Value.Integer IntegerKind.Usize 256 ]
                []
            ])
          "IntoIter".
      
      (*             $crate::private::derive_more::IntoIterator *)
      Definition into_iter (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.associated_in_trait
                "core::iter::traits::collect::IntoIterator"
                []
                []
                (Ty.apply
                  (Ty.path "&mut")
                  []
                  [
                    Ty.apply
                      (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                      [ Value.Integer IntegerKind.Usize 256 ]
                      []
                  ])
                "IntoIter",
              M.get_trait_method (|
                "core::iter::traits::collect::IntoIterator",
                Ty.apply
                  (Ty.path "&mut")
                  []
                  [
                    Ty.apply
                      (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                      [ Value.Integer IntegerKind.Usize 256 ]
                      []
                  ],
                [],
                [],
                "into_iter",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.MutRef,
                      M.SubPointer.get_struct_tuple_field (|
                        M.deref (| M.read (| self |) |),
                        "alloy_primitives::bits::bloom::Bloom",
                        0
                      |)
                    |)
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::iter::traits::collect::IntoIterator"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *)
          [
            ("Item", InstanceField.Ty _Item);
            ("IntoIter", InstanceField.Ty _IntoIter);
            ("into_iter", InstanceField.Method into_iter)
          ].
    End Impl_core_iter_traits_collect_IntoIterator_where_core_iter_traits_collect_IntoIterator_ref_mut_alloy_primitives_bits_fixed_FixedBytes_Usize_256_for_ref_mut_alloy_primitives_bits_bloom_Bloom.
    
    Module Impl_core_fmt_LowerHex_for_alloy_primitives_bits_bloom_Bloom.
      Definition Self : Ty.t := Ty.path "alloy_primitives::bits::bloom::Bloom".
      
      (*             $crate::private::derive_more::LowerHex *)
      Definition fmt (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; __derive_more_f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let __derive_more_f := M.alloc (| __derive_more_f |) in
            M.read (|
              let~ _0 :
                  Ty.apply
                    (Ty.path "&")
                    []
                    [
                      Ty.apply
                        (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                        [ Value.Integer IntegerKind.Usize 256 ]
                        []
                    ] :=
                M.alloc (|
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.SubPointer.get_struct_tuple_field (|
                      M.deref (| M.read (| self |) |),
                      "alloy_primitives::bits::bloom::Bloom",
                      0
                    |)
                  |)
                |) in
              M.alloc (|
                M.call_closure (|
                  Ty.apply
                    (Ty.path "core::result::Result")
                    []
                    [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                  M.get_trait_method (|
                    "core::fmt::LowerHex",
                    Ty.apply
                      (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                      [ Value.Integer IntegerKind.Usize 256 ]
                      [],
                    [],
                    [],
                    "fmt",
                    [],
                    []
                  |),
                  [
                    M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| _0 |) |) |);
                    M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| __derive_more_f |) |) |)
                  ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::LowerHex"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
    End Impl_core_fmt_LowerHex_for_alloy_primitives_bits_bloom_Bloom.
    
    Module Impl_core_fmt_UpperHex_for_alloy_primitives_bits_bloom_Bloom.
      Definition Self : Ty.t := Ty.path "alloy_primitives::bits::bloom::Bloom".
      
      (*             $crate::private::derive_more::UpperHex *)
      Definition fmt (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; __derive_more_f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let __derive_more_f := M.alloc (| __derive_more_f |) in
            M.read (|
              let~ _0 :
                  Ty.apply
                    (Ty.path "&")
                    []
                    [
                      Ty.apply
                        (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                        [ Value.Integer IntegerKind.Usize 256 ]
                        []
                    ] :=
                M.alloc (|
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.SubPointer.get_struct_tuple_field (|
                      M.deref (| M.read (| self |) |),
                      "alloy_primitives::bits::bloom::Bloom",
                      0
                    |)
                  |)
                |) in
              M.alloc (|
                M.call_closure (|
                  Ty.apply
                    (Ty.path "core::result::Result")
                    []
                    [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                  M.get_trait_method (|
                    "core::fmt::UpperHex",
                    Ty.apply
                      (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                      [ Value.Integer IntegerKind.Usize 256 ]
                      [],
                    [],
                    [],
                    "fmt",
                    [],
                    []
                  |),
                  [
                    M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| _0 |) |) |);
                    M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| __derive_more_f |) |) |)
                  ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::UpperHex"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
    End Impl_core_fmt_UpperHex_for_alloy_primitives_bits_bloom_Bloom.
    
    Module Impl_core_fmt_Display_for_alloy_primitives_bits_bloom_Bloom.
      Definition Self : Ty.t := Ty.path "alloy_primitives::bits::bloom::Bloom".
      
      (*             $crate::private::derive_more::Display *)
      Definition fmt (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; __derive_more_f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let __derive_more_f := M.alloc (| __derive_more_f |) in
            M.read (|
              let~ _0 :
                  Ty.apply
                    (Ty.path "&")
                    []
                    [
                      Ty.apply
                        (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                        [ Value.Integer IntegerKind.Usize 256 ]
                        []
                    ] :=
                M.alloc (|
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.SubPointer.get_struct_tuple_field (|
                      M.deref (| M.read (| self |) |),
                      "alloy_primitives::bits::bloom::Bloom",
                      0
                    |)
                  |)
                |) in
              M.alloc (|
                M.call_closure (|
                  Ty.apply
                    (Ty.path "core::result::Result")
                    []
                    [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                  M.get_trait_method (|
                    "core::fmt::Display",
                    Ty.apply
                      (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                      [ Value.Integer IntegerKind.Usize 256 ]
                      [],
                    [],
                    [],
                    "fmt",
                    [],
                    []
                  |),
                  [
                    M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| _0 |) |) |);
                    M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| __derive_more_f |) |) |)
                  ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::Display"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
    End Impl_core_fmt_Display_for_alloy_primitives_bits_bloom_Bloom.
    
    Module Impl_core_convert_From_array_Usize_256_u8_for_alloy_primitives_bits_bloom_Bloom.
      Definition Self : Ty.t := Ty.path "alloy_primitives::bits::bloom::Bloom".
      
      (*
                  fn from(value: [u8; $n]) -> Self {
                      Self($crate::FixedBytes(value))
                  }
      *)
      Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            Value.StructTuple
              "alloy_primitives::bits::bloom::Bloom"
              [ Value.StructTuple "alloy_primitives::bits::fixed::FixedBytes" [ M.read (| value |) ]
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 256 ] [ Ty.path "u8" ] ]
          Self
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_array_Usize_256_u8_for_alloy_primitives_bits_bloom_Bloom.
    
    Module Impl_core_convert_From_alloy_primitives_bits_bloom_Bloom_for_array_Usize_256_u8.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 256 ] [ Ty.path "u8" ].
      
      (*
                  fn from(value: $name) -> Self {
                      value.0 .0
                  }
      *)
      Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            M.read (|
              M.SubPointer.get_struct_tuple_field (|
                M.SubPointer.get_struct_tuple_field (|
                  value,
                  "alloy_primitives::bits::bloom::Bloom",
                  0
                |),
                "alloy_primitives::bits::fixed::FixedBytes",
                0
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "alloy_primitives::bits::bloom::Bloom" ]
          Self
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_alloy_primitives_bits_bloom_Bloom_for_array_Usize_256_u8.
    
    Module Impl_core_convert_From_ref__array_Usize_256_u8_for_alloy_primitives_bits_bloom_Bloom.
      Definition Self : Ty.t := Ty.path "alloy_primitives::bits::bloom::Bloom".
      
      (*
                  fn from(value: &'a [u8; $n]) -> Self {
                      Self($crate::FixedBytes( *value))
                  }
      *)
      Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            Value.StructTuple
              "alloy_primitives::bits::bloom::Bloom"
              [
                Value.StructTuple
                  "alloy_primitives::bits::fixed::FixedBytes"
                  [ M.read (| M.deref (| M.read (| value |) |) |) ]
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [
            Ty.apply
              (Ty.path "&")
              []
              [ Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 256 ] [ Ty.path "u8" ]
              ]
          ]
          Self
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_ref__array_Usize_256_u8_for_alloy_primitives_bits_bloom_Bloom.
    
    Module Impl_core_convert_From_ref_mut_array_Usize_256_u8_for_alloy_primitives_bits_bloom_Bloom.
      Definition Self : Ty.t := Ty.path "alloy_primitives::bits::bloom::Bloom".
      
      (*
                  fn from(value: &'a mut [u8; $n]) -> Self {
                      Self($crate::FixedBytes( *value))
                  }
      *)
      Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            Value.StructTuple
              "alloy_primitives::bits::bloom::Bloom"
              [
                Value.StructTuple
                  "alloy_primitives::bits::fixed::FixedBytes"
                  [ M.read (| M.deref (| M.read (| value |) |) |) ]
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [
            Ty.apply
              (Ty.path "&mut")
              []
              [ Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 256 ] [ Ty.path "u8" ]
              ]
          ]
          Self
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_ref_mut_array_Usize_256_u8_for_alloy_primitives_bits_bloom_Bloom.
    
    Module Impl_core_convert_TryFrom_ref__slice_u8_for_alloy_primitives_bits_bloom_Bloom.
      Definition Self : Ty.t := Ty.path "alloy_primitives::bits::bloom::Bloom".
      
      (*             type Error = $crate::private::core::array::TryFromSliceError; *)
      Definition _Error : Ty.t := Ty.path "core::array::TryFromSliceError".
      
      (*
                  fn try_from(slice: &[u8]) -> Result<Self, Self::Error> {
                      <&Self as $crate::private::TryFrom<&[u8]>>::try_from(slice).copied()
                  }
      *)
      Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ slice ] =>
          ltac:(M.monadic
            (let slice := M.alloc (| slice |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "core::result::Result")
                []
                [
                  Ty.path "alloy_primitives::bits::bloom::Bloom";
                  Ty.path "core::array::TryFromSliceError"
                ],
              M.get_associated_function (|
                Ty.apply
                  (Ty.path "core::result::Result")
                  []
                  [
                    Ty.apply (Ty.path "&") [] [ Ty.path "alloy_primitives::bits::bloom::Bloom" ];
                    Ty.path "core::array::TryFromSliceError"
                  ],
                "copied",
                [],
                []
              |),
              [
                M.call_closure (|
                  Ty.apply
                    (Ty.path "core::result::Result")
                    []
                    [
                      Ty.apply (Ty.path "&") [] [ Ty.path "alloy_primitives::bits::bloom::Bloom" ];
                      Ty.path "core::array::TryFromSliceError"
                    ],
                  M.get_trait_method (|
                    "core::convert::TryFrom",
                    Ty.apply (Ty.path "&") [] [ Ty.path "alloy_primitives::bits::bloom::Bloom" ],
                    [],
                    [ Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
                    ],
                    "try_from",
                    [],
                    []
                  |),
                  [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| slice |) |) |) ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::TryFrom"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ] ]
          Self
          (* Instance *)
          [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
    End Impl_core_convert_TryFrom_ref__slice_u8_for_alloy_primitives_bits_bloom_Bloom.
    
    Module Impl_core_convert_TryFrom_ref_mut_slice_u8_for_alloy_primitives_bits_bloom_Bloom.
      Definition Self : Ty.t := Ty.path "alloy_primitives::bits::bloom::Bloom".
      
      (*             type Error = $crate::private::core::array::TryFromSliceError; *)
      Definition _Error : Ty.t := Ty.path "core::array::TryFromSliceError".
      
      (*
                  fn try_from(slice: &mut [u8]) -> Result<Self, Self::Error> {
                      <Self as $crate::private::TryFrom<&[u8]>>::try_from(&*slice)
                  }
      *)
      Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ slice ] =>
          ltac:(M.monadic
            (let slice := M.alloc (| slice |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "core::result::Result")
                []
                [
                  Ty.path "alloy_primitives::bits::bloom::Bloom";
                  Ty.path "core::array::TryFromSliceError"
                ],
              M.get_trait_method (|
                "core::convert::TryFrom",
                Ty.path "alloy_primitives::bits::bloom::Bloom",
                [],
                [ Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ] ],
                "try_from",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (| M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| slice |) |) |) |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::TryFrom"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ] ]
          Self
          (* Instance *)
          [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
    End Impl_core_convert_TryFrom_ref_mut_slice_u8_for_alloy_primitives_bits_bloom_Bloom.
    
    Module Impl_core_convert_TryFrom_ref__slice_u8_for_ref__alloy_primitives_bits_bloom_Bloom.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "&") [] [ Ty.path "alloy_primitives::bits::bloom::Bloom" ].
      
      (*             type Error = $crate::private::core::array::TryFromSliceError; *)
      Definition _Error : Ty.t := Ty.path "core::array::TryFromSliceError".
      
      (*
                  fn try_from(slice: &'a [u8]) -> Result<&'a $name, Self::Error> {
                      // SAFETY: `$name` is `repr(transparent)` for `FixedBytes<$n>`
                      // and consequently `[u8; $n]`
                      <&[u8; $n] as $crate::private::TryFrom<&[u8]>>::try_from(slice)
                          .map(|array_ref| unsafe { $crate::private::core::mem::transmute(array_ref) })
                  }
      *)
      Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ slice ] =>
          ltac:(M.monadic
            (let slice := M.alloc (| slice |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "core::result::Result")
                []
                [
                  Ty.apply (Ty.path "&") [] [ Ty.path "alloy_primitives::bits::bloom::Bloom" ];
                  Ty.path "core::array::TryFromSliceError"
                ],
              M.get_associated_function (|
                Ty.apply
                  (Ty.path "core::result::Result")
                  []
                  [
                    Ty.apply
                      (Ty.path "&")
                      []
                      [
                        Ty.apply
                          (Ty.path "array")
                          [ Value.Integer IntegerKind.Usize 256 ]
                          [ Ty.path "u8" ]
                      ];
                    Ty.path "core::array::TryFromSliceError"
                  ],
                "map",
                [],
                [
                  Ty.apply (Ty.path "&") [] [ Ty.path "alloy_primitives::bits::bloom::Bloom" ];
                  Ty.function
                    [
                      Ty.tuple
                        [
                          Ty.apply
                            (Ty.path "&")
                            []
                            [
                              Ty.apply
                                (Ty.path "array")
                                [ Value.Integer IntegerKind.Usize 256 ]
                                [ Ty.path "u8" ]
                            ]
                        ]
                    ]
                    (Ty.apply (Ty.path "&") [] [ Ty.path "alloy_primitives::bits::bloom::Bloom" ])
                ]
              |),
              [
                M.call_closure (|
                  Ty.apply
                    (Ty.path "core::result::Result")
                    []
                    [
                      Ty.apply
                        (Ty.path "&")
                        []
                        [
                          Ty.apply
                            (Ty.path "array")
                            [ Value.Integer IntegerKind.Usize 256 ]
                            [ Ty.path "u8" ]
                        ];
                      Ty.path "core::array::TryFromSliceError"
                    ],
                  M.get_trait_method (|
                    "core::convert::TryFrom",
                    Ty.apply
                      (Ty.path "&")
                      []
                      [
                        Ty.apply
                          (Ty.path "array")
                          [ Value.Integer IntegerKind.Usize 256 ]
                          [ Ty.path "u8" ]
                      ],
                    [],
                    [ Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
                    ],
                    "try_from",
                    [],
                    []
                  |),
                  [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| slice |) |) |) ]
                |);
                M.closure
                  (fun γ =>
                    ltac:(M.monadic
                      match γ with
                      | [ α0 ] =>
                        ltac:(M.monadic
                          (M.match_operator (|
                            Some
                              (Ty.function
                                [
                                  Ty.tuple
                                    [
                                      Ty.apply
                                        (Ty.path "&")
                                        []
                                        [
                                          Ty.apply
                                            (Ty.path "array")
                                            [ Value.Integer IntegerKind.Usize 256 ]
                                            [ Ty.path "u8" ]
                                        ]
                                    ]
                                ]
                                (Ty.apply
                                  (Ty.path "&")
                                  []
                                  [ Ty.path "alloy_primitives::bits::bloom::Bloom" ])),
                            M.alloc (| α0 |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let array_ref := M.copy (| γ |) in
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "&")
                                      []
                                      [ Ty.path "alloy_primitives::bits::bloom::Bloom" ],
                                    M.get_function (|
                                      "core::intrinsics::transmute",
                                      [],
                                      [
                                        Ty.apply
                                          (Ty.path "&")
                                          []
                                          [
                                            Ty.apply
                                              (Ty.path "array")
                                              [ Value.Integer IntegerKind.Usize 256 ]
                                              [ Ty.path "u8" ]
                                          ];
                                        Ty.apply
                                          (Ty.path "&")
                                          []
                                          [ Ty.path "alloy_primitives::bits::bloom::Bloom" ]
                                      ]
                                    |),
                                    [ M.read (| array_ref |) ]
                                  |)))
                            ]
                          |)))
                      | _ => M.impossible "wrong number of arguments"
                      end))
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::TryFrom"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ] ]
          Self
          (* Instance *)
          [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
    End Impl_core_convert_TryFrom_ref__slice_u8_for_ref__alloy_primitives_bits_bloom_Bloom.
    
    Module Impl_core_convert_TryFrom_ref_mut_slice_u8_for_ref_mut_alloy_primitives_bits_bloom_Bloom.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "&mut") [] [ Ty.path "alloy_primitives::bits::bloom::Bloom" ].
      
      (*             type Error = $crate::private::core::array::TryFromSliceError; *)
      Definition _Error : Ty.t := Ty.path "core::array::TryFromSliceError".
      
      (*
                  fn try_from(slice: &'a mut [u8]) -> Result<&'a mut $name, Self::Error> {
                      // SAFETY: `$name` is `repr(transparent)` for `FixedBytes<$n>`
                      // and consequently `[u8; $n]`
                      <&mut [u8; $n] as $crate::private::TryFrom<&mut [u8]>>::try_from(slice)
                          .map(|array_ref| unsafe { $crate::private::core::mem::transmute(array_ref) })
                  }
      *)
      Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ slice ] =>
          ltac:(M.monadic
            (let slice := M.alloc (| slice |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "core::result::Result")
                []
                [
                  Ty.apply (Ty.path "&mut") [] [ Ty.path "alloy_primitives::bits::bloom::Bloom" ];
                  Ty.path "core::array::TryFromSliceError"
                ],
              M.get_associated_function (|
                Ty.apply
                  (Ty.path "core::result::Result")
                  []
                  [
                    Ty.apply
                      (Ty.path "&mut")
                      []
                      [
                        Ty.apply
                          (Ty.path "array")
                          [ Value.Integer IntegerKind.Usize 256 ]
                          [ Ty.path "u8" ]
                      ];
                    Ty.path "core::array::TryFromSliceError"
                  ],
                "map",
                [],
                [
                  Ty.apply (Ty.path "&mut") [] [ Ty.path "alloy_primitives::bits::bloom::Bloom" ];
                  Ty.function
                    [
                      Ty.tuple
                        [
                          Ty.apply
                            (Ty.path "&mut")
                            []
                            [
                              Ty.apply
                                (Ty.path "array")
                                [ Value.Integer IntegerKind.Usize 256 ]
                                [ Ty.path "u8" ]
                            ]
                        ]
                    ]
                    (Ty.apply
                      (Ty.path "&mut")
                      []
                      [ Ty.path "alloy_primitives::bits::bloom::Bloom" ])
                ]
              |),
              [
                M.call_closure (|
                  Ty.apply
                    (Ty.path "core::result::Result")
                    []
                    [
                      Ty.apply
                        (Ty.path "&mut")
                        []
                        [
                          Ty.apply
                            (Ty.path "array")
                            [ Value.Integer IntegerKind.Usize 256 ]
                            [ Ty.path "u8" ]
                        ];
                      Ty.path "core::array::TryFromSliceError"
                    ],
                  M.get_trait_method (|
                    "core::convert::TryFrom",
                    Ty.apply
                      (Ty.path "&mut")
                      []
                      [
                        Ty.apply
                          (Ty.path "array")
                          [ Value.Integer IntegerKind.Usize 256 ]
                          [ Ty.path "u8" ]
                      ],
                    [],
                    [
                      Ty.apply
                        (Ty.path "&mut")
                        []
                        [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
                    ],
                    "try_from",
                    [],
                    []
                  |),
                  [ M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| slice |) |) |) ]
                |);
                M.closure
                  (fun γ =>
                    ltac:(M.monadic
                      match γ with
                      | [ α0 ] =>
                        ltac:(M.monadic
                          (M.match_operator (|
                            Some
                              (Ty.function
                                [
                                  Ty.tuple
                                    [
                                      Ty.apply
                                        (Ty.path "&mut")
                                        []
                                        [
                                          Ty.apply
                                            (Ty.path "array")
                                            [ Value.Integer IntegerKind.Usize 256 ]
                                            [ Ty.path "u8" ]
                                        ]
                                    ]
                                ]
                                (Ty.apply
                                  (Ty.path "&mut")
                                  []
                                  [ Ty.path "alloy_primitives::bits::bloom::Bloom" ])),
                            M.alloc (| α0 |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let array_ref := M.copy (| γ |) in
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "&mut")
                                      []
                                      [ Ty.path "alloy_primitives::bits::bloom::Bloom" ],
                                    M.get_function (|
                                      "core::intrinsics::transmute",
                                      [],
                                      [
                                        Ty.apply
                                          (Ty.path "&mut")
                                          []
                                          [
                                            Ty.apply
                                              (Ty.path "array")
                                              [ Value.Integer IntegerKind.Usize 256 ]
                                              [ Ty.path "u8" ]
                                          ];
                                        Ty.apply
                                          (Ty.path "&mut")
                                          []
                                          [ Ty.path "alloy_primitives::bits::bloom::Bloom" ]
                                      ]
                                    |),
                                    [ M.read (| array_ref |) ]
                                  |)))
                            ]
                          |)))
                      | _ => M.impossible "wrong number of arguments"
                      end))
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::TryFrom"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ] ]
          Self
          (* Instance *)
          [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
    End Impl_core_convert_TryFrom_ref_mut_slice_u8_for_ref_mut_alloy_primitives_bits_bloom_Bloom.
    
    Module Impl_core_convert_AsRef_array_Usize_256_u8_for_alloy_primitives_bits_bloom_Bloom.
      Definition Self : Ty.t := Ty.path "alloy_primitives::bits::bloom::Bloom".
      
      (*
                  fn as_ref(&self) -> &[u8; $n] {
                      &self.0 .0
                  }
      *)
      Definition as_ref (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.borrow (|
              Pointer.Kind.Ref,
              M.deref (|
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.SubPointer.get_struct_tuple_field (|
                    M.SubPointer.get_struct_tuple_field (|
                      M.deref (| M.read (| self |) |),
                      "alloy_primitives::bits::bloom::Bloom",
                      0
                    |),
                    "alloy_primitives::bits::fixed::FixedBytes",
                    0
                  |)
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::AsRef"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 256 ] [ Ty.path "u8" ] ]
          Self
          (* Instance *) [ ("as_ref", InstanceField.Method as_ref) ].
    End Impl_core_convert_AsRef_array_Usize_256_u8_for_alloy_primitives_bits_bloom_Bloom.
    
    Module Impl_core_convert_AsMut_array_Usize_256_u8_for_alloy_primitives_bits_bloom_Bloom.
      Definition Self : Ty.t := Ty.path "alloy_primitives::bits::bloom::Bloom".
      
      (*
                  fn as_mut(&mut self) -> &mut [u8; $n] {
                      &mut self.0 .0
                  }
      *)
      Definition as_mut (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.borrow (|
              Pointer.Kind.MutRef,
              M.deref (|
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.MutRef,
                      M.SubPointer.get_struct_tuple_field (|
                        M.SubPointer.get_struct_tuple_field (|
                          M.deref (| M.read (| self |) |),
                          "alloy_primitives::bits::bloom::Bloom",
                          0
                        |),
                        "alloy_primitives::bits::fixed::FixedBytes",
                        0
                      |)
                    |)
                  |)
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::AsMut"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 256 ] [ Ty.path "u8" ] ]
          Self
          (* Instance *) [ ("as_mut", InstanceField.Method as_mut) ].
    End Impl_core_convert_AsMut_array_Usize_256_u8_for_alloy_primitives_bits_bloom_Bloom.
    
    Module Impl_core_convert_AsRef_slice_u8_for_alloy_primitives_bits_bloom_Bloom.
      Definition Self : Ty.t := Ty.path "alloy_primitives::bits::bloom::Bloom".
      
      (*
                  fn as_ref(&self) -> &[u8] {
                      &self.0 .0
                  }
      *)
      Definition as_ref (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            (* Unsize *)
            M.pointer_coercion
              (M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.SubPointer.get_struct_tuple_field (|
                      M.SubPointer.get_struct_tuple_field (|
                        M.deref (| M.read (| self |) |),
                        "alloy_primitives::bits::bloom::Bloom",
                        0
                      |),
                      "alloy_primitives::bits::fixed::FixedBytes",
                      0
                    |)
                  |)
                |)
              |))))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::AsRef"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
          Self
          (* Instance *) [ ("as_ref", InstanceField.Method as_ref) ].
    End Impl_core_convert_AsRef_slice_u8_for_alloy_primitives_bits_bloom_Bloom.
    
    Module Impl_core_convert_AsMut_slice_u8_for_alloy_primitives_bits_bloom_Bloom.
      Definition Self : Ty.t := Ty.path "alloy_primitives::bits::bloom::Bloom".
      
      (*
                  fn as_mut(&mut self) -> &mut [u8] {
                      &mut self.0 .0
                  }
      *)
      Definition as_mut (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.borrow (|
              Pointer.Kind.MutRef,
              M.deref (|
                (* Unsize *)
                M.pointer_coercion
                  (M.borrow (|
                    Pointer.Kind.MutRef,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.MutRef,
                        M.SubPointer.get_struct_tuple_field (|
                          M.SubPointer.get_struct_tuple_field (|
                            M.deref (| M.read (| self |) |),
                            "alloy_primitives::bits::bloom::Bloom",
                            0
                          |),
                          "alloy_primitives::bits::fixed::FixedBytes",
                          0
                        |)
                      |)
                    |)
                  |))
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::AsMut"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
          Self
          (* Instance *) [ ("as_mut", InstanceField.Method as_mut) ].
    End Impl_core_convert_AsMut_slice_u8_for_alloy_primitives_bits_bloom_Bloom.
    
    Module Impl_core_fmt_Debug_for_alloy_primitives_bits_bloom_Bloom.
      Definition Self : Ty.t := Ty.path "alloy_primitives::bits::bloom::Bloom".
      
      (*
                  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                      $crate::private::core::fmt::Debug::fmt(&self.0, f)
                  }
      *)
      Definition fmt (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "core::result::Result")
                []
                [ Ty.tuple []; Ty.path "core::fmt::Error" ],
              M.get_trait_method (|
                "core::fmt::Debug",
                Ty.apply
                  (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                  [ Value.Integer IntegerKind.Usize 256 ]
                  [],
                [],
                [],
                "fmt",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_tuple_field (|
                        M.deref (| M.read (| self |) |),
                        "alloy_primitives::bits::bloom::Bloom",
                        0
                      |)
                    |)
                  |)
                |);
                M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::Debug"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
    End Impl_core_fmt_Debug_for_alloy_primitives_bits_bloom_Bloom.
    
    Module Impl_core_borrow_Borrow_slice_u8_for_alloy_primitives_bits_bloom_Bloom.
      Definition Self : Ty.t := Ty.path "alloy_primitives::bits::bloom::Bloom".
      
      (*
                  fn borrow(&self) -> &$t {
                      $crate::private::Borrow::borrow(&self.0)
                  }
      *)
      Definition borrow (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.borrow (|
              Pointer.Kind.Ref,
              M.deref (|
                M.call_closure (|
                  Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                  M.get_trait_method (|
                    "core::borrow::Borrow",
                    Ty.apply
                      (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                      [ Value.Integer IntegerKind.Usize 256 ]
                      [],
                    [],
                    [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                    "borrow",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_tuple_field (|
                            M.deref (| M.read (| self |) |),
                            "alloy_primitives::bits::bloom::Bloom",
                            0
                          |)
                        |)
                      |)
                    |)
                  ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::borrow::Borrow"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
          Self
          (* Instance *) [ ("borrow", InstanceField.Method borrow) ].
    End Impl_core_borrow_Borrow_slice_u8_for_alloy_primitives_bits_bloom_Bloom.
    
    Module Impl_core_borrow_Borrow_slice_u8_for_ref__alloy_primitives_bits_bloom_Bloom.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "&") [] [ Ty.path "alloy_primitives::bits::bloom::Bloom" ].
      
      (*
                  fn borrow(&self) -> &$t {
                      $crate::private::Borrow::borrow(&self.0)
                  }
      *)
      Definition borrow (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.borrow (|
              Pointer.Kind.Ref,
              M.deref (|
                M.call_closure (|
                  Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                  M.get_trait_method (|
                    "core::borrow::Borrow",
                    Ty.apply
                      (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                      [ Value.Integer IntegerKind.Usize 256 ]
                      [],
                    [],
                    [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                    "borrow",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_tuple_field (|
                            M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |),
                            "alloy_primitives::bits::bloom::Bloom",
                            0
                          |)
                        |)
                      |)
                    |)
                  ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::borrow::Borrow"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
          Self
          (* Instance *) [ ("borrow", InstanceField.Method borrow) ].
    End Impl_core_borrow_Borrow_slice_u8_for_ref__alloy_primitives_bits_bloom_Bloom.
    
    Module Impl_core_borrow_Borrow_slice_u8_for_ref_mut_alloy_primitives_bits_bloom_Bloom.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "&mut") [] [ Ty.path "alloy_primitives::bits::bloom::Bloom" ].
      
      (*
                  fn borrow(&self) -> &$t {
                      $crate::private::Borrow::borrow(&self.0)
                  }
      *)
      Definition borrow (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.borrow (|
              Pointer.Kind.Ref,
              M.deref (|
                M.call_closure (|
                  Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                  M.get_trait_method (|
                    "core::borrow::Borrow",
                    Ty.apply
                      (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                      [ Value.Integer IntegerKind.Usize 256 ]
                      [],
                    [],
                    [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                    "borrow",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_tuple_field (|
                            M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |),
                            "alloy_primitives::bits::bloom::Bloom",
                            0
                          |)
                        |)
                      |)
                    |)
                  ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::borrow::Borrow"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
          Self
          (* Instance *) [ ("borrow", InstanceField.Method borrow) ].
    End Impl_core_borrow_Borrow_slice_u8_for_ref_mut_alloy_primitives_bits_bloom_Bloom.
    
    Module Impl_core_borrow_Borrow_array_Usize_256_u8_for_alloy_primitives_bits_bloom_Bloom.
      Definition Self : Ty.t := Ty.path "alloy_primitives::bits::bloom::Bloom".
      
      (*
                  fn borrow(&self) -> &$t {
                      $crate::private::Borrow::borrow(&self.0)
                  }
      *)
      Definition borrow (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.borrow (|
              Pointer.Kind.Ref,
              M.deref (|
                M.call_closure (|
                  Ty.apply
                    (Ty.path "&")
                    []
                    [
                      Ty.apply
                        (Ty.path "array")
                        [ Value.Integer IntegerKind.Usize 256 ]
                        [ Ty.path "u8" ]
                    ],
                  M.get_trait_method (|
                    "core::borrow::Borrow",
                    Ty.apply
                      (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                      [ Value.Integer IntegerKind.Usize 256 ]
                      [],
                    [],
                    [
                      Ty.apply
                        (Ty.path "array")
                        [ Value.Integer IntegerKind.Usize 256 ]
                        [ Ty.path "u8" ]
                    ],
                    "borrow",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_tuple_field (|
                            M.deref (| M.read (| self |) |),
                            "alloy_primitives::bits::bloom::Bloom",
                            0
                          |)
                        |)
                      |)
                    |)
                  ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::borrow::Borrow"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 256 ] [ Ty.path "u8" ] ]
          Self
          (* Instance *) [ ("borrow", InstanceField.Method borrow) ].
    End Impl_core_borrow_Borrow_array_Usize_256_u8_for_alloy_primitives_bits_bloom_Bloom.
    
    Module Impl_core_borrow_Borrow_array_Usize_256_u8_for_ref__alloy_primitives_bits_bloom_Bloom.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "&") [] [ Ty.path "alloy_primitives::bits::bloom::Bloom" ].
      
      (*
                  fn borrow(&self) -> &$t {
                      $crate::private::Borrow::borrow(&self.0)
                  }
      *)
      Definition borrow (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.borrow (|
              Pointer.Kind.Ref,
              M.deref (|
                M.call_closure (|
                  Ty.apply
                    (Ty.path "&")
                    []
                    [
                      Ty.apply
                        (Ty.path "array")
                        [ Value.Integer IntegerKind.Usize 256 ]
                        [ Ty.path "u8" ]
                    ],
                  M.get_trait_method (|
                    "core::borrow::Borrow",
                    Ty.apply
                      (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                      [ Value.Integer IntegerKind.Usize 256 ]
                      [],
                    [],
                    [
                      Ty.apply
                        (Ty.path "array")
                        [ Value.Integer IntegerKind.Usize 256 ]
                        [ Ty.path "u8" ]
                    ],
                    "borrow",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_tuple_field (|
                            M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |),
                            "alloy_primitives::bits::bloom::Bloom",
                            0
                          |)
                        |)
                      |)
                    |)
                  ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::borrow::Borrow"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 256 ] [ Ty.path "u8" ] ]
          Self
          (* Instance *) [ ("borrow", InstanceField.Method borrow) ].
    End Impl_core_borrow_Borrow_array_Usize_256_u8_for_ref__alloy_primitives_bits_bloom_Bloom.
    
    Module Impl_core_borrow_Borrow_array_Usize_256_u8_for_ref_mut_alloy_primitives_bits_bloom_Bloom.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "&mut") [] [ Ty.path "alloy_primitives::bits::bloom::Bloom" ].
      
      (*
                  fn borrow(&self) -> &$t {
                      $crate::private::Borrow::borrow(&self.0)
                  }
      *)
      Definition borrow (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.borrow (|
              Pointer.Kind.Ref,
              M.deref (|
                M.call_closure (|
                  Ty.apply
                    (Ty.path "&")
                    []
                    [
                      Ty.apply
                        (Ty.path "array")
                        [ Value.Integer IntegerKind.Usize 256 ]
                        [ Ty.path "u8" ]
                    ],
                  M.get_trait_method (|
                    "core::borrow::Borrow",
                    Ty.apply
                      (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                      [ Value.Integer IntegerKind.Usize 256 ]
                      [],
                    [],
                    [
                      Ty.apply
                        (Ty.path "array")
                        [ Value.Integer IntegerKind.Usize 256 ]
                        [ Ty.path "u8" ]
                    ],
                    "borrow",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_tuple_field (|
                            M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |),
                            "alloy_primitives::bits::bloom::Bloom",
                            0
                          |)
                        |)
                      |)
                    |)
                  ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::borrow::Borrow"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 256 ] [ Ty.path "u8" ] ]
          Self
          (* Instance *) [ ("borrow", InstanceField.Method borrow) ].
    End Impl_core_borrow_Borrow_array_Usize_256_u8_for_ref_mut_alloy_primitives_bits_bloom_Bloom.
    
    Module Impl_core_borrow_BorrowMut_slice_u8_for_alloy_primitives_bits_bloom_Bloom.
      Definition Self : Ty.t := Ty.path "alloy_primitives::bits::bloom::Bloom".
      
      (*
                  fn borrow_mut(&mut self) -> &mut $t {
                      $crate::private::BorrowMut::borrow_mut(&mut self.0)
                  }
      *)
      Definition borrow_mut (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.borrow (|
              Pointer.Kind.MutRef,
              M.deref (|
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.deref (|
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "&mut")
                        []
                        [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                      M.get_trait_method (|
                        "core::borrow::BorrowMut",
                        Ty.apply
                          (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                          [ Value.Integer IntegerKind.Usize 256 ]
                          [],
                        [],
                        [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                        "borrow_mut",
                        [],
                        []
                      |),
                      [
                        M.borrow (|
                          Pointer.Kind.MutRef,
                          M.deref (|
                            M.borrow (|
                              Pointer.Kind.MutRef,
                              M.SubPointer.get_struct_tuple_field (|
                                M.deref (| M.read (| self |) |),
                                "alloy_primitives::bits::bloom::Bloom",
                                0
                              |)
                            |)
                          |)
                        |)
                      ]
                    |)
                  |)
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::borrow::BorrowMut"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
          Self
          (* Instance *) [ ("borrow_mut", InstanceField.Method borrow_mut) ].
    End Impl_core_borrow_BorrowMut_slice_u8_for_alloy_primitives_bits_bloom_Bloom.
    
    Module Impl_core_borrow_BorrowMut_slice_u8_for_ref_mut_alloy_primitives_bits_bloom_Bloom.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "&mut") [] [ Ty.path "alloy_primitives::bits::bloom::Bloom" ].
      
      (*
                  fn borrow_mut(&mut self) -> &mut $t {
                      $crate::private::BorrowMut::borrow_mut(&mut self.0)
                  }
      *)
      Definition borrow_mut (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.borrow (|
              Pointer.Kind.MutRef,
              M.deref (|
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.deref (|
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "&mut")
                        []
                        [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                      M.get_trait_method (|
                        "core::borrow::BorrowMut",
                        Ty.apply
                          (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                          [ Value.Integer IntegerKind.Usize 256 ]
                          [],
                        [],
                        [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                        "borrow_mut",
                        [],
                        []
                      |),
                      [
                        M.borrow (|
                          Pointer.Kind.MutRef,
                          M.deref (|
                            M.borrow (|
                              Pointer.Kind.MutRef,
                              M.SubPointer.get_struct_tuple_field (|
                                M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |),
                                "alloy_primitives::bits::bloom::Bloom",
                                0
                              |)
                            |)
                          |)
                        |)
                      ]
                    |)
                  |)
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::borrow::BorrowMut"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
          Self
          (* Instance *) [ ("borrow_mut", InstanceField.Method borrow_mut) ].
    End Impl_core_borrow_BorrowMut_slice_u8_for_ref_mut_alloy_primitives_bits_bloom_Bloom.
    
    Module Impl_core_borrow_BorrowMut_array_Usize_256_u8_for_alloy_primitives_bits_bloom_Bloom.
      Definition Self : Ty.t := Ty.path "alloy_primitives::bits::bloom::Bloom".
      
      (*
                  fn borrow_mut(&mut self) -> &mut $t {
                      $crate::private::BorrowMut::borrow_mut(&mut self.0)
                  }
      *)
      Definition borrow_mut (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.borrow (|
              Pointer.Kind.MutRef,
              M.deref (|
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.deref (|
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "&mut")
                        []
                        [
                          Ty.apply
                            (Ty.path "array")
                            [ Value.Integer IntegerKind.Usize 256 ]
                            [ Ty.path "u8" ]
                        ],
                      M.get_trait_method (|
                        "core::borrow::BorrowMut",
                        Ty.apply
                          (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                          [ Value.Integer IntegerKind.Usize 256 ]
                          [],
                        [],
                        [
                          Ty.apply
                            (Ty.path "array")
                            [ Value.Integer IntegerKind.Usize 256 ]
                            [ Ty.path "u8" ]
                        ],
                        "borrow_mut",
                        [],
                        []
                      |),
                      [
                        M.borrow (|
                          Pointer.Kind.MutRef,
                          M.deref (|
                            M.borrow (|
                              Pointer.Kind.MutRef,
                              M.SubPointer.get_struct_tuple_field (|
                                M.deref (| M.read (| self |) |),
                                "alloy_primitives::bits::bloom::Bloom",
                                0
                              |)
                            |)
                          |)
                        |)
                      ]
                    |)
                  |)
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::borrow::BorrowMut"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 256 ] [ Ty.path "u8" ] ]
          Self
          (* Instance *) [ ("borrow_mut", InstanceField.Method borrow_mut) ].
    End Impl_core_borrow_BorrowMut_array_Usize_256_u8_for_alloy_primitives_bits_bloom_Bloom.
    
    Module Impl_core_borrow_BorrowMut_array_Usize_256_u8_for_ref_mut_alloy_primitives_bits_bloom_Bloom.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "&mut") [] [ Ty.path "alloy_primitives::bits::bloom::Bloom" ].
      
      (*
                  fn borrow_mut(&mut self) -> &mut $t {
                      $crate::private::BorrowMut::borrow_mut(&mut self.0)
                  }
      *)
      Definition borrow_mut (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.borrow (|
              Pointer.Kind.MutRef,
              M.deref (|
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.deref (|
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "&mut")
                        []
                        [
                          Ty.apply
                            (Ty.path "array")
                            [ Value.Integer IntegerKind.Usize 256 ]
                            [ Ty.path "u8" ]
                        ],
                      M.get_trait_method (|
                        "core::borrow::BorrowMut",
                        Ty.apply
                          (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                          [ Value.Integer IntegerKind.Usize 256 ]
                          [],
                        [],
                        [
                          Ty.apply
                            (Ty.path "array")
                            [ Value.Integer IntegerKind.Usize 256 ]
                            [ Ty.path "u8" ]
                        ],
                        "borrow_mut",
                        [],
                        []
                      |),
                      [
                        M.borrow (|
                          Pointer.Kind.MutRef,
                          M.deref (|
                            M.borrow (|
                              Pointer.Kind.MutRef,
                              M.SubPointer.get_struct_tuple_field (|
                                M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |),
                                "alloy_primitives::bits::bloom::Bloom",
                                0
                              |)
                            |)
                          |)
                        |)
                      ]
                    |)
                  |)
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::borrow::BorrowMut"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 256 ] [ Ty.path "u8" ] ]
          Self
          (* Instance *) [ ("borrow_mut", InstanceField.Method borrow_mut) ].
    End Impl_core_borrow_BorrowMut_array_Usize_256_u8_for_ref_mut_alloy_primitives_bits_bloom_Bloom.
    
    Module Impl_core_convert_From_ref__array_Usize_256_u8_for_ref__alloy_primitives_bits_bloom_Bloom.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "&") [] [ Ty.path "alloy_primitives::bits::bloom::Bloom" ].
      
      (*
                  fn from(value: $a) -> $b {
                      // SAFETY: guaranteed by caller
                      unsafe { $crate::private::core::mem::transmute::<$a, $b>(value) }
                  }
      *)
      Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            M.call_closure (|
              Ty.apply (Ty.path "&") [] [ Ty.path "alloy_primitives::bits::bloom::Bloom" ],
              M.get_function (|
                "core::intrinsics::transmute",
                [],
                [
                  Ty.apply
                    (Ty.path "&")
                    []
                    [
                      Ty.apply
                        (Ty.path "array")
                        [ Value.Integer IntegerKind.Usize 256 ]
                        [ Ty.path "u8" ]
                    ];
                  Ty.apply (Ty.path "&") [] [ Ty.path "alloy_primitives::bits::bloom::Bloom" ]
                ]
              |),
              [ M.read (| value |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [
            Ty.apply
              (Ty.path "&")
              []
              [ Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 256 ] [ Ty.path "u8" ]
              ]
          ]
          Self
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_ref__array_Usize_256_u8_for_ref__alloy_primitives_bits_bloom_Bloom.
    
    Module Impl_core_convert_From_ref_mut_array_Usize_256_u8_for_ref__alloy_primitives_bits_bloom_Bloom.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "&") [] [ Ty.path "alloy_primitives::bits::bloom::Bloom" ].
      
      (*
                  fn from(value: $a) -> $b {
                      // SAFETY: guaranteed by caller
                      unsafe { $crate::private::core::mem::transmute::<$a, $b>(value) }
                  }
      *)
      Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            M.call_closure (|
              Ty.apply (Ty.path "&") [] [ Ty.path "alloy_primitives::bits::bloom::Bloom" ],
              M.get_function (|
                "core::intrinsics::transmute",
                [],
                [
                  Ty.apply
                    (Ty.path "&mut")
                    []
                    [
                      Ty.apply
                        (Ty.path "array")
                        [ Value.Integer IntegerKind.Usize 256 ]
                        [ Ty.path "u8" ]
                    ];
                  Ty.apply (Ty.path "&") [] [ Ty.path "alloy_primitives::bits::bloom::Bloom" ]
                ]
              |),
              [ M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| value |) |) |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [
            Ty.apply
              (Ty.path "&mut")
              []
              [ Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 256 ] [ Ty.path "u8" ]
              ]
          ]
          Self
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_ref_mut_array_Usize_256_u8_for_ref__alloy_primitives_bits_bloom_Bloom.
    
    Module Impl_core_convert_From_ref_mut_array_Usize_256_u8_for_ref_mut_alloy_primitives_bits_bloom_Bloom.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "&mut") [] [ Ty.path "alloy_primitives::bits::bloom::Bloom" ].
      
      (*
                  fn from(value: $a) -> $b {
                      // SAFETY: guaranteed by caller
                      unsafe { $crate::private::core::mem::transmute::<$a, $b>(value) }
                  }
      *)
      Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            M.borrow (|
              Pointer.Kind.MutRef,
              M.deref (|
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.MutRef,
                      M.deref (|
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "&mut")
                            []
                            [ Ty.path "alloy_primitives::bits::bloom::Bloom" ],
                          M.get_function (|
                            "core::intrinsics::transmute",
                            [],
                            [
                              Ty.apply
                                (Ty.path "&mut")
                                []
                                [
                                  Ty.apply
                                    (Ty.path "array")
                                    [ Value.Integer IntegerKind.Usize 256 ]
                                    [ Ty.path "u8" ]
                                ];
                              Ty.apply
                                (Ty.path "&mut")
                                []
                                [ Ty.path "alloy_primitives::bits::bloom::Bloom" ]
                            ]
                          |),
                          [ M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| value |) |) |) ]
                        |)
                      |)
                    |)
                  |)
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [
            Ty.apply
              (Ty.path "&mut")
              []
              [ Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 256 ] [ Ty.path "u8" ]
              ]
          ]
          Self
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_ref_mut_array_Usize_256_u8_for_ref_mut_alloy_primitives_bits_bloom_Bloom.
    
    Module Impl_core_convert_From_ref__alloy_primitives_bits_bloom_Bloom_for_ref__array_Usize_256_u8.
      Definition Self : Ty.t :=
        Ty.apply
          (Ty.path "&")
          []
          [ Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 256 ] [ Ty.path "u8" ] ].
      
      (*
                  fn from(value: $a) -> $b {
                      // SAFETY: guaranteed by caller
                      unsafe { $crate::private::core::mem::transmute::<$a, $b>(value) }
                  }
      *)
      Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "&")
                []
                [
                  Ty.apply
                    (Ty.path "array")
                    [ Value.Integer IntegerKind.Usize 256 ]
                    [ Ty.path "u8" ]
                ],
              M.get_function (|
                "core::intrinsics::transmute",
                [],
                [
                  Ty.apply (Ty.path "&") [] [ Ty.path "alloy_primitives::bits::bloom::Bloom" ];
                  Ty.apply
                    (Ty.path "&")
                    []
                    [
                      Ty.apply
                        (Ty.path "array")
                        [ Value.Integer IntegerKind.Usize 256 ]
                        [ Ty.path "u8" ]
                    ]
                ]
              |),
              [ M.read (| value |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "&") [] [ Ty.path "alloy_primitives::bits::bloom::Bloom" ] ]
          Self
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_ref__alloy_primitives_bits_bloom_Bloom_for_ref__array_Usize_256_u8.
    
    Module Impl_core_convert_From_ref_mut_alloy_primitives_bits_bloom_Bloom_for_ref__array_Usize_256_u8.
      Definition Self : Ty.t :=
        Ty.apply
          (Ty.path "&")
          []
          [ Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 256 ] [ Ty.path "u8" ] ].
      
      (*
                  fn from(value: $a) -> $b {
                      // SAFETY: guaranteed by caller
                      unsafe { $crate::private::core::mem::transmute::<$a, $b>(value) }
                  }
      *)
      Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "&")
                []
                [
                  Ty.apply
                    (Ty.path "array")
                    [ Value.Integer IntegerKind.Usize 256 ]
                    [ Ty.path "u8" ]
                ],
              M.get_function (|
                "core::intrinsics::transmute",
                [],
                [
                  Ty.apply (Ty.path "&mut") [] [ Ty.path "alloy_primitives::bits::bloom::Bloom" ];
                  Ty.apply
                    (Ty.path "&")
                    []
                    [
                      Ty.apply
                        (Ty.path "array")
                        [ Value.Integer IntegerKind.Usize 256 ]
                        [ Ty.path "u8" ]
                    ]
                ]
              |),
              [ M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| value |) |) |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "&mut") [] [ Ty.path "alloy_primitives::bits::bloom::Bloom" ] ]
          Self
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_ref_mut_alloy_primitives_bits_bloom_Bloom_for_ref__array_Usize_256_u8.
    
    Module Impl_core_convert_From_ref_mut_alloy_primitives_bits_bloom_Bloom_for_ref_mut_array_Usize_256_u8.
      Definition Self : Ty.t :=
        Ty.apply
          (Ty.path "&mut")
          []
          [ Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 256 ] [ Ty.path "u8" ] ].
      
      (*
                  fn from(value: $a) -> $b {
                      // SAFETY: guaranteed by caller
                      unsafe { $crate::private::core::mem::transmute::<$a, $b>(value) }
                  }
      *)
      Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            M.borrow (|
              Pointer.Kind.MutRef,
              M.deref (|
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.MutRef,
                      M.deref (|
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "&mut")
                            []
                            [
                              Ty.apply
                                (Ty.path "array")
                                [ Value.Integer IntegerKind.Usize 256 ]
                                [ Ty.path "u8" ]
                            ],
                          M.get_function (|
                            "core::intrinsics::transmute",
                            [],
                            [
                              Ty.apply
                                (Ty.path "&mut")
                                []
                                [ Ty.path "alloy_primitives::bits::bloom::Bloom" ];
                              Ty.apply
                                (Ty.path "&mut")
                                []
                                [
                                  Ty.apply
                                    (Ty.path "array")
                                    [ Value.Integer IntegerKind.Usize 256 ]
                                    [ Ty.path "u8" ]
                                ]
                            ]
                          |),
                          [ M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| value |) |) |) ]
                        |)
                      |)
                    |)
                  |)
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "&mut") [] [ Ty.path "alloy_primitives::bits::bloom::Bloom" ] ]
          Self
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_ref_mut_alloy_primitives_bits_bloom_Bloom_for_ref_mut_array_Usize_256_u8.
    
    Module Impl_core_cmp_PartialEq_slice_u8_for_alloy_primitives_bits_bloom_Bloom.
      Definition Self : Ty.t := Ty.path "alloy_primitives::bits::bloom::Bloom".
      
      (*
                  fn $fn(&self, other: &$a) -> $ret {
                      $crate::private::$tr::$fn(&self.0 $([$e])?, other)
                  }
      *)
      Definition eq (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              Ty.path "bool",
              M.get_trait_method (|
                "core::cmp::PartialEq",
                Ty.apply
                  (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                  [ Value.Integer IntegerKind.Usize 256 ]
                  [],
                [],
                [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                "eq",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_tuple_field (|
                        M.deref (| M.read (| self |) |),
                        "alloy_primitives::bits::bloom::Bloom",
                        0
                      |)
                    |)
                  |)
                |);
                M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| other |) |) |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::cmp::PartialEq"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
          Self
          (* Instance *) [ ("eq", InstanceField.Method eq) ].
    End Impl_core_cmp_PartialEq_slice_u8_for_alloy_primitives_bits_bloom_Bloom.
    
    Module Impl_core_cmp_PartialEq_alloy_primitives_bits_bloom_Bloom_for_slice_u8.
      Definition Self : Ty.t := Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ].
      
      (*
                  fn $fn(&self, other: &$b) -> $ret {
                      $crate::private::$tr::$fn(self, &other.0 $([$e])?)
                  }
      *)
      Definition eq (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              Ty.path "bool",
              M.get_trait_method (|
                "core::cmp::PartialEq",
                Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                [],
                [
                  Ty.apply
                    (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                    [ Value.Integer IntegerKind.Usize 256 ]
                    []
                ],
                "eq",
                [],
                []
              |),
              [
                M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |);
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_tuple_field (|
                        M.deref (| M.read (| other |) |),
                        "alloy_primitives::bits::bloom::Bloom",
                        0
                      |)
                    |)
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::cmp::PartialEq"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "alloy_primitives::bits::bloom::Bloom" ]
          Self
          (* Instance *) [ ("eq", InstanceField.Method eq) ].
    End Impl_core_cmp_PartialEq_alloy_primitives_bits_bloom_Bloom_for_slice_u8.
    
    Module Impl_core_cmp_PartialEq_ref__slice_u8_for_alloy_primitives_bits_bloom_Bloom.
      Definition Self : Ty.t := Ty.path "alloy_primitives::bits::bloom::Bloom".
      
      (*
                  fn $fn(&self, other: &&$a) -> $ret {
                      $crate::private::$tr::$fn(&self.0 $([$e])?, *other)
                  }
      *)
      Definition eq (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              Ty.path "bool",
              M.get_trait_method (|
                "core::cmp::PartialEq",
                Ty.apply
                  (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                  [ Value.Integer IntegerKind.Usize 256 ]
                  [],
                [],
                [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                "eq",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_tuple_field (|
                        M.deref (| M.read (| self |) |),
                        "alloy_primitives::bits::bloom::Bloom",
                        0
                      |)
                    |)
                  |)
                |);
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (| M.read (| M.deref (| M.read (| other |) |) |) |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::cmp::PartialEq"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ] ]
          Self
          (* Instance *) [ ("eq", InstanceField.Method eq) ].
    End Impl_core_cmp_PartialEq_ref__slice_u8_for_alloy_primitives_bits_bloom_Bloom.
    
    Module Impl_core_cmp_PartialEq_alloy_primitives_bits_bloom_Bloom_for_ref__slice_u8.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ].
      
      (*
                  fn $fn(&self, other: &$b) -> $ret {
                      $crate::private::$tr::$fn( *self, &other.0 $([$e])?)
                  }
      *)
      Definition eq (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              Ty.path "bool",
              M.get_trait_method (|
                "core::cmp::PartialEq",
                Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                [],
                [
                  Ty.apply
                    (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                    [ Value.Integer IntegerKind.Usize 256 ]
                    []
                ],
                "eq",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
                |);
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_tuple_field (|
                        M.deref (| M.read (| other |) |),
                        "alloy_primitives::bits::bloom::Bloom",
                        0
                      |)
                    |)
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::cmp::PartialEq"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "alloy_primitives::bits::bloom::Bloom" ]
          Self
          (* Instance *) [ ("eq", InstanceField.Method eq) ].
    End Impl_core_cmp_PartialEq_alloy_primitives_bits_bloom_Bloom_for_ref__slice_u8.
    
    Module Impl_core_cmp_PartialEq_slice_u8_for_ref__alloy_primitives_bits_bloom_Bloom.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "&") [] [ Ty.path "alloy_primitives::bits::bloom::Bloom" ].
      
      (*
                  fn $fn(&self, other: &$a) -> $ret {
                      $crate::private::$tr::$fn(&self.0 $([$e])?, other)
                  }
      *)
      Definition eq (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              Ty.path "bool",
              M.get_trait_method (|
                "core::cmp::PartialEq",
                Ty.apply
                  (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                  [ Value.Integer IntegerKind.Usize 256 ]
                  [],
                [],
                [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                "eq",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_tuple_field (|
                        M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |),
                        "alloy_primitives::bits::bloom::Bloom",
                        0
                      |)
                    |)
                  |)
                |);
                M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| other |) |) |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::cmp::PartialEq"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
          Self
          (* Instance *) [ ("eq", InstanceField.Method eq) ].
    End Impl_core_cmp_PartialEq_slice_u8_for_ref__alloy_primitives_bits_bloom_Bloom.
    
    Module Impl_core_cmp_PartialEq_ref__alloy_primitives_bits_bloom_Bloom_for_slice_u8.
      Definition Self : Ty.t := Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ].
      
      (*
                  fn $fn(&self, other: &&$b) -> $ret {
                      $crate::private::$tr::$fn(self, &other.0 $([$e])?)
                  }
      *)
      Definition eq (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              Ty.path "bool",
              M.get_trait_method (|
                "core::cmp::PartialEq",
                Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                [],
                [
                  Ty.apply
                    (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                    [ Value.Integer IntegerKind.Usize 256 ]
                    []
                ],
                "eq",
                [],
                []
              |),
              [
                M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |);
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_tuple_field (|
                        M.deref (| M.read (| M.deref (| M.read (| other |) |) |) |),
                        "alloy_primitives::bits::bloom::Bloom",
                        0
                      |)
                    |)
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::cmp::PartialEq"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "&") [] [ Ty.path "alloy_primitives::bits::bloom::Bloom" ] ]
          Self
          (* Instance *) [ ("eq", InstanceField.Method eq) ].
    End Impl_core_cmp_PartialEq_ref__alloy_primitives_bits_bloom_Bloom_for_slice_u8.
    
    Module Impl_core_cmp_PartialEq_array_Usize_256_u8_for_alloy_primitives_bits_bloom_Bloom.
      Definition Self : Ty.t := Ty.path "alloy_primitives::bits::bloom::Bloom".
      
      (*
                  fn $fn(&self, other: &$a) -> $ret {
                      $crate::private::$tr::$fn(&self.0 $([$e])?, other)
                  }
      *)
      Definition eq (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              Ty.path "bool",
              M.get_trait_method (|
                "core::cmp::PartialEq",
                Ty.apply
                  (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                  [ Value.Integer IntegerKind.Usize 256 ]
                  [],
                [],
                [
                  Ty.apply
                    (Ty.path "array")
                    [ Value.Integer IntegerKind.Usize 256 ]
                    [ Ty.path "u8" ]
                ],
                "eq",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_tuple_field (|
                        M.deref (| M.read (| self |) |),
                        "alloy_primitives::bits::bloom::Bloom",
                        0
                      |)
                    |)
                  |)
                |);
                M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| other |) |) |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::cmp::PartialEq"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 256 ] [ Ty.path "u8" ] ]
          Self
          (* Instance *) [ ("eq", InstanceField.Method eq) ].
    End Impl_core_cmp_PartialEq_array_Usize_256_u8_for_alloy_primitives_bits_bloom_Bloom.
    
    Module Impl_core_cmp_PartialEq_alloy_primitives_bits_bloom_Bloom_for_array_Usize_256_u8.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 256 ] [ Ty.path "u8" ].
      
      (*
                  fn $fn(&self, other: &$b) -> $ret {
                      $crate::private::$tr::$fn(self, &other.0 $([$e])?)
                  }
      *)
      Definition eq (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              Ty.path "bool",
              M.get_trait_method (|
                "core::cmp::PartialEq",
                Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 256 ] [ Ty.path "u8" ],
                [],
                [
                  Ty.apply
                    (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                    [ Value.Integer IntegerKind.Usize 256 ]
                    []
                ],
                "eq",
                [],
                []
              |),
              [
                M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |);
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_tuple_field (|
                        M.deref (| M.read (| other |) |),
                        "alloy_primitives::bits::bloom::Bloom",
                        0
                      |)
                    |)
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::cmp::PartialEq"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "alloy_primitives::bits::bloom::Bloom" ]
          Self
          (* Instance *) [ ("eq", InstanceField.Method eq) ].
    End Impl_core_cmp_PartialEq_alloy_primitives_bits_bloom_Bloom_for_array_Usize_256_u8.
    
    Module Impl_core_cmp_PartialEq_ref__array_Usize_256_u8_for_alloy_primitives_bits_bloom_Bloom.
      Definition Self : Ty.t := Ty.path "alloy_primitives::bits::bloom::Bloom".
      
      (*
                  fn $fn(&self, other: &&$a) -> $ret {
                      $crate::private::$tr::$fn(&self.0 $([$e])?, *other)
                  }
      *)
      Definition eq (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              Ty.path "bool",
              M.get_trait_method (|
                "core::cmp::PartialEq",
                Ty.apply
                  (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                  [ Value.Integer IntegerKind.Usize 256 ]
                  [],
                [],
                [
                  Ty.apply
                    (Ty.path "array")
                    [ Value.Integer IntegerKind.Usize 256 ]
                    [ Ty.path "u8" ]
                ],
                "eq",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_tuple_field (|
                        M.deref (| M.read (| self |) |),
                        "alloy_primitives::bits::bloom::Bloom",
                        0
                      |)
                    |)
                  |)
                |);
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (| M.read (| M.deref (| M.read (| other |) |) |) |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::cmp::PartialEq"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [
            Ty.apply
              (Ty.path "&")
              []
              [ Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 256 ] [ Ty.path "u8" ]
              ]
          ]
          Self
          (* Instance *) [ ("eq", InstanceField.Method eq) ].
    End Impl_core_cmp_PartialEq_ref__array_Usize_256_u8_for_alloy_primitives_bits_bloom_Bloom.
    
    Module Impl_core_cmp_PartialEq_alloy_primitives_bits_bloom_Bloom_for_ref__array_Usize_256_u8.
      Definition Self : Ty.t :=
        Ty.apply
          (Ty.path "&")
          []
          [ Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 256 ] [ Ty.path "u8" ] ].
      
      (*
                  fn $fn(&self, other: &$b) -> $ret {
                      $crate::private::$tr::$fn( *self, &other.0 $([$e])?)
                  }
      *)
      Definition eq (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              Ty.path "bool",
              M.get_trait_method (|
                "core::cmp::PartialEq",
                Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 256 ] [ Ty.path "u8" ],
                [],
                [
                  Ty.apply
                    (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                    [ Value.Integer IntegerKind.Usize 256 ]
                    []
                ],
                "eq",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
                |);
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_tuple_field (|
                        M.deref (| M.read (| other |) |),
                        "alloy_primitives::bits::bloom::Bloom",
                        0
                      |)
                    |)
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::cmp::PartialEq"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "alloy_primitives::bits::bloom::Bloom" ]
          Self
          (* Instance *) [ ("eq", InstanceField.Method eq) ].
    End Impl_core_cmp_PartialEq_alloy_primitives_bits_bloom_Bloom_for_ref__array_Usize_256_u8.
    
    Module Impl_core_cmp_PartialEq_array_Usize_256_u8_for_ref__alloy_primitives_bits_bloom_Bloom.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "&") [] [ Ty.path "alloy_primitives::bits::bloom::Bloom" ].
      
      (*
                  fn $fn(&self, other: &$a) -> $ret {
                      $crate::private::$tr::$fn(&self.0 $([$e])?, other)
                  }
      *)
      Definition eq (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              Ty.path "bool",
              M.get_trait_method (|
                "core::cmp::PartialEq",
                Ty.apply
                  (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                  [ Value.Integer IntegerKind.Usize 256 ]
                  [],
                [],
                [
                  Ty.apply
                    (Ty.path "array")
                    [ Value.Integer IntegerKind.Usize 256 ]
                    [ Ty.path "u8" ]
                ],
                "eq",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_tuple_field (|
                        M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |),
                        "alloy_primitives::bits::bloom::Bloom",
                        0
                      |)
                    |)
                  |)
                |);
                M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| other |) |) |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::cmp::PartialEq"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 256 ] [ Ty.path "u8" ] ]
          Self
          (* Instance *) [ ("eq", InstanceField.Method eq) ].
    End Impl_core_cmp_PartialEq_array_Usize_256_u8_for_ref__alloy_primitives_bits_bloom_Bloom.
    
    Module Impl_core_cmp_PartialEq_ref__alloy_primitives_bits_bloom_Bloom_for_array_Usize_256_u8.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 256 ] [ Ty.path "u8" ].
      
      (*
                  fn $fn(&self, other: &&$b) -> $ret {
                      $crate::private::$tr::$fn(self, &other.0 $([$e])?)
                  }
      *)
      Definition eq (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              Ty.path "bool",
              M.get_trait_method (|
                "core::cmp::PartialEq",
                Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 256 ] [ Ty.path "u8" ],
                [],
                [
                  Ty.apply
                    (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                    [ Value.Integer IntegerKind.Usize 256 ]
                    []
                ],
                "eq",
                [],
                []
              |),
              [
                M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |);
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_tuple_field (|
                        M.deref (| M.read (| M.deref (| M.read (| other |) |) |) |),
                        "alloy_primitives::bits::bloom::Bloom",
                        0
                      |)
                    |)
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::cmp::PartialEq"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "&") [] [ Ty.path "alloy_primitives::bits::bloom::Bloom" ] ]
          Self
          (* Instance *) [ ("eq", InstanceField.Method eq) ].
    End Impl_core_cmp_PartialEq_ref__alloy_primitives_bits_bloom_Bloom_for_array_Usize_256_u8.
    
    Module Impl_core_cmp_PartialOrd_slice_u8_for_alloy_primitives_bits_bloom_Bloom.
      Definition Self : Ty.t := Ty.path "alloy_primitives::bits::bloom::Bloom".
      
      (*
                  fn $fn(&self, other: &$a) -> $ret {
                      $crate::private::$tr::$fn(&self.0 $([$e])?, other)
                  }
      *)
      Definition partial_cmp (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "core::cmp::Ordering" ],
              M.get_trait_method (|
                "core::cmp::PartialOrd",
                Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                [],
                [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                "partial_cmp",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "&")
                            []
                            [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                          M.get_trait_method (|
                            "core::ops::index::Index",
                            Ty.apply
                              (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                              [ Value.Integer IntegerKind.Usize 256 ]
                              [],
                            [],
                            [ Ty.path "core::ops::range::RangeFull" ],
                            "index",
                            [],
                            []
                          |),
                          [
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.SubPointer.get_struct_tuple_field (|
                                M.deref (| M.read (| self |) |),
                                "alloy_primitives::bits::bloom::Bloom",
                                0
                              |)
                            |);
                            Value.StructTuple "core::ops::range::RangeFull" []
                          ]
                        |)
                      |)
                    |)
                  |)
                |);
                M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| other |) |) |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::cmp::PartialOrd"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
          Self
          (* Instance *) [ ("partial_cmp", InstanceField.Method partial_cmp) ].
    End Impl_core_cmp_PartialOrd_slice_u8_for_alloy_primitives_bits_bloom_Bloom.
    
    Module Impl_core_cmp_PartialOrd_alloy_primitives_bits_bloom_Bloom_for_slice_u8.
      Definition Self : Ty.t := Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ].
      
      (*
                  fn $fn(&self, other: &$b) -> $ret {
                      $crate::private::$tr::$fn(self, &other.0 $([$e])?)
                  }
      *)
      Definition partial_cmp (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "core::cmp::Ordering" ],
              M.get_trait_method (|
                "core::cmp::PartialOrd",
                Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                [],
                [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                "partial_cmp",
                [],
                []
              |),
              [
                M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |);
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "&")
                            []
                            [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                          M.get_trait_method (|
                            "core::ops::index::Index",
                            Ty.apply
                              (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                              [ Value.Integer IntegerKind.Usize 256 ]
                              [],
                            [],
                            [ Ty.path "core::ops::range::RangeFull" ],
                            "index",
                            [],
                            []
                          |),
                          [
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.SubPointer.get_struct_tuple_field (|
                                M.deref (| M.read (| other |) |),
                                "alloy_primitives::bits::bloom::Bloom",
                                0
                              |)
                            |);
                            Value.StructTuple "core::ops::range::RangeFull" []
                          ]
                        |)
                      |)
                    |)
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::cmp::PartialOrd"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "alloy_primitives::bits::bloom::Bloom" ]
          Self
          (* Instance *) [ ("partial_cmp", InstanceField.Method partial_cmp) ].
    End Impl_core_cmp_PartialOrd_alloy_primitives_bits_bloom_Bloom_for_slice_u8.
    
    Module Impl_core_cmp_PartialOrd_ref__slice_u8_for_alloy_primitives_bits_bloom_Bloom.
      Definition Self : Ty.t := Ty.path "alloy_primitives::bits::bloom::Bloom".
      
      (*
                  fn $fn(&self, other: &&$a) -> $ret {
                      $crate::private::$tr::$fn(&self.0 $([$e])?, *other)
                  }
      *)
      Definition partial_cmp (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "core::cmp::Ordering" ],
              M.get_trait_method (|
                "core::cmp::PartialOrd",
                Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                [],
                [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                "partial_cmp",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "&")
                            []
                            [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                          M.get_trait_method (|
                            "core::ops::index::Index",
                            Ty.apply
                              (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                              [ Value.Integer IntegerKind.Usize 256 ]
                              [],
                            [],
                            [ Ty.path "core::ops::range::RangeFull" ],
                            "index",
                            [],
                            []
                          |),
                          [
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.SubPointer.get_struct_tuple_field (|
                                M.deref (| M.read (| self |) |),
                                "alloy_primitives::bits::bloom::Bloom",
                                0
                              |)
                            |);
                            Value.StructTuple "core::ops::range::RangeFull" []
                          ]
                        |)
                      |)
                    |)
                  |)
                |);
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (| M.read (| M.deref (| M.read (| other |) |) |) |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::cmp::PartialOrd"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ] ]
          Self
          (* Instance *) [ ("partial_cmp", InstanceField.Method partial_cmp) ].
    End Impl_core_cmp_PartialOrd_ref__slice_u8_for_alloy_primitives_bits_bloom_Bloom.
    
    Module Impl_core_cmp_PartialOrd_alloy_primitives_bits_bloom_Bloom_for_ref__slice_u8.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ].
      
      (*
                  fn $fn(&self, other: &$b) -> $ret {
                      $crate::private::$tr::$fn( *self, &other.0 $([$e])?)
                  }
      *)
      Definition partial_cmp (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "core::cmp::Ordering" ],
              M.get_trait_method (|
                "core::cmp::PartialOrd",
                Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                [],
                [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                "partial_cmp",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
                |);
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "&")
                            []
                            [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                          M.get_trait_method (|
                            "core::ops::index::Index",
                            Ty.apply
                              (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                              [ Value.Integer IntegerKind.Usize 256 ]
                              [],
                            [],
                            [ Ty.path "core::ops::range::RangeFull" ],
                            "index",
                            [],
                            []
                          |),
                          [
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.SubPointer.get_struct_tuple_field (|
                                M.deref (| M.read (| other |) |),
                                "alloy_primitives::bits::bloom::Bloom",
                                0
                              |)
                            |);
                            Value.StructTuple "core::ops::range::RangeFull" []
                          ]
                        |)
                      |)
                    |)
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::cmp::PartialOrd"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "alloy_primitives::bits::bloom::Bloom" ]
          Self
          (* Instance *) [ ("partial_cmp", InstanceField.Method partial_cmp) ].
    End Impl_core_cmp_PartialOrd_alloy_primitives_bits_bloom_Bloom_for_ref__slice_u8.
    
    Module Impl_core_cmp_PartialOrd_slice_u8_for_ref__alloy_primitives_bits_bloom_Bloom.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "&") [] [ Ty.path "alloy_primitives::bits::bloom::Bloom" ].
      
      (*
                  fn $fn(&self, other: &$a) -> $ret {
                      $crate::private::$tr::$fn(&self.0 $([$e])?, other)
                  }
      *)
      Definition partial_cmp (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "core::cmp::Ordering" ],
              M.get_trait_method (|
                "core::cmp::PartialOrd",
                Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                [],
                [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                "partial_cmp",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "&")
                            []
                            [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                          M.get_trait_method (|
                            "core::ops::index::Index",
                            Ty.apply
                              (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                              [ Value.Integer IntegerKind.Usize 256 ]
                              [],
                            [],
                            [ Ty.path "core::ops::range::RangeFull" ],
                            "index",
                            [],
                            []
                          |),
                          [
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.SubPointer.get_struct_tuple_field (|
                                M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |),
                                "alloy_primitives::bits::bloom::Bloom",
                                0
                              |)
                            |);
                            Value.StructTuple "core::ops::range::RangeFull" []
                          ]
                        |)
                      |)
                    |)
                  |)
                |);
                M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| other |) |) |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::cmp::PartialOrd"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
          Self
          (* Instance *) [ ("partial_cmp", InstanceField.Method partial_cmp) ].
    End Impl_core_cmp_PartialOrd_slice_u8_for_ref__alloy_primitives_bits_bloom_Bloom.
    
    Module Impl_core_cmp_PartialOrd_ref__alloy_primitives_bits_bloom_Bloom_for_slice_u8.
      Definition Self : Ty.t := Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ].
      
      (*
                  fn $fn(&self, other: &&$b) -> $ret {
                      $crate::private::$tr::$fn(self, &other.0 $([$e])?)
                  }
      *)
      Definition partial_cmp (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "core::cmp::Ordering" ],
              M.get_trait_method (|
                "core::cmp::PartialOrd",
                Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                [],
                [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                "partial_cmp",
                [],
                []
              |),
              [
                M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |);
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "&")
                            []
                            [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                          M.get_trait_method (|
                            "core::ops::index::Index",
                            Ty.apply
                              (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                              [ Value.Integer IntegerKind.Usize 256 ]
                              [],
                            [],
                            [ Ty.path "core::ops::range::RangeFull" ],
                            "index",
                            [],
                            []
                          |),
                          [
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.SubPointer.get_struct_tuple_field (|
                                M.deref (| M.read (| M.deref (| M.read (| other |) |) |) |),
                                "alloy_primitives::bits::bloom::Bloom",
                                0
                              |)
                            |);
                            Value.StructTuple "core::ops::range::RangeFull" []
                          ]
                        |)
                      |)
                    |)
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::cmp::PartialOrd"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "&") [] [ Ty.path "alloy_primitives::bits::bloom::Bloom" ] ]
          Self
          (* Instance *) [ ("partial_cmp", InstanceField.Method partial_cmp) ].
    End Impl_core_cmp_PartialOrd_ref__alloy_primitives_bits_bloom_Bloom_for_slice_u8.
    
    Module Impl_const_hex_traits_FromHex_for_alloy_primitives_bits_bloom_Bloom.
      Definition Self : Ty.t := Ty.path "alloy_primitives::bits::bloom::Bloom".
      
      (*             type Error = $crate::hex::FromHexError; *)
      Definition _Error : Ty.t := Ty.path "const_hex::error::FromHexError".
      
      (*
                  fn from_hex<T: $crate::private::AsRef<[u8]>>(hex: T) -> Result<Self, Self::Error> {
                      $crate::hex::decode_to_array(hex).map(Self::new)
                  }
      *)
      Definition from_hex (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [ T ], [ hex ] =>
          ltac:(M.monadic
            (let hex := M.alloc (| hex |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "core::result::Result")
                []
                [
                  Ty.path "alloy_primitives::bits::bloom::Bloom";
                  Ty.path "const_hex::error::FromHexError"
                ],
              M.get_associated_function (|
                Ty.apply
                  (Ty.path "core::result::Result")
                  []
                  [
                    Ty.apply
                      (Ty.path "array")
                      [ Value.Integer IntegerKind.Usize 256 ]
                      [ Ty.path "u8" ];
                    Ty.path "const_hex::error::FromHexError"
                  ],
                "map",
                [],
                [
                  Ty.path "alloy_primitives::bits::bloom::Bloom";
                  Ty.function
                    [
                      Ty.apply
                        (Ty.path "array")
                        [ Value.Integer IntegerKind.Usize 256 ]
                        [ Ty.path "u8" ]
                    ]
                    (Ty.path "alloy_primitives::bits::bloom::Bloom")
                ]
              |),
              [
                M.call_closure (|
                  Ty.apply
                    (Ty.path "core::result::Result")
                    []
                    [
                      Ty.apply
                        (Ty.path "array")
                        [ Value.Integer IntegerKind.Usize 256 ]
                        [ Ty.path "u8" ];
                      Ty.path "const_hex::error::FromHexError"
                    ],
                  M.get_function (|
                    "const_hex::decode_to_array",
                    [ Value.Integer IntegerKind.Usize 256 ],
                    [ T ]
                  |),
                  [ M.read (| hex |) ]
                |);
                M.get_associated_function (|
                  Ty.path "alloy_primitives::bits::bloom::Bloom",
                  "new",
                  [],
                  []
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "const_hex::traits::FromHex"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *)
          [ ("Error", InstanceField.Ty _Error); ("from_hex", InstanceField.Method from_hex) ].
    End Impl_const_hex_traits_FromHex_for_alloy_primitives_bits_bloom_Bloom.
    
    Module Impl_alloy_primitives_bits_bloom_Bloom.
      Definition Self : Ty.t := Ty.path "alloy_primitives::bits::bloom::Bloom".
      
      (*             pub const ZERO: Self = Self($crate::FixedBytes::ZERO); *)
      (* Ty.path "alloy_primitives::bits::bloom::Bloom" *)
      Definition value_ZERO (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple
              "alloy_primitives::bits::bloom::Bloom"
              [
                M.read (|
                  get_associated_constant (|
                    Ty.apply
                      (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                      [ Value.Integer IntegerKind.Usize 256 ]
                      [],
                    "ZERO",
                    Ty.apply
                      (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                      [ Value.Integer IntegerKind.Usize 256 ]
                      []
                  |)
                |)
              ]
          |))).
      
      Global Instance AssociatedConstant_value_ZERO :
        M.IsAssociatedFunction.C Self "ZERO" value_ZERO.
      Admitted.
      Global Typeclasses Opaque value_ZERO.
      
      (*
                  pub const fn new(bytes: [u8; $n]) -> Self {
                      Self($crate::FixedBytes(bytes))
                  }
      *)
      Definition new (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ bytes ] =>
          ltac:(M.monadic
            (let bytes := M.alloc (| bytes |) in
            Value.StructTuple
              "alloy_primitives::bits::bloom::Bloom"
              [ Value.StructTuple "alloy_primitives::bits::fixed::FixedBytes" [ M.read (| bytes |) ]
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_new : M.IsAssociatedFunction.C Self "new" new.
      Admitted.
      Global Typeclasses Opaque new.
      
      (*
                  pub const fn with_last_byte(x: u8) -> Self {
                      Self($crate::FixedBytes::with_last_byte(x))
                  }
      *)
      Definition with_last_byte (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ x ] =>
          ltac:(M.monadic
            (let x := M.alloc (| x |) in
            Value.StructTuple
              "alloy_primitives::bits::bloom::Bloom"
              [
                M.call_closure (|
                  Ty.apply
                    (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                    [ Value.Integer IntegerKind.Usize 256 ]
                    [],
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                      [ Value.Integer IntegerKind.Usize 256 ]
                      [],
                    "with_last_byte",
                    [],
                    []
                  |),
                  [ M.read (| x |) ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_with_last_byte :
        M.IsAssociatedFunction.C Self "with_last_byte" with_last_byte.
      Admitted.
      Global Typeclasses Opaque with_last_byte.
      
      (*
                  pub const fn repeat_byte(byte: u8) -> Self {
                      Self($crate::FixedBytes::repeat_byte(byte))
                  }
      *)
      Definition repeat_byte (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ byte ] =>
          ltac:(M.monadic
            (let byte := M.alloc (| byte |) in
            Value.StructTuple
              "alloy_primitives::bits::bloom::Bloom"
              [
                M.call_closure (|
                  Ty.apply
                    (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                    [ Value.Integer IntegerKind.Usize 256 ]
                    [],
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                      [ Value.Integer IntegerKind.Usize 256 ]
                      [],
                    "repeat_byte",
                    [],
                    []
                  |),
                  [ M.read (| byte |) ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_repeat_byte :
        M.IsAssociatedFunction.C Self "repeat_byte" repeat_byte.
      Admitted.
      Global Typeclasses Opaque repeat_byte.
      
      (*
                  pub const fn len_bytes() -> usize {
                      $n
                  }
      *)
      Definition len_bytes (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [] => ltac:(M.monadic (Value.Integer IntegerKind.Usize 256))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_len_bytes :
        M.IsAssociatedFunction.C Self "len_bytes" len_bytes.
      Admitted.
      Global Typeclasses Opaque len_bytes.
      
      (*
                  pub fn from_slice(src: &[u8]) -> Self {
                      match Self::try_from(src) {
                          Ok(x) => x,
                          Err(_) => panic!("cannot convert a slice of length {} to {}", src.len(), stringify!($name)),
                      }
                  }
      *)
      Definition from_slice (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ src ] =>
          ltac:(M.monadic
            (let src := M.alloc (| src |) in
            M.read (|
              M.match_operator (|
                Some (Ty.path "alloy_primitives::bits::bloom::Bloom"),
                M.alloc (|
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "core::result::Result")
                      []
                      [
                        Ty.path "alloy_primitives::bits::bloom::Bloom";
                        Ty.path "core::array::TryFromSliceError"
                      ],
                    M.get_trait_method (|
                      "core::convert::TryFrom",
                      Ty.path "alloy_primitives::bits::bloom::Bloom",
                      [],
                      [ Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
                      ],
                      "try_from",
                      [],
                      []
                    |),
                    [ M.read (| src |) ]
                  |)
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::result::Result::Ok",
                          0
                        |) in
                      let x := M.copy (| γ0_0 |) in
                      x));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::result::Result::Err",
                          0
                        |) in
                      M.alloc (|
                        M.never_to_any (|
                          M.call_closure (|
                            Ty.path "never",
                            M.get_function (| "core::panicking::panic_fmt", [], [] |),
                            [
                              M.call_closure (|
                                Ty.path "core::fmt::Arguments",
                                M.get_associated_function (|
                                  Ty.path "core::fmt::Arguments",
                                  "new_v1",
                                  [
                                    Value.Integer IntegerKind.Usize 2;
                                    Value.Integer IntegerKind.Usize 1
                                  ],
                                  []
                                |),
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (|
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.alloc (|
                                          Value.Array
                                            [
                                              mk_str (| "cannot convert a slice of length " |);
                                              mk_str (| " to Bloom" |)
                                            ]
                                        |)
                                      |)
                                    |)
                                  |);
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (|
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.alloc (|
                                          Value.Array
                                            [
                                              M.call_closure (|
                                                Ty.path "core::fmt::rt::Argument",
                                                M.get_associated_function (|
                                                  Ty.path "core::fmt::rt::Argument",
                                                  "new_display",
                                                  [],
                                                  [ Ty.path "usize" ]
                                                |),
                                                [
                                                  M.borrow (|
                                                    Pointer.Kind.Ref,
                                                    M.deref (|
                                                      M.borrow (|
                                                        Pointer.Kind.Ref,
                                                        M.alloc (|
                                                          M.call_closure (|
                                                            Ty.path "usize",
                                                            M.get_associated_function (|
                                                              Ty.apply
                                                                (Ty.path "slice")
                                                                []
                                                                [ Ty.path "u8" ],
                                                              "len",
                                                              [],
                                                              []
                                                            |),
                                                            [
                                                              M.borrow (|
                                                                Pointer.Kind.Ref,
                                                                M.deref (| M.read (| src |) |)
                                                              |)
                                                            ]
                                                          |)
                                                        |)
                                                      |)
                                                    |)
                                                  |)
                                                ]
                                              |)
                                            ]
                                        |)
                                      |)
                                    |)
                                  |)
                                ]
                              |)
                            ]
                          |)
                        |)
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_from_slice :
        M.IsAssociatedFunction.C Self "from_slice" from_slice.
      Admitted.
      Global Typeclasses Opaque from_slice.
      
      (*
                  pub fn left_padding_from(value: &[u8]) -> Self {
                      Self($crate::FixedBytes::left_padding_from(value))
                  }
      *)
      Definition left_padding_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            Value.StructTuple
              "alloy_primitives::bits::bloom::Bloom"
              [
                M.call_closure (|
                  Ty.apply
                    (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                    [ Value.Integer IntegerKind.Usize 256 ]
                    [],
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                      [ Value.Integer IntegerKind.Usize 256 ]
                      [],
                    "left_padding_from",
                    [],
                    []
                  |),
                  [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| value |) |) |) ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_left_padding_from :
        M.IsAssociatedFunction.C Self "left_padding_from" left_padding_from.
      Admitted.
      Global Typeclasses Opaque left_padding_from.
      
      (*
                  pub fn right_padding_from(value: &[u8]) -> Self {
                      Self($crate::FixedBytes::right_padding_from(value))
                  }
      *)
      Definition right_padding_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            Value.StructTuple
              "alloy_primitives::bits::bloom::Bloom"
              [
                M.call_closure (|
                  Ty.apply
                    (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                    [ Value.Integer IntegerKind.Usize 256 ]
                    [],
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                      [ Value.Integer IntegerKind.Usize 256 ]
                      [],
                    "right_padding_from",
                    [],
                    []
                  |),
                  [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| value |) |) |) ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_right_padding_from :
        M.IsAssociatedFunction.C Self "right_padding_from" right_padding_from.
      Admitted.
      Global Typeclasses Opaque right_padding_from.
      
      (*
                  pub const fn into_array(self) -> [u8; $n] {
                      self.0 .0
                  }
      *)
      Definition into_array (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.SubPointer.get_struct_tuple_field (|
                M.SubPointer.get_struct_tuple_field (|
                  self,
                  "alloy_primitives::bits::bloom::Bloom",
                  0
                |),
                "alloy_primitives::bits::fixed::FixedBytes",
                0
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_into_array :
        M.IsAssociatedFunction.C Self "into_array" into_array.
      Admitted.
      Global Typeclasses Opaque into_array.
      
      (*
                  pub fn covers(&self, b: &Self) -> bool {
                      &( *b & *self) == b
                  }
      *)
      Definition covers (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; b ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let b := M.alloc (| b |) in
            M.call_closure (|
              Ty.path "bool",
              M.get_trait_method (|
                "core::cmp::PartialEq",
                Ty.apply (Ty.path "&") [] [ Ty.path "alloy_primitives::bits::bloom::Bloom" ],
                [],
                [ Ty.apply (Ty.path "&") [] [ Ty.path "alloy_primitives::bits::bloom::Bloom" ] ],
                "eq",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.alloc (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.alloc (|
                        M.call_closure (|
                          Ty.path "alloy_primitives::bits::bloom::Bloom",
                          M.get_trait_method (|
                            "core::ops::bit::BitAnd",
                            Ty.path "alloy_primitives::bits::bloom::Bloom",
                            [],
                            [ Ty.path "alloy_primitives::bits::bloom::Bloom" ],
                            "bitand",
                            [],
                            []
                          |),
                          [
                            M.read (| M.deref (| M.read (| b |) |) |);
                            M.read (| M.deref (| M.read (| self |) |) |)
                          ]
                        |)
                      |)
                    |)
                  |)
                |);
                M.borrow (| Pointer.Kind.Ref, b |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_covers : M.IsAssociatedFunction.C Self "covers" covers.
      Admitted.
      Global Typeclasses Opaque covers.
      
      (*
                  pub const fn const_eq(&self, other: &Self) -> bool {
                      self.0.const_eq(&other.0)
                  }
      *)
      Definition const_eq (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              Ty.path "bool",
              M.get_associated_function (|
                Ty.apply
                  (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                  [ Value.Integer IntegerKind.Usize 256 ]
                  [],
                "const_eq",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.SubPointer.get_struct_tuple_field (|
                    M.deref (| M.read (| self |) |),
                    "alloy_primitives::bits::bloom::Bloom",
                    0
                  |)
                |);
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_tuple_field (|
                        M.deref (| M.read (| other |) |),
                        "alloy_primitives::bits::bloom::Bloom",
                        0
                      |)
                    |)
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_const_eq :
        M.IsAssociatedFunction.C Self "const_eq" const_eq.
      Admitted.
      Global Typeclasses Opaque const_eq.
      
      (*
                  pub const fn bit_and(self, rhs: Self) -> Self {
                      Self(self.0.bit_and(rhs.0))
                  }
      *)
      Definition bit_and (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            Value.StructTuple
              "alloy_primitives::bits::bloom::Bloom"
              [
                M.call_closure (|
                  Ty.apply
                    (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                    [ Value.Integer IntegerKind.Usize 256 ]
                    [],
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                      [ Value.Integer IntegerKind.Usize 256 ]
                      [],
                    "bit_and",
                    [],
                    []
                  |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "alloy_primitives::bits::bloom::Bloom",
                        0
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        rhs,
                        "alloy_primitives::bits::bloom::Bloom",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_bit_and : M.IsAssociatedFunction.C Self "bit_and" bit_and.
      Admitted.
      Global Typeclasses Opaque bit_and.
      
      (*
                  pub const fn bit_or(self, rhs: Self) -> Self {
                      Self(self.0.bit_or(rhs.0))
                  }
      *)
      Definition bit_or (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            Value.StructTuple
              "alloy_primitives::bits::bloom::Bloom"
              [
                M.call_closure (|
                  Ty.apply
                    (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                    [ Value.Integer IntegerKind.Usize 256 ]
                    [],
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                      [ Value.Integer IntegerKind.Usize 256 ]
                      [],
                    "bit_or",
                    [],
                    []
                  |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "alloy_primitives::bits::bloom::Bloom",
                        0
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        rhs,
                        "alloy_primitives::bits::bloom::Bloom",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_bit_or : M.IsAssociatedFunction.C Self "bit_or" bit_or.
      Admitted.
      Global Typeclasses Opaque bit_or.
      
      (*
                  pub const fn bit_xor(self, rhs: Self) -> Self {
                      Self(self.0.bit_xor(rhs.0))
                  }
      *)
      Definition bit_xor (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            Value.StructTuple
              "alloy_primitives::bits::bloom::Bloom"
              [
                M.call_closure (|
                  Ty.apply
                    (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                    [ Value.Integer IntegerKind.Usize 256 ]
                    [],
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                      [ Value.Integer IntegerKind.Usize 256 ]
                      [],
                    "bit_xor",
                    [],
                    []
                  |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "alloy_primitives::bits::bloom::Bloom",
                        0
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        rhs,
                        "alloy_primitives::bits::bloom::Bloom",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_bit_xor : M.IsAssociatedFunction.C Self "bit_xor" bit_xor.
      Admitted.
      Global Typeclasses Opaque bit_xor.
    End Impl_alloy_primitives_bits_bloom_Bloom.
  End bloom.
  
  Module fixed.
    Module Impl_core_borrow_Borrow_slice_u8_for_alloy_primitives_bits_fixed_FixedBytes_N.
      Definition Self (N : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::bits::fixed::FixedBytes") [ N ] [].
      
      (*
                  fn borrow(&self) -> &$t {
                      $crate::private::Borrow::borrow(&self.0)
                  }
      *)
      Definition borrow (N : Value.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self N in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.borrow (|
              Pointer.Kind.Ref,
              M.deref (|
                M.call_closure (|
                  Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                  M.get_trait_method (|
                    "core::borrow::Borrow",
                    Ty.apply (Ty.path "array") [ N ] [ Ty.path "u8" ],
                    [],
                    [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                    "borrow",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_tuple_field (|
                            M.deref (| M.read (| self |) |),
                            "alloy_primitives::bits::fixed::FixedBytes",
                            0
                          |)
                        |)
                      |)
                    |)
                  ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (N : Value.t),
        M.IsTraitInstance
          "core::borrow::Borrow"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
          (Self N)
          (* Instance *) [ ("borrow", InstanceField.Method (borrow N)) ].
    End Impl_core_borrow_Borrow_slice_u8_for_alloy_primitives_bits_fixed_FixedBytes_N.
    
    Module Impl_core_borrow_Borrow_slice_u8_for_ref__alloy_primitives_bits_fixed_FixedBytes_N.
      Definition Self (N : Value.t) : Ty.t :=
        Ty.apply
          (Ty.path "&")
          []
          [ Ty.apply (Ty.path "alloy_primitives::bits::fixed::FixedBytes") [ N ] [] ].
      
      (*
                  fn borrow(&self) -> &$t {
                      $crate::private::Borrow::borrow(&self.0)
                  }
      *)
      Definition borrow (N : Value.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self N in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.borrow (|
              Pointer.Kind.Ref,
              M.deref (|
                M.call_closure (|
                  Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                  M.get_trait_method (|
                    "core::borrow::Borrow",
                    Ty.apply (Ty.path "array") [ N ] [ Ty.path "u8" ],
                    [],
                    [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                    "borrow",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_tuple_field (|
                            M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |),
                            "alloy_primitives::bits::fixed::FixedBytes",
                            0
                          |)
                        |)
                      |)
                    |)
                  ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (N : Value.t),
        M.IsTraitInstance
          "core::borrow::Borrow"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
          (Self N)
          (* Instance *) [ ("borrow", InstanceField.Method (borrow N)) ].
    End Impl_core_borrow_Borrow_slice_u8_for_ref__alloy_primitives_bits_fixed_FixedBytes_N.
    
    Module Impl_core_borrow_Borrow_slice_u8_for_ref_mut_alloy_primitives_bits_fixed_FixedBytes_N.
      Definition Self (N : Value.t) : Ty.t :=
        Ty.apply
          (Ty.path "&mut")
          []
          [ Ty.apply (Ty.path "alloy_primitives::bits::fixed::FixedBytes") [ N ] [] ].
      
      (*
                  fn borrow(&self) -> &$t {
                      $crate::private::Borrow::borrow(&self.0)
                  }
      *)
      Definition borrow (N : Value.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self N in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.borrow (|
              Pointer.Kind.Ref,
              M.deref (|
                M.call_closure (|
                  Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                  M.get_trait_method (|
                    "core::borrow::Borrow",
                    Ty.apply (Ty.path "array") [ N ] [ Ty.path "u8" ],
                    [],
                    [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                    "borrow",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_tuple_field (|
                            M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |),
                            "alloy_primitives::bits::fixed::FixedBytes",
                            0
                          |)
                        |)
                      |)
                    |)
                  ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (N : Value.t),
        M.IsTraitInstance
          "core::borrow::Borrow"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
          (Self N)
          (* Instance *) [ ("borrow", InstanceField.Method (borrow N)) ].
    End Impl_core_borrow_Borrow_slice_u8_for_ref_mut_alloy_primitives_bits_fixed_FixedBytes_N.
    
    Module Impl_core_borrow_Borrow_array_N_u8_for_alloy_primitives_bits_fixed_FixedBytes_N.
      Definition Self (N : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::bits::fixed::FixedBytes") [ N ] [].
      
      (*
                  fn borrow(&self) -> &$t {
                      $crate::private::Borrow::borrow(&self.0)
                  }
      *)
      Definition borrow (N : Value.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self N in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.borrow (|
              Pointer.Kind.Ref,
              M.deref (|
                M.call_closure (|
                  Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "array") [ N ] [ Ty.path "u8" ] ],
                  M.get_trait_method (|
                    "core::borrow::Borrow",
                    Ty.apply (Ty.path "array") [ N ] [ Ty.path "u8" ],
                    [],
                    [ Ty.apply (Ty.path "array") [ N ] [ Ty.path "u8" ] ],
                    "borrow",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_tuple_field (|
                            M.deref (| M.read (| self |) |),
                            "alloy_primitives::bits::fixed::FixedBytes",
                            0
                          |)
                        |)
                      |)
                    |)
                  ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (N : Value.t),
        M.IsTraitInstance
          "core::borrow::Borrow"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.apply (Ty.path "array") [ N ] [ Ty.path "u8" ] ]
          (Self N)
          (* Instance *) [ ("borrow", InstanceField.Method (borrow N)) ].
    End Impl_core_borrow_Borrow_array_N_u8_for_alloy_primitives_bits_fixed_FixedBytes_N.
    
    Module Impl_core_borrow_Borrow_array_N_u8_for_ref__alloy_primitives_bits_fixed_FixedBytes_N.
      Definition Self (N : Value.t) : Ty.t :=
        Ty.apply
          (Ty.path "&")
          []
          [ Ty.apply (Ty.path "alloy_primitives::bits::fixed::FixedBytes") [ N ] [] ].
      
      (*
                  fn borrow(&self) -> &$t {
                      $crate::private::Borrow::borrow(&self.0)
                  }
      *)
      Definition borrow (N : Value.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self N in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.borrow (|
              Pointer.Kind.Ref,
              M.deref (|
                M.call_closure (|
                  Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "array") [ N ] [ Ty.path "u8" ] ],
                  M.get_trait_method (|
                    "core::borrow::Borrow",
                    Ty.apply (Ty.path "array") [ N ] [ Ty.path "u8" ],
                    [],
                    [ Ty.apply (Ty.path "array") [ N ] [ Ty.path "u8" ] ],
                    "borrow",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_tuple_field (|
                            M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |),
                            "alloy_primitives::bits::fixed::FixedBytes",
                            0
                          |)
                        |)
                      |)
                    |)
                  ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (N : Value.t),
        M.IsTraitInstance
          "core::borrow::Borrow"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.apply (Ty.path "array") [ N ] [ Ty.path "u8" ] ]
          (Self N)
          (* Instance *) [ ("borrow", InstanceField.Method (borrow N)) ].
    End Impl_core_borrow_Borrow_array_N_u8_for_ref__alloy_primitives_bits_fixed_FixedBytes_N.
    
    Module Impl_core_borrow_Borrow_array_N_u8_for_ref_mut_alloy_primitives_bits_fixed_FixedBytes_N.
      Definition Self (N : Value.t) : Ty.t :=
        Ty.apply
          (Ty.path "&mut")
          []
          [ Ty.apply (Ty.path "alloy_primitives::bits::fixed::FixedBytes") [ N ] [] ].
      
      (*
                  fn borrow(&self) -> &$t {
                      $crate::private::Borrow::borrow(&self.0)
                  }
      *)
      Definition borrow (N : Value.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self N in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.borrow (|
              Pointer.Kind.Ref,
              M.deref (|
                M.call_closure (|
                  Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "array") [ N ] [ Ty.path "u8" ] ],
                  M.get_trait_method (|
                    "core::borrow::Borrow",
                    Ty.apply (Ty.path "array") [ N ] [ Ty.path "u8" ],
                    [],
                    [ Ty.apply (Ty.path "array") [ N ] [ Ty.path "u8" ] ],
                    "borrow",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_tuple_field (|
                            M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |),
                            "alloy_primitives::bits::fixed::FixedBytes",
                            0
                          |)
                        |)
                      |)
                    |)
                  ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (N : Value.t),
        M.IsTraitInstance
          "core::borrow::Borrow"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.apply (Ty.path "array") [ N ] [ Ty.path "u8" ] ]
          (Self N)
          (* Instance *) [ ("borrow", InstanceField.Method (borrow N)) ].
    End Impl_core_borrow_Borrow_array_N_u8_for_ref_mut_alloy_primitives_bits_fixed_FixedBytes_N.
    
    Module Impl_core_borrow_BorrowMut_slice_u8_for_alloy_primitives_bits_fixed_FixedBytes_N.
      Definition Self (N : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::bits::fixed::FixedBytes") [ N ] [].
      
      (*
                  fn borrow_mut(&mut self) -> &mut $t {
                      $crate::private::BorrowMut::borrow_mut(&mut self.0)
                  }
      *)
      Definition borrow_mut
          (N : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self N in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.borrow (|
              Pointer.Kind.MutRef,
              M.deref (|
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.deref (|
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "&mut")
                        []
                        [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                      M.get_trait_method (|
                        "core::borrow::BorrowMut",
                        Ty.apply (Ty.path "array") [ N ] [ Ty.path "u8" ],
                        [],
                        [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                        "borrow_mut",
                        [],
                        []
                      |),
                      [
                        M.borrow (|
                          Pointer.Kind.MutRef,
                          M.deref (|
                            M.borrow (|
                              Pointer.Kind.MutRef,
                              M.SubPointer.get_struct_tuple_field (|
                                M.deref (| M.read (| self |) |),
                                "alloy_primitives::bits::fixed::FixedBytes",
                                0
                              |)
                            |)
                          |)
                        |)
                      ]
                    |)
                  |)
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (N : Value.t),
        M.IsTraitInstance
          "core::borrow::BorrowMut"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
          (Self N)
          (* Instance *) [ ("borrow_mut", InstanceField.Method (borrow_mut N)) ].
    End Impl_core_borrow_BorrowMut_slice_u8_for_alloy_primitives_bits_fixed_FixedBytes_N.
    
    Module Impl_core_borrow_BorrowMut_slice_u8_for_ref_mut_alloy_primitives_bits_fixed_FixedBytes_N.
      Definition Self (N : Value.t) : Ty.t :=
        Ty.apply
          (Ty.path "&mut")
          []
          [ Ty.apply (Ty.path "alloy_primitives::bits::fixed::FixedBytes") [ N ] [] ].
      
      (*
                  fn borrow_mut(&mut self) -> &mut $t {
                      $crate::private::BorrowMut::borrow_mut(&mut self.0)
                  }
      *)
      Definition borrow_mut
          (N : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self N in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.borrow (|
              Pointer.Kind.MutRef,
              M.deref (|
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.deref (|
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "&mut")
                        []
                        [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                      M.get_trait_method (|
                        "core::borrow::BorrowMut",
                        Ty.apply (Ty.path "array") [ N ] [ Ty.path "u8" ],
                        [],
                        [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                        "borrow_mut",
                        [],
                        []
                      |),
                      [
                        M.borrow (|
                          Pointer.Kind.MutRef,
                          M.deref (|
                            M.borrow (|
                              Pointer.Kind.MutRef,
                              M.SubPointer.get_struct_tuple_field (|
                                M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |),
                                "alloy_primitives::bits::fixed::FixedBytes",
                                0
                              |)
                            |)
                          |)
                        |)
                      ]
                    |)
                  |)
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (N : Value.t),
        M.IsTraitInstance
          "core::borrow::BorrowMut"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
          (Self N)
          (* Instance *) [ ("borrow_mut", InstanceField.Method (borrow_mut N)) ].
    End Impl_core_borrow_BorrowMut_slice_u8_for_ref_mut_alloy_primitives_bits_fixed_FixedBytes_N.
    
    Module Impl_core_borrow_BorrowMut_array_N_u8_for_alloy_primitives_bits_fixed_FixedBytes_N.
      Definition Self (N : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::bits::fixed::FixedBytes") [ N ] [].
      
      (*
                  fn borrow_mut(&mut self) -> &mut $t {
                      $crate::private::BorrowMut::borrow_mut(&mut self.0)
                  }
      *)
      Definition borrow_mut
          (N : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self N in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.borrow (|
              Pointer.Kind.MutRef,
              M.deref (|
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.deref (|
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "&mut")
                        []
                        [ Ty.apply (Ty.path "array") [ N ] [ Ty.path "u8" ] ],
                      M.get_trait_method (|
                        "core::borrow::BorrowMut",
                        Ty.apply (Ty.path "array") [ N ] [ Ty.path "u8" ],
                        [],
                        [ Ty.apply (Ty.path "array") [ N ] [ Ty.path "u8" ] ],
                        "borrow_mut",
                        [],
                        []
                      |),
                      [
                        M.borrow (|
                          Pointer.Kind.MutRef,
                          M.deref (|
                            M.borrow (|
                              Pointer.Kind.MutRef,
                              M.SubPointer.get_struct_tuple_field (|
                                M.deref (| M.read (| self |) |),
                                "alloy_primitives::bits::fixed::FixedBytes",
                                0
                              |)
                            |)
                          |)
                        |)
                      ]
                    |)
                  |)
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (N : Value.t),
        M.IsTraitInstance
          "core::borrow::BorrowMut"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.apply (Ty.path "array") [ N ] [ Ty.path "u8" ] ]
          (Self N)
          (* Instance *) [ ("borrow_mut", InstanceField.Method (borrow_mut N)) ].
    End Impl_core_borrow_BorrowMut_array_N_u8_for_alloy_primitives_bits_fixed_FixedBytes_N.
    
    Module Impl_core_borrow_BorrowMut_array_N_u8_for_ref_mut_alloy_primitives_bits_fixed_FixedBytes_N.
      Definition Self (N : Value.t) : Ty.t :=
        Ty.apply
          (Ty.path "&mut")
          []
          [ Ty.apply (Ty.path "alloy_primitives::bits::fixed::FixedBytes") [ N ] [] ].
      
      (*
                  fn borrow_mut(&mut self) -> &mut $t {
                      $crate::private::BorrowMut::borrow_mut(&mut self.0)
                  }
      *)
      Definition borrow_mut
          (N : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self N in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.borrow (|
              Pointer.Kind.MutRef,
              M.deref (|
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.deref (|
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "&mut")
                        []
                        [ Ty.apply (Ty.path "array") [ N ] [ Ty.path "u8" ] ],
                      M.get_trait_method (|
                        "core::borrow::BorrowMut",
                        Ty.apply (Ty.path "array") [ N ] [ Ty.path "u8" ],
                        [],
                        [ Ty.apply (Ty.path "array") [ N ] [ Ty.path "u8" ] ],
                        "borrow_mut",
                        [],
                        []
                      |),
                      [
                        M.borrow (|
                          Pointer.Kind.MutRef,
                          M.deref (|
                            M.borrow (|
                              Pointer.Kind.MutRef,
                              M.SubPointer.get_struct_tuple_field (|
                                M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |),
                                "alloy_primitives::bits::fixed::FixedBytes",
                                0
                              |)
                            |)
                          |)
                        |)
                      ]
                    |)
                  |)
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (N : Value.t),
        M.IsTraitInstance
          "core::borrow::BorrowMut"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.apply (Ty.path "array") [ N ] [ Ty.path "u8" ] ]
          (Self N)
          (* Instance *) [ ("borrow_mut", InstanceField.Method (borrow_mut N)) ].
    End Impl_core_borrow_BorrowMut_array_N_u8_for_ref_mut_alloy_primitives_bits_fixed_FixedBytes_N.
    
    Module Impl_core_convert_From_ref__array_N_u8_for_ref__alloy_primitives_bits_fixed_FixedBytes_N.
      Definition Self (N : Value.t) : Ty.t :=
        Ty.apply
          (Ty.path "&")
          []
          [ Ty.apply (Ty.path "alloy_primitives::bits::fixed::FixedBytes") [ N ] [] ].
      
      (*
                  fn from(value: $a) -> $b {
                      // SAFETY: guaranteed by caller
                      unsafe { $crate::private::core::mem::transmute::<$a, $b>(value) }
                  }
      *)
      Definition from (N : Value.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self N in
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "&")
                []
                [ Ty.apply (Ty.path "alloy_primitives::bits::fixed::FixedBytes") [ N ] [] ],
              M.get_function (|
                "core::intrinsics::transmute",
                [],
                [
                  Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "array") [ N ] [ Ty.path "u8" ] ];
                  Ty.apply
                    (Ty.path "&")
                    []
                    [ Ty.apply (Ty.path "alloy_primitives::bits::fixed::FixedBytes") [ N ] [] ]
                ]
              |),
              [ M.read (| value |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (N : Value.t),
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "array") [ N ] [ Ty.path "u8" ] ] ]
          (Self N)
          (* Instance *) [ ("from", InstanceField.Method (from N)) ].
    End Impl_core_convert_From_ref__array_N_u8_for_ref__alloy_primitives_bits_fixed_FixedBytes_N.
    
    Module Impl_core_convert_From_ref_mut_array_N_u8_for_ref__alloy_primitives_bits_fixed_FixedBytes_N.
      Definition Self (N : Value.t) : Ty.t :=
        Ty.apply
          (Ty.path "&")
          []
          [ Ty.apply (Ty.path "alloy_primitives::bits::fixed::FixedBytes") [ N ] [] ].
      
      (*
                  fn from(value: $a) -> $b {
                      // SAFETY: guaranteed by caller
                      unsafe { $crate::private::core::mem::transmute::<$a, $b>(value) }
                  }
      *)
      Definition from (N : Value.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self N in
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "&")
                []
                [ Ty.apply (Ty.path "alloy_primitives::bits::fixed::FixedBytes") [ N ] [] ],
              M.get_function (|
                "core::intrinsics::transmute",
                [],
                [
                  Ty.apply
                    (Ty.path "&mut")
                    []
                    [ Ty.apply (Ty.path "array") [ N ] [ Ty.path "u8" ] ];
                  Ty.apply
                    (Ty.path "&")
                    []
                    [ Ty.apply (Ty.path "alloy_primitives::bits::fixed::FixedBytes") [ N ] [] ]
                ]
              |),
              [ M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| value |) |) |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (N : Value.t),
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "array") [ N ] [ Ty.path "u8" ] ] ]
          (Self N)
          (* Instance *) [ ("from", InstanceField.Method (from N)) ].
    End Impl_core_convert_From_ref_mut_array_N_u8_for_ref__alloy_primitives_bits_fixed_FixedBytes_N.
    
    Module Impl_core_convert_From_ref_mut_array_N_u8_for_ref_mut_alloy_primitives_bits_fixed_FixedBytes_N.
      Definition Self (N : Value.t) : Ty.t :=
        Ty.apply
          (Ty.path "&mut")
          []
          [ Ty.apply (Ty.path "alloy_primitives::bits::fixed::FixedBytes") [ N ] [] ].
      
      (*
                  fn from(value: $a) -> $b {
                      // SAFETY: guaranteed by caller
                      unsafe { $crate::private::core::mem::transmute::<$a, $b>(value) }
                  }
      *)
      Definition from (N : Value.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self N in
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            M.borrow (|
              Pointer.Kind.MutRef,
              M.deref (|
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.MutRef,
                      M.deref (|
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "&mut")
                            []
                            [
                              Ty.apply
                                (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                                [ N ]
                                []
                            ],
                          M.get_function (|
                            "core::intrinsics::transmute",
                            [],
                            [
                              Ty.apply
                                (Ty.path "&mut")
                                []
                                [ Ty.apply (Ty.path "array") [ N ] [ Ty.path "u8" ] ];
                              Ty.apply
                                (Ty.path "&mut")
                                []
                                [
                                  Ty.apply
                                    (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                                    [ N ]
                                    []
                                ]
                            ]
                          |),
                          [ M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| value |) |) |) ]
                        |)
                      |)
                    |)
                  |)
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (N : Value.t),
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "array") [ N ] [ Ty.path "u8" ] ] ]
          (Self N)
          (* Instance *) [ ("from", InstanceField.Method (from N)) ].
    End Impl_core_convert_From_ref_mut_array_N_u8_for_ref_mut_alloy_primitives_bits_fixed_FixedBytes_N.
    
    Module Impl_core_convert_From_ref__alloy_primitives_bits_fixed_FixedBytes_N_for_ref__array_N_u8.
      Definition Self (N : Value.t) : Ty.t :=
        Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "array") [ N ] [ Ty.path "u8" ] ].
      
      (*
                  fn from(value: $a) -> $b {
                      // SAFETY: guaranteed by caller
                      unsafe { $crate::private::core::mem::transmute::<$a, $b>(value) }
                  }
      *)
      Definition from (N : Value.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self N in
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            M.call_closure (|
              Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "array") [ N ] [ Ty.path "u8" ] ],
              M.get_function (|
                "core::intrinsics::transmute",
                [],
                [
                  Ty.apply
                    (Ty.path "&")
                    []
                    [ Ty.apply (Ty.path "alloy_primitives::bits::fixed::FixedBytes") [ N ] [] ];
                  Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "array") [ N ] [ Ty.path "u8" ] ]
                ]
              |),
              [ M.read (| value |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (N : Value.t),
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [
            Ty.apply
              (Ty.path "&")
              []
              [ Ty.apply (Ty.path "alloy_primitives::bits::fixed::FixedBytes") [ N ] [] ]
          ]
          (Self N)
          (* Instance *) [ ("from", InstanceField.Method (from N)) ].
    End Impl_core_convert_From_ref__alloy_primitives_bits_fixed_FixedBytes_N_for_ref__array_N_u8.
    
    Module Impl_core_convert_From_ref_mut_alloy_primitives_bits_fixed_FixedBytes_N_for_ref__array_N_u8.
      Definition Self (N : Value.t) : Ty.t :=
        Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "array") [ N ] [ Ty.path "u8" ] ].
      
      (*
                  fn from(value: $a) -> $b {
                      // SAFETY: guaranteed by caller
                      unsafe { $crate::private::core::mem::transmute::<$a, $b>(value) }
                  }
      *)
      Definition from (N : Value.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self N in
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            M.call_closure (|
              Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "array") [ N ] [ Ty.path "u8" ] ],
              M.get_function (|
                "core::intrinsics::transmute",
                [],
                [
                  Ty.apply
                    (Ty.path "&mut")
                    []
                    [ Ty.apply (Ty.path "alloy_primitives::bits::fixed::FixedBytes") [ N ] [] ];
                  Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "array") [ N ] [ Ty.path "u8" ] ]
                ]
              |),
              [ M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| value |) |) |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (N : Value.t),
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [
            Ty.apply
              (Ty.path "&mut")
              []
              [ Ty.apply (Ty.path "alloy_primitives::bits::fixed::FixedBytes") [ N ] [] ]
          ]
          (Self N)
          (* Instance *) [ ("from", InstanceField.Method (from N)) ].
    End Impl_core_convert_From_ref_mut_alloy_primitives_bits_fixed_FixedBytes_N_for_ref__array_N_u8.
    
    Module Impl_core_convert_From_ref_mut_alloy_primitives_bits_fixed_FixedBytes_N_for_ref_mut_array_N_u8.
      Definition Self (N : Value.t) : Ty.t :=
        Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "array") [ N ] [ Ty.path "u8" ] ].
      
      (*
                  fn from(value: $a) -> $b {
                      // SAFETY: guaranteed by caller
                      unsafe { $crate::private::core::mem::transmute::<$a, $b>(value) }
                  }
      *)
      Definition from (N : Value.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self N in
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            M.borrow (|
              Pointer.Kind.MutRef,
              M.deref (|
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.MutRef,
                      M.deref (|
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "&mut")
                            []
                            [ Ty.apply (Ty.path "array") [ N ] [ Ty.path "u8" ] ],
                          M.get_function (|
                            "core::intrinsics::transmute",
                            [],
                            [
                              Ty.apply
                                (Ty.path "&mut")
                                []
                                [
                                  Ty.apply
                                    (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                                    [ N ]
                                    []
                                ];
                              Ty.apply
                                (Ty.path "&mut")
                                []
                                [ Ty.apply (Ty.path "array") [ N ] [ Ty.path "u8" ] ]
                            ]
                          |),
                          [ M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| value |) |) |) ]
                        |)
                      |)
                    |)
                  |)
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (N : Value.t),
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [
            Ty.apply
              (Ty.path "&mut")
              []
              [ Ty.apply (Ty.path "alloy_primitives::bits::fixed::FixedBytes") [ N ] [] ]
          ]
          (Self N)
          (* Instance *) [ ("from", InstanceField.Method (from N)) ].
    End Impl_core_convert_From_ref_mut_alloy_primitives_bits_fixed_FixedBytes_N_for_ref_mut_array_N_u8.
    
    Module Impl_core_cmp_PartialEq_slice_u8_for_alloy_primitives_bits_fixed_FixedBytes_N.
      Definition Self (N : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::bits::fixed::FixedBytes") [ N ] [].
      
      (*
                  fn $fn(&self, other: &$a) -> $ret {
                      $crate::private::$tr::$fn(&self.0 $([$e])?, other)
                  }
      *)
      Definition eq (N : Value.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self N in
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              Ty.path "bool",
              M.get_trait_method (|
                "core::cmp::PartialEq",
                Ty.apply (Ty.path "array") [ N ] [ Ty.path "u8" ],
                [],
                [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                "eq",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_tuple_field (|
                        M.deref (| M.read (| self |) |),
                        "alloy_primitives::bits::fixed::FixedBytes",
                        0
                      |)
                    |)
                  |)
                |);
                M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| other |) |) |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (N : Value.t),
        M.IsTraitInstance
          "core::cmp::PartialEq"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
          (Self N)
          (* Instance *) [ ("eq", InstanceField.Method (eq N)) ].
    End Impl_core_cmp_PartialEq_slice_u8_for_alloy_primitives_bits_fixed_FixedBytes_N.
    
    Module Impl_core_cmp_PartialEq_alloy_primitives_bits_fixed_FixedBytes_N_for_slice_u8.
      Definition Self (N : Value.t) : Ty.t := Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ].
      
      (*
                  fn $fn(&self, other: &$b) -> $ret {
                      $crate::private::$tr::$fn(self, &other.0 $([$e])?)
                  }
      *)
      Definition eq (N : Value.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self N in
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              Ty.path "bool",
              M.get_trait_method (|
                "core::cmp::PartialEq",
                Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                [],
                [ Ty.apply (Ty.path "array") [ N ] [ Ty.path "u8" ] ],
                "eq",
                [],
                []
              |),
              [
                M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |);
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_tuple_field (|
                        M.deref (| M.read (| other |) |),
                        "alloy_primitives::bits::fixed::FixedBytes",
                        0
                      |)
                    |)
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (N : Value.t),
        M.IsTraitInstance
          "core::cmp::PartialEq"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "alloy_primitives::bits::fixed::FixedBytes") [ N ] [] ]
          (Self N)
          (* Instance *) [ ("eq", InstanceField.Method (eq N)) ].
    End Impl_core_cmp_PartialEq_alloy_primitives_bits_fixed_FixedBytes_N_for_slice_u8.
    
    Module Impl_core_cmp_PartialEq_ref__slice_u8_for_alloy_primitives_bits_fixed_FixedBytes_N.
      Definition Self (N : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::bits::fixed::FixedBytes") [ N ] [].
      
      (*
                  fn $fn(&self, other: &&$a) -> $ret {
                      $crate::private::$tr::$fn(&self.0 $([$e])?, *other)
                  }
      *)
      Definition eq (N : Value.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self N in
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              Ty.path "bool",
              M.get_trait_method (|
                "core::cmp::PartialEq",
                Ty.apply (Ty.path "array") [ N ] [ Ty.path "u8" ],
                [],
                [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                "eq",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_tuple_field (|
                        M.deref (| M.read (| self |) |),
                        "alloy_primitives::bits::fixed::FixedBytes",
                        0
                      |)
                    |)
                  |)
                |);
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (| M.read (| M.deref (| M.read (| other |) |) |) |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (N : Value.t),
        M.IsTraitInstance
          "core::cmp::PartialEq"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ] ]
          (Self N)
          (* Instance *) [ ("eq", InstanceField.Method (eq N)) ].
    End Impl_core_cmp_PartialEq_ref__slice_u8_for_alloy_primitives_bits_fixed_FixedBytes_N.
    
    Module Impl_core_cmp_PartialEq_alloy_primitives_bits_fixed_FixedBytes_N_for_ref__slice_u8.
      Definition Self (N : Value.t) : Ty.t :=
        Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ].
      
      (*
                  fn $fn(&self, other: &$b) -> $ret {
                      $crate::private::$tr::$fn( *self, &other.0 $([$e])?)
                  }
      *)
      Definition eq (N : Value.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self N in
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              Ty.path "bool",
              M.get_trait_method (|
                "core::cmp::PartialEq",
                Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                [],
                [ Ty.apply (Ty.path "array") [ N ] [ Ty.path "u8" ] ],
                "eq",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
                |);
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_tuple_field (|
                        M.deref (| M.read (| other |) |),
                        "alloy_primitives::bits::fixed::FixedBytes",
                        0
                      |)
                    |)
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (N : Value.t),
        M.IsTraitInstance
          "core::cmp::PartialEq"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "alloy_primitives::bits::fixed::FixedBytes") [ N ] [] ]
          (Self N)
          (* Instance *) [ ("eq", InstanceField.Method (eq N)) ].
    End Impl_core_cmp_PartialEq_alloy_primitives_bits_fixed_FixedBytes_N_for_ref__slice_u8.
    
    Module Impl_core_cmp_PartialEq_slice_u8_for_ref__alloy_primitives_bits_fixed_FixedBytes_N.
      Definition Self (N : Value.t) : Ty.t :=
        Ty.apply
          (Ty.path "&")
          []
          [ Ty.apply (Ty.path "alloy_primitives::bits::fixed::FixedBytes") [ N ] [] ].
      
      (*
                  fn $fn(&self, other: &$a) -> $ret {
                      $crate::private::$tr::$fn(&self.0 $([$e])?, other)
                  }
      *)
      Definition eq (N : Value.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self N in
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              Ty.path "bool",
              M.get_trait_method (|
                "core::cmp::PartialEq",
                Ty.apply (Ty.path "array") [ N ] [ Ty.path "u8" ],
                [],
                [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                "eq",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_tuple_field (|
                        M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |),
                        "alloy_primitives::bits::fixed::FixedBytes",
                        0
                      |)
                    |)
                  |)
                |);
                M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| other |) |) |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (N : Value.t),
        M.IsTraitInstance
          "core::cmp::PartialEq"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
          (Self N)
          (* Instance *) [ ("eq", InstanceField.Method (eq N)) ].
    End Impl_core_cmp_PartialEq_slice_u8_for_ref__alloy_primitives_bits_fixed_FixedBytes_N.
    
    Module Impl_core_cmp_PartialEq_ref__alloy_primitives_bits_fixed_FixedBytes_N_for_slice_u8.
      Definition Self (N : Value.t) : Ty.t := Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ].
      
      (*
                  fn $fn(&self, other: &&$b) -> $ret {
                      $crate::private::$tr::$fn(self, &other.0 $([$e])?)
                  }
      *)
      Definition eq (N : Value.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self N in
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              Ty.path "bool",
              M.get_trait_method (|
                "core::cmp::PartialEq",
                Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                [],
                [ Ty.apply (Ty.path "array") [ N ] [ Ty.path "u8" ] ],
                "eq",
                [],
                []
              |),
              [
                M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |);
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_tuple_field (|
                        M.deref (| M.read (| M.deref (| M.read (| other |) |) |) |),
                        "alloy_primitives::bits::fixed::FixedBytes",
                        0
                      |)
                    |)
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (N : Value.t),
        M.IsTraitInstance
          "core::cmp::PartialEq"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [
            Ty.apply
              (Ty.path "&")
              []
              [ Ty.apply (Ty.path "alloy_primitives::bits::fixed::FixedBytes") [ N ] [] ]
          ]
          (Self N)
          (* Instance *) [ ("eq", InstanceField.Method (eq N)) ].
    End Impl_core_cmp_PartialEq_ref__alloy_primitives_bits_fixed_FixedBytes_N_for_slice_u8.
    
    Module Impl_core_cmp_PartialEq_array_N_u8_for_alloy_primitives_bits_fixed_FixedBytes_N.
      Definition Self (N : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::bits::fixed::FixedBytes") [ N ] [].
      
      (*
                  fn $fn(&self, other: &$a) -> $ret {
                      $crate::private::$tr::$fn(&self.0 $([$e])?, other)
                  }
      *)
      Definition eq (N : Value.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self N in
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              Ty.path "bool",
              M.get_trait_method (|
                "core::cmp::PartialEq",
                Ty.apply (Ty.path "array") [ N ] [ Ty.path "u8" ],
                [],
                [ Ty.apply (Ty.path "array") [ N ] [ Ty.path "u8" ] ],
                "eq",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_tuple_field (|
                        M.deref (| M.read (| self |) |),
                        "alloy_primitives::bits::fixed::FixedBytes",
                        0
                      |)
                    |)
                  |)
                |);
                M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| other |) |) |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (N : Value.t),
        M.IsTraitInstance
          "core::cmp::PartialEq"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.apply (Ty.path "array") [ N ] [ Ty.path "u8" ] ]
          (Self N)
          (* Instance *) [ ("eq", InstanceField.Method (eq N)) ].
    End Impl_core_cmp_PartialEq_array_N_u8_for_alloy_primitives_bits_fixed_FixedBytes_N.
    
    Module Impl_core_cmp_PartialEq_alloy_primitives_bits_fixed_FixedBytes_N_for_array_N_u8.
      Definition Self (N : Value.t) : Ty.t := Ty.apply (Ty.path "array") [ N ] [ Ty.path "u8" ].
      
      (*
                  fn $fn(&self, other: &$b) -> $ret {
                      $crate::private::$tr::$fn(self, &other.0 $([$e])?)
                  }
      *)
      Definition eq (N : Value.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self N in
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              Ty.path "bool",
              M.get_trait_method (|
                "core::cmp::PartialEq",
                Ty.apply (Ty.path "array") [ N ] [ Ty.path "u8" ],
                [],
                [ Ty.apply (Ty.path "array") [ N ] [ Ty.path "u8" ] ],
                "eq",
                [],
                []
              |),
              [
                M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |);
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_tuple_field (|
                        M.deref (| M.read (| other |) |),
                        "alloy_primitives::bits::fixed::FixedBytes",
                        0
                      |)
                    |)
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (N : Value.t),
        M.IsTraitInstance
          "core::cmp::PartialEq"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "alloy_primitives::bits::fixed::FixedBytes") [ N ] [] ]
          (Self N)
          (* Instance *) [ ("eq", InstanceField.Method (eq N)) ].
    End Impl_core_cmp_PartialEq_alloy_primitives_bits_fixed_FixedBytes_N_for_array_N_u8.
    
    Module Impl_core_cmp_PartialEq_ref__array_N_u8_for_alloy_primitives_bits_fixed_FixedBytes_N.
      Definition Self (N : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::bits::fixed::FixedBytes") [ N ] [].
      
      (*
                  fn $fn(&self, other: &&$a) -> $ret {
                      $crate::private::$tr::$fn(&self.0 $([$e])?, *other)
                  }
      *)
      Definition eq (N : Value.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self N in
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              Ty.path "bool",
              M.get_trait_method (|
                "core::cmp::PartialEq",
                Ty.apply (Ty.path "array") [ N ] [ Ty.path "u8" ],
                [],
                [ Ty.apply (Ty.path "array") [ N ] [ Ty.path "u8" ] ],
                "eq",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_tuple_field (|
                        M.deref (| M.read (| self |) |),
                        "alloy_primitives::bits::fixed::FixedBytes",
                        0
                      |)
                    |)
                  |)
                |);
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (| M.read (| M.deref (| M.read (| other |) |) |) |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (N : Value.t),
        M.IsTraitInstance
          "core::cmp::PartialEq"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "array") [ N ] [ Ty.path "u8" ] ] ]
          (Self N)
          (* Instance *) [ ("eq", InstanceField.Method (eq N)) ].
    End Impl_core_cmp_PartialEq_ref__array_N_u8_for_alloy_primitives_bits_fixed_FixedBytes_N.
    
    Module Impl_core_cmp_PartialEq_alloy_primitives_bits_fixed_FixedBytes_N_for_ref__array_N_u8.
      Definition Self (N : Value.t) : Ty.t :=
        Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "array") [ N ] [ Ty.path "u8" ] ].
      
      (*
                  fn $fn(&self, other: &$b) -> $ret {
                      $crate::private::$tr::$fn( *self, &other.0 $([$e])?)
                  }
      *)
      Definition eq (N : Value.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self N in
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              Ty.path "bool",
              M.get_trait_method (|
                "core::cmp::PartialEq",
                Ty.apply (Ty.path "array") [ N ] [ Ty.path "u8" ],
                [],
                [ Ty.apply (Ty.path "array") [ N ] [ Ty.path "u8" ] ],
                "eq",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
                |);
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_tuple_field (|
                        M.deref (| M.read (| other |) |),
                        "alloy_primitives::bits::fixed::FixedBytes",
                        0
                      |)
                    |)
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (N : Value.t),
        M.IsTraitInstance
          "core::cmp::PartialEq"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "alloy_primitives::bits::fixed::FixedBytes") [ N ] [] ]
          (Self N)
          (* Instance *) [ ("eq", InstanceField.Method (eq N)) ].
    End Impl_core_cmp_PartialEq_alloy_primitives_bits_fixed_FixedBytes_N_for_ref__array_N_u8.
    
    Module Impl_core_cmp_PartialEq_array_N_u8_for_ref__alloy_primitives_bits_fixed_FixedBytes_N.
      Definition Self (N : Value.t) : Ty.t :=
        Ty.apply
          (Ty.path "&")
          []
          [ Ty.apply (Ty.path "alloy_primitives::bits::fixed::FixedBytes") [ N ] [] ].
      
      (*
                  fn $fn(&self, other: &$a) -> $ret {
                      $crate::private::$tr::$fn(&self.0 $([$e])?, other)
                  }
      *)
      Definition eq (N : Value.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self N in
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              Ty.path "bool",
              M.get_trait_method (|
                "core::cmp::PartialEq",
                Ty.apply (Ty.path "array") [ N ] [ Ty.path "u8" ],
                [],
                [ Ty.apply (Ty.path "array") [ N ] [ Ty.path "u8" ] ],
                "eq",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_tuple_field (|
                        M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |),
                        "alloy_primitives::bits::fixed::FixedBytes",
                        0
                      |)
                    |)
                  |)
                |);
                M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| other |) |) |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (N : Value.t),
        M.IsTraitInstance
          "core::cmp::PartialEq"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.apply (Ty.path "array") [ N ] [ Ty.path "u8" ] ]
          (Self N)
          (* Instance *) [ ("eq", InstanceField.Method (eq N)) ].
    End Impl_core_cmp_PartialEq_array_N_u8_for_ref__alloy_primitives_bits_fixed_FixedBytes_N.
    
    Module Impl_core_cmp_PartialEq_ref__alloy_primitives_bits_fixed_FixedBytes_N_for_array_N_u8.
      Definition Self (N : Value.t) : Ty.t := Ty.apply (Ty.path "array") [ N ] [ Ty.path "u8" ].
      
      (*
                  fn $fn(&self, other: &&$b) -> $ret {
                      $crate::private::$tr::$fn(self, &other.0 $([$e])?)
                  }
      *)
      Definition eq (N : Value.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self N in
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              Ty.path "bool",
              M.get_trait_method (|
                "core::cmp::PartialEq",
                Ty.apply (Ty.path "array") [ N ] [ Ty.path "u8" ],
                [],
                [ Ty.apply (Ty.path "array") [ N ] [ Ty.path "u8" ] ],
                "eq",
                [],
                []
              |),
              [
                M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |);
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_tuple_field (|
                        M.deref (| M.read (| M.deref (| M.read (| other |) |) |) |),
                        "alloy_primitives::bits::fixed::FixedBytes",
                        0
                      |)
                    |)
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (N : Value.t),
        M.IsTraitInstance
          "core::cmp::PartialEq"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [
            Ty.apply
              (Ty.path "&")
              []
              [ Ty.apply (Ty.path "alloy_primitives::bits::fixed::FixedBytes") [ N ] [] ]
          ]
          (Self N)
          (* Instance *) [ ("eq", InstanceField.Method (eq N)) ].
    End Impl_core_cmp_PartialEq_ref__alloy_primitives_bits_fixed_FixedBytes_N_for_array_N_u8.
    
    Module Impl_core_cmp_PartialOrd_slice_u8_for_alloy_primitives_bits_fixed_FixedBytes_N.
      Definition Self (N : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::bits::fixed::FixedBytes") [ N ] [].
      
      (*
                  fn $fn(&self, other: &$a) -> $ret {
                      $crate::private::$tr::$fn(&self.0 $([$e])?, other)
                  }
      *)
      Definition partial_cmp
          (N : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self N in
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "core::cmp::Ordering" ],
              M.get_trait_method (|
                "core::cmp::PartialOrd",
                Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                [],
                [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                "partial_cmp",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "&")
                            []
                            [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                          M.get_trait_method (|
                            "core::ops::index::Index",
                            Ty.apply (Ty.path "array") [ N ] [ Ty.path "u8" ],
                            [],
                            [ Ty.path "core::ops::range::RangeFull" ],
                            "index",
                            [],
                            []
                          |),
                          [
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.SubPointer.get_struct_tuple_field (|
                                M.deref (| M.read (| self |) |),
                                "alloy_primitives::bits::fixed::FixedBytes",
                                0
                              |)
                            |);
                            Value.StructTuple "core::ops::range::RangeFull" []
                          ]
                        |)
                      |)
                    |)
                  |)
                |);
                M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| other |) |) |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (N : Value.t),
        M.IsTraitInstance
          "core::cmp::PartialOrd"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
          (Self N)
          (* Instance *) [ ("partial_cmp", InstanceField.Method (partial_cmp N)) ].
    End Impl_core_cmp_PartialOrd_slice_u8_for_alloy_primitives_bits_fixed_FixedBytes_N.
    
    Module Impl_core_cmp_PartialOrd_alloy_primitives_bits_fixed_FixedBytes_N_for_slice_u8.
      Definition Self (N : Value.t) : Ty.t := Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ].
      
      (*
                  fn $fn(&self, other: &$b) -> $ret {
                      $crate::private::$tr::$fn(self, &other.0 $([$e])?)
                  }
      *)
      Definition partial_cmp
          (N : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self N in
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "core::cmp::Ordering" ],
              M.get_trait_method (|
                "core::cmp::PartialOrd",
                Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                [],
                [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                "partial_cmp",
                [],
                []
              |),
              [
                M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |);
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "&")
                            []
                            [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                          M.get_trait_method (|
                            "core::ops::index::Index",
                            Ty.apply (Ty.path "array") [ N ] [ Ty.path "u8" ],
                            [],
                            [ Ty.path "core::ops::range::RangeFull" ],
                            "index",
                            [],
                            []
                          |),
                          [
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.SubPointer.get_struct_tuple_field (|
                                M.deref (| M.read (| other |) |),
                                "alloy_primitives::bits::fixed::FixedBytes",
                                0
                              |)
                            |);
                            Value.StructTuple "core::ops::range::RangeFull" []
                          ]
                        |)
                      |)
                    |)
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (N : Value.t),
        M.IsTraitInstance
          "core::cmp::PartialOrd"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "alloy_primitives::bits::fixed::FixedBytes") [ N ] [] ]
          (Self N)
          (* Instance *) [ ("partial_cmp", InstanceField.Method (partial_cmp N)) ].
    End Impl_core_cmp_PartialOrd_alloy_primitives_bits_fixed_FixedBytes_N_for_slice_u8.
    
    Module Impl_core_cmp_PartialOrd_ref__slice_u8_for_alloy_primitives_bits_fixed_FixedBytes_N.
      Definition Self (N : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::bits::fixed::FixedBytes") [ N ] [].
      
      (*
                  fn $fn(&self, other: &&$a) -> $ret {
                      $crate::private::$tr::$fn(&self.0 $([$e])?, *other)
                  }
      *)
      Definition partial_cmp
          (N : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self N in
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "core::cmp::Ordering" ],
              M.get_trait_method (|
                "core::cmp::PartialOrd",
                Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                [],
                [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                "partial_cmp",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "&")
                            []
                            [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                          M.get_trait_method (|
                            "core::ops::index::Index",
                            Ty.apply (Ty.path "array") [ N ] [ Ty.path "u8" ],
                            [],
                            [ Ty.path "core::ops::range::RangeFull" ],
                            "index",
                            [],
                            []
                          |),
                          [
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.SubPointer.get_struct_tuple_field (|
                                M.deref (| M.read (| self |) |),
                                "alloy_primitives::bits::fixed::FixedBytes",
                                0
                              |)
                            |);
                            Value.StructTuple "core::ops::range::RangeFull" []
                          ]
                        |)
                      |)
                    |)
                  |)
                |);
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (| M.read (| M.deref (| M.read (| other |) |) |) |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (N : Value.t),
        M.IsTraitInstance
          "core::cmp::PartialOrd"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ] ]
          (Self N)
          (* Instance *) [ ("partial_cmp", InstanceField.Method (partial_cmp N)) ].
    End Impl_core_cmp_PartialOrd_ref__slice_u8_for_alloy_primitives_bits_fixed_FixedBytes_N.
    
    Module Impl_core_cmp_PartialOrd_alloy_primitives_bits_fixed_FixedBytes_N_for_ref__slice_u8.
      Definition Self (N : Value.t) : Ty.t :=
        Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ].
      
      (*
                  fn $fn(&self, other: &$b) -> $ret {
                      $crate::private::$tr::$fn( *self, &other.0 $([$e])?)
                  }
      *)
      Definition partial_cmp
          (N : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self N in
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "core::cmp::Ordering" ],
              M.get_trait_method (|
                "core::cmp::PartialOrd",
                Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                [],
                [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                "partial_cmp",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
                |);
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "&")
                            []
                            [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                          M.get_trait_method (|
                            "core::ops::index::Index",
                            Ty.apply (Ty.path "array") [ N ] [ Ty.path "u8" ],
                            [],
                            [ Ty.path "core::ops::range::RangeFull" ],
                            "index",
                            [],
                            []
                          |),
                          [
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.SubPointer.get_struct_tuple_field (|
                                M.deref (| M.read (| other |) |),
                                "alloy_primitives::bits::fixed::FixedBytes",
                                0
                              |)
                            |);
                            Value.StructTuple "core::ops::range::RangeFull" []
                          ]
                        |)
                      |)
                    |)
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (N : Value.t),
        M.IsTraitInstance
          "core::cmp::PartialOrd"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "alloy_primitives::bits::fixed::FixedBytes") [ N ] [] ]
          (Self N)
          (* Instance *) [ ("partial_cmp", InstanceField.Method (partial_cmp N)) ].
    End Impl_core_cmp_PartialOrd_alloy_primitives_bits_fixed_FixedBytes_N_for_ref__slice_u8.
    
    Module Impl_core_cmp_PartialOrd_slice_u8_for_ref__alloy_primitives_bits_fixed_FixedBytes_N.
      Definition Self (N : Value.t) : Ty.t :=
        Ty.apply
          (Ty.path "&")
          []
          [ Ty.apply (Ty.path "alloy_primitives::bits::fixed::FixedBytes") [ N ] [] ].
      
      (*
                  fn $fn(&self, other: &$a) -> $ret {
                      $crate::private::$tr::$fn(&self.0 $([$e])?, other)
                  }
      *)
      Definition partial_cmp
          (N : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self N in
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "core::cmp::Ordering" ],
              M.get_trait_method (|
                "core::cmp::PartialOrd",
                Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                [],
                [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                "partial_cmp",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "&")
                            []
                            [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                          M.get_trait_method (|
                            "core::ops::index::Index",
                            Ty.apply (Ty.path "array") [ N ] [ Ty.path "u8" ],
                            [],
                            [ Ty.path "core::ops::range::RangeFull" ],
                            "index",
                            [],
                            []
                          |),
                          [
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.SubPointer.get_struct_tuple_field (|
                                M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |),
                                "alloy_primitives::bits::fixed::FixedBytes",
                                0
                              |)
                            |);
                            Value.StructTuple "core::ops::range::RangeFull" []
                          ]
                        |)
                      |)
                    |)
                  |)
                |);
                M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| other |) |) |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (N : Value.t),
        M.IsTraitInstance
          "core::cmp::PartialOrd"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
          (Self N)
          (* Instance *) [ ("partial_cmp", InstanceField.Method (partial_cmp N)) ].
    End Impl_core_cmp_PartialOrd_slice_u8_for_ref__alloy_primitives_bits_fixed_FixedBytes_N.
    
    Module Impl_core_cmp_PartialOrd_ref__alloy_primitives_bits_fixed_FixedBytes_N_for_slice_u8.
      Definition Self (N : Value.t) : Ty.t := Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ].
      
      (*
                  fn $fn(&self, other: &&$b) -> $ret {
                      $crate::private::$tr::$fn(self, &other.0 $([$e])?)
                  }
      *)
      Definition partial_cmp
          (N : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self N in
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "core::cmp::Ordering" ],
              M.get_trait_method (|
                "core::cmp::PartialOrd",
                Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                [],
                [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                "partial_cmp",
                [],
                []
              |),
              [
                M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |);
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "&")
                            []
                            [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                          M.get_trait_method (|
                            "core::ops::index::Index",
                            Ty.apply (Ty.path "array") [ N ] [ Ty.path "u8" ],
                            [],
                            [ Ty.path "core::ops::range::RangeFull" ],
                            "index",
                            [],
                            []
                          |),
                          [
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.SubPointer.get_struct_tuple_field (|
                                M.deref (| M.read (| M.deref (| M.read (| other |) |) |) |),
                                "alloy_primitives::bits::fixed::FixedBytes",
                                0
                              |)
                            |);
                            Value.StructTuple "core::ops::range::RangeFull" []
                          ]
                        |)
                      |)
                    |)
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (N : Value.t),
        M.IsTraitInstance
          "core::cmp::PartialOrd"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [
            Ty.apply
              (Ty.path "&")
              []
              [ Ty.apply (Ty.path "alloy_primitives::bits::fixed::FixedBytes") [ N ] [] ]
          ]
          (Self N)
          (* Instance *) [ ("partial_cmp", InstanceField.Method (partial_cmp N)) ].
    End Impl_core_cmp_PartialOrd_ref__alloy_primitives_bits_fixed_FixedBytes_N_for_slice_u8.
    
    Module Impl_const_hex_traits_FromHex_for_alloy_primitives_bits_fixed_FixedBytes_N.
      Definition Self (N : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::bits::fixed::FixedBytes") [ N ] [].
      
      (*             type Error = $crate::hex::FromHexError; *)
      Definition _Error (N : Value.t) : Ty.t := Ty.path "const_hex::error::FromHexError".
      
      (*
                  fn from_hex<T: $crate::private::AsRef<[u8]>>(hex: T) -> Result<Self, Self::Error> {
                      $crate::hex::decode_to_array(hex).map(Self::new)
                  }
      *)
      Definition from_hex (N : Value.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self N in
        match ε, τ, α with
        | [], [ T ], [ hex ] =>
          ltac:(M.monadic
            (let hex := M.alloc (| hex |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "core::result::Result")
                []
                [
                  Ty.apply (Ty.path "alloy_primitives::bits::fixed::FixedBytes") [ N ] [];
                  Ty.path "const_hex::error::FromHexError"
                ],
              M.get_associated_function (|
                Ty.apply
                  (Ty.path "core::result::Result")
                  []
                  [
                    Ty.apply (Ty.path "array") [ N ] [ Ty.path "u8" ];
                    Ty.path "const_hex::error::FromHexError"
                  ],
                "map",
                [],
                [
                  Ty.apply (Ty.path "alloy_primitives::bits::fixed::FixedBytes") [ N ] [];
                  Ty.function
                    [ Ty.apply (Ty.path "array") [ N ] [ Ty.path "u8" ] ]
                    (Ty.apply (Ty.path "alloy_primitives::bits::fixed::FixedBytes") [ N ] [])
                ]
              |),
              [
                M.call_closure (|
                  Ty.apply
                    (Ty.path "core::result::Result")
                    []
                    [
                      Ty.apply (Ty.path "array") [ N ] [ Ty.path "u8" ];
                      Ty.path "const_hex::error::FromHexError"
                    ],
                  M.get_function (| "const_hex::decode_to_array", [ N ], [ T ] |),
                  [ M.read (| hex |) ]
                |);
                M.get_associated_function (|
                  Ty.apply (Ty.path "alloy_primitives::bits::fixed::FixedBytes") [ N ] [],
                  "new",
                  [],
                  []
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (N : Value.t),
        M.IsTraitInstance
          "const_hex::traits::FromHex"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self N)
          (* Instance *)
          [ ("Error", InstanceField.Ty (_Error N)); ("from_hex", InstanceField.Method (from_hex N))
          ].
    End Impl_const_hex_traits_FromHex_for_alloy_primitives_bits_fixed_FixedBytes_N.
  End fixed.
  
  Module function.
    (* StructTuple
      {
        name := "Function";
        const_params := [];
        ty_params := [];
        fields :=
          [
            Ty.apply
              (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
              [ Value.Integer IntegerKind.Usize 24 ]
              []
          ];
      } *)
    
    Module Impl_core_clone_Clone_for_alloy_primitives_bits_function_Function.
      Definition Self : Ty.t := Ty.path "alloy_primitives::bits::function::Function".
      
      (*             Clone *)
      Definition clone (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                None,
                Value.DeclaredButUndefined,
                [ fun γ => ltac:(M.monadic (M.deref (| M.read (| self |) |))) ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::clone::Clone"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [ ("clone", InstanceField.Method clone) ].
    End Impl_core_clone_Clone_for_alloy_primitives_bits_function_Function.
    
    Module Impl_core_marker_Copy_for_alloy_primitives_bits_function_Function.
      Definition Self : Ty.t := Ty.path "alloy_primitives::bits::function::Function".
      
      Axiom Implements :
        M.IsTraitInstance
          "core::marker::Copy"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [].
    End Impl_core_marker_Copy_for_alloy_primitives_bits_function_Function.
    
    Module Impl_core_default_Default_for_alloy_primitives_bits_function_Function.
      Definition Self : Ty.t := Ty.path "alloy_primitives::bits::function::Function".
      
      (*             Default *)
      Definition default (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [] =>
          ltac:(M.monadic
            (Value.StructTuple
              "alloy_primitives::bits::function::Function"
              [
                M.call_closure (|
                  Ty.apply
                    (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                    [ Value.Integer IntegerKind.Usize 24 ]
                    [],
                  M.get_trait_method (|
                    "core::default::Default",
                    Ty.apply
                      (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                      [ Value.Integer IntegerKind.Usize 24 ]
                      [],
                    [],
                    [],
                    "default",
                    [],
                    []
                  |),
                  []
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::default::Default"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [ ("default", InstanceField.Method default) ].
    End Impl_core_default_Default_for_alloy_primitives_bits_function_Function.
    
    Module Impl_core_marker_StructuralPartialEq_for_alloy_primitives_bits_function_Function.
      Definition Self : Ty.t := Ty.path "alloy_primitives::bits::function::Function".
      
      Axiom Implements :
        M.IsTraitInstance
          "core::marker::StructuralPartialEq"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [].
    End Impl_core_marker_StructuralPartialEq_for_alloy_primitives_bits_function_Function.
    
    Module Impl_core_cmp_PartialEq_alloy_primitives_bits_function_Function_for_alloy_primitives_bits_function_Function.
      Definition Self : Ty.t := Ty.path "alloy_primitives::bits::function::Function".
      
      (*             PartialEq *)
      Definition eq (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              Ty.path "bool",
              M.get_trait_method (|
                "core::cmp::PartialEq",
                Ty.apply
                  (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                  [ Value.Integer IntegerKind.Usize 24 ]
                  [],
                [],
                [
                  Ty.apply
                    (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                    [ Value.Integer IntegerKind.Usize 24 ]
                    []
                ],
                "eq",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.SubPointer.get_struct_tuple_field (|
                    M.deref (| M.read (| self |) |),
                    "alloy_primitives::bits::function::Function",
                    0
                  |)
                |);
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.SubPointer.get_struct_tuple_field (|
                    M.deref (| M.read (| other |) |),
                    "alloy_primitives::bits::function::Function",
                    0
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::cmp::PartialEq"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "alloy_primitives::bits::function::Function" ]
          Self
          (* Instance *) [ ("eq", InstanceField.Method eq) ].
    End Impl_core_cmp_PartialEq_alloy_primitives_bits_function_Function_for_alloy_primitives_bits_function_Function.
    
    Module Impl_core_cmp_Eq_for_alloy_primitives_bits_function_Function.
      Definition Self : Ty.t := Ty.path "alloy_primitives::bits::function::Function".
      
      (*             Eq *)
      Definition assert_receiver_is_total_eq
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                None,
                Value.DeclaredButUndefined,
                [ fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |))) ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::cmp::Eq"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *)
          [ ("assert_receiver_is_total_eq", InstanceField.Method assert_receiver_is_total_eq) ].
    End Impl_core_cmp_Eq_for_alloy_primitives_bits_function_Function.
    
    Module Impl_core_cmp_PartialOrd_alloy_primitives_bits_function_Function_for_alloy_primitives_bits_function_Function.
      Definition Self : Ty.t := Ty.path "alloy_primitives::bits::function::Function".
      
      (*             PartialOrd *)
      Definition partial_cmp (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "core::cmp::Ordering" ],
              M.get_trait_method (|
                "core::cmp::PartialOrd",
                Ty.apply
                  (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                  [ Value.Integer IntegerKind.Usize 24 ]
                  [],
                [],
                [
                  Ty.apply
                    (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                    [ Value.Integer IntegerKind.Usize 24 ]
                    []
                ],
                "partial_cmp",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_tuple_field (|
                        M.deref (| M.read (| self |) |),
                        "alloy_primitives::bits::function::Function",
                        0
                      |)
                    |)
                  |)
                |);
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_tuple_field (|
                        M.deref (| M.read (| other |) |),
                        "alloy_primitives::bits::function::Function",
                        0
                      |)
                    |)
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::cmp::PartialOrd"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "alloy_primitives::bits::function::Function" ]
          Self
          (* Instance *) [ ("partial_cmp", InstanceField.Method partial_cmp) ].
    End Impl_core_cmp_PartialOrd_alloy_primitives_bits_function_Function_for_alloy_primitives_bits_function_Function.
    
    Module Impl_core_cmp_Ord_for_alloy_primitives_bits_function_Function.
      Definition Self : Ty.t := Ty.path "alloy_primitives::bits::function::Function".
      
      (*             Ord *)
      Definition cmp (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              Ty.path "core::cmp::Ordering",
              M.get_trait_method (|
                "core::cmp::Ord",
                Ty.apply
                  (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                  [ Value.Integer IntegerKind.Usize 24 ]
                  [],
                [],
                [],
                "cmp",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_tuple_field (|
                        M.deref (| M.read (| self |) |),
                        "alloy_primitives::bits::function::Function",
                        0
                      |)
                    |)
                  |)
                |);
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_tuple_field (|
                        M.deref (| M.read (| other |) |),
                        "alloy_primitives::bits::function::Function",
                        0
                      |)
                    |)
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::cmp::Ord"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [ ("cmp", InstanceField.Method cmp) ].
    End Impl_core_cmp_Ord_for_alloy_primitives_bits_function_Function.
    
    Module Impl_core_hash_Hash_for_alloy_primitives_bits_function_Function.
      Definition Self : Ty.t := Ty.path "alloy_primitives::bits::function::Function".
      
      (*             Hash *)
      Definition hash (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [ __H ], [ self; state ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let state := M.alloc (| state |) in
            M.call_closure (|
              Ty.tuple [],
              M.get_trait_method (|
                "core::hash::Hash",
                Ty.apply
                  (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                  [ Value.Integer IntegerKind.Usize 24 ]
                  [],
                [],
                [],
                "hash",
                [],
                [ __H ]
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_tuple_field (|
                        M.deref (| M.read (| self |) |),
                        "alloy_primitives::bits::function::Function",
                        0
                      |)
                    |)
                  |)
                |);
                M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::hash::Hash"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [ ("hash", InstanceField.Method hash) ].
    End Impl_core_hash_Hash_for_alloy_primitives_bits_function_Function.
    
    Module Impl_core_convert_AsMut_alloy_primitives_bits_fixed_FixedBytes_Usize_24_for_alloy_primitives_bits_function_Function.
      Definition Self : Ty.t := Ty.path "alloy_primitives::bits::function::Function".
      
      (*             $crate::private::derive_more::AsMut *)
      Definition as_mut (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.borrow (|
              Pointer.Kind.MutRef,
              M.deref (|
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.MutRef,
                      M.SubPointer.get_struct_tuple_field (|
                        M.deref (| M.read (| self |) |),
                        "alloy_primitives::bits::function::Function",
                        0
                      |)
                    |)
                  |)
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::AsMut"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [
            Ty.apply
              (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
              [ Value.Integer IntegerKind.Usize 24 ]
              []
          ]
          Self
          (* Instance *) [ ("as_mut", InstanceField.Method as_mut) ].
    End Impl_core_convert_AsMut_alloy_primitives_bits_fixed_FixedBytes_Usize_24_for_alloy_primitives_bits_function_Function.
    
    Module Impl_core_convert_AsRef_alloy_primitives_bits_fixed_FixedBytes_Usize_24_for_alloy_primitives_bits_function_Function.
      Definition Self : Ty.t := Ty.path "alloy_primitives::bits::function::Function".
      
      (*             $crate::private::derive_more::AsRef *)
      Definition as_ref (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.borrow (|
              Pointer.Kind.Ref,
              M.deref (|
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.SubPointer.get_struct_tuple_field (|
                    M.deref (| M.read (| self |) |),
                    "alloy_primitives::bits::function::Function",
                    0
                  |)
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::AsRef"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [
            Ty.apply
              (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
              [ Value.Integer IntegerKind.Usize 24 ]
              []
          ]
          Self
          (* Instance *) [ ("as_ref", InstanceField.Method as_ref) ].
    End Impl_core_convert_AsRef_alloy_primitives_bits_fixed_FixedBytes_Usize_24_for_alloy_primitives_bits_function_Function.
    
    Module Impl_core_ops_bit_BitAnd_alloy_primitives_bits_function_Function_for_alloy_primitives_bits_function_Function.
      Definition Self : Ty.t := Ty.path "alloy_primitives::bits::function::Function".
      
      (*             $crate::private::derive_more::BitAnd *)
      Definition _Output : Ty.t := Ty.path "alloy_primitives::bits::function::Function".
      
      (*             $crate::private::derive_more::BitAnd *)
      Definition bitand (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            Value.StructTuple
              "alloy_primitives::bits::function::Function"
              [
                M.call_closure (|
                  Ty.apply
                    (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                    [ Value.Integer IntegerKind.Usize 24 ]
                    [],
                  M.get_trait_method (|
                    "core::ops::bit::BitAnd",
                    Ty.apply
                      (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                      [ Value.Integer IntegerKind.Usize 24 ]
                      [],
                    [],
                    [
                      Ty.apply
                        (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                        [ Value.Integer IntegerKind.Usize 24 ]
                        []
                    ],
                    "bitand",
                    [],
                    []
                  |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "alloy_primitives::bits::function::Function",
                        0
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        rhs,
                        "alloy_primitives::bits::function::Function",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitAnd"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "alloy_primitives::bits::function::Function" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("bitand", InstanceField.Method bitand) ].
    End Impl_core_ops_bit_BitAnd_alloy_primitives_bits_function_Function_for_alloy_primitives_bits_function_Function.
    
    Module Impl_core_ops_bit_BitAndAssign_alloy_primitives_bits_function_Function_for_alloy_primitives_bits_function_Function.
      Definition Self : Ty.t := Ty.path "alloy_primitives::bits::function::Function".
      
      (*             $crate::private::derive_more::BitAndAssign *)
      Definition bitand_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            M.read (|
              let~ _ : Ty.tuple [] :=
                M.alloc (|
                  M.call_closure (|
                    Ty.tuple [],
                    M.get_trait_method (|
                      "core::ops::bit::BitAndAssign",
                      Ty.apply
                        (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                        [ Value.Integer IntegerKind.Usize 24 ]
                        [],
                      [],
                      [
                        Ty.apply
                          (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                          [ Value.Integer IntegerKind.Usize 24 ]
                          []
                      ],
                      "bitand_assign",
                      [],
                      []
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.MutRef,
                        M.SubPointer.get_struct_tuple_field (|
                          M.deref (| M.read (| self |) |),
                          "alloy_primitives::bits::function::Function",
                          0
                        |)
                      |);
                      M.read (|
                        M.SubPointer.get_struct_tuple_field (|
                          rhs,
                          "alloy_primitives::bits::function::Function",
                          0
                        |)
                      |)
                    ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitAndAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "alloy_primitives::bits::function::Function" ]
          Self
          (* Instance *) [ ("bitand_assign", InstanceField.Method bitand_assign) ].
    End Impl_core_ops_bit_BitAndAssign_alloy_primitives_bits_function_Function_for_alloy_primitives_bits_function_Function.
    
    Module Impl_core_ops_bit_BitOr_alloy_primitives_bits_function_Function_for_alloy_primitives_bits_function_Function.
      Definition Self : Ty.t := Ty.path "alloy_primitives::bits::function::Function".
      
      (*             $crate::private::derive_more::BitOr *)
      Definition _Output : Ty.t := Ty.path "alloy_primitives::bits::function::Function".
      
      (*             $crate::private::derive_more::BitOr *)
      Definition bitor (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            Value.StructTuple
              "alloy_primitives::bits::function::Function"
              [
                M.call_closure (|
                  Ty.apply
                    (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                    [ Value.Integer IntegerKind.Usize 24 ]
                    [],
                  M.get_trait_method (|
                    "core::ops::bit::BitOr",
                    Ty.apply
                      (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                      [ Value.Integer IntegerKind.Usize 24 ]
                      [],
                    [],
                    [
                      Ty.apply
                        (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                        [ Value.Integer IntegerKind.Usize 24 ]
                        []
                    ],
                    "bitor",
                    [],
                    []
                  |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "alloy_primitives::bits::function::Function",
                        0
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        rhs,
                        "alloy_primitives::bits::function::Function",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitOr"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "alloy_primitives::bits::function::Function" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("bitor", InstanceField.Method bitor) ].
    End Impl_core_ops_bit_BitOr_alloy_primitives_bits_function_Function_for_alloy_primitives_bits_function_Function.
    
    Module Impl_core_ops_bit_BitOrAssign_alloy_primitives_bits_function_Function_for_alloy_primitives_bits_function_Function.
      Definition Self : Ty.t := Ty.path "alloy_primitives::bits::function::Function".
      
      (*             $crate::private::derive_more::BitOrAssign *)
      Definition bitor_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            M.read (|
              let~ _ : Ty.tuple [] :=
                M.alloc (|
                  M.call_closure (|
                    Ty.tuple [],
                    M.get_trait_method (|
                      "core::ops::bit::BitOrAssign",
                      Ty.apply
                        (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                        [ Value.Integer IntegerKind.Usize 24 ]
                        [],
                      [],
                      [
                        Ty.apply
                          (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                          [ Value.Integer IntegerKind.Usize 24 ]
                          []
                      ],
                      "bitor_assign",
                      [],
                      []
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.MutRef,
                        M.SubPointer.get_struct_tuple_field (|
                          M.deref (| M.read (| self |) |),
                          "alloy_primitives::bits::function::Function",
                          0
                        |)
                      |);
                      M.read (|
                        M.SubPointer.get_struct_tuple_field (|
                          rhs,
                          "alloy_primitives::bits::function::Function",
                          0
                        |)
                      |)
                    ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitOrAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "alloy_primitives::bits::function::Function" ]
          Self
          (* Instance *) [ ("bitor_assign", InstanceField.Method bitor_assign) ].
    End Impl_core_ops_bit_BitOrAssign_alloy_primitives_bits_function_Function_for_alloy_primitives_bits_function_Function.
    
    Module Impl_core_ops_bit_BitXor_alloy_primitives_bits_function_Function_for_alloy_primitives_bits_function_Function.
      Definition Self : Ty.t := Ty.path "alloy_primitives::bits::function::Function".
      
      (*             $crate::private::derive_more::BitXor *)
      Definition _Output : Ty.t := Ty.path "alloy_primitives::bits::function::Function".
      
      (*             $crate::private::derive_more::BitXor *)
      Definition bitxor (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            Value.StructTuple
              "alloy_primitives::bits::function::Function"
              [
                M.call_closure (|
                  Ty.apply
                    (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                    [ Value.Integer IntegerKind.Usize 24 ]
                    [],
                  M.get_trait_method (|
                    "core::ops::bit::BitXor",
                    Ty.apply
                      (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                      [ Value.Integer IntegerKind.Usize 24 ]
                      [],
                    [],
                    [
                      Ty.apply
                        (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                        [ Value.Integer IntegerKind.Usize 24 ]
                        []
                    ],
                    "bitxor",
                    [],
                    []
                  |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "alloy_primitives::bits::function::Function",
                        0
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        rhs,
                        "alloy_primitives::bits::function::Function",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitXor"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "alloy_primitives::bits::function::Function" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("bitxor", InstanceField.Method bitxor) ].
    End Impl_core_ops_bit_BitXor_alloy_primitives_bits_function_Function_for_alloy_primitives_bits_function_Function.
    
    Module Impl_core_ops_bit_BitXorAssign_alloy_primitives_bits_function_Function_for_alloy_primitives_bits_function_Function.
      Definition Self : Ty.t := Ty.path "alloy_primitives::bits::function::Function".
      
      (*             $crate::private::derive_more::BitXorAssign *)
      Definition bitxor_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            M.read (|
              let~ _ : Ty.tuple [] :=
                M.alloc (|
                  M.call_closure (|
                    Ty.tuple [],
                    M.get_trait_method (|
                      "core::ops::bit::BitXorAssign",
                      Ty.apply
                        (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                        [ Value.Integer IntegerKind.Usize 24 ]
                        [],
                      [],
                      [
                        Ty.apply
                          (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                          [ Value.Integer IntegerKind.Usize 24 ]
                          []
                      ],
                      "bitxor_assign",
                      [],
                      []
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.MutRef,
                        M.SubPointer.get_struct_tuple_field (|
                          M.deref (| M.read (| self |) |),
                          "alloy_primitives::bits::function::Function",
                          0
                        |)
                      |);
                      M.read (|
                        M.SubPointer.get_struct_tuple_field (|
                          rhs,
                          "alloy_primitives::bits::function::Function",
                          0
                        |)
                      |)
                    ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::BitXorAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "alloy_primitives::bits::function::Function" ]
          Self
          (* Instance *) [ ("bitxor_assign", InstanceField.Method bitxor_assign) ].
    End Impl_core_ops_bit_BitXorAssign_alloy_primitives_bits_function_Function_for_alloy_primitives_bits_function_Function.
    
    Module Impl_core_ops_bit_Not_for_alloy_primitives_bits_function_Function.
      Definition Self : Ty.t := Ty.path "alloy_primitives::bits::function::Function".
      
      (*             $crate::private::derive_more::Not *)
      Definition _Output : Ty.t := Ty.path "alloy_primitives::bits::function::Function".
      
      (*             $crate::private::derive_more::Not *)
      Definition not (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructTuple
              "alloy_primitives::bits::function::Function"
              [
                M.call_closure (|
                  Ty.apply
                    (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                    [ Value.Integer IntegerKind.Usize 24 ]
                    [],
                  M.get_trait_method (|
                    "core::ops::bit::Not",
                    Ty.apply
                      (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                      [ Value.Integer IntegerKind.Usize 24 ]
                      [],
                    [],
                    [],
                    "not",
                    [],
                    []
                  |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "alloy_primitives::bits::function::Function",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::bit::Not"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("not", InstanceField.Method not) ].
    End Impl_core_ops_bit_Not_for_alloy_primitives_bits_function_Function.
    
    Module Impl_core_ops_deref_Deref_for_alloy_primitives_bits_function_Function.
      Definition Self : Ty.t := Ty.path "alloy_primitives::bits::function::Function".
      
      (*             $crate::private::derive_more::Deref *)
      Definition _Target : Ty.t :=
        Ty.apply
          (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
          [ Value.Integer IntegerKind.Usize 24 ]
          [].
      
      (*             $crate::private::derive_more::Deref *)
      Definition deref (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.borrow (|
              Pointer.Kind.Ref,
              M.deref (|
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.SubPointer.get_struct_tuple_field (|
                    M.deref (| M.read (| self |) |),
                    "alloy_primitives::bits::function::Function",
                    0
                  |)
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::deref::Deref"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *)
          [ ("Target", InstanceField.Ty _Target); ("deref", InstanceField.Method deref) ].
    End Impl_core_ops_deref_Deref_for_alloy_primitives_bits_function_Function.
    
    Module Impl_core_ops_deref_DerefMut_for_alloy_primitives_bits_function_Function.
      Definition Self : Ty.t := Ty.path "alloy_primitives::bits::function::Function".
      
      (*             $crate::private::derive_more::DerefMut *)
      Definition deref_mut (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.borrow (|
              Pointer.Kind.MutRef,
              M.deref (|
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.MutRef,
                      M.SubPointer.get_struct_tuple_field (|
                        M.deref (| M.read (| self |) |),
                        "alloy_primitives::bits::function::Function",
                        0
                      |)
                    |)
                  |)
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::deref::DerefMut"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [ ("deref_mut", InstanceField.Method deref_mut) ].
    End Impl_core_ops_deref_DerefMut_for_alloy_primitives_bits_function_Function.
    
    Module Impl_core_convert_From_alloy_primitives_bits_fixed_FixedBytes_Usize_24_for_alloy_primitives_bits_function_Function.
      Definition Self : Ty.t := Ty.path "alloy_primitives::bits::function::Function".
      
      (*             $crate::private::derive_more::From *)
      Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            Value.StructTuple "alloy_primitives::bits::function::Function" [ M.read (| value |) ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [
            Ty.apply
              (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
              [ Value.Integer IntegerKind.Usize 24 ]
              []
          ]
          Self
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_alloy_primitives_bits_fixed_FixedBytes_Usize_24_for_alloy_primitives_bits_function_Function.
    
    Module Impl_core_str_traits_FromStr_for_alloy_primitives_bits_function_Function.
      Definition Self : Ty.t := Ty.path "alloy_primitives::bits::function::Function".
      
      (*             $crate::private::derive_more::FromStr *)
      Definition _Err : Ty.t :=
        Ty.associated_in_trait
          "core::str::traits::FromStr"
          []
          []
          (Ty.apply
            (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
            [ Value.Integer IntegerKind.Usize 24 ]
            [])
          "Err".
      
      (*             $crate::private::derive_more::FromStr *)
      Definition from_str (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ src ] =>
          ltac:(M.monadic
            (let src := M.alloc (| src |) in
            M.catch_return (|
              ltac:(M.monadic
                (Value.StructTuple
                  "core::result::Result::Ok"
                  [
                    Value.StructTuple
                      "alloy_primitives::bits::function::Function"
                      [
                        M.read (|
                          M.match_operator (|
                            Some
                              (Ty.apply
                                (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                                [ Value.Integer IntegerKind.Usize 24 ]
                                []),
                            M.alloc (|
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "core::ops::control_flow::ControlFlow")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [
                                        Ty.path "core::convert::Infallible";
                                        Ty.path "const_hex::error::FromHexError"
                                      ];
                                    Ty.apply
                                      (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                                      [ Value.Integer IntegerKind.Usize 24 ]
                                      []
                                  ],
                                M.get_trait_method (|
                                  "core::ops::try_trait::Try",
                                  Ty.apply
                                    (Ty.path "core::result::Result")
                                    []
                                    [
                                      Ty.apply
                                        (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                                        [ Value.Integer IntegerKind.Usize 24 ]
                                        [];
                                      Ty.path "const_hex::error::FromHexError"
                                    ],
                                  [],
                                  [],
                                  "branch",
                                  [],
                                  []
                                |),
                                [
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [
                                        Ty.apply
                                          (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                                          [ Value.Integer IntegerKind.Usize 24 ]
                                          [];
                                        Ty.path "const_hex::error::FromHexError"
                                      ],
                                    M.get_trait_method (|
                                      "core::str::traits::FromStr",
                                      Ty.apply
                                        (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                                        [ Value.Integer IntegerKind.Usize 24 ]
                                        [],
                                      [],
                                      [],
                                      "from_str",
                                      [],
                                      []
                                    |),
                                    [
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.deref (| M.read (| src |) |)
                                      |)
                                    ]
                                  |)
                                ]
                              |)
                            |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Break",
                                      0
                                    |) in
                                  let residual := M.copy (| γ0_0 |) in
                                  M.alloc (|
                                    M.never_to_any (|
                                      M.read (|
                                        M.return_ (|
                                          M.call_closure (|
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              []
                                              [
                                                Ty.path
                                                  "alloy_primitives::bits::function::Function";
                                                Ty.path "const_hex::error::FromHexError"
                                              ],
                                            M.get_trait_method (|
                                              "core::ops::try_trait::FromResidual",
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                []
                                                [
                                                  Ty.path
                                                    "alloy_primitives::bits::function::Function";
                                                  Ty.path "const_hex::error::FromHexError"
                                                ],
                                              [],
                                              [
                                                Ty.apply
                                                  (Ty.path "core::result::Result")
                                                  []
                                                  [
                                                    Ty.path "core::convert::Infallible";
                                                    Ty.path "const_hex::error::FromHexError"
                                                  ]
                                              ],
                                              "from_residual",
                                              [],
                                              []
                                            |),
                                            [ M.read (| residual |) ]
                                          |)
                                        |)
                                      |)
                                    |)
                                  |)));
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Continue",
                                      0
                                    |) in
                                  let val := M.copy (| γ0_0 |) in
                                  val))
                            ]
                          |)
                        |)
                      ]
                  ]))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::str::traits::FromStr"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *)
          [ ("Err", InstanceField.Ty _Err); ("from_str", InstanceField.Method from_str) ].
    End Impl_core_str_traits_FromStr_for_alloy_primitives_bits_function_Function.
    
    Module Impl_core_ops_index_Index_where_core_ops_index_Index_alloy_primitives_bits_fixed_FixedBytes_Usize_24___IdxT___IdxT_for_alloy_primitives_bits_function_Function.
      Definition Self (__IdxT : Ty.t) : Ty.t :=
        Ty.path "alloy_primitives::bits::function::Function".
      
      (*             $crate::private::derive_more::Index *)
      Definition _Output (__IdxT : Ty.t) : Ty.t :=
        Ty.associated_in_trait
          "core::ops::index::Index"
          []
          [ __IdxT ]
          (Ty.apply
            (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
            [ Value.Integer IntegerKind.Usize 24 ]
            [])
          "Output".
      
      (*             $crate::private::derive_more::Index *)
      Definition index (__IdxT : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self __IdxT in
        match ε, τ, α with
        | [], [], [ self; idx ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let idx := M.alloc (| idx |) in
            M.borrow (|
              Pointer.Kind.Ref,
              M.deref (|
                M.call_closure (|
                  Ty.apply
                    (Ty.path "&")
                    []
                    [
                      Ty.associated_in_trait
                        "core::ops::index::Index"
                        []
                        [ __IdxT ]
                        (Ty.apply
                          (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                          [ Value.Integer IntegerKind.Usize 24 ]
                          [])
                        "Output"
                    ],
                  M.get_trait_method (|
                    "core::ops::index::Index",
                    Ty.apply
                      (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                      [ Value.Integer IntegerKind.Usize 24 ]
                      [],
                    [],
                    [ __IdxT ],
                    "index",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_tuple_field (|
                            M.deref (| M.read (| self |) |),
                            "alloy_primitives::bits::function::Function",
                            0
                          |)
                        |)
                      |)
                    |);
                    M.read (| idx |)
                  ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (__IdxT : Ty.t),
        M.IsTraitInstance
          "core::ops::index::Index"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ __IdxT ]
          (Self __IdxT)
          (* Instance *)
          [
            ("Output", InstanceField.Ty (_Output __IdxT));
            ("index", InstanceField.Method (index __IdxT))
          ].
    End Impl_core_ops_index_Index_where_core_ops_index_Index_alloy_primitives_bits_fixed_FixedBytes_Usize_24___IdxT___IdxT_for_alloy_primitives_bits_function_Function.
    
    Module Impl_core_ops_index_IndexMut_where_core_ops_index_IndexMut_alloy_primitives_bits_fixed_FixedBytes_Usize_24___IdxT___IdxT_for_alloy_primitives_bits_function_Function.
      Definition Self (__IdxT : Ty.t) : Ty.t :=
        Ty.path "alloy_primitives::bits::function::Function".
      
      (*             $crate::private::derive_more::IndexMut *)
      Definition index_mut
          (__IdxT : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self __IdxT in
        match ε, τ, α with
        | [], [], [ self; idx ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let idx := M.alloc (| idx |) in
            M.borrow (|
              Pointer.Kind.MutRef,
              M.deref (|
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.deref (|
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "&mut")
                        []
                        [
                          Ty.associated_in_trait
                            "core::ops::index::Index"
                            []
                            [ __IdxT ]
                            (Ty.apply
                              (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                              [ Value.Integer IntegerKind.Usize 24 ]
                              [])
                            "Output"
                        ],
                      M.get_trait_method (|
                        "core::ops::index::IndexMut",
                        Ty.apply
                          (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                          [ Value.Integer IntegerKind.Usize 24 ]
                          [],
                        [],
                        [ __IdxT ],
                        "index_mut",
                        [],
                        []
                      |),
                      [
                        M.borrow (|
                          Pointer.Kind.MutRef,
                          M.deref (|
                            M.borrow (|
                              Pointer.Kind.MutRef,
                              M.SubPointer.get_struct_tuple_field (|
                                M.deref (| M.read (| self |) |),
                                "alloy_primitives::bits::function::Function",
                                0
                              |)
                            |)
                          |)
                        |);
                        M.read (| idx |)
                      ]
                    |)
                  |)
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (__IdxT : Ty.t),
        M.IsTraitInstance
          "core::ops::index::IndexMut"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ __IdxT ]
          (Self __IdxT)
          (* Instance *) [ ("index_mut", InstanceField.Method (index_mut __IdxT)) ].
    End Impl_core_ops_index_IndexMut_where_core_ops_index_IndexMut_alloy_primitives_bits_fixed_FixedBytes_Usize_24___IdxT___IdxT_for_alloy_primitives_bits_function_Function.
    
    Module Impl_core_convert_From_alloy_primitives_bits_function_Function_for_alloy_primitives_bits_fixed_FixedBytes_Usize_24.
      Definition Self : Ty.t :=
        Ty.apply
          (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
          [ Value.Integer IntegerKind.Usize 24 ]
          [].
      
      (*             $crate::private::derive_more::Into *)
      Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                [ Value.Integer IntegerKind.Usize 24 ]
                [],
              M.get_trait_method (|
                "core::convert::From",
                Ty.apply
                  (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                  [ Value.Integer IntegerKind.Usize 24 ]
                  [],
                [],
                [
                  Ty.apply
                    (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                    [ Value.Integer IntegerKind.Usize 24 ]
                    []
                ],
                "from",
                [],
                []
              |),
              [
                M.read (|
                  M.SubPointer.get_struct_tuple_field (|
                    value,
                    "alloy_primitives::bits::function::Function",
                    0
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "alloy_primitives::bits::function::Function" ]
          Self
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_alloy_primitives_bits_function_Function_for_alloy_primitives_bits_fixed_FixedBytes_Usize_24.
    
    Module Impl_core_iter_traits_collect_IntoIterator_where_core_iter_traits_collect_IntoIterator_alloy_primitives_bits_fixed_FixedBytes_Usize_24_for_alloy_primitives_bits_function_Function.
      Definition Self : Ty.t := Ty.path "alloy_primitives::bits::function::Function".
      
      (*             $crate::private::derive_more::IntoIterator *)
      Definition _Item : Ty.t :=
        Ty.associated_in_trait
          "core::iter::traits::collect::IntoIterator"
          []
          []
          (Ty.apply
            (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
            [ Value.Integer IntegerKind.Usize 24 ]
            [])
          "Item".
      
      (*             $crate::private::derive_more::IntoIterator *)
      Definition _IntoIter : Ty.t :=
        Ty.associated_in_trait
          "core::iter::traits::collect::IntoIterator"
          []
          []
          (Ty.apply
            (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
            [ Value.Integer IntegerKind.Usize 24 ]
            [])
          "IntoIter".
      
      (*             $crate::private::derive_more::IntoIterator *)
      Definition into_iter (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "core::array::iter::IntoIter")
                [ Value.Integer IntegerKind.Usize 24 ]
                [ Ty.path "u8" ],
              M.get_trait_method (|
                "core::iter::traits::collect::IntoIterator",
                Ty.apply
                  (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                  [ Value.Integer IntegerKind.Usize 24 ]
                  [],
                [],
                [],
                "into_iter",
                [],
                []
              |),
              [
                M.read (|
                  M.SubPointer.get_struct_tuple_field (|
                    self,
                    "alloy_primitives::bits::function::Function",
                    0
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::iter::traits::collect::IntoIterator"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *)
          [
            ("Item", InstanceField.Ty _Item);
            ("IntoIter", InstanceField.Ty _IntoIter);
            ("into_iter", InstanceField.Method into_iter)
          ].
    End Impl_core_iter_traits_collect_IntoIterator_where_core_iter_traits_collect_IntoIterator_alloy_primitives_bits_fixed_FixedBytes_Usize_24_for_alloy_primitives_bits_function_Function.
    
    Module Impl_core_iter_traits_collect_IntoIterator_where_core_iter_traits_collect_IntoIterator_ref__alloy_primitives_bits_fixed_FixedBytes_Usize_24_for_ref__alloy_primitives_bits_function_Function.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "&") [] [ Ty.path "alloy_primitives::bits::function::Function" ].
      
      (*             $crate::private::derive_more::IntoIterator *)
      Definition _Item : Ty.t :=
        Ty.associated_in_trait
          "core::iter::traits::collect::IntoIterator"
          []
          []
          (Ty.apply
            (Ty.path "&")
            []
            [
              Ty.apply
                (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                [ Value.Integer IntegerKind.Usize 24 ]
                []
            ])
          "Item".
      
      (*             $crate::private::derive_more::IntoIterator *)
      Definition _IntoIter : Ty.t :=
        Ty.associated_in_trait
          "core::iter::traits::collect::IntoIterator"
          []
          []
          (Ty.apply
            (Ty.path "&")
            []
            [
              Ty.apply
                (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                [ Value.Integer IntegerKind.Usize 24 ]
                []
            ])
          "IntoIter".
      
      (*             $crate::private::derive_more::IntoIterator *)
      Definition into_iter (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.associated_in_trait
                "core::iter::traits::collect::IntoIterator"
                []
                []
                (Ty.apply
                  (Ty.path "&")
                  []
                  [
                    Ty.apply
                      (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                      [ Value.Integer IntegerKind.Usize 24 ]
                      []
                  ])
                "IntoIter",
              M.get_trait_method (|
                "core::iter::traits::collect::IntoIterator",
                Ty.apply
                  (Ty.path "&")
                  []
                  [
                    Ty.apply
                      (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                      [ Value.Integer IntegerKind.Usize 24 ]
                      []
                  ],
                [],
                [],
                "into_iter",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_tuple_field (|
                        M.deref (| M.read (| self |) |),
                        "alloy_primitives::bits::function::Function",
                        0
                      |)
                    |)
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::iter::traits::collect::IntoIterator"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *)
          [
            ("Item", InstanceField.Ty _Item);
            ("IntoIter", InstanceField.Ty _IntoIter);
            ("into_iter", InstanceField.Method into_iter)
          ].
    End Impl_core_iter_traits_collect_IntoIterator_where_core_iter_traits_collect_IntoIterator_ref__alloy_primitives_bits_fixed_FixedBytes_Usize_24_for_ref__alloy_primitives_bits_function_Function.
    
    Module Impl_core_iter_traits_collect_IntoIterator_where_core_iter_traits_collect_IntoIterator_ref_mut_alloy_primitives_bits_fixed_FixedBytes_Usize_24_for_ref_mut_alloy_primitives_bits_function_Function.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "&mut") [] [ Ty.path "alloy_primitives::bits::function::Function" ].
      
      (*             $crate::private::derive_more::IntoIterator *)
      Definition _Item : Ty.t :=
        Ty.associated_in_trait
          "core::iter::traits::collect::IntoIterator"
          []
          []
          (Ty.apply
            (Ty.path "&mut")
            []
            [
              Ty.apply
                (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                [ Value.Integer IntegerKind.Usize 24 ]
                []
            ])
          "Item".
      
      (*             $crate::private::derive_more::IntoIterator *)
      Definition _IntoIter : Ty.t :=
        Ty.associated_in_trait
          "core::iter::traits::collect::IntoIterator"
          []
          []
          (Ty.apply
            (Ty.path "&mut")
            []
            [
              Ty.apply
                (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                [ Value.Integer IntegerKind.Usize 24 ]
                []
            ])
          "IntoIter".
      
      (*             $crate::private::derive_more::IntoIterator *)
      Definition into_iter (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.associated_in_trait
                "core::iter::traits::collect::IntoIterator"
                []
                []
                (Ty.apply
                  (Ty.path "&mut")
                  []
                  [
                    Ty.apply
                      (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                      [ Value.Integer IntegerKind.Usize 24 ]
                      []
                  ])
                "IntoIter",
              M.get_trait_method (|
                "core::iter::traits::collect::IntoIterator",
                Ty.apply
                  (Ty.path "&mut")
                  []
                  [
                    Ty.apply
                      (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                      [ Value.Integer IntegerKind.Usize 24 ]
                      []
                  ],
                [],
                [],
                "into_iter",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.MutRef,
                      M.SubPointer.get_struct_tuple_field (|
                        M.deref (| M.read (| self |) |),
                        "alloy_primitives::bits::function::Function",
                        0
                      |)
                    |)
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::iter::traits::collect::IntoIterator"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *)
          [
            ("Item", InstanceField.Ty _Item);
            ("IntoIter", InstanceField.Ty _IntoIter);
            ("into_iter", InstanceField.Method into_iter)
          ].
    End Impl_core_iter_traits_collect_IntoIterator_where_core_iter_traits_collect_IntoIterator_ref_mut_alloy_primitives_bits_fixed_FixedBytes_Usize_24_for_ref_mut_alloy_primitives_bits_function_Function.
    
    Module Impl_core_fmt_LowerHex_for_alloy_primitives_bits_function_Function.
      Definition Self : Ty.t := Ty.path "alloy_primitives::bits::function::Function".
      
      (*             $crate::private::derive_more::LowerHex *)
      Definition fmt (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; __derive_more_f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let __derive_more_f := M.alloc (| __derive_more_f |) in
            M.read (|
              let~ _0 :
                  Ty.apply
                    (Ty.path "&")
                    []
                    [
                      Ty.apply
                        (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                        [ Value.Integer IntegerKind.Usize 24 ]
                        []
                    ] :=
                M.alloc (|
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.SubPointer.get_struct_tuple_field (|
                      M.deref (| M.read (| self |) |),
                      "alloy_primitives::bits::function::Function",
                      0
                    |)
                  |)
                |) in
              M.alloc (|
                M.call_closure (|
                  Ty.apply
                    (Ty.path "core::result::Result")
                    []
                    [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                  M.get_trait_method (|
                    "core::fmt::LowerHex",
                    Ty.apply
                      (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                      [ Value.Integer IntegerKind.Usize 24 ]
                      [],
                    [],
                    [],
                    "fmt",
                    [],
                    []
                  |),
                  [
                    M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| _0 |) |) |);
                    M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| __derive_more_f |) |) |)
                  ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::LowerHex"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
    End Impl_core_fmt_LowerHex_for_alloy_primitives_bits_function_Function.
    
    Module Impl_core_fmt_UpperHex_for_alloy_primitives_bits_function_Function.
      Definition Self : Ty.t := Ty.path "alloy_primitives::bits::function::Function".
      
      (*             $crate::private::derive_more::UpperHex *)
      Definition fmt (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; __derive_more_f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let __derive_more_f := M.alloc (| __derive_more_f |) in
            M.read (|
              let~ _0 :
                  Ty.apply
                    (Ty.path "&")
                    []
                    [
                      Ty.apply
                        (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                        [ Value.Integer IntegerKind.Usize 24 ]
                        []
                    ] :=
                M.alloc (|
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.SubPointer.get_struct_tuple_field (|
                      M.deref (| M.read (| self |) |),
                      "alloy_primitives::bits::function::Function",
                      0
                    |)
                  |)
                |) in
              M.alloc (|
                M.call_closure (|
                  Ty.apply
                    (Ty.path "core::result::Result")
                    []
                    [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                  M.get_trait_method (|
                    "core::fmt::UpperHex",
                    Ty.apply
                      (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                      [ Value.Integer IntegerKind.Usize 24 ]
                      [],
                    [],
                    [],
                    "fmt",
                    [],
                    []
                  |),
                  [
                    M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| _0 |) |) |);
                    M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| __derive_more_f |) |) |)
                  ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::UpperHex"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
    End Impl_core_fmt_UpperHex_for_alloy_primitives_bits_function_Function.
    
    Module Impl_core_fmt_Display_for_alloy_primitives_bits_function_Function.
      Definition Self : Ty.t := Ty.path "alloy_primitives::bits::function::Function".
      
      (*             $crate::private::derive_more::Display *)
      Definition fmt (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; __derive_more_f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let __derive_more_f := M.alloc (| __derive_more_f |) in
            M.read (|
              let~ _0 :
                  Ty.apply
                    (Ty.path "&")
                    []
                    [
                      Ty.apply
                        (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                        [ Value.Integer IntegerKind.Usize 24 ]
                        []
                    ] :=
                M.alloc (|
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.SubPointer.get_struct_tuple_field (|
                      M.deref (| M.read (| self |) |),
                      "alloy_primitives::bits::function::Function",
                      0
                    |)
                  |)
                |) in
              M.alloc (|
                M.call_closure (|
                  Ty.apply
                    (Ty.path "core::result::Result")
                    []
                    [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                  M.get_trait_method (|
                    "core::fmt::Display",
                    Ty.apply
                      (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                      [ Value.Integer IntegerKind.Usize 24 ]
                      [],
                    [],
                    [],
                    "fmt",
                    [],
                    []
                  |),
                  [
                    M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| _0 |) |) |);
                    M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| __derive_more_f |) |) |)
                  ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::Display"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
    End Impl_core_fmt_Display_for_alloy_primitives_bits_function_Function.
    
    Module Impl_core_convert_From_array_Usize_24_u8_for_alloy_primitives_bits_function_Function.
      Definition Self : Ty.t := Ty.path "alloy_primitives::bits::function::Function".
      
      (*
                  fn from(value: [u8; $n]) -> Self {
                      Self($crate::FixedBytes(value))
                  }
      *)
      Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            Value.StructTuple
              "alloy_primitives::bits::function::Function"
              [ Value.StructTuple "alloy_primitives::bits::fixed::FixedBytes" [ M.read (| value |) ]
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 24 ] [ Ty.path "u8" ] ]
          Self
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_array_Usize_24_u8_for_alloy_primitives_bits_function_Function.
    
    Module Impl_core_convert_From_alloy_primitives_bits_function_Function_for_array_Usize_24_u8.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 24 ] [ Ty.path "u8" ].
      
      (*
                  fn from(value: $name) -> Self {
                      value.0 .0
                  }
      *)
      Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            M.read (|
              M.SubPointer.get_struct_tuple_field (|
                M.SubPointer.get_struct_tuple_field (|
                  value,
                  "alloy_primitives::bits::function::Function",
                  0
                |),
                "alloy_primitives::bits::fixed::FixedBytes",
                0
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "alloy_primitives::bits::function::Function" ]
          Self
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_alloy_primitives_bits_function_Function_for_array_Usize_24_u8.
    
    Module Impl_core_convert_From_ref__array_Usize_24_u8_for_alloy_primitives_bits_function_Function.
      Definition Self : Ty.t := Ty.path "alloy_primitives::bits::function::Function".
      
      (*
                  fn from(value: &'a [u8; $n]) -> Self {
                      Self($crate::FixedBytes( *value))
                  }
      *)
      Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            Value.StructTuple
              "alloy_primitives::bits::function::Function"
              [
                Value.StructTuple
                  "alloy_primitives::bits::fixed::FixedBytes"
                  [ M.read (| M.deref (| M.read (| value |) |) |) ]
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [
            Ty.apply
              (Ty.path "&")
              []
              [ Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 24 ] [ Ty.path "u8" ] ]
          ]
          Self
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_ref__array_Usize_24_u8_for_alloy_primitives_bits_function_Function.
    
    Module Impl_core_convert_From_ref_mut_array_Usize_24_u8_for_alloy_primitives_bits_function_Function.
      Definition Self : Ty.t := Ty.path "alloy_primitives::bits::function::Function".
      
      (*
                  fn from(value: &'a mut [u8; $n]) -> Self {
                      Self($crate::FixedBytes( *value))
                  }
      *)
      Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            Value.StructTuple
              "alloy_primitives::bits::function::Function"
              [
                Value.StructTuple
                  "alloy_primitives::bits::fixed::FixedBytes"
                  [ M.read (| M.deref (| M.read (| value |) |) |) ]
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [
            Ty.apply
              (Ty.path "&mut")
              []
              [ Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 24 ] [ Ty.path "u8" ] ]
          ]
          Self
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_ref_mut_array_Usize_24_u8_for_alloy_primitives_bits_function_Function.
    
    Module Impl_core_convert_TryFrom_ref__slice_u8_for_alloy_primitives_bits_function_Function.
      Definition Self : Ty.t := Ty.path "alloy_primitives::bits::function::Function".
      
      (*             type Error = $crate::private::core::array::TryFromSliceError; *)
      Definition _Error : Ty.t := Ty.path "core::array::TryFromSliceError".
      
      (*
                  fn try_from(slice: &[u8]) -> Result<Self, Self::Error> {
                      <&Self as $crate::private::TryFrom<&[u8]>>::try_from(slice).copied()
                  }
      *)
      Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ slice ] =>
          ltac:(M.monadic
            (let slice := M.alloc (| slice |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "core::result::Result")
                []
                [
                  Ty.path "alloy_primitives::bits::function::Function";
                  Ty.path "core::array::TryFromSliceError"
                ],
              M.get_associated_function (|
                Ty.apply
                  (Ty.path "core::result::Result")
                  []
                  [
                    Ty.apply
                      (Ty.path "&")
                      []
                      [ Ty.path "alloy_primitives::bits::function::Function" ];
                    Ty.path "core::array::TryFromSliceError"
                  ],
                "copied",
                [],
                []
              |),
              [
                M.call_closure (|
                  Ty.apply
                    (Ty.path "core::result::Result")
                    []
                    [
                      Ty.apply
                        (Ty.path "&")
                        []
                        [ Ty.path "alloy_primitives::bits::function::Function" ];
                      Ty.path "core::array::TryFromSliceError"
                    ],
                  M.get_trait_method (|
                    "core::convert::TryFrom",
                    Ty.apply
                      (Ty.path "&")
                      []
                      [ Ty.path "alloy_primitives::bits::function::Function" ],
                    [],
                    [ Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
                    ],
                    "try_from",
                    [],
                    []
                  |),
                  [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| slice |) |) |) ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::TryFrom"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ] ]
          Self
          (* Instance *)
          [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
    End Impl_core_convert_TryFrom_ref__slice_u8_for_alloy_primitives_bits_function_Function.
    
    Module Impl_core_convert_TryFrom_ref_mut_slice_u8_for_alloy_primitives_bits_function_Function.
      Definition Self : Ty.t := Ty.path "alloy_primitives::bits::function::Function".
      
      (*             type Error = $crate::private::core::array::TryFromSliceError; *)
      Definition _Error : Ty.t := Ty.path "core::array::TryFromSliceError".
      
      (*
                  fn try_from(slice: &mut [u8]) -> Result<Self, Self::Error> {
                      <Self as $crate::private::TryFrom<&[u8]>>::try_from(&*slice)
                  }
      *)
      Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ slice ] =>
          ltac:(M.monadic
            (let slice := M.alloc (| slice |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "core::result::Result")
                []
                [
                  Ty.path "alloy_primitives::bits::function::Function";
                  Ty.path "core::array::TryFromSliceError"
                ],
              M.get_trait_method (|
                "core::convert::TryFrom",
                Ty.path "alloy_primitives::bits::function::Function",
                [],
                [ Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ] ],
                "try_from",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (| M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| slice |) |) |) |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::TryFrom"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ] ]
          Self
          (* Instance *)
          [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
    End Impl_core_convert_TryFrom_ref_mut_slice_u8_for_alloy_primitives_bits_function_Function.
    
    Module Impl_core_convert_TryFrom_ref__slice_u8_for_ref__alloy_primitives_bits_function_Function.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "&") [] [ Ty.path "alloy_primitives::bits::function::Function" ].
      
      (*             type Error = $crate::private::core::array::TryFromSliceError; *)
      Definition _Error : Ty.t := Ty.path "core::array::TryFromSliceError".
      
      (*
                  fn try_from(slice: &'a [u8]) -> Result<&'a $name, Self::Error> {
                      // SAFETY: `$name` is `repr(transparent)` for `FixedBytes<$n>`
                      // and consequently `[u8; $n]`
                      <&[u8; $n] as $crate::private::TryFrom<&[u8]>>::try_from(slice)
                          .map(|array_ref| unsafe { $crate::private::core::mem::transmute(array_ref) })
                  }
      *)
      Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ slice ] =>
          ltac:(M.monadic
            (let slice := M.alloc (| slice |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "core::result::Result")
                []
                [
                  Ty.apply
                    (Ty.path "&")
                    []
                    [ Ty.path "alloy_primitives::bits::function::Function" ];
                  Ty.path "core::array::TryFromSliceError"
                ],
              M.get_associated_function (|
                Ty.apply
                  (Ty.path "core::result::Result")
                  []
                  [
                    Ty.apply
                      (Ty.path "&")
                      []
                      [
                        Ty.apply
                          (Ty.path "array")
                          [ Value.Integer IntegerKind.Usize 24 ]
                          [ Ty.path "u8" ]
                      ];
                    Ty.path "core::array::TryFromSliceError"
                  ],
                "map",
                [],
                [
                  Ty.apply
                    (Ty.path "&")
                    []
                    [ Ty.path "alloy_primitives::bits::function::Function" ];
                  Ty.function
                    [
                      Ty.tuple
                        [
                          Ty.apply
                            (Ty.path "&")
                            []
                            [
                              Ty.apply
                                (Ty.path "array")
                                [ Value.Integer IntegerKind.Usize 24 ]
                                [ Ty.path "u8" ]
                            ]
                        ]
                    ]
                    (Ty.apply
                      (Ty.path "&")
                      []
                      [ Ty.path "alloy_primitives::bits::function::Function" ])
                ]
              |),
              [
                M.call_closure (|
                  Ty.apply
                    (Ty.path "core::result::Result")
                    []
                    [
                      Ty.apply
                        (Ty.path "&")
                        []
                        [
                          Ty.apply
                            (Ty.path "array")
                            [ Value.Integer IntegerKind.Usize 24 ]
                            [ Ty.path "u8" ]
                        ];
                      Ty.path "core::array::TryFromSliceError"
                    ],
                  M.get_trait_method (|
                    "core::convert::TryFrom",
                    Ty.apply
                      (Ty.path "&")
                      []
                      [
                        Ty.apply
                          (Ty.path "array")
                          [ Value.Integer IntegerKind.Usize 24 ]
                          [ Ty.path "u8" ]
                      ],
                    [],
                    [ Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
                    ],
                    "try_from",
                    [],
                    []
                  |),
                  [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| slice |) |) |) ]
                |);
                M.closure
                  (fun γ =>
                    ltac:(M.monadic
                      match γ with
                      | [ α0 ] =>
                        ltac:(M.monadic
                          (M.match_operator (|
                            Some
                              (Ty.function
                                [
                                  Ty.tuple
                                    [
                                      Ty.apply
                                        (Ty.path "&")
                                        []
                                        [
                                          Ty.apply
                                            (Ty.path "array")
                                            [ Value.Integer IntegerKind.Usize 24 ]
                                            [ Ty.path "u8" ]
                                        ]
                                    ]
                                ]
                                (Ty.apply
                                  (Ty.path "&")
                                  []
                                  [ Ty.path "alloy_primitives::bits::function::Function" ])),
                            M.alloc (| α0 |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let array_ref := M.copy (| γ |) in
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "&")
                                      []
                                      [ Ty.path "alloy_primitives::bits::function::Function" ],
                                    M.get_function (|
                                      "core::intrinsics::transmute",
                                      [],
                                      [
                                        Ty.apply
                                          (Ty.path "&")
                                          []
                                          [
                                            Ty.apply
                                              (Ty.path "array")
                                              [ Value.Integer IntegerKind.Usize 24 ]
                                              [ Ty.path "u8" ]
                                          ];
                                        Ty.apply
                                          (Ty.path "&")
                                          []
                                          [ Ty.path "alloy_primitives::bits::function::Function" ]
                                      ]
                                    |),
                                    [ M.read (| array_ref |) ]
                                  |)))
                            ]
                          |)))
                      | _ => M.impossible "wrong number of arguments"
                      end))
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::TryFrom"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ] ]
          Self
          (* Instance *)
          [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
    End Impl_core_convert_TryFrom_ref__slice_u8_for_ref__alloy_primitives_bits_function_Function.
    
    Module Impl_core_convert_TryFrom_ref_mut_slice_u8_for_ref_mut_alloy_primitives_bits_function_Function.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "&mut") [] [ Ty.path "alloy_primitives::bits::function::Function" ].
      
      (*             type Error = $crate::private::core::array::TryFromSliceError; *)
      Definition _Error : Ty.t := Ty.path "core::array::TryFromSliceError".
      
      (*
                  fn try_from(slice: &'a mut [u8]) -> Result<&'a mut $name, Self::Error> {
                      // SAFETY: `$name` is `repr(transparent)` for `FixedBytes<$n>`
                      // and consequently `[u8; $n]`
                      <&mut [u8; $n] as $crate::private::TryFrom<&mut [u8]>>::try_from(slice)
                          .map(|array_ref| unsafe { $crate::private::core::mem::transmute(array_ref) })
                  }
      *)
      Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ slice ] =>
          ltac:(M.monadic
            (let slice := M.alloc (| slice |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "core::result::Result")
                []
                [
                  Ty.apply
                    (Ty.path "&mut")
                    []
                    [ Ty.path "alloy_primitives::bits::function::Function" ];
                  Ty.path "core::array::TryFromSliceError"
                ],
              M.get_associated_function (|
                Ty.apply
                  (Ty.path "core::result::Result")
                  []
                  [
                    Ty.apply
                      (Ty.path "&mut")
                      []
                      [
                        Ty.apply
                          (Ty.path "array")
                          [ Value.Integer IntegerKind.Usize 24 ]
                          [ Ty.path "u8" ]
                      ];
                    Ty.path "core::array::TryFromSliceError"
                  ],
                "map",
                [],
                [
                  Ty.apply
                    (Ty.path "&mut")
                    []
                    [ Ty.path "alloy_primitives::bits::function::Function" ];
                  Ty.function
                    [
                      Ty.tuple
                        [
                          Ty.apply
                            (Ty.path "&mut")
                            []
                            [
                              Ty.apply
                                (Ty.path "array")
                                [ Value.Integer IntegerKind.Usize 24 ]
                                [ Ty.path "u8" ]
                            ]
                        ]
                    ]
                    (Ty.apply
                      (Ty.path "&mut")
                      []
                      [ Ty.path "alloy_primitives::bits::function::Function" ])
                ]
              |),
              [
                M.call_closure (|
                  Ty.apply
                    (Ty.path "core::result::Result")
                    []
                    [
                      Ty.apply
                        (Ty.path "&mut")
                        []
                        [
                          Ty.apply
                            (Ty.path "array")
                            [ Value.Integer IntegerKind.Usize 24 ]
                            [ Ty.path "u8" ]
                        ];
                      Ty.path "core::array::TryFromSliceError"
                    ],
                  M.get_trait_method (|
                    "core::convert::TryFrom",
                    Ty.apply
                      (Ty.path "&mut")
                      []
                      [
                        Ty.apply
                          (Ty.path "array")
                          [ Value.Integer IntegerKind.Usize 24 ]
                          [ Ty.path "u8" ]
                      ],
                    [],
                    [
                      Ty.apply
                        (Ty.path "&mut")
                        []
                        [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
                    ],
                    "try_from",
                    [],
                    []
                  |),
                  [ M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| slice |) |) |) ]
                |);
                M.closure
                  (fun γ =>
                    ltac:(M.monadic
                      match γ with
                      | [ α0 ] =>
                        ltac:(M.monadic
                          (M.match_operator (|
                            Some
                              (Ty.function
                                [
                                  Ty.tuple
                                    [
                                      Ty.apply
                                        (Ty.path "&mut")
                                        []
                                        [
                                          Ty.apply
                                            (Ty.path "array")
                                            [ Value.Integer IntegerKind.Usize 24 ]
                                            [ Ty.path "u8" ]
                                        ]
                                    ]
                                ]
                                (Ty.apply
                                  (Ty.path "&mut")
                                  []
                                  [ Ty.path "alloy_primitives::bits::function::Function" ])),
                            M.alloc (| α0 |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let array_ref := M.copy (| γ |) in
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "&mut")
                                      []
                                      [ Ty.path "alloy_primitives::bits::function::Function" ],
                                    M.get_function (|
                                      "core::intrinsics::transmute",
                                      [],
                                      [
                                        Ty.apply
                                          (Ty.path "&mut")
                                          []
                                          [
                                            Ty.apply
                                              (Ty.path "array")
                                              [ Value.Integer IntegerKind.Usize 24 ]
                                              [ Ty.path "u8" ]
                                          ];
                                        Ty.apply
                                          (Ty.path "&mut")
                                          []
                                          [ Ty.path "alloy_primitives::bits::function::Function" ]
                                      ]
                                    |),
                                    [ M.read (| array_ref |) ]
                                  |)))
                            ]
                          |)))
                      | _ => M.impossible "wrong number of arguments"
                      end))
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::TryFrom"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ] ]
          Self
          (* Instance *)
          [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
    End Impl_core_convert_TryFrom_ref_mut_slice_u8_for_ref_mut_alloy_primitives_bits_function_Function.
    
    Module Impl_core_convert_AsRef_array_Usize_24_u8_for_alloy_primitives_bits_function_Function.
      Definition Self : Ty.t := Ty.path "alloy_primitives::bits::function::Function".
      
      (*
                  fn as_ref(&self) -> &[u8; $n] {
                      &self.0 .0
                  }
      *)
      Definition as_ref (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.borrow (|
              Pointer.Kind.Ref,
              M.deref (|
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.SubPointer.get_struct_tuple_field (|
                    M.SubPointer.get_struct_tuple_field (|
                      M.deref (| M.read (| self |) |),
                      "alloy_primitives::bits::function::Function",
                      0
                    |),
                    "alloy_primitives::bits::fixed::FixedBytes",
                    0
                  |)
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::AsRef"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 24 ] [ Ty.path "u8" ] ]
          Self
          (* Instance *) [ ("as_ref", InstanceField.Method as_ref) ].
    End Impl_core_convert_AsRef_array_Usize_24_u8_for_alloy_primitives_bits_function_Function.
    
    Module Impl_core_convert_AsMut_array_Usize_24_u8_for_alloy_primitives_bits_function_Function.
      Definition Self : Ty.t := Ty.path "alloy_primitives::bits::function::Function".
      
      (*
                  fn as_mut(&mut self) -> &mut [u8; $n] {
                      &mut self.0 .0
                  }
      *)
      Definition as_mut (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.borrow (|
              Pointer.Kind.MutRef,
              M.deref (|
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.MutRef,
                      M.SubPointer.get_struct_tuple_field (|
                        M.SubPointer.get_struct_tuple_field (|
                          M.deref (| M.read (| self |) |),
                          "alloy_primitives::bits::function::Function",
                          0
                        |),
                        "alloy_primitives::bits::fixed::FixedBytes",
                        0
                      |)
                    |)
                  |)
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::AsMut"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 24 ] [ Ty.path "u8" ] ]
          Self
          (* Instance *) [ ("as_mut", InstanceField.Method as_mut) ].
    End Impl_core_convert_AsMut_array_Usize_24_u8_for_alloy_primitives_bits_function_Function.
    
    Module Impl_core_convert_AsRef_slice_u8_for_alloy_primitives_bits_function_Function.
      Definition Self : Ty.t := Ty.path "alloy_primitives::bits::function::Function".
      
      (*
                  fn as_ref(&self) -> &[u8] {
                      &self.0 .0
                  }
      *)
      Definition as_ref (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            (* Unsize *)
            M.pointer_coercion
              (M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.SubPointer.get_struct_tuple_field (|
                      M.SubPointer.get_struct_tuple_field (|
                        M.deref (| M.read (| self |) |),
                        "alloy_primitives::bits::function::Function",
                        0
                      |),
                      "alloy_primitives::bits::fixed::FixedBytes",
                      0
                    |)
                  |)
                |)
              |))))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::AsRef"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
          Self
          (* Instance *) [ ("as_ref", InstanceField.Method as_ref) ].
    End Impl_core_convert_AsRef_slice_u8_for_alloy_primitives_bits_function_Function.
    
    Module Impl_core_convert_AsMut_slice_u8_for_alloy_primitives_bits_function_Function.
      Definition Self : Ty.t := Ty.path "alloy_primitives::bits::function::Function".
      
      (*
                  fn as_mut(&mut self) -> &mut [u8] {
                      &mut self.0 .0
                  }
      *)
      Definition as_mut (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.borrow (|
              Pointer.Kind.MutRef,
              M.deref (|
                (* Unsize *)
                M.pointer_coercion
                  (M.borrow (|
                    Pointer.Kind.MutRef,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.MutRef,
                        M.SubPointer.get_struct_tuple_field (|
                          M.SubPointer.get_struct_tuple_field (|
                            M.deref (| M.read (| self |) |),
                            "alloy_primitives::bits::function::Function",
                            0
                          |),
                          "alloy_primitives::bits::fixed::FixedBytes",
                          0
                        |)
                      |)
                    |)
                  |))
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::AsMut"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
          Self
          (* Instance *) [ ("as_mut", InstanceField.Method as_mut) ].
    End Impl_core_convert_AsMut_slice_u8_for_alloy_primitives_bits_function_Function.
    
    Module Impl_core_fmt_Debug_for_alloy_primitives_bits_function_Function.
      Definition Self : Ty.t := Ty.path "alloy_primitives::bits::function::Function".
      
      (*
                  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                      $crate::private::core::fmt::Debug::fmt(&self.0, f)
                  }
      *)
      Definition fmt (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "core::result::Result")
                []
                [ Ty.tuple []; Ty.path "core::fmt::Error" ],
              M.get_trait_method (|
                "core::fmt::Debug",
                Ty.apply
                  (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                  [ Value.Integer IntegerKind.Usize 24 ]
                  [],
                [],
                [],
                "fmt",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_tuple_field (|
                        M.deref (| M.read (| self |) |),
                        "alloy_primitives::bits::function::Function",
                        0
                      |)
                    |)
                  |)
                |);
                M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::Debug"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
    End Impl_core_fmt_Debug_for_alloy_primitives_bits_function_Function.
    
    Module Impl_core_borrow_Borrow_slice_u8_for_alloy_primitives_bits_function_Function.
      Definition Self : Ty.t := Ty.path "alloy_primitives::bits::function::Function".
      
      (*
                  fn borrow(&self) -> &$t {
                      $crate::private::Borrow::borrow(&self.0)
                  }
      *)
      Definition borrow (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.borrow (|
              Pointer.Kind.Ref,
              M.deref (|
                M.call_closure (|
                  Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                  M.get_trait_method (|
                    "core::borrow::Borrow",
                    Ty.apply
                      (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                      [ Value.Integer IntegerKind.Usize 24 ]
                      [],
                    [],
                    [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                    "borrow",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_tuple_field (|
                            M.deref (| M.read (| self |) |),
                            "alloy_primitives::bits::function::Function",
                            0
                          |)
                        |)
                      |)
                    |)
                  ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::borrow::Borrow"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
          Self
          (* Instance *) [ ("borrow", InstanceField.Method borrow) ].
    End Impl_core_borrow_Borrow_slice_u8_for_alloy_primitives_bits_function_Function.
    
    Module Impl_core_borrow_Borrow_slice_u8_for_ref__alloy_primitives_bits_function_Function.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "&") [] [ Ty.path "alloy_primitives::bits::function::Function" ].
      
      (*
                  fn borrow(&self) -> &$t {
                      $crate::private::Borrow::borrow(&self.0)
                  }
      *)
      Definition borrow (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.borrow (|
              Pointer.Kind.Ref,
              M.deref (|
                M.call_closure (|
                  Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                  M.get_trait_method (|
                    "core::borrow::Borrow",
                    Ty.apply
                      (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                      [ Value.Integer IntegerKind.Usize 24 ]
                      [],
                    [],
                    [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                    "borrow",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_tuple_field (|
                            M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |),
                            "alloy_primitives::bits::function::Function",
                            0
                          |)
                        |)
                      |)
                    |)
                  ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::borrow::Borrow"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
          Self
          (* Instance *) [ ("borrow", InstanceField.Method borrow) ].
    End Impl_core_borrow_Borrow_slice_u8_for_ref__alloy_primitives_bits_function_Function.
    
    Module Impl_core_borrow_Borrow_slice_u8_for_ref_mut_alloy_primitives_bits_function_Function.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "&mut") [] [ Ty.path "alloy_primitives::bits::function::Function" ].
      
      (*
                  fn borrow(&self) -> &$t {
                      $crate::private::Borrow::borrow(&self.0)
                  }
      *)
      Definition borrow (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.borrow (|
              Pointer.Kind.Ref,
              M.deref (|
                M.call_closure (|
                  Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                  M.get_trait_method (|
                    "core::borrow::Borrow",
                    Ty.apply
                      (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                      [ Value.Integer IntegerKind.Usize 24 ]
                      [],
                    [],
                    [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                    "borrow",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_tuple_field (|
                            M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |),
                            "alloy_primitives::bits::function::Function",
                            0
                          |)
                        |)
                      |)
                    |)
                  ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::borrow::Borrow"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
          Self
          (* Instance *) [ ("borrow", InstanceField.Method borrow) ].
    End Impl_core_borrow_Borrow_slice_u8_for_ref_mut_alloy_primitives_bits_function_Function.
    
    Module Impl_core_borrow_Borrow_array_Usize_24_u8_for_alloy_primitives_bits_function_Function.
      Definition Self : Ty.t := Ty.path "alloy_primitives::bits::function::Function".
      
      (*
                  fn borrow(&self) -> &$t {
                      $crate::private::Borrow::borrow(&self.0)
                  }
      *)
      Definition borrow (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.borrow (|
              Pointer.Kind.Ref,
              M.deref (|
                M.call_closure (|
                  Ty.apply
                    (Ty.path "&")
                    []
                    [
                      Ty.apply
                        (Ty.path "array")
                        [ Value.Integer IntegerKind.Usize 24 ]
                        [ Ty.path "u8" ]
                    ],
                  M.get_trait_method (|
                    "core::borrow::Borrow",
                    Ty.apply
                      (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                      [ Value.Integer IntegerKind.Usize 24 ]
                      [],
                    [],
                    [
                      Ty.apply
                        (Ty.path "array")
                        [ Value.Integer IntegerKind.Usize 24 ]
                        [ Ty.path "u8" ]
                    ],
                    "borrow",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_tuple_field (|
                            M.deref (| M.read (| self |) |),
                            "alloy_primitives::bits::function::Function",
                            0
                          |)
                        |)
                      |)
                    |)
                  ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::borrow::Borrow"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 24 ] [ Ty.path "u8" ] ]
          Self
          (* Instance *) [ ("borrow", InstanceField.Method borrow) ].
    End Impl_core_borrow_Borrow_array_Usize_24_u8_for_alloy_primitives_bits_function_Function.
    
    Module Impl_core_borrow_Borrow_array_Usize_24_u8_for_ref__alloy_primitives_bits_function_Function.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "&") [] [ Ty.path "alloy_primitives::bits::function::Function" ].
      
      (*
                  fn borrow(&self) -> &$t {
                      $crate::private::Borrow::borrow(&self.0)
                  }
      *)
      Definition borrow (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.borrow (|
              Pointer.Kind.Ref,
              M.deref (|
                M.call_closure (|
                  Ty.apply
                    (Ty.path "&")
                    []
                    [
                      Ty.apply
                        (Ty.path "array")
                        [ Value.Integer IntegerKind.Usize 24 ]
                        [ Ty.path "u8" ]
                    ],
                  M.get_trait_method (|
                    "core::borrow::Borrow",
                    Ty.apply
                      (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                      [ Value.Integer IntegerKind.Usize 24 ]
                      [],
                    [],
                    [
                      Ty.apply
                        (Ty.path "array")
                        [ Value.Integer IntegerKind.Usize 24 ]
                        [ Ty.path "u8" ]
                    ],
                    "borrow",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_tuple_field (|
                            M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |),
                            "alloy_primitives::bits::function::Function",
                            0
                          |)
                        |)
                      |)
                    |)
                  ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::borrow::Borrow"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 24 ] [ Ty.path "u8" ] ]
          Self
          (* Instance *) [ ("borrow", InstanceField.Method borrow) ].
    End Impl_core_borrow_Borrow_array_Usize_24_u8_for_ref__alloy_primitives_bits_function_Function.
    
    Module Impl_core_borrow_Borrow_array_Usize_24_u8_for_ref_mut_alloy_primitives_bits_function_Function.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "&mut") [] [ Ty.path "alloy_primitives::bits::function::Function" ].
      
      (*
                  fn borrow(&self) -> &$t {
                      $crate::private::Borrow::borrow(&self.0)
                  }
      *)
      Definition borrow (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.borrow (|
              Pointer.Kind.Ref,
              M.deref (|
                M.call_closure (|
                  Ty.apply
                    (Ty.path "&")
                    []
                    [
                      Ty.apply
                        (Ty.path "array")
                        [ Value.Integer IntegerKind.Usize 24 ]
                        [ Ty.path "u8" ]
                    ],
                  M.get_trait_method (|
                    "core::borrow::Borrow",
                    Ty.apply
                      (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                      [ Value.Integer IntegerKind.Usize 24 ]
                      [],
                    [],
                    [
                      Ty.apply
                        (Ty.path "array")
                        [ Value.Integer IntegerKind.Usize 24 ]
                        [ Ty.path "u8" ]
                    ],
                    "borrow",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_tuple_field (|
                            M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |),
                            "alloy_primitives::bits::function::Function",
                            0
                          |)
                        |)
                      |)
                    |)
                  ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::borrow::Borrow"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 24 ] [ Ty.path "u8" ] ]
          Self
          (* Instance *) [ ("borrow", InstanceField.Method borrow) ].
    End Impl_core_borrow_Borrow_array_Usize_24_u8_for_ref_mut_alloy_primitives_bits_function_Function.
    
    Module Impl_core_borrow_BorrowMut_slice_u8_for_alloy_primitives_bits_function_Function.
      Definition Self : Ty.t := Ty.path "alloy_primitives::bits::function::Function".
      
      (*
                  fn borrow_mut(&mut self) -> &mut $t {
                      $crate::private::BorrowMut::borrow_mut(&mut self.0)
                  }
      *)
      Definition borrow_mut (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.borrow (|
              Pointer.Kind.MutRef,
              M.deref (|
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.deref (|
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "&mut")
                        []
                        [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                      M.get_trait_method (|
                        "core::borrow::BorrowMut",
                        Ty.apply
                          (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                          [ Value.Integer IntegerKind.Usize 24 ]
                          [],
                        [],
                        [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                        "borrow_mut",
                        [],
                        []
                      |),
                      [
                        M.borrow (|
                          Pointer.Kind.MutRef,
                          M.deref (|
                            M.borrow (|
                              Pointer.Kind.MutRef,
                              M.SubPointer.get_struct_tuple_field (|
                                M.deref (| M.read (| self |) |),
                                "alloy_primitives::bits::function::Function",
                                0
                              |)
                            |)
                          |)
                        |)
                      ]
                    |)
                  |)
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::borrow::BorrowMut"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
          Self
          (* Instance *) [ ("borrow_mut", InstanceField.Method borrow_mut) ].
    End Impl_core_borrow_BorrowMut_slice_u8_for_alloy_primitives_bits_function_Function.
    
    Module Impl_core_borrow_BorrowMut_slice_u8_for_ref_mut_alloy_primitives_bits_function_Function.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "&mut") [] [ Ty.path "alloy_primitives::bits::function::Function" ].
      
      (*
                  fn borrow_mut(&mut self) -> &mut $t {
                      $crate::private::BorrowMut::borrow_mut(&mut self.0)
                  }
      *)
      Definition borrow_mut (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.borrow (|
              Pointer.Kind.MutRef,
              M.deref (|
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.deref (|
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "&mut")
                        []
                        [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                      M.get_trait_method (|
                        "core::borrow::BorrowMut",
                        Ty.apply
                          (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                          [ Value.Integer IntegerKind.Usize 24 ]
                          [],
                        [],
                        [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                        "borrow_mut",
                        [],
                        []
                      |),
                      [
                        M.borrow (|
                          Pointer.Kind.MutRef,
                          M.deref (|
                            M.borrow (|
                              Pointer.Kind.MutRef,
                              M.SubPointer.get_struct_tuple_field (|
                                M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |),
                                "alloy_primitives::bits::function::Function",
                                0
                              |)
                            |)
                          |)
                        |)
                      ]
                    |)
                  |)
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::borrow::BorrowMut"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
          Self
          (* Instance *) [ ("borrow_mut", InstanceField.Method borrow_mut) ].
    End Impl_core_borrow_BorrowMut_slice_u8_for_ref_mut_alloy_primitives_bits_function_Function.
    
    Module Impl_core_borrow_BorrowMut_array_Usize_24_u8_for_alloy_primitives_bits_function_Function.
      Definition Self : Ty.t := Ty.path "alloy_primitives::bits::function::Function".
      
      (*
                  fn borrow_mut(&mut self) -> &mut $t {
                      $crate::private::BorrowMut::borrow_mut(&mut self.0)
                  }
      *)
      Definition borrow_mut (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.borrow (|
              Pointer.Kind.MutRef,
              M.deref (|
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.deref (|
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "&mut")
                        []
                        [
                          Ty.apply
                            (Ty.path "array")
                            [ Value.Integer IntegerKind.Usize 24 ]
                            [ Ty.path "u8" ]
                        ],
                      M.get_trait_method (|
                        "core::borrow::BorrowMut",
                        Ty.apply
                          (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                          [ Value.Integer IntegerKind.Usize 24 ]
                          [],
                        [],
                        [
                          Ty.apply
                            (Ty.path "array")
                            [ Value.Integer IntegerKind.Usize 24 ]
                            [ Ty.path "u8" ]
                        ],
                        "borrow_mut",
                        [],
                        []
                      |),
                      [
                        M.borrow (|
                          Pointer.Kind.MutRef,
                          M.deref (|
                            M.borrow (|
                              Pointer.Kind.MutRef,
                              M.SubPointer.get_struct_tuple_field (|
                                M.deref (| M.read (| self |) |),
                                "alloy_primitives::bits::function::Function",
                                0
                              |)
                            |)
                          |)
                        |)
                      ]
                    |)
                  |)
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::borrow::BorrowMut"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 24 ] [ Ty.path "u8" ] ]
          Self
          (* Instance *) [ ("borrow_mut", InstanceField.Method borrow_mut) ].
    End Impl_core_borrow_BorrowMut_array_Usize_24_u8_for_alloy_primitives_bits_function_Function.
    
    Module Impl_core_borrow_BorrowMut_array_Usize_24_u8_for_ref_mut_alloy_primitives_bits_function_Function.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "&mut") [] [ Ty.path "alloy_primitives::bits::function::Function" ].
      
      (*
                  fn borrow_mut(&mut self) -> &mut $t {
                      $crate::private::BorrowMut::borrow_mut(&mut self.0)
                  }
      *)
      Definition borrow_mut (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.borrow (|
              Pointer.Kind.MutRef,
              M.deref (|
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.deref (|
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "&mut")
                        []
                        [
                          Ty.apply
                            (Ty.path "array")
                            [ Value.Integer IntegerKind.Usize 24 ]
                            [ Ty.path "u8" ]
                        ],
                      M.get_trait_method (|
                        "core::borrow::BorrowMut",
                        Ty.apply
                          (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                          [ Value.Integer IntegerKind.Usize 24 ]
                          [],
                        [],
                        [
                          Ty.apply
                            (Ty.path "array")
                            [ Value.Integer IntegerKind.Usize 24 ]
                            [ Ty.path "u8" ]
                        ],
                        "borrow_mut",
                        [],
                        []
                      |),
                      [
                        M.borrow (|
                          Pointer.Kind.MutRef,
                          M.deref (|
                            M.borrow (|
                              Pointer.Kind.MutRef,
                              M.SubPointer.get_struct_tuple_field (|
                                M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |),
                                "alloy_primitives::bits::function::Function",
                                0
                              |)
                            |)
                          |)
                        |)
                      ]
                    |)
                  |)
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::borrow::BorrowMut"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 24 ] [ Ty.path "u8" ] ]
          Self
          (* Instance *) [ ("borrow_mut", InstanceField.Method borrow_mut) ].
    End Impl_core_borrow_BorrowMut_array_Usize_24_u8_for_ref_mut_alloy_primitives_bits_function_Function.
    
    Module Impl_core_convert_From_ref__array_Usize_24_u8_for_ref__alloy_primitives_bits_function_Function.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "&") [] [ Ty.path "alloy_primitives::bits::function::Function" ].
      
      (*
                  fn from(value: $a) -> $b {
                      // SAFETY: guaranteed by caller
                      unsafe { $crate::private::core::mem::transmute::<$a, $b>(value) }
                  }
      *)
      Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            M.call_closure (|
              Ty.apply (Ty.path "&") [] [ Ty.path "alloy_primitives::bits::function::Function" ],
              M.get_function (|
                "core::intrinsics::transmute",
                [],
                [
                  Ty.apply
                    (Ty.path "&")
                    []
                    [
                      Ty.apply
                        (Ty.path "array")
                        [ Value.Integer IntegerKind.Usize 24 ]
                        [ Ty.path "u8" ]
                    ];
                  Ty.apply (Ty.path "&") [] [ Ty.path "alloy_primitives::bits::function::Function" ]
                ]
              |),
              [ M.read (| value |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [
            Ty.apply
              (Ty.path "&")
              []
              [ Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 24 ] [ Ty.path "u8" ] ]
          ]
          Self
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_ref__array_Usize_24_u8_for_ref__alloy_primitives_bits_function_Function.
    
    Module Impl_core_convert_From_ref_mut_array_Usize_24_u8_for_ref__alloy_primitives_bits_function_Function.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "&") [] [ Ty.path "alloy_primitives::bits::function::Function" ].
      
      (*
                  fn from(value: $a) -> $b {
                      // SAFETY: guaranteed by caller
                      unsafe { $crate::private::core::mem::transmute::<$a, $b>(value) }
                  }
      *)
      Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            M.call_closure (|
              Ty.apply (Ty.path "&") [] [ Ty.path "alloy_primitives::bits::function::Function" ],
              M.get_function (|
                "core::intrinsics::transmute",
                [],
                [
                  Ty.apply
                    (Ty.path "&mut")
                    []
                    [
                      Ty.apply
                        (Ty.path "array")
                        [ Value.Integer IntegerKind.Usize 24 ]
                        [ Ty.path "u8" ]
                    ];
                  Ty.apply (Ty.path "&") [] [ Ty.path "alloy_primitives::bits::function::Function" ]
                ]
              |),
              [ M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| value |) |) |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [
            Ty.apply
              (Ty.path "&mut")
              []
              [ Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 24 ] [ Ty.path "u8" ] ]
          ]
          Self
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_ref_mut_array_Usize_24_u8_for_ref__alloy_primitives_bits_function_Function.
    
    Module Impl_core_convert_From_ref_mut_array_Usize_24_u8_for_ref_mut_alloy_primitives_bits_function_Function.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "&mut") [] [ Ty.path "alloy_primitives::bits::function::Function" ].
      
      (*
                  fn from(value: $a) -> $b {
                      // SAFETY: guaranteed by caller
                      unsafe { $crate::private::core::mem::transmute::<$a, $b>(value) }
                  }
      *)
      Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            M.borrow (|
              Pointer.Kind.MutRef,
              M.deref (|
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.MutRef,
                      M.deref (|
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "&mut")
                            []
                            [ Ty.path "alloy_primitives::bits::function::Function" ],
                          M.get_function (|
                            "core::intrinsics::transmute",
                            [],
                            [
                              Ty.apply
                                (Ty.path "&mut")
                                []
                                [
                                  Ty.apply
                                    (Ty.path "array")
                                    [ Value.Integer IntegerKind.Usize 24 ]
                                    [ Ty.path "u8" ]
                                ];
                              Ty.apply
                                (Ty.path "&mut")
                                []
                                [ Ty.path "alloy_primitives::bits::function::Function" ]
                            ]
                          |),
                          [ M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| value |) |) |) ]
                        |)
                      |)
                    |)
                  |)
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [
            Ty.apply
              (Ty.path "&mut")
              []
              [ Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 24 ] [ Ty.path "u8" ] ]
          ]
          Self
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_ref_mut_array_Usize_24_u8_for_ref_mut_alloy_primitives_bits_function_Function.
    
    Module Impl_core_convert_From_ref__alloy_primitives_bits_function_Function_for_ref__array_Usize_24_u8.
      Definition Self : Ty.t :=
        Ty.apply
          (Ty.path "&")
          []
          [ Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 24 ] [ Ty.path "u8" ] ].
      
      (*
                  fn from(value: $a) -> $b {
                      // SAFETY: guaranteed by caller
                      unsafe { $crate::private::core::mem::transmute::<$a, $b>(value) }
                  }
      *)
      Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "&")
                []
                [ Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 24 ] [ Ty.path "u8" ]
                ],
              M.get_function (|
                "core::intrinsics::transmute",
                [],
                [
                  Ty.apply
                    (Ty.path "&")
                    []
                    [ Ty.path "alloy_primitives::bits::function::Function" ];
                  Ty.apply
                    (Ty.path "&")
                    []
                    [
                      Ty.apply
                        (Ty.path "array")
                        [ Value.Integer IntegerKind.Usize 24 ]
                        [ Ty.path "u8" ]
                    ]
                ]
              |),
              [ M.read (| value |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "&") [] [ Ty.path "alloy_primitives::bits::function::Function" ] ]
          Self
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_ref__alloy_primitives_bits_function_Function_for_ref__array_Usize_24_u8.
    
    Module Impl_core_convert_From_ref_mut_alloy_primitives_bits_function_Function_for_ref__array_Usize_24_u8.
      Definition Self : Ty.t :=
        Ty.apply
          (Ty.path "&")
          []
          [ Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 24 ] [ Ty.path "u8" ] ].
      
      (*
                  fn from(value: $a) -> $b {
                      // SAFETY: guaranteed by caller
                      unsafe { $crate::private::core::mem::transmute::<$a, $b>(value) }
                  }
      *)
      Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "&")
                []
                [ Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 24 ] [ Ty.path "u8" ]
                ],
              M.get_function (|
                "core::intrinsics::transmute",
                [],
                [
                  Ty.apply
                    (Ty.path "&mut")
                    []
                    [ Ty.path "alloy_primitives::bits::function::Function" ];
                  Ty.apply
                    (Ty.path "&")
                    []
                    [
                      Ty.apply
                        (Ty.path "array")
                        [ Value.Integer IntegerKind.Usize 24 ]
                        [ Ty.path "u8" ]
                    ]
                ]
              |),
              [ M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| value |) |) |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "&mut") [] [ Ty.path "alloy_primitives::bits::function::Function" ] ]
          Self
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_ref_mut_alloy_primitives_bits_function_Function_for_ref__array_Usize_24_u8.
    
    Module Impl_core_convert_From_ref_mut_alloy_primitives_bits_function_Function_for_ref_mut_array_Usize_24_u8.
      Definition Self : Ty.t :=
        Ty.apply
          (Ty.path "&mut")
          []
          [ Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 24 ] [ Ty.path "u8" ] ].
      
      (*
                  fn from(value: $a) -> $b {
                      // SAFETY: guaranteed by caller
                      unsafe { $crate::private::core::mem::transmute::<$a, $b>(value) }
                  }
      *)
      Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            M.borrow (|
              Pointer.Kind.MutRef,
              M.deref (|
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.MutRef,
                      M.deref (|
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "&mut")
                            []
                            [
                              Ty.apply
                                (Ty.path "array")
                                [ Value.Integer IntegerKind.Usize 24 ]
                                [ Ty.path "u8" ]
                            ],
                          M.get_function (|
                            "core::intrinsics::transmute",
                            [],
                            [
                              Ty.apply
                                (Ty.path "&mut")
                                []
                                [ Ty.path "alloy_primitives::bits::function::Function" ];
                              Ty.apply
                                (Ty.path "&mut")
                                []
                                [
                                  Ty.apply
                                    (Ty.path "array")
                                    [ Value.Integer IntegerKind.Usize 24 ]
                                    [ Ty.path "u8" ]
                                ]
                            ]
                          |),
                          [ M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| value |) |) |) ]
                        |)
                      |)
                    |)
                  |)
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "&mut") [] [ Ty.path "alloy_primitives::bits::function::Function" ] ]
          Self
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_ref_mut_alloy_primitives_bits_function_Function_for_ref_mut_array_Usize_24_u8.
    
    Module Impl_core_cmp_PartialEq_slice_u8_for_alloy_primitives_bits_function_Function.
      Definition Self : Ty.t := Ty.path "alloy_primitives::bits::function::Function".
      
      (*
                  fn $fn(&self, other: &$a) -> $ret {
                      $crate::private::$tr::$fn(&self.0 $([$e])?, other)
                  }
      *)
      Definition eq (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              Ty.path "bool",
              M.get_trait_method (|
                "core::cmp::PartialEq",
                Ty.apply
                  (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                  [ Value.Integer IntegerKind.Usize 24 ]
                  [],
                [],
                [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                "eq",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_tuple_field (|
                        M.deref (| M.read (| self |) |),
                        "alloy_primitives::bits::function::Function",
                        0
                      |)
                    |)
                  |)
                |);
                M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| other |) |) |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::cmp::PartialEq"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
          Self
          (* Instance *) [ ("eq", InstanceField.Method eq) ].
    End Impl_core_cmp_PartialEq_slice_u8_for_alloy_primitives_bits_function_Function.
    
    Module Impl_core_cmp_PartialEq_alloy_primitives_bits_function_Function_for_slice_u8.
      Definition Self : Ty.t := Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ].
      
      (*
                  fn $fn(&self, other: &$b) -> $ret {
                      $crate::private::$tr::$fn(self, &other.0 $([$e])?)
                  }
      *)
      Definition eq (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              Ty.path "bool",
              M.get_trait_method (|
                "core::cmp::PartialEq",
                Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                [],
                [
                  Ty.apply
                    (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                    [ Value.Integer IntegerKind.Usize 24 ]
                    []
                ],
                "eq",
                [],
                []
              |),
              [
                M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |);
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_tuple_field (|
                        M.deref (| M.read (| other |) |),
                        "alloy_primitives::bits::function::Function",
                        0
                      |)
                    |)
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::cmp::PartialEq"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "alloy_primitives::bits::function::Function" ]
          Self
          (* Instance *) [ ("eq", InstanceField.Method eq) ].
    End Impl_core_cmp_PartialEq_alloy_primitives_bits_function_Function_for_slice_u8.
    
    Module Impl_core_cmp_PartialEq_ref__slice_u8_for_alloy_primitives_bits_function_Function.
      Definition Self : Ty.t := Ty.path "alloy_primitives::bits::function::Function".
      
      (*
                  fn $fn(&self, other: &&$a) -> $ret {
                      $crate::private::$tr::$fn(&self.0 $([$e])?, *other)
                  }
      *)
      Definition eq (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              Ty.path "bool",
              M.get_trait_method (|
                "core::cmp::PartialEq",
                Ty.apply
                  (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                  [ Value.Integer IntegerKind.Usize 24 ]
                  [],
                [],
                [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                "eq",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_tuple_field (|
                        M.deref (| M.read (| self |) |),
                        "alloy_primitives::bits::function::Function",
                        0
                      |)
                    |)
                  |)
                |);
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (| M.read (| M.deref (| M.read (| other |) |) |) |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::cmp::PartialEq"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ] ]
          Self
          (* Instance *) [ ("eq", InstanceField.Method eq) ].
    End Impl_core_cmp_PartialEq_ref__slice_u8_for_alloy_primitives_bits_function_Function.
    
    Module Impl_core_cmp_PartialEq_alloy_primitives_bits_function_Function_for_ref__slice_u8.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ].
      
      (*
                  fn $fn(&self, other: &$b) -> $ret {
                      $crate::private::$tr::$fn( *self, &other.0 $([$e])?)
                  }
      *)
      Definition eq (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              Ty.path "bool",
              M.get_trait_method (|
                "core::cmp::PartialEq",
                Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                [],
                [
                  Ty.apply
                    (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                    [ Value.Integer IntegerKind.Usize 24 ]
                    []
                ],
                "eq",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
                |);
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_tuple_field (|
                        M.deref (| M.read (| other |) |),
                        "alloy_primitives::bits::function::Function",
                        0
                      |)
                    |)
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::cmp::PartialEq"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "alloy_primitives::bits::function::Function" ]
          Self
          (* Instance *) [ ("eq", InstanceField.Method eq) ].
    End Impl_core_cmp_PartialEq_alloy_primitives_bits_function_Function_for_ref__slice_u8.
    
    Module Impl_core_cmp_PartialEq_slice_u8_for_ref__alloy_primitives_bits_function_Function.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "&") [] [ Ty.path "alloy_primitives::bits::function::Function" ].
      
      (*
                  fn $fn(&self, other: &$a) -> $ret {
                      $crate::private::$tr::$fn(&self.0 $([$e])?, other)
                  }
      *)
      Definition eq (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              Ty.path "bool",
              M.get_trait_method (|
                "core::cmp::PartialEq",
                Ty.apply
                  (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                  [ Value.Integer IntegerKind.Usize 24 ]
                  [],
                [],
                [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                "eq",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_tuple_field (|
                        M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |),
                        "alloy_primitives::bits::function::Function",
                        0
                      |)
                    |)
                  |)
                |);
                M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| other |) |) |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::cmp::PartialEq"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
          Self
          (* Instance *) [ ("eq", InstanceField.Method eq) ].
    End Impl_core_cmp_PartialEq_slice_u8_for_ref__alloy_primitives_bits_function_Function.
    
    Module Impl_core_cmp_PartialEq_ref__alloy_primitives_bits_function_Function_for_slice_u8.
      Definition Self : Ty.t := Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ].
      
      (*
                  fn $fn(&self, other: &&$b) -> $ret {
                      $crate::private::$tr::$fn(self, &other.0 $([$e])?)
                  }
      *)
      Definition eq (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              Ty.path "bool",
              M.get_trait_method (|
                "core::cmp::PartialEq",
                Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                [],
                [
                  Ty.apply
                    (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                    [ Value.Integer IntegerKind.Usize 24 ]
                    []
                ],
                "eq",
                [],
                []
              |),
              [
                M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |);
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_tuple_field (|
                        M.deref (| M.read (| M.deref (| M.read (| other |) |) |) |),
                        "alloy_primitives::bits::function::Function",
                        0
                      |)
                    |)
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::cmp::PartialEq"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "&") [] [ Ty.path "alloy_primitives::bits::function::Function" ] ]
          Self
          (* Instance *) [ ("eq", InstanceField.Method eq) ].
    End Impl_core_cmp_PartialEq_ref__alloy_primitives_bits_function_Function_for_slice_u8.
    
    Module Impl_core_cmp_PartialEq_array_Usize_24_u8_for_alloy_primitives_bits_function_Function.
      Definition Self : Ty.t := Ty.path "alloy_primitives::bits::function::Function".
      
      (*
                  fn $fn(&self, other: &$a) -> $ret {
                      $crate::private::$tr::$fn(&self.0 $([$e])?, other)
                  }
      *)
      Definition eq (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              Ty.path "bool",
              M.get_trait_method (|
                "core::cmp::PartialEq",
                Ty.apply
                  (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                  [ Value.Integer IntegerKind.Usize 24 ]
                  [],
                [],
                [ Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 24 ] [ Ty.path "u8" ]
                ],
                "eq",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_tuple_field (|
                        M.deref (| M.read (| self |) |),
                        "alloy_primitives::bits::function::Function",
                        0
                      |)
                    |)
                  |)
                |);
                M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| other |) |) |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::cmp::PartialEq"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 24 ] [ Ty.path "u8" ] ]
          Self
          (* Instance *) [ ("eq", InstanceField.Method eq) ].
    End Impl_core_cmp_PartialEq_array_Usize_24_u8_for_alloy_primitives_bits_function_Function.
    
    Module Impl_core_cmp_PartialEq_alloy_primitives_bits_function_Function_for_array_Usize_24_u8.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 24 ] [ Ty.path "u8" ].
      
      (*
                  fn $fn(&self, other: &$b) -> $ret {
                      $crate::private::$tr::$fn(self, &other.0 $([$e])?)
                  }
      *)
      Definition eq (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              Ty.path "bool",
              M.get_trait_method (|
                "core::cmp::PartialEq",
                Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 24 ] [ Ty.path "u8" ],
                [],
                [
                  Ty.apply
                    (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                    [ Value.Integer IntegerKind.Usize 24 ]
                    []
                ],
                "eq",
                [],
                []
              |),
              [
                M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |);
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_tuple_field (|
                        M.deref (| M.read (| other |) |),
                        "alloy_primitives::bits::function::Function",
                        0
                      |)
                    |)
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::cmp::PartialEq"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "alloy_primitives::bits::function::Function" ]
          Self
          (* Instance *) [ ("eq", InstanceField.Method eq) ].
    End Impl_core_cmp_PartialEq_alloy_primitives_bits_function_Function_for_array_Usize_24_u8.
    
    Module Impl_core_cmp_PartialEq_ref__array_Usize_24_u8_for_alloy_primitives_bits_function_Function.
      Definition Self : Ty.t := Ty.path "alloy_primitives::bits::function::Function".
      
      (*
                  fn $fn(&self, other: &&$a) -> $ret {
                      $crate::private::$tr::$fn(&self.0 $([$e])?, *other)
                  }
      *)
      Definition eq (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              Ty.path "bool",
              M.get_trait_method (|
                "core::cmp::PartialEq",
                Ty.apply
                  (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                  [ Value.Integer IntegerKind.Usize 24 ]
                  [],
                [],
                [ Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 24 ] [ Ty.path "u8" ]
                ],
                "eq",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_tuple_field (|
                        M.deref (| M.read (| self |) |),
                        "alloy_primitives::bits::function::Function",
                        0
                      |)
                    |)
                  |)
                |);
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (| M.read (| M.deref (| M.read (| other |) |) |) |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::cmp::PartialEq"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [
            Ty.apply
              (Ty.path "&")
              []
              [ Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 24 ] [ Ty.path "u8" ] ]
          ]
          Self
          (* Instance *) [ ("eq", InstanceField.Method eq) ].
    End Impl_core_cmp_PartialEq_ref__array_Usize_24_u8_for_alloy_primitives_bits_function_Function.
    
    Module Impl_core_cmp_PartialEq_alloy_primitives_bits_function_Function_for_ref__array_Usize_24_u8.
      Definition Self : Ty.t :=
        Ty.apply
          (Ty.path "&")
          []
          [ Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 24 ] [ Ty.path "u8" ] ].
      
      (*
                  fn $fn(&self, other: &$b) -> $ret {
                      $crate::private::$tr::$fn( *self, &other.0 $([$e])?)
                  }
      *)
      Definition eq (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              Ty.path "bool",
              M.get_trait_method (|
                "core::cmp::PartialEq",
                Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 24 ] [ Ty.path "u8" ],
                [],
                [
                  Ty.apply
                    (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                    [ Value.Integer IntegerKind.Usize 24 ]
                    []
                ],
                "eq",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
                |);
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_tuple_field (|
                        M.deref (| M.read (| other |) |),
                        "alloy_primitives::bits::function::Function",
                        0
                      |)
                    |)
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::cmp::PartialEq"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "alloy_primitives::bits::function::Function" ]
          Self
          (* Instance *) [ ("eq", InstanceField.Method eq) ].
    End Impl_core_cmp_PartialEq_alloy_primitives_bits_function_Function_for_ref__array_Usize_24_u8.
    
    Module Impl_core_cmp_PartialEq_array_Usize_24_u8_for_ref__alloy_primitives_bits_function_Function.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "&") [] [ Ty.path "alloy_primitives::bits::function::Function" ].
      
      (*
                  fn $fn(&self, other: &$a) -> $ret {
                      $crate::private::$tr::$fn(&self.0 $([$e])?, other)
                  }
      *)
      Definition eq (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              Ty.path "bool",
              M.get_trait_method (|
                "core::cmp::PartialEq",
                Ty.apply
                  (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                  [ Value.Integer IntegerKind.Usize 24 ]
                  [],
                [],
                [ Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 24 ] [ Ty.path "u8" ]
                ],
                "eq",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_tuple_field (|
                        M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |),
                        "alloy_primitives::bits::function::Function",
                        0
                      |)
                    |)
                  |)
                |);
                M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| other |) |) |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::cmp::PartialEq"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 24 ] [ Ty.path "u8" ] ]
          Self
          (* Instance *) [ ("eq", InstanceField.Method eq) ].
    End Impl_core_cmp_PartialEq_array_Usize_24_u8_for_ref__alloy_primitives_bits_function_Function.
    
    Module Impl_core_cmp_PartialEq_ref__alloy_primitives_bits_function_Function_for_array_Usize_24_u8.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 24 ] [ Ty.path "u8" ].
      
      (*
                  fn $fn(&self, other: &&$b) -> $ret {
                      $crate::private::$tr::$fn(self, &other.0 $([$e])?)
                  }
      *)
      Definition eq (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              Ty.path "bool",
              M.get_trait_method (|
                "core::cmp::PartialEq",
                Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 24 ] [ Ty.path "u8" ],
                [],
                [
                  Ty.apply
                    (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                    [ Value.Integer IntegerKind.Usize 24 ]
                    []
                ],
                "eq",
                [],
                []
              |),
              [
                M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |);
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_tuple_field (|
                        M.deref (| M.read (| M.deref (| M.read (| other |) |) |) |),
                        "alloy_primitives::bits::function::Function",
                        0
                      |)
                    |)
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::cmp::PartialEq"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "&") [] [ Ty.path "alloy_primitives::bits::function::Function" ] ]
          Self
          (* Instance *) [ ("eq", InstanceField.Method eq) ].
    End Impl_core_cmp_PartialEq_ref__alloy_primitives_bits_function_Function_for_array_Usize_24_u8.
    
    Module Impl_core_cmp_PartialOrd_slice_u8_for_alloy_primitives_bits_function_Function.
      Definition Self : Ty.t := Ty.path "alloy_primitives::bits::function::Function".
      
      (*
                  fn $fn(&self, other: &$a) -> $ret {
                      $crate::private::$tr::$fn(&self.0 $([$e])?, other)
                  }
      *)
      Definition partial_cmp (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "core::cmp::Ordering" ],
              M.get_trait_method (|
                "core::cmp::PartialOrd",
                Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                [],
                [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                "partial_cmp",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "&")
                            []
                            [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                          M.get_trait_method (|
                            "core::ops::index::Index",
                            Ty.apply
                              (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                              [ Value.Integer IntegerKind.Usize 24 ]
                              [],
                            [],
                            [ Ty.path "core::ops::range::RangeFull" ],
                            "index",
                            [],
                            []
                          |),
                          [
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.SubPointer.get_struct_tuple_field (|
                                M.deref (| M.read (| self |) |),
                                "alloy_primitives::bits::function::Function",
                                0
                              |)
                            |);
                            Value.StructTuple "core::ops::range::RangeFull" []
                          ]
                        |)
                      |)
                    |)
                  |)
                |);
                M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| other |) |) |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::cmp::PartialOrd"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
          Self
          (* Instance *) [ ("partial_cmp", InstanceField.Method partial_cmp) ].
    End Impl_core_cmp_PartialOrd_slice_u8_for_alloy_primitives_bits_function_Function.
    
    Module Impl_core_cmp_PartialOrd_alloy_primitives_bits_function_Function_for_slice_u8.
      Definition Self : Ty.t := Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ].
      
      (*
                  fn $fn(&self, other: &$b) -> $ret {
                      $crate::private::$tr::$fn(self, &other.0 $([$e])?)
                  }
      *)
      Definition partial_cmp (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "core::cmp::Ordering" ],
              M.get_trait_method (|
                "core::cmp::PartialOrd",
                Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                [],
                [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                "partial_cmp",
                [],
                []
              |),
              [
                M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |);
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "&")
                            []
                            [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                          M.get_trait_method (|
                            "core::ops::index::Index",
                            Ty.apply
                              (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                              [ Value.Integer IntegerKind.Usize 24 ]
                              [],
                            [],
                            [ Ty.path "core::ops::range::RangeFull" ],
                            "index",
                            [],
                            []
                          |),
                          [
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.SubPointer.get_struct_tuple_field (|
                                M.deref (| M.read (| other |) |),
                                "alloy_primitives::bits::function::Function",
                                0
                              |)
                            |);
                            Value.StructTuple "core::ops::range::RangeFull" []
                          ]
                        |)
                      |)
                    |)
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::cmp::PartialOrd"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "alloy_primitives::bits::function::Function" ]
          Self
          (* Instance *) [ ("partial_cmp", InstanceField.Method partial_cmp) ].
    End Impl_core_cmp_PartialOrd_alloy_primitives_bits_function_Function_for_slice_u8.
    
    Module Impl_core_cmp_PartialOrd_ref__slice_u8_for_alloy_primitives_bits_function_Function.
      Definition Self : Ty.t := Ty.path "alloy_primitives::bits::function::Function".
      
      (*
                  fn $fn(&self, other: &&$a) -> $ret {
                      $crate::private::$tr::$fn(&self.0 $([$e])?, *other)
                  }
      *)
      Definition partial_cmp (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "core::cmp::Ordering" ],
              M.get_trait_method (|
                "core::cmp::PartialOrd",
                Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                [],
                [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                "partial_cmp",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "&")
                            []
                            [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                          M.get_trait_method (|
                            "core::ops::index::Index",
                            Ty.apply
                              (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                              [ Value.Integer IntegerKind.Usize 24 ]
                              [],
                            [],
                            [ Ty.path "core::ops::range::RangeFull" ],
                            "index",
                            [],
                            []
                          |),
                          [
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.SubPointer.get_struct_tuple_field (|
                                M.deref (| M.read (| self |) |),
                                "alloy_primitives::bits::function::Function",
                                0
                              |)
                            |);
                            Value.StructTuple "core::ops::range::RangeFull" []
                          ]
                        |)
                      |)
                    |)
                  |)
                |);
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (| M.read (| M.deref (| M.read (| other |) |) |) |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::cmp::PartialOrd"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ] ]
          Self
          (* Instance *) [ ("partial_cmp", InstanceField.Method partial_cmp) ].
    End Impl_core_cmp_PartialOrd_ref__slice_u8_for_alloy_primitives_bits_function_Function.
    
    Module Impl_core_cmp_PartialOrd_alloy_primitives_bits_function_Function_for_ref__slice_u8.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ].
      
      (*
                  fn $fn(&self, other: &$b) -> $ret {
                      $crate::private::$tr::$fn( *self, &other.0 $([$e])?)
                  }
      *)
      Definition partial_cmp (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "core::cmp::Ordering" ],
              M.get_trait_method (|
                "core::cmp::PartialOrd",
                Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                [],
                [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                "partial_cmp",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
                |);
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "&")
                            []
                            [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                          M.get_trait_method (|
                            "core::ops::index::Index",
                            Ty.apply
                              (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                              [ Value.Integer IntegerKind.Usize 24 ]
                              [],
                            [],
                            [ Ty.path "core::ops::range::RangeFull" ],
                            "index",
                            [],
                            []
                          |),
                          [
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.SubPointer.get_struct_tuple_field (|
                                M.deref (| M.read (| other |) |),
                                "alloy_primitives::bits::function::Function",
                                0
                              |)
                            |);
                            Value.StructTuple "core::ops::range::RangeFull" []
                          ]
                        |)
                      |)
                    |)
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::cmp::PartialOrd"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "alloy_primitives::bits::function::Function" ]
          Self
          (* Instance *) [ ("partial_cmp", InstanceField.Method partial_cmp) ].
    End Impl_core_cmp_PartialOrd_alloy_primitives_bits_function_Function_for_ref__slice_u8.
    
    Module Impl_core_cmp_PartialOrd_slice_u8_for_ref__alloy_primitives_bits_function_Function.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "&") [] [ Ty.path "alloy_primitives::bits::function::Function" ].
      
      (*
                  fn $fn(&self, other: &$a) -> $ret {
                      $crate::private::$tr::$fn(&self.0 $([$e])?, other)
                  }
      *)
      Definition partial_cmp (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "core::cmp::Ordering" ],
              M.get_trait_method (|
                "core::cmp::PartialOrd",
                Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                [],
                [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                "partial_cmp",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "&")
                            []
                            [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                          M.get_trait_method (|
                            "core::ops::index::Index",
                            Ty.apply
                              (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                              [ Value.Integer IntegerKind.Usize 24 ]
                              [],
                            [],
                            [ Ty.path "core::ops::range::RangeFull" ],
                            "index",
                            [],
                            []
                          |),
                          [
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.SubPointer.get_struct_tuple_field (|
                                M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |),
                                "alloy_primitives::bits::function::Function",
                                0
                              |)
                            |);
                            Value.StructTuple "core::ops::range::RangeFull" []
                          ]
                        |)
                      |)
                    |)
                  |)
                |);
                M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| other |) |) |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::cmp::PartialOrd"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
          Self
          (* Instance *) [ ("partial_cmp", InstanceField.Method partial_cmp) ].
    End Impl_core_cmp_PartialOrd_slice_u8_for_ref__alloy_primitives_bits_function_Function.
    
    Module Impl_core_cmp_PartialOrd_ref__alloy_primitives_bits_function_Function_for_slice_u8.
      Definition Self : Ty.t := Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ].
      
      (*
                  fn $fn(&self, other: &&$b) -> $ret {
                      $crate::private::$tr::$fn(self, &other.0 $([$e])?)
                  }
      *)
      Definition partial_cmp (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "core::cmp::Ordering" ],
              M.get_trait_method (|
                "core::cmp::PartialOrd",
                Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                [],
                [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                "partial_cmp",
                [],
                []
              |),
              [
                M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |);
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "&")
                            []
                            [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                          M.get_trait_method (|
                            "core::ops::index::Index",
                            Ty.apply
                              (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                              [ Value.Integer IntegerKind.Usize 24 ]
                              [],
                            [],
                            [ Ty.path "core::ops::range::RangeFull" ],
                            "index",
                            [],
                            []
                          |),
                          [
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.SubPointer.get_struct_tuple_field (|
                                M.deref (| M.read (| M.deref (| M.read (| other |) |) |) |),
                                "alloy_primitives::bits::function::Function",
                                0
                              |)
                            |);
                            Value.StructTuple "core::ops::range::RangeFull" []
                          ]
                        |)
                      |)
                    |)
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::cmp::PartialOrd"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "&") [] [ Ty.path "alloy_primitives::bits::function::Function" ] ]
          Self
          (* Instance *) [ ("partial_cmp", InstanceField.Method partial_cmp) ].
    End Impl_core_cmp_PartialOrd_ref__alloy_primitives_bits_function_Function_for_slice_u8.
    
    Module Impl_const_hex_traits_FromHex_for_alloy_primitives_bits_function_Function.
      Definition Self : Ty.t := Ty.path "alloy_primitives::bits::function::Function".
      
      (*             type Error = $crate::hex::FromHexError; *)
      Definition _Error : Ty.t := Ty.path "const_hex::error::FromHexError".
      
      (*
                  fn from_hex<T: $crate::private::AsRef<[u8]>>(hex: T) -> Result<Self, Self::Error> {
                      $crate::hex::decode_to_array(hex).map(Self::new)
                  }
      *)
      Definition from_hex (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [ T ], [ hex ] =>
          ltac:(M.monadic
            (let hex := M.alloc (| hex |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "core::result::Result")
                []
                [
                  Ty.path "alloy_primitives::bits::function::Function";
                  Ty.path "const_hex::error::FromHexError"
                ],
              M.get_associated_function (|
                Ty.apply
                  (Ty.path "core::result::Result")
                  []
                  [
                    Ty.apply
                      (Ty.path "array")
                      [ Value.Integer IntegerKind.Usize 24 ]
                      [ Ty.path "u8" ];
                    Ty.path "const_hex::error::FromHexError"
                  ],
                "map",
                [],
                [
                  Ty.path "alloy_primitives::bits::function::Function";
                  Ty.function
                    [
                      Ty.apply
                        (Ty.path "array")
                        [ Value.Integer IntegerKind.Usize 24 ]
                        [ Ty.path "u8" ]
                    ]
                    (Ty.path "alloy_primitives::bits::function::Function")
                ]
              |),
              [
                M.call_closure (|
                  Ty.apply
                    (Ty.path "core::result::Result")
                    []
                    [
                      Ty.apply
                        (Ty.path "array")
                        [ Value.Integer IntegerKind.Usize 24 ]
                        [ Ty.path "u8" ];
                      Ty.path "const_hex::error::FromHexError"
                    ],
                  M.get_function (|
                    "const_hex::decode_to_array",
                    [ Value.Integer IntegerKind.Usize 24 ],
                    [ T ]
                  |),
                  [ M.read (| hex |) ]
                |);
                M.get_associated_function (|
                  Ty.path "alloy_primitives::bits::function::Function",
                  "new",
                  [],
                  []
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "const_hex::traits::FromHex"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *)
          [ ("Error", InstanceField.Ty _Error); ("from_hex", InstanceField.Method from_hex) ].
    End Impl_const_hex_traits_FromHex_for_alloy_primitives_bits_function_Function.
    
    Module Impl_alloy_primitives_bits_function_Function.
      Definition Self : Ty.t := Ty.path "alloy_primitives::bits::function::Function".
      
      (*             pub const ZERO: Self = Self($crate::FixedBytes::ZERO); *)
      (* Ty.path "alloy_primitives::bits::function::Function" *)
      Definition value_ZERO (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple
              "alloy_primitives::bits::function::Function"
              [
                M.read (|
                  get_associated_constant (|
                    Ty.apply
                      (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                      [ Value.Integer IntegerKind.Usize 24 ]
                      [],
                    "ZERO",
                    Ty.apply
                      (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                      [ Value.Integer IntegerKind.Usize 24 ]
                      []
                  |)
                |)
              ]
          |))).
      
      Global Instance AssociatedConstant_value_ZERO :
        M.IsAssociatedFunction.C Self "ZERO" value_ZERO.
      Admitted.
      Global Typeclasses Opaque value_ZERO.
      
      (*
                  pub const fn new(bytes: [u8; $n]) -> Self {
                      Self($crate::FixedBytes(bytes))
                  }
      *)
      Definition new (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ bytes ] =>
          ltac:(M.monadic
            (let bytes := M.alloc (| bytes |) in
            Value.StructTuple
              "alloy_primitives::bits::function::Function"
              [ Value.StructTuple "alloy_primitives::bits::fixed::FixedBytes" [ M.read (| bytes |) ]
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_new : M.IsAssociatedFunction.C Self "new" new.
      Admitted.
      Global Typeclasses Opaque new.
      
      (*
                  pub const fn with_last_byte(x: u8) -> Self {
                      Self($crate::FixedBytes::with_last_byte(x))
                  }
      *)
      Definition with_last_byte (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ x ] =>
          ltac:(M.monadic
            (let x := M.alloc (| x |) in
            Value.StructTuple
              "alloy_primitives::bits::function::Function"
              [
                M.call_closure (|
                  Ty.apply
                    (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                    [ Value.Integer IntegerKind.Usize 24 ]
                    [],
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                      [ Value.Integer IntegerKind.Usize 24 ]
                      [],
                    "with_last_byte",
                    [],
                    []
                  |),
                  [ M.read (| x |) ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_with_last_byte :
        M.IsAssociatedFunction.C Self "with_last_byte" with_last_byte.
      Admitted.
      Global Typeclasses Opaque with_last_byte.
      
      (*
                  pub const fn repeat_byte(byte: u8) -> Self {
                      Self($crate::FixedBytes::repeat_byte(byte))
                  }
      *)
      Definition repeat_byte (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ byte ] =>
          ltac:(M.monadic
            (let byte := M.alloc (| byte |) in
            Value.StructTuple
              "alloy_primitives::bits::function::Function"
              [
                M.call_closure (|
                  Ty.apply
                    (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                    [ Value.Integer IntegerKind.Usize 24 ]
                    [],
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                      [ Value.Integer IntegerKind.Usize 24 ]
                      [],
                    "repeat_byte",
                    [],
                    []
                  |),
                  [ M.read (| byte |) ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_repeat_byte :
        M.IsAssociatedFunction.C Self "repeat_byte" repeat_byte.
      Admitted.
      Global Typeclasses Opaque repeat_byte.
      
      (*
                  pub const fn len_bytes() -> usize {
                      $n
                  }
      *)
      Definition len_bytes (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [] => ltac:(M.monadic (Value.Integer IntegerKind.Usize 24))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_len_bytes :
        M.IsAssociatedFunction.C Self "len_bytes" len_bytes.
      Admitted.
      Global Typeclasses Opaque len_bytes.
      
      (*
                  pub fn from_slice(src: &[u8]) -> Self {
                      match Self::try_from(src) {
                          Ok(x) => x,
                          Err(_) => panic!("cannot convert a slice of length {} to {}", src.len(), stringify!($name)),
                      }
                  }
      *)
      Definition from_slice (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ src ] =>
          ltac:(M.monadic
            (let src := M.alloc (| src |) in
            M.read (|
              M.match_operator (|
                Some (Ty.path "alloy_primitives::bits::function::Function"),
                M.alloc (|
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "core::result::Result")
                      []
                      [
                        Ty.path "alloy_primitives::bits::function::Function";
                        Ty.path "core::array::TryFromSliceError"
                      ],
                    M.get_trait_method (|
                      "core::convert::TryFrom",
                      Ty.path "alloy_primitives::bits::function::Function",
                      [],
                      [ Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
                      ],
                      "try_from",
                      [],
                      []
                    |),
                    [ M.read (| src |) ]
                  |)
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::result::Result::Ok",
                          0
                        |) in
                      let x := M.copy (| γ0_0 |) in
                      x));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::result::Result::Err",
                          0
                        |) in
                      M.alloc (|
                        M.never_to_any (|
                          M.call_closure (|
                            Ty.path "never",
                            M.get_function (| "core::panicking::panic_fmt", [], [] |),
                            [
                              M.call_closure (|
                                Ty.path "core::fmt::Arguments",
                                M.get_associated_function (|
                                  Ty.path "core::fmt::Arguments",
                                  "new_v1",
                                  [
                                    Value.Integer IntegerKind.Usize 2;
                                    Value.Integer IntegerKind.Usize 1
                                  ],
                                  []
                                |),
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (|
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.alloc (|
                                          Value.Array
                                            [
                                              mk_str (| "cannot convert a slice of length " |);
                                              mk_str (| " to Function" |)
                                            ]
                                        |)
                                      |)
                                    |)
                                  |);
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (|
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.alloc (|
                                          Value.Array
                                            [
                                              M.call_closure (|
                                                Ty.path "core::fmt::rt::Argument",
                                                M.get_associated_function (|
                                                  Ty.path "core::fmt::rt::Argument",
                                                  "new_display",
                                                  [],
                                                  [ Ty.path "usize" ]
                                                |),
                                                [
                                                  M.borrow (|
                                                    Pointer.Kind.Ref,
                                                    M.deref (|
                                                      M.borrow (|
                                                        Pointer.Kind.Ref,
                                                        M.alloc (|
                                                          M.call_closure (|
                                                            Ty.path "usize",
                                                            M.get_associated_function (|
                                                              Ty.apply
                                                                (Ty.path "slice")
                                                                []
                                                                [ Ty.path "u8" ],
                                                              "len",
                                                              [],
                                                              []
                                                            |),
                                                            [
                                                              M.borrow (|
                                                                Pointer.Kind.Ref,
                                                                M.deref (| M.read (| src |) |)
                                                              |)
                                                            ]
                                                          |)
                                                        |)
                                                      |)
                                                    |)
                                                  |)
                                                ]
                                              |)
                                            ]
                                        |)
                                      |)
                                    |)
                                  |)
                                ]
                              |)
                            ]
                          |)
                        |)
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_from_slice :
        M.IsAssociatedFunction.C Self "from_slice" from_slice.
      Admitted.
      Global Typeclasses Opaque from_slice.
      
      (*
                  pub fn left_padding_from(value: &[u8]) -> Self {
                      Self($crate::FixedBytes::left_padding_from(value))
                  }
      *)
      Definition left_padding_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            Value.StructTuple
              "alloy_primitives::bits::function::Function"
              [
                M.call_closure (|
                  Ty.apply
                    (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                    [ Value.Integer IntegerKind.Usize 24 ]
                    [],
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                      [ Value.Integer IntegerKind.Usize 24 ]
                      [],
                    "left_padding_from",
                    [],
                    []
                  |),
                  [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| value |) |) |) ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_left_padding_from :
        M.IsAssociatedFunction.C Self "left_padding_from" left_padding_from.
      Admitted.
      Global Typeclasses Opaque left_padding_from.
      
      (*
                  pub fn right_padding_from(value: &[u8]) -> Self {
                      Self($crate::FixedBytes::right_padding_from(value))
                  }
      *)
      Definition right_padding_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            Value.StructTuple
              "alloy_primitives::bits::function::Function"
              [
                M.call_closure (|
                  Ty.apply
                    (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                    [ Value.Integer IntegerKind.Usize 24 ]
                    [],
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                      [ Value.Integer IntegerKind.Usize 24 ]
                      [],
                    "right_padding_from",
                    [],
                    []
                  |),
                  [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| value |) |) |) ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_right_padding_from :
        M.IsAssociatedFunction.C Self "right_padding_from" right_padding_from.
      Admitted.
      Global Typeclasses Opaque right_padding_from.
      
      (*
                  pub const fn into_array(self) -> [u8; $n] {
                      self.0 .0
                  }
      *)
      Definition into_array (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.SubPointer.get_struct_tuple_field (|
                M.SubPointer.get_struct_tuple_field (|
                  self,
                  "alloy_primitives::bits::function::Function",
                  0
                |),
                "alloy_primitives::bits::fixed::FixedBytes",
                0
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_into_array :
        M.IsAssociatedFunction.C Self "into_array" into_array.
      Admitted.
      Global Typeclasses Opaque into_array.
      
      (*
                  pub fn covers(&self, b: &Self) -> bool {
                      &( *b & *self) == b
                  }
      *)
      Definition covers (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; b ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let b := M.alloc (| b |) in
            M.call_closure (|
              Ty.path "bool",
              M.get_trait_method (|
                "core::cmp::PartialEq",
                Ty.apply (Ty.path "&") [] [ Ty.path "alloy_primitives::bits::function::Function" ],
                [],
                [ Ty.apply (Ty.path "&") [] [ Ty.path "alloy_primitives::bits::function::Function" ]
                ],
                "eq",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.alloc (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.alloc (|
                        M.call_closure (|
                          Ty.path "alloy_primitives::bits::function::Function",
                          M.get_trait_method (|
                            "core::ops::bit::BitAnd",
                            Ty.path "alloy_primitives::bits::function::Function",
                            [],
                            [ Ty.path "alloy_primitives::bits::function::Function" ],
                            "bitand",
                            [],
                            []
                          |),
                          [
                            M.read (| M.deref (| M.read (| b |) |) |);
                            M.read (| M.deref (| M.read (| self |) |) |)
                          ]
                        |)
                      |)
                    |)
                  |)
                |);
                M.borrow (| Pointer.Kind.Ref, b |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_covers : M.IsAssociatedFunction.C Self "covers" covers.
      Admitted.
      Global Typeclasses Opaque covers.
      
      (*
                  pub const fn const_eq(&self, other: &Self) -> bool {
                      self.0.const_eq(&other.0)
                  }
      *)
      Definition const_eq (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              Ty.path "bool",
              M.get_associated_function (|
                Ty.apply
                  (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                  [ Value.Integer IntegerKind.Usize 24 ]
                  [],
                "const_eq",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.SubPointer.get_struct_tuple_field (|
                    M.deref (| M.read (| self |) |),
                    "alloy_primitives::bits::function::Function",
                    0
                  |)
                |);
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_tuple_field (|
                        M.deref (| M.read (| other |) |),
                        "alloy_primitives::bits::function::Function",
                        0
                      |)
                    |)
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_const_eq :
        M.IsAssociatedFunction.C Self "const_eq" const_eq.
      Admitted.
      Global Typeclasses Opaque const_eq.
      
      (*
                  pub const fn bit_and(self, rhs: Self) -> Self {
                      Self(self.0.bit_and(rhs.0))
                  }
      *)
      Definition bit_and (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            Value.StructTuple
              "alloy_primitives::bits::function::Function"
              [
                M.call_closure (|
                  Ty.apply
                    (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                    [ Value.Integer IntegerKind.Usize 24 ]
                    [],
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                      [ Value.Integer IntegerKind.Usize 24 ]
                      [],
                    "bit_and",
                    [],
                    []
                  |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "alloy_primitives::bits::function::Function",
                        0
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        rhs,
                        "alloy_primitives::bits::function::Function",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_bit_and : M.IsAssociatedFunction.C Self "bit_and" bit_and.
      Admitted.
      Global Typeclasses Opaque bit_and.
      
      (*
                  pub const fn bit_or(self, rhs: Self) -> Self {
                      Self(self.0.bit_or(rhs.0))
                  }
      *)
      Definition bit_or (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            Value.StructTuple
              "alloy_primitives::bits::function::Function"
              [
                M.call_closure (|
                  Ty.apply
                    (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                    [ Value.Integer IntegerKind.Usize 24 ]
                    [],
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                      [ Value.Integer IntegerKind.Usize 24 ]
                      [],
                    "bit_or",
                    [],
                    []
                  |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "alloy_primitives::bits::function::Function",
                        0
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        rhs,
                        "alloy_primitives::bits::function::Function",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_bit_or : M.IsAssociatedFunction.C Self "bit_or" bit_or.
      Admitted.
      Global Typeclasses Opaque bit_or.
      
      (*
                  pub const fn bit_xor(self, rhs: Self) -> Self {
                      Self(self.0.bit_xor(rhs.0))
                  }
      *)
      Definition bit_xor (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            Value.StructTuple
              "alloy_primitives::bits::function::Function"
              [
                M.call_closure (|
                  Ty.apply
                    (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                    [ Value.Integer IntegerKind.Usize 24 ]
                    [],
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                      [ Value.Integer IntegerKind.Usize 24 ]
                      [],
                    "bit_xor",
                    [],
                    []
                  |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "alloy_primitives::bits::function::Function",
                        0
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        rhs,
                        "alloy_primitives::bits::function::Function",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_bit_xor : M.IsAssociatedFunction.C Self "bit_xor" bit_xor.
      Admitted.
      Global Typeclasses Opaque bit_xor.
    End Impl_alloy_primitives_bits_function_Function.
  End function.
End bits.
