(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module map.
  Module fixed.
    Axiom FbHashMap :
      forall (N : Value.t) (V : Ty.t),
      (Ty.apply (Ty.path "alloy_primitives::map::fixed::FbHashMap") [ N ] [ V ]) =
        (Ty.apply
          (Ty.path "std::collections::hash::map::HashMap")
          []
          [
            Ty.apply (Ty.path "alloy_primitives::bits::fixed::FixedBytes") [ N ] [];
            V;
            Ty.apply (Ty.path "alloy_primitives::map::fixed::FbBuildHasher") [ N ] []
          ]).
    
    Axiom FbHashSet :
      forall (N : Value.t),
      (Ty.apply (Ty.path "alloy_primitives::map::fixed::FbHashSet") [ N ] []) =
        (Ty.apply
          (Ty.path "std::collections::hash::set::HashSet")
          []
          [
            Ty.apply (Ty.path "alloy_primitives::bits::fixed::FixedBytes") [ N ] [];
            Ty.apply (Ty.path "alloy_primitives::map::fixed::FbBuildHasher") [ N ] []
          ]).
    
    Axiom SelectorHashMap :
      forall (V : Ty.t),
      (Ty.apply (Ty.path "alloy_primitives::map::fixed::SelectorHashMap") [] [ V ]) =
        (Ty.apply
          (Ty.path "std::collections::hash::map::HashMap")
          []
          [
            Ty.apply
              (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
              [ Value.Integer IntegerKind.Usize 4 ]
              [];
            V;
            Ty.apply
              (Ty.path "alloy_primitives::map::fixed::FbBuildHasher")
              [ Value.Integer IntegerKind.Usize 4 ]
              []
          ]).
    
    Axiom SelectorHashSet :
      (Ty.path "alloy_primitives::map::fixed::SelectorHashSet") =
        (Ty.apply
          (Ty.path "std::collections::hash::set::HashSet")
          []
          [
            Ty.apply
              (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
              [ Value.Integer IntegerKind.Usize 4 ]
              [];
            Ty.apply
              (Ty.path "alloy_primitives::map::fixed::FbBuildHasher")
              [ Value.Integer IntegerKind.Usize 4 ]
              []
          ]).
    
    Axiom AddressHashMap :
      forall (V : Ty.t),
      (Ty.apply (Ty.path "alloy_primitives::map::fixed::AddressHashMap") [] [ V ]) =
        (Ty.apply
          (Ty.path "std::collections::hash::map::HashMap")
          []
          [
            Ty.path "alloy_primitives::bits::address::Address";
            V;
            Ty.apply
              (Ty.path "alloy_primitives::map::fixed::FbBuildHasher")
              [ Value.Integer IntegerKind.Usize 20 ]
              []
          ]).
    
    Axiom AddressHashSet :
      (Ty.path "alloy_primitives::map::fixed::AddressHashSet") =
        (Ty.apply
          (Ty.path "std::collections::hash::set::HashSet")
          []
          [
            Ty.path "alloy_primitives::bits::address::Address";
            Ty.apply
              (Ty.path "alloy_primitives::map::fixed::FbBuildHasher")
              [ Value.Integer IntegerKind.Usize 20 ]
              []
          ]).
    
    Axiom B256HashMap :
      forall (V : Ty.t),
      (Ty.apply (Ty.path "alloy_primitives::map::fixed::B256HashMap") [] [ V ]) =
        (Ty.apply
          (Ty.path "std::collections::hash::map::HashMap")
          []
          [
            Ty.apply
              (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
              [ Value.Integer IntegerKind.Usize 32 ]
              [];
            V;
            Ty.apply
              (Ty.path "alloy_primitives::map::fixed::FbBuildHasher")
              [ Value.Integer IntegerKind.Usize 32 ]
              []
          ]).
    
    Axiom B256HashSet :
      (Ty.path "alloy_primitives::map::fixed::B256HashSet") =
        (Ty.apply
          (Ty.path "std::collections::hash::set::HashSet")
          []
          [
            Ty.apply
              (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
              [ Value.Integer IntegerKind.Usize 32 ]
              [];
            Ty.apply
              (Ty.path "alloy_primitives::map::fixed::FbBuildHasher")
              [ Value.Integer IntegerKind.Usize 32 ]
              []
          ]).
    
    (* StructRecord
      {
        name := "FbBuildHasher";
        const_params := [ "N" ];
        ty_params := [];
        fields :=
          [
            ("inner", Ty.path "foldhash::fast::RandomState");
            ("_marker",
              Ty.apply
                (Ty.path "core::marker::PhantomData")
                []
                [ Ty.apply (Ty.path "array") [ N ] [ Ty.tuple [] ] ])
          ];
      } *)
    
    Module Impl_core_clone_Clone_for_alloy_primitives_map_fixed_FbBuildHasher_N.
      Definition Self (N : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::map::fixed::FbBuildHasher") [ N ] [].
      
      (* Clone *)
      Definition clone (N : Value.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self N in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructRecord
              "alloy_primitives::map::fixed::FbBuildHasher"
              [
                ("inner",
                  M.call_closure (|
                    Ty.path "foldhash::fast::RandomState",
                    M.get_trait_method (|
                      "core::clone::Clone",
                      Ty.path "foldhash::fast::RandomState",
                      [],
                      [],
                      "clone",
                      [],
                      []
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.deref (|
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| self |) |),
                              "alloy_primitives::map::fixed::FbBuildHasher",
                              "inner"
                            |)
                          |)
                        |)
                      |)
                    ]
                  |));
                ("_marker",
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "core::marker::PhantomData")
                      []
                      [ Ty.apply (Ty.path "array") [ N ] [ Ty.tuple [] ] ],
                    M.get_trait_method (|
                      "core::clone::Clone",
                      Ty.apply
                        (Ty.path "core::marker::PhantomData")
                        []
                        [ Ty.apply (Ty.path "array") [ N ] [ Ty.tuple [] ] ],
                      [],
                      [],
                      "clone",
                      [],
                      []
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.deref (|
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| self |) |),
                              "alloy_primitives::map::fixed::FbBuildHasher",
                              "_marker"
                            |)
                          |)
                        |)
                      |)
                    ]
                  |))
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (N : Value.t),
        M.IsTraitInstance
          "core::clone::Clone"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self N)
          (* Instance *) [ ("clone", InstanceField.Method (clone N)) ].
    End Impl_core_clone_Clone_for_alloy_primitives_map_fixed_FbBuildHasher_N.
    
    Module Impl_core_default_Default_for_alloy_primitives_map_fixed_FbBuildHasher_N.
      Definition Self (N : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::map::fixed::FbBuildHasher") [ N ] [].
      
      (* Default *)
      Definition default (N : Value.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self N in
        match ε, τ, α with
        | [], [], [] =>
          ltac:(M.monadic
            (Value.StructRecord
              "alloy_primitives::map::fixed::FbBuildHasher"
              [
                ("inner",
                  M.call_closure (|
                    Ty.path "foldhash::fast::RandomState",
                    M.get_trait_method (|
                      "core::default::Default",
                      Ty.path "foldhash::fast::RandomState",
                      [],
                      [],
                      "default",
                      [],
                      []
                    |),
                    []
                  |));
                ("_marker",
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "core::marker::PhantomData")
                      []
                      [ Ty.apply (Ty.path "array") [ N ] [ Ty.tuple [] ] ],
                    M.get_trait_method (|
                      "core::default::Default",
                      Ty.apply
                        (Ty.path "core::marker::PhantomData")
                        []
                        [ Ty.apply (Ty.path "array") [ N ] [ Ty.tuple [] ] ],
                      [],
                      [],
                      "default",
                      [],
                      []
                    |),
                    []
                  |))
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (N : Value.t),
        M.IsTraitInstance
          "core::default::Default"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self N)
          (* Instance *) [ ("default", InstanceField.Method (default N)) ].
    End Impl_core_default_Default_for_alloy_primitives_map_fixed_FbBuildHasher_N.
    
    Module Impl_core_fmt_Debug_for_alloy_primitives_map_fixed_FbBuildHasher_N.
      Definition Self (N : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::map::fixed::FbBuildHasher") [ N ] [].
      
      (*
          fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
              f.debug_struct("FbBuildHasher").finish_non_exhaustive()
          }
      *)
      Definition fmt (N : Value.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self N in
        match ε, τ, α with
        | [], [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "core::result::Result")
                []
                [ Ty.tuple []; Ty.path "core::fmt::Error" ],
              M.get_associated_function (|
                Ty.path "core::fmt::builders::DebugStruct",
                "finish_non_exhaustive",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.alloc (|
                    M.call_closure (|
                      Ty.path "core::fmt::builders::DebugStruct",
                      M.get_associated_function (|
                        Ty.path "core::fmt::Formatter",
                        "debug_struct",
                        [],
                        []
                      |),
                      [
                        M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                        M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "FbBuildHasher" |) |) |)
                      ]
                    |)
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (N : Value.t),
        M.IsTraitInstance
          "core::fmt::Debug"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self N)
          (* Instance *) [ ("fmt", InstanceField.Method (fmt N)) ].
    End Impl_core_fmt_Debug_for_alloy_primitives_map_fixed_FbBuildHasher_N.
    
    Module Impl_core_hash_BuildHasher_for_alloy_primitives_map_fixed_FbBuildHasher_N.
      Definition Self (N : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::map::fixed::FbBuildHasher") [ N ] [].
      
      (*     type Hasher = FbHasher<N>; *)
      Definition _Hasher (N : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::map::fixed::FbHasher") [ N ] [].
      
      (*
          fn build_hasher(&self) -> Self::Hasher {
              FbHasher { inner: self.inner.build_hasher(), _marker: core::marker::PhantomData }
          }
      *)
      Definition build_hasher
          (N : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self N in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructRecord
              "alloy_primitives::map::fixed::FbHasher"
              [
                ("inner",
                  M.call_closure (|
                    Ty.path "foldhash::fast::FoldHasher",
                    M.get_trait_method (|
                      "core::hash::BuildHasher",
                      Ty.path "foldhash::fast::RandomState",
                      [],
                      [],
                      "build_hasher",
                      [],
                      []
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "alloy_primitives::map::fixed::FbBuildHasher",
                          "inner"
                        |)
                      |)
                    ]
                  |));
                ("_marker", Value.StructTuple "core::marker::PhantomData" [])
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (N : Value.t),
        M.IsTraitInstance
          "core::hash::BuildHasher"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self N)
          (* Instance *)
          [
            ("Hasher", InstanceField.Ty (_Hasher N));
            ("build_hasher", InstanceField.Method (build_hasher N))
          ].
    End Impl_core_hash_BuildHasher_for_alloy_primitives_map_fixed_FbBuildHasher_N.
    
    (* StructRecord
      {
        name := "FbHasher";
        const_params := [ "N" ];
        ty_params := [];
        fields :=
          [
            ("inner",
              Ty.associated_in_trait
                "core::hash::BuildHasher"
                []
                []
                (Ty.path "foldhash::fast::RandomState")
                "Hasher");
            ("_marker",
              Ty.apply
                (Ty.path "core::marker::PhantomData")
                []
                [ Ty.apply (Ty.path "array") [ N ] [ Ty.tuple [] ] ])
          ];
      } *)
    
    Module Impl_core_clone_Clone_for_alloy_primitives_map_fixed_FbHasher_N.
      Definition Self (N : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::map::fixed::FbHasher") [ N ] [].
      
      (* Clone *)
      Definition clone (N : Value.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self N in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructRecord
              "alloy_primitives::map::fixed::FbHasher"
              [
                ("inner",
                  M.call_closure (|
                    Ty.path "foldhash::fast::FoldHasher",
                    M.get_trait_method (|
                      "core::clone::Clone",
                      Ty.path "foldhash::fast::FoldHasher",
                      [],
                      [],
                      "clone",
                      [],
                      []
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.deref (|
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| self |) |),
                              "alloy_primitives::map::fixed::FbHasher",
                              "inner"
                            |)
                          |)
                        |)
                      |)
                    ]
                  |));
                ("_marker",
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "core::marker::PhantomData")
                      []
                      [ Ty.apply (Ty.path "array") [ N ] [ Ty.tuple [] ] ],
                    M.get_trait_method (|
                      "core::clone::Clone",
                      Ty.apply
                        (Ty.path "core::marker::PhantomData")
                        []
                        [ Ty.apply (Ty.path "array") [ N ] [ Ty.tuple [] ] ],
                      [],
                      [],
                      "clone",
                      [],
                      []
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.deref (|
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| self |) |),
                              "alloy_primitives::map::fixed::FbHasher",
                              "_marker"
                            |)
                          |)
                        |)
                      |)
                    ]
                  |))
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (N : Value.t),
        M.IsTraitInstance
          "core::clone::Clone"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self N)
          (* Instance *) [ ("clone", InstanceField.Method (clone N)) ].
    End Impl_core_clone_Clone_for_alloy_primitives_map_fixed_FbHasher_N.
    
    Module Impl_core_default_Default_for_alloy_primitives_map_fixed_FbHasher_N.
      Definition Self (N : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::map::fixed::FbHasher") [ N ] [].
      
      (*
          fn default() -> Self {
              Self {
                  inner: DefaultHashBuilder::default().build_hasher(),
                  _marker: core::marker::PhantomData,
              }
          }
      *)
      Definition default (N : Value.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self N in
        match ε, τ, α with
        | [], [], [] =>
          ltac:(M.monadic
            (Value.StructRecord
              "alloy_primitives::map::fixed::FbHasher"
              [
                ("inner",
                  M.call_closure (|
                    Ty.path "foldhash::fast::FoldHasher",
                    M.get_trait_method (|
                      "core::hash::BuildHasher",
                      Ty.path "foldhash::fast::RandomState",
                      [],
                      [],
                      "build_hasher",
                      [],
                      []
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.alloc (|
                          M.call_closure (|
                            Ty.path "foldhash::fast::RandomState",
                            M.get_trait_method (|
                              "core::default::Default",
                              Ty.path "foldhash::fast::RandomState",
                              [],
                              [],
                              "default",
                              [],
                              []
                            |),
                            []
                          |)
                        |)
                      |)
                    ]
                  |));
                ("_marker", Value.StructTuple "core::marker::PhantomData" [])
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (N : Value.t),
        M.IsTraitInstance
          "core::default::Default"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self N)
          (* Instance *) [ ("default", InstanceField.Method (default N)) ].
    End Impl_core_default_Default_for_alloy_primitives_map_fixed_FbHasher_N.
    
    Module Impl_core_fmt_Debug_for_alloy_primitives_map_fixed_FbHasher_N.
      Definition Self (N : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::map::fixed::FbHasher") [ N ] [].
      
      (*
          fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
              f.debug_struct("FbHasher").finish_non_exhaustive()
          }
      *)
      Definition fmt (N : Value.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self N in
        match ε, τ, α with
        | [], [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "core::result::Result")
                []
                [ Ty.tuple []; Ty.path "core::fmt::Error" ],
              M.get_associated_function (|
                Ty.path "core::fmt::builders::DebugStruct",
                "finish_non_exhaustive",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.alloc (|
                    M.call_closure (|
                      Ty.path "core::fmt::builders::DebugStruct",
                      M.get_associated_function (|
                        Ty.path "core::fmt::Formatter",
                        "debug_struct",
                        [],
                        []
                      |),
                      [
                        M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                        M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "FbHasher" |) |) |)
                      ]
                    |)
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (N : Value.t),
        M.IsTraitInstance
          "core::fmt::Debug"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self N)
          (* Instance *) [ ("fmt", InstanceField.Method (fmt N)) ].
    End Impl_core_fmt_Debug_for_alloy_primitives_map_fixed_FbHasher_N.
    
    Module Impl_core_hash_Hasher_for_alloy_primitives_map_fixed_FbHasher_N.
      Definition Self (N : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::map::fixed::FbHasher") [ N ] [].
      
      (*
          fn finish(&self) -> u64 {
              self.inner.finish()
          }
      *)
      Definition finish (N : Value.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self N in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "u64",
              M.get_trait_method (|
                "core::hash::Hasher",
                Ty.path "foldhash::fast::FoldHasher",
                [],
                [],
                "finish",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.SubPointer.get_struct_record_field (|
                    M.deref (| M.read (| self |) |),
                    "alloy_primitives::map::fixed::FbHasher",
                    "inner"
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn write(&mut self, bytes: &[u8]) {
              assert_eq_unchecked!(bytes.len(), N);
              // Threshold decided by some basic micro-benchmarks with fxhash.
              if N > 32 {
                  self.inner.write(bytes);
              } else {
                  write_bytes_unrolled(&mut self.inner, bytes);
              }
          }
      *)
      Definition write (N : Value.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self N in
        match ε, τ, α with
        | [], [], [ self; bytes ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let bytes := M.alloc (| bytes |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.match_operator (|
                  Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.use (M.alloc (| Value.Bool true |)) in
                        let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                          M.match_operator (|
                            Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                            M.alloc (|
                              Value.Tuple
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      M.call_closure (|
                                        Ty.path "usize",
                                        M.get_associated_function (|
                                          Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                                          "len",
                                          [],
                                          []
                                        |),
                                        [
                                          M.borrow (|
                                            Pointer.Kind.Ref,
                                            M.deref (| M.read (| bytes |) |)
                                          |)
                                        ]
                                      |)
                                    |)
                                  |);
                                  M.borrow (| Pointer.Kind.Ref, M.alloc (| N |) |)
                                ]
                            |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                                  let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                  let left_val := M.copy (| γ0_0 |) in
                                  let right_val := M.copy (| γ0_1 |) in
                                  M.match_operator (|
                                    Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                                    M.alloc (| Value.Tuple [] |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let γ :=
                                            M.use
                                              (M.alloc (|
                                                UnOp.not (|
                                                  M.call_closure (|
                                                    Ty.path "bool",
                                                    BinOp.eq,
                                                    [
                                                      M.read (|
                                                        M.deref (| M.read (| left_val |) |)
                                                      |);
                                                      M.read (|
                                                        M.deref (| M.read (| right_val |) |)
                                                      |)
                                                    ]
                                                  |)
                                                |)
                                              |)) in
                                          let _ :=
                                            is_constant_or_break_match (|
                                              M.read (| γ |),
                                              Value.Bool true
                                            |) in
                                          M.alloc (|
                                            M.never_to_any (|
                                              M.read (|
                                                let~ kind :
                                                    Ty.apply
                                                      (Ty.path "*")
                                                      []
                                                      [ Ty.path "core::panicking::AssertKind" ] :=
                                                  M.alloc (|
                                                    Value.StructTuple
                                                      "core::panicking::AssertKind::Eq"
                                                      []
                                                  |) in
                                                M.alloc (|
                                                  M.call_closure (|
                                                    Ty.path "never",
                                                    M.get_function (|
                                                      "core::panicking::assert_failed",
                                                      [],
                                                      [ Ty.path "usize"; Ty.path "usize" ]
                                                    |),
                                                    [
                                                      M.read (| kind |);
                                                      M.borrow (|
                                                        Pointer.Kind.Ref,
                                                        M.deref (|
                                                          M.borrow (|
                                                            Pointer.Kind.Ref,
                                                            M.deref (| M.read (| left_val |) |)
                                                          |)
                                                        |)
                                                      |);
                                                      M.borrow (|
                                                        Pointer.Kind.Ref,
                                                        M.deref (|
                                                          M.borrow (|
                                                            Pointer.Kind.Ref,
                                                            M.deref (| M.read (| right_val |) |)
                                                          |)
                                                        |)
                                                      |);
                                                      Value.StructTuple
                                                        "core::option::Option::None"
                                                        []
                                                    ]
                                                  |)
                                                |)
                                              |)
                                            |)
                                          |)));
                                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                                    ]
                                  |)))
                            ]
                          |) in
                        M.alloc (| Value.Tuple [] |)));
                    fun γ =>
                      ltac:(M.monadic
                        (M.match_operator (|
                          Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                          M.alloc (| Value.Tuple [] |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ :=
                                  M.use
                                    (M.alloc (|
                                      M.call_closure (|
                                        Ty.path "bool",
                                        BinOp.ne,
                                        [
                                          M.call_closure (|
                                            Ty.path "usize",
                                            M.get_associated_function (|
                                              Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                                              "len",
                                              [],
                                              []
                                            |),
                                            [
                                              M.borrow (|
                                                Pointer.Kind.Ref,
                                                M.deref (| M.read (| bytes |) |)
                                              |)
                                            ]
                                          |);
                                          N
                                        ]
                                      |)
                                    |)) in
                                let _ :=
                                  is_constant_or_break_match (|
                                    M.read (| γ |),
                                    Value.Bool true
                                  |) in
                                M.alloc (|
                                  M.never_to_any (|
                                    M.call_closure (|
                                      Ty.path "never",
                                      M.get_function (|
                                        "core::hint::unreachable_unchecked",
                                        [],
                                        []
                                      |),
                                      []
                                    |)
                                  |)
                                |)));
                            fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                          ]
                        |)))
                  ]
                |) in
              M.match_operator (|
                Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            M.call_closure (|
                              Ty.path "bool",
                              BinOp.gt,
                              [ N; Value.Integer IntegerKind.Usize 32 ]
                            |)
                          |)) in
                      let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                        M.alloc (|
                          M.call_closure (|
                            Ty.tuple [],
                            M.get_trait_method (|
                              "core::hash::Hasher",
                              Ty.path "foldhash::fast::FoldHasher",
                              [],
                              [],
                              "write",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.MutRef,
                                M.SubPointer.get_struct_record_field (|
                                  M.deref (| M.read (| self |) |),
                                  "alloy_primitives::map::fixed::FbHasher",
                                  "inner"
                                |)
                              |);
                              M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| bytes |) |) |)
                            ]
                          |)
                        |) in
                      M.alloc (| Value.Tuple [] |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                        M.alloc (|
                          M.call_closure (|
                            Ty.tuple [],
                            M.get_function (|
                              "alloy_primitives::map::fixed::write_bytes_unrolled",
                              [],
                              [ Ty.path "foldhash::fast::FoldHasher" ]
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.MutRef,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.MutRef,
                                    M.SubPointer.get_struct_record_field (|
                                      M.deref (| M.read (| self |) |),
                                      "alloy_primitives::map::fixed::FbHasher",
                                      "inner"
                                    |)
                                  |)
                                |)
                              |);
                              M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| bytes |) |) |)
                            ]
                          |)
                        |) in
                      M.alloc (| Value.Tuple [] |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn write_usize(&mut self, i: usize) {
              debug_assert_eq!(i, N);
          }
      *)
      Definition write_usize
          (N : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self N in
        match ε, τ, α with
        | [], [], [ self; i ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let i := M.alloc (| i |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.match_operator (|
                  Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.use (M.alloc (| Value.Bool true |)) in
                        let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                          M.match_operator (|
                            Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                            M.alloc (|
                              Value.Tuple
                                [
                                  M.borrow (| Pointer.Kind.Ref, i |);
                                  M.borrow (| Pointer.Kind.Ref, M.alloc (| N |) |)
                                ]
                            |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                                  let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                  let left_val := M.copy (| γ0_0 |) in
                                  let right_val := M.copy (| γ0_1 |) in
                                  M.match_operator (|
                                    Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                                    M.alloc (| Value.Tuple [] |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let γ :=
                                            M.use
                                              (M.alloc (|
                                                UnOp.not (|
                                                  M.call_closure (|
                                                    Ty.path "bool",
                                                    BinOp.eq,
                                                    [
                                                      M.read (|
                                                        M.deref (| M.read (| left_val |) |)
                                                      |);
                                                      M.read (|
                                                        M.deref (| M.read (| right_val |) |)
                                                      |)
                                                    ]
                                                  |)
                                                |)
                                              |)) in
                                          let _ :=
                                            is_constant_or_break_match (|
                                              M.read (| γ |),
                                              Value.Bool true
                                            |) in
                                          M.alloc (|
                                            M.never_to_any (|
                                              M.read (|
                                                let~ kind :
                                                    Ty.apply
                                                      (Ty.path "*")
                                                      []
                                                      [ Ty.path "core::panicking::AssertKind" ] :=
                                                  M.alloc (|
                                                    Value.StructTuple
                                                      "core::panicking::AssertKind::Eq"
                                                      []
                                                  |) in
                                                M.alloc (|
                                                  M.call_closure (|
                                                    Ty.path "never",
                                                    M.get_function (|
                                                      "core::panicking::assert_failed",
                                                      [],
                                                      [ Ty.path "usize"; Ty.path "usize" ]
                                                    |),
                                                    [
                                                      M.read (| kind |);
                                                      M.borrow (|
                                                        Pointer.Kind.Ref,
                                                        M.deref (|
                                                          M.borrow (|
                                                            Pointer.Kind.Ref,
                                                            M.deref (| M.read (| left_val |) |)
                                                          |)
                                                        |)
                                                      |);
                                                      M.borrow (|
                                                        Pointer.Kind.Ref,
                                                        M.deref (|
                                                          M.borrow (|
                                                            Pointer.Kind.Ref,
                                                            M.deref (| M.read (| right_val |) |)
                                                          |)
                                                        |)
                                                      |);
                                                      Value.StructTuple
                                                        "core::option::Option::None"
                                                        []
                                                    ]
                                                  |)
                                                |)
                                              |)
                                            |)
                                          |)));
                                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                                    ]
                                  |)))
                            ]
                          |) in
                        M.alloc (| Value.Tuple [] |)));
                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                  ]
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (N : Value.t),
        M.IsTraitInstance
          "core::hash::Hasher"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self N)
          (* Instance *)
          [
            ("finish", InstanceField.Method (finish N));
            ("write", InstanceField.Method (write N));
            ("write_usize", InstanceField.Method (write_usize N))
          ].
    End Impl_core_hash_Hasher_for_alloy_primitives_map_fixed_FbHasher_N.
    
    (*
    fn write_bytes_unrolled(hasher: &mut impl Hasher, mut bytes: &[u8]) {
        while let Some((chunk, rest)) = bytes.split_first_chunk() {
            hasher.write_usize(usize::from_ne_bytes( *chunk));
            bytes = rest;
        }
        if usize::BITS > 64 {
            if let Some((chunk, rest)) = bytes.split_first_chunk() {
                hasher.write_u64(u64::from_ne_bytes( *chunk));
                bytes = rest;
            }
        }
        if usize::BITS > 32 {
            if let Some((chunk, rest)) = bytes.split_first_chunk() {
                hasher.write_u32(u32::from_ne_bytes( *chunk));
                bytes = rest;
            }
        }
        if usize::BITS > 16 {
            if let Some((chunk, rest)) = bytes.split_first_chunk() {
                hasher.write_u16(u16::from_ne_bytes( *chunk));
                bytes = rest;
            }
        }
        if usize::BITS > 8 {
            if let Some((chunk, rest)) = bytes.split_first_chunk() {
                hasher.write_u8(u8::from_ne_bytes( *chunk));
                bytes = rest;
            }
        }
    
        debug_assert!(bytes.is_empty());
    }
    *)
    Definition write_bytes_unrolled (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [ impl_Hasher ], [ hasher; bytes ] =>
        ltac:(M.monadic
          (let hasher := M.alloc (| hasher |) in
          let bytes := M.alloc (| bytes |) in
          M.read (|
            let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
              M.loop (|
                Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                ltac:(M.monadic
                  (M.match_operator (|
                    Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.alloc (|
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "core::option::Option")
                                  []
                                  [
                                    Ty.tuple
                                      [
                                        Ty.apply
                                          (Ty.path "&")
                                          []
                                          [
                                            Ty.apply
                                              (Ty.path "array")
                                              [ Value.Integer IntegerKind.Usize 8 ]
                                              [ Ty.path "u8" ]
                                          ];
                                        Ty.apply
                                          (Ty.path "&")
                                          []
                                          [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
                                      ]
                                  ],
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                                  "split_first_chunk",
                                  [ Value.Integer IntegerKind.Usize 8 ],
                                  []
                                |),
                                [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| bytes |) |) |)
                                ]
                              |)
                            |) in
                          let γ0_0 :=
                            M.SubPointer.get_struct_tuple_field (|
                              γ,
                              "core::option::Option::Some",
                              0
                            |) in
                          let γ1_0 := M.SubPointer.get_tuple_field (| γ0_0, 0 |) in
                          let γ1_1 := M.SubPointer.get_tuple_field (| γ0_0, 1 |) in
                          let chunk := M.copy (| γ1_0 |) in
                          let rest := M.copy (| γ1_1 |) in
                          let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                            M.alloc (|
                              M.call_closure (|
                                Ty.tuple [],
                                M.get_trait_method (|
                                  "core::hash::Hasher",
                                  impl_Hasher,
                                  [],
                                  [],
                                  "write_usize",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (|
                                    Pointer.Kind.MutRef,
                                    M.deref (| M.read (| hasher |) |)
                                  |);
                                  M.call_closure (|
                                    Ty.path "usize",
                                    M.get_associated_function (|
                                      Ty.path "usize",
                                      "from_ne_bytes",
                                      [],
                                      []
                                    |),
                                    [ M.read (| M.deref (| M.read (| chunk |) |) |) ]
                                  |)
                                ]
                              |)
                            |) in
                          let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                            M.alloc (|
                              M.write (|
                                bytes,
                                M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| rest |) |) |)
                              |)
                            |) in
                          M.alloc (| Value.Tuple [] |)));
                      fun γ =>
                        ltac:(M.monadic
                          (M.alloc (|
                            M.never_to_any (|
                              M.read (|
                                let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                                  M.alloc (| M.never_to_any (| M.read (| M.break (||) |) |) |) in
                                M.alloc (| Value.Tuple [] |)
                              |)
                            |)
                          |)))
                    ]
                  |)))
              |) in
            let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
              M.match_operator (|
                Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            M.call_closure (|
                              Ty.path "bool",
                              BinOp.gt,
                              [
                                M.read (|
                                  get_associated_constant (|
                                    Ty.path "usize",
                                    "BITS",
                                    Ty.path "u32"
                                  |)
                                |);
                                Value.Integer IntegerKind.U32 64
                              ]
                            |)
                          |)) in
                      let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.match_operator (|
                        Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                        M.alloc (| Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.alloc (|
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "core::option::Option")
                                      []
                                      [
                                        Ty.tuple
                                          [
                                            Ty.apply
                                              (Ty.path "&")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "array")
                                                  [ Value.Integer IntegerKind.Usize 8 ]
                                                  [ Ty.path "u8" ]
                                              ];
                                            Ty.apply
                                              (Ty.path "&")
                                              []
                                              [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
                                          ]
                                      ],
                                    M.get_associated_function (|
                                      Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                                      "split_first_chunk",
                                      [ Value.Integer IntegerKind.Usize 8 ],
                                      []
                                    |),
                                    [
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.deref (| M.read (| bytes |) |)
                                      |)
                                    ]
                                  |)
                                |) in
                              let γ0_0 :=
                                M.SubPointer.get_struct_tuple_field (|
                                  γ,
                                  "core::option::Option::Some",
                                  0
                                |) in
                              let γ1_0 := M.SubPointer.get_tuple_field (| γ0_0, 0 |) in
                              let γ1_1 := M.SubPointer.get_tuple_field (| γ0_0, 1 |) in
                              let chunk := M.copy (| γ1_0 |) in
                              let rest := M.copy (| γ1_1 |) in
                              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                                M.alloc (|
                                  M.call_closure (|
                                    Ty.tuple [],
                                    M.get_trait_method (|
                                      "core::hash::Hasher",
                                      impl_Hasher,
                                      [],
                                      [],
                                      "write_u64",
                                      [],
                                      []
                                    |),
                                    [
                                      M.borrow (|
                                        Pointer.Kind.MutRef,
                                        M.deref (| M.read (| hasher |) |)
                                      |);
                                      M.call_closure (|
                                        Ty.path "u64",
                                        M.get_associated_function (|
                                          Ty.path "u64",
                                          "from_ne_bytes",
                                          [],
                                          []
                                        |),
                                        [ M.read (| M.deref (| M.read (| chunk |) |) |) ]
                                      |)
                                    ]
                                  |)
                                |) in
                              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                                M.alloc (|
                                  M.write (|
                                    bytes,
                                    M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| rest |) |) |)
                                  |)
                                |) in
                              M.alloc (| Value.Tuple [] |)));
                          fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                        ]
                      |)));
                  fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                ]
              |) in
            let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
              M.match_operator (|
                Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            M.call_closure (|
                              Ty.path "bool",
                              BinOp.gt,
                              [
                                M.read (|
                                  get_associated_constant (|
                                    Ty.path "usize",
                                    "BITS",
                                    Ty.path "u32"
                                  |)
                                |);
                                Value.Integer IntegerKind.U32 32
                              ]
                            |)
                          |)) in
                      let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.match_operator (|
                        Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                        M.alloc (| Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.alloc (|
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "core::option::Option")
                                      []
                                      [
                                        Ty.tuple
                                          [
                                            Ty.apply
                                              (Ty.path "&")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "array")
                                                  [ Value.Integer IntegerKind.Usize 4 ]
                                                  [ Ty.path "u8" ]
                                              ];
                                            Ty.apply
                                              (Ty.path "&")
                                              []
                                              [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
                                          ]
                                      ],
                                    M.get_associated_function (|
                                      Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                                      "split_first_chunk",
                                      [ Value.Integer IntegerKind.Usize 4 ],
                                      []
                                    |),
                                    [
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.deref (| M.read (| bytes |) |)
                                      |)
                                    ]
                                  |)
                                |) in
                              let γ0_0 :=
                                M.SubPointer.get_struct_tuple_field (|
                                  γ,
                                  "core::option::Option::Some",
                                  0
                                |) in
                              let γ1_0 := M.SubPointer.get_tuple_field (| γ0_0, 0 |) in
                              let γ1_1 := M.SubPointer.get_tuple_field (| γ0_0, 1 |) in
                              let chunk := M.copy (| γ1_0 |) in
                              let rest := M.copy (| γ1_1 |) in
                              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                                M.alloc (|
                                  M.call_closure (|
                                    Ty.tuple [],
                                    M.get_trait_method (|
                                      "core::hash::Hasher",
                                      impl_Hasher,
                                      [],
                                      [],
                                      "write_u32",
                                      [],
                                      []
                                    |),
                                    [
                                      M.borrow (|
                                        Pointer.Kind.MutRef,
                                        M.deref (| M.read (| hasher |) |)
                                      |);
                                      M.call_closure (|
                                        Ty.path "u32",
                                        M.get_associated_function (|
                                          Ty.path "u32",
                                          "from_ne_bytes",
                                          [],
                                          []
                                        |),
                                        [ M.read (| M.deref (| M.read (| chunk |) |) |) ]
                                      |)
                                    ]
                                  |)
                                |) in
                              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                                M.alloc (|
                                  M.write (|
                                    bytes,
                                    M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| rest |) |) |)
                                  |)
                                |) in
                              M.alloc (| Value.Tuple [] |)));
                          fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                        ]
                      |)));
                  fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                ]
              |) in
            let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
              M.match_operator (|
                Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            M.call_closure (|
                              Ty.path "bool",
                              BinOp.gt,
                              [
                                M.read (|
                                  get_associated_constant (|
                                    Ty.path "usize",
                                    "BITS",
                                    Ty.path "u32"
                                  |)
                                |);
                                Value.Integer IntegerKind.U32 16
                              ]
                            |)
                          |)) in
                      let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.match_operator (|
                        Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                        M.alloc (| Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.alloc (|
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "core::option::Option")
                                      []
                                      [
                                        Ty.tuple
                                          [
                                            Ty.apply
                                              (Ty.path "&")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "array")
                                                  [ Value.Integer IntegerKind.Usize 2 ]
                                                  [ Ty.path "u8" ]
                                              ];
                                            Ty.apply
                                              (Ty.path "&")
                                              []
                                              [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
                                          ]
                                      ],
                                    M.get_associated_function (|
                                      Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                                      "split_first_chunk",
                                      [ Value.Integer IntegerKind.Usize 2 ],
                                      []
                                    |),
                                    [
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.deref (| M.read (| bytes |) |)
                                      |)
                                    ]
                                  |)
                                |) in
                              let γ0_0 :=
                                M.SubPointer.get_struct_tuple_field (|
                                  γ,
                                  "core::option::Option::Some",
                                  0
                                |) in
                              let γ1_0 := M.SubPointer.get_tuple_field (| γ0_0, 0 |) in
                              let γ1_1 := M.SubPointer.get_tuple_field (| γ0_0, 1 |) in
                              let chunk := M.copy (| γ1_0 |) in
                              let rest := M.copy (| γ1_1 |) in
                              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                                M.alloc (|
                                  M.call_closure (|
                                    Ty.tuple [],
                                    M.get_trait_method (|
                                      "core::hash::Hasher",
                                      impl_Hasher,
                                      [],
                                      [],
                                      "write_u16",
                                      [],
                                      []
                                    |),
                                    [
                                      M.borrow (|
                                        Pointer.Kind.MutRef,
                                        M.deref (| M.read (| hasher |) |)
                                      |);
                                      M.call_closure (|
                                        Ty.path "u16",
                                        M.get_associated_function (|
                                          Ty.path "u16",
                                          "from_ne_bytes",
                                          [],
                                          []
                                        |),
                                        [ M.read (| M.deref (| M.read (| chunk |) |) |) ]
                                      |)
                                    ]
                                  |)
                                |) in
                              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                                M.alloc (|
                                  M.write (|
                                    bytes,
                                    M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| rest |) |) |)
                                  |)
                                |) in
                              M.alloc (| Value.Tuple [] |)));
                          fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                        ]
                      |)));
                  fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                ]
              |) in
            let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
              M.match_operator (|
                Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            M.call_closure (|
                              Ty.path "bool",
                              BinOp.gt,
                              [
                                M.read (|
                                  get_associated_constant (|
                                    Ty.path "usize",
                                    "BITS",
                                    Ty.path "u32"
                                  |)
                                |);
                                Value.Integer IntegerKind.U32 8
                              ]
                            |)
                          |)) in
                      let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.match_operator (|
                        Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                        M.alloc (| Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.alloc (|
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "core::option::Option")
                                      []
                                      [
                                        Ty.tuple
                                          [
                                            Ty.apply
                                              (Ty.path "&")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "array")
                                                  [ Value.Integer IntegerKind.Usize 1 ]
                                                  [ Ty.path "u8" ]
                                              ];
                                            Ty.apply
                                              (Ty.path "&")
                                              []
                                              [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
                                          ]
                                      ],
                                    M.get_associated_function (|
                                      Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                                      "split_first_chunk",
                                      [ Value.Integer IntegerKind.Usize 1 ],
                                      []
                                    |),
                                    [
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.deref (| M.read (| bytes |) |)
                                      |)
                                    ]
                                  |)
                                |) in
                              let γ0_0 :=
                                M.SubPointer.get_struct_tuple_field (|
                                  γ,
                                  "core::option::Option::Some",
                                  0
                                |) in
                              let γ1_0 := M.SubPointer.get_tuple_field (| γ0_0, 0 |) in
                              let γ1_1 := M.SubPointer.get_tuple_field (| γ0_0, 1 |) in
                              let chunk := M.copy (| γ1_0 |) in
                              let rest := M.copy (| γ1_1 |) in
                              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                                M.alloc (|
                                  M.call_closure (|
                                    Ty.tuple [],
                                    M.get_trait_method (|
                                      "core::hash::Hasher",
                                      impl_Hasher,
                                      [],
                                      [],
                                      "write_u8",
                                      [],
                                      []
                                    |),
                                    [
                                      M.borrow (|
                                        Pointer.Kind.MutRef,
                                        M.deref (| M.read (| hasher |) |)
                                      |);
                                      M.call_closure (|
                                        Ty.path "u8",
                                        M.get_associated_function (|
                                          Ty.path "u8",
                                          "from_ne_bytes",
                                          [],
                                          []
                                        |),
                                        [ M.read (| M.deref (| M.read (| chunk |) |) |) ]
                                      |)
                                    ]
                                  |)
                                |) in
                              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                                M.alloc (|
                                  M.write (|
                                    bytes,
                                    M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| rest |) |) |)
                                  |)
                                |) in
                              M.alloc (| Value.Tuple [] |)));
                          fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                        ]
                      |)));
                  fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                ]
              |) in
            let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
              M.match_operator (|
                Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.use (M.alloc (| Value.Bool true |)) in
                      let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                        M.match_operator (|
                          Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                          M.alloc (| Value.Tuple [] |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ :=
                                  M.use
                                    (M.alloc (|
                                      UnOp.not (|
                                        M.call_closure (|
                                          Ty.path "bool",
                                          M.get_associated_function (|
                                            Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                                            "is_empty",
                                            [],
                                            []
                                          |),
                                          [
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.deref (| M.read (| bytes |) |)
                                            |)
                                          ]
                                        |)
                                      |)
                                    |)) in
                                let _ :=
                                  is_constant_or_break_match (|
                                    M.read (| γ |),
                                    Value.Bool true
                                  |) in
                                M.alloc (|
                                  M.never_to_any (|
                                    M.call_closure (|
                                      Ty.path "never",
                                      M.get_function (| "core::panicking::panic", [], [] |),
                                      [ mk_str (| "assertion failed: bytes.is_empty()" |) ]
                                    |)
                                  |)
                                |)));
                            fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                          ]
                        |) in
                      M.alloc (| Value.Tuple [] |)));
                  fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                ]
              |) in
            M.alloc (| Value.Tuple [] |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance Instance_IsFunction_write_bytes_unrolled :
      M.IsFunction.C "alloy_primitives::map::fixed::write_bytes_unrolled" write_bytes_unrolled.
    Admitted.
    Global Typeclasses Opaque write_bytes_unrolled.
  End fixed.
End map.
