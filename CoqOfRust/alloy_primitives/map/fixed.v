(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module map.
  Module fixed.
    Axiom FbHashMap :
      forall (N : Value.t) (V : Ty.t),
      (Ty.apply (Ty.path "alloy_primitives::map::fixed::FbHashMap") [ N ] [ V ]) =
        (Ty.apply
          (Ty.path "std::collections::hash::map::HashMap")
          []
          [
            Ty.apply (Ty.path "alloy_primitives::bits::fixed::FixedBytes") [ N ] [];
            V;
            Ty.apply (Ty.path "alloy_primitives::map::fixed::FbBuildHasher") [ N ] []
          ]).
    
    Axiom FbHashSet :
      forall (N : Value.t),
      (Ty.apply (Ty.path "alloy_primitives::map::fixed::FbHashSet") [ N ] []) =
        (Ty.apply
          (Ty.path "std::collections::hash::set::HashSet")
          []
          [
            Ty.apply (Ty.path "alloy_primitives::bits::fixed::FixedBytes") [ N ] [];
            Ty.apply (Ty.path "alloy_primitives::map::fixed::FbBuildHasher") [ N ] []
          ]).
    
    Axiom SelectorHashMap :
      forall (V : Ty.t),
      (Ty.apply (Ty.path "alloy_primitives::map::fixed::SelectorHashMap") [] [ V ]) =
        (Ty.apply
          (Ty.path "std::collections::hash::map::HashMap")
          []
          [
            Ty.apply
              (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
              [ Value.Integer IntegerKind.Usize 4 ]
              [];
            V;
            Ty.apply
              (Ty.path "alloy_primitives::map::fixed::FbBuildHasher")
              [ Value.Integer IntegerKind.Usize 4 ]
              []
          ]).
    
    Axiom SelectorHashSet :
      (Ty.path "alloy_primitives::map::fixed::SelectorHashSet") =
        (Ty.apply
          (Ty.path "std::collections::hash::set::HashSet")
          []
          [
            Ty.apply
              (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
              [ Value.Integer IntegerKind.Usize 4 ]
              [];
            Ty.apply
              (Ty.path "alloy_primitives::map::fixed::FbBuildHasher")
              [ Value.Integer IntegerKind.Usize 4 ]
              []
          ]).
    
    Axiom AddressHashMap :
      forall (V : Ty.t),
      (Ty.apply (Ty.path "alloy_primitives::map::fixed::AddressHashMap") [] [ V ]) =
        (Ty.apply
          (Ty.path "std::collections::hash::map::HashMap")
          []
          [
            Ty.path "alloy_primitives::bits::address::Address";
            V;
            Ty.apply
              (Ty.path "alloy_primitives::map::fixed::FbBuildHasher")
              [ Value.Integer IntegerKind.Usize 20 ]
              []
          ]).
    
    Axiom AddressHashSet :
      (Ty.path "alloy_primitives::map::fixed::AddressHashSet") =
        (Ty.apply
          (Ty.path "std::collections::hash::set::HashSet")
          []
          [
            Ty.path "alloy_primitives::bits::address::Address";
            Ty.apply
              (Ty.path "alloy_primitives::map::fixed::FbBuildHasher")
              [ Value.Integer IntegerKind.Usize 20 ]
              []
          ]).
    
    Axiom B256HashMap :
      forall (V : Ty.t),
      (Ty.apply (Ty.path "alloy_primitives::map::fixed::B256HashMap") [] [ V ]) =
        (Ty.apply
          (Ty.path "std::collections::hash::map::HashMap")
          []
          [
            Ty.apply
              (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
              [ Value.Integer IntegerKind.Usize 32 ]
              [];
            V;
            Ty.apply
              (Ty.path "alloy_primitives::map::fixed::FbBuildHasher")
              [ Value.Integer IntegerKind.Usize 32 ]
              []
          ]).
    
    Axiom B256HashSet :
      (Ty.path "alloy_primitives::map::fixed::B256HashSet") =
        (Ty.apply
          (Ty.path "std::collections::hash::set::HashSet")
          []
          [
            Ty.apply
              (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
              [ Value.Integer IntegerKind.Usize 32 ]
              [];
            Ty.apply
              (Ty.path "alloy_primitives::map::fixed::FbBuildHasher")
              [ Value.Integer IntegerKind.Usize 32 ]
              []
          ]).
    
    (* StructRecord
      {
        name := "FbBuildHasher";
        const_params := [ "N" ];
        ty_params := [];
        fields :=
          [
            ("inner", Ty.path "foldhash::fast::RandomState");
            ("_marker",
              Ty.apply
                (Ty.path "core::marker::PhantomData")
                []
                [ Ty.apply (Ty.path "array") [ N ] [ Ty.tuple [] ] ])
          ];
      } *)
    
    Module Impl_core_clone_Clone_for_alloy_primitives_map_fixed_FbBuildHasher_N.
      Definition Self (N : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::map::fixed::FbBuildHasher") [ N ] [].
      
      (* Clone *)
      Definition clone (N : Value.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self N in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply
                  (Ty.path "&")
                  []
                  [ Ty.apply (Ty.path "alloy_primitives::map::fixed::FbBuildHasher") [ N ] [] ],
                self
              |) in
            Value.mkStructRecord
              "alloy_primitives::map::fixed::FbBuildHasher"
              [ N ]
              []
              [
                ("inner",
                  M.call_closure (|
                    Ty.path "foldhash::fast::RandomState",
                    M.get_trait_method (|
                      "core::clone::Clone",
                      Ty.path "foldhash::fast::RandomState",
                      [],
                      [],
                      "clone",
                      [],
                      []
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.deref (|
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| self |) |),
                              "alloy_primitives::map::fixed::FbBuildHasher",
                              "inner"
                            |)
                          |)
                        |)
                      |)
                    ]
                  |));
                ("_marker",
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "core::marker::PhantomData")
                      []
                      [ Ty.apply (Ty.path "array") [ N ] [ Ty.tuple [] ] ],
                    M.get_trait_method (|
                      "core::clone::Clone",
                      Ty.apply
                        (Ty.path "core::marker::PhantomData")
                        []
                        [ Ty.apply (Ty.path "array") [ N ] [ Ty.tuple [] ] ],
                      [],
                      [],
                      "clone",
                      [],
                      []
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.deref (|
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| self |) |),
                              "alloy_primitives::map::fixed::FbBuildHasher",
                              "_marker"
                            |)
                          |)
                        |)
                      |)
                    ]
                  |))
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (N : Value.t),
        M.IsTraitInstance
          "core::clone::Clone"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self N)
          (* Instance *) [ ("clone", InstanceField.Method (clone N)) ].
    End Impl_core_clone_Clone_for_alloy_primitives_map_fixed_FbBuildHasher_N.
    
    Module Impl_core_default_Default_for_alloy_primitives_map_fixed_FbBuildHasher_N.
      Definition Self (N : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::map::fixed::FbBuildHasher") [ N ] [].
      
      (* Default *)
      Definition default (N : Value.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self N in
        match ε, τ, α with
        | [], [], [] =>
          ltac:(M.monadic
            (Value.mkStructRecord
              "alloy_primitives::map::fixed::FbBuildHasher"
              [ N ]
              []
              [
                ("inner",
                  M.call_closure (|
                    Ty.path "foldhash::fast::RandomState",
                    M.get_trait_method (|
                      "core::default::Default",
                      Ty.path "foldhash::fast::RandomState",
                      [],
                      [],
                      "default",
                      [],
                      []
                    |),
                    []
                  |));
                ("_marker",
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "core::marker::PhantomData")
                      []
                      [ Ty.apply (Ty.path "array") [ N ] [ Ty.tuple [] ] ],
                    M.get_trait_method (|
                      "core::default::Default",
                      Ty.apply
                        (Ty.path "core::marker::PhantomData")
                        []
                        [ Ty.apply (Ty.path "array") [ N ] [ Ty.tuple [] ] ],
                      [],
                      [],
                      "default",
                      [],
                      []
                    |),
                    []
                  |))
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (N : Value.t),
        M.IsTraitInstance
          "core::default::Default"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self N)
          (* Instance *) [ ("default", InstanceField.Method (default N)) ].
    End Impl_core_default_Default_for_alloy_primitives_map_fixed_FbBuildHasher_N.
    
    Module Impl_core_fmt_Debug_for_alloy_primitives_map_fixed_FbBuildHasher_N.
      Definition Self (N : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::map::fixed::FbBuildHasher") [ N ] [].
      
      (*
          fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
              f.debug_struct("FbBuildHasher").finish_non_exhaustive()
          }
      *)
      Definition fmt (N : Value.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self N in
        match ε, τ, α with
        | [], [], [ self; f ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply
                  (Ty.path "&")
                  []
                  [ Ty.apply (Ty.path "alloy_primitives::map::fixed::FbBuildHasher") [ N ] [] ],
                self
              |) in
            let f :=
              M.alloc (| Ty.apply (Ty.path "&mut") [] [ Ty.path "core::fmt::Formatter" ], f |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "core::result::Result")
                []
                [ Ty.tuple []; Ty.path "core::fmt::Error" ],
              M.get_associated_function (|
                Ty.path "core::fmt::builders::DebugStruct",
                "finish_non_exhaustive",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.alloc (|
                    Ty.path "core::fmt::builders::DebugStruct",
                    M.call_closure (|
                      Ty.path "core::fmt::builders::DebugStruct",
                      M.get_associated_function (|
                        Ty.path "core::fmt::Formatter",
                        "debug_struct",
                        [],
                        []
                      |),
                      [
                        M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                        M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "FbBuildHasher" |) |) |)
                      ]
                    |)
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (N : Value.t),
        M.IsTraitInstance
          "core::fmt::Debug"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self N)
          (* Instance *) [ ("fmt", InstanceField.Method (fmt N)) ].
    End Impl_core_fmt_Debug_for_alloy_primitives_map_fixed_FbBuildHasher_N.
    
    Module Impl_core_hash_BuildHasher_for_alloy_primitives_map_fixed_FbBuildHasher_N.
      Definition Self (N : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::map::fixed::FbBuildHasher") [ N ] [].
      
      (*     type Hasher = FbHasher<N>; *)
      Definition _Hasher (N : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::map::fixed::FbHasher") [ N ] [].
      
      (*
          fn build_hasher(&self) -> Self::Hasher {
              FbHasher { inner: self.inner.build_hasher(), _marker: core::marker::PhantomData }
          }
      *)
      Definition build_hasher
          (N : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self N in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply
                  (Ty.path "&")
                  []
                  [ Ty.apply (Ty.path "alloy_primitives::map::fixed::FbBuildHasher") [ N ] [] ],
                self
              |) in
            Value.mkStructRecord
              "alloy_primitives::map::fixed::FbHasher"
              [ N ]
              []
              [
                ("inner",
                  M.call_closure (|
                    Ty.path "foldhash::fast::FoldHasher",
                    M.get_trait_method (|
                      "core::hash::BuildHasher",
                      Ty.path "foldhash::fast::RandomState",
                      [],
                      [],
                      "build_hasher",
                      [],
                      []
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "alloy_primitives::map::fixed::FbBuildHasher",
                          "inner"
                        |)
                      |)
                    ]
                  |));
                ("_marker",
                  Value.StructTuple
                    "core::marker::PhantomData"
                    []
                    [ Ty.apply (Ty.path "array") [ N ] [ Ty.tuple [] ] ]
                    [])
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (N : Value.t),
        M.IsTraitInstance
          "core::hash::BuildHasher"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self N)
          (* Instance *)
          [
            ("Hasher", InstanceField.Ty (_Hasher N));
            ("build_hasher", InstanceField.Method (build_hasher N))
          ].
    End Impl_core_hash_BuildHasher_for_alloy_primitives_map_fixed_FbBuildHasher_N.
    
    (* StructRecord
      {
        name := "FbHasher";
        const_params := [ "N" ];
        ty_params := [];
        fields :=
          [
            ("inner",
              Ty.associated_in_trait
                "core::hash::BuildHasher"
                []
                []
                (Ty.path "foldhash::fast::RandomState")
                "Hasher");
            ("_marker",
              Ty.apply
                (Ty.path "core::marker::PhantomData")
                []
                [ Ty.apply (Ty.path "array") [ N ] [ Ty.tuple [] ] ])
          ];
      } *)
    
    Module Impl_core_clone_Clone_for_alloy_primitives_map_fixed_FbHasher_N.
      Definition Self (N : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::map::fixed::FbHasher") [ N ] [].
      
      (* Clone *)
      Definition clone (N : Value.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self N in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply
                  (Ty.path "&")
                  []
                  [ Ty.apply (Ty.path "alloy_primitives::map::fixed::FbHasher") [ N ] [] ],
                self
              |) in
            Value.mkStructRecord
              "alloy_primitives::map::fixed::FbHasher"
              [ N ]
              []
              [
                ("inner",
                  M.call_closure (|
                    Ty.path "foldhash::fast::FoldHasher",
                    M.get_trait_method (|
                      "core::clone::Clone",
                      Ty.path "foldhash::fast::FoldHasher",
                      [],
                      [],
                      "clone",
                      [],
                      []
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.deref (|
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| self |) |),
                              "alloy_primitives::map::fixed::FbHasher",
                              "inner"
                            |)
                          |)
                        |)
                      |)
                    ]
                  |));
                ("_marker",
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "core::marker::PhantomData")
                      []
                      [ Ty.apply (Ty.path "array") [ N ] [ Ty.tuple [] ] ],
                    M.get_trait_method (|
                      "core::clone::Clone",
                      Ty.apply
                        (Ty.path "core::marker::PhantomData")
                        []
                        [ Ty.apply (Ty.path "array") [ N ] [ Ty.tuple [] ] ],
                      [],
                      [],
                      "clone",
                      [],
                      []
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.deref (|
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| self |) |),
                              "alloy_primitives::map::fixed::FbHasher",
                              "_marker"
                            |)
                          |)
                        |)
                      |)
                    ]
                  |))
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (N : Value.t),
        M.IsTraitInstance
          "core::clone::Clone"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self N)
          (* Instance *) [ ("clone", InstanceField.Method (clone N)) ].
    End Impl_core_clone_Clone_for_alloy_primitives_map_fixed_FbHasher_N.
    
    Module Impl_core_default_Default_for_alloy_primitives_map_fixed_FbHasher_N.
      Definition Self (N : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::map::fixed::FbHasher") [ N ] [].
      
      (*
          fn default() -> Self {
              Self {
                  inner: DefaultHashBuilder::default().build_hasher(),
                  _marker: core::marker::PhantomData,
              }
          }
      *)
      Definition default (N : Value.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self N in
        match ε, τ, α with
        | [], [], [] =>
          ltac:(M.monadic
            (Value.mkStructRecord
              "alloy_primitives::map::fixed::FbHasher"
              [ N ]
              []
              [
                ("inner",
                  M.call_closure (|
                    Ty.path "foldhash::fast::FoldHasher",
                    M.get_trait_method (|
                      "core::hash::BuildHasher",
                      Ty.path "foldhash::fast::RandomState",
                      [],
                      [],
                      "build_hasher",
                      [],
                      []
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.alloc (|
                          Ty.path "foldhash::fast::RandomState",
                          M.call_closure (|
                            Ty.path "foldhash::fast::RandomState",
                            M.get_trait_method (|
                              "core::default::Default",
                              Ty.path "foldhash::fast::RandomState",
                              [],
                              [],
                              "default",
                              [],
                              []
                            |),
                            []
                          |)
                        |)
                      |)
                    ]
                  |));
                ("_marker",
                  Value.StructTuple
                    "core::marker::PhantomData"
                    []
                    [ Ty.apply (Ty.path "array") [ N ] [ Ty.tuple [] ] ]
                    [])
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (N : Value.t),
        M.IsTraitInstance
          "core::default::Default"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self N)
          (* Instance *) [ ("default", InstanceField.Method (default N)) ].
    End Impl_core_default_Default_for_alloy_primitives_map_fixed_FbHasher_N.
    
    Module Impl_core_fmt_Debug_for_alloy_primitives_map_fixed_FbHasher_N.
      Definition Self (N : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::map::fixed::FbHasher") [ N ] [].
      
      (*
          fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
              f.debug_struct("FbHasher").finish_non_exhaustive()
          }
      *)
      Definition fmt (N : Value.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self N in
        match ε, τ, α with
        | [], [], [ self; f ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply
                  (Ty.path "&")
                  []
                  [ Ty.apply (Ty.path "alloy_primitives::map::fixed::FbHasher") [ N ] [] ],
                self
              |) in
            let f :=
              M.alloc (| Ty.apply (Ty.path "&mut") [] [ Ty.path "core::fmt::Formatter" ], f |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "core::result::Result")
                []
                [ Ty.tuple []; Ty.path "core::fmt::Error" ],
              M.get_associated_function (|
                Ty.path "core::fmt::builders::DebugStruct",
                "finish_non_exhaustive",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.alloc (|
                    Ty.path "core::fmt::builders::DebugStruct",
                    M.call_closure (|
                      Ty.path "core::fmt::builders::DebugStruct",
                      M.get_associated_function (|
                        Ty.path "core::fmt::Formatter",
                        "debug_struct",
                        [],
                        []
                      |),
                      [
                        M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                        M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "FbHasher" |) |) |)
                      ]
                    |)
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (N : Value.t),
        M.IsTraitInstance
          "core::fmt::Debug"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self N)
          (* Instance *) [ ("fmt", InstanceField.Method (fmt N)) ].
    End Impl_core_fmt_Debug_for_alloy_primitives_map_fixed_FbHasher_N.
    
    Module Impl_core_hash_Hasher_for_alloy_primitives_map_fixed_FbHasher_N.
      Definition Self (N : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::map::fixed::FbHasher") [ N ] [].
      
      (*
          fn finish(&self) -> u64 {
              self.inner.finish()
          }
      *)
      Definition finish (N : Value.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self N in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply
                  (Ty.path "&")
                  []
                  [ Ty.apply (Ty.path "alloy_primitives::map::fixed::FbHasher") [ N ] [] ],
                self
              |) in
            M.call_closure (|
              Ty.path "u64",
              M.get_trait_method (|
                "core::hash::Hasher",
                Ty.path "foldhash::fast::FoldHasher",
                [],
                [],
                "finish",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.SubPointer.get_struct_record_field (|
                    M.deref (| M.read (| self |) |),
                    "alloy_primitives::map::fixed::FbHasher",
                    "inner"
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn write(&mut self, bytes: &[u8]) {
              assert_eq_unchecked!(bytes.len(), N);
              // Threshold decided by some basic micro-benchmarks with fxhash.
              if N > 32 {
                  self.inner.write(bytes);
              } else {
                  write_bytes_unrolled(&mut self.inner, bytes);
              }
          }
      *)
      Definition write (N : Value.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self N in
        match ε, τ, α with
        | [], [], [ self; bytes ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply
                  (Ty.path "&mut")
                  []
                  [ Ty.apply (Ty.path "alloy_primitives::map::fixed::FbHasher") [ N ] [] ],
                self
              |) in
            let bytes :=
              M.alloc (|
                Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                bytes
              |) in
            M.read (|
              let~ _ : Ty.tuple [] :=
                M.read (|
                  M.match_operator (|
                    Ty.tuple [],
                    M.alloc (| Ty.tuple [], Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ := M.use (M.alloc (| Ty.path "bool", Value.Bool true |)) in
                          let _ :=
                            is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          let~ _ : Ty.tuple [] :=
                            M.read (|
                              M.match_operator (|
                                Ty.tuple [],
                                M.alloc (|
                                  Ty.tuple
                                    [
                                      Ty.apply (Ty.path "&") [] [ Ty.path "usize" ];
                                      Ty.apply (Ty.path "&") [] [ Ty.path "usize" ]
                                    ],
                                  Value.Tuple
                                    [
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.alloc (|
                                          Ty.path "usize",
                                          M.call_closure (|
                                            Ty.path "usize",
                                            M.get_associated_function (|
                                              Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                                              "len",
                                              [],
                                              []
                                            |),
                                            [
                                              M.borrow (|
                                                Pointer.Kind.Ref,
                                                M.deref (| M.read (| bytes |) |)
                                              |)
                                            ]
                                          |)
                                        |)
                                      |);
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.alloc (| Ty.path "usize", N |)
                                      |)
                                    ]
                                |),
                                [
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                      let left_val :=
                                        M.copy (|
                                          Ty.apply (Ty.path "&") [] [ Ty.path "usize" ],
                                          γ0_0
                                        |) in
                                      let right_val :=
                                        M.copy (|
                                          Ty.apply (Ty.path "&") [] [ Ty.path "usize" ],
                                          γ0_1
                                        |) in
                                      M.match_operator (|
                                        Ty.tuple [],
                                        M.alloc (| Ty.tuple [], Value.Tuple [] |),
                                        [
                                          fun γ =>
                                            ltac:(M.monadic
                                              (let γ :=
                                                M.use
                                                  (M.alloc (|
                                                    Ty.path "bool",
                                                    UnOp.not (|
                                                      M.call_closure (|
                                                        Ty.path "bool",
                                                        BinOp.eq,
                                                        [
                                                          M.read (|
                                                            M.deref (| M.read (| left_val |) |)
                                                          |);
                                                          M.read (|
                                                            M.deref (| M.read (| right_val |) |)
                                                          |)
                                                        ]
                                                      |)
                                                    |)
                                                  |)) in
                                              let _ :=
                                                is_constant_or_break_match (|
                                                  M.read (| γ |),
                                                  Value.Bool true
                                                |) in
                                              M.alloc (|
                                                Ty.tuple [],
                                                M.never_to_any (|
                                                  M.read (|
                                                    let~ kind :
                                                        Ty.path "core::panicking::AssertKind" :=
                                                      Value.StructTuple
                                                        "core::panicking::AssertKind::Eq"
                                                        []
                                                        []
                                                        [] in
                                                    M.alloc (|
                                                      Ty.path "never",
                                                      M.call_closure (|
                                                        Ty.path "never",
                                                        M.get_function (|
                                                          "core::panicking::assert_failed",
                                                          [],
                                                          [ Ty.path "usize"; Ty.path "usize" ]
                                                        |),
                                                        [
                                                          M.read (| kind |);
                                                          M.borrow (|
                                                            Pointer.Kind.Ref,
                                                            M.deref (|
                                                              M.borrow (|
                                                                Pointer.Kind.Ref,
                                                                M.deref (| M.read (| left_val |) |)
                                                              |)
                                                            |)
                                                          |);
                                                          M.borrow (|
                                                            Pointer.Kind.Ref,
                                                            M.deref (|
                                                              M.borrow (|
                                                                Pointer.Kind.Ref,
                                                                M.deref (| M.read (| right_val |) |)
                                                              |)
                                                            |)
                                                          |);
                                                          Value.StructTuple
                                                            "core::option::Option::None"
                                                            []
                                                            [ Ty.path "core::fmt::Arguments" ]
                                                            []
                                                        ]
                                                      |)
                                                    |)
                                                  |)
                                                |)
                                              |)));
                                          fun γ =>
                                            ltac:(M.monadic
                                              (M.alloc (| Ty.tuple [], Value.Tuple [] |)))
                                        ]
                                      |)))
                                ]
                              |)
                            |) in
                          M.alloc (| Ty.tuple [], Value.Tuple [] |)));
                      fun γ =>
                        ltac:(M.monadic
                          (M.match_operator (|
                            Ty.tuple [],
                            M.alloc (| Ty.tuple [], Value.Tuple [] |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ :=
                                    M.use
                                      (M.alloc (|
                                        Ty.path "bool",
                                        M.call_closure (|
                                          Ty.path "bool",
                                          BinOp.ne,
                                          [
                                            M.call_closure (|
                                              Ty.path "usize",
                                              M.get_associated_function (|
                                                Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                                                "len",
                                                [],
                                                []
                                              |),
                                              [
                                                M.borrow (|
                                                  Pointer.Kind.Ref,
                                                  M.deref (| M.read (| bytes |) |)
                                                |)
                                              ]
                                            |);
                                            N
                                          ]
                                        |)
                                      |)) in
                                  let _ :=
                                    is_constant_or_break_match (|
                                      M.read (| γ |),
                                      Value.Bool true
                                    |) in
                                  M.alloc (|
                                    Ty.tuple [],
                                    M.never_to_any (|
                                      M.call_closure (|
                                        Ty.path "never",
                                        M.get_function (|
                                          "core::hint::unreachable_unchecked",
                                          [],
                                          []
                                        |),
                                        []
                                      |)
                                    |)
                                  |)));
                              fun γ => ltac:(M.monadic (M.alloc (| Ty.tuple [], Value.Tuple [] |)))
                            ]
                          |)))
                    ]
                  |)
                |) in
              M.match_operator (|
                Ty.tuple [],
                M.alloc (| Ty.tuple [], Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            Ty.path "bool",
                            M.call_closure (|
                              Ty.path "bool",
                              BinOp.gt,
                              [ N; Value.Integer IntegerKind.Usize 32 ]
                            |)
                          |)) in
                      let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      let~ _ : Ty.tuple [] :=
                        M.call_closure (|
                          Ty.tuple [],
                          M.get_trait_method (|
                            "core::hash::Hasher",
                            Ty.path "foldhash::fast::FoldHasher",
                            [],
                            [],
                            "write",
                            [],
                            []
                          |),
                          [
                            M.borrow (|
                              Pointer.Kind.MutRef,
                              M.SubPointer.get_struct_record_field (|
                                M.deref (| M.read (| self |) |),
                                "alloy_primitives::map::fixed::FbHasher",
                                "inner"
                              |)
                            |);
                            M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| bytes |) |) |)
                          ]
                        |) in
                      M.alloc (| Ty.tuple [], Value.Tuple [] |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let~ _ : Ty.tuple [] :=
                        M.call_closure (|
                          Ty.tuple [],
                          M.get_function (|
                            "alloy_primitives::map::fixed::write_bytes_unrolled",
                            [],
                            [ Ty.path "foldhash::fast::FoldHasher" ]
                          |),
                          [
                            M.borrow (|
                              Pointer.Kind.MutRef,
                              M.deref (|
                                M.borrow (|
                                  Pointer.Kind.MutRef,
                                  M.SubPointer.get_struct_record_field (|
                                    M.deref (| M.read (| self |) |),
                                    "alloy_primitives::map::fixed::FbHasher",
                                    "inner"
                                  |)
                                |)
                              |)
                            |);
                            M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| bytes |) |) |)
                          ]
                        |) in
                      M.alloc (| Ty.tuple [], Value.Tuple [] |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn write_usize(&mut self, i: usize) {
              debug_assert_eq!(i, N);
          }
      *)
      Definition write_usize
          (N : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self N in
        match ε, τ, α with
        | [], [], [ self; i ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply
                  (Ty.path "&mut")
                  []
                  [ Ty.apply (Ty.path "alloy_primitives::map::fixed::FbHasher") [ N ] [] ],
                self
              |) in
            let i := M.alloc (| Ty.path "usize", i |) in
            M.read (|
              let~ _ : Ty.tuple [] :=
                M.read (|
                  M.match_operator (|
                    Ty.tuple [],
                    M.alloc (| Ty.tuple [], Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ := M.use (M.alloc (| Ty.path "bool", Value.Bool true |)) in
                          let _ :=
                            is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          let~ _ : Ty.tuple [] :=
                            M.read (|
                              M.match_operator (|
                                Ty.tuple [],
                                M.alloc (|
                                  Ty.tuple
                                    [
                                      Ty.apply (Ty.path "&") [] [ Ty.path "usize" ];
                                      Ty.apply (Ty.path "&") [] [ Ty.path "usize" ]
                                    ],
                                  Value.Tuple
                                    [
                                      M.borrow (| Pointer.Kind.Ref, i |);
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.alloc (| Ty.path "usize", N |)
                                      |)
                                    ]
                                |),
                                [
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                      let left_val :=
                                        M.copy (|
                                          Ty.apply (Ty.path "&") [] [ Ty.path "usize" ],
                                          γ0_0
                                        |) in
                                      let right_val :=
                                        M.copy (|
                                          Ty.apply (Ty.path "&") [] [ Ty.path "usize" ],
                                          γ0_1
                                        |) in
                                      M.match_operator (|
                                        Ty.tuple [],
                                        M.alloc (| Ty.tuple [], Value.Tuple [] |),
                                        [
                                          fun γ =>
                                            ltac:(M.monadic
                                              (let γ :=
                                                M.use
                                                  (M.alloc (|
                                                    Ty.path "bool",
                                                    UnOp.not (|
                                                      M.call_closure (|
                                                        Ty.path "bool",
                                                        BinOp.eq,
                                                        [
                                                          M.read (|
                                                            M.deref (| M.read (| left_val |) |)
                                                          |);
                                                          M.read (|
                                                            M.deref (| M.read (| right_val |) |)
                                                          |)
                                                        ]
                                                      |)
                                                    |)
                                                  |)) in
                                              let _ :=
                                                is_constant_or_break_match (|
                                                  M.read (| γ |),
                                                  Value.Bool true
                                                |) in
                                              M.alloc (|
                                                Ty.tuple [],
                                                M.never_to_any (|
                                                  M.read (|
                                                    let~ kind :
                                                        Ty.path "core::panicking::AssertKind" :=
                                                      Value.StructTuple
                                                        "core::panicking::AssertKind::Eq"
                                                        []
                                                        []
                                                        [] in
                                                    M.alloc (|
                                                      Ty.path "never",
                                                      M.call_closure (|
                                                        Ty.path "never",
                                                        M.get_function (|
                                                          "core::panicking::assert_failed",
                                                          [],
                                                          [ Ty.path "usize"; Ty.path "usize" ]
                                                        |),
                                                        [
                                                          M.read (| kind |);
                                                          M.borrow (|
                                                            Pointer.Kind.Ref,
                                                            M.deref (|
                                                              M.borrow (|
                                                                Pointer.Kind.Ref,
                                                                M.deref (| M.read (| left_val |) |)
                                                              |)
                                                            |)
                                                          |);
                                                          M.borrow (|
                                                            Pointer.Kind.Ref,
                                                            M.deref (|
                                                              M.borrow (|
                                                                Pointer.Kind.Ref,
                                                                M.deref (| M.read (| right_val |) |)
                                                              |)
                                                            |)
                                                          |);
                                                          Value.StructTuple
                                                            "core::option::Option::None"
                                                            []
                                                            [ Ty.path "core::fmt::Arguments" ]
                                                            []
                                                        ]
                                                      |)
                                                    |)
                                                  |)
                                                |)
                                              |)));
                                          fun γ =>
                                            ltac:(M.monadic
                                              (M.alloc (| Ty.tuple [], Value.Tuple [] |)))
                                        ]
                                      |)))
                                ]
                              |)
                            |) in
                          M.alloc (| Ty.tuple [], Value.Tuple [] |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Ty.tuple [], Value.Tuple [] |)))
                    ]
                  |)
                |) in
              M.alloc (| Ty.tuple [], Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (N : Value.t),
        M.IsTraitInstance
          "core::hash::Hasher"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self N)
          (* Instance *)
          [
            ("finish", InstanceField.Method (finish N));
            ("write", InstanceField.Method (write N));
            ("write_usize", InstanceField.Method (write_usize N))
          ].
    End Impl_core_hash_Hasher_for_alloy_primitives_map_fixed_FbHasher_N.
    
    (*
    fn write_bytes_unrolled(hasher: &mut impl Hasher, mut bytes: &[u8]) {
        while let Some((chunk, rest)) = bytes.split_first_chunk() {
            hasher.write_usize(usize::from_ne_bytes( *chunk));
            bytes = rest;
        }
        if usize::BITS > 64 {
            if let Some((chunk, rest)) = bytes.split_first_chunk() {
                hasher.write_u64(u64::from_ne_bytes( *chunk));
                bytes = rest;
            }
        }
        if usize::BITS > 32 {
            if let Some((chunk, rest)) = bytes.split_first_chunk() {
                hasher.write_u32(u32::from_ne_bytes( *chunk));
                bytes = rest;
            }
        }
        if usize::BITS > 16 {
            if let Some((chunk, rest)) = bytes.split_first_chunk() {
                hasher.write_u16(u16::from_ne_bytes( *chunk));
                bytes = rest;
            }
        }
        if usize::BITS > 8 {
            if let Some((chunk, rest)) = bytes.split_first_chunk() {
                hasher.write_u8(u8::from_ne_bytes( *chunk));
                bytes = rest;
            }
        }
    
        debug_assert!(bytes.is_empty());
    }
    *)
    Definition write_bytes_unrolled (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [ impl_Hasher ], [ hasher; bytes ] =>
        ltac:(M.monadic
          (let hasher := M.alloc (| Ty.apply (Ty.path "&mut") [] [ impl_Hasher ], hasher |) in
          let bytes :=
            M.alloc (|
              Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
              bytes
            |) in
          M.read (|
            let~ _ : Ty.tuple [] :=
              M.read (|
                M.loop (|
                  Ty.tuple [],
                  ltac:(M.monadic
                    (M.match_operator (|
                      Ty.tuple [],
                      M.alloc (| Ty.tuple [], Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.alloc (|
                                Ty.apply
                                  (Ty.path "core::option::Option")
                                  []
                                  [
                                    Ty.tuple
                                      [
                                        Ty.apply
                                          (Ty.path "&")
                                          []
                                          [
                                            Ty.apply
                                              (Ty.path "array")
                                              [ Value.Integer IntegerKind.Usize 8 ]
                                              [ Ty.path "u8" ]
                                          ];
                                        Ty.apply
                                          (Ty.path "&")
                                          []
                                          [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
                                      ]
                                  ],
                                M.call_closure (|
                                  Ty.apply
                                    (Ty.path "core::option::Option")
                                    []
                                    [
                                      Ty.tuple
                                        [
                                          Ty.apply
                                            (Ty.path "&")
                                            []
                                            [
                                              Ty.apply
                                                (Ty.path "array")
                                                [ Value.Integer IntegerKind.Usize 8 ]
                                                [ Ty.path "u8" ]
                                            ];
                                          Ty.apply
                                            (Ty.path "&")
                                            []
                                            [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
                                        ]
                                    ],
                                  M.get_associated_function (|
                                    Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                                    "split_first_chunk",
                                    [ Value.Integer IntegerKind.Usize 8 ],
                                    []
                                  |),
                                  [
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.deref (| M.read (| bytes |) |)
                                    |)
                                  ]
                                |)
                              |) in
                            let γ0_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "core::option::Option::Some",
                                0
                              |) in
                            let γ1_0 := M.SubPointer.get_tuple_field (| γ0_0, 0 |) in
                            let γ1_1 := M.SubPointer.get_tuple_field (| γ0_0, 1 |) in
                            let chunk :=
                              M.copy (|
                                Ty.apply
                                  (Ty.path "&")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "array")
                                      [ Value.Integer IntegerKind.Usize 8 ]
                                      [ Ty.path "u8" ]
                                  ],
                                γ1_0
                              |) in
                            let rest :=
                              M.copy (|
                                Ty.apply
                                  (Ty.path "&")
                                  []
                                  [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                                γ1_1
                              |) in
                            let~ _ : Ty.tuple [] :=
                              M.call_closure (|
                                Ty.tuple [],
                                M.get_trait_method (|
                                  "core::hash::Hasher",
                                  impl_Hasher,
                                  [],
                                  [],
                                  "write_usize",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (|
                                    Pointer.Kind.MutRef,
                                    M.deref (| M.read (| hasher |) |)
                                  |);
                                  M.call_closure (|
                                    Ty.path "usize",
                                    M.get_associated_function (|
                                      Ty.path "usize",
                                      "from_ne_bytes",
                                      [],
                                      []
                                    |),
                                    [ M.read (| M.deref (| M.read (| chunk |) |) |) ]
                                  |)
                                ]
                              |) in
                            let~ _ : Ty.tuple [] :=
                              M.write (|
                                bytes,
                                M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| rest |) |) |)
                              |) in
                            M.alloc (| Ty.tuple [], Value.Tuple [] |)));
                        fun γ =>
                          ltac:(M.monadic
                            (M.alloc (|
                              Ty.tuple [],
                              M.never_to_any (|
                                M.read (|
                                  let~ _ : Ty.tuple [] :=
                                    M.never_to_any (| M.read (| M.break (||) |) |) in
                                  M.alloc (| Ty.tuple [], Value.Tuple [] |)
                                |)
                              |)
                            |)))
                      ]
                    |)))
                |)
              |) in
            let~ _ : Ty.tuple [] :=
              M.read (|
                M.match_operator (|
                  Ty.tuple [],
                  M.alloc (| Ty.tuple [], Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ :=
                          M.use
                            (M.alloc (|
                              Ty.path "bool",
                              M.call_closure (|
                                Ty.path "bool",
                                BinOp.gt,
                                [
                                  M.read (|
                                    get_associated_constant (|
                                      Ty.path "usize",
                                      "BITS",
                                      Ty.path "u32"
                                    |)
                                  |);
                                  Value.Integer IntegerKind.U32 64
                                ]
                              |)
                            |)) in
                        let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        M.match_operator (|
                          Ty.tuple [],
                          M.alloc (| Ty.tuple [], Value.Tuple [] |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ :=
                                  M.alloc (|
                                    Ty.apply
                                      (Ty.path "core::option::Option")
                                      []
                                      [
                                        Ty.tuple
                                          [
                                            Ty.apply
                                              (Ty.path "&")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "array")
                                                  [ Value.Integer IntegerKind.Usize 8 ]
                                                  [ Ty.path "u8" ]
                                              ];
                                            Ty.apply
                                              (Ty.path "&")
                                              []
                                              [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
                                          ]
                                      ],
                                    M.call_closure (|
                                      Ty.apply
                                        (Ty.path "core::option::Option")
                                        []
                                        [
                                          Ty.tuple
                                            [
                                              Ty.apply
                                                (Ty.path "&")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path "array")
                                                    [ Value.Integer IntegerKind.Usize 8 ]
                                                    [ Ty.path "u8" ]
                                                ];
                                              Ty.apply
                                                (Ty.path "&")
                                                []
                                                [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
                                            ]
                                        ],
                                      M.get_associated_function (|
                                        Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                                        "split_first_chunk",
                                        [ Value.Integer IntegerKind.Usize 8 ],
                                        []
                                      |),
                                      [
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.deref (| M.read (| bytes |) |)
                                        |)
                                      ]
                                    |)
                                  |) in
                                let γ0_0 :=
                                  M.SubPointer.get_struct_tuple_field (|
                                    γ,
                                    "core::option::Option::Some",
                                    0
                                  |) in
                                let γ1_0 := M.SubPointer.get_tuple_field (| γ0_0, 0 |) in
                                let γ1_1 := M.SubPointer.get_tuple_field (| γ0_0, 1 |) in
                                let chunk :=
                                  M.copy (|
                                    Ty.apply
                                      (Ty.path "&")
                                      []
                                      [
                                        Ty.apply
                                          (Ty.path "array")
                                          [ Value.Integer IntegerKind.Usize 8 ]
                                          [ Ty.path "u8" ]
                                      ],
                                    γ1_0
                                  |) in
                                let rest :=
                                  M.copy (|
                                    Ty.apply
                                      (Ty.path "&")
                                      []
                                      [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                                    γ1_1
                                  |) in
                                let~ _ : Ty.tuple [] :=
                                  M.call_closure (|
                                    Ty.tuple [],
                                    M.get_trait_method (|
                                      "core::hash::Hasher",
                                      impl_Hasher,
                                      [],
                                      [],
                                      "write_u64",
                                      [],
                                      []
                                    |),
                                    [
                                      M.borrow (|
                                        Pointer.Kind.MutRef,
                                        M.deref (| M.read (| hasher |) |)
                                      |);
                                      M.call_closure (|
                                        Ty.path "u64",
                                        M.get_associated_function (|
                                          Ty.path "u64",
                                          "from_ne_bytes",
                                          [],
                                          []
                                        |),
                                        [ M.read (| M.deref (| M.read (| chunk |) |) |) ]
                                      |)
                                    ]
                                  |) in
                                let~ _ : Ty.tuple [] :=
                                  M.write (|
                                    bytes,
                                    M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| rest |) |) |)
                                  |) in
                                M.alloc (| Ty.tuple [], Value.Tuple [] |)));
                            fun γ => ltac:(M.monadic (M.alloc (| Ty.tuple [], Value.Tuple [] |)))
                          ]
                        |)));
                    fun γ => ltac:(M.monadic (M.alloc (| Ty.tuple [], Value.Tuple [] |)))
                  ]
                |)
              |) in
            let~ _ : Ty.tuple [] :=
              M.read (|
                M.match_operator (|
                  Ty.tuple [],
                  M.alloc (| Ty.tuple [], Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ :=
                          M.use
                            (M.alloc (|
                              Ty.path "bool",
                              M.call_closure (|
                                Ty.path "bool",
                                BinOp.gt,
                                [
                                  M.read (|
                                    get_associated_constant (|
                                      Ty.path "usize",
                                      "BITS",
                                      Ty.path "u32"
                                    |)
                                  |);
                                  Value.Integer IntegerKind.U32 32
                                ]
                              |)
                            |)) in
                        let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        M.match_operator (|
                          Ty.tuple [],
                          M.alloc (| Ty.tuple [], Value.Tuple [] |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ :=
                                  M.alloc (|
                                    Ty.apply
                                      (Ty.path "core::option::Option")
                                      []
                                      [
                                        Ty.tuple
                                          [
                                            Ty.apply
                                              (Ty.path "&")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "array")
                                                  [ Value.Integer IntegerKind.Usize 4 ]
                                                  [ Ty.path "u8" ]
                                              ];
                                            Ty.apply
                                              (Ty.path "&")
                                              []
                                              [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
                                          ]
                                      ],
                                    M.call_closure (|
                                      Ty.apply
                                        (Ty.path "core::option::Option")
                                        []
                                        [
                                          Ty.tuple
                                            [
                                              Ty.apply
                                                (Ty.path "&")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path "array")
                                                    [ Value.Integer IntegerKind.Usize 4 ]
                                                    [ Ty.path "u8" ]
                                                ];
                                              Ty.apply
                                                (Ty.path "&")
                                                []
                                                [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
                                            ]
                                        ],
                                      M.get_associated_function (|
                                        Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                                        "split_first_chunk",
                                        [ Value.Integer IntegerKind.Usize 4 ],
                                        []
                                      |),
                                      [
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.deref (| M.read (| bytes |) |)
                                        |)
                                      ]
                                    |)
                                  |) in
                                let γ0_0 :=
                                  M.SubPointer.get_struct_tuple_field (|
                                    γ,
                                    "core::option::Option::Some",
                                    0
                                  |) in
                                let γ1_0 := M.SubPointer.get_tuple_field (| γ0_0, 0 |) in
                                let γ1_1 := M.SubPointer.get_tuple_field (| γ0_0, 1 |) in
                                let chunk :=
                                  M.copy (|
                                    Ty.apply
                                      (Ty.path "&")
                                      []
                                      [
                                        Ty.apply
                                          (Ty.path "array")
                                          [ Value.Integer IntegerKind.Usize 4 ]
                                          [ Ty.path "u8" ]
                                      ],
                                    γ1_0
                                  |) in
                                let rest :=
                                  M.copy (|
                                    Ty.apply
                                      (Ty.path "&")
                                      []
                                      [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                                    γ1_1
                                  |) in
                                let~ _ : Ty.tuple [] :=
                                  M.call_closure (|
                                    Ty.tuple [],
                                    M.get_trait_method (|
                                      "core::hash::Hasher",
                                      impl_Hasher,
                                      [],
                                      [],
                                      "write_u32",
                                      [],
                                      []
                                    |),
                                    [
                                      M.borrow (|
                                        Pointer.Kind.MutRef,
                                        M.deref (| M.read (| hasher |) |)
                                      |);
                                      M.call_closure (|
                                        Ty.path "u32",
                                        M.get_associated_function (|
                                          Ty.path "u32",
                                          "from_ne_bytes",
                                          [],
                                          []
                                        |),
                                        [ M.read (| M.deref (| M.read (| chunk |) |) |) ]
                                      |)
                                    ]
                                  |) in
                                let~ _ : Ty.tuple [] :=
                                  M.write (|
                                    bytes,
                                    M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| rest |) |) |)
                                  |) in
                                M.alloc (| Ty.tuple [], Value.Tuple [] |)));
                            fun γ => ltac:(M.monadic (M.alloc (| Ty.tuple [], Value.Tuple [] |)))
                          ]
                        |)));
                    fun γ => ltac:(M.monadic (M.alloc (| Ty.tuple [], Value.Tuple [] |)))
                  ]
                |)
              |) in
            let~ _ : Ty.tuple [] :=
              M.read (|
                M.match_operator (|
                  Ty.tuple [],
                  M.alloc (| Ty.tuple [], Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ :=
                          M.use
                            (M.alloc (|
                              Ty.path "bool",
                              M.call_closure (|
                                Ty.path "bool",
                                BinOp.gt,
                                [
                                  M.read (|
                                    get_associated_constant (|
                                      Ty.path "usize",
                                      "BITS",
                                      Ty.path "u32"
                                    |)
                                  |);
                                  Value.Integer IntegerKind.U32 16
                                ]
                              |)
                            |)) in
                        let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        M.match_operator (|
                          Ty.tuple [],
                          M.alloc (| Ty.tuple [], Value.Tuple [] |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ :=
                                  M.alloc (|
                                    Ty.apply
                                      (Ty.path "core::option::Option")
                                      []
                                      [
                                        Ty.tuple
                                          [
                                            Ty.apply
                                              (Ty.path "&")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "array")
                                                  [ Value.Integer IntegerKind.Usize 2 ]
                                                  [ Ty.path "u8" ]
                                              ];
                                            Ty.apply
                                              (Ty.path "&")
                                              []
                                              [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
                                          ]
                                      ],
                                    M.call_closure (|
                                      Ty.apply
                                        (Ty.path "core::option::Option")
                                        []
                                        [
                                          Ty.tuple
                                            [
                                              Ty.apply
                                                (Ty.path "&")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path "array")
                                                    [ Value.Integer IntegerKind.Usize 2 ]
                                                    [ Ty.path "u8" ]
                                                ];
                                              Ty.apply
                                                (Ty.path "&")
                                                []
                                                [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
                                            ]
                                        ],
                                      M.get_associated_function (|
                                        Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                                        "split_first_chunk",
                                        [ Value.Integer IntegerKind.Usize 2 ],
                                        []
                                      |),
                                      [
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.deref (| M.read (| bytes |) |)
                                        |)
                                      ]
                                    |)
                                  |) in
                                let γ0_0 :=
                                  M.SubPointer.get_struct_tuple_field (|
                                    γ,
                                    "core::option::Option::Some",
                                    0
                                  |) in
                                let γ1_0 := M.SubPointer.get_tuple_field (| γ0_0, 0 |) in
                                let γ1_1 := M.SubPointer.get_tuple_field (| γ0_0, 1 |) in
                                let chunk :=
                                  M.copy (|
                                    Ty.apply
                                      (Ty.path "&")
                                      []
                                      [
                                        Ty.apply
                                          (Ty.path "array")
                                          [ Value.Integer IntegerKind.Usize 2 ]
                                          [ Ty.path "u8" ]
                                      ],
                                    γ1_0
                                  |) in
                                let rest :=
                                  M.copy (|
                                    Ty.apply
                                      (Ty.path "&")
                                      []
                                      [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                                    γ1_1
                                  |) in
                                let~ _ : Ty.tuple [] :=
                                  M.call_closure (|
                                    Ty.tuple [],
                                    M.get_trait_method (|
                                      "core::hash::Hasher",
                                      impl_Hasher,
                                      [],
                                      [],
                                      "write_u16",
                                      [],
                                      []
                                    |),
                                    [
                                      M.borrow (|
                                        Pointer.Kind.MutRef,
                                        M.deref (| M.read (| hasher |) |)
                                      |);
                                      M.call_closure (|
                                        Ty.path "u16",
                                        M.get_associated_function (|
                                          Ty.path "u16",
                                          "from_ne_bytes",
                                          [],
                                          []
                                        |),
                                        [ M.read (| M.deref (| M.read (| chunk |) |) |) ]
                                      |)
                                    ]
                                  |) in
                                let~ _ : Ty.tuple [] :=
                                  M.write (|
                                    bytes,
                                    M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| rest |) |) |)
                                  |) in
                                M.alloc (| Ty.tuple [], Value.Tuple [] |)));
                            fun γ => ltac:(M.monadic (M.alloc (| Ty.tuple [], Value.Tuple [] |)))
                          ]
                        |)));
                    fun γ => ltac:(M.monadic (M.alloc (| Ty.tuple [], Value.Tuple [] |)))
                  ]
                |)
              |) in
            let~ _ : Ty.tuple [] :=
              M.read (|
                M.match_operator (|
                  Ty.tuple [],
                  M.alloc (| Ty.tuple [], Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ :=
                          M.use
                            (M.alloc (|
                              Ty.path "bool",
                              M.call_closure (|
                                Ty.path "bool",
                                BinOp.gt,
                                [
                                  M.read (|
                                    get_associated_constant (|
                                      Ty.path "usize",
                                      "BITS",
                                      Ty.path "u32"
                                    |)
                                  |);
                                  Value.Integer IntegerKind.U32 8
                                ]
                              |)
                            |)) in
                        let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        M.match_operator (|
                          Ty.tuple [],
                          M.alloc (| Ty.tuple [], Value.Tuple [] |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ :=
                                  M.alloc (|
                                    Ty.apply
                                      (Ty.path "core::option::Option")
                                      []
                                      [
                                        Ty.tuple
                                          [
                                            Ty.apply
                                              (Ty.path "&")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "array")
                                                  [ Value.Integer IntegerKind.Usize 1 ]
                                                  [ Ty.path "u8" ]
                                              ];
                                            Ty.apply
                                              (Ty.path "&")
                                              []
                                              [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
                                          ]
                                      ],
                                    M.call_closure (|
                                      Ty.apply
                                        (Ty.path "core::option::Option")
                                        []
                                        [
                                          Ty.tuple
                                            [
                                              Ty.apply
                                                (Ty.path "&")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path "array")
                                                    [ Value.Integer IntegerKind.Usize 1 ]
                                                    [ Ty.path "u8" ]
                                                ];
                                              Ty.apply
                                                (Ty.path "&")
                                                []
                                                [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
                                            ]
                                        ],
                                      M.get_associated_function (|
                                        Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                                        "split_first_chunk",
                                        [ Value.Integer IntegerKind.Usize 1 ],
                                        []
                                      |),
                                      [
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.deref (| M.read (| bytes |) |)
                                        |)
                                      ]
                                    |)
                                  |) in
                                let γ0_0 :=
                                  M.SubPointer.get_struct_tuple_field (|
                                    γ,
                                    "core::option::Option::Some",
                                    0
                                  |) in
                                let γ1_0 := M.SubPointer.get_tuple_field (| γ0_0, 0 |) in
                                let γ1_1 := M.SubPointer.get_tuple_field (| γ0_0, 1 |) in
                                let chunk :=
                                  M.copy (|
                                    Ty.apply
                                      (Ty.path "&")
                                      []
                                      [
                                        Ty.apply
                                          (Ty.path "array")
                                          [ Value.Integer IntegerKind.Usize 1 ]
                                          [ Ty.path "u8" ]
                                      ],
                                    γ1_0
                                  |) in
                                let rest :=
                                  M.copy (|
                                    Ty.apply
                                      (Ty.path "&")
                                      []
                                      [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                                    γ1_1
                                  |) in
                                let~ _ : Ty.tuple [] :=
                                  M.call_closure (|
                                    Ty.tuple [],
                                    M.get_trait_method (|
                                      "core::hash::Hasher",
                                      impl_Hasher,
                                      [],
                                      [],
                                      "write_u8",
                                      [],
                                      []
                                    |),
                                    [
                                      M.borrow (|
                                        Pointer.Kind.MutRef,
                                        M.deref (| M.read (| hasher |) |)
                                      |);
                                      M.call_closure (|
                                        Ty.path "u8",
                                        M.get_associated_function (|
                                          Ty.path "u8",
                                          "from_ne_bytes",
                                          [],
                                          []
                                        |),
                                        [ M.read (| M.deref (| M.read (| chunk |) |) |) ]
                                      |)
                                    ]
                                  |) in
                                let~ _ : Ty.tuple [] :=
                                  M.write (|
                                    bytes,
                                    M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| rest |) |) |)
                                  |) in
                                M.alloc (| Ty.tuple [], Value.Tuple [] |)));
                            fun γ => ltac:(M.monadic (M.alloc (| Ty.tuple [], Value.Tuple [] |)))
                          ]
                        |)));
                    fun γ => ltac:(M.monadic (M.alloc (| Ty.tuple [], Value.Tuple [] |)))
                  ]
                |)
              |) in
            let~ _ : Ty.tuple [] :=
              M.read (|
                M.match_operator (|
                  Ty.tuple [],
                  M.alloc (| Ty.tuple [], Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.use (M.alloc (| Ty.path "bool", Value.Bool true |)) in
                        let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        let~ _ : Ty.tuple [] :=
                          M.read (|
                            M.match_operator (|
                              Ty.tuple [],
                              M.alloc (| Ty.tuple [], Value.Tuple [] |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let γ :=
                                      M.use
                                        (M.alloc (|
                                          Ty.path "bool",
                                          UnOp.not (|
                                            M.call_closure (|
                                              Ty.path "bool",
                                              M.get_associated_function (|
                                                Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                                                "is_empty",
                                                [],
                                                []
                                              |),
                                              [
                                                M.borrow (|
                                                  Pointer.Kind.Ref,
                                                  M.deref (| M.read (| bytes |) |)
                                                |)
                                              ]
                                            |)
                                          |)
                                        |)) in
                                    let _ :=
                                      is_constant_or_break_match (|
                                        M.read (| γ |),
                                        Value.Bool true
                                      |) in
                                    M.alloc (|
                                      Ty.tuple [],
                                      M.never_to_any (|
                                        M.call_closure (|
                                          Ty.path "never",
                                          M.get_function (| "core::panicking::panic", [], [] |),
                                          [ mk_str (| "assertion failed: bytes.is_empty()" |) ]
                                        |)
                                      |)
                                    |)));
                                fun γ =>
                                  ltac:(M.monadic (M.alloc (| Ty.tuple [], Value.Tuple [] |)))
                              ]
                            |)
                          |) in
                        M.alloc (| Ty.tuple [], Value.Tuple [] |)));
                    fun γ => ltac:(M.monadic (M.alloc (| Ty.tuple [], Value.Tuple [] |)))
                  ]
                |)
              |) in
            M.alloc (| Ty.tuple [], Value.Tuple [] |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance Instance_IsFunction_write_bytes_unrolled :
      M.IsFunction.C "alloy_primitives::map::fixed::write_bytes_unrolled" write_bytes_unrolled.
    Admitted.
    Global Typeclasses Opaque write_bytes_unrolled.
  End fixed.
End map.
