(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module sealed.
  (* StructRecord
    {
      name := "Sealed";
      const_params := [];
      ty_params := [ "T" ];
      fields :=
        [
          ("inner", T);
          ("seal",
            Ty.apply
              (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
              [ Value.Integer IntegerKind.Usize 32 ]
              [])
        ];
    } *)
  
  Module Impl_core_clone_Clone_where_core_clone_Clone_T_for_alloy_primitives_sealed_Sealed_T.
    Definition Self (T : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "alloy_primitives::sealed::Sealed") [] [ T ].
    
    (* Clone *)
    Definition clone (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          Value.StructRecord
            "alloy_primitives::sealed::Sealed"
            [
              ("inner",
                M.call_closure (|
                  T,
                  M.get_trait_method (| "core::clone::Clone", T, [], [], "clone", [], [] |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "alloy_primitives::sealed::Sealed",
                            "inner"
                          |)
                        |)
                      |)
                    |)
                  ]
                |));
              ("seal",
                M.call_closure (|
                  Ty.apply
                    (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                    [ Value.Integer IntegerKind.Usize 32 ]
                    [],
                  M.get_trait_method (|
                    "core::clone::Clone",
                    Ty.apply
                      (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                      [ Value.Integer IntegerKind.Usize 32 ]
                      [],
                    [],
                    [],
                    "clone",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "alloy_primitives::sealed::Sealed",
                            "seal"
                          |)
                        |)
                      |)
                    |)
                  ]
                |))
            ]))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "core::clone::Clone"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self T)
        (* Instance *) [ ("clone", InstanceField.Method (clone T)) ].
  End Impl_core_clone_Clone_where_core_clone_Clone_T_for_alloy_primitives_sealed_Sealed_T.
  
  Module Impl_core_marker_Copy_where_core_marker_Copy_T_for_alloy_primitives_sealed_Sealed_T.
    Definition Self (T : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "alloy_primitives::sealed::Sealed") [] [ T ].
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "core::marker::Copy"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self T)
        (* Instance *) [].
  End Impl_core_marker_Copy_where_core_marker_Copy_T_for_alloy_primitives_sealed_Sealed_T.
  
  Module Impl_core_fmt_Debug_where_core_fmt_Debug_T_for_alloy_primitives_sealed_Sealed_T.
    Definition Self (T : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "alloy_primitives::sealed::Sealed") [] [ T ].
    
    (* Debug *)
    Definition fmt (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "core::result::Result")
              []
              [ Ty.tuple []; Ty.path "core::fmt::Error" ],
            M.get_associated_function (|
              Ty.path "core::fmt::Formatter",
              "debug_struct_field2_finish",
              [],
              []
            |),
            [
              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
              M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "Sealed" |) |) |);
              M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "inner" |) |) |);
              (* Unsize *)
              M.pointer_coercion
                (M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "alloy_primitives::sealed::Sealed",
                        "inner"
                      |)
                    |)
                  |)
                |));
              M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "seal" |) |) |);
              (* Unsize *)
              M.pointer_coercion
                (M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.alloc (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "alloy_primitives::sealed::Sealed",
                            "seal"
                          |)
                        |)
                      |)
                    |)
                  |)
                |))
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "core::fmt::Debug"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self T)
        (* Instance *) [ ("fmt", InstanceField.Method (fmt T)) ].
  End Impl_core_fmt_Debug_where_core_fmt_Debug_T_for_alloy_primitives_sealed_Sealed_T.
  
  Module Impl_core_marker_StructuralPartialEq_for_alloy_primitives_sealed_Sealed_T.
    Definition Self (T : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "alloy_primitives::sealed::Sealed") [] [ T ].
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "core::marker::StructuralPartialEq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self T)
        (* Instance *) [].
  End Impl_core_marker_StructuralPartialEq_for_alloy_primitives_sealed_Sealed_T.
  
  Module Impl_core_cmp_PartialEq_where_core_cmp_PartialEq_T_alloy_primitives_sealed_Sealed_T_for_alloy_primitives_sealed_Sealed_T.
    Definition Self (T : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "alloy_primitives::sealed::Sealed") [] [ T ].
    
    (* PartialEq *)
    Definition eq (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          LogicalOp.and (|
            M.call_closure (|
              Ty.path "bool",
              M.get_trait_method (| "core::cmp::PartialEq", T, [], [ T ], "eq", [], [] |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.SubPointer.get_struct_record_field (|
                    M.deref (| M.read (| self |) |),
                    "alloy_primitives::sealed::Sealed",
                    "inner"
                  |)
                |);
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.SubPointer.get_struct_record_field (|
                    M.deref (| M.read (| other |) |),
                    "alloy_primitives::sealed::Sealed",
                    "inner"
                  |)
                |)
              ]
            |),
            ltac:(M.monadic
              (M.call_closure (|
                Ty.path "bool",
                M.get_trait_method (|
                  "core::cmp::PartialEq",
                  Ty.apply
                    (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                    [ Value.Integer IntegerKind.Usize 32 ]
                    [],
                  [],
                  [
                    Ty.apply
                      (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                      [ Value.Integer IntegerKind.Usize 32 ]
                      []
                  ],
                  "eq",
                  [],
                  []
                |),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| self |) |),
                      "alloy_primitives::sealed::Sealed",
                      "seal"
                    |)
                  |);
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| other |) |),
                      "alloy_primitives::sealed::Sealed",
                      "seal"
                    |)
                  |)
                ]
              |)))
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "core::cmp::PartialEq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *)
        [ Ty.apply (Ty.path "alloy_primitives::sealed::Sealed") [] [ T ] ]
        (Self T)
        (* Instance *) [ ("eq", InstanceField.Method (eq T)) ].
  End Impl_core_cmp_PartialEq_where_core_cmp_PartialEq_T_alloy_primitives_sealed_Sealed_T_for_alloy_primitives_sealed_Sealed_T.
  
  Module Impl_core_cmp_Eq_where_core_cmp_Eq_T_for_alloy_primitives_sealed_Sealed_T.
    Definition Self (T : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "alloy_primitives::sealed::Sealed") [] [ T ].
    
    (* Eq *)
    Definition assert_receiver_is_total_eq
        (T : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              None,
              Value.DeclaredButUndefined,
              [
                fun γ =>
                  ltac:(M.monadic
                    (M.match_operator (|
                      None,
                      Value.DeclaredButUndefined,
                      [ fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |))) ]
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "core::cmp::Eq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self T)
        (* Instance *)
        [ ("assert_receiver_is_total_eq", InstanceField.Method (assert_receiver_is_total_eq T)) ].
  End Impl_core_cmp_Eq_where_core_cmp_Eq_T_for_alloy_primitives_sealed_Sealed_T.
  
  Module Impl_core_hash_Hash_where_core_hash_Hash_T_for_alloy_primitives_sealed_Sealed_T.
    Definition Self (T : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "alloy_primitives::sealed::Sealed") [] [ T ].
    
    (* Hash *)
    Definition hash (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [ __H ], [ self; state ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let state := M.alloc (| state |) in
          M.read (|
            let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
              M.alloc (|
                M.call_closure (|
                  Ty.tuple [],
                  M.get_trait_method (| "core::hash::Hash", T, [], [], "hash", [], [ __H ] |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "alloy_primitives::sealed::Sealed",
                            "inner"
                          |)
                        |)
                      |)
                    |);
                    M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                  ]
                |)
              |) in
            M.alloc (|
              M.call_closure (|
                Ty.tuple [],
                M.get_trait_method (|
                  "core::hash::Hash",
                  Ty.apply
                    (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                    [ Value.Integer IntegerKind.Usize 32 ]
                    [],
                  [],
                  [],
                  "hash",
                  [],
                  [ __H ]
                |),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "alloy_primitives::sealed::Sealed",
                          "seal"
                        |)
                      |)
                    |)
                  |);
                  M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                ]
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "core::hash::Hash"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self T)
        (* Instance *) [ ("hash", InstanceField.Method (hash T)) ].
  End Impl_core_hash_Hash_where_core_hash_Hash_T_for_alloy_primitives_sealed_Sealed_T.
  
  Module Impl_core_convert_AsRef_T_for_alloy_primitives_sealed_Sealed_T.
    Definition Self (T : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "alloy_primitives::sealed::Sealed") [] [ T ].
    
    (* AsRef *)
    Definition as_ref (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.borrow (|
            Pointer.Kind.Ref,
            M.deref (|
              M.borrow (|
                Pointer.Kind.Ref,
                M.SubPointer.get_struct_record_field (|
                  M.deref (| M.read (| self |) |),
                  "alloy_primitives::sealed::Sealed",
                  "inner"
                |)
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "core::convert::AsRef"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ T ]
        (Self T)
        (* Instance *) [ ("as_ref", InstanceField.Method (as_ref T)) ].
  End Impl_core_convert_AsRef_T_for_alloy_primitives_sealed_Sealed_T.
  
  Module Impl_core_ops_deref_Deref_for_alloy_primitives_sealed_Sealed_T.
    Definition Self (T : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "alloy_primitives::sealed::Sealed") [] [ T ].
    
    (* Deref *)
    Definition _Target (T : Ty.t) : Ty.t := T.
    
    (* Deref *)
    Definition deref (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.borrow (|
            Pointer.Kind.Ref,
            M.deref (|
              M.borrow (|
                Pointer.Kind.Ref,
                M.SubPointer.get_struct_record_field (|
                  M.deref (| M.read (| self |) |),
                  "alloy_primitives::sealed::Sealed",
                  "inner"
                |)
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "core::ops::deref::Deref"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self T)
        (* Instance *)
        [ ("Target", InstanceField.Ty (_Target T)); ("deref", InstanceField.Method (deref T)) ].
  End Impl_core_ops_deref_Deref_for_alloy_primitives_sealed_Sealed_T.
  
  Module Impl_alloy_primitives_sealed_Sealed_T.
    Definition Self (T : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "alloy_primitives::sealed::Sealed") [] [ T ].
    
    (*
        pub fn new(inner: T) -> Self
        where
            T: Sealable,
        {
            let seal = inner.hash_slow();
            Self { inner, seal }
        }
    *)
    Definition new (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [], [ inner ] =>
        ltac:(M.monadic
          (let inner := M.alloc (| inner |) in
          M.read (|
            let~ seal :
                Ty.apply
                  (Ty.path "*")
                  []
                  [
                    Ty.apply
                      (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                      [ Value.Integer IntegerKind.Usize 32 ]
                      []
                  ] :=
              M.alloc (|
                M.call_closure (|
                  Ty.apply
                    (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                    [ Value.Integer IntegerKind.Usize 32 ]
                    [],
                  M.get_trait_method (|
                    "alloy_primitives::sealed::Sealable",
                    T,
                    [],
                    [],
                    "hash_slow",
                    [],
                    []
                  |),
                  [ M.borrow (| Pointer.Kind.Ref, inner |) ]
                |)
              |) in
            M.alloc (|
              Value.StructRecord
                "alloy_primitives::sealed::Sealed"
                [ ("inner", M.read (| inner |)); ("seal", M.read (| seal |)) ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_new :
      forall (T : Ty.t),
      M.IsAssociatedFunction.C (Self T) "new" (new T).
    Admitted.
    Global Typeclasses Opaque new.
    
    (*
        pub fn new_ref(inner: &T) -> Sealed<&T>
        where
            T: Sealable,
        {
            let seal = inner.hash_slow();
            Sealed { inner, seal }
        }
    *)
    Definition new_ref (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [], [ inner ] =>
        ltac:(M.monadic
          (let inner := M.alloc (| inner |) in
          M.read (|
            let~ seal :
                Ty.apply
                  (Ty.path "*")
                  []
                  [
                    Ty.apply
                      (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                      [ Value.Integer IntegerKind.Usize 32 ]
                      []
                  ] :=
              M.alloc (|
                M.call_closure (|
                  Ty.apply
                    (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                    [ Value.Integer IntegerKind.Usize 32 ]
                    [],
                  M.get_trait_method (|
                    "alloy_primitives::sealed::Sealable",
                    T,
                    [],
                    [],
                    "hash_slow",
                    [],
                    []
                  |),
                  [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| inner |) |) |) ]
                |)
              |) in
            M.alloc (|
              Value.StructRecord
                "alloy_primitives::sealed::Sealed"
                [
                  ("inner", M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| inner |) |) |));
                  ("seal", M.read (| seal |))
                ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_new_ref :
      forall (T : Ty.t),
      M.IsAssociatedFunction.C (Self T) "new_ref" (new_ref T).
    Admitted.
    Global Typeclasses Opaque new_ref.
    
    (*
        pub fn new_with<F>(inner: T, f: F) -> Self
        where
            T: Sized,
            F: FnOnce(&T) -> B256,
        {
            let seal = f(&inner);
            Self::new_unchecked(inner, seal)
        }
    *)
    Definition new_with (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [ F ], [ inner; f ] =>
        ltac:(M.monadic
          (let inner := M.alloc (| inner |) in
          let f := M.alloc (| f |) in
          M.read (|
            let~ seal :
                Ty.apply
                  (Ty.path "*")
                  []
                  [
                    Ty.apply
                      (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                      [ Value.Integer IntegerKind.Usize 32 ]
                      []
                  ] :=
              M.alloc (|
                M.call_closure (|
                  Ty.apply
                    (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                    [ Value.Integer IntegerKind.Usize 32 ]
                    [],
                  M.get_trait_method (|
                    "core::ops::function::FnOnce",
                    F,
                    [],
                    [ Ty.tuple [ Ty.apply (Ty.path "&") [] [ T ] ] ],
                    "call_once",
                    [],
                    []
                  |),
                  [
                    M.read (| f |);
                    Value.Tuple
                      [
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.deref (| M.borrow (| Pointer.Kind.Ref, inner |) |)
                        |)
                      ]
                  ]
                |)
              |) in
            M.alloc (|
              M.call_closure (|
                Ty.apply (Ty.path "alloy_primitives::sealed::Sealed") [] [ T ],
                M.get_associated_function (|
                  Ty.apply (Ty.path "alloy_primitives::sealed::Sealed") [] [ T ],
                  "new_unchecked",
                  [],
                  []
                |),
                [ M.read (| inner |); M.read (| seal |) ]
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_new_with :
      forall (T : Ty.t),
      M.IsAssociatedFunction.C (Self T) "new_with" (new_with T).
    Admitted.
    Global Typeclasses Opaque new_with.
    
    (*
        pub fn new_ref_with<F>(inner: &T, f: F) -> Sealed<&T>
        where
            T: Sized,
            F: FnOnce(&T) -> B256,
        {
            let seal = f(inner);
            Sealed::new_unchecked(inner, seal)
        }
    *)
    Definition new_ref_with (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [ F ], [ inner; f ] =>
        ltac:(M.monadic
          (let inner := M.alloc (| inner |) in
          let f := M.alloc (| f |) in
          M.read (|
            let~ seal :
                Ty.apply
                  (Ty.path "*")
                  []
                  [
                    Ty.apply
                      (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                      [ Value.Integer IntegerKind.Usize 32 ]
                      []
                  ] :=
              M.alloc (|
                M.call_closure (|
                  Ty.apply
                    (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                    [ Value.Integer IntegerKind.Usize 32 ]
                    [],
                  M.get_trait_method (|
                    "core::ops::function::FnOnce",
                    F,
                    [],
                    [ Ty.tuple [ Ty.apply (Ty.path "&") [] [ T ] ] ],
                    "call_once",
                    [],
                    []
                  |),
                  [
                    M.read (| f |);
                    Value.Tuple
                      [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| inner |) |) |) ]
                  ]
                |)
              |) in
            M.alloc (|
              M.call_closure (|
                Ty.apply
                  (Ty.path "alloy_primitives::sealed::Sealed")
                  []
                  [ Ty.apply (Ty.path "&") [] [ T ] ],
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "alloy_primitives::sealed::Sealed")
                    []
                    [ Ty.apply (Ty.path "&") [] [ T ] ],
                  "new_unchecked",
                  [],
                  []
                |),
                [
                  M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| inner |) |) |);
                  M.read (| seal |)
                ]
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_new_ref_with :
      forall (T : Ty.t),
      M.IsAssociatedFunction.C (Self T) "new_ref_with" (new_ref_with T).
    Admitted.
    Global Typeclasses Opaque new_ref_with.
    
    (*
        pub const fn new_unchecked(inner: T, seal: B256) -> Self {
            Self { inner, seal }
        }
    *)
    Definition new_unchecked (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [], [ inner; seal ] =>
        ltac:(M.monadic
          (let inner := M.alloc (| inner |) in
          let seal := M.alloc (| seal |) in
          Value.StructRecord
            "alloy_primitives::sealed::Sealed"
            [ ("inner", M.read (| inner |)); ("seal", M.read (| seal |)) ]))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_new_unchecked :
      forall (T : Ty.t),
      M.IsAssociatedFunction.C (Self T) "new_unchecked" (new_unchecked T).
    Admitted.
    Global Typeclasses Opaque new_unchecked.
    
    (*
        pub fn into_parts(self) -> (T, B256) {
            (self.inner, self.seal)
        }
    *)
    Definition into_parts (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          Value.Tuple
            [
              M.read (|
                M.SubPointer.get_struct_record_field (|
                  self,
                  "alloy_primitives::sealed::Sealed",
                  "inner"
                |)
              |);
              M.read (|
                M.SubPointer.get_struct_record_field (|
                  self,
                  "alloy_primitives::sealed::Sealed",
                  "seal"
                |)
              |)
            ]))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_into_parts :
      forall (T : Ty.t),
      M.IsAssociatedFunction.C (Self T) "into_parts" (into_parts T).
    Admitted.
    Global Typeclasses Opaque into_parts.
    
    (*
        pub fn split(self) -> (T, B256) {
            self.into_parts()
        }
    *)
    Definition split (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            Ty.tuple
              [
                T;
                Ty.apply
                  (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                  [ Value.Integer IntegerKind.Usize 32 ]
                  []
              ],
            M.get_associated_function (|
              Ty.apply (Ty.path "alloy_primitives::sealed::Sealed") [] [ T ],
              "into_parts",
              [],
              []
            |),
            [ M.read (| self |) ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_split :
      forall (T : Ty.t),
      M.IsAssociatedFunction.C (Self T) "split" (split T).
    Admitted.
    Global Typeclasses Opaque split.
    
    (*
        pub const fn inner(&self) -> &T {
            &self.inner
        }
    *)
    Definition inner (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.borrow (|
            Pointer.Kind.Ref,
            M.deref (|
              M.borrow (|
                Pointer.Kind.Ref,
                M.SubPointer.get_struct_record_field (|
                  M.deref (| M.read (| self |) |),
                  "alloy_primitives::sealed::Sealed",
                  "inner"
                |)
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_inner :
      forall (T : Ty.t),
      M.IsAssociatedFunction.C (Self T) "inner" (inner T).
    Admitted.
    Global Typeclasses Opaque inner.
    
    (*
        pub const fn seal(&self) -> B256 {
            self.seal
        }
    *)
    Definition seal (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.SubPointer.get_struct_record_field (|
              M.deref (| M.read (| self |) |),
              "alloy_primitives::sealed::Sealed",
              "seal"
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_seal :
      forall (T : Ty.t),
      M.IsAssociatedFunction.C (Self T) "seal" (seal T).
    Admitted.
    Global Typeclasses Opaque seal.
    
    (*
        pub const fn hash(&self) -> B256 {
            self.seal
        }
    *)
    Definition hash (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.SubPointer.get_struct_record_field (|
              M.deref (| M.read (| self |) |),
              "alloy_primitives::sealed::Sealed",
              "seal"
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_hash :
      forall (T : Ty.t),
      M.IsAssociatedFunction.C (Self T) "hash" (hash T).
    Admitted.
    Global Typeclasses Opaque hash.
    
    (*
        pub fn into_inner(self) -> T {
            self.inner
        }
    *)
    Definition into_inner (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.SubPointer.get_struct_record_field (|
              self,
              "alloy_primitives::sealed::Sealed",
              "inner"
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_into_inner :
      forall (T : Ty.t),
      M.IsAssociatedFunction.C (Self T) "into_inner" (into_inner T).
    Admitted.
    Global Typeclasses Opaque into_inner.
    
    (*
        pub fn unseal(self) -> T {
            self.into_inner()
        }
    *)
    Definition unseal (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            T,
            M.get_associated_function (|
              Ty.apply (Ty.path "alloy_primitives::sealed::Sealed") [] [ T ],
              "into_inner",
              [],
              []
            |),
            [ M.read (| self |) ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_unseal :
      forall (T : Ty.t),
      M.IsAssociatedFunction.C (Self T) "unseal" (unseal T).
    Admitted.
    Global Typeclasses Opaque unseal.
  End Impl_alloy_primitives_sealed_Sealed_T.
  
  Module Impl_core_default_Default_where_alloy_primitives_sealed_Sealable_T_where_core_default_Default_T_for_alloy_primitives_sealed_Sealed_T.
    Definition Self (T : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "alloy_primitives::sealed::Sealed") [] [ T ].
    
    (*
        fn default() -> Self {
            T::default().seal_slow()
        }
    *)
    Definition default (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [], [] =>
        ltac:(M.monadic
          (M.call_closure (|
            Ty.apply (Ty.path "alloy_primitives::sealed::Sealed") [] [ T ],
            M.get_trait_method (|
              "alloy_primitives::sealed::Sealable",
              T,
              [],
              [],
              "seal_slow",
              [],
              []
            |),
            [
              M.call_closure (|
                T,
                M.get_trait_method (| "core::default::Default", T, [], [], "default", [], [] |),
                []
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "core::default::Default"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self T)
        (* Instance *) [ ("default", InstanceField.Method (default T)) ].
  End Impl_core_default_Default_where_alloy_primitives_sealed_Sealable_T_where_core_default_Default_T_for_alloy_primitives_sealed_Sealed_T.
  
  (* Trait *)
  Module Sealable.
    Definition seal_slow (Self : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            Ty.apply (Ty.path "alloy_primitives::sealed::Sealed") [] [ Self ],
            M.get_associated_function (|
              Ty.apply (Ty.path "alloy_primitives::sealed::Sealed") [] [ Self ],
              "new",
              [],
              []
            |),
            [ M.read (| self |) ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom ProvidedMethod_seal_slow :
      M.IsProvidedMethod "alloy_primitives::sealed::Sealable" "seal_slow" seal_slow.
    Definition seal_ref_slow
        (Self : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "alloy_primitives::sealed::Sealed")
              []
              [ Ty.apply (Ty.path "&") [] [ Self ] ],
            M.get_associated_function (|
              Ty.apply (Ty.path "alloy_primitives::sealed::Sealed") [] [ Self ],
              "new_ref",
              [],
              []
            |),
            [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom ProvidedMethod_seal_ref_slow :
      M.IsProvidedMethod "alloy_primitives::sealed::Sealable" "seal_ref_slow" seal_ref_slow.
    Definition seal_unchecked
        (Self : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      match ε, τ, α with
      | [], [], [ self; seal ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let seal := M.alloc (| seal |) in
          M.call_closure (|
            Ty.apply (Ty.path "alloy_primitives::sealed::Sealed") [] [ Self ],
            M.get_associated_function (|
              Ty.apply (Ty.path "alloy_primitives::sealed::Sealed") [] [ Self ],
              "new_unchecked",
              [],
              []
            |),
            [ M.read (| self |); M.read (| seal |) ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom ProvidedMethod_seal_unchecked :
      M.IsProvidedMethod "alloy_primitives::sealed::Sealable" "seal_unchecked" seal_unchecked.
    Definition seal_ref_unchecked
        (Self : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      match ε, τ, α with
      | [], [], [ self; seal ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let seal := M.alloc (| seal |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "alloy_primitives::sealed::Sealed")
              []
              [ Ty.apply (Ty.path "&") [] [ Self ] ],
            M.get_associated_function (|
              Ty.apply
                (Ty.path "alloy_primitives::sealed::Sealed")
                []
                [ Ty.apply (Ty.path "&") [] [ Self ] ],
              "new_unchecked",
              [],
              []
            |),
            [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |); M.read (| seal |) ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom ProvidedMethod_seal_ref_unchecked :
      M.IsProvidedMethod
        "alloy_primitives::sealed::Sealable"
        "seal_ref_unchecked"
        seal_ref_unchecked.
  End Sealable.
End sealed.
