(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module signature.
  Module parity.
    (*
    Enum Parity
    {
      const_params := [];
      ty_params := [];
      variants :=
        [
          {
            name := "Eip155";
            item := StructTuple [ Ty.path "u64" ];
          };
          {
            name := "NonEip155";
            item := StructTuple [ Ty.path "bool" ];
          };
          {
            name := "Parity";
            item := StructTuple [ Ty.path "bool" ];
          }
        ];
    }
    *)
    
    Axiom IsDiscriminant_Parity_Eip155 :
      M.IsDiscriminant "alloy_primitives::signature::parity::Parity::Eip155" 0.
    Axiom IsDiscriminant_Parity_NonEip155 :
      M.IsDiscriminant "alloy_primitives::signature::parity::Parity::NonEip155" 1.
    Axiom IsDiscriminant_Parity_Parity :
      M.IsDiscriminant "alloy_primitives::signature::parity::Parity::Parity" 2.
    
    Module Impl_core_clone_Clone_for_alloy_primitives_signature_parity_Parity.
      Definition Self : Ty.t := Ty.path "alloy_primitives::signature::parity::Parity".
      
      (* Clone *)
      Definition clone (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                None,
                Value.DeclaredButUndefined,
                [
                  fun γ =>
                    ltac:(M.monadic
                      (M.match_operator (|
                        None,
                        Value.DeclaredButUndefined,
                        [ fun γ => ltac:(M.monadic (M.deref (| M.read (| self |) |))) ]
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::clone::Clone"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [ ("clone", InstanceField.Method clone) ].
    End Impl_core_clone_Clone_for_alloy_primitives_signature_parity_Parity.
    
    Module Impl_core_marker_Copy_for_alloy_primitives_signature_parity_Parity.
      Definition Self : Ty.t := Ty.path "alloy_primitives::signature::parity::Parity".
      
      Axiom Implements :
        M.IsTraitInstance
          "core::marker::Copy"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [].
    End Impl_core_marker_Copy_for_alloy_primitives_signature_parity_Parity.
    
    Module Impl_core_fmt_Debug_for_alloy_primitives_signature_parity_Parity.
      Definition Self : Ty.t := Ty.path "alloy_primitives::signature::parity::Parity".
      
      (* Debug *)
      Definition fmt (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.read (|
              M.match_operator (|
                Some
                  (Ty.apply
                    (Ty.path "core::result::Result")
                    []
                    [ Ty.tuple []; Ty.path "core::fmt::Error" ]),
                self,
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.read (| γ |) in
                      let γ1_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "alloy_primitives::signature::parity::Parity::Eip155",
                          0
                        |) in
                      let __self_0 := M.alloc (| γ1_0 |) in
                      M.alloc (|
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "core::result::Result")
                            []
                            [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                          M.get_associated_function (|
                            Ty.path "core::fmt::Formatter",
                            "debug_tuple_field1_finish",
                            [],
                            []
                          |),
                          [
                            M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                            M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "Eip155" |) |) |);
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.deref (| M.borrow (| Pointer.Kind.Ref, __self_0 |) |)
                            |)
                          ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.read (| γ |) in
                      let γ1_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "alloy_primitives::signature::parity::Parity::NonEip155",
                          0
                        |) in
                      let __self_0 := M.alloc (| γ1_0 |) in
                      M.alloc (|
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "core::result::Result")
                            []
                            [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                          M.get_associated_function (|
                            Ty.path "core::fmt::Formatter",
                            "debug_tuple_field1_finish",
                            [],
                            []
                          |),
                          [
                            M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                            M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "NonEip155" |) |) |);
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.deref (| M.borrow (| Pointer.Kind.Ref, __self_0 |) |)
                            |)
                          ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.read (| γ |) in
                      let γ1_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "alloy_primitives::signature::parity::Parity::Parity",
                          0
                        |) in
                      let __self_0 := M.alloc (| γ1_0 |) in
                      M.alloc (|
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "core::result::Result")
                            []
                            [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                          M.get_associated_function (|
                            Ty.path "core::fmt::Formatter",
                            "debug_tuple_field1_finish",
                            [],
                            []
                          |),
                          [
                            M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                            M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "Parity" |) |) |);
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.deref (| M.borrow (| Pointer.Kind.Ref, __self_0 |) |)
                            |)
                          ]
                        |)
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::Debug"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
    End Impl_core_fmt_Debug_for_alloy_primitives_signature_parity_Parity.
    
    Module Impl_core_hash_Hash_for_alloy_primitives_signature_parity_Parity.
      Definition Self : Ty.t := Ty.path "alloy_primitives::signature::parity::Parity".
      
      (* Hash *)
      Definition hash (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [ __H ], [ self; state ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let state := M.alloc (| state |) in
            M.read (|
              let~ __self_discr : Ty.path "isize" :=
                M.alloc (|
                  M.call_closure (|
                    Ty.path "isize",
                    M.get_function (|
                      "core::intrinsics::discriminant_value",
                      [],
                      [ Ty.path "alloy_primitives::signature::parity::Parity" ]
                    |),
                    [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                  |)
                |) in
              let~ _ : Ty.tuple [] :=
                M.alloc (|
                  M.call_closure (|
                    Ty.tuple [],
                    M.get_trait_method (|
                      "core::hash::Hash",
                      Ty.path "isize",
                      [],
                      [],
                      "hash",
                      [],
                      [ __H ]
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.deref (| M.borrow (| Pointer.Kind.Ref, __self_discr |) |)
                      |);
                      M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                    ]
                  |)
                |) in
              M.match_operator (|
                Some (Ty.tuple []),
                self,
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.read (| γ |) in
                      let γ1_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "alloy_primitives::signature::parity::Parity::Eip155",
                          0
                        |) in
                      let __self_0 := M.alloc (| γ1_0 |) in
                      M.alloc (|
                        M.call_closure (|
                          Ty.tuple [],
                          M.get_trait_method (|
                            "core::hash::Hash",
                            Ty.path "u64",
                            [],
                            [],
                            "hash",
                            [],
                            [ __H ]
                          |),
                          [
                            M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_0 |) |) |);
                            M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                          ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.read (| γ |) in
                      let γ1_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "alloy_primitives::signature::parity::Parity::NonEip155",
                          0
                        |) in
                      let __self_0 := M.alloc (| γ1_0 |) in
                      M.alloc (|
                        M.call_closure (|
                          Ty.tuple [],
                          M.get_trait_method (|
                            "core::hash::Hash",
                            Ty.path "bool",
                            [],
                            [],
                            "hash",
                            [],
                            [ __H ]
                          |),
                          [
                            M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_0 |) |) |);
                            M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                          ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.read (| γ |) in
                      let γ1_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "alloy_primitives::signature::parity::Parity::Parity",
                          0
                        |) in
                      let __self_0 := M.alloc (| γ1_0 |) in
                      M.alloc (|
                        M.call_closure (|
                          Ty.tuple [],
                          M.get_trait_method (|
                            "core::hash::Hash",
                            Ty.path "bool",
                            [],
                            [],
                            "hash",
                            [],
                            [ __H ]
                          |),
                          [
                            M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_0 |) |) |);
                            M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                          ]
                        |)
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::hash::Hash"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [ ("hash", InstanceField.Method hash) ].
    End Impl_core_hash_Hash_for_alloy_primitives_signature_parity_Parity.
    
    Module Impl_core_marker_StructuralPartialEq_for_alloy_primitives_signature_parity_Parity.
      Definition Self : Ty.t := Ty.path "alloy_primitives::signature::parity::Parity".
      
      Axiom Implements :
        M.IsTraitInstance
          "core::marker::StructuralPartialEq"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [].
    End Impl_core_marker_StructuralPartialEq_for_alloy_primitives_signature_parity_Parity.
    
    Module Impl_core_cmp_PartialEq_alloy_primitives_signature_parity_Parity_for_alloy_primitives_signature_parity_Parity.
      Definition Self : Ty.t := Ty.path "alloy_primitives::signature::parity::Parity".
      
      (* PartialEq *)
      Definition eq (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let~ __self_discr : Ty.path "isize" :=
                M.alloc (|
                  M.call_closure (|
                    Ty.path "isize",
                    M.get_function (|
                      "core::intrinsics::discriminant_value",
                      [],
                      [ Ty.path "alloy_primitives::signature::parity::Parity" ]
                    |),
                    [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                  |)
                |) in
              let~ __arg1_discr : Ty.path "isize" :=
                M.alloc (|
                  M.call_closure (|
                    Ty.path "isize",
                    M.get_function (|
                      "core::intrinsics::discriminant_value",
                      [],
                      [ Ty.path "alloy_primitives::signature::parity::Parity" ]
                    |),
                    [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| other |) |) |) ]
                  |)
                |) in
              M.alloc (|
                LogicalOp.and (|
                  BinOp.eq (| M.read (| __self_discr |), M.read (| __arg1_discr |) |),
                  ltac:(M.monadic
                    (M.read (|
                      M.match_operator (|
                        Some (Ty.path "bool"),
                        M.alloc (| Value.Tuple [ M.read (| self |); M.read (| other |) ] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                              let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                              let γ0_0 := M.read (| γ0_0 |) in
                              let γ2_0 :=
                                M.SubPointer.get_struct_tuple_field (|
                                  γ0_0,
                                  "alloy_primitives::signature::parity::Parity::Eip155",
                                  0
                                |) in
                              let __self_0 := M.alloc (| γ2_0 |) in
                              let γ0_1 := M.read (| γ0_1 |) in
                              let γ2_0 :=
                                M.SubPointer.get_struct_tuple_field (|
                                  γ0_1,
                                  "alloy_primitives::signature::parity::Parity::Eip155",
                                  0
                                |) in
                              let __arg1_0 := M.alloc (| γ2_0 |) in
                              M.alloc (|
                                M.call_closure (|
                                  Ty.path "bool",
                                  M.get_trait_method (|
                                    "core::cmp::PartialEq",
                                    Ty.apply (Ty.path "&") [] [ Ty.path "u64" ],
                                    [],
                                    [ Ty.apply (Ty.path "&") [] [ Ty.path "u64" ] ],
                                    "eq",
                                    [],
                                    []
                                  |),
                                  [
                                    M.borrow (| Pointer.Kind.Ref, __self_0 |);
                                    M.borrow (| Pointer.Kind.Ref, __arg1_0 |)
                                  ]
                                |)
                              |)));
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                              let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                              let γ0_0 := M.read (| γ0_0 |) in
                              let γ2_0 :=
                                M.SubPointer.get_struct_tuple_field (|
                                  γ0_0,
                                  "alloy_primitives::signature::parity::Parity::NonEip155",
                                  0
                                |) in
                              let __self_0 := M.alloc (| γ2_0 |) in
                              let γ0_1 := M.read (| γ0_1 |) in
                              let γ2_0 :=
                                M.SubPointer.get_struct_tuple_field (|
                                  γ0_1,
                                  "alloy_primitives::signature::parity::Parity::NonEip155",
                                  0
                                |) in
                              let __arg1_0 := M.alloc (| γ2_0 |) in
                              M.alloc (|
                                M.call_closure (|
                                  Ty.path "bool",
                                  M.get_trait_method (|
                                    "core::cmp::PartialEq",
                                    Ty.apply (Ty.path "&") [] [ Ty.path "bool" ],
                                    [],
                                    [ Ty.apply (Ty.path "&") [] [ Ty.path "bool" ] ],
                                    "eq",
                                    [],
                                    []
                                  |),
                                  [
                                    M.borrow (| Pointer.Kind.Ref, __self_0 |);
                                    M.borrow (| Pointer.Kind.Ref, __arg1_0 |)
                                  ]
                                |)
                              |)));
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                              let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                              let γ0_0 := M.read (| γ0_0 |) in
                              let γ2_0 :=
                                M.SubPointer.get_struct_tuple_field (|
                                  γ0_0,
                                  "alloy_primitives::signature::parity::Parity::Parity",
                                  0
                                |) in
                              let __self_0 := M.alloc (| γ2_0 |) in
                              let γ0_1 := M.read (| γ0_1 |) in
                              let γ2_0 :=
                                M.SubPointer.get_struct_tuple_field (|
                                  γ0_1,
                                  "alloy_primitives::signature::parity::Parity::Parity",
                                  0
                                |) in
                              let __arg1_0 := M.alloc (| γ2_0 |) in
                              M.alloc (|
                                M.call_closure (|
                                  Ty.path "bool",
                                  M.get_trait_method (|
                                    "core::cmp::PartialEq",
                                    Ty.apply (Ty.path "&") [] [ Ty.path "bool" ],
                                    [],
                                    [ Ty.apply (Ty.path "&") [] [ Ty.path "bool" ] ],
                                    "eq",
                                    [],
                                    []
                                  |),
                                  [
                                    M.borrow (| Pointer.Kind.Ref, __self_0 |);
                                    M.borrow (| Pointer.Kind.Ref, __arg1_0 |)
                                  ]
                                |)
                              |)));
                          fun γ =>
                            ltac:(M.monadic
                              (M.alloc (|
                                M.never_to_any (|
                                  M.call_closure (|
                                    Ty.path "never",
                                    M.get_function (| "core::intrinsics::unreachable", [], [] |),
                                    []
                                  |)
                                |)
                              |)))
                        ]
                      |)
                    |)))
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::cmp::PartialEq"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "alloy_primitives::signature::parity::Parity" ]
          Self
          (* Instance *) [ ("eq", InstanceField.Method eq) ].
    End Impl_core_cmp_PartialEq_alloy_primitives_signature_parity_Parity_for_alloy_primitives_signature_parity_Parity.
    
    Module Impl_core_cmp_Eq_for_alloy_primitives_signature_parity_Parity.
      Definition Self : Ty.t := Ty.path "alloy_primitives::signature::parity::Parity".
      
      (* Eq *)
      Definition assert_receiver_is_total_eq
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                None,
                Value.DeclaredButUndefined,
                [
                  fun γ =>
                    ltac:(M.monadic
                      (M.match_operator (|
                        None,
                        Value.DeclaredButUndefined,
                        [ fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |))) ]
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::cmp::Eq"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *)
          [ ("assert_receiver_is_total_eq", InstanceField.Method assert_receiver_is_total_eq) ].
    End Impl_core_cmp_Eq_for_alloy_primitives_signature_parity_Parity.
    
    Module Impl_core_default_Default_for_alloy_primitives_signature_parity_Parity.
      Definition Self : Ty.t := Ty.path "alloy_primitives::signature::parity::Parity".
      
      (*
          fn default() -> Self {
              Self::Parity(false)
          }
      *)
      Definition default (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [] =>
          ltac:(M.monadic
            (Value.StructTuple
              "alloy_primitives::signature::parity::Parity::Parity"
              [ Value.Bool false ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::default::Default"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [ ("default", InstanceField.Method default) ].
    End Impl_core_default_Default_for_alloy_primitives_signature_parity_Parity.
    
    Module Impl_core_convert_TryFrom_ruint_Uint_Usize_64_Usize_1_for_alloy_primitives_signature_parity_Parity.
      Definition Self : Ty.t := Ty.path "alloy_primitives::signature::parity::Parity".
      
      (*     type Error = <Self as TryFrom<u64>>::Error; *)
      Definition _Error : Ty.t :=
        Ty.associated_in_trait
          "core::convert::TryFrom"
          []
          [ Ty.path "u64" ]
          (Ty.path "alloy_primitives::signature::parity::Parity")
          "Error".
      
      (*
          fn try_from(value: U64) -> Result<Self, Self::Error> {
              value.as_limbs()[0].try_into()
          }
      *)
      Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "core::result::Result")
                []
                [
                  Ty.path "alloy_primitives::signature::parity::Parity";
                  Ty.path "alloy_primitives::signature::error::SignatureError"
                ],
              M.get_trait_method (|
                "core::convert::TryInto",
                Ty.path "u64",
                [],
                [ Ty.path "alloy_primitives::signature::parity::Parity" ],
                "try_into",
                [],
                []
              |),
              [
                M.read (|
                  M.SubPointer.get_array_field (|
                    M.deref (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "&")
                          []
                          [
                            Ty.apply
                              (Ty.path "array")
                              [ Value.Integer IntegerKind.Usize 1 ]
                              [ Ty.path "u64" ]
                          ],
                        M.get_associated_function (|
                          Ty.apply
                            (Ty.path "ruint::Uint")
                            [ Value.Integer IntegerKind.Usize 64; Value.Integer IntegerKind.Usize 1
                            ]
                            [],
                          "as_limbs",
                          [],
                          []
                        |),
                        [ M.borrow (| Pointer.Kind.Ref, value |) ]
                      |)
                    |),
                    Value.Integer IntegerKind.Usize 0
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::TryFrom"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [
            Ty.apply
              (Ty.path "ruint::Uint")
              [ Value.Integer IntegerKind.Usize 64; Value.Integer IntegerKind.Usize 1 ]
              []
          ]
          Self
          (* Instance *)
          [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
    End Impl_core_convert_TryFrom_ruint_Uint_Usize_64_Usize_1_for_alloy_primitives_signature_parity_Parity.
    
    Module Impl_core_convert_From_ruint_Uint_Usize_1_Usize_1_for_alloy_primitives_signature_parity_Parity.
      Definition Self : Ty.t := Ty.path "alloy_primitives::signature::parity::Parity".
      
      (*
          fn from(value: Uint<1, 1>) -> Self {
              Self::Parity(!value.is_zero())
          }
      *)
      Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            Value.StructTuple
              "alloy_primitives::signature::parity::Parity::Parity"
              [
                UnOp.not (|
                  M.call_closure (|
                    Ty.path "bool",
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "ruint::Uint")
                        [ Value.Integer IntegerKind.Usize 1; Value.Integer IntegerKind.Usize 1 ]
                        [],
                      "is_zero",
                      [],
                      []
                    |),
                    [ M.borrow (| Pointer.Kind.Ref, value |) ]
                  |)
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [
            Ty.apply
              (Ty.path "ruint::Uint")
              [ Value.Integer IntegerKind.Usize 1; Value.Integer IntegerKind.Usize 1 ]
              []
          ]
          Self
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_ruint_Uint_Usize_1_Usize_1_for_alloy_primitives_signature_parity_Parity.
    
    Module Impl_core_convert_From_bool_for_alloy_primitives_signature_parity_Parity.
      Definition Self : Ty.t := Ty.path "alloy_primitives::signature::parity::Parity".
      
      (*
          fn from(value: bool) -> Self {
              Self::Parity(value)
          }
      *)
      Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            Value.StructTuple
              "alloy_primitives::signature::parity::Parity::Parity"
              [ M.read (| value |) ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "bool" ]
          Self
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_bool_for_alloy_primitives_signature_parity_Parity.
    
    Module Impl_core_convert_TryFrom_u64_for_alloy_primitives_signature_parity_Parity.
      Definition Self : Ty.t := Ty.path "alloy_primitives::signature::parity::Parity".
      
      (*     type Error = SignatureError; *)
      Definition _Error : Ty.t := Ty.path "alloy_primitives::signature::error::SignatureError".
      
      (*
          fn try_from(value: u64) -> Result<Self, Self::Error> {
              match value {
                  0 | 1 => Ok(Self::Parity(value != 0)),
                  27 | 28 => Ok(Self::NonEip155((value - 27) != 0)),
                  value @ 35..=u64::MAX => Ok(Self::Eip155(value)),
                  _ => Err(SignatureError::InvalidParity(value)),
              }
          }
      *)
      Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            M.read (|
              M.match_operator (|
                Some
                  (Ty.apply
                    (Ty.path "core::result::Result")
                    []
                    [
                      Ty.path "alloy_primitives::signature::parity::Parity";
                      Ty.path "alloy_primitives::signature::error::SignatureError"
                    ]),
                value,
                [
                  fun γ =>
                    ltac:(M.monadic
                      (M.find_or_pattern (|
                        γ,
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let _ :=
                                M.is_constant_or_break_match (|
                                  M.read (| γ |),
                                  Value.Integer IntegerKind.U64 0
                                |) in
                              Value.Tuple []));
                          fun γ =>
                            ltac:(M.monadic
                              (let _ :=
                                M.is_constant_or_break_match (|
                                  M.read (| γ |),
                                  Value.Integer IntegerKind.U64 1
                                |) in
                              Value.Tuple []))
                        ],
                        fun γ =>
                          ltac:(M.monadic
                            match γ with
                            | [] =>
                              ltac:(M.monadic
                                (M.alloc (|
                                  Value.StructTuple
                                    "core::result::Result::Ok"
                                    [
                                      Value.StructTuple
                                        "alloy_primitives::signature::parity::Parity::Parity"
                                        [
                                          BinOp.ne (|
                                            M.read (| value |),
                                            Value.Integer IntegerKind.U64 0
                                          |)
                                        ]
                                    ]
                                |)))
                            | _ => M.impossible "wrong number of arguments"
                            end)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.find_or_pattern (|
                        γ,
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let _ :=
                                M.is_constant_or_break_match (|
                                  M.read (| γ |),
                                  Value.Integer IntegerKind.U64 27
                                |) in
                              Value.Tuple []));
                          fun γ =>
                            ltac:(M.monadic
                              (let _ :=
                                M.is_constant_or_break_match (|
                                  M.read (| γ |),
                                  Value.Integer IntegerKind.U64 28
                                |) in
                              Value.Tuple []))
                        ],
                        fun γ =>
                          ltac:(M.monadic
                            match γ with
                            | [] =>
                              ltac:(M.monadic
                                (M.alloc (|
                                  Value.StructTuple
                                    "core::result::Result::Ok"
                                    [
                                      Value.StructTuple
                                        "alloy_primitives::signature::parity::Parity::NonEip155"
                                        [
                                          BinOp.ne (|
                                            BinOp.Wrap.sub (|
                                              M.read (| value |),
                                              Value.Integer IntegerKind.U64 27
                                            |),
                                            Value.Integer IntegerKind.U64 0
                                          |)
                                        ]
                                    ]
                                |)))
                            | _ => M.impossible "wrong number of arguments"
                            end)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let value := M.copy (| γ |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::result::Result::Ok"
                          [
                            Value.StructTuple
                              "alloy_primitives::signature::parity::Parity::Eip155"
                              [ M.read (| value |) ]
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (|
                        Value.StructTuple
                          "core::result::Result::Err"
                          [
                            Value.StructTuple
                              "alloy_primitives::signature::error::SignatureError::InvalidParity"
                              [ M.read (| value |) ]
                          ]
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::TryFrom"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u64" ]
          Self
          (* Instance *)
          [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
    End Impl_core_convert_TryFrom_u64_for_alloy_primitives_signature_parity_Parity.
    
    Module Impl_alloy_primitives_signature_parity_Parity.
      Definition Self : Ty.t := Ty.path "alloy_primitives::signature::parity::Parity".
      
      (*
          pub const fn chain_id(&self) -> Option<ChainId> {
              match *self {
                  Self::Eip155(mut v @ 35..) => {
                      if v % 2 == 0 {
                          v -= 1;
                      }
                      v -= 35;
                      Some(v / 2)
                  }
                  _ => None,
              }
          }
      *)
      Definition chain_id (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                Some (Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "u64" ]),
                M.deref (| M.read (| self |) |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "alloy_primitives::signature::parity::Parity::Eip155",
                          0
                        |) in
                      let v := M.copy (| γ0_0 |) in
                      let~ _ : Ty.tuple [] :=
                        M.match_operator (|
                          Some (Ty.tuple []),
                          M.alloc (| Value.Tuple [] |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ :=
                                  M.use
                                    (M.alloc (|
                                      BinOp.eq (|
                                        BinOp.Wrap.rem (|
                                          M.read (| v |),
                                          Value.Integer IntegerKind.U64 2
                                        |),
                                        Value.Integer IntegerKind.U64 0
                                      |)
                                    |)) in
                                let _ :=
                                  M.is_constant_or_break_match (|
                                    M.read (| γ |),
                                    Value.Bool true
                                  |) in
                                let~ _ : Ty.tuple [] :=
                                  M.alloc (|
                                    let β := v in
                                    M.write (|
                                      β,
                                      BinOp.Wrap.sub (|
                                        M.read (| β |),
                                        Value.Integer IntegerKind.U64 1
                                      |)
                                    |)
                                  |) in
                                M.alloc (| Value.Tuple [] |)));
                            fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                          ]
                        |) in
                      let~ _ : Ty.tuple [] :=
                        M.alloc (|
                          let β := v in
                          M.write (|
                            β,
                            BinOp.Wrap.sub (| M.read (| β |), Value.Integer IntegerKind.U64 35 |)
                          |)
                        |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::option::Option::Some"
                          [ BinOp.Wrap.div (| M.read (| v |), Value.Integer IntegerKind.U64 2 |) ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_chain_id :
        M.IsAssociatedFunction.C Self "chain_id" chain_id.
      Admitted.
      Global Typeclasses Opaque chain_id.
      
      (*
          pub const fn has_eip155_value(&self) -> bool {
              self.chain_id().is_some()
          }
      *)
      Definition has_eip155_value (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "bool",
              M.get_associated_function (|
                Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "u64" ],
                "is_some",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.alloc (|
                    M.call_closure (|
                      Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "u64" ],
                      M.get_associated_function (|
                        Ty.path "alloy_primitives::signature::parity::Parity",
                        "chain_id",
                        [],
                        []
                      |),
                      [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                    |)
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_has_eip155_value :
        M.IsAssociatedFunction.C Self "has_eip155_value" has_eip155_value.
      Admitted.
      Global Typeclasses Opaque has_eip155_value.
      
      (*
          pub const fn y_parity(&self) -> bool {
              match self {
                  Self::Eip155(v @ 0..=34) => *v % 2 == 1,
                  Self::Eip155(v) => ( *v ^ 1) % 2 == 1,
                  Self::NonEip155(b) | Self::Parity(b) => *b,
              }
          }
      *)
      Definition y_parity (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                Some (Ty.path "bool"),
                self,
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.read (| γ |) in
                      let γ1_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "alloy_primitives::signature::parity::Parity::Eip155",
                          0
                        |) in
                      let v := M.alloc (| γ1_0 |) in
                      M.alloc (|
                        BinOp.eq (|
                          BinOp.Wrap.rem (|
                            M.read (| M.deref (| M.read (| v |) |) |),
                            Value.Integer IntegerKind.U64 2
                          |),
                          Value.Integer IntegerKind.U64 1
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.read (| γ |) in
                      let γ1_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "alloy_primitives::signature::parity::Parity::Eip155",
                          0
                        |) in
                      let v := M.alloc (| γ1_0 |) in
                      M.alloc (|
                        BinOp.eq (|
                          BinOp.Wrap.rem (|
                            BinOp.bit_xor
                              (M.read (| M.deref (| M.read (| v |) |) |))
                              (Value.Integer IntegerKind.U64 1),
                            Value.Integer IntegerKind.U64 2
                          |),
                          Value.Integer IntegerKind.U64 1
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.find_or_pattern (|
                        γ,
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ := M.read (| γ |) in
                              let γ1_0 :=
                                M.SubPointer.get_struct_tuple_field (|
                                  γ,
                                  "alloy_primitives::signature::parity::Parity::NonEip155",
                                  0
                                |) in
                              let b := M.alloc (| γ1_0 |) in
                              Value.Tuple [ b ]));
                          fun γ =>
                            ltac:(M.monadic
                              (let γ := M.read (| γ |) in
                              let γ1_0 :=
                                M.SubPointer.get_struct_tuple_field (|
                                  γ,
                                  "alloy_primitives::signature::parity::Parity::Parity",
                                  0
                                |) in
                              let b := M.alloc (| γ1_0 |) in
                              Value.Tuple [ b ]))
                        ],
                        fun γ =>
                          ltac:(M.monadic
                            match γ with
                            | [ b ] => ltac:(M.monadic (M.deref (| M.read (| b |) |)))
                            | _ => M.impossible "wrong number of arguments"
                            end)
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_y_parity :
        M.IsAssociatedFunction.C Self "y_parity" y_parity.
      Admitted.
      Global Typeclasses Opaque y_parity.
      
      (*
          pub const fn y_parity_byte(&self) -> u8 {
              self.y_parity() as u8
          }
      *)
      Definition y_parity_byte (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.cast
              (Ty.path "u8")
              (M.call_closure (|
                Ty.path "bool",
                M.get_associated_function (|
                  Ty.path "alloy_primitives::signature::parity::Parity",
                  "y_parity",
                  [],
                  []
                |),
                [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
              |))))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_y_parity_byte :
        M.IsAssociatedFunction.C Self "y_parity_byte" y_parity_byte.
      Admitted.
      Global Typeclasses Opaque y_parity_byte.
      
      (*
          pub const fn y_parity_byte_non_eip155(&self) -> Option<u8> {
              match self {
                  Self::NonEip155(v) | Self::Parity(v) => Some( *v as u8 + 27),
                  _ => None,
              }
          }
      *)
      Definition y_parity_byte_non_eip155
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                Some (Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "u8" ]),
                self,
                [
                  fun γ =>
                    ltac:(M.monadic
                      (M.find_or_pattern (|
                        γ,
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ := M.read (| γ |) in
                              let γ1_0 :=
                                M.SubPointer.get_struct_tuple_field (|
                                  γ,
                                  "alloy_primitives::signature::parity::Parity::NonEip155",
                                  0
                                |) in
                              let v := M.alloc (| γ1_0 |) in
                              Value.Tuple [ v ]));
                          fun γ =>
                            ltac:(M.monadic
                              (let γ := M.read (| γ |) in
                              let γ1_0 :=
                                M.SubPointer.get_struct_tuple_field (|
                                  γ,
                                  "alloy_primitives::signature::parity::Parity::Parity",
                                  0
                                |) in
                              let v := M.alloc (| γ1_0 |) in
                              Value.Tuple [ v ]))
                        ],
                        fun γ =>
                          ltac:(M.monadic
                            match γ with
                            | [ v ] =>
                              ltac:(M.monadic
                                (M.alloc (|
                                  Value.StructTuple
                                    "core::option::Option::Some"
                                    [
                                      BinOp.Wrap.add (|
                                        M.cast
                                          (Ty.path "u8")
                                          (M.read (| M.deref (| M.read (| v |) |) |)),
                                        Value.Integer IntegerKind.U8 27
                                      |)
                                    ]
                                |)))
                            | _ => M.impossible "wrong number of arguments"
                            end)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_y_parity_byte_non_eip155 :
        M.IsAssociatedFunction.C Self "y_parity_byte_non_eip155" y_parity_byte_non_eip155.
      Admitted.
      Global Typeclasses Opaque y_parity_byte_non_eip155.
      
      (*
          pub const fn to_u64(&self) -> u64 {
              match self {
                  Self::Eip155(v) => *v,
                  Self::NonEip155(b) => *b as u64 + 27,
                  Self::Parity(b) => *b as u64,
              }
          }
      *)
      Definition to_u64 (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                Some (Ty.path "u64"),
                self,
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.read (| γ |) in
                      let γ1_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "alloy_primitives::signature::parity::Parity::Eip155",
                          0
                        |) in
                      let v := M.alloc (| γ1_0 |) in
                      M.deref (| M.read (| v |) |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.read (| γ |) in
                      let γ1_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "alloy_primitives::signature::parity::Parity::NonEip155",
                          0
                        |) in
                      let b := M.alloc (| γ1_0 |) in
                      M.alloc (|
                        BinOp.Wrap.add (|
                          M.cast (Ty.path "u64") (M.read (| M.deref (| M.read (| b |) |) |)),
                          Value.Integer IntegerKind.U64 27
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.read (| γ |) in
                      let γ1_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "alloy_primitives::signature::parity::Parity::Parity",
                          0
                        |) in
                      let b := M.alloc (| γ1_0 |) in
                      M.alloc (|
                        M.cast (Ty.path "u64") (M.read (| M.deref (| M.read (| b |) |) |))
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_to_u64 : M.IsAssociatedFunction.C Self "to_u64" to_u64.
      Admitted.
      Global Typeclasses Opaque to_u64.
      
      (*
          pub const fn inverted(&self) -> Self {
              match *self {
                  Self::Parity(b) => Self::Parity(!b),
                  Self::NonEip155(b) => Self::NonEip155(!b),
                  Self::Eip155(0) => Self::Eip155(1),
                  Self::Eip155(v @ 1..=34) => Self::Eip155(if v % 2 == 0 { v - 1 } else { v + 1 }),
                  Self::Eip155(v @ 35..) => Self::Eip155(v ^ 1),
              }
          }
      *)
      Definition inverted (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                Some (Ty.path "alloy_primitives::signature::parity::Parity"),
                M.deref (| M.read (| self |) |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "alloy_primitives::signature::parity::Parity::Parity",
                          0
                        |) in
                      let b := M.copy (| γ0_0 |) in
                      M.alloc (|
                        Value.StructTuple
                          "alloy_primitives::signature::parity::Parity::Parity"
                          [ UnOp.not (| M.read (| b |) |) ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "alloy_primitives::signature::parity::Parity::NonEip155",
                          0
                        |) in
                      let b := M.copy (| γ0_0 |) in
                      M.alloc (|
                        Value.StructTuple
                          "alloy_primitives::signature::parity::Parity::NonEip155"
                          [ UnOp.not (| M.read (| b |) |) ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "alloy_primitives::signature::parity::Parity::Eip155",
                          0
                        |) in
                      let _ :=
                        M.is_constant_or_break_match (|
                          M.read (| γ0_0 |),
                          Value.Integer IntegerKind.U64 0
                        |) in
                      M.alloc (|
                        Value.StructTuple
                          "alloy_primitives::signature::parity::Parity::Eip155"
                          [ Value.Integer IntegerKind.U64 1 ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "alloy_primitives::signature::parity::Parity::Eip155",
                          0
                        |) in
                      let v := M.copy (| γ0_0 |) in
                      M.alloc (|
                        Value.StructTuple
                          "alloy_primitives::signature::parity::Parity::Eip155"
                          [
                            M.read (|
                              M.match_operator (|
                                Some (Ty.path "u64"),
                                M.alloc (| Value.Tuple [] |),
                                [
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let γ :=
                                        M.use
                                          (M.alloc (|
                                            BinOp.eq (|
                                              BinOp.Wrap.rem (|
                                                M.read (| v |),
                                                Value.Integer IntegerKind.U64 2
                                              |),
                                              Value.Integer IntegerKind.U64 0
                                            |)
                                          |)) in
                                      let _ :=
                                        M.is_constant_or_break_match (|
                                          M.read (| γ |),
                                          Value.Bool true
                                        |) in
                                      M.alloc (|
                                        BinOp.Wrap.sub (|
                                          M.read (| v |),
                                          Value.Integer IntegerKind.U64 1
                                        |)
                                      |)));
                                  fun γ =>
                                    ltac:(M.monadic
                                      (M.alloc (|
                                        BinOp.Wrap.add (|
                                          M.read (| v |),
                                          Value.Integer IntegerKind.U64 1
                                        |)
                                      |)))
                                ]
                              |)
                            |)
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "alloy_primitives::signature::parity::Parity::Eip155",
                          0
                        |) in
                      let v := M.copy (| γ0_0 |) in
                      M.alloc (|
                        Value.StructTuple
                          "alloy_primitives::signature::parity::Parity::Eip155"
                          [ BinOp.bit_xor (M.read (| v |)) (Value.Integer IntegerKind.U64 1) ]
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_inverted :
        M.IsAssociatedFunction.C Self "inverted" inverted.
      Admitted.
      Global Typeclasses Opaque inverted.
      
      (*
          pub const fn strip_chain_id(&self) -> Self {
              match *self {
                  Self::Eip155(v) => Self::NonEip155(v % 2 == 1),
                  this => this,
              }
          }
      *)
      Definition strip_chain_id (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                Some (Ty.path "alloy_primitives::signature::parity::Parity"),
                M.deref (| M.read (| self |) |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "alloy_primitives::signature::parity::Parity::Eip155",
                          0
                        |) in
                      let v := M.copy (| γ0_0 |) in
                      M.alloc (|
                        Value.StructTuple
                          "alloy_primitives::signature::parity::Parity::NonEip155"
                          [
                            BinOp.eq (|
                              BinOp.Wrap.rem (| M.read (| v |), Value.Integer IntegerKind.U64 2 |),
                              Value.Integer IntegerKind.U64 1
                            |)
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let this := M.copy (| γ |) in
                      this))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_strip_chain_id :
        M.IsAssociatedFunction.C Self "strip_chain_id" strip_chain_id.
      Admitted.
      Global Typeclasses Opaque strip_chain_id.
      
      (*
          pub const fn with_chain_id(self, chain_id: ChainId) -> Self {
              let parity = match self {
                  Self::Eip155(v) => normalize_v_to_byte(v) == 1,
                  Self::NonEip155(b) | Self::Parity(b) => b,
              };
      
              Self::Eip155(to_eip155_v(parity as u8, chain_id))
          }
      *)
      Definition with_chain_id (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; chain_id ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let chain_id := M.alloc (| chain_id |) in
            M.read (|
              let~ parity : Ty.path "bool" :=
                M.copy (|
                  M.match_operator (|
                    Some (Ty.path "bool"),
                    self,
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ0_0 :=
                            M.SubPointer.get_struct_tuple_field (|
                              γ,
                              "alloy_primitives::signature::parity::Parity::Eip155",
                              0
                            |) in
                          let v := M.copy (| γ0_0 |) in
                          M.alloc (|
                            BinOp.eq (|
                              M.call_closure (|
                                Ty.path "u8",
                                M.get_function (|
                                  "alloy_primitives::signature::utils::normalize_v_to_byte",
                                  [],
                                  []
                                |),
                                [ M.read (| v |) ]
                              |),
                              Value.Integer IntegerKind.U8 1
                            |)
                          |)));
                      fun γ =>
                        ltac:(M.monadic
                          (M.find_or_pattern (|
                            γ,
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "alloy_primitives::signature::parity::Parity::NonEip155",
                                      0
                                    |) in
                                  let b := M.copy (| γ0_0 |) in
                                  Value.Tuple [ b ]));
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "alloy_primitives::signature::parity::Parity::Parity",
                                      0
                                    |) in
                                  let b := M.copy (| γ0_0 |) in
                                  Value.Tuple [ b ]))
                            ],
                            fun γ =>
                              ltac:(M.monadic
                                match γ with
                                | [ b ] => ltac:(M.monadic b)
                                | _ => M.impossible "wrong number of arguments"
                                end)
                          |)))
                    ]
                  |)
                |) in
              M.alloc (|
                Value.StructTuple
                  "alloy_primitives::signature::parity::Parity::Eip155"
                  [
                    M.call_closure (|
                      Ty.path "u64",
                      M.get_function (|
                        "alloy_primitives::signature::utils::to_eip155_v",
                        [],
                        []
                      |),
                      [ M.cast (Ty.path "u8") (M.read (| parity |)); M.read (| chain_id |) ]
                    |)
                  ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_with_chain_id :
        M.IsAssociatedFunction.C Self "with_chain_id" with_chain_id.
      Admitted.
      Global Typeclasses Opaque with_chain_id.
      
      (*
          pub const fn to_parity_bool(self) -> Self {
              Self::Parity(self.y_parity())
          }
      *)
      Definition to_parity_bool (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructTuple
              "alloy_primitives::signature::parity::Parity::Parity"
              [
                M.call_closure (|
                  Ty.path "bool",
                  M.get_associated_function (|
                    Ty.path "alloy_primitives::signature::parity::Parity",
                    "y_parity",
                    [],
                    []
                  |),
                  [ M.borrow (| Pointer.Kind.Ref, self |) ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_to_parity_bool :
        M.IsAssociatedFunction.C Self "to_parity_bool" to_parity_bool.
      Admitted.
      Global Typeclasses Opaque to_parity_bool.
    End Impl_alloy_primitives_signature_parity_Parity.
  End parity.
End signature.
