(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module signature.
  Module parity.
    (*
    Enum Parity
    {
      const_params := [];
      ty_params := [];
      variants :=
        [
          {
            name := "Eip155";
            item := StructTuple [ Ty.path "u64" ];
          };
          {
            name := "NonEip155";
            item := StructTuple [ Ty.path "bool" ];
          };
          {
            name := "Parity";
            item := StructTuple [ Ty.path "bool" ];
          }
        ];
    }
    *)
    
    Axiom IsDiscriminant_Parity_Eip155 :
      M.IsDiscriminant "alloy_primitives::signature::parity::Parity::Eip155" 0.
    Axiom IsDiscriminant_Parity_NonEip155 :
      M.IsDiscriminant "alloy_primitives::signature::parity::Parity::NonEip155" 1.
    Axiom IsDiscriminant_Parity_Parity :
      M.IsDiscriminant "alloy_primitives::signature::parity::Parity::Parity" 2.
    
    Module Impl_core_clone_Clone_for_alloy_primitives_signature_parity_Parity.
      Definition Self : Ty.t := Ty.path "alloy_primitives::signature::parity::Parity".
      
      (* Clone *)
      Definition clone (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply (Ty.path "&") [] [ Ty.path "alloy_primitives::signature::parity::Parity" ],
                self
              |) in
            M.match_operator (|
              Ty.path "alloy_primitives::signature::parity::Parity",
              Value.DeclaredButUndefined,
              [
                fun γ =>
                  ltac:(M.monadic
                    (M.match_operator (|
                      Ty.path "alloy_primitives::signature::parity::Parity",
                      Value.DeclaredButUndefined,
                      [ fun γ => ltac:(M.monadic (M.read (| M.deref (| M.read (| self |) |) |))) ]
                    |)))
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::clone::Clone"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [ ("clone", InstanceField.Method clone) ].
    End Impl_core_clone_Clone_for_alloy_primitives_signature_parity_Parity.
    
    Module Impl_core_marker_Copy_for_alloy_primitives_signature_parity_Parity.
      Definition Self : Ty.t := Ty.path "alloy_primitives::signature::parity::Parity".
      
      Axiom Implements :
        M.IsTraitInstance
          "core::marker::Copy"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [].
    End Impl_core_marker_Copy_for_alloy_primitives_signature_parity_Parity.
    
    Module Impl_core_fmt_Debug_for_alloy_primitives_signature_parity_Parity.
      Definition Self : Ty.t := Ty.path "alloy_primitives::signature::parity::Parity".
      
      (* Debug *)
      Definition fmt (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; f ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply (Ty.path "&") [] [ Ty.path "alloy_primitives::signature::parity::Parity" ],
                self
              |) in
            let f :=
              M.alloc (| Ty.apply (Ty.path "&mut") [] [ Ty.path "core::fmt::Formatter" ], f |) in
            M.match_operator (|
              Ty.apply
                (Ty.path "core::result::Result")
                []
                [ Ty.tuple []; Ty.path "core::fmt::Error" ],
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.deref (| M.read (| γ |) |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "alloy_primitives::signature::parity::Parity::Eip155",
                        0
                      |) in
                    let __self_0 :=
                      M.alloc (| Ty.apply (Ty.path "&") [] [ Ty.path "u64" ], γ1_0 |) in
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "core::result::Result")
                        []
                        [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                      M.get_associated_function (|
                        Ty.path "core::fmt::Formatter",
                        "debug_tuple_field1_finish",
                        [],
                        []
                      |),
                      [
                        M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                        M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "Eip155" |) |) |);
                        M.call_closure (|
                          Ty.apply (Ty.path "&") [] [ Ty.dyn [ ("core::fmt::Debug::Trait", []) ] ],
                          M.pointer_coercion
                            M.PointerCoercion.Unsize
                            (Ty.apply
                              (Ty.path "&")
                              []
                              [ Ty.apply (Ty.path "&") [] [ Ty.path "u64" ] ])
                            (Ty.apply
                              (Ty.path "&")
                              []
                              [ Ty.dyn [ ("core::fmt::Debug::Trait", []) ] ]),
                          [
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.deref (| M.borrow (| Pointer.Kind.Ref, __self_0 |) |)
                            |)
                          ]
                        |)
                      ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.deref (| M.read (| γ |) |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "alloy_primitives::signature::parity::Parity::NonEip155",
                        0
                      |) in
                    let __self_0 :=
                      M.alloc (| Ty.apply (Ty.path "&") [] [ Ty.path "bool" ], γ1_0 |) in
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "core::result::Result")
                        []
                        [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                      M.get_associated_function (|
                        Ty.path "core::fmt::Formatter",
                        "debug_tuple_field1_finish",
                        [],
                        []
                      |),
                      [
                        M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                        M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "NonEip155" |) |) |);
                        M.call_closure (|
                          Ty.apply (Ty.path "&") [] [ Ty.dyn [ ("core::fmt::Debug::Trait", []) ] ],
                          M.pointer_coercion
                            M.PointerCoercion.Unsize
                            (Ty.apply
                              (Ty.path "&")
                              []
                              [ Ty.apply (Ty.path "&") [] [ Ty.path "bool" ] ])
                            (Ty.apply
                              (Ty.path "&")
                              []
                              [ Ty.dyn [ ("core::fmt::Debug::Trait", []) ] ]),
                          [
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.deref (| M.borrow (| Pointer.Kind.Ref, __self_0 |) |)
                            |)
                          ]
                        |)
                      ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.deref (| M.read (| γ |) |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "alloy_primitives::signature::parity::Parity::Parity",
                        0
                      |) in
                    let __self_0 :=
                      M.alloc (| Ty.apply (Ty.path "&") [] [ Ty.path "bool" ], γ1_0 |) in
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "core::result::Result")
                        []
                        [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                      M.get_associated_function (|
                        Ty.path "core::fmt::Formatter",
                        "debug_tuple_field1_finish",
                        [],
                        []
                      |),
                      [
                        M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                        M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "Parity" |) |) |);
                        M.call_closure (|
                          Ty.apply (Ty.path "&") [] [ Ty.dyn [ ("core::fmt::Debug::Trait", []) ] ],
                          M.pointer_coercion
                            M.PointerCoercion.Unsize
                            (Ty.apply
                              (Ty.path "&")
                              []
                              [ Ty.apply (Ty.path "&") [] [ Ty.path "bool" ] ])
                            (Ty.apply
                              (Ty.path "&")
                              []
                              [ Ty.dyn [ ("core::fmt::Debug::Trait", []) ] ]),
                          [
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.deref (| M.borrow (| Pointer.Kind.Ref, __self_0 |) |)
                            |)
                          ]
                        |)
                      ]
                    |)))
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::Debug"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
    End Impl_core_fmt_Debug_for_alloy_primitives_signature_parity_Parity.
    
    Module Impl_core_hash_Hash_for_alloy_primitives_signature_parity_Parity.
      Definition Self : Ty.t := Ty.path "alloy_primitives::signature::parity::Parity".
      
      (* Hash *)
      Definition hash (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [ __H ], [ self; state ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply (Ty.path "&") [] [ Ty.path "alloy_primitives::signature::parity::Parity" ],
                self
              |) in
            let state := M.alloc (| Ty.apply (Ty.path "&mut") [] [ __H ], state |) in
            M.read (|
              let~ __self_discr : Ty.path "isize" :=
                M.call_closure (|
                  Ty.path "isize",
                  M.get_function (|
                    "core::intrinsics::discriminant_value",
                    [],
                    [ Ty.path "alloy_primitives::signature::parity::Parity" ]
                  |),
                  [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                |) in
              let~ _ : Ty.tuple [] :=
                M.call_closure (|
                  Ty.tuple [],
                  M.get_trait_method (|
                    "core::hash::Hash",
                    Ty.path "isize",
                    [],
                    [],
                    "hash",
                    [],
                    [ __H ]
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (| M.borrow (| Pointer.Kind.Ref, __self_discr |) |)
                    |);
                    M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                  ]
                |) in
              M.alloc (|
                Ty.tuple [],
                M.match_operator (|
                  Ty.tuple [],
                  self,
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.deref (| M.read (| γ |) |) in
                        let γ1_0 :=
                          M.SubPointer.get_struct_tuple_field (|
                            γ,
                            "alloy_primitives::signature::parity::Parity::Eip155",
                            0
                          |) in
                        let __self_0 :=
                          M.alloc (| Ty.apply (Ty.path "&") [] [ Ty.path "u64" ], γ1_0 |) in
                        M.call_closure (|
                          Ty.tuple [],
                          M.get_trait_method (|
                            "core::hash::Hash",
                            Ty.path "u64",
                            [],
                            [],
                            "hash",
                            [],
                            [ __H ]
                          |),
                          [
                            M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_0 |) |) |);
                            M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                          ]
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.deref (| M.read (| γ |) |) in
                        let γ1_0 :=
                          M.SubPointer.get_struct_tuple_field (|
                            γ,
                            "alloy_primitives::signature::parity::Parity::NonEip155",
                            0
                          |) in
                        let __self_0 :=
                          M.alloc (| Ty.apply (Ty.path "&") [] [ Ty.path "bool" ], γ1_0 |) in
                        M.call_closure (|
                          Ty.tuple [],
                          M.get_trait_method (|
                            "core::hash::Hash",
                            Ty.path "bool",
                            [],
                            [],
                            "hash",
                            [],
                            [ __H ]
                          |),
                          [
                            M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_0 |) |) |);
                            M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                          ]
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.deref (| M.read (| γ |) |) in
                        let γ1_0 :=
                          M.SubPointer.get_struct_tuple_field (|
                            γ,
                            "alloy_primitives::signature::parity::Parity::Parity",
                            0
                          |) in
                        let __self_0 :=
                          M.alloc (| Ty.apply (Ty.path "&") [] [ Ty.path "bool" ], γ1_0 |) in
                        M.call_closure (|
                          Ty.tuple [],
                          M.get_trait_method (|
                            "core::hash::Hash",
                            Ty.path "bool",
                            [],
                            [],
                            "hash",
                            [],
                            [ __H ]
                          |),
                          [
                            M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_0 |) |) |);
                            M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                          ]
                        |)))
                  ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::hash::Hash"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [ ("hash", InstanceField.Method hash) ].
    End Impl_core_hash_Hash_for_alloy_primitives_signature_parity_Parity.
    
    Module Impl_core_marker_StructuralPartialEq_for_alloy_primitives_signature_parity_Parity.
      Definition Self : Ty.t := Ty.path "alloy_primitives::signature::parity::Parity".
      
      Axiom Implements :
        M.IsTraitInstance
          "core::marker::StructuralPartialEq"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [].
    End Impl_core_marker_StructuralPartialEq_for_alloy_primitives_signature_parity_Parity.
    
    Module Impl_core_cmp_PartialEq_alloy_primitives_signature_parity_Parity_for_alloy_primitives_signature_parity_Parity.
      Definition Self : Ty.t := Ty.path "alloy_primitives::signature::parity::Parity".
      
      (* PartialEq *)
      Definition eq (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply (Ty.path "&") [] [ Ty.path "alloy_primitives::signature::parity::Parity" ],
                self
              |) in
            let other :=
              M.alloc (|
                Ty.apply (Ty.path "&") [] [ Ty.path "alloy_primitives::signature::parity::Parity" ],
                other
              |) in
            M.read (|
              let~ __self_discr : Ty.path "isize" :=
                M.call_closure (|
                  Ty.path "isize",
                  M.get_function (|
                    "core::intrinsics::discriminant_value",
                    [],
                    [ Ty.path "alloy_primitives::signature::parity::Parity" ]
                  |),
                  [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                |) in
              let~ __arg1_discr : Ty.path "isize" :=
                M.call_closure (|
                  Ty.path "isize",
                  M.get_function (|
                    "core::intrinsics::discriminant_value",
                    [],
                    [ Ty.path "alloy_primitives::signature::parity::Parity" ]
                  |),
                  [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| other |) |) |) ]
                |) in
              M.alloc (|
                Ty.path "bool",
                LogicalOp.and (|
                  M.call_closure (|
                    Ty.path "bool",
                    BinOp.eq,
                    [ M.read (| __self_discr |); M.read (| __arg1_discr |) ]
                  |),
                  ltac:(M.monadic
                    (M.match_operator (|
                      Ty.path "bool",
                      M.alloc (|
                        Ty.tuple
                          [
                            Ty.apply
                              (Ty.path "&")
                              []
                              [ Ty.path "alloy_primitives::signature::parity::Parity" ];
                            Ty.apply
                              (Ty.path "&")
                              []
                              [ Ty.path "alloy_primitives::signature::parity::Parity" ]
                          ],
                        Value.Tuple [ M.read (| self |); M.read (| other |) ]
                      |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                            let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                            let γ0_0 := M.deref (| M.read (| γ0_0 |) |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ0_0,
                                "alloy_primitives::signature::parity::Parity::Eip155",
                                0
                              |) in
                            let __self_0 :=
                              M.alloc (| Ty.apply (Ty.path "&") [] [ Ty.path "u64" ], γ2_0 |) in
                            let γ0_1 := M.deref (| M.read (| γ0_1 |) |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ0_1,
                                "alloy_primitives::signature::parity::Parity::Eip155",
                                0
                              |) in
                            let __arg1_0 :=
                              M.alloc (| Ty.apply (Ty.path "&") [] [ Ty.path "u64" ], γ2_0 |) in
                            M.call_closure (|
                              Ty.path "bool",
                              M.get_trait_method (|
                                "core::cmp::PartialEq",
                                Ty.apply (Ty.path "&") [] [ Ty.path "u64" ],
                                [],
                                [ Ty.apply (Ty.path "&") [] [ Ty.path "u64" ] ],
                                "eq",
                                [],
                                []
                              |),
                              [
                                M.borrow (| Pointer.Kind.Ref, __self_0 |);
                                M.borrow (| Pointer.Kind.Ref, __arg1_0 |)
                              ]
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                            let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                            let γ0_0 := M.deref (| M.read (| γ0_0 |) |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ0_0,
                                "alloy_primitives::signature::parity::Parity::NonEip155",
                                0
                              |) in
                            let __self_0 :=
                              M.alloc (| Ty.apply (Ty.path "&") [] [ Ty.path "bool" ], γ2_0 |) in
                            let γ0_1 := M.deref (| M.read (| γ0_1 |) |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ0_1,
                                "alloy_primitives::signature::parity::Parity::NonEip155",
                                0
                              |) in
                            let __arg1_0 :=
                              M.alloc (| Ty.apply (Ty.path "&") [] [ Ty.path "bool" ], γ2_0 |) in
                            M.call_closure (|
                              Ty.path "bool",
                              M.get_trait_method (|
                                "core::cmp::PartialEq",
                                Ty.apply (Ty.path "&") [] [ Ty.path "bool" ],
                                [],
                                [ Ty.apply (Ty.path "&") [] [ Ty.path "bool" ] ],
                                "eq",
                                [],
                                []
                              |),
                              [
                                M.borrow (| Pointer.Kind.Ref, __self_0 |);
                                M.borrow (| Pointer.Kind.Ref, __arg1_0 |)
                              ]
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                            let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                            let γ0_0 := M.deref (| M.read (| γ0_0 |) |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ0_0,
                                "alloy_primitives::signature::parity::Parity::Parity",
                                0
                              |) in
                            let __self_0 :=
                              M.alloc (| Ty.apply (Ty.path "&") [] [ Ty.path "bool" ], γ2_0 |) in
                            let γ0_1 := M.deref (| M.read (| γ0_1 |) |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ0_1,
                                "alloy_primitives::signature::parity::Parity::Parity",
                                0
                              |) in
                            let __arg1_0 :=
                              M.alloc (| Ty.apply (Ty.path "&") [] [ Ty.path "bool" ], γ2_0 |) in
                            M.call_closure (|
                              Ty.path "bool",
                              M.get_trait_method (|
                                "core::cmp::PartialEq",
                                Ty.apply (Ty.path "&") [] [ Ty.path "bool" ],
                                [],
                                [ Ty.apply (Ty.path "&") [] [ Ty.path "bool" ] ],
                                "eq",
                                [],
                                []
                              |),
                              [
                                M.borrow (| Pointer.Kind.Ref, __self_0 |);
                                M.borrow (| Pointer.Kind.Ref, __arg1_0 |)
                              ]
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (M.never_to_any (|
                              M.call_closure (|
                                Ty.path "never",
                                M.get_function (| "core::intrinsics::unreachable", [], [] |),
                                []
                              |)
                            |)))
                      ]
                    |)))
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::cmp::PartialEq"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "alloy_primitives::signature::parity::Parity" ]
          Self
          (* Instance *) [ ("eq", InstanceField.Method eq) ].
    End Impl_core_cmp_PartialEq_alloy_primitives_signature_parity_Parity_for_alloy_primitives_signature_parity_Parity.
    
    Module Impl_core_cmp_Eq_for_alloy_primitives_signature_parity_Parity.
      Definition Self : Ty.t := Ty.path "alloy_primitives::signature::parity::Parity".
      
      (* Eq *)
      Definition assert_receiver_is_total_eq
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply (Ty.path "&") [] [ Ty.path "alloy_primitives::signature::parity::Parity" ],
                self
              |) in
            M.match_operator (|
              Ty.tuple [],
              Value.DeclaredButUndefined,
              [
                fun γ =>
                  ltac:(M.monadic
                    (M.match_operator (|
                      Ty.tuple [],
                      Value.DeclaredButUndefined,
                      [ fun γ => ltac:(M.monadic (Value.Tuple [])) ]
                    |)))
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::cmp::Eq"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *)
          [ ("assert_receiver_is_total_eq", InstanceField.Method assert_receiver_is_total_eq) ].
    End Impl_core_cmp_Eq_for_alloy_primitives_signature_parity_Parity.
    
    Module Impl_core_default_Default_for_alloy_primitives_signature_parity_Parity.
      Definition Self : Ty.t := Ty.path "alloy_primitives::signature::parity::Parity".
      
      (*
          fn default() -> Self {
              Self::Parity(false)
          }
      *)
      Definition default (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [] =>
          ltac:(M.monadic
            (Value.StructTuple
              "alloy_primitives::signature::parity::Parity::Parity"
              []
              []
              [ Value.Bool false ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::default::Default"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [ ("default", InstanceField.Method default) ].
    End Impl_core_default_Default_for_alloy_primitives_signature_parity_Parity.
    
    Module Impl_core_convert_TryFrom_ruint_Uint_Usize_64_Usize_1_for_alloy_primitives_signature_parity_Parity.
      Definition Self : Ty.t := Ty.path "alloy_primitives::signature::parity::Parity".
      
      (*     type Error = <Self as TryFrom<u64>>::Error; *)
      Definition _Error : Ty.t :=
        Ty.associated_in_trait
          "core::convert::TryFrom"
          []
          [ Ty.path "u64" ]
          (Ty.path "alloy_primitives::signature::parity::Parity")
          "Error".
      
      (*
          fn try_from(value: U64) -> Result<Self, Self::Error> {
              value.as_limbs()[0].try_into()
          }
      *)
      Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value :=
              M.alloc (|
                Ty.apply
                  (Ty.path "ruint::Uint")
                  [ Value.Integer IntegerKind.Usize 64; Value.Integer IntegerKind.Usize 1 ]
                  [],
                value
              |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "core::result::Result")
                []
                [
                  Ty.path "alloy_primitives::signature::parity::Parity";
                  Ty.path "alloy_primitives::signature::error::SignatureError"
                ],
              M.get_trait_method (|
                "core::convert::TryInto",
                Ty.path "u64",
                [],
                [ Ty.path "alloy_primitives::signature::parity::Parity" ],
                "try_into",
                [],
                []
              |),
              [
                M.read (|
                  M.SubPointer.get_array_field (|
                    M.deref (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "&")
                          []
                          [
                            Ty.apply
                              (Ty.path "array")
                              [ Value.Integer IntegerKind.Usize 1 ]
                              [ Ty.path "u64" ]
                          ],
                        M.get_associated_function (|
                          Ty.apply
                            (Ty.path "ruint::Uint")
                            [ Value.Integer IntegerKind.Usize 64; Value.Integer IntegerKind.Usize 1
                            ]
                            [],
                          "as_limbs",
                          [],
                          []
                        |),
                        [ M.borrow (| Pointer.Kind.Ref, value |) ]
                      |)
                    |),
                    Value.Integer IntegerKind.Usize 0
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::TryFrom"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [
            Ty.apply
              (Ty.path "ruint::Uint")
              [ Value.Integer IntegerKind.Usize 64; Value.Integer IntegerKind.Usize 1 ]
              []
          ]
          Self
          (* Instance *)
          [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
    End Impl_core_convert_TryFrom_ruint_Uint_Usize_64_Usize_1_for_alloy_primitives_signature_parity_Parity.
    
    Module Impl_core_convert_From_ruint_Uint_Usize_1_Usize_1_for_alloy_primitives_signature_parity_Parity.
      Definition Self : Ty.t := Ty.path "alloy_primitives::signature::parity::Parity".
      
      (*
          fn from(value: Uint<1, 1>) -> Self {
              Self::Parity(!value.is_zero())
          }
      *)
      Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value :=
              M.alloc (|
                Ty.apply
                  (Ty.path "ruint::Uint")
                  [ Value.Integer IntegerKind.Usize 1; Value.Integer IntegerKind.Usize 1 ]
                  [],
                value
              |) in
            Value.StructTuple
              "alloy_primitives::signature::parity::Parity::Parity"
              []
              []
              [
                UnOp.not (|
                  M.call_closure (|
                    Ty.path "bool",
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "ruint::Uint")
                        [ Value.Integer IntegerKind.Usize 1; Value.Integer IntegerKind.Usize 1 ]
                        [],
                      "is_zero",
                      [],
                      []
                    |),
                    [ M.borrow (| Pointer.Kind.Ref, value |) ]
                  |)
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [
            Ty.apply
              (Ty.path "ruint::Uint")
              [ Value.Integer IntegerKind.Usize 1; Value.Integer IntegerKind.Usize 1 ]
              []
          ]
          Self
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_ruint_Uint_Usize_1_Usize_1_for_alloy_primitives_signature_parity_Parity.
    
    Module Impl_core_convert_From_bool_for_alloy_primitives_signature_parity_Parity.
      Definition Self : Ty.t := Ty.path "alloy_primitives::signature::parity::Parity".
      
      (*
          fn from(value: bool) -> Self {
              Self::Parity(value)
          }
      *)
      Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| Ty.path "bool", value |) in
            Value.StructTuple
              "alloy_primitives::signature::parity::Parity::Parity"
              []
              []
              [ M.read (| value |) ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "bool" ]
          Self
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_bool_for_alloy_primitives_signature_parity_Parity.
    
    Module Impl_core_convert_TryFrom_u64_for_alloy_primitives_signature_parity_Parity.
      Definition Self : Ty.t := Ty.path "alloy_primitives::signature::parity::Parity".
      
      (*     type Error = SignatureError; *)
      Definition _Error : Ty.t := Ty.path "alloy_primitives::signature::error::SignatureError".
      
      (*
          fn try_from(value: u64) -> Result<Self, Self::Error> {
              match value {
                  0 | 1 => Ok(Self::Parity(value != 0)),
                  27 | 28 => Ok(Self::NonEip155((value - 27) != 0)),
                  value @ 35..=u64::MAX => Ok(Self::Eip155(value)),
                  _ => Err(SignatureError::InvalidParity(value)),
              }
          }
      *)
      Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| Ty.path "u64", value |) in
            M.match_operator (|
              Ty.apply
                (Ty.path "core::result::Result")
                []
                [
                  Ty.path "alloy_primitives::signature::parity::Parity";
                  Ty.path "alloy_primitives::signature::error::SignatureError"
                ],
              value,
              [
                fun γ =>
                  ltac:(M.monadic
                    (M.find_or_pattern (Ty.tuple []) (|
                      γ,
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let _ :=
                              is_constant_or_break_match (|
                                M.read (| γ |),
                                Value.Integer IntegerKind.U64 0
                              |) in
                            Value.Tuple []));
                        fun γ =>
                          ltac:(M.monadic
                            (let _ :=
                              is_constant_or_break_match (|
                                M.read (| γ |),
                                Value.Integer IntegerKind.U64 1
                              |) in
                            Value.Tuple []))
                      ],
                      fun γ =>
                        ltac:(M.monadic
                          match γ with
                          | [] =>
                            ltac:(M.monadic
                              (Value.StructTuple
                                "core::result::Result::Ok"
                                []
                                [
                                  Ty.path "alloy_primitives::signature::parity::Parity";
                                  Ty.path "alloy_primitives::signature::error::SignatureError"
                                ]
                                [
                                  Value.StructTuple
                                    "alloy_primitives::signature::parity::Parity::Parity"
                                    []
                                    []
                                    [
                                      M.call_closure (|
                                        Ty.path "bool",
                                        BinOp.ne,
                                        [ M.read (| value |); Value.Integer IntegerKind.U64 0 ]
                                      |)
                                    ]
                                ]))
                          | _ => M.impossible "wrong number of arguments"
                          end)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.find_or_pattern (Ty.tuple []) (|
                      γ,
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let _ :=
                              is_constant_or_break_match (|
                                M.read (| γ |),
                                Value.Integer IntegerKind.U64 27
                              |) in
                            Value.Tuple []));
                        fun γ =>
                          ltac:(M.monadic
                            (let _ :=
                              is_constant_or_break_match (|
                                M.read (| γ |),
                                Value.Integer IntegerKind.U64 28
                              |) in
                            Value.Tuple []))
                      ],
                      fun γ =>
                        ltac:(M.monadic
                          match γ with
                          | [] =>
                            ltac:(M.monadic
                              (Value.StructTuple
                                "core::result::Result::Ok"
                                []
                                [
                                  Ty.path "alloy_primitives::signature::parity::Parity";
                                  Ty.path "alloy_primitives::signature::error::SignatureError"
                                ]
                                [
                                  Value.StructTuple
                                    "alloy_primitives::signature::parity::Parity::NonEip155"
                                    []
                                    []
                                    [
                                      M.call_closure (|
                                        Ty.path "bool",
                                        BinOp.ne,
                                        [
                                          M.call_closure (|
                                            Ty.path "u64",
                                            BinOp.Wrap.sub,
                                            [ M.read (| value |); Value.Integer IntegerKind.U64 27 ]
                                          |);
                                          Value.Integer IntegerKind.U64 0
                                        ]
                                      |)
                                    ]
                                ]))
                          | _ => M.impossible "wrong number of arguments"
                          end)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let value := M.copy (| Ty.path "u64", γ |) in
                    Value.StructTuple
                      "core::result::Result::Ok"
                      []
                      [
                        Ty.path "alloy_primitives::signature::parity::Parity";
                        Ty.path "alloy_primitives::signature::error::SignatureError"
                      ]
                      [
                        Value.StructTuple
                          "alloy_primitives::signature::parity::Parity::Eip155"
                          []
                          []
                          [ M.read (| value |) ]
                      ]));
                fun γ =>
                  ltac:(M.monadic
                    (Value.StructTuple
                      "core::result::Result::Err"
                      []
                      [
                        Ty.path "alloy_primitives::signature::parity::Parity";
                        Ty.path "alloy_primitives::signature::error::SignatureError"
                      ]
                      [
                        Value.StructTuple
                          "alloy_primitives::signature::error::SignatureError::InvalidParity"
                          []
                          []
                          [ M.read (| value |) ]
                      ]))
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::TryFrom"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u64" ]
          Self
          (* Instance *)
          [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
    End Impl_core_convert_TryFrom_u64_for_alloy_primitives_signature_parity_Parity.
    
    Module Impl_alloy_primitives_signature_parity_Parity.
      Definition Self : Ty.t := Ty.path "alloy_primitives::signature::parity::Parity".
      
      (*
          pub const fn chain_id(&self) -> Option<ChainId> {
              match *self {
                  Self::Eip155(mut v @ 35..) => {
                      if v % 2 == 0 {
                          v -= 1;
                      }
                      v -= 35;
                      Some(v / 2)
                  }
                  _ => None,
              }
          }
      *)
      Definition chain_id (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply (Ty.path "&") [] [ Ty.path "alloy_primitives::signature::parity::Parity" ],
                self
              |) in
            M.match_operator (|
              Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "u64" ],
              M.deref (| M.read (| self |) |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "alloy_primitives::signature::parity::Parity::Eip155",
                        0
                      |) in
                    let v := M.copy (| Ty.path "u64", γ0_0 |) in
                    M.read (|
                      let~ _ : Ty.tuple [] :=
                        M.match_operator (|
                          Ty.tuple [],
                          M.alloc (| Ty.tuple [], Value.Tuple [] |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ :=
                                  M.use
                                    (M.alloc (|
                                      Ty.path "bool",
                                      M.call_closure (|
                                        Ty.path "bool",
                                        BinOp.eq,
                                        [
                                          M.call_closure (|
                                            Ty.path "u64",
                                            BinOp.Wrap.rem,
                                            [ M.read (| v |); Value.Integer IntegerKind.U64 2 ]
                                          |);
                                          Value.Integer IntegerKind.U64 0
                                        ]
                                      |)
                                    |)) in
                                let _ :=
                                  is_constant_or_break_match (|
                                    M.read (| γ |),
                                    Value.Bool true
                                  |) in
                                M.read (|
                                  let~ _ : Ty.tuple [] :=
                                    let β := v in
                                    M.write (|
                                      β,
                                      M.call_closure (|
                                        Ty.path "u64",
                                        BinOp.Wrap.sub,
                                        [ M.read (| β |); Value.Integer IntegerKind.U64 1 ]
                                      |)
                                    |) in
                                  M.alloc (| Ty.tuple [], Value.Tuple [] |)
                                |)));
                            fun γ => ltac:(M.monadic (Value.Tuple []))
                          ]
                        |) in
                      let~ _ : Ty.tuple [] :=
                        let β := v in
                        M.write (|
                          β,
                          M.call_closure (|
                            Ty.path "u64",
                            BinOp.Wrap.sub,
                            [ M.read (| β |); Value.Integer IntegerKind.U64 35 ]
                          |)
                        |) in
                      M.alloc (|
                        Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "u64" ],
                        Value.StructTuple
                          "core::option::Option::Some"
                          []
                          [ Ty.path "u64" ]
                          [
                            M.call_closure (|
                              Ty.path "u64",
                              BinOp.Wrap.div,
                              [ M.read (| v |); Value.Integer IntegerKind.U64 2 ]
                            |)
                          ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (Value.StructTuple "core::option::Option::None" [] [ Ty.path "u64" ] []))
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_chain_id :
        M.IsAssociatedFunction.C Self "chain_id" chain_id.
      Admitted.
      Global Typeclasses Opaque chain_id.
      
      (*
          pub const fn has_eip155_value(&self) -> bool {
              self.chain_id().is_some()
          }
      *)
      Definition has_eip155_value (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply (Ty.path "&") [] [ Ty.path "alloy_primitives::signature::parity::Parity" ],
                self
              |) in
            M.call_closure (|
              Ty.path "bool",
              M.get_associated_function (|
                Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "u64" ],
                "is_some",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.alloc (|
                    Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "u64" ],
                    M.call_closure (|
                      Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "u64" ],
                      M.get_associated_function (|
                        Ty.path "alloy_primitives::signature::parity::Parity",
                        "chain_id",
                        [],
                        []
                      |),
                      [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                    |)
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_has_eip155_value :
        M.IsAssociatedFunction.C Self "has_eip155_value" has_eip155_value.
      Admitted.
      Global Typeclasses Opaque has_eip155_value.
      
      (*
          pub const fn y_parity(&self) -> bool {
              match self {
                  Self::Eip155(v @ 0..=34) => *v % 2 == 1,
                  Self::Eip155(v) => ( *v ^ 1) % 2 == 1,
                  Self::NonEip155(b) | Self::Parity(b) => *b,
              }
          }
      *)
      Definition y_parity (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply (Ty.path "&") [] [ Ty.path "alloy_primitives::signature::parity::Parity" ],
                self
              |) in
            M.match_operator (|
              Ty.path "bool",
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.deref (| M.read (| γ |) |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "alloy_primitives::signature::parity::Parity::Eip155",
                        0
                      |) in
                    let v := M.alloc (| Ty.apply (Ty.path "&") [] [ Ty.path "u64" ], γ1_0 |) in
                    M.call_closure (|
                      Ty.path "bool",
                      BinOp.eq,
                      [
                        M.call_closure (|
                          Ty.path "u64",
                          BinOp.Wrap.rem,
                          [
                            M.read (| M.deref (| M.read (| v |) |) |);
                            Value.Integer IntegerKind.U64 2
                          ]
                        |);
                        Value.Integer IntegerKind.U64 1
                      ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.deref (| M.read (| γ |) |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "alloy_primitives::signature::parity::Parity::Eip155",
                        0
                      |) in
                    let v := M.alloc (| Ty.apply (Ty.path "&") [] [ Ty.path "u64" ], γ1_0 |) in
                    M.call_closure (|
                      Ty.path "bool",
                      BinOp.eq,
                      [
                        M.call_closure (|
                          Ty.path "u64",
                          BinOp.Wrap.rem,
                          [
                            M.call_closure (|
                              Ty.path "u64",
                              BinOp.Wrap.bit_xor,
                              [
                                M.read (| M.deref (| M.read (| v |) |) |);
                                Value.Integer IntegerKind.U64 1
                              ]
                            |);
                            Value.Integer IntegerKind.U64 2
                          ]
                        |);
                        Value.Integer IntegerKind.U64 1
                      ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.find_or_pattern
                      (Ty.tuple [ Ty.apply (Ty.path "&") [] [ Ty.path "bool" ] ]) (|
                      γ,
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ := M.deref (| M.read (| γ |) |) in
                            let γ1_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "alloy_primitives::signature::parity::Parity::NonEip155",
                                0
                              |) in
                            let b :=
                              M.alloc (| Ty.apply (Ty.path "&") [] [ Ty.path "bool" ], γ1_0 |) in
                            Value.Tuple [ b ]));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ := M.deref (| M.read (| γ |) |) in
                            let γ1_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "alloy_primitives::signature::parity::Parity::Parity",
                                0
                              |) in
                            let b :=
                              M.alloc (| Ty.apply (Ty.path "&") [] [ Ty.path "bool" ], γ1_0 |) in
                            Value.Tuple [ b ]))
                      ],
                      fun γ =>
                        ltac:(M.monadic
                          match γ with
                          | [ b ] => ltac:(M.monadic (M.read (| M.deref (| M.read (| b |) |) |)))
                          | _ => M.impossible "wrong number of arguments"
                          end)
                    |)))
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_y_parity :
        M.IsAssociatedFunction.C Self "y_parity" y_parity.
      Admitted.
      Global Typeclasses Opaque y_parity.
      
      (*
          pub const fn y_parity_byte(&self) -> u8 {
              self.y_parity() as u8
          }
      *)
      Definition y_parity_byte (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply (Ty.path "&") [] [ Ty.path "alloy_primitives::signature::parity::Parity" ],
                self
              |) in
            M.cast
              (Ty.path "u8")
              (M.call_closure (|
                Ty.path "bool",
                M.get_associated_function (|
                  Ty.path "alloy_primitives::signature::parity::Parity",
                  "y_parity",
                  [],
                  []
                |),
                [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
              |))))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_y_parity_byte :
        M.IsAssociatedFunction.C Self "y_parity_byte" y_parity_byte.
      Admitted.
      Global Typeclasses Opaque y_parity_byte.
      
      (*
          pub const fn y_parity_byte_non_eip155(&self) -> Option<u8> {
              match self {
                  Self::NonEip155(v) | Self::Parity(v) => Some( *v as u8 + 27),
                  _ => None,
              }
          }
      *)
      Definition y_parity_byte_non_eip155
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply (Ty.path "&") [] [ Ty.path "alloy_primitives::signature::parity::Parity" ],
                self
              |) in
            M.match_operator (|
              Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "u8" ],
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (M.find_or_pattern
                      (Ty.tuple [ Ty.apply (Ty.path "&") [] [ Ty.path "bool" ] ]) (|
                      γ,
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ := M.deref (| M.read (| γ |) |) in
                            let γ1_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "alloy_primitives::signature::parity::Parity::NonEip155",
                                0
                              |) in
                            let v :=
                              M.alloc (| Ty.apply (Ty.path "&") [] [ Ty.path "bool" ], γ1_0 |) in
                            Value.Tuple [ v ]));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ := M.deref (| M.read (| γ |) |) in
                            let γ1_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "alloy_primitives::signature::parity::Parity::Parity",
                                0
                              |) in
                            let v :=
                              M.alloc (| Ty.apply (Ty.path "&") [] [ Ty.path "bool" ], γ1_0 |) in
                            Value.Tuple [ v ]))
                      ],
                      fun γ =>
                        ltac:(M.monadic
                          match γ with
                          | [ v ] =>
                            ltac:(M.monadic
                              (Value.StructTuple
                                "core::option::Option::Some"
                                []
                                [ Ty.path "u8" ]
                                [
                                  M.call_closure (|
                                    Ty.path "u8",
                                    BinOp.Wrap.add,
                                    [
                                      M.cast
                                        (Ty.path "u8")
                                        (M.read (| M.deref (| M.read (| v |) |) |));
                                      Value.Integer IntegerKind.U8 27
                                    ]
                                  |)
                                ]))
                          | _ => M.impossible "wrong number of arguments"
                          end)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (Value.StructTuple "core::option::Option::None" [] [ Ty.path "u8" ] []))
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_y_parity_byte_non_eip155 :
        M.IsAssociatedFunction.C Self "y_parity_byte_non_eip155" y_parity_byte_non_eip155.
      Admitted.
      Global Typeclasses Opaque y_parity_byte_non_eip155.
      
      (*
          pub const fn to_u64(&self) -> u64 {
              match self {
                  Self::Eip155(v) => *v,
                  Self::NonEip155(b) => *b as u64 + 27,
                  Self::Parity(b) => *b as u64,
              }
          }
      *)
      Definition to_u64 (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply (Ty.path "&") [] [ Ty.path "alloy_primitives::signature::parity::Parity" ],
                self
              |) in
            M.match_operator (|
              Ty.path "u64",
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.deref (| M.read (| γ |) |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "alloy_primitives::signature::parity::Parity::Eip155",
                        0
                      |) in
                    let v := M.alloc (| Ty.apply (Ty.path "&") [] [ Ty.path "u64" ], γ1_0 |) in
                    M.read (| M.deref (| M.read (| v |) |) |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.deref (| M.read (| γ |) |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "alloy_primitives::signature::parity::Parity::NonEip155",
                        0
                      |) in
                    let b := M.alloc (| Ty.apply (Ty.path "&") [] [ Ty.path "bool" ], γ1_0 |) in
                    M.call_closure (|
                      Ty.path "u64",
                      BinOp.Wrap.add,
                      [
                        M.cast (Ty.path "u64") (M.read (| M.deref (| M.read (| b |) |) |));
                        Value.Integer IntegerKind.U64 27
                      ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.deref (| M.read (| γ |) |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "alloy_primitives::signature::parity::Parity::Parity",
                        0
                      |) in
                    let b := M.alloc (| Ty.apply (Ty.path "&") [] [ Ty.path "bool" ], γ1_0 |) in
                    M.cast (Ty.path "u64") (M.read (| M.deref (| M.read (| b |) |) |))))
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_to_u64 : M.IsAssociatedFunction.C Self "to_u64" to_u64.
      Admitted.
      Global Typeclasses Opaque to_u64.
      
      (*
          pub const fn inverted(&self) -> Self {
              match *self {
                  Self::Parity(b) => Self::Parity(!b),
                  Self::NonEip155(b) => Self::NonEip155(!b),
                  Self::Eip155(0) => Self::Eip155(1),
                  Self::Eip155(v @ 1..=34) => Self::Eip155(if v % 2 == 0 { v - 1 } else { v + 1 }),
                  Self::Eip155(v @ 35..) => Self::Eip155(v ^ 1),
              }
          }
      *)
      Definition inverted (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply (Ty.path "&") [] [ Ty.path "alloy_primitives::signature::parity::Parity" ],
                self
              |) in
            M.match_operator (|
              Ty.path "alloy_primitives::signature::parity::Parity",
              M.deref (| M.read (| self |) |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "alloy_primitives::signature::parity::Parity::Parity",
                        0
                      |) in
                    let b := M.copy (| Ty.path "bool", γ0_0 |) in
                    Value.StructTuple
                      "alloy_primitives::signature::parity::Parity::Parity"
                      []
                      []
                      [ UnOp.not (| M.read (| b |) |) ]));
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "alloy_primitives::signature::parity::Parity::NonEip155",
                        0
                      |) in
                    let b := M.copy (| Ty.path "bool", γ0_0 |) in
                    Value.StructTuple
                      "alloy_primitives::signature::parity::Parity::NonEip155"
                      []
                      []
                      [ UnOp.not (| M.read (| b |) |) ]));
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "alloy_primitives::signature::parity::Parity::Eip155",
                        0
                      |) in
                    let _ :=
                      is_constant_or_break_match (|
                        M.read (| γ0_0 |),
                        Value.Integer IntegerKind.U64 0
                      |) in
                    Value.StructTuple
                      "alloy_primitives::signature::parity::Parity::Eip155"
                      []
                      []
                      [ Value.Integer IntegerKind.U64 1 ]));
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "alloy_primitives::signature::parity::Parity::Eip155",
                        0
                      |) in
                    let v := M.copy (| Ty.path "u64", γ0_0 |) in
                    Value.StructTuple
                      "alloy_primitives::signature::parity::Parity::Eip155"
                      []
                      []
                      [
                        M.match_operator (|
                          Ty.path "u64",
                          M.alloc (| Ty.tuple [], Value.Tuple [] |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ :=
                                  M.use
                                    (M.alloc (|
                                      Ty.path "bool",
                                      M.call_closure (|
                                        Ty.path "bool",
                                        BinOp.eq,
                                        [
                                          M.call_closure (|
                                            Ty.path "u64",
                                            BinOp.Wrap.rem,
                                            [ M.read (| v |); Value.Integer IntegerKind.U64 2 ]
                                          |);
                                          Value.Integer IntegerKind.U64 0
                                        ]
                                      |)
                                    |)) in
                                let _ :=
                                  is_constant_or_break_match (|
                                    M.read (| γ |),
                                    Value.Bool true
                                  |) in
                                M.call_closure (|
                                  Ty.path "u64",
                                  BinOp.Wrap.sub,
                                  [ M.read (| v |); Value.Integer IntegerKind.U64 1 ]
                                |)));
                            fun γ =>
                              ltac:(M.monadic
                                (M.call_closure (|
                                  Ty.path "u64",
                                  BinOp.Wrap.add,
                                  [ M.read (| v |); Value.Integer IntegerKind.U64 1 ]
                                |)))
                          ]
                        |)
                      ]));
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "alloy_primitives::signature::parity::Parity::Eip155",
                        0
                      |) in
                    let v := M.copy (| Ty.path "u64", γ0_0 |) in
                    Value.StructTuple
                      "alloy_primitives::signature::parity::Parity::Eip155"
                      []
                      []
                      [
                        M.call_closure (|
                          Ty.path "u64",
                          BinOp.Wrap.bit_xor,
                          [ M.read (| v |); Value.Integer IntegerKind.U64 1 ]
                        |)
                      ]))
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_inverted :
        M.IsAssociatedFunction.C Self "inverted" inverted.
      Admitted.
      Global Typeclasses Opaque inverted.
      
      (*
          pub const fn strip_chain_id(&self) -> Self {
              match *self {
                  Self::Eip155(v) => Self::NonEip155(v % 2 == 1),
                  this => this,
              }
          }
      *)
      Definition strip_chain_id (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply (Ty.path "&") [] [ Ty.path "alloy_primitives::signature::parity::Parity" ],
                self
              |) in
            M.match_operator (|
              Ty.path "alloy_primitives::signature::parity::Parity",
              M.deref (| M.read (| self |) |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "alloy_primitives::signature::parity::Parity::Eip155",
                        0
                      |) in
                    let v := M.copy (| Ty.path "u64", γ0_0 |) in
                    Value.StructTuple
                      "alloy_primitives::signature::parity::Parity::NonEip155"
                      []
                      []
                      [
                        M.call_closure (|
                          Ty.path "bool",
                          BinOp.eq,
                          [
                            M.call_closure (|
                              Ty.path "u64",
                              BinOp.Wrap.rem,
                              [ M.read (| v |); Value.Integer IntegerKind.U64 2 ]
                            |);
                            Value.Integer IntegerKind.U64 1
                          ]
                        |)
                      ]));
                fun γ =>
                  ltac:(M.monadic
                    (let this :=
                      M.copy (| Ty.path "alloy_primitives::signature::parity::Parity", γ |) in
                    M.read (| this |)))
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_strip_chain_id :
        M.IsAssociatedFunction.C Self "strip_chain_id" strip_chain_id.
      Admitted.
      Global Typeclasses Opaque strip_chain_id.
      
      (*
          pub const fn with_chain_id(self, chain_id: ChainId) -> Self {
              let parity = match self {
                  Self::Eip155(v) => normalize_v_to_byte(v) == 1,
                  Self::NonEip155(b) | Self::Parity(b) => b,
              };
      
              Self::Eip155(to_eip155_v(parity as u8, chain_id))
          }
      *)
      Definition with_chain_id (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; chain_id ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (| Ty.path "alloy_primitives::signature::parity::Parity", self |) in
            let chain_id := M.alloc (| Ty.path "u64", chain_id |) in
            M.read (|
              let~ parity : Ty.path "bool" :=
                M.match_operator (|
                  Ty.path "bool",
                  self,
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ0_0 :=
                          M.SubPointer.get_struct_tuple_field (|
                            γ,
                            "alloy_primitives::signature::parity::Parity::Eip155",
                            0
                          |) in
                        let v := M.copy (| Ty.path "u64", γ0_0 |) in
                        M.call_closure (|
                          Ty.path "bool",
                          BinOp.eq,
                          [
                            M.call_closure (|
                              Ty.path "u8",
                              M.get_function (|
                                "alloy_primitives::signature::utils::normalize_v_to_byte",
                                [],
                                []
                              |),
                              [ M.read (| v |) ]
                            |);
                            Value.Integer IntegerKind.U8 1
                          ]
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (M.find_or_pattern (Ty.tuple [ Ty.path "bool" ]) (|
                          γ,
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ0_0 :=
                                  M.SubPointer.get_struct_tuple_field (|
                                    γ,
                                    "alloy_primitives::signature::parity::Parity::NonEip155",
                                    0
                                  |) in
                                let b := M.copy (| Ty.path "bool", γ0_0 |) in
                                Value.Tuple [ b ]));
                            fun γ =>
                              ltac:(M.monadic
                                (let γ0_0 :=
                                  M.SubPointer.get_struct_tuple_field (|
                                    γ,
                                    "alloy_primitives::signature::parity::Parity::Parity",
                                    0
                                  |) in
                                let b := M.copy (| Ty.path "bool", γ0_0 |) in
                                Value.Tuple [ b ]))
                          ],
                          fun γ =>
                            ltac:(M.monadic
                              match γ with
                              | [ b ] => ltac:(M.monadic (M.read (| b |)))
                              | _ => M.impossible "wrong number of arguments"
                              end)
                        |)))
                  ]
                |) in
              M.alloc (|
                Ty.path "alloy_primitives::signature::parity::Parity",
                Value.StructTuple
                  "alloy_primitives::signature::parity::Parity::Eip155"
                  []
                  []
                  [
                    M.call_closure (|
                      Ty.path "u64",
                      M.get_function (|
                        "alloy_primitives::signature::utils::to_eip155_v",
                        [],
                        []
                      |),
                      [ M.cast (Ty.path "u8") (M.read (| parity |)); M.read (| chain_id |) ]
                    |)
                  ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_with_chain_id :
        M.IsAssociatedFunction.C Self "with_chain_id" with_chain_id.
      Admitted.
      Global Typeclasses Opaque with_chain_id.
      
      (*
          pub const fn to_parity_bool(self) -> Self {
              Self::Parity(self.y_parity())
          }
      *)
      Definition to_parity_bool (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (| Ty.path "alloy_primitives::signature::parity::Parity", self |) in
            Value.StructTuple
              "alloy_primitives::signature::parity::Parity::Parity"
              []
              []
              [
                M.call_closure (|
                  Ty.path "bool",
                  M.get_associated_function (|
                    Ty.path "alloy_primitives::signature::parity::Parity",
                    "y_parity",
                    [],
                    []
                  |),
                  [ M.borrow (| Pointer.Kind.Ref, self |) ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_to_parity_bool :
        M.IsAssociatedFunction.C Self "to_parity_bool" to_parity_bool.
      Admitted.
      Global Typeclasses Opaque to_parity_bool.
    End Impl_alloy_primitives_signature_parity_Parity.
  End parity.
End signature.
