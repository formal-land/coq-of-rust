(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module signature.
  Module utils.
    (*
    pub const fn to_eip155_v(v: u8, chain_id: ChainId) -> ChainId {
        (v as u64) + 35 + chain_id * 2
    }
    *)
    Definition to_eip155_v (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ v; chain_id ] =>
        ltac:(M.monadic
          (let v := M.alloc (| v |) in
          let chain_id := M.alloc (| chain_id |) in
          M.call_closure (|
            Ty.path "u64",
            BinOp.Wrap.add,
            [
              M.call_closure (|
                Ty.path "u64",
                BinOp.Wrap.add,
                [ M.cast (Ty.path "u64") (M.read (| v |)); Value.Integer IntegerKind.U64 35 ]
              |);
              M.call_closure (|
                Ty.path "u64",
                BinOp.Wrap.mul,
                [ M.read (| chain_id |); Value.Integer IntegerKind.U64 2 ]
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance Instance_IsFunction_to_eip155_v :
      M.IsFunction.C "alloy_primitives::signature::utils::to_eip155_v" to_eip155_v.
    Admitted.
    Global Typeclasses Opaque to_eip155_v.
    
    (*
    pub const fn normalize_v(v: u64) -> Option<bool> {
        if !is_valid_v(v) {
            return None;
        }
    
        // Simplifying:
        //  0| 1 => v % 2 == 0
        // 27|28 => (v - 27) % 2 == 0
        //  35.. => (v - 35) % 2 == 0
        // ---
        //  0| 1 => v % 2 == 0
        // 27|28 => v % 2 == 1
        //  35.. => v % 2 == 1
        // ---
        //   ..2 => v % 2 == 0
        //     _ => v % 2 == 1
        let cmp = (v <= 1) as u64;
        Some(v % 2 == cmp)
    }
    *)
    Definition normalize_v (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ v ] =>
        ltac:(M.monadic
          (let v := M.alloc (| v |) in
          M.catch_return (Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "bool" ]) (|
            ltac:(M.monadic
              (M.read (|
                let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                  M.match_operator (|
                    Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                UnOp.not (|
                                  M.call_closure (|
                                    Ty.path "bool",
                                    M.get_function (|
                                      "alloy_primitives::signature::utils::is_valid_v",
                                      [],
                                      []
                                    |),
                                    [ M.read (| v |) ]
                                  |)
                                |)
                              |)) in
                          let _ :=
                            is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (|
                            M.never_to_any (|
                              M.read (|
                                M.return_ (| Value.StructTuple "core::option::Option::None" [] |)
                              |)
                            |)
                          |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                let~ cmp : Ty.apply (Ty.path "*") [] [ Ty.path "u64" ] :=
                  M.alloc (|
                    M.cast
                      (Ty.path "u64")
                      (M.call_closure (|
                        Ty.path "bool",
                        BinOp.le,
                        [ M.read (| v |); Value.Integer IntegerKind.U64 1 ]
                      |))
                  |) in
                M.alloc (|
                  Value.StructTuple
                    "core::option::Option::Some"
                    [
                      M.call_closure (|
                        Ty.path "bool",
                        BinOp.eq,
                        [
                          M.call_closure (|
                            Ty.path "u64",
                            BinOp.Wrap.rem,
                            [ M.read (| v |); Value.Integer IntegerKind.U64 2 ]
                          |);
                          M.read (| cmp |)
                        ]
                      |)
                    ]
                |)
              |)))
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance Instance_IsFunction_normalize_v :
      M.IsFunction.C "alloy_primitives::signature::utils::normalize_v" normalize_v.
    Admitted.
    Global Typeclasses Opaque normalize_v.
    
    (*
    const fn is_valid_v(v: u64) -> bool {
        matches!(
            v,
            // Case 1: raw/bare
            0 | 1
            // Case 2: non-EIP-155 v value
            | 27 | 28
            // Case 3: EIP-155 V value
            | 35..
        )
    }
    *)
    Definition is_valid_v (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ v ] =>
        ltac:(M.monadic
          (let v := M.alloc (| v |) in
          M.read (|
            M.match_operator (|
              Ty.apply (Ty.path "*") [] [ Ty.path "bool" ],
              v,
              [
                fun γ =>
                  ltac:(M.monadic
                    (M.find_or_pattern (Ty.tuple []) (|
                      γ,
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let _ :=
                              is_constant_or_break_match (|
                                M.read (| γ |),
                                Value.Integer IntegerKind.U64 0
                              |) in
                            Value.Tuple []));
                        fun γ =>
                          ltac:(M.monadic
                            (let _ :=
                              is_constant_or_break_match (|
                                M.read (| γ |),
                                Value.Integer IntegerKind.U64 1
                              |) in
                            Value.Tuple []));
                        fun γ =>
                          ltac:(M.monadic
                            (let _ :=
                              is_constant_or_break_match (|
                                M.read (| γ |),
                                Value.Integer IntegerKind.U64 27
                              |) in
                            Value.Tuple []));
                        fun γ =>
                          ltac:(M.monadic
                            (let _ :=
                              is_constant_or_break_match (|
                                M.read (| γ |),
                                Value.Integer IntegerKind.U64 28
                              |) in
                            Value.Tuple []));
                        fun γ => ltac:(M.monadic (Value.Tuple []))
                      ],
                      fun γ =>
                        ltac:(M.monadic
                          match γ with
                          | [] => ltac:(M.monadic (M.alloc (| Value.Bool true |)))
                          | _ => M.impossible "wrong number of arguments"
                          end)
                    |)));
                fun γ => ltac:(M.monadic (M.alloc (| Value.Bool false |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance Instance_IsFunction_is_valid_v :
      M.IsFunction.C "alloy_primitives::signature::utils::is_valid_v" is_valid_v.
    Admitted.
    Global Typeclasses Opaque is_valid_v.
    
    (*
    pub(crate) const fn normalize_v_to_byte(v: u64) -> u8 {
        match v {
            // Case 1: raw/bare
            0..=26 => (v % 4) as u8,
            // Case 2: non-EIP-155 v value
            27..=34 => ((v - 27) % 4) as u8,
            // Case 3: EIP-155 V value
            35.. => ((v - 1) % 2) as u8,
        }
    }
    *)
    Definition normalize_v_to_byte (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ v ] =>
        ltac:(M.monadic
          (let v := M.alloc (| v |) in
          M.read (|
            M.match_operator (|
              Ty.apply (Ty.path "*") [] [ Ty.path "u8" ],
              v,
              [
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      M.cast
                        (Ty.path "u8")
                        (M.call_closure (|
                          Ty.path "u64",
                          BinOp.Wrap.rem,
                          [ M.read (| v |); Value.Integer IntegerKind.U64 4 ]
                        |))
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      M.cast
                        (Ty.path "u8")
                        (M.call_closure (|
                          Ty.path "u64",
                          BinOp.Wrap.rem,
                          [
                            M.call_closure (|
                              Ty.path "u64",
                              BinOp.Wrap.sub,
                              [ M.read (| v |); Value.Integer IntegerKind.U64 27 ]
                            |);
                            Value.Integer IntegerKind.U64 4
                          ]
                        |))
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      M.cast
                        (Ty.path "u8")
                        (M.call_closure (|
                          Ty.path "u64",
                          BinOp.Wrap.rem,
                          [
                            M.call_closure (|
                              Ty.path "u64",
                              BinOp.Wrap.sub,
                              [ M.read (| v |); Value.Integer IntegerKind.U64 1 ]
                            |);
                            Value.Integer IntegerKind.U64 2
                          ]
                        |))
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance Instance_IsFunction_normalize_v_to_byte :
      M.IsFunction.C "alloy_primitives::signature::utils::normalize_v_to_byte" normalize_v_to_byte.
    Admitted.
    Global Typeclasses Opaque normalize_v_to_byte.
  End utils.
End signature.
