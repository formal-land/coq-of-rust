(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module signature.
  Module utils.
    (*
    pub const fn to_eip155_v(v: u8, chain_id: ChainId) -> ChainId {
        (v as u64) + 35 + chain_id * 2
    }
    *)
    Definition to_eip155_v (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ v; chain_id ] =>
        ltac:(M.monadic
          (let v := M.alloc (| Ty.path "u8", v |) in
          let chain_id := M.alloc (| Ty.path "u64", chain_id |) in
          M.call_closure (|
            Ty.path "u64",
            BinOp.Wrap.add,
            [
              M.call_closure (|
                Ty.path "u64",
                BinOp.Wrap.add,
                [ M.cast (Ty.path "u64") (M.read (| v |)); Value.Integer IntegerKind.U64 35 ]
              |);
              M.call_closure (|
                Ty.path "u64",
                BinOp.Wrap.mul,
                [ M.read (| chain_id |); Value.Integer IntegerKind.U64 2 ]
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance Instance_IsFunction_to_eip155_v :
      M.IsFunction.C "alloy_primitives::signature::utils::to_eip155_v" to_eip155_v.
    Admitted.
    Global Typeclasses Opaque to_eip155_v.
    
    (*
    pub const fn normalize_v(v: u64) -> Option<bool> {
        if !is_valid_v(v) {
            return None;
        }
    
        // Simplifying:
        //  0| 1 => v % 2 == 0
        // 27|28 => (v - 27) % 2 == 0
        //  35.. => (v - 35) % 2 == 0
        // ---
        //  0| 1 => v % 2 == 0
        // 27|28 => v % 2 == 1
        //  35.. => v % 2 == 1
        // ---
        //   ..2 => v % 2 == 0
        //     _ => v % 2 == 1
        let cmp = (v <= 1) as u64;
        Some(v % 2 == cmp)
    }
    *)
    Definition normalize_v (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ v ] =>
        ltac:(M.monadic
          (let v := M.alloc (| Ty.path "u64", v |) in
          M.catch_return (Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "bool" ]) (|
            ltac:(M.monadic
              (M.read (|
                let~ _ : Ty.tuple [] :=
                  M.match_operator (|
                    Ty.tuple [],
                    M.alloc (| Ty.tuple [], Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                Ty.path "bool",
                                UnOp.not (|
                                  M.call_closure (|
                                    Ty.path "bool",
                                    M.get_function (|
                                      "alloy_primitives::signature::utils::is_valid_v",
                                      [],
                                      []
                                    |),
                                    [ M.read (| v |) ]
                                  |)
                                |)
                              |)) in
                          let _ :=
                            is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.never_to_any (|
                            M.read (|
                              M.return_ (|
                                Value.StructTuple
                                  "core::option::Option::None"
                                  []
                                  [ Ty.path "bool" ]
                                  []
                              |)
                            |)
                          |)));
                      fun γ => ltac:(M.monadic (Value.Tuple []))
                    ]
                  |) in
                let~ cmp : Ty.path "u64" :=
                  M.cast
                    (Ty.path "u64")
                    (M.call_closure (|
                      Ty.path "bool",
                      BinOp.le,
                      [ M.read (| v |); Value.Integer IntegerKind.U64 1 ]
                    |)) in
                M.alloc (|
                  Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "bool" ],
                  Value.StructTuple
                    "core::option::Option::Some"
                    []
                    [ Ty.path "bool" ]
                    [
                      M.call_closure (|
                        Ty.path "bool",
                        BinOp.eq,
                        [
                          M.call_closure (|
                            Ty.path "u64",
                            BinOp.Wrap.rem,
                            [ M.read (| v |); Value.Integer IntegerKind.U64 2 ]
                          |);
                          M.read (| cmp |)
                        ]
                      |)
                    ]
                |)
              |)))
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance Instance_IsFunction_normalize_v :
      M.IsFunction.C "alloy_primitives::signature::utils::normalize_v" normalize_v.
    Admitted.
    Global Typeclasses Opaque normalize_v.
    
    (*
    const fn is_valid_v(v: u64) -> bool {
        matches!(
            v,
            // Case 1: raw/bare
            0 | 1
            // Case 2: non-EIP-155 v value
            | 27 | 28
            // Case 3: EIP-155 V value
            | 35..
        )
    }
    *)
    Definition is_valid_v (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ v ] =>
        ltac:(M.monadic
          (let v := M.alloc (| Ty.path "u64", v |) in
          M.match_operator (|
            Ty.path "bool",
            v,
            [
              fun γ =>
                ltac:(M.monadic
                  (M.find_or_pattern (Ty.tuple []) (|
                    γ,
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let _ :=
                            is_constant_or_break_match (|
                              M.read (| γ |),
                              Value.Integer IntegerKind.U64 0
                            |) in
                          Value.Tuple []));
                      fun γ =>
                        ltac:(M.monadic
                          (let _ :=
                            is_constant_or_break_match (|
                              M.read (| γ |),
                              Value.Integer IntegerKind.U64 1
                            |) in
                          Value.Tuple []));
                      fun γ =>
                        ltac:(M.monadic
                          (let _ :=
                            is_constant_or_break_match (|
                              M.read (| γ |),
                              Value.Integer IntegerKind.U64 27
                            |) in
                          Value.Tuple []));
                      fun γ =>
                        ltac:(M.monadic
                          (let _ :=
                            is_constant_or_break_match (|
                              M.read (| γ |),
                              Value.Integer IntegerKind.U64 28
                            |) in
                          Value.Tuple []));
                      fun γ => ltac:(M.monadic (Value.Tuple []))
                    ],
                    fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [] => ltac:(M.monadic (Value.Bool true))
                        | _ => M.impossible "wrong number of arguments"
                        end)
                  |)));
              fun γ => ltac:(M.monadic (Value.Bool false))
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance Instance_IsFunction_is_valid_v :
      M.IsFunction.C "alloy_primitives::signature::utils::is_valid_v" is_valid_v.
    Admitted.
    Global Typeclasses Opaque is_valid_v.
    
    (*
    pub(crate) const fn normalize_v_to_byte(v: u64) -> u8 {
        match v {
            // Case 1: raw/bare
            0..=26 => (v % 4) as u8,
            // Case 2: non-EIP-155 v value
            27..=34 => ((v - 27) % 4) as u8,
            // Case 3: EIP-155 V value
            35.. => ((v - 1) % 2) as u8,
        }
    }
    *)
    Definition normalize_v_to_byte (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ v ] =>
        ltac:(M.monadic
          (let v := M.alloc (| Ty.path "u64", v |) in
          M.match_operator (|
            Ty.path "u8",
            v,
            [
              fun γ =>
                ltac:(M.monadic
                  (M.cast
                    (Ty.path "u8")
                    (M.call_closure (|
                      Ty.path "u64",
                      BinOp.Wrap.rem,
                      [ M.read (| v |); Value.Integer IntegerKind.U64 4 ]
                    |))));
              fun γ =>
                ltac:(M.monadic
                  (M.cast
                    (Ty.path "u8")
                    (M.call_closure (|
                      Ty.path "u64",
                      BinOp.Wrap.rem,
                      [
                        M.call_closure (|
                          Ty.path "u64",
                          BinOp.Wrap.sub,
                          [ M.read (| v |); Value.Integer IntegerKind.U64 27 ]
                        |);
                        Value.Integer IntegerKind.U64 4
                      ]
                    |))));
              fun γ =>
                ltac:(M.monadic
                  (M.cast
                    (Ty.path "u8")
                    (M.call_closure (|
                      Ty.path "u64",
                      BinOp.Wrap.rem,
                      [
                        M.call_closure (|
                          Ty.path "u64",
                          BinOp.Wrap.sub,
                          [ M.read (| v |); Value.Integer IntegerKind.U64 1 ]
                        |);
                        Value.Integer IntegerKind.U64 2
                      ]
                    |))))
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance Instance_IsFunction_normalize_v_to_byte :
      M.IsFunction.C "alloy_primitives::signature::utils::normalize_v_to_byte" normalize_v_to_byte.
    Admitted.
    Global Typeclasses Opaque normalize_v_to_byte.
  End utils.
End signature.
